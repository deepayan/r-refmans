<!DOCTYPE html><html><head><title>Help for package mc2d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mc2d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bernoulli'>
<p>The Bernoulli Distribution</p></a></li>
<li><a href='#betagen'>
<p>The Generalised Beta Distribution</p></a></li>
<li><a href='#BetaSubjective'><p>The BetaSubjective Distribution</p></a></li>
<li><a href='#converg'>
<p>Graph of Running Statistics in the Variability or in the Uncertainty</p>
Dimension.</a></li>
<li><a href='#cornode'>
<p>Builds a Rank Correlation using the Iman and Conover Method.</p></a></li>
<li><a href='#dimmcnode'>
<p>Dimension of mcnode and mc Objects</p></a></li>
<li><a href='#dirichlet'>
<p>The Dirichlet Distribution</p></a></li>
<li><a href='#dmultinomial'>
<p>The Vectorized Multinomial Distribution</p></a></li>
<li><a href='#ec'><p>An example on Escherichia coli in ground beef</p></a></li>
<li><a href='#empiricalC'>
<p>The Continuous Empirical Distribution</p></a></li>
<li><a href='#empiricalD'>
<p>The Discrete Empirical Distribution</p></a></li>
<li><a href='#evalmcmod'>
<p>Evaluates a Monte-Carlo model</p></a></li>
<li><a href='#extractvar'>
<p>Utilities for multivariate nodes</p></a></li>
<li><a href='#gghist'><p>Histogram of a Monte Carlo Simulation (ggplot version)</p></a></li>
<li><a href='#ggplotmc'><p>ggplotmc</p></a></li>
<li><a href='#ggspaghetti'><p>Spaghetti Plot of 'mc' or 'mcnode' Object</p></a></li>
<li><a href='#ggtornado'><p>Draws a Tornado chart as provided by tornado (ggplot version).</p></a></li>
<li><a href='#hist.mc'>
<p>Histogram of a Monte Carlo Simulation</p></a></li>
<li><a href='#is.mc'>
<p>Tests mc and mcnode Objects</p></a></li>
<li><a href='#lhs'>
<p>Random Latin Hypercube Sampling</p></a></li>
<li><a href='#Lognormalb'><p>The Log Normal Distribution parameterized through its mean and standard deviation.</p></a></li>
<li><a href='#mc'>
<p>Monte Carlo Object</p></a></li>
<li><a href='#mc.control'>
<p>Sets or Gets the Default Number of Simulations.</p></a></li>
<li><a href='#mcapply'>
<p>Apply Functions Over mc or mcnode Objects</p></a></li>
<li><a href='#mccut'>
<p>Evaluates a Two-Dimensional Monte Carlo Model in a Loop.</p></a></li>
<li><a href='#mcmodel'>
<p>Monte Carlo model</p></a></li>
<li><a href='#mcnode'>
<p>Build mcnode Objects from Data or other mcnode Objects</p></a></li>
<li><a href='#mcprobtree'>
<p>Creates a Stochastic mcnode Object using a Probability Tree</p></a></li>
<li><a href='#mcratio'>
<p>Ratio of uncertainty and the variability</p></a></li>
<li><a href='#mcstoc'>
<p>Creates Stochastic mcnode Objects</p></a></li>
<li><a href='#MinimumQuantileInformation'><p>Minimum Quantile Information Distribution</p></a></li>
<li><a href='#multinormal'>
<p>The Vectorized Multivariate Random Deviates</p></a></li>
<li><a href='#NA.mcnode'>
<p>Finite, Infinite, NA and NaN Numbers in mcnode.</p></a></li>
<li><a href='#Ops.mcnode'>
<p>Operations on mcnode Objects</p></a></li>
<li><a href='#outm'>
<p>Output of Nodes</p></a></li>
<li><a href='#pert'><p>The (Modified) PERT Distribution</p></a></li>
<li><a href='#plot.mc'>
<p>Plots Results of a Monte Carlo Simulation</p></a></li>
<li><a href='#plot.tornado'>
<p>Draws a Tornado chart.</p></a></li>
<li><a href='#pmin'>
<p>Maxima and Minima for mcnodes</p></a></li>
<li><a href='#print.mc'>
<p>Prints a mcnode or a mc Object</p></a></li>
<li><a href='#quantile.mc'>
<p>Quantiles of a mc Object</p></a></li>
<li><a href='#rtrunc'>
<p>Random Truncated Distributions</p></a></li>
<li><a href='#spaghetti'><p>Spaghetti Plot of mc/mcnode Object</p></a></li>
<li><a href='#summary.mc'>
<p>Summary of mcnode and mc Object</p></a></li>
<li><a href='#tornado'>
<p>Computes Correlation between Inputs and Output in a mc Object</p>
(tornado) in the Variability Dimension;</a></li>
<li><a href='#tornadounc'>
<p>Computes Correlation between Inputs and Output in a mc Object</p>
(tornado) in the Uncertainty Dimension</a></li>
<li><a href='#total'><p>An Example of all Kind of mcnode</p></a></li>
<li><a href='#triangular'><p>The Triangular Distribution</p></a></li>
<li><a href='#typemcnode'>
<p>Provides the Type of a mcnode Object</p></a></li>
<li><a href='#unmc'>
<p>Unclasses the mc or the mcnode Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Two-Dimensional Monte-Carlo Simulations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Regis Pouillot [aut, cre],
  Marie-Laure Delignette-Muller [ctb],
  Jean-Baptiste Denis [ctb],
  Yu Chen [ctb],
  Arie Havelaar [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Regis Pouillot &lt;rpouillot@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fitdistrplus, survival, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics, utils, ggplot2, ggpubr</td>
</tr>
<tr>
<td>Description:</td>
<td>A complete framework to build and study Two-Dimensional Monte-Carlo simulations, aka Second-Order Monte-Carlo simulations. Also includes various distributions (pert, triangular, Bernoulli, empirical discrete and continuous).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-17 15:25:13 UTC; rpoui</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-17 16:00:02 UTC</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
</table>
<hr>
<h2 id='bernoulli'>
The Bernoulli Distribution
</h2><span id='topic+bernoulli'></span><span id='topic+dbern'></span><span id='topic+pbern'></span><span id='topic+qbern'></span><span id='topic+rbern'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Bernoulli distribution with probability equals to
&lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbern(x, prob=.5, log=FALSE)
pbern(q, prob=.5, lower.tail=TRUE, log.p=FALSE)
qbern(p, prob=.5, lower.tail=TRUE, log.p=FALSE)
rbern(n, prob=.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernoulli_+3A_x">x</code>, <code id="bernoulli_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="bernoulli_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="bernoulli_+3A_n">n</code></td>
<td>
<p>number of observations. If &lsquo;<span class="samp">&#8288;length(n) &gt; 1&#8288;</span>&rsquo;, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="bernoulli_+3A_prob">prob</code></td>
<td>
<p>vector of probabilities of success of each trial.</p>
</td></tr>
<tr><td><code id="bernoulli_+3A_log">log</code>, <code id="bernoulli_+3A_log.p">log.p</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are
given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="bernoulli_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities
are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use the corresponding functions from the
<code><a href="stats.html#topic+binomial">binomial</a></code> distribution with argument &lsquo;<span class="samp">&#8288;size = 1&#8288;</span>&rsquo;.
Thus, 1 is for success, 0 is for failure.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dbern&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;pbern&#8288;</span>&rsquo; gives the distribution
function, &lsquo;<span class="samp">&#8288;qbern&#8288;</span>&rsquo; gives the quantile function, and &lsquo;<span class="samp">&#8288;rbern&#8288;</span>&rsquo;
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Binomial">Binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbern(n=10, prob=.5)
rbern(n=3, prob=c(0, .5, 1))



</code></pre>

<hr>
<h2 id='betagen'>
The Generalised Beta Distribution
</h2><span id='topic+betagen'></span><span id='topic+dbetagen'></span><span id='topic+pbetagen'></span><span id='topic+qbetagen'></span><span id='topic+rbetagen'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Beta distribution defined on the &lsquo;<span class="samp">&#8288;[min, max]&#8288;</span>&rsquo;
domain with parameters &lsquo;<span class="samp">&#8288;shape1&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;shape2&#8288;</span>&rsquo; ( and optional
non-centrality parameter &lsquo;<span class="samp">&#8288;ncp&#8288;</span>&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetagen(x, shape1, shape2, min=0, max=1, ncp=0, log=FALSE)
pbetagen(q, shape1, shape2, min=0, max=1, ncp=0, lower.tail=TRUE,
	  log.p=FALSE)
qbetagen(p, shape1, shape2, min=0, max=1, ncp=0, lower.tail=TRUE,
	  log.p=FALSE)
rbetagen(n, shape1, shape2, min=0, max=1, ncp=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betagen_+3A_x">x</code>, <code id="betagen_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="betagen_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="betagen_+3A_n">n</code></td>
<td>
<p>Number of observations. If &lsquo;<span class="samp">&#8288;length(n) &gt; 1&#8288;</span>&rsquo;, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="betagen_+3A_shape1">shape1</code>, <code id="betagen_+3A_shape2">shape2</code></td>
<td>
<p>Positive parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="betagen_+3A_min">min</code></td>
<td>
<p>Vector of minima.</p>
</td></tr>
<tr><td><code id="betagen_+3A_max">max</code></td>
<td>
<p>Vector of maxima.</p>
</td></tr>
<tr><td><code id="betagen_+3A_ncp">ncp</code></td>
<td>
<p>Non-centrality parameter of the Beta distribution.</p>
</td></tr>
<tr><td><code id="betagen_+3A_log">log</code>, <code id="betagen_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are
given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="betagen_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities
are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">x \sim betagen(shape1, shape2, min, max, ncp)</code>
</p>
<p> if
</p>
<p style="text-align: center;"><code class="reqn">\frac{x-min}{max-min}\sim
beta(shape1,shape2,ncp)</code>
</p>

<p>These functions use the <code><a href="stats.html#topic+Beta">Beta</a></code> distribution functions
after correct parameterization.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dbetagen&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;pbetagen&#8288;</span>&rsquo; gives the
distribution function, &lsquo;<span class="samp">&#8288;qbetagen&#8288;</span>&rsquo; gives the quantile function,
and &lsquo;<span class="samp">&#8288;rbetagen&#8288;</span>&rsquo; generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(dbetagen(x, shape1=3, shape2=5, min=1, max=6), from = 0, to = 7)
curve(dbetagen(x, shape1=1, shape2=1, min=2, max=5), from = 0, to = 7, lty=2, add=TRUE)
curve(dbetagen(x, shape1=.5, shape2=.5, min=0, max=7), from = 0, to = 7, lty=3, add=TRUE)



</code></pre>

<hr>
<h2 id='BetaSubjective'>The BetaSubjective Distribution</h2><span id='topic+BetaSubjective'></span><span id='topic+dbetasubj'></span><span id='topic+pbetasubj'></span><span id='topic+qbetasubj'></span><span id='topic+rbetasubj'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the &quot;Beta Subjective&quot; distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetasubj(x, 
  min,
  mode,
  mean,
  max, 
  log = FALSE)

pbetasubj(q, 
  min,
  mode,
  mean,
  max, 
  lower.tail = TRUE,
  log.p = FALSE
)

qbetasubj(p, 
  min,
  mode,
  mean,
  max, 
  lower.tail = TRUE, 
  log.p = FALSE
)

rbetasubj(n, 
  min,
  mode,
  mean,
  max
)

pbetasubj(q, min, mode, mean, max, lower.tail = TRUE, log.p = FALSE)

qbetasubj(p, min, mode, mean, max, lower.tail = TRUE, log.p = FALSE)

rbetasubj(n, min, mode, mean, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaSubjective_+3A_x">x</code>, <code id="BetaSubjective_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_min">min</code></td>
<td>
<p>continuous boundary parameter min &lt; max</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_mode">mode</code></td>
<td>
<p>continuous parameter <code class="reqn">min &lt; mode &lt; max</code> and <code class="reqn">mode \ne mean</code>.</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_mean">mean</code></td>
<td>
<p>continuous parameter min &lt; mean &lt; max</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_max">max</code></td>
<td>
<p>continuous boundary parameter</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_log">log</code>, <code id="BetaSubjective_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="BetaSubjective_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Subjective beta distribution specifies a [stats::dbeta()] distribution defined by the minimum, most likely (mode), mean
and maximum values and can be used for fitting data for a variable that is bounded to the interval <code class="reqn">[min, max]</code>. 
The shape parameters are calculated from the mode value and mean parameters. It can also be used to represent 
uncertainty in subjective expert estimates.
</p>
<p>Define
</p>
<p style="text-align: center;"><code class="reqn">mid=(min+max)/2</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{1}=2*\frac{(mean-min)*(mid-mode)}{((mean-mode)*(max-min))}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{2}=a_{1}*\frac{(max-mean)}{(mean-min)}</code>
</p>

<p>The subject beta distribution is a [stats::dbeta()] distribution defined on the <code class="reqn">[min, max]</code> domain 
with parameter <code class="reqn">shape1 = a_{1}</code> and <code class="reqn">shape2 = a_{2}</code>.  
</p>
<p># Hence, it has density
# </p>
<p style="text-align: center;"><code class="reqn">f(x)=(x-min)^{(a_{1}-1)}*(max-x)^{(a_{2}-1)} / (B(a_{1},a_{2})*(max-min)^{(a_{1}+a_{2}-1)})</code>
</p>

<p># The cumulative distribution function is
# </p>
<p style="text-align: center;"><code class="reqn">F(x)=B_{z}(a_{1},a_{2})/B(a_{1},a_{2})=I_{z}(a_{1},a_{2})</code>
</p>

<p># where <code class="reqn">z=(x-min)/(max-min)</code>. Here B is the beta function and <code class="reqn">B_z</code> is the incomplete beta function.
</p>
<p>The parameter restrictions are:
</p>
<p style="text-align: center;"><code class="reqn">min &lt;= mode &lt;= max</code>
</p>

<p style="text-align: center;"><code class="reqn">min &lt;= mean &lt;= max</code>
</p>

<p>If <code class="reqn">mode &gt; mean</code> then <code class="reqn">mode &gt; mid</code>, else <code class="reqn">mode &lt; mid</code>.
</p>


<h3>Author(s)</h3>

<p>Yu Chen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(dbetasubj(x, min=0, mode=1, mean=2, max=5), from=-1,to=6) 
pbetasubj(q = seq(0,5,0.01), 0, 1, 2, 5)
qbetasubj(p = seq(0,1,0.01), 0, 1, 2, 5)
rbetasubj(n = 1e7, 0, 1, 2, 5)
</code></pre>

<hr>
<h2 id='converg'>
Graph of Running Statistics in the Variability or in the Uncertainty
Dimension.
</h2><span id='topic+converg'></span>

<h3>Description</h3>

<p>This function provides basic graphs to evaluate the convergence of a
node of a <code><a href="#topic+mc">mc</a></code> or a <code><a href="#topic+mccut">mccut</a></code> object in the
variability or in the uncertainty dimension. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>converg(x, node=length(x), margin=c("var", "unc"), nvariates=1, iter=1,
	  probs=c(0.025, 0.975), lim=c(0.025, 0.975), griddim=NULL,
	  log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="converg_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+mcnode">mcnode</a></code> object, a <code><a href="#topic+mc">mc</a></code> object or
a <code><a href="#topic+mccut">mccut</a></code> object.</p>
</td></tr>
<tr><td><code id="converg_+3A_node">node</code></td>
<td>
<p>The node to be considered in a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object or a
&lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object, displayed either as the order number or the name
of the node. By default: the last node of the object.The
corresponding node should not be of type &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; in a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;
object or of type &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; in a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="converg_+3A_margin">margin</code></td>
<td>
<p>The margin used to plot the graph. &lsquo;<span class="samp">&#8288;margin&#8288;</span>&rsquo; is
used only if the node is a &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="converg_+3A_nvariates">nvariates</code></td>
<td>
<p>The variates to be considered. &lsquo;<span class="samp">&#8288;nvariates&#8288;</span>&rsquo; is
used only for multivariates nodes.</p>
</td></tr>
<tr><td><code id="converg_+3A_iter">iter</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;margin == "var"&#8288;</span>&rsquo; and the node is a &lsquo;<span class="samp">&#8288;"VU"
mcnode&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;iter&#8288;</span>&rsquo; specify the iteration in the uncertainty
dimension to be used for the graph.</p>
</td></tr>
<tr><td><code id="converg_+3A_probs">probs</code></td>
<td>
<p>The quantiles to be provided in the variability
dimension.</p>
</td></tr>
<tr><td><code id="converg_+3A_lim">lim</code></td>
<td>
<p>The quantiles to be used in the uncertainty dimension.</p>
</td></tr>
<tr><td><code id="converg_+3A_griddim">griddim</code></td>
<td>
<p>A vector of two integers, indicating the size of the
grid of the graph. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;, the grid is calculated to produce
a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="converg_+3A_log">log</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, the data will be log transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the node is of type &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo;, the running mean, median and
&lsquo;<span class="samp">&#8288;probs&#8288;</span>&rsquo; quantiles according to the variability dimension will be
provided. If the node is of type &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;margin="var"&#8288;</span>&rsquo;,
this graph will be provided on one simulation in the uncertainty
dimension (chosen by &lsquo;<span class="samp">&#8288;iter&#8288;</span>&rsquo;).
</p>
<p>If the node is of type &lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo; the running mean, median and
&lsquo;<span class="samp">&#8288;lim&#8288;</span>&rsquo; quantiles according to the uncertainty dimension will be
provided.
</p>
<p>If the node is of type &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo; (with &lsquo;<span class="samp">&#8288;margin="unc"&#8288;</span>&rsquo; or from
a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object), one graph are provided for each of the mean,
median and &lsquo;<span class="samp">&#8288;probs&#8288;</span>&rsquo; quantiles calculated in the variability
dimension.
</p>


<h3>Note</h3>

<p>This function may be used on a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object only if a
&lsquo;<span class="samp">&#8288;summary.mc&#8288;</span>&rsquo; function was used in the third block of the
<code><a href="#topic+evalmccut">evalmccut</a></code> call. The values used as &lsquo;<span class="samp">&#8288;probs&#8288;</span>&rsquo;
arguments in &lsquo;<span class="samp">&#8288;converg&#8288;</span>&rsquo; should have been used in the
&lsquo;<span class="samp">&#8288;summary.mc&#8288;</span>&rsquo; function of this third block.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
converg(xVU, margin="var")
converg(xVU, margin="unc")
</code></pre>

<hr>
<h2 id='cornode'>
Builds a Rank Correlation using the Iman and Conover Method.
</h2><span id='topic+cornode'></span>

<h3>Description</h3>

<p>This function builds a rank correlation structure between columns of
a matrix or between &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects using the Iman and Conover
method (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cornode(..., target, outrank=FALSE, result=FALSE, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cornode_+3A_...">...</code></td>
<td>
<p>A matrix (each of its &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; columns but the first
one will be reordered) or &lsquo;<span class="samp">&#8288;n mcnode&#8288;</span>&rsquo; objects (each elements but
the first one will be reordered).</p>
</td></tr>
<tr><td><code id="cornode_+3A_target">target</code></td>
<td>
<p>A scalar (only if &lsquo;<span class="samp">&#8288;n=2&#8288;</span>&rsquo;) or a &lsquo;<span class="samp">&#8288;(n x n)&#8288;</span>&rsquo;
matrix of correlation.</p>
</td></tr>
<tr><td><code id="cornode_+3A_outrank">outrank</code></td>
<td>
<p>Should the order be returned?</p>
</td></tr>
<tr><td><code id="cornode_+3A_result">result</code></td>
<td>
<p>Should the correlation eventually obtained be printed?</p>
</td></tr>
<tr><td><code id="cornode_+3A_seed">seed</code></td>
<td>
<p>The random seed used for building the correlation. If
&lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo; the &lsquo;<span class="samp">&#8288;seed&#8288;</span>&rsquo; is unchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments should be named.
</p>
<p>The function accepts for &lsquo;<span class="samp">&#8288;data&#8288;</span>&rsquo; a matrix or: 
</p>

<ul>
<li><p> some &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo; objects separated by a comma;
</p>
</li>
<li><p> some &lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo; objects separated by a comma;
</p>
</li>
<li><p> some &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo; objects separated by a comma. In that
case, the structure is built columns by columns (the first column of
each &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo; will have a correlation structure, the second
ones will have a correlation structure, ....).
</p>
</li>
<li><p> one &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo; as a first element and some &lsquo;<span class="samp">&#8288;"VU"
mcnode&#8288;</span>&rsquo; objects, separated by a comma. In that case, the structure is
built between the &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo; and each column of the &lsquo;<span class="samp">&#8288;"VU"
mcnode&#8288;</span>&rsquo; objects. The correlation result (&lsquo;<span class="samp">&#8288;result = TRUE&#8288;</span>&rsquo;) is not
provided in that case.</p>
</li></ul>

<p>The number of variates of the elements should be equal.
</p>
<p>&lsquo;<span class="samp">&#8288;target&#8288;</span>&rsquo; should be a scalar (two columns only) or a real
symmetric positive-definite square matrix. Only the upper triangular
part of &lsquo;<span class="samp">&#8288;target&#8288;</span>&rsquo; is used (see <code><a href="Matrix.html#topic+chol">chol</a></code>).
</p>
<p>The final correlation structure should be checked because it is not
always possible to build the target correlation structure.
</p>
<p>In a Monte-Carlo simulation, note that the order of the values
within each &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; will be changed by this function (excepted
for the first one of the list). As a consequence, previous links
between variables will be broken. The &lsquo;<span class="samp">&#8288;outrank&#8288;</span>&rsquo; option may help
to rebuild these links (see the Examples).
</p>


<h3>Value</h3>

<p>If &lsquo;<span class="samp">&#8288;rank = FALSE&#8288;</span>&rsquo;: the matrix or a list of rearranged
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s. 
</p>
<p>If &lsquo;<span class="samp">&#8288;rank = TRUE&#8288;</span>&rsquo;: the order to be used to rearranged the matrix
or the &lsquo;<span class="samp">&#8288;mcnodes&#8288;</span>&rsquo; to build the desired correlation structure.
</p>


<h3>References</h3>

<p>Iman, R. L., &amp; Conover, W. J. (1982). A distribution-free approach to inducing rank correlation among input variables. <em>Communication in Statistics - Simulation and Computation</em>, 11(3), 311-334. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnorm(1000)
x2 &lt;- rnorm(1000)
x3 &lt;- rnorm(1000)
mat &lt;- cbind(x1, x2, x3)
## Target
(corr &lt;- matrix(c(1, 0.5, 0.2, 0.5, 1, 0.2, 0.2, 0.2, 1), ncol=3))
## Before
cor(mat, method="spearman")
matc &lt;- cornode(mat, target=corr, result=TRUE)
## The first row is unchanged
all(matc[, 1] == mat[, 1])

##Using mcnode and outrank
cook &lt;- mcstoc(rempiricalD, values=c(0, 1/5, 1/50), prob=c(0.027, 0.373, 0.600), nsv=1000)
serving &lt;- mcstoc(rgamma, shape=3.93, rate=0.0806, nsv=1000)
roundserv &lt;- mcdata(round(serving), nsv=1000)
## Strong relation between roundserv and serving (of course)
cor(cbind(cook, roundserv, serving), method="spearman")

##The classical way to build the correlation structure 
matcorr &lt;- matrix(c(1, 0.5, 0.5, 1), ncol=2)
matc &lt;- cornode(cook=cook, roundserv=roundserv, target=matcorr)
## The structure between cook and roundserv is OK but ...
## the structure between roundserv and serving is lost
cor(cbind(cook=matc$cook, serv=matc$roundserv, serving), method="spearman")

##An alternative way to build the correlation structure
matc &lt;- cornode(cook=cook, roundserv=roundserv, target=matcorr, outrank=TRUE)
## Rebuilding the structure
roundserv[] &lt;- roundserv[matc$roundserv, , ]
serving[] &lt;- serving[matc$roundserv, , ]
## The structure between cook and roundserv is OK and ...
## the structure between roundserv and serving is preserved
cor(cbind(cook, roundserv, serving), method="spearman")
</code></pre>

<hr>
<h2 id='dimmcnode'>
Dimension of mcnode and mc Objects
</h2><span id='topic+dimmcnode'></span><span id='topic+dimmc'></span>

<h3>Description</h3>

<p>Provides the dimension (i.e. the number of simulations in the
variability dimension, the number of simulations in the uncertainty
dimension and the maximum number of variates of a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimmcnode(x)
dimmc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimmcnode_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of three scalars: the dimension of variability (1 for
&lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo;), the dimension of uncertainty (1
for &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;) and the number of variates (the
maximal number of variates for an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Note</h3>

<p>This function does not test if the object is correctly built. See
<code><a href="#topic+is.mcnode">is.mcnode</a></code> and <code><a href="#topic+is.mc">is.mc</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
dimmcnode(xVUM2)
dimmc(total)

</code></pre>

<hr>
<h2 id='dirichlet'>
The Dirichlet Distribution
</h2><span id='topic+dirichlet'></span><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density function and random generation from the Dirichlet
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha)
rdirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet_+3A_x">x</code></td>
<td>
<p>A vector containing a single deviate or a matrix containing
one random deviate per row.</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>A vector of shape parameters, or a matrix of shape
parameters by rows. Recycling (by row) is permitted.</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_n">n</code></td>
<td>
<p>Number of random vectors to generate. If length(n) <code class="reqn">&gt;</code>
1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dirichlet distribution is the multidimensional generalization of
the beta distribution. The original code was adapted to provide a
kind of &quot;vectorization&quot; used in multivariates &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;ddirichlet&#8288;</span>&rsquo; gives the density. &lsquo;<span class="samp">&#8288;rdirichlet&#8288;</span>&rsquo; returns a
matrix with &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; rows, each containing a single Dirichlet random
deviate.
</p>


<h3>Author(s)</h3>

<p>Code is adapted from &lsquo;<span class="samp">&#8288;MCMCpack&#8288;</span>&rsquo;. It originates from Greg's
Miscellaneous Functions (gregmisc).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- c(1, 10, 100, 1000, 1000, 100, 10, 1)
(alpha &lt;- matrix(dat, nrow=4, byrow=TRUE))
round(x &lt;- rdirichlet(4, alpha), 2)
ddirichlet(x, alpha)

## rdirichlet used with mcstoc
mcalpha &lt;- mcdata(dat, type="V", nsv=4, nvariates=2)
(x &lt;- mcstoc(rdirichlet, type="V", alpha=mcalpha, nsv=4, nvariates=2))
unclass(x)
x &lt;- mcstoc(rdirichlet, type="VU", alpha=mcalpha, nsv=4, nsu=10, nvariates=2)
unclass(x)

</code></pre>

<hr>
<h2 id='dmultinomial'>
The Vectorized Multinomial Distribution
</h2><span id='topic+dmultinomial'></span><span id='topic+rmultinomial'></span>

<h3>Description</h3>

<p>Generate multinomially distributed random number vectors and compute
multinomial probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultinomial(x, size=NULL, prob, log=FALSE)
rmultinomial(n, size, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmultinomial_+3A_x">x</code></td>
<td>
<p>vector or matrix of length (or ncol) K of integers in
&lsquo;<span class="samp">&#8288;0:size&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="dmultinomial_+3A_n">n</code></td>
<td>
<p>number of random vectors to draw.</p>
</td></tr>
<tr><td><code id="dmultinomial_+3A_size">size</code></td>
<td>
<p>a vector of integers, say N, specifying the total number
of objects that are put into K boxes in the typical multinomial
experiment. For &lsquo;<span class="samp">&#8288;dmultinom&#8288;</span>&rsquo;, it defaults to &lsquo;<span class="samp">&#8288;sum(x)&#8288;</span>&rsquo;. The
first element correspond to the vector &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; or the first row
of &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;, ...</p>
</td></tr>
<tr><td><code id="dmultinomial_+3A_prob">prob</code></td>
<td>
<p>Numeric non-negative vector of length K, or matrix of
size &lsquo;<span class="samp">&#8288;(x x K)&#8288;</span>&rsquo; specifying the probability for the K classes; is
internally normalized to sum 1.</p>
</td></tr>
<tr><td><code id="dmultinomial_+3A_log">log</code></td>
<td>
<p>Logical; if TRUE, log probabilities are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are the vectorized versions of
<code><a href="stats.html#topic+rmultinom">rmultinom</a></code> and <code><a href="stats.html#topic+dmultinom">dmultinom</a></code>. Recycling is
permitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(100, 200, 700)
x1 &lt;- matrix(c(100, 200, 700, 200, 100, 700, 700, 200, 100), byrow=TRUE, ncol=3)
p &lt;- c(1, 2, 7)
p1 &lt;- matrix(c(1, 2, 7, 2, 1, 7, 7, 2, 1), byrow=TRUE, ncol=3)
dmultinomial(x1, prob=p) 
## is equivalent to 
c(	dmultinom(x1[1, ], prob=p), 
	dmultinom(x1[2, ], prob=p), 
	dmultinom(x1[3, ], prob=p))

dmultinomial(x1, prob=p1, log=TRUE) 
## is equivalent to 
c(	dmultinom(x1[1, ], prob=p1[1, ], log=TRUE), 
	dmultinom(x1[2, ], prob=p1[2, ], log=TRUE), 
	dmultinom(x1[3, ], prob=p1[3, ], log=TRUE))

dmultinomial(x, prob=p1, log=TRUE)
## is equivalent to 
c(	dmultinom(x, prob=p1[1, ], log=TRUE), 
	dmultinom(x, prob=p1[2, ], log=TRUE), 
	dmultinom(x, prob=p1[3, ], log=TRUE))

prob &lt;- c(1, 2, 7)
rmultinomial(4, 1000, prob)
rmultinomial(4, c(10, 100, 1000, 10000), prob)

## rmultinomial used with mcstoc
## (uncertain size and prob)
s &lt;- mcstoc(rpois, "U", lambda=50)
p &lt;- mcstoc(rdirichlet, "U", nvariates=3, alpha=c(4, 10, 20))
mcstoc(rmultinomial, "VU", nvariates=3, size=s, prob=p)

</code></pre>

<hr>
<h2 id='ec'>An example on Escherichia coli in ground beef</h2><span id='topic+ec'></span><span id='topic+modEC1'></span><span id='topic+modEC2'></span>

<h3>Description</h3>

<p>The fictive example is as following:
</p>
<p>A batch of ground beef is contaminated with <em>E. coli</em>,
with a mean concentration &lsquo;<span class="samp">&#8288;conc&#8288;</span>&rsquo;.
</p>
<p>Consumers may eat the beef &quot;rare&quot;, &quot;medium rare&quot; or
&quot;well cooked&quot;. If &quot;rare&quot;, no bacteria is killed. If &quot;medium rare&quot;, 1/5 of bacteria survive. If &quot;well cooked&quot;, 1/50 of bacteria survive.
</p>
<p>The serving size is variable.
</p>
<p>The risk of infection follows an exponential model.
</p>
<p>For the one-dimensional model, it is assumed that:
</p>
<p><code>conc &lt;- 10</code>
</p>
<p><code>cook &lt;- sample(n, x=c(1,1/5,1/50),replace=TRUE,prob=c(0.027,0.373,0.600))</code>
</p>
<p><code>serving &lt;- rgamma(n, shape=3.93,rate=0.0806)</code>
</p>
<p><code>expo &lt;- conc * cook * serving</code>
</p>
<p><code>dose &lt;- rpois(n, lambda=expo)</code>
</p>
<p><code>risk &lt;- 1-(1-0.001)^dose</code>
</p>
<p>For the two-dimensional model, it is assumed moreover that the concentration and the &lsquo;<span class="samp">&#8288;r&#8288;</span>&rsquo; parameter
of the dose response are uncertain.
</p>
<p><code>conc &lt;- rnorm(n,mean=10,sd=2)</code>
</p>
<p><code>r &lt;- runif(n ,min=0.0005,max=0.0015)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ec)</code></pre>


<h3>Format</h3>

<p>A list of two expression to be passed in <code>mcmodel</code>
</p>


<h3>Source</h3>

<p>Fictive example</p>


<h3>References</h3>

<p>None
</p>

<hr>
<h2 id='empiricalC'>
The Continuous Empirical Distribution
</h2><span id='topic+empiricalC'></span><span id='topic+dempiricalC'></span><span id='topic+pempiricalC'></span><span id='topic+qempiricalC'></span><span id='topic+rempiricalC'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for a continuous
empirical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dempiricalC(x, min, max, values, prob=NULL, log=FALSE)
pempiricalC(q, min, max, values, prob=NULL, lower.tail=TRUE, log.p=FALSE)
qempiricalC(p, min, max, values, prob=NULL, lower.tail=TRUE, log.p=FALSE)
rempiricalC(n, min, max, values, prob=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiricalC_+3A_x">x</code>, <code id="empiricalC_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_n">n</code></td>
<td>
<p>Number of random values. If &lsquo;<span class="samp">&#8288;length(n) &gt; 1&#8288;</span>&rsquo;, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_min">min</code></td>
<td>
<p>A finite minimal value.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_max">max</code></td>
<td>
<p>A finite maximal value.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_values">values</code></td>
<td>
<p>Vector of numerical values.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_prob">prob</code></td>
<td>
<p>Optional vector of count or probabilities.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_log">log</code>, <code id="empiricalC_+3A_log.p">log.p</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are
given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="empiricalC_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities
are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">p_{i}</code>, the distribution value for <code class="reqn">x_{i}</code>
with &lsquo;<span class="samp">&#8288;i&#8288;</span>&rsquo; the rank <code class="reqn">i = 0, 1, 2, \ldots, N+1</code>,
<code class="reqn">x_{0}=min</code> and <code class="reqn">x_{N+1}=max</code> the
density is:
</p>
<p style="text-align: center;"><code class="reqn">f(x)=p_{i}+(\frac{x-x_{i}}{x_{i+1}-x_{i}})(p_{i+1}-p_{i})</code>
</p>
<p> The
&lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; values being normalized to give the distribution a unit
area.
</p>
<p>&lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;
may vary: in that case, &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo; should be
vector(s). &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; should be matrixes, the
first row being used for the first element of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;q&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; or the first random value, the second row for the second
element of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;q&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; or random value, ...
Recycling is permitted if the number of elements of &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo; or the number of rows of &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; are
equal or equals one.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dempiricalC&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;pempiricalC&#8288;</span>&rsquo; gives the
distribution function, &lsquo;<span class="samp">&#8288;qempiricalC&#8288;</span>&rsquo; gives the quantile function
and &lsquo;<span class="samp">&#8288;rempiricalC&#8288;</span>&rsquo; generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalD">empiricalD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob &lt;- c(2, 3, 1, 6, 1)
values &lt;- 1:5
par(mfrow=c(1, 2))
curve(dempiricalC(x, min=0, max=6, values, prob), from=-1, to=7, n=1001)
curve(pempiricalC(x, min=0, max=6, values, prob), from=-1, to=7, n=1001)

## Varying values
(values &lt;- matrix(1:10, ncol=5))
## the first x apply to the first row 
## the second x to the second one
dempiricalC(c(1, 1), values, min=0, max=11)


##Use with mc2d 
val &lt;- c(100, 150, 170, 200)
pr &lt;- c(6, 12, 6, 6)
out &lt;- c("min", "mean", "max")
##First Bootstrap in the uncertainty dimension
##with rempirical D
(x &lt;- mcstoc(rempiricalD, type = "U", outm = out, nvariates = 30, values = val, prob = pr))
##Continuous Empirical distribution in the variability dimension
mcstoc(rempiricalC, type = "VU", values = x, min=90, max=210)



</code></pre>

<hr>
<h2 id='empiricalD'>
The Discrete Empirical Distribution
</h2><span id='topic+empiricalD'></span><span id='topic+dempiricalD'></span><span id='topic+pempiricalD'></span><span id='topic+qempiricalD'></span><span id='topic+rempiricalD'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for a discrete
empirical distribution. This function is vectorized to accept
different sets of &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dempiricalD(x, values, prob=NULL, log=FALSE)
pempiricalD(q, values, prob=NULL, lower.tail=TRUE, log.p=FALSE)
qempiricalD(p, values, prob=NULL, lower.tail=TRUE, log.p=FALSE)
rempiricalD(n, values, prob=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiricalD_+3A_x">x</code>, <code id="empiricalD_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_n">n</code></td>
<td>
<p>Number of random values. If length(n) <code class="reqn">&gt;</code> 1, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_values">values</code></td>
<td>
<p>Vector or matrix of numerical values. See details.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_prob">prob</code></td>
<td>
<p>Optional vector or matrix of count or probabilities. See
details.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_log">log</code>, <code id="empiricalD_+3A_log.p">log.p</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are
given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="empiricalD_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities
are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; is missing, the discrete distribution is obtained
directly from the vector of &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo;, otherwise &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; is
used to weight the values. &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; is normalized before use.
Thus, &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; may be the count of each &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo;. &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;
values should be non negative and their sum should not be 0.
</p>
<p>&lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; may vary: in that case,
&lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; should be sent as matrixes, the
first row being used for the first element of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;q&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; or the first random value, the second row for the second
element of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;q&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; or random value, ...
Recycling is permitted if the number of rows of &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; and
&lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; are equal or if the number of rows of &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;
and/or &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; are one.
</p>
<p>&lsquo;<span class="samp">&#8288;rempiricalD(n, values, prob)&#8288;</span>&rsquo; with &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo; and
&lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; as vectors is equivalent to &lsquo;<span class="samp">&#8288;sample(x=values,
size=n, replace=TRUE, prob=prob)&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dempiricalD&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;pempiricalD&#8288;</span>&rsquo; gives the
distribution function, &lsquo;<span class="samp">&#8288;qempiricalD&#8288;</span>&rsquo; gives the quantile function
and &lsquo;<span class="samp">&#8288;rempiricalD&#8288;</span>&rsquo; generates random deviates.
</p>


<h3>Note</h3>

<p>In the future, the functions should be written for non numerical
values.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>. <code><a href="#topic+empiricalC">empiricalC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dempiricalD(1:6, 2:6, prob=c(10, 10, 70, 0, 10))
pempiricalD(1:6, 2:6, prob=c(10, 10, 70, 0, 10))
qempiricalD(seq(0, 1, 0.1), 2:6, prob=c(10, 10, 70, 0, 10))
table(rempiricalD(10000, 2:6, prob=c(10, 10, 70, 0, 10)))

## Varying values
(values &lt;- matrix(1:10, ncol=5))
## the first x apply to the first row : p = 0.2
## the second x to the second one: p = 0
dempiricalD(c(1, 1), values)


##Use with mc2d
##Non Parameteric Bootstrap
val &lt;- c(100, 150, 170, 200)
pr &lt;- c(6, 12, 6, 6)
out &lt;- c("min", "mean", "max")
##First Bootstrap in the uncertainty dimension
(x &lt;- mcstoc(rempiricalD, type = "U", outm = out, nvariates = 30, values = val, prob = pr))
##Second one in the variability dimension
mcstoc(rempiricalD, type = "VU", values = x)



</code></pre>

<hr>
<h2 id='evalmcmod'>
Evaluates a Monte-Carlo model
</h2><span id='topic+evalmcmod'></span>

<h3>Description</h3>

<p>Evaluates a <code><a href="#topic+mcmodel">mcmodel</a></code> object (or a valid expression)
using a specified number of simulations and with (or without) a
specified seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalmcmod(expr, nsv=ndvar(), nsu=ndunc(), seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalmcmod_+3A_expr">expr</code></td>
<td>
<p>A model of class <code><a href="#topic+mcmodel">mcmodel</a></code> or a valid
expression.</p>
</td></tr>
<tr><td><code id="evalmcmod_+3A_nsv">nsv</code></td>
<td>
<p>The number of simulations in the dimension of variability
used in the evaluation.</p>
</td></tr>
<tr><td><code id="evalmcmod_+3A_nsu">nsu</code></td>
<td>
<p>The number of simulations in the dimension of uncertainty
used in the evaluation.</p>
</td></tr>
<tr><td><code id="evalmcmod_+3A_seed">seed</code></td>
<td>
<p>The random seed used for the evaluation. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;
the &lsquo;<span class="samp">&#8288;seed&#8288;</span>&rsquo; is unchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is evaluated. The intermediate variables used to build the
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object are not stored.
</p>


<h3>Value</h3>

<p>The results of the evaluation. It should be a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Note</h3>

<p>The seed is set at the beginning of the evaluation. Thus, the
complete similarity of two evaluations with similar seed is not
certain, depending on the structure of your model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmodel">mcmodel</a></code>
</p>
<p><code><a href="#topic+evalmccut">evalmccut</a></code> to evaluate high dimension Monte Carlo Model
in a loop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ec)
ec$modEC1
evalmcmod(ec$modEC1, nsv=100, nsu=100, seed=666)
</code></pre>

<hr>
<h2 id='extractvar'>
Utilities for multivariate nodes
</h2><span id='topic+extractvar'></span><span id='topic+addvar'></span>

<h3>Description</h3>

<p>&lsquo;<span class="samp">&#8288;extractvar&#8288;</span>&rsquo; extracts one variate from a multivariate node. 
</p>
<p>&lsquo;<span class="samp">&#8288;addvar&#8288;</span>&rsquo; adds consistent &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s to build a multivariate
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractvar(x, which=1)
addvar(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractvar_+3A_x">x</code></td>
<td>
<p>a multivariates &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="extractvar_+3A_which">which</code></td>
<td>
<p>a vector. which variate(s) should be extracted?</p>
</td></tr>
<tr><td><code id="extractvar_+3A_...">...</code></td>
<td>
 <p>&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s to be gathered in a multivariate
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;. These &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s should be of same type and
dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute of the output of &lsquo;<span class="samp">&#8288;addvar&#8288;</span>&rsquo; will be the
one of the first element.
</p>


<h3>Value</h3>

<p>The new built &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnode">mcnode</a></code> for &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mcdata(0:3, "0", nvariates = 4)
y &lt;- extractvar(x, c(1, 3)) 
y
addvar(x, y)

</code></pre>

<hr>
<h2 id='gghist'>Histogram of a Monte Carlo Simulation (ggplot version)</h2><span id='topic+gghist'></span><span id='topic+gghist.mc'></span><span id='topic+gghist.mcnode'></span>

<h3>Description</h3>

<p>Shows histogram of a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object by ggplot framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gghist(x, ...)

## S3 method for class 'mcnode'
gghist(
  x,
  griddim = NULL,
  xlab = names(x),
  ylab = "Frequency",
  main = "",
  bins = 30,
  which = NULL,
  ...
)

## S3 method for class 'mc'
gghist(
  x,
  griddim = NULL,
  xlab = names(x),
  ylab = "Frequency",
  main = "",
  bins = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gghist_+3A_x">x</code></td>
<td>
<p>an 'mc' or an 'mcnode' object</p>
</td></tr>
<tr><td><code id="gghist_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to geom_histogram()</p>
</td></tr>
<tr><td><code id="gghist_+3A_griddim">griddim</code></td>
<td>
<p>A vector of two integers, indicating the size of the grid of the graph. 
If 'NULL', the grid is calculated to produce a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="gghist_+3A_xlab">xlab</code></td>
<td>
<p>Vector of labels for the x-axis. If 'NULL', use the name of the node.</p>
</td></tr>
<tr><td><code id="gghist_+3A_ylab">ylab</code></td>
<td>
<p>Vector of labels for the y-axis.</p>
</td></tr>
<tr><td><code id="gghist_+3A_main">main</code></td>
<td>
<p>Vector of main titles of the graph</p>
</td></tr>
<tr><td><code id="gghist_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Defaults to 30.</p>
</td></tr>
<tr><td><code id="gghist_+3A_which">which</code></td>
<td>
<p>An argument used for a multivariate 'mcnode'. 
Can specify which variate plot to display. 
When variates are more than one, the output will be saved in a plot list by 
default or use the number of which variate to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>Author(s)</h3>

<p>Yu Chen and Regis Pouillot
</p>


<h3>See Also</h3>

<p>[hist.mc()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
# When mcnode has one variate
gghist(xV)
# When mcnode has two variates, the two plots will be saved in a list 
# if affected to a variable
gplots &lt;- gghist(xVUM) 
# show the first variate plot of xVUM mcnode
gplots[[1]] 
# directly show the first variate plot of xVUM mcnode
gghist(xVUM, which = 1) #directly show the first variate plot of xVUM mcnode
# Post process
gplots[[1]] + ggplot2::geom_histogram(color = "red",fill="blue")

</code></pre>

<hr>
<h2 id='ggplotmc'>ggplotmc</h2><span id='topic+ggplotmc'></span><span id='topic+ggplotmc.mc'></span><span id='topic+ggplotmc.mcnode'></span>

<h3>Description</h3>

<p>Plots the empirical cumulative distribution function of a [mcnode] 
or a [mc] object (&quot;'0'&quot; and &quot;'V'&quot; nodes) or the empirical cumulative distribution 
function of the estimate of a [mcnode] or [mc] object (&quot;'U'&quot; and &quot;'VU'&quot; nodes) based on 
[ggplot2::ggplot] package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotmc(x, ...)

## S3 method for class 'mcnode'
ggplotmc(
  x,
  prec = 0.001,
  stat = c("median", "mean"),
  lim = c(0.025, 0.25, 0.75, 0.975),
  na.rm = TRUE,
  griddim = NULL,
  xlab = NULL,
  ylab = "Fn(x)",
  main = "",
  paint = TRUE,
  xlim = NULL,
  ylim = NULL,
  which = NULL,
  ...
)

## S3 method for class 'mc'
ggplotmc(
  x,
  prec = 0.001,
  stat = c("median", "mean"),
  lim = c(0.025, 0.25, 0.75, 0.975),
  na.rm = TRUE,
  griddim = NULL,
  xlab = NULL,
  ylab = "Fn(x)",
  main = "",
  paint = TRUE,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotmc_+3A_x">x</code></td>
<td>
<p>and 'mc' or an 'mcnode' object</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to [ggplot2::stat_ecdf()]</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_prec">prec</code></td>
<td>
<p>the precision of the plot. 0.001 will provide an ecdf using the 0.000, 0.001, .002, ..., 1.000 quantiles.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_stat">stat</code></td>
<td>
<p>the function used for estimates (2D 'mc' or 'mcnode'). By default the median.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_lim">lim</code></td>
<td>
<p>a  vector of numbers (between 0 and 1) indicating the envelope (2D 'mc' or 'mcnode') . Maybe NULL or empty.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_na.rm">na.rm</code></td>
<td>
<p>Should 'NA' values be discarded</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_griddim">griddim</code></td>
<td>
<p>a vector of two integers, indicating the size of the grid of the graph. If NULL, the grid is calculated to produce a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_xlab">xlab</code></td>
<td>
<p>vector of labels for the x-axis. If 'NULL', the name of the node is used.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_ylab">ylab</code></td>
<td>
<p>vector of labels for the y-axis.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_main">main</code></td>
<td>
<p>vector of main titles of the graph</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_paint">paint</code></td>
<td>
<p>Should the envelopes be filled?</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_xlim">xlim</code></td>
<td>
<p>x coordinate range. 'xlim' is either a vector of length 2, used for each graph, or a list of vectors of length 2, whose ith element is used for the ith graph. By default, the data range is used as xlim.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_ylim">ylim</code></td>
<td>
<p>y coordinate range. 'ylim' is either a vector of length 2, used for each graph, or a list of vectors of length 2, whose ith element is used for the ith graph. By default, the data range is 0-1.</p>
</td></tr>
<tr><td><code id="ggplotmc_+3A_which">which</code></td>
<td>
<p>An argument used for an 'mcnode' with multivariates. Can specify which variate plot to display. When variates are more than one, the output will be saved in a plot list by default or use the number of which variate to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>Author(s)</h3>

<p>Yu Chen and Regis Pouillot
</p>


<h3>See Also</h3>

<p>[plot.mc()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
# When mcnode has one variate
ggplotmc(xV)
# Post process
ggplotmc(xV) + ggplot2::ggtitle("post processed")
# When mcnode has two variates
gplots &lt;- ggplotmc(xVUM) #will save two plots in a list
gplots[[1]] # show the first variate plot of xVUM mcnode
ggplotmc(xVUM, which = 1) #directly show the first variate plot of xVUM mcnode

</code></pre>

<hr>
<h2 id='ggspaghetti'>Spaghetti Plot of 'mc' or 'mcnode' Object</h2><span id='topic+ggspaghetti'></span><span id='topic+ggspaghetti.mc'></span><span id='topic+ggspaghetti.mcnode'></span>

<h3>Description</h3>

<p>Use ggplot to draw spaghetti plots for the [mc] or [mcnode] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggspaghetti(x, ...)

## S3 method for class 'mc'
ggspaghetti(
  x,
  griddim = NULL,
  xlab = names(x),
  ylab = "F(n)",
  main = "",
  maxlines = 100,
  ...
)

## S3 method for class 'mcnode'
ggspaghetti(
  x,
  griddim = NULL,
  xlab = names(x),
  ylab = "F(n)",
  main = "",
  which = NULL,
  maxlines = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggspaghetti_+3A_x">x</code></td>
<td>
<p>an 'mc' or an 'mcnode' object</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to [ggplot2::stat_ecdf()]</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_griddim">griddim</code></td>
<td>
<p>a vector of two integers, indicating the size of the grid of the graph. If 'NULL', the grid is calculated to produce a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_xlab">xlab</code></td>
<td>
<p>vector of labels for the x-axis. If 'NULL', use the name of the node.</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_ylab">ylab</code></td>
<td>
<p>vector of labels for the y-axis.</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_main">main</code></td>
<td>
<p>vector of main titles of the graph</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_maxlines">maxlines</code></td>
<td>
<p>the maximum number of ecdf to draw.</p>
</td></tr>
<tr><td><code id="ggspaghetti_+3A_which">which</code></td>
<td>
<p>An argument used for an 'mcnode' with multivariates. 
Can specify which variate plot to display. When variates are more than one, 
the output will be saved in a plot list by default or use the number of which variate to display.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu Chen and Regis Pouillot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ec)
EC2 &lt;- evalmcmod(ec[[2]])
# When the input is mc object
ggspaghetti(EC2) 
# When the input is mcnode object
data(total)
# mcnode has one variate
ggspaghetti(xV) 
# This mcnode has two variates, will save two plots in a list
gplots &lt;- ggplotmc(xVUM) #will save two plots in a list
# show the first variate plot of xVUM mcnode
gplots[[1]] 
# directly show the first variate plot of xVUM mcnode
ggspaghetti(xVUM, which = 1) 

</code></pre>

<hr>
<h2 id='ggtornado'>Draws a Tornado chart as provided by tornado (ggplot version).</h2><span id='topic+ggtornado'></span><span id='topic+ggtornadounc'></span>

<h3>Description</h3>

<p>Draws a Tornado chart as provided by tornado.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## For class 'tornado'
ggtornado(x, 
  which=1, 
  name=NULL, 
  stat=c("median","mean"), 
  xlab="method", 
  ylab=""
)

## For class 'tornadounc'
ggtornadounc(x,
  which=1, 
  stat="median", 
  name=NULL, 
  xlab="method", 
  ylab=""
)

ggtornadounc(
  x,
  which = 1,
  stat = "median",
  name = NULL,
  xlab = "method",
  ylab = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtornado_+3A_x">x</code></td>
<td>
<p>A tornado object as provided by the <code><a href="#topic+tornado">tornado</a></code> function.</p>
</td></tr>
<tr><td><code id="ggtornado_+3A_which">which</code></td>
<td>
<p>Which output to print -for multivariates output-.</p>
</td></tr>
<tr><td><code id="ggtornado_+3A_name">name</code></td>
<td>
<p>Vector of name of input variables. If NULL, the name will be given from the name of the elements.</p>
</td></tr>
<tr><td><code id="ggtornado_+3A_stat">stat</code></td>
<td>
<p>The name of the statistics of the output to be considered. For a tornado object: &quot;median&quot; or &quot;mean&quot;. For a tornadounc object: the value should match one row name of the tornadounc object. Alternatively, for a tornadounc object, the number of the row may be used.</p>
</td></tr>
<tr><td><code id="ggtornado_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x axis. Default is to use the correlation method used in the tornado object.</p>
</td></tr>
<tr><td><code id="ggtornado_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y axis. Default is empty.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tornado">tornado</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ec)
x &lt;- evalmcmod(ec$modEC2, nsv=100, nsu=100, seed=666)
tor &lt;- tornado(x, 7)
ggtornado(tor)
data(total)
ggtornado(tornadounc(total, 10, use="complete.obs"), which=1)
</code></pre>

<hr>
<h2 id='hist.mc'>
Histogram of a Monte Carlo Simulation
</h2><span id='topic+hist.mc'></span><span id='topic+hist.mcnode'></span>

<h3>Description</h3>

<p>Shows histogram of a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
hist(x, griddim=NULL, xlab=names(x), ylab="Frequency", main="", ...)
## S3 method for class 'mcnode'
hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.mc_+3A_x">x</code></td>
<td>
<p>An &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="hist.mc_+3A_griddim">griddim</code></td>
<td>
<p>A vector of two integers, indicating the size of the
grid of plots. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;, the grid is calculated to produce a
&quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="hist.mc_+3A_xlab">xlab</code></td>
<td>
<p>A vector of labels for the x-axis for drawn histograms
(those whose &lsquo;<span class="samp">&#8288;outm(x)!="none"&#8288;</span>&rsquo;). May be recycled.</p>
</td></tr>
<tr><td><code id="hist.mc_+3A_ylab">ylab</code></td>
<td>
<p>A vector of labels for the y-axis for drawn histograms.
May be recycled.</p>
</td></tr>
<tr><td><code id="hist.mc_+3A_main">main</code></td>
<td>
<p>A vector of main title of histograms for drawn
histograms. May be recycled.</p>
</td></tr>
<tr><td><code id="hist.mc_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to all calls of
&lsquo;<span class="samp">&#8288;hist&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For Two-dimensional &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;, the histogram is based on all data
(variability and uncertainty) pooled together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
hist(xVUM3)
hist(total)

</code></pre>

<hr>
<h2 id='is.mc'>
Tests mc and mcnode Objects
</h2><span id='topic+is.mc'></span><span id='topic+is.mcnode'></span>

<h3>Description</h3>

<p>&lsquo;<span class="samp">&#8288;is.mc&#8288;</span>&rsquo; tests &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects and &lsquo;<span class="samp">&#8288;is.mcnode&#8288;</span>&rsquo; tests
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mc(x)
is.mcnode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mc_+3A_x">x</code></td>
<td>
<p>An &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;is.mc&#8288;</span>&rsquo; tests if &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is a list of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;, each
elements being of compatible dimension. It tests if the class
&lsquo;<span class="samp">&#8288;"mc"&#8288;</span>&rsquo; is affected to the object.
</p>
<p>&lsquo;<span class="samp">&#8288;is.mcnode&#8288;</span>&rsquo; tests if &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is an array of numeric or
logical, if it has a &quot;type&quot; attribute and compatible dimensions, and
if the class &lsquo;<span class="samp">&#8288;"mcnode"&#8288;</span>&rsquo; is affected to the object.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
is.mcnode(xVU)
is.mcnode(total)
is.mc(total)

</code></pre>

<hr>
<h2 id='lhs'>
Random Latin Hypercube Sampling
</h2><span id='topic+lhs'></span>

<h3>Description</h3>

<p>Creates a Latin Hypercube Sample (LHS) of the specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs(distr="runif", nsv=ndvar(), nsu=ndunc(), nvariates=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lhs_+3A_distr">distr</code></td>
<td>
<p>The function for generating random sample or its name.
If &lsquo;<span class="samp">&#8288;distr&#8288;</span>&rsquo; is &quot;rdist&quot;, the function &quot;qdist&quot; must be the quantile
function of this distribution with argument &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; as a vector of
probabilities, as all univariates distributions of the &lsquo;<span class="samp">&#8288;stat&#8288;</span>&rsquo;
library.</p>
</td></tr>
<tr><td><code id="lhs_+3A_nsv">nsv</code></td>
<td>
<p>The number of rows of the final matrix.</p>
</td></tr>
<tr><td><code id="lhs_+3A_nsu">nsu</code></td>
<td>
<p>The number of columns of the final matrix</p>
</td></tr>
<tr><td><code id="lhs_+3A_nvariates">nvariates</code></td>
<td>
<p>The number of variates</p>
</td></tr>
<tr><td><code id="lhs_+3A_...">...</code></td>
<td>
<p>All arguments to be passed to &lsquo;<span class="samp">&#8288;distr&#8288;</span>&rsquo; except the
size of the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &lsquo;<span class="samp">&#8288;nsv x nsu&#8288;</span>&rsquo; matrix of random variates.
</p>


<h3>Note</h3>

<p>The resulting lhs is in fact a latin hypersquare sampling: the lhs is
provided only in the first 2 dimensions.
</p>
<p>It is not possible to send truncated distribution with
<code><a href="#topic+rtrunc">rtrunc</a></code>. Use <code><a href="#topic+mcstoc">mcstoc</a></code> for this purpose, with
&lsquo;<span class="samp">&#8288;lhs=TRUE&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;rtrunc=TRUE&#8288;</span>&rsquo;.
</p>
<p>The ... arguments will be recycled.
</p>


<h3>Author(s)</h3>

<p>adapted from a code of Rob Carnell (library &lsquo;<span class="samp">&#8288;lhs&#8288;</span>&rsquo;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcstoc">mcstoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ceiling(lhs(runif, nsu=10, nsv=10)*10)
</code></pre>

<hr>
<h2 id='Lognormalb'>The Log Normal Distribution parameterized through its mean and standard deviation.</h2><span id='topic+Lognormalb'></span><span id='topic+dlnormb'></span><span id='topic+plnormb'></span><span id='topic+qlnormb'></span><span id='topic+rlnormb'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for a log normal distribution whose 
arithmetic mean equals to &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and standard deviation equals to &lsquo;<span class="samp">&#8288;sd&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlnormb(x, mean = exp(0.5), sd = sqrt(exp(2) - exp(1)), log = FALSE)

plnormb(
  q,
  mean = exp(0.5),
  sd = sqrt(exp(2) - exp(1)),
  lower.tail = TRUE,
  log.p = FALSE
)

qlnormb(
  p,
  mean = exp(0.5),
  sd = sqrt(exp(2) - exp(1)),
  lower.tail = TRUE,
  log.p = FALSE
)

rlnormb(n, mean = exp(0.5), sd = sqrt(exp(2) - exp(1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lognormalb_+3A_x">x</code>, <code id="Lognormalb_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_mean">mean</code></td>
<td>
<p>the mean of the distribution.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the distribution.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_log">log</code>, <code id="Lognormalb_+3A_log.p">log.p</code></td>
<td>
<p>logical. if 'TRUE' probabilities 'p' are given as 'log(p)'.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. if 'TRUE', probabilities are <code class="reqn">P[X \le x]</code>, otherwise,  <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Lognormalb_+3A_n">n</code></td>
<td>
<p>number of observations. If 'length(n) &gt; 1', the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the corresponding density, distribution function, quantile function and random generation 
from the log normal (see <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>) after evaluation of <code class="reqn">meanlog = log(mean^2 / sqrt(sd^2+mean^2))</code> and
<code class="reqn">sqrt{(log(1+sd^2/mean^2))}</code>
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dlnormb&#8288;</span>&rsquo;  gives the density, &lsquo;<span class="samp">&#8288;plnormb&#8288;</span>&rsquo; gives the distribution function, 
&lsquo;<span class="samp">&#8288;qlnormb&#8288;</span>&rsquo; gives the quantile function, and &lsquo;<span class="samp">&#8288;rlnormb&#8288;</span>&rsquo; generates random deviates.
The length of the result is determined by &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; for &lsquo;<span class="samp">&#8288;rlnorm&#8288;</span>&rsquo;, and is the maximum of the lengths 
of the numerical arguments for the other functions. 
The numerical arguments other than &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; are recycled to the length of the result. 
Only the first elements of the logical arguments are used.
</p>
<p>The default &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;sd&#8288;</span>&rsquo; are chosen to provide a distribution close to a lognormal with 
&lsquo;<span class="samp">&#8288;meanlog = 0&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;sdlog = 1&#8288;</span>&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Lognormal">Lognormal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rlnormb(1E5,3,6)
mean(x) 
sd(x)
dlnormb(1) == dnorm(0)
dlnormb(1) == dlnorm(1)

</code></pre>

<hr>
<h2 id='mc'>
Monte Carlo Object
</h2><span id='topic+mc'></span>

<h3>Description</h3>

<p>Creates &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects from <code><a href="#topic+mcnode">mcnode</a></code> or &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc(..., name=NULL, devname=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_+3A_...">...</code></td>
<td>
<p>&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object(s) to be gathered in
a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object separated by a coma.</p>
</td></tr>
<tr><td><code id="mc_+3A_name">name</code></td>
<td>
<p>Vector of character of the same length of the final
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object. If NULL, the name will be given from the name of
the elements. </p>
</td></tr>
<tr><td><code id="mc_+3A_devname">devname</code></td>
<td>
<p>Develop the name from the name of the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;
objects, if any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object is a list of <code><a href="#topic+mcnode">mcnode</a></code> objects.
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects must be of coherent dimensions.
</p>
<p>If one of the arguments is a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object, the name of the
elements of this &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object are used. &lsquo;<span class="samp">&#8288;devname = TRUE&#8288;</span>&rsquo;
will develop the name, using as a prefix the name of the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;
object.
</p>
<p>Finally, names are transformed to be unique.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnode">mcnode</a></code>, the basic element of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>
<p>To evaluate &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects: <code><a href="#topic+mcmodel">mcmodel</a></code>,
<code><a href="#topic+evalmcmod">evalmcmod</a></code>, <code><a href="#topic+evalmccut">evalmccut</a></code>
</p>
<p>Informations about an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object: <code><a href="#topic+is.mc">is.mc</a></code>,
<code><a href="#topic+dimmc">dimmc</a></code>
</p>
<p>To study &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects: <code><a href="#topic+print.mc">print.mc</a></code>,
<code><a href="#topic+summary.mc">summary.mc</a></code>, <code><a href="#topic+plot.mc">plot.mc</a></code>,
<code><a href="#topic+converg">converg</a></code>, <code><a href="#topic+hist.mc">hist.mc</a></code>, <code><a href="#topic+tornado">tornado</a></code>,
<code><a href="#topic+tornadounc.mc">tornadounc.mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
x &lt;- mcstoc(runif)
y &lt;- mcdata(3, type="0")
z &lt;- x * y
(m &lt;- mc(x, y, z, name=c('n1', 'n2', 'n3')))
mc(m, x, devname=TRUE)
</code></pre>

<hr>
<h2 id='mc.control'>
Sets or Gets the Default Number of Simulations.
</h2><span id='topic+mc.control'></span><span id='topic+ndvar'></span><span id='topic+ndunc'></span>

<h3>Description</h3>

<p>Sets or retrieves the default number of simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvar(n)
ndunc(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.control_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;ndvar()&#8288;</span>&rsquo; gets and &lsquo;<span class="samp">&#8288;ndvar(n)&#8288;</span>&rsquo; sets the default number of
simulation in the 1D simulations or the number of simulation in the
variability dimension in the 2D simulations.
</p>
<p>&lsquo;<span class="samp">&#8288;ndunc()&#8288;</span>&rsquo; gets and &lsquo;<span class="samp">&#8288;ndunc(n)&#8288;</span>&rsquo; sets the number of
simulations in the uncertainty dimension in the 2D simulations.
</p>
<p>&lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; is rounded to its ceiling value.
</p>
<p>The default values when loaded are 1001 for &lsquo;<span class="samp">&#8288;ndvar&#8288;</span>&rsquo; and 101 for
&lsquo;<span class="samp">&#8288;ndunc&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>The current value, AFTER modification if &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; is present (!=
&lsquo;<span class="samp">&#8288;options&#8288;</span>&rsquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(oldvar &lt;- ndvar())
(oldunc &lt;- ndunc())
mcstoc(runif, type="VU")
ndvar(12)
ndunc(21)
mcstoc(runif, type="VU")
ndvar(oldvar)
ndunc(oldunc)

</code></pre>

<hr>
<h2 id='mcapply'>
Apply Functions Over mc or mcnode Objects
</h2><span id='topic+mcapply'></span>

<h3>Description</h3>

<p>Apply a function on all values or over a given dimension of an
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object. May be used for all &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of an
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcapply(x, margin=c("all", "var", "unc", "variates"), fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcapply_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="mcapply_+3A_margin">margin</code></td>
<td>
<p>The dimension on which applying the function. Maybe
&lsquo;<span class="samp">&#8288;"all"&#8288;</span>&rsquo; (default) to apply the function on all values,
&lsquo;<span class="samp">&#8288;"var"&#8288;</span>&rsquo; to apply the function on the variability dimension,
&lsquo;<span class="samp">&#8288;"unc"&#8288;</span>&rsquo; to apply the function on the uncertainty dimension, or
&lsquo;<span class="samp">&#8288;"variates"&#8288;</span>&rsquo; to apply the function on the variates. Watch out:
do not use 'var' for 'variates'</p>
</td></tr>
<tr><td><code id="mcapply_+3A_fun">fun</code></td>
<td>
<p>The function to be applied. When applied to a vector of
length &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;fun&#8288;</span>&rsquo; should return a vector of length &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo;
or &lsquo;<span class="samp">&#8288;1&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="mcapply_+3A_...">...</code></td>
<td>
<p>Optional arguments to &lsquo;<span class="samp">&#8288;fun&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If &lsquo;<span class="samp">&#8288;fun&#8288;</span>&rsquo; returns a function of length &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; or if
&lsquo;<span class="samp">&#8288;margin="all"&#8288;</span>&rsquo;, the returned &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s are of type and
dimension of &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;. In other cases, the type of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; is
changed.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>, <code><a href="#topic+mc">mc</a></code>, <code><a href="#topic+mcnode">mcnode</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
xVUM
mcapply(xVUM, "unc", sum)
mcapply(xVUM, "var", sum)
mcapply(xVUM, "all", sum)
mcapply(xVUM, "variates", sum)
mcapply(total, "all", exp)
</code></pre>

<hr>
<h2 id='mccut'>
Evaluates a Two-Dimensional Monte Carlo Model in a Loop.
</h2><span id='topic+mccut'></span><span id='topic+evalmccut'></span><span id='topic+print.mccut'></span><span id='topic+mcmodelcut'></span>

<h3>Description</h3>

<p>&lsquo;<span class="samp">&#8288;evalmccut&#8288;</span>&rsquo; evaluates a Two-Dimensional Monte Carlo model using
a loop on the uncertainty dimension. Within each loop, it calculates
statistics in the variability dimension and stores them for further
analysis. It allows to evaluate very high dimension models using
(unlimited?) time instead of (limited) memory.
</p>
<p>&lsquo;<span class="samp">&#8288;mcmodelcut&#8288;</span>&rsquo; builds a &lsquo;<span class="samp">&#8288;mcmodelcut&#8288;</span>&rsquo; object that can be sent
to &lsquo;<span class="samp">&#8288;evalmccut&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalmccut(model, nsv=ndvar(), nsu=ndunc(), seed=NULL, ind="index")
## S3 method for class 'mccut'
print(x, lim=c(0.025, 0.975), digits=3, ...)
mcmodelcut(x, is.expr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mccut_+3A_model">model</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcmodelcut&#8288;</span>&rsquo; object obtained using
&lsquo;<span class="samp">&#8288;mcmodelcut&#8288;</span>&rsquo; function or (directly) a valid call including three
blocks. See Details and Examples for the structure of the call.</p>
</td></tr>
<tr><td><code id="mccut_+3A_x">x</code></td>
<td>
<p>a call or an expression (if &lsquo;<span class="samp">&#8288;is.expr=TRUE&#8288;</span>&rsquo;) including
three blocks. See Details and Examples for the structure of the
call.</p>
</td></tr>
<tr><td><code id="mccut_+3A_nsv">nsv</code></td>
<td>
<p>The number of simulations for variability used in the
evaluation.</p>
</td></tr>
<tr><td><code id="mccut_+3A_nsu">nsu</code></td>
<td>
<p>The number of simulations for uncertainty used in the
evaluation.</p>
</td></tr>
<tr><td><code id="mccut_+3A_seed">seed</code></td>
<td>
<p>The random seed used for the evaluation. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;
the &lsquo;<span class="samp">&#8288;seed&#8288;</span>&rsquo; is unchanged.</p>
</td></tr>
<tr><td><code id="mccut_+3A_ind">ind</code></td>
<td>
<p>The variable name used in &lsquo;<span class="samp">&#8288;model&#8288;</span>&rsquo; to refers to the
uncertainty. see Details and Example.</p>
</td></tr>
<tr><td><code id="mccut_+3A_is.expr">is.expr</code></td>
<td>
 <p>&lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo; to send a call, &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; to send an
expression (see <code><a href="#topic+mcmodel">mcmodel</a></code> examples)</p>
</td></tr>
<tr><td><code id="mccut_+3A_lim">lim</code></td>
<td>
<p>A vector of values used for the quantile function
(uncertainty dimension).</p>
</td></tr>
<tr><td><code id="mccut_+3A_digits">digits</code></td>
<td>
<p>Number of digits in the print.</p>
</td></tr>
<tr><td><code id="mccut_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed in the final print
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be used for high dimension Two-Dimensional
Monte-Carlo simulations, when the memory limits of <span class="rlang"><b>R</b></span> are attained.
The use of a loop will take (lots of) time, but less memory.
</p>
<p>&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; (or &lsquo;<span class="samp">&#8288;model&#8288;</span>&rsquo; if a call is used directly in
&lsquo;<span class="samp">&#8288;evalmccut&#8288;</span>&rsquo;) should be built as three blocks, separated by
&lsquo;<span class="samp">&#8288;{&#8288;</span>&rsquo;. 
</p>

<ol>
<li><p> The first block is evaluated once (and only once) before the
first loop (step 1).
</p>
</li>
<li><p> The second block, which should lead to an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object, is
evaluated using &lsquo;<span class="samp">&#8288;nsu = 1&#8288;</span>&rsquo; (step 2).
</p>
</li>
<li><p> The third block is evaluated on the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object. All
resulting statistics are stored (step 3).
</p>
</li>
<li><p> The steps 2 and 3 are repeated &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; times. At each
iteration, the values of the loop index (from 1 to &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo;) is
given to the variable specified in &lsquo;<span class="samp">&#8288;ind&#8288;</span>&rsquo;.
</p>
</li>
<li><p> Finally, the &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; statistics are returned in an invisible
object of class &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo;.</p>
</li></ol>

<p>Understanding this, the call should be built like this:
&lsquo;<span class="samp">&#8288;{{block 1}{block 2}{block 3}}&#8288;</span>&rsquo; 
</p>

<ol>
<li><p> The first block (maybe empty) is an expression that will be
evaluated only once. This block should evaluate all &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo;s. It may evaluate and &lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo; that
will be sent in the second and third block by column, and,
optionaly, some other codes (even &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo;, sent by
columns) that can not be evaluated if &lsquo;<span class="samp">&#8288;ndunc=1&#8288;</span>&rsquo; (e.g. sampling
without replacement in the uncertainty dimension).
</p>
</li>
<li><p> The second block is an expression that leads to the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;
object. It must end with an expression as &lsquo;<span class="samp">&#8288;mymc &lt;- mc(...)&#8288;</span>&rsquo;. The
variable specified as &lsquo;<span class="samp">&#8288;ind&#8288;</span>&rsquo; may be helpful to refer to the
uncertainty dimension in this step 
</p>
</li>
<li><p> The last block should build a list of statistics refering to
the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object. The function &lsquo;<span class="samp">&#8288;summary&#8288;</span>&rsquo; should be used if a
summary, a tornado on uncertainty (<code><a href="#topic+tornadounc.mccut">tornadounc.mccut</a></code>) or
a convergence diagnostic <code><a href="#topic+converg">converg</a></code> is needed, the
function <code><a href="#topic+plot.mc">plot.mc</a></code> should be used if a plot is needed,
the function <code><a href="#topic+tornado">tornado</a></code> should be used if a tornado is
needed. Moreover, any other function that leads to a vector, a
matrix, or a list of vector/matrix of statistics evaluated from the
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object may be used. list are time consuming.</p>
</li></ol>

<p>IMPORTANT WARNING: do not forget to affect the results, since the
print method provide only a summary of the results while all data may
be stored in an &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo;. This is a list including statistics
evaluated within the third block. Each list consists of all the
&lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; values obtained. The &lsquo;<span class="samp">&#8288;print.mccut&#8288;</span>&rsquo; method print the
median, the mean, the &lsquo;<span class="samp">&#8288;lim&#8288;</span>&rsquo; quantiles estimated on each
statistics on the uncertainty dimension.
</p>


<h3>Note</h3>

<p>The methods and functions available on the &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object is
function of the statistics evaluated within the third block: 
</p>

<ul>
<li><p> a <code><a href="#topic+print.mccut">print.mccut</a></code> is available as soon as one
statistic is evaluated within the third block;
</p>
</li>
<li><p> a <code><a href="#topic+summary.mccut">summary.mccut</a></code> and a
<code><a href="#topic+tornadounc.mccut">tornadounc.mccut</a></code> are available if a
<code><a href="#topic+summary.mc">summary.mc</a></code> is evaluated within the third block;
</p>
</li>
<li> <p><code><a href="#topic+converg">converg</a></code> may be used if a <code><a href="#topic+summary.mc">summary.mc</a></code>
is evaluated within the third block;
</p>
</li>
<li><p> a <code><a href="#topic+plot.mccut">plot.mccut</a></code> is available if a
<code><a href="#topic+plot.mc">plot.mc</a></code> is evaluated within the third block. (Do not
forget to use the argument &lsquo;<span class="samp">&#8288;draw = FALSE&#8288;</span>&rsquo; in the third block);
</p>
</li>
<li><p> a <code><a href="#topic+tornado">tornado</a></code> is available if a <code><a href="#topic+tornado">tornado</a></code>
is evaluated within the third block.</p>
</li></ul>

<p>The seed is set at the beginning of the evaluation. Thus, the
complete similarity of two evaluations is not certain, depending of
the structure of your model. Moreover, with a similar seed, the
simulation will not be equal to the one obtained with
<code><a href="#topic+evalmcmod">evalmcmod</a></code> since the random samples will not be obtained
in the same order.
</p>
<p>In order to avoid conflicts between the &lsquo;<span class="samp">&#8288;model&#8288;</span>&rsquo; evaluation and
the function, the function uses upper case variables. Do not use
upper case variables in your model.
</p>
<p>The function should be re-adapted if a new function to be applied on
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects is written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalmcmod">evalmcmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modEC3 &lt;- mcmodelcut({

## First block:
## Evaluates all the 0, V and U nodes.
 { cook &lt;- mcstoc(rempiricalD, type = "V", values = c(0, 1/5, 
 1/50), prob = c(0.027, 0.373, 0.6))
 serving &lt;- mcstoc(rgamma, type = "V", shape = 3.93, rate = 0.0806)
 conc &lt;- mcstoc(rnorm, type = "U", mean = 10, sd = 2)
 r &lt;- mcstoc(runif, type = "U", min = 5e-04, max = 0.0015)
 }
## Second block:
## Evaluates all the VU nodes
## Leads to the mc object. 
 {
 expo &lt;- conc * cook * serving
 dose &lt;- mcstoc(rpois, type = "VU", lambda = expo)
 risk &lt;- 1 - (1 - r)^dose
 res &lt;- mc(conc, cook, serving, expo, dose, r, risk)
 }
## Third block:
## Leads to a list of statistics: summary, plot, tornado
## or any function leading to a vector (et), a list (minmax), 
## a matrix or a data.frame (summary)
 {
 list(
 sum = summary(res), 
 plot = plot(res, draw=FALSE), 
 minmax = lapply(res, range)
 )
 }
})

x &lt;- evalmccut(modEC3, nsv = 101, nsu = 101, seed = 666)
summary(x)

</code></pre>

<hr>
<h2 id='mcmodel'>
Monte Carlo model
</h2><span id='topic+mcmodel'></span>

<h3>Description</h3>

<p>Specify a &lsquo;<span class="samp">&#8288;mcmodel&#8288;</span>&rsquo;, without evaluating it, for a further
evaluation using <code><a href="#topic+evalmcmod">evalmcmod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmodel(x, is.expr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmodel_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> call or an expression.</p>
</td></tr>
<tr><td><code id="mcmodel_+3A_is.expr">is.expr</code></td>
<td>
 <p>&lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo; to send a call, &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; to send an
expression (see Examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model should be put between &lsquo;<span class="samp">&#8288;{&#8288;</span>&rsquo; and the last line should be
of the form &lsquo;<span class="samp">&#8288;mc(...)&#8288;</span>&rsquo;. Any reference to the number of simulation
in the dimension of variability should be done via &lsquo;<span class="samp">&#8288;ndvar()&#8288;</span>&rsquo; or
(preferred) &lsquo;<span class="samp">&#8288;nsv&#8288;</span>&rsquo;. Any reference to the number of simulations in
the dimension of uncertainty should be done via &lsquo;<span class="samp">&#8288;ndunc()&#8288;</span>&rsquo; or
(preferred) &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>an <span class="rlang"><b>R</b></span> expression, with class &lsquo;<span class="samp">&#8288;mcmodel&#8288;</span>&rsquo;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expression">expression</a></code>.
</p>
<p><code><a href="#topic+evalmcmod">evalmcmod</a></code> to evaluate the model.
</p>
<p><code><a href="#topic+mcmodelcut">mcmodelcut</a></code> to evaluate high Dimension Monte Carlo
Model in a loop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modEC1 &lt;- mcmodel({
 conc &lt;- mcdata(10, "0")
 cook &lt;- mcstoc(rempiricalD, values=c(0, 1/5, 1/50), prob=c(0.027, 0.373, 0.600))
 serving &lt;- mcstoc(rgamma, shape=3.93, rate=0.0806)
 expo &lt;- conc * cook * serving
 dose &lt;- mcstoc(rpois, lambda=expo)
 risk &lt;- 1-(1-0.001)^dose
 mc(conc, cook, serving, expo, dose, risk)
 })
evalmcmod(modEC1, nsv=100, nsu=100)
</code></pre>

<hr>
<h2 id='mcnode'>
Build mcnode Objects from Data or other mcnode Objects
</h2><span id='topic+mcnode'></span><span id='topic+mcdata'></span><span id='topic+mcdatanocontrol'></span>

<h3>Description</h3>

<p>Creates a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object from a vector, an array or a
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcdata(data, type=c("V", "U", "VU", "0"), nsv=ndvar(), nsu=ndunc(),
	  nvariates=1, outm="each")
mcdatanocontrol(data, type=c("V", "U", "VU", "0"), nsv=ndvar(), nsu=ndunc(),
	  nvariates=1, outm="each")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcnode_+3A_data">data</code></td>
<td>
<p>The numeric/logical vector/matrix/array of data or the
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="mcnode_+3A_type">type</code></td>
<td>
<p>The type of node to be built. By default, a &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo;
node.</p>
</td></tr>
<tr><td><code id="mcnode_+3A_nsv">nsv</code></td>
<td>
<p>The variability dimension (&lsquo;<span class="samp">&#8288;type="V"&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;type="VU"&#8288;</span>&rsquo;) of the node. By default: the current value in
<code><a href="#topic+mc.control">mc.control</a></code></p>
</td></tr>
<tr><td><code id="mcnode_+3A_nsu">nsu</code></td>
<td>
<p>The uncertainty dimension (&lsquo;<span class="samp">&#8288;type="U"&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;type="VU"&#8288;</span>&rsquo;) of the node. By default: the current value in
<code><a href="#topic+mc.control">mc.control</a></code></p>
</td></tr>
<tr><td><code id="mcnode_+3A_nvariates">nvariates</code></td>
<td>
<p>The number of variates. By default: 1</p>
</td></tr>
<tr><td><code id="mcnode_+3A_outm">outm</code></td>
<td>
<p>The output of the &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; for multivariates nodes.
May be &quot;each&quot; (default) if output should be provided for each
variates considered independently, &quot;none&quot; for no output or a vector
of name of function(s) (as a character string) that will be applied
on the variates dimension before any output (ex: &lsquo;<span class="samp">&#8288;"mean"&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;"median"&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;c("min", "max")&#8288;</span>&rsquo;). The function should have no
other arguments and send one value per vector of values (ex. do not
use &lsquo;<span class="samp">&#8288;"range"&#8288;</span>&rsquo;). Note that the &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute may be
changed at any time using the <code><a href="#topic+outm">outm</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object is the basic element of a <code><a href="#topic+mc">mc</a></code>
object. It is an array of dimension &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo;.
Four types of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; exists:
</p>

<ul>
<li> <p>&lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;, for &quot;Variability&quot;, are arrays of dimension
&lsquo;<span class="samp">&#8288;(nsv x 1 x nvariates)&#8288;</span>&rsquo;. The alea in the data should reflect
variability of the parameter.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo;, for &quot;Uncertainty&quot;, are arrays of dimension
&lsquo;<span class="samp">&#8288;c(1 x nsu x nvariates)&#8288;</span>&rsquo;. The alea in the data should reflect
uncertainty of the parameter.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo;, for &quot;Variability and Uncertainty&quot;, are
arrays of dimension &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo;. The alea in the
data reflects separated variability (in rows) and uncertainty (in
columns) of the parameter.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo;, for &quot;Neither Variability or Uncertainty&quot;,
are arrays of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x nvariates)&#8288;</span>&rsquo;. No alea is
considered for these nodes. &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo; are not necessary in
the univariate context (use scalar instead) but may be useful for
operations on multivariate nodes.</p>
</li></ul>

<p>Multivariate nodes (i.e. &lsquo;<span class="samp">&#8288;nvariates != 1&#8288;</span>&rsquo;) should be used for
multivariate distributions implemented in &lsquo;<span class="samp">&#8288;mc2d&#8288;</span>&rsquo;
(<code><a href="#topic+rmultinomial">rmultinomial</a></code>, <code><a href="#topic+rmultinormal">rmultinormal</a></code>,
<code><a href="#topic+rempiricalD">rempiricalD</a></code> and <code><a href="#topic+rdirichlet">rdirichlet</a></code>).
</p>
<p>For security, recycling rules are limited to fill the array using
&lsquo;<span class="samp">&#8288;data&#8288;</span>&rsquo;. The general rules is that recycling is only permitted to
fill a dimension from 1 to the final size of the dimension.
</p>
<p>If the final dimension of the node is &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo;
(with &lsquo;<span class="samp">&#8288;nsv = 1&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;nsu = 1&#8288;</span>&rsquo; for &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; nodes,
&lsquo;<span class="samp">&#8288;nsu = 1&#8288;</span>&rsquo; for &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; nodes and &lsquo;<span class="samp">&#8288;nsv = 1&#8288;</span>&rsquo; for &lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo;
nodes), &lsquo;<span class="samp">&#8288;mcdata&#8288;</span>&rsquo; accepts : 
</p>

<ul>
<li><p> Vectors of length &lsquo;<span class="samp">&#8288;1&#8288;</span>&rsquo; (recycled on all dimensions),
vectors of length &lsquo;<span class="samp">&#8288;(nsv * nsu)&#8288;</span>&rsquo; (filling first the dimension of
variability, then the dimension of uncertainty then recycling on
nvariates), or vectors of length &lsquo;<span class="samp">&#8288;(nsv * nsu * nvariates)&#8288;</span>&rsquo;
(filling first the dimension of variability, then the uncertainty,
then the variates).
</p>
</li>
<li><p> Matrixes of dimensions &lsquo;<span class="samp">&#8288;(nsv x nsu)&#8288;</span>&rsquo;, recycling on
variates.
</p>
</li>
<li><p> Arrays of dimensions &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;(nsv x nsu x 1)&#8288;</span>&rsquo;, recycling on variates.
</p>
</li>
<li><p> For &lsquo;<span class="samp">&#8288;data&#8288;</span>&rsquo; as &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;, recycling is dealt to proper
fill the array:</p>

<ol>
<li><p> a &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; node accepts a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; node of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x nvariates)&#8288;</span>&rsquo; (recycling on variability) or of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycling on variability and variates), or a
&lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; node of dimension &lsquo;<span class="samp">&#8288;(nsv x 1 x nvariates)&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;(nsv x 1 x 1)&#8288;</span>&rsquo; (recycling on variates),
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo; node accepts a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; node of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x nvariates)&#8288;</span>&rsquo; (recycling on uncertainty) or of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycling on uncertainty and variates), or a
&lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo; node of dimension &lsquo;<span class="samp">&#8288;(1 x nsu x nvariates)&#8288;</span>&rsquo;, or
&lsquo;<span class="samp">&#8288;(1 x nsu x 1)&#8288;</span>&rsquo; (recycling on variates),
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo; node accepts a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; node of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x nvariates)&#8288;</span>&rsquo; (recycling on variability and
uncertainty) or of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycling on
variability, uncertainty and variates), a &lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo; node of
dimension &lsquo;<span class="samp">&#8288;(1 x nsu x nvariates)&#8288;</span>&rsquo;(recycling &quot;by row&quot; on the
variability dimension), or of dimension &lsquo;<span class="samp">&#8288;(1 x nsu x 1)&#8288;</span>&rsquo;(recycled
&quot;by row&quot; on the variability dimension then on variates), a &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo;
node of dimension &lsquo;<span class="samp">&#8288;(nsv x 1 x nvariates)&#8288;</span>&rsquo;(recycling on the
uncertainty dimension) or of dimension &lsquo;<span class="samp">&#8288;(nsv x 1 x 1)&#8288;</span>&rsquo;(recycled
on the uncertainty dimension then on variates), and a &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo;
node of dimension &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo; or of dimension
&lsquo;<span class="samp">&#8288;(nsv x nsu x 1)&#8288;</span>&rsquo; (recycling on variates).
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; node accepts a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; node of dimension
&lsquo;<span class="samp">&#8288;(1 x 1 x nvariates)&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycling on
variates).</p>
</li></ol>

</li></ul>

<p>&lsquo;<span class="samp">&#8288;mcdatanocontrol&#8288;</span>&rsquo; is a dangerous version of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; which
forces the dimension of data to be &lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo; and
gives the attributes and the class without any control. This function
is useful when your model is tested since it is much more quicker.
</p>


<h3>Value</h3>

<p>An &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcstoc">mcstoc</a></code> to build a stochastic &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object,
<code><a href="#topic+mcprobtree">mcprobtree</a></code> to build a stochastic node fro a probability
tree.
</p>
<p><code><a href="#topic+Ops.mcnode">Ops.mcnode</a></code> for operations on &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects.
</p>
<p><code><a href="#topic+mc">mc</a></code> to build a Monte-Carlo object.
</p>
<p>Informations about an mcnode: <code><a href="#topic+is.mcnode">is.mcnode</a></code>,
<code><a href="#topic+dimmcnode">dimmcnode</a></code>, <code><a href="#topic+typemcnode">typemcnode</a></code>.
</p>
<p>To build a correlation structure between &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;:
<code><a href="#topic+cornode">cornode</a></code>.
</p>
<p>To study &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects: <code><a href="#topic+print.mcnode">print.mcnode</a></code>,
<code><a href="#topic+summary.mcnode">summary.mcnode</a></code>, <code><a href="#topic+plot.mcnode">plot.mcnode</a></code>,
<code><a href="#topic+converg">converg</a></code>, <code><a href="#topic+hist.mcnode">hist.mcnode</a></code>
</p>
<p>To modify &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects: <code><a href="#topic+NA.mcnode">NA.mcnode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldvar &lt;- ndvar()
oldunc &lt;- ndunc()
ndvar(3)
ndunc(5)

(x0 &lt;- mcdata(100, type="0"))
mcdata(matrix(100), type="0")

(xV &lt;- mcdata(1:ndvar(), type="V"))
mcdata(matrix(1:ndvar(), ncol=1), type="V")

(xU &lt;- mcdata(10*1:ndunc(), type="U"))
mcdata(matrix(10*1:ndunc(), nrow=1), type="U")

(xVU &lt;- mcdata(1:(ndvar()*ndunc()), type="VU"))
mcdata(matrix(1:(ndvar()*ndunc()), ncol=5, nrow=3), type="VU")

##Do not use
## Not run: 
mcdata(matrix(1:5, nrow=1), type="VU")

## End(Not run)
##use instead
mcdata(mcdata(matrix(1:ndunc(), nrow=1), type="U"), "VU")
##or
mcdata(matrix(1:ndunc(), nrow=1), type="U") + mcdata(0, "VU")

mcdata(x0, type="0")

mcdata(x0, type="V")
mcdata(xV, type="V")

mcdata(x0, type="U")
mcdata(xU, type="U")

mcdata(x0, type="VU")
mcdata(xU, type="VU")
mcdata(xV, type="VU")

##Multivariates
(x0M &lt;- mcdata(1:2, type="0", nvariates=2))
mcdata(1, type="0", nvariates=2)

(xVM &lt;- mcdata(1:(2*ndvar()), type="V", nvariates=2))
mcdata(1:ndvar(), type="V", nvariates=2)
mcdata(array(1:(2*ndvar()), dim=c(3, 1, 2)), type="V", nvariates=2)

mcdata(1, type="V", nvariates=2)
mcdata(x0, type="V", nvariates=2)
mcdata(x0M, type="V", nvariates=2)
mcdata(xV, type="V", nvariates=2)
mcdata(xVM, type="V", nvariates=2)

(xUM &lt;- mcdata(10*(1:(2*ndunc())), type="U", nvariates=2))
mcdata(array(10*(1:(2*ndunc())), dim=c(1, 5, 2)), type="U", nvariates=2)

mcdata(1, type="U", nvariates=2)
mcdata(x0, type="U", nvariates=2)
mcdata(x0M, type="U", nvariates=2)
mcdata(xU, type="U", nvariates=2)
mcdata(xUM, type="U", nvariates=2)

(xVUM &lt;- mcdata(1:(ndvar()*ndunc()), type="VU", nvariates=2))
mcdata(array(1:(ndvar()*ndunc()), dim=c(3, 5, 2)), type="VU", nvariates=2)

mcdata(1, type="VU", nvariates=2)
mcdata(x0, type="VU", nvariates=2)
mcdata(x0M, type="VU", nvariates=2)
mcdata(xV, type="VU", nvariates=2)
mcdata(xVM, type="VU", nvariates=2)
mcdata(xU, type="VU", nvariates=2)
mcdata(xUM, type="VU", nvariates=2)
mcdata(xVU, type="VU", nvariates=2)
mcdata(xVUM, type="VU", nvariates=2)

ndvar(oldvar)
ndunc(oldunc)

</code></pre>

<hr>
<h2 id='mcprobtree'>
Creates a Stochastic mcnode Object using a Probability Tree
</h2><span id='topic+mcprobtree'></span>

<h3>Description</h3>

<p>This function builds an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; as a mixture &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcprobtree(mcswitch, mcvalues, type=c("V", "U", "VU", "0"), nsv=ndvar(),
	  nsu=ndunc(), nvariates=1, outm="each", seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcprobtree_+3A_mcswitch">mcswitch</code></td>
<td>
<p>A vector of probabilities/weights or an
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_mcvalues">mcvalues</code></td>
<td>
<p>A named list of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s, &lsquo;<span class="samp">&#8288;mcdata&#8288;</span>&rsquo;
functions or &lsquo;<span class="samp">&#8288;mcstoc&#8288;</span>&rsquo; functions, or a combination of those
objects. Each element should be or lead to a compatible &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;
(see Details). </p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_type">type</code></td>
<td>
<p>The type of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; to be built. By default, a
&lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; node. see <code><a href="#topic+mcnode">mcnode</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_nsv">nsv</code></td>
<td>
<p>The number of simulations in the variability dimension of
the final node.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_nsu">nsu</code></td>
<td>
<p>The number of simulations in the uncertainty dimension of
the final node.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_nvariates">nvariates</code></td>
<td>
<p>The number of variates of the final &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_outm">outm</code></td>
<td>
<p>The default output of the &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; for multivariates
nodes. see <code><a href="#topic+outm">outm</a></code>.</p>
</td></tr>
<tr><td><code id="mcprobtree_+3A_seed">seed</code></td>
<td>
<p>The random seed used for the evaluation. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;
the &lsquo;<span class="samp">&#8288;seed&#8288;</span>&rsquo; is unchanged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;mcswitch&#8288;</span>&rsquo; may be either: 
</p>

<ul>
<li><p> a vector of weights. They need not sum to one, but they should
be nonnegative and not all zero. The length of this vector should
equal the number of elements in the list &lsquo;<span class="samp">&#8288;mcvalues&#8288;</span>&rsquo;. Each
elements of &lsquo;<span class="samp">&#8288;mcvalues&#8288;</span>&rsquo; will appear in the final sample a random
number of times with probability as specified by this vector.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"0 mcnode"&#8288;</span>&rsquo; to build any type of node.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"V mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"V mcnode"&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;"VU
mcnode"&#8288;</span>&rsquo;.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"U mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"U mcnode"&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;"VU
mcnode"&#8288;</span>&rsquo;.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"VU mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"VU mcnode"&#8288;</span>&rsquo;.</p>
</li></ul>

<p>Each elements of &lsquo;<span class="samp">&#8288;mcvalues&#8288;</span>&rsquo; may be either: 
</p>

<ul>
<li><p> a &lsquo;<span class="samp">&#8288;"0 mcnode"&#8288;</span>&rsquo; to build any type of node.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"V mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"V mcnode"&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;"VU
mcnode"&#8288;</span>&rsquo;.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"U mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"U mcnode"&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;"VU
mcnode"&#8288;</span>&rsquo;.
</p>
</li>
<li><p> a &lsquo;<span class="samp">&#8288;"VU mcnode"&#8288;</span>&rsquo; to build a &lsquo;<span class="samp">&#8288;"VU mcnode"&#8288;</span>&rsquo;.</p>
</li></ul>

<p>Their name should correspond to the values in &lsquo;<span class="samp">&#8288;mcswitch&#8288;</span>&rsquo;,
specified as character (See Examples). These elements will be
evaluated only if needed : if the corresponding value is not present
in &lsquo;<span class="samp">&#8288;mcswitch&#8288;</span>&rsquo;, the element will not be evaluated.
</p>


<h3>Value</h3>

<p>An &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcdata">mcdata</a></code>, <code><a href="#topic+mcstoc">mcstoc</a></code>, <code><a href="base.html#topic+switch">switch</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A mixture of normal (prob=0.75), uniform (prob=0.20) and constant (prob=0.05)
conc1 &lt;- mcstoc(rnorm, type="VU", mean=10, sd=2)
conc2 &lt;- mcstoc(runif, type="VU", min=-6, max=-5)
conc3 &lt;- mcdata(0, type="VU")

## Randomly in the cells 
whichdist &lt;- mcstoc(rempiricalD, type="VU", values=1:3, prob= c(.75, .20, .05)) 
mcprobtree(whichdist, list("1"=conc1, "2"=conc2, "3"=conc3), type="VU")
## Which is equivalent to 
mcprobtree(c(.75, .20, .05), list("1"=conc1, "2"=conc2, "3"=conc3), type="VU")
## Not that there is no control on the exact number of occurences.

## Randomly by colums (Uncertainty) 
whichdist &lt;- mcstoc(rempiricalD, type="U", values=1:3, prob= c(.75, .20, .05)) 
mcprobtree(whichdist, list("1"=conc1, "2"=conc2, "3"=conc3), type="VU")

## Randomly by line (Variability) 
whichdist &lt;- mcstoc(rempiricalD, type="V", values=1:3, prob= c(.75, .20, .05)) 
mcprobtree(whichdist, list("1"=conc1, "2"=conc2, "3"=conc3), type="VU")

## The elements of mcvalues may be of various (but compatible) type
conc1 &lt;- mcstoc(rnorm, type="V", mean=10, sd=2)
conc2 &lt;- mcstoc(runif, type="U", min=-6, max=-5)
conc3 &lt;- mcdata(0, type="0")
whichdist &lt;- mcstoc(rempiricalD, type="VU", values=1:3, prob= c(.75, .20, .05))
mcprobtree(whichdist, list("1"=conc1, "2"=conc2, "3"=conc3), type="VU")


</code></pre>

<hr>
<h2 id='mcratio'>
Ratio of uncertainty and the variability
</h2><span id='topic+mcratio'></span>

<h3>Description</h3>

<p>Provides measures of variability, uncertainty, and both combined for
an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcratio(x, pcentral=.5, pvar=.975, punc=.975, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcratio_+3A_x">x</code></td>
<td>
<p>an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object</p>
</td></tr>
<tr><td><code id="mcratio_+3A_pcentral">pcentral</code></td>
<td>
<p>the quantile for the central tendency.</p>
</td></tr>
</table>
<p>. 
</p>
<table>
<tr><td><code id="mcratio_+3A_pvar">pvar</code></td>
<td>
<p>the quantile for the measure of variability.</p>
</td></tr>
<tr><td><code id="mcratio_+3A_punc">punc</code></td>
<td>
<p>the quantile for the measure of uncertainty.</p>
</td></tr>
<tr><td><code id="mcratio_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates three ratios for each &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;. Given: 
</p>

<dl>
<dt>A</dt><dd><p>the &lsquo;<span class="samp">&#8288;(100 * pcentral)&#8288;</span>&rsquo;th percentile of uncertainty (by
default the median) for the &lsquo;<span class="samp">&#8288;(100 * pcentral)&#8288;</span>&rsquo;th percentile of
variability</p>
</dd>
<dt>B</dt><dd><p>the &lsquo;<span class="samp">&#8288;(100 * pcentral)&#8288;</span>&rsquo;th percentile of uncertainty for
the &lsquo;<span class="samp">&#8288;(100 * pvar)&#8288;</span>&rsquo;th percentile of variability</p>
</dd>
<dt>C</dt><dd><p>the &lsquo;<span class="samp">&#8288;(100 * punc)&#8288;</span>&rsquo;th percentile of uncertainty for the
&lsquo;<span class="samp">&#8288;(100 * pcentral)&#8288;</span>&rsquo;th percentile of variability</p>
</dd>
<dt>D</dt><dd><p>the &lsquo;<span class="samp">&#8288;(100 * punc)&#8288;</span>&rsquo;th percentile of uncertainty for the
&lsquo;<span class="samp">&#8288;(100 * pvar)&#8288;</span>&rsquo;th percentile of variability</p>
</dd></dl>

<p>The following ratio are estimated 
</p>

<ul>
<li><p> Variability Ratio: B / A
</p>
</li>
<li><p> Uncertainty Ratio: C / A
</p>
</li>
<li><p> Overall Uncertainty Ratio: D / A</p>
</li></ul>

<p>For multivariate nodes, the statistics are evaluate on each dimension
or on statistics according to the corresponding &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; value.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>References</h3>

<p>Ozkaynak, H., Frey, H.C., Burke, J., Pinder, R.W. (2009) &quot;Analysis of
coupled model uncertainties in source-to-dose modeling of human
exposures to ambient air pollution: A PM2.5 case study&quot;, Atmospheric
environment, Volume 43, Issue 9, March 2009, Pages 1641-1649.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
mcratio(total, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='mcstoc'>
Creates Stochastic mcnode Objects
</h2><span id='topic+mcstoc'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+mcnode">mcnode</a></code> object using a random generating
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcstoc(func=runif, type=c("V", "U", "VU", "0"), ..., nsv=ndvar(),
	  nsu=ndunc(), nvariates=1, outm="each", nsample="n",
	  seed=NULL, rtrunc=FALSE, linf=-Inf, lsup=Inf, lhs=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcstoc_+3A_func">func</code></td>
<td>
<p>A function providing random data or its name as
character.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_type">type</code></td>
<td>
<p>The type of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; to be built. By default, a
&lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; node. see <code><a href="#topic+mcnode">mcnode</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_...">...</code></td>
<td>
<p>All other arguments but the size of the sample to be
passed to &lsquo;<span class="samp">&#8288;func&#8288;</span>&rsquo;. These arguments should be vectors or
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s (arrays prohibited).</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_nsv">nsv</code></td>
<td>
<p>The number of simulations in the variability dimension.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_nsu">nsu</code></td>
<td>
<p>The number of simulations in the uncertainty dimension.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_nvariates">nvariates</code></td>
<td>
<p>The number of variates of the output.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_outm">outm</code></td>
<td>
<p>The output of the &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; for multivariates nodes.
May be &quot;each&quot; (default) if an output should be provided for each
variates considered independently, &quot;none&quot; for no output or a vector
of functions (as a character string) that will be applied on the
variates dimension before any output (ex: &lsquo;<span class="samp">&#8288;"mean"&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;"median"&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;c("min","max")&#8288;</span>&rsquo;). Each function should return
1 value when applied to 1 value (ex. do not use &lsquo;<span class="samp">&#8288;"range"&#8288;</span>&rsquo;). Note
that the &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute may be changed further using the
<code><a href="#topic+outm">outm</a></code> function.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_nsample">nsample</code></td>
<td>
<p>The name of the parameter of the function giving the
size of the vector. By default, &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo;, as in most of the random
sampling distributions of the &lsquo;<span class="samp">&#8288;stats&#8288;</span>&rsquo; library (with the
exceptions of &lsquo;<span class="samp">&#8288;rhyper&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;rwilcox&#8288;</span>&rsquo; where
&lsquo;<span class="samp">&#8288;nsample="nn"&#8288;</span>&rsquo; should be used).</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_seed">seed</code></td>
<td>
<p>The random seed used for the evaluation. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;
the &lsquo;<span class="samp">&#8288;seed&#8288;</span>&rsquo; is unchanged.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_rtrunc">rtrunc</code></td>
<td>
<p>Should the distribution be truncated? See
<code><a href="#topic+rtrunc">rtrunc</a></code>.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_linf">linf</code></td>
<td>
<p>If truncated: lower limit. May be a scalar, an array or a
mcnode.</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_lsup">lsup</code></td>
<td>
<p>If truncated: upper limit. May be a scalar, an array or a
mcnode. &lsquo;<span class="samp">&#8288;lsup&#8288;</span>&rsquo; should be pairwise strictly greater then
&lsquo;<span class="samp">&#8288;linf&#8288;</span>&rsquo;</p>
</td></tr>
<tr><td><code id="mcstoc_+3A_lhs">lhs</code></td>
<td>
<p>Should a Random Latin Hypercube Sampling be used? see
<code><a href="#topic+lhs">lhs</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after ... must match exactly.
</p>
<p>Any function who accepts vectors/matrix as arguments may be used
(notably: all current random generator of the &lsquo;<span class="samp">&#8288;stats&#8288;</span>&rsquo; package).
The arguments may be sent classically but it is STRONGLY recommended
to use consistent &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s if arguments should be recycled,
since a very complex recycling is handled for &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; and not
for vectors. The rules for compliance of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; arguments are
as following (see below for special functions): 
</p>

<dl>
<dt>type=&quot;V&quot;</dt><dd><p>accepts &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x
nvariates)&#8288;</span>&rsquo; or of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycled) and
&lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(nsv x 1 x nvariates)&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;(nsv x 1 x 1)&#8288;</span>&rsquo; (recycled).</p>
</dd>
<dt>type=&quot;U&quot;</dt><dd><p>accepts &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x
nvariates)&#8288;</span>&rsquo; or of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycled) and
&lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x nsu x nvariates)&#8288;</span>&rsquo; or of
dimension &lsquo;<span class="samp">&#8288;(1 x nsu x 1)&#8288;</span>&rsquo; (recycled).</p>
</dd>
<dt>type=&quot;VU&quot;</dt><dd><p>accepts &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x 1
x nvariates)&#8288;</span>&rsquo; or of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycled),
&lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(nsv x 1 x nvariates)&#8288;</span>&rsquo; (recycled
classically) or &lsquo;<span class="samp">&#8288;(nsv x 1 x 1)&#8288;</span>&rsquo; (recycled classically), &lsquo;<span class="samp">&#8288;"U"
mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x nsu x nvariates)&#8288;</span>&rsquo; (recycled by rows)
or &lsquo;<span class="samp">&#8288;(1 x nsu x 1)&#8288;</span>&rsquo; (recycled by row on the uncertainty dimension
and classically on variates), &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo; of dimension
&lsquo;<span class="samp">&#8288;(nsv x nsu x nvariates)&#8288;</span>&rsquo; or of dimension &lsquo;<span class="samp">&#8288;(nsv x nsu x 1)&#8288;</span>&rsquo;
(recycled).</p>
</dd>
<dt>type=&quot;0&quot;</dt><dd><p>accepts &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo; of dimension &lsquo;<span class="samp">&#8288;(1 x 1 x
nvariates)&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;(1 x 1 x 1)&#8288;</span>&rsquo; (recycled).</p>
</dd></dl>

<p>Multivariate nodes and multivariate distributions:
</p>
<p>The number of variates should be provided (not guesses by the
function). A multivariates node may be built using a univariate
distribution and &lsquo;<span class="samp">&#8288;nvariates!=1&#8288;</span>&rsquo;. See examples.
</p>
<p><code><a href="#topic+rdirichlet">rdirichlet</a></code> needs for &lsquo;<span class="samp">&#8288;alpha&#8288;</span>&rsquo; a vector or a
multivariates nodes and returns a multivariate node.
<code><a href="#topic+rmultinomial">rmultinomial</a></code> needs for &lsquo;<span class="samp">&#8288;size&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo;
vectors and/or multivariate nodes and return a univariate or a
multivariate node. <code><a href="#topic+rmultinormal">rmultinormal</a></code> needs for &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;sigma&#8288;</span>&rsquo; vectors and/or multivariate nodes and return a
multivariate node. <code><a href="#topic+rempiricalD">rempiricalD</a></code> needs for &lsquo;<span class="samp">&#8288;values&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;prob&#8288;</span>&rsquo; vectors and/or multivariate nodes and return a a
univariate or a multivariate node. See examples.
</p>
<p>&lsquo;<span class="samp">&#8288;trunc=TRUE&#8288;</span>&rsquo; is valid for univariates distributions only. The
distribution will be truncated on &lsquo;<span class="samp">&#8288;(linf, lsup]&#8288;</span>&rsquo;. The function
'func' should have a 'q' form (with first argument 'p') and a 'p'
form, as all current random generator of the &lsquo;<span class="samp">&#8288;stats&#8288;</span>&rsquo; library.
Example : 'rnorm' (has a 'qnorm' and a 'pnorm' form), 'rbeta',
'rbinom', 'rgamma', ...
</p>
<p>If &lsquo;<span class="samp">&#8288;lhs=TRUE&#8288;</span>&rsquo;, a Random Hypercube Sampling will be used on
&lsquo;<span class="samp">&#8288;nsv&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; The function 'func' should have a 'q' form
(with argument 'p'). &lsquo;<span class="samp">&#8288;lhs=TRUE&#8288;</span>&rsquo; is thus not allowed on
multivariates distributions.
</p>


<h3>Value</h3>

<p>An &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnode">mcnode</a></code> for a description of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object,
methods and functions on &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects.
</p>
<p><code><a href="#topic+Ops.mcnode">Ops.mcnode</a></code> for operations on &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects.
<code><a href="#topic+rtrunc">rtrunc</a></code> for important warnings on the use of the
&lsquo;<span class="samp">&#8288;trunc&#8288;</span>&rsquo; option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Oldnvar &lt;- ndvar()
Oldnunc &lt;- ndunc()
ndvar(5)
ndunc(4)

## compatibility with mcdata as arguments
x0 &lt;- mcstoc(runif, type="0")
xV &lt;- mcstoc(runif, type="V")
xU &lt;- mcstoc(runif, type="U")
xVU &lt;- mcstoc(runif, type="VU")

## "0" accepts mcdata "0"
mcstoc(runif, type="0", min=-10, max=x0)

## "V" accepts "0" mcdata and "V" mcdata
mcstoc(rnorm, type="V", mean=x0, sd=xV)

## "U" accepts "0" mcdata and "U" mcdata
mcstoc(rnorm, type="U", mean=x0, sd=xU)

## "VU" accepts "0" mcdata, "U" mcdata
## "V" mcdata and "U" mcdata with correct recycling
mcstoc(rnorm, type="VU", mean=x0, sd=xVU)
mcstoc(rnorm, type="VU", mean=xV, sd=xU)

## any function giving a set (vector/matrix) of value of length 'size' works
f &lt;- function(popi) 1:popi
mcstoc(f, type="V", nsample="popi")

##Multivariates

ndvar(2)
ndunc(5)
##Build a multivariate node with univariate distribution
mcstoc(rnorm, "0", nvariates=3)
mcstoc(rnorm, "V", nvariates=3)
mcstoc(rnorm, "U", nvariates=3)
mcstoc(rnorm, "VU", nvariates=3)

##Build a multivariate node with multivariates distribution
alpha &lt;- mcdata(c(1, 1000, 10, 100, 100, 10, 1000, 1), "V", nvariates=4)
(p &lt;- mcstoc(rdirichlet, "V", alpha=alpha, nvariates=4))
mcstoc(rmultinomial, "VU", size=10, p, nvariates=4)

##Build a univariates node with "multivariates" distribution
size &lt;- mcdata(c(1:5), "U")
mcstoc(rmultinomial, "VU", size, p, nvariates=1) #since a multinomial return one value

##Build a multivariates node with "multivariates" distribution
mcstoc(rmultinomial, "VU", size, p, nvariates=4) #sent 4 times to fill the array

##Use of rempiricalD with nodes
##A bootstrap
ndunc(5)
ndvar(5)
dataset &lt;- c(1:9)
(b &lt;- mcstoc(rempiricalD, "U", nvariates=9, values=dataset))
unclass(b)
##Then we build a VU node by sampling in each set of bootstrap
(node &lt;- mcstoc(rempiricalD, "VU", values=b))
unclass(node)

## truncated
ndvar(2)
ndunc(5)
linf &lt;- mcdata(-1:3, "U")
x &lt;- mcstoc(rnorm, "VU", rtrunc=TRUE, linf=linf)
unclass(round(x))
linf &lt;- mcdata(1:5, "U")
mcstoc(rnorm, "VU", nsv=100, rtrunc=TRUE, linf=linf, lhs=TRUE)

ndvar(Oldnvar)
ndunc(Oldnunc)
</code></pre>

<hr>
<h2 id='MinimumQuantileInformation'>Minimum Quantile Information Distribution</h2><span id='topic+MinimumQuantileInformation'></span><span id='topic+dmqi'></span><span id='topic+pmqi'></span><span id='topic+qmqi'></span><span id='topic+rmqi'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for Minimum Quantile Information distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmqi(x, 
  mqi, 
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL, 
  k = 0.1, 
  intrinsic = NA,
  log = FALSE)

pmqi(q, 
  mqi, 
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL,
  k = 0.1,
  intrinsic = NA,
  lower.tail = TRUE,
  log.p = FALSE
)

qmqi(p, 
  mqi, 
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL, 
  k = 0.1, 
  intrinsic = NA,
  lower.tail = TRUE, 
  log.p = FALSE
)

rmqi(n, 
  mqi, 
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL, 
  k=0.1, 
  intrinsic = NA
)

pmqi(
  q,
  mqi,
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL,
  k = 0.1,
  intrinsic = NA,
  lower.tail = TRUE,
  log.p = FALSE
)

qmqi(
  p,
  mqi,
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL,
  k = 0.1,
  intrinsic = NA,
  lower.tail = TRUE,
  log.p = FALSE
)

rmqi(
  n,
  mqi,
  mqi.quantile = c(0.05, 0.5, 0.95),
  realization = NULL,
  k = 0.1,
  intrinsic = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinimumQuantileInformation_+3A_x">x</code>, <code id="MinimumQuantileInformation_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_mqi">mqi</code></td>
<td>
<p>Minimum quantile information</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_mqi.quantile">mqi.quantile</code></td>
<td>
<p>The quantile of &lsquo;mqi'. It&rsquo;s a vector of length 3. Default is 'c(0.05, 0.5, 0.95)', 
that is the 5th, 50th and 95th.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_realization">realization</code></td>
<td>
<p>Default is 'NULL'. If not 'NULL', used to define 'L' or 'U' (see details).</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_k">k</code></td>
<td>
<p>Overshot, default value is 0.1.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_intrinsic">intrinsic</code></td>
<td>
<p>Use to specify a prior bounds of the intrinsic range. Default = 'NA'.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_log">log</code>, <code id="MinimumQuantileInformation_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if 'TRUE', probabilities 'p' are given as 'log(p)'.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if 'TRUE' (default), probabilities are 'P[X &lt;= x]' otherwise, 'P[X &gt; x]'.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="MinimumQuantileInformation_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">p_1</code>, <code class="reqn">p_2</code>, and <code class="reqn">p_3</code> are percentiles of a distribution with <code class="reqn">p_1 &lt; p_2 &lt; p_3</code>. 
The interval <code class="reqn">[L,U]</code> is given with:
</p>
<p style="text-align: center;"><code class="reqn">L = x_{p_{1}}</code>
</p>

<p style="text-align: center;"><code class="reqn">U = x_{p_{3}}</code>
</p>

<p>The support of minimum quantile information distribution is determined by the intrinsic range:
</p>
<p style="text-align: center;"><code class="reqn">[L^{*}, U^{*}] = [L - k \times (U - L), U + k \times (U - L)]</code>
</p>

<p>where <code class="reqn">k</code> denotes an overshoot and is chosen by the analyst (usually <code class="reqn">k = 10\%</code>, which is the default value).
</p>
<p>Given the three values of quantile, <code class="reqn">x_{p_1}</code>, <code class="reqn">x_{p_2}</code> and <code class="reqn">x_{p_3}</code>, 
and define <code class="reqn">p_0 = 0</code>, <code class="reqn">p_4 = 1</code>, <code class="reqn">x_{p_0} = L^{*}</code> and <code class="reqn">x_{p_4} = U^{*}</code>
the minimum quantile information distribution is given by:
</p>
<p>Probability density function 
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{p_{i}-p_{i-1}}{x_{p_{i}}-x_{p_{i-1}}} \text{ for } x_{p_{i-1}} \le x &lt; x_{p_{i}},
 i = 1,\dots,4</code>
</p>

<p style="text-align: center;"><code class="reqn">f(x) = 0, \text{ otherwise}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(x) = 0 \text{ for } x &lt; x_{p_{0}}</code>
</p>

<p style="text-align: center;"><code class="reqn">F(x) = \frac{p_{i}-p_{i-1}}{x_{p_{i}}-x_{p_{i-1}}}*(x-x_{p_{i-1}})+p_{i-1} \text{ for } x_{p_{i-1}} \le x &lt; x_{p_{i}}, i = 1,\dots,4</code>
</p>

<p style="text-align: center;"><code class="reqn">F(x) = 1 \text{ for } x_{p_{4}}\le x</code>
</p>

<p>This distribution is usually used for expert elicitation.
If experts have realization information, then the range <code class="reqn">[L,U]</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">L = \min(x_{p_{1}}, realization)</code>
</p>

<p style="text-align: center;"><code class="reqn">U = \max(x_{p_{3}}, realization)</code>
</p>

<p>For some questions, experts may have information for the intrinsic range and set a prior intrinsic range (<code class="reqn">L^*</code> and <code class="reqn">U^*</code>).
</p>
<p>NOTE that the function is vectorized only for x, q, p, n. As a consequence, it can't be used 
for variable other parameters.
</p>


<h3>Author(s)</h3>

<p>Yu Chen and Arie Havelaar
</p>


<h3>References</h3>

<p>Hanea, A. M., &amp; Nane, G. F. (2021). An in-depth perspective on the classical model. In International Series in Operations Research &amp; Management Science (pp. 225–256). Springer International Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
curve(dmqi(x, mqi=c(40,50,60), intrinsic=c(0,100)), from=0, to=100, type = "l", xlab="x",ylab="pdf")
curve(pmqi(x, mqi=c(40,50,60), intrinsic=c(0,100)), from=0, to=100, type = "l", xlab="x",ylab="cdf")
rmqi(n = 10, mqi=c(555, 575, 586))
</code></pre>

<hr>
<h2 id='multinormal'>
The Vectorized Multivariate Random Deviates
</h2><span id='topic+multinormal'></span><span id='topic+rmultinormal'></span><span id='topic+dmultinormal'></span>

<h3>Description</h3>

<p>This function is the vectorized version of the &lsquo;<span class="samp">&#8288;rmvnorm&#8288;</span>&rsquo; from
the &lsquo;<span class="samp">&#8288;mvtnorm&#8288;</span>&rsquo; library. It provides a random number generator for
the multivariate normal distribution with varying vectors of means
and varying covariance matrixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultinormal(n, mean, sigma, method=c("eigen", "svd", "chol"))
dmultinormal(x, mean, sigma, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinormal_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If x is a matrix, each row is
taken to be a quantile.</p>
</td></tr>
<tr><td><code id="multinormal_+3A_n">n</code></td>
<td>
<p>Number of observations. If &lsquo;<span class="samp">&#8288;length(n) &gt; 1&#8288;</span>&rsquo;, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="multinormal_+3A_mean">mean</code></td>
<td>
<p>Vector or matrix of means. If a matrix, each row is taken
to be a quantile. Default is a vector of 0 of convenient length.</p>
</td></tr>
<tr><td><code id="multinormal_+3A_sigma">sigma</code></td>
<td>
<p>Covariance vector corresponding to the coercion of the
covariance matrix into a vector (if unique for all &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;) or array of covariance vectors (if varying according to
&lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;). default is a diagonal matrix of convenient
size.</p>
</td></tr>
<tr><td><code id="multinormal_+3A_method">method</code></td>
<td>
<p>Matrix decomposition used to determine the matrix root
of sigma, possible methods are eigenvalue decomposition (&quot;eigen&quot;,
default), singular value decomposition (&quot;svd&quot;), and Cholesky
decomposition (&quot;chol&quot;).</p>
</td></tr>
<tr><td><code id="multinormal_+3A_log">log</code></td>
<td>
<p>Logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, densities d are given as log(d).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;rmvnorm(n, m, s)&#8288;</span>&rsquo; is equivalent to &lsquo;<span class="samp">&#8288;rmultinormal(n, m,
as.vector(s))&#8288;</span>&rsquo;. &lsquo;<span class="samp">&#8288;dmvnorm(x, m, s)&#8288;</span>&rsquo; is equivalent to
&lsquo;<span class="samp">&#8288;dmultinormal(x, m, as.vector(s))&#8288;</span>&rsquo;.
</p>
<p>If &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;sigma&#8288;</span>&rsquo; is a matrix, the first random
deviate will use the first row of &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and/or &lsquo;<span class="samp">&#8288;sigma&#8288;</span>&rsquo;,
the second random deviate will use the second row of &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo;
and/or &lsquo;<span class="samp">&#8288;sigma&#8288;</span>&rsquo;, ... recycling being permitted by raw. If
&lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; is a vector of length &lsquo;<span class="samp">&#8288;l&#8288;</span>&rsquo; or is a matrix with
&lsquo;<span class="samp">&#8288;l&#8288;</span>&rsquo; columns, &lsquo;<span class="samp">&#8288;sigma&#8288;</span>&rsquo; should be a vector of length &lsquo;<span class="samp">&#8288;l x
l&#8288;</span>&rsquo; or a matrix of number of &lsquo;<span class="samp">&#8288;l x 2&#8288;</span>&rsquo; columns.
</p>


<h3>Note</h3>

<p>The use of a varying sigma may be very time consuming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## including equivalence with dmvnorm
## mean and sigma as vectors
(mean &lt;- c(10, 0))
(sigma &lt;- matrix(c(1, 2, 2, 10), ncol=2))
sigma &lt;- as.vector(sigma)
(x &lt;- matrix(c(9, 8, 1, -1), ncol=2))
round(rmultinormal(10, mean, sigma))
dmultinormal(x, mean, sigma) 
## Eq
dmvnorm(x, mean, matrix(sigma, ncol=2)) 

## mean as matrix
(mean &lt;- matrix(c(10, 0, 0, 10), ncol=2))
round(rmultinormal(10, mean, sigma))
dmultinormal(x, mean, sigma)
## Eq
dmvnorm(x[1, ], mean[1, ], matrix(sigma, ncol=2)) 
dmvnorm(x[2, ], mean[2, ], matrix(sigma, ncol=2)) 

## sigma as matrix
(mean &lt;- c(10, 0))
(sigma &lt;- matrix(c(1, 2, 2, 10, 10, 2, 2, 1), nrow=2, byrow=TRUE))
round(rmultinormal(10, mean, sigma))
dmultinormal(x, mean, sigma) 
## Eq
dmvnorm(x[1, ], mean, matrix(sigma[1, ], ncol=2)) 
dmvnorm(x[2, ], mean, matrix(sigma[2, ], ncol=2)) 

## mean and sigma as matrix
(mean &lt;- matrix(c(10, 0, 0, 10), ncol=2))
(sigma &lt;- matrix(c(1, 2, 2, 10, 10, 2, 2, 1), nrow=2, byrow=TRUE))
round(rmultinormal(10, mean, sigma))
dmultinormal(x, mean, sigma) 
## Eq
dmvnorm(x[1, ], mean[1, ], matrix(sigma[1, ], ncol=2)) 
dmvnorm(x[2, ], mean[2, ], matrix(sigma[2, ], ncol=2)) 

(mean &lt;- c(10, 0))
(sigma &lt;- matrix(c(1, 2, 2, 10, 10, 2, 2, 1), nrow=2, byrow=TRUE))
x &lt;- rmultinormal(1000, mean, sigma)
plot(x)

</code></pre>

<hr>
<h2 id='NA.mcnode'>
Finite, Infinite, NA and NaN Numbers in mcnode.
</h2><span id='topic+NA.mcnode'></span><span id='topic+is.na.mcnode'></span><span id='topic+is.nan.mcnode'></span><span id='topic+is.finite.mcnode'></span><span id='topic+is.infinite.mcnode'></span>

<h3>Description</h3>

<p>&lsquo;<span class="samp">&#8288;is.na&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;is.nan&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;is.finite&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;is.infinite&#8288;</span>&rsquo;
return a logical &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of the same dimension as &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcnode'
is.na(x)
## S3 method for class 'mcnode'
is.nan(x)
## S3 method for class 'mcnode'
is.finite(x)
## S3 method for class 'mcnode'
is.infinite(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NA.mcnode_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.finite">is.finite</a></code>, <code><a href="base.html#topic+NA">NA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- log(mcstoc(rnorm, nsv=1001))
x
is.na(x)



</code></pre>

<hr>
<h2 id='Ops.mcnode'>
Operations on mcnode Objects
</h2><span id='topic+Ops.mcnode'></span>

<h3>Description</h3>

<p>This function alters the way operations are performed on
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects for a better consistency of the theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcnode'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.mcnode_+3A_e1">e1</code></td>
<td>
<p>An &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object, a vector or an array.</p>
</td></tr>
<tr><td><code id="Ops.mcnode_+3A_e2">e2</code></td>
<td>
<p>An optional &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object, a vector or a matrix
with at least one of both objects as an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will be used for any of the Group <code><a href="methods.html#topic+Ops">Ops</a></code>
functions.
</p>
<p>The rules are as following (illustrated with a &lsquo;<span class="samp">&#8288;+&#8288;</span>&rsquo; function and
ignoring the &lsquo;<span class="samp">&#8288;nvariates&#8288;</span>&rsquo; dimension): 
</p>

<ul>
<li> <p>&lsquo;<span class="samp">&#8288;0 + 0 = 0&#8288;</span>&rsquo;;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;0 + V = V&#8288;</span>&rsquo;: classical recycling of the scalar;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;0 + U = U&#8288;</span>&rsquo;: classical recycling of the scalar;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;0 + VU = VU&#8288;</span>&rsquo;: classical recycling of the scalar;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;V + V = V&#8288;</span>&rsquo;: if both of the same &lsquo;<span class="samp">&#8288;(nsv)&#8288;</span>&rsquo; dimension;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;V + U = VU&#8288;</span>&rsquo;: the &lsquo;<span class="samp">&#8288;U&#8288;</span>&rsquo; object will be recycled &quot;by
row&quot;. The &lsquo;<span class="samp">&#8288;V&#8288;</span>&rsquo; object will be recycled classically &quot;by column&quot;;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;V + VU = VU&#8288;</span>&rsquo;: if the dimension of the &lsquo;<span class="samp">&#8288;V&#8288;</span>&rsquo; is
&lsquo;<span class="samp">&#8288;(nsv)&#8288;</span>&rsquo; and the dimension of the &lsquo;<span class="samp">&#8288;VU&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;(nsv x
nsu)&#8288;</span>&rsquo;. The &lsquo;<span class="samp">&#8288;V&#8288;</span>&rsquo; object will be recycled classically &quot;by column&quot;;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;U + U = U&#8288;</span>&rsquo;: if both of the same &lsquo;<span class="samp">&#8288;(nsu)&#8288;</span>&rsquo; dimension;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;U + VU = VU&#8288;</span>&rsquo;: if the dimension of the &lsquo;<span class="samp">&#8288;U&#8288;</span>&rsquo; is
&lsquo;<span class="samp">&#8288;(nsu)&#8288;</span>&rsquo; and the dimension of the &lsquo;<span class="samp">&#8288;VU&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;(nsv x
nsu)&#8288;</span>&rsquo;. The &lsquo;<span class="samp">&#8288;U&#8288;</span>&rsquo; object will be recycled &quot;by row&quot;;
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;VU + VU = VU&#8288;</span>&rsquo;: if the dimension of the &lsquo;<span class="samp">&#8288;VU&#8288;</span>&rsquo; nodes is
&lsquo;<span class="samp">&#8288;(nsu x nsv)&#8288;</span>&rsquo;;</p>
</li></ul>

<p>A vector or an array may be combined with an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of size
&lsquo;<span class="samp">&#8288;(nsv x nsu)&#8288;</span>&rsquo; if an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of this dimension may be built
from this vector/array using the &lsquo;<span class="samp">&#8288;mcdata&#8288;</span>&rsquo; function. See
<code><a href="#topic+mcdata">mcdata</a></code> for the rules.
</p>
<p>The &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute is transferred as following: &lsquo;<span class="samp">&#8288;each +
each = each&#8288;</span>&rsquo;; &lsquo;<span class="samp">&#8288;none + other = other&#8288;</span>&rsquo;; &lsquo;<span class="samp">&#8288;other1 + other2 =
other1&#8288;</span>&rsquo;. The &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute of the resulting node may be
changed using the <code><a href="#topic+outm">outm</a></code> function.
</p>
<p>For multivariate nodes, a recycling on the &lsquo;<span class="samp">&#8288;nvariates&#8288;</span>&rsquo; dimension
is done if a &lsquo;<span class="samp">&#8288;(nsu x nsv x nvariates)&#8288;</span>&rsquo; node is combined with a
&lsquo;<span class="samp">&#8288;(nsu x nsv x 1)&#8288;</span>&rsquo; node.
</p>


<h3>Value</h3>

<p>The results as a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcdata">mcdata</a></code>, <code><a href="#topic+mcstoc">mcstoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldvar &lt;- ndvar()
oldunc &lt;- ndunc()
ndvar(30)
ndunc(20)

## Given
x0 &lt;- mcdata(3, type="0")
xV &lt;- mcdata(1:ndvar(), type="V")
xU &lt;- mcdata(1:ndunc(), type="U")
xVU &lt;- mcdata(1:(ndunc()*ndvar()), type="VU")
x0M &lt;- mcdata(c(5, 10), type="0", nvariates=2)
xVM &lt;- mcdata(1:(2*ndvar()), type="V", nvariates=2)
xUM &lt;- mcdata(1:(2*ndunc()), type="U", nvariates=2)
xVUM &lt;- mcdata(1:(2*(ndunc()*ndvar())), type="VU", nvariates=2)

## All possible combinations
## "0"
-x0
x0 + 3

## "V"
-xV
3 + xV
xV * (1:ndvar())
xV * x0
xV - xV

## "U"
-xU
xU + 3
(1:ndunc()) * xU
xU * x0
xU - xU

## Watch out the resulting type
xV + xU
xU + xV

## "VU"
-xVU
3 + xVU
(1:(ndunc()*ndvar())) * xVU
xVU + xV
x0 + xVU
xU + xVU
xVU - xVU

## Some Multivariates
x0M+3
xVM * (1:ndvar())
xVM - xV
xUM - xU
xVUM - xU
</code></pre>

<hr>
<h2 id='outm'>
Output of Nodes
</h2><span id='topic+outm'></span>

<h3>Description</h3>

<p>Changes the output of Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outm(x, value="each", which.node=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outm_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="outm_+3A_value">value</code></td>
<td>
<p>The output of the &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; for multivariates nodes.
May be &quot;each&quot; (default) if output should be provided for each
variates considered independently, &quot;none&quot; for no output or a vector
of name of function(s) (as a character string) that will be applied
on the variates dimension before any output (ex: &lsquo;<span class="samp">&#8288;"mean"&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;"median"&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;c("min","max")&#8288;</span>&rsquo;). The function should have no
other arguments and send one value per vector of values (ex. do not
use &lsquo;<span class="samp">&#8288;"range"&#8288;</span>&rsquo;).</p>
</td></tr>
<tr><td><code id="outm_+3A_which.node">which.node</code></td>
<td>
<p>which node should be changed in a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; with a modified &lsquo;<span class="samp">&#8288;outm&#8288;</span>&rsquo; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
total$xVUM2
## since outm = NULL
summary(total$xVUM2) 
x &lt;- outm(total$xVUM2, c("min"))
summary(x)
</code></pre>

<hr>
<h2 id='pert'>The (Modified) PERT Distribution</h2><span id='topic+pert'></span><span id='topic+dpert'></span><span id='topic+ppert'></span><span id='topic+qpert'></span><span id='topic+rpert'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the PERT (<em>aka</em> Beta PERT) distribution with minimum equals to &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo;, mode equals to &lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo;
(or, alternatively, mean equals to &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo;) and maximum equals to &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpert(x, min = -1, mode = 0, max = 1, shape = 4, log = FALSE, mean = 0)

ppert(
  q,
  min = -1,
  mode = 0,
  max = 1,
  shape = 4,
  lower.tail = TRUE,
  log.p = FALSE,
  mean = 0
)

qpert(
  p,
  min = -1,
  mode = 0,
  max = 1,
  shape = 4,
  lower.tail = TRUE,
  log.p = FALSE,
  mean = 0
)

rpert(n, min = -1, mode = 0, max = 1, shape = 4, mean = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pert_+3A_x">x</code>, <code id="pert_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="pert_+3A_min">min</code></td>
<td>
<p>Vector of minima.</p>
</td></tr>
<tr><td><code id="pert_+3A_mode">mode</code></td>
<td>
<p>Vector of modes.</p>
</td></tr>
<tr><td><code id="pert_+3A_max">max</code></td>
<td>
<p>Vector of maxima.</p>
</td></tr>
<tr><td><code id="pert_+3A_shape">shape</code></td>
<td>
<p>Vector of scaling parameters. Default value: 4.</p>
</td></tr>
<tr><td><code id="pert_+3A_log">log</code>, <code id="pert_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="pert_+3A_mean">mean</code></td>
<td>
<p>Vector of means, can be specified in place of &lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo; as an alternative parametrization.</p>
</td></tr>
<tr><td><code id="pert_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;</p>
</td></tr>
<tr><td><code id="pert_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="pert_+3A_n">n</code></td>
<td>
<p>Number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PERT distribution is a <code><a href="stats.html#topic+Beta">Beta</a></code> distribution extended to the domain &lsquo;<span class="samp">&#8288;[min, max]&#8288;</span>&rsquo; with mean 
</p>
<p style="text-align: center;"><code class="reqn">mean=\frac{min+shape\times mode+max}{shape+2}</code>
</p>

<p>The underlying beta distribution is specified by <code class="reqn">\alpha_{1}</code> and <code class="reqn">\alpha_{2}</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{1}=\frac{(mean-min)(2\times mode-min-max)}{(mode-mean)(max-min)}</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha_{2}=\frac{\alpha_{1}\times (max-mean)}{mean-min}</code>
</p>

<p>&lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; can be specified, but not both. Note: &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; is the last parameter for back-compatibility. 
A warning will be provided if some combinations of &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo; leads to impossible mode.
</p>
<p>David Vose (See reference) proposed a modified PERT distribution with a shape parameter different from 4. 
</p>
<p>The PERT distribution is frequently used (with the <a href="#topic+triangular">triangular</a> distribution) to translate expert estimates
of the min, max and mode of a random variable in a smooth parametric distribution.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dpert&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;ppert&#8288;</span>&rsquo; gives the distribution function,
&lsquo;<span class="samp">&#8288;qpert&#8288;</span>&rsquo; gives the quantile function, and &lsquo;<span class="samp">&#8288;rpert&#8288;</span>&rsquo; generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Regis Pouillot and Matthew Wiener
</p>


<h3>References</h3>

<p>Vose D. Risk Analysis - A Quantitative Guide (2nd and 3rd editions, John Wiley and Sons, 2000, 2008).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(dpert(x,min=3,mode=5,max=10,shape=6), from = 2, to = 11, lty=3,ylab="density")
curve(dpert(x,min=3,mode=5,max=10), from = 2, to = 11, add=TRUE)
curve(dpert(x,min=3,mode=5,max=10,shape=2), from = 2, to = 11, add=TRUE,lty=2)
legend(x = 8, y = .30, c("Default: 4","shape: 2","shape: 6"), lty=1:3)
## Alternatie parametrization using mean
curve(dpert(x,min=3,mean=5,max=10), from = 2, to = 11, lty=2 ,ylab="density")
curve(dpert(x,min=3,mode=5,max=10), from = 2, to = 11, add=TRUE)
legend(x = 8, y = .30, c("mode: 5","mean: 5"), lty=1:2)
</code></pre>

<hr>
<h2 id='plot.mc'>
Plots Results of a Monte Carlo Simulation
</h2><span id='topic+plot.mc'></span><span id='topic+plot.mcnode'></span><span id='topic+plot.plotmc'></span><span id='topic+plot.mccut'></span>

<h3>Description</h3>

<p>Plots the empirical cumulative distribution function of a
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object (&quot;0&quot; and &quot;V&quot; nodes) or the
empirical cumulative distribution function of the estimate of a
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object (&quot;U&quot; and &quot;VU&quot; nodes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
plot(x, prec=0.001, stat=c("median", "mean"), lim=c(0.025, 0.25, 0.75,
	  0.975), na.rm=TRUE, griddim=NULL, xlab=NULL, ylab="Fn(x)",
	  main="", draw=TRUE, paint=TRUE, xlim=NULL, ylim=NULL, ...)
## S3 method for class 'mcnode'
plot(x, ...)
## S3 method for class 'plotmc'
plot(x, ...)
## S3 method for class 'mccut'
plot(x, stat=c("median", "mean"), lim=c(0.025, 0.25, 0.75, 0.975),
	  griddim=NULL, xlab=names(x), ylab="Fn(x)", main="",
	  draw=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mc_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_prec">prec</code></td>
<td>
<p>the precision of the plot. 0.001 will provide an ecdf
from the 0.000, 0.001, .002, ..., 1.000 quantiles.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_stat">stat</code></td>
<td>
<p>the function used for estimates (2D &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;). By default the median.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_lim">lim</code></td>
<td>
<p>a vector of numbers (between 0 and 1) indicating the
envelope (2D &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;) . Maybe &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo; or
empty.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NA values be discarded</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_griddim">griddim</code></td>
<td>
<p>a vector of two integers, indicating the size of the
grid of the graph. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;, the grid is calculated to produce
a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_xlab">xlab</code></td>
<td>
<p>vector of labels for the x-axis. If &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo;, use the
name of the node.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_ylab">ylab</code></td>
<td>
<p>vector of labels for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_main">main</code></td>
<td>
<p>vector of main titles of the graph.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_draw">draw</code></td>
<td>
<p>Should the plot be drawn?</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_paint">paint</code></td>
<td>
<p>Should the envelopes be filled?</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_xlim">xlim</code></td>
<td>
<p>x coordinate range. &lsquo;<span class="samp">&#8288;xlim&#8288;</span>&rsquo; is either a vector of
length 2, used for each graph, or a list of vectors of length 2,
whose ith element is used for the ith graph. By default, the data
range is used as &lsquo;<span class="samp">&#8288;xlim&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_ylim">ylim</code></td>
<td>
<p>y coordinate range. &lsquo;<span class="samp">&#8288;ylim&#8288;</span>&rsquo; is either a vector of
length 2, used for each graph, or a list of vectors of length 2,
whose ith element is used for the ith graph. By default, the data
range is 0-1.</p>
</td></tr>
<tr><td><code id="plot.mc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &lsquo;<span class="samp">&#8288;plot.stepfun&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;plot.mcnode&#8288;</span>&rsquo; is a user-friendly function that send the
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; to &lsquo;<span class="samp">&#8288;plot.mc&#8288;</span>&rsquo;.
</p>
<p>For &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;"U"&#8288;</span>&rsquo; &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s, quantiles are
calculated using <code><a href="#topic+quantile.mc">quantile.mc</a></code> within each of the
&lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; simulations (i.e. by columns of each &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;). The
medians (but may be the means using &lsquo;<span class="samp">&#8288;stat="mean"&#8288;</span>&rsquo;) calculated
from the &lsquo;<span class="samp">&#8288;nsu&#8288;</span>&rsquo; values are plotted. The 0.025 and 0.975
quantiles, and the 0.25 and 0.75 quantiles (default values of
&lsquo;<span class="samp">&#8288;lim&#8288;</span>&rsquo;) of these quantiles are used as the envelope.
</p>


<h3>Value</h3>

<p>A &lsquo;<span class="samp">&#8288;plot.mc&#8288;</span>&rsquo; object, list of the quantiles used to plot the draw.
</p>


<h3>References</h3>

<p>Cullen AC and Frey HC (1999) Probabilistic techniques in exposure
assessment. Plenum Press, USA, pp. 81-155.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+quantile.mc">quantile.mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)

plot(xVUM3)
## only one envelope corresponding to quantiles 0.025 and 0.975
plot(xVUM3, lim=c(0.025, 0.975)) 
## only one envelope not painted
plot(xVUM3, lim=c(0.025, 0.975), paint=FALSE) 

def.par &lt;- par(no.readonly = TRUE)
par(mar=c(4, 4, 1, 1))
plot(total)
par(def.par)



</code></pre>

<hr>
<h2 id='plot.tornado'>
Draws a Tornado chart.
</h2><span id='topic+plot.tornado'></span><span id='topic+plot.tornadounc'></span>

<h3>Description</h3>

<p>Draws a Tornado chart as provided by &lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tornado'
plot(x, which=1, name=NULL, stat=c("median", "mean"), xlab="method",
	  ylab="", ...)
## S3 method for class 'tornadounc'
plot(x, which=1, stat="median", name=NULL, xlab="method", ylab="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tornado_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+tornado">tornado</a></code> object or a <code><a href="#topic+tornadounc">tornadounc</a></code>
object.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_which">which</code></td>
<td>
<p>Which output to print -for multivariates output-.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_name">name</code></td>
<td>
<p>Vector of name of input variables. If NULL, the name will
be given from the name of the elements.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_stat">stat</code></td>
<td>
<p>The name of the statistics of the output to be
considered. For a &lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo; object: &quot;median&quot; or &quot;mean&quot;. For a
&lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo; object: the value should match one row name of the
&lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo; object. Alternatively, for a &lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo;
object, the number of the row may be used.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x axis. if &quot;method&quot;, use the correlation
method used in the &lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y axis.</p>
</td></tr>
<tr><td><code id="plot.tornado_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the &lsquo;<span class="samp">&#8288;plot&#8288;</span>&rsquo;
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A point is drawn at the estimate and the segment reflects the
uncertainty around this estimate.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tornado">tornado</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ec)
x &lt;- evalmcmod(ec$modEC2, nsv=100, nsu=100, seed=666)
tor &lt;- tornado(x, 7)
plot(tor)

</code></pre>

<hr>
<h2 id='pmin'>
Maxima and Minima for mcnodes
</h2><span id='topic+pmin'></span><span id='topic+pmax'></span><span id='topic+pmin.default'></span><span id='topic+pmax.default'></span><span id='topic+pmin.mcnode'></span><span id='topic+pmax.mcnode'></span>

<h3>Description</h3>

<p>Returns the parallel maxima and minima of the input values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcnode'
pmin(..., na.rm=FALSE)
## S3 method for class 'mcnode'
pmax(..., na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmin_+3A_...">...</code></td>
<td>
<p>One or more &lsquo;<span class="samp">&#8288;mcnodes&#8288;</span>&rsquo;s or one or more
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s and vector(s) of compatible size. Note that one
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; must be at the first place.</p>
</td></tr>
<tr><td><code id="pmin_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;pmax&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;pmin&#8288;</span>&rsquo; take one or more &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; and/or
vectors as arguments and return a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of adequate type and
size giving the &quot;parallel&quot; maxima (or minima) of the &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;
and/or vectors. Note that the first element of ... should be an
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;. The resulting type of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; is variable
according to the elements that are passed. The same rules as in
<code><a href="#topic+Ops.mcnode">Ops.mcnode</a></code> are applied.
</p>


<h3>Value</h3>

<p>an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; of adequate type and dimension.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+min">min</a></code>, <code><a href="#topic+Ops.mcnode">Ops.mcnode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndvar(10);ndunc(21)
x &lt;- mcstoc(rnorm, "V")
pmin(x, 0)
y &lt;- mcdata(rep(c(-1, 1), length=ndunc()), "U")
unclass(pmin(x, y))





</code></pre>

<hr>
<h2 id='print.mc'>
Prints a mcnode or a mc Object
</h2><span id='topic+print.mc'></span><span id='topic+print.mcnode'></span>

<h3>Description</h3>

<p>Print a description of the structure of the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or the
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
print(x, digits=3, ...)
## S3 method for class 'mcnode'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mc_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="print.mc_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be used.</p>
</td></tr>
<tr><td><code id="print.mc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the print function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnode">mcnode</a></code> for &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects. <code><a href="#topic+mc">mc</a></code> for
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects.
</p>

<hr>
<h2 id='quantile.mc'>
Quantiles of a mc Object
</h2><span id='topic+quantile.mc'></span><span id='topic+quantile.mcnode'></span>

<h3>Description</h3>

<p>Evaluates quantiles of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object. This function is used by
&lsquo;<span class="samp">&#8288;plot.mc&#8288;</span>&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
quantile(x, probs=seq(0, 1, 0.01), lim=c(0.025, 0.975), na.rm=TRUE, ...)
## S3 method for class 'mcnode'
quantile(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.mc_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects</p>
</td></tr>
<tr><td><code id="quantile.mc_+3A_probs">probs</code></td>
<td>
<p>the quantiles to be calculated</p>
</td></tr>
<tr><td><code id="quantile.mc_+3A_na.rm">na.rm</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code id="quantile.mc_+3A_lim">lim</code></td>
<td>
<p>a vector of numbers (between 0 and 1) indicating the
envelope. Maybe &lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo; or empty.</p>
</td></tr>
<tr><td><code id="quantile.mc_+3A_...">...</code></td>
<td>
<p>For generic method consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantiles are evaluated in the variability dimension. Then, the
median, the mean and the &lsquo;<span class="samp">&#8288;lim&#8288;</span>&rsquo; quantiles are evaluated for each
of these quantiles.
</p>


<h3>Value</h3>

<p>A list of quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mc">plot.mc</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
quantile(total$xVUM3)
quantile(total)

</code></pre>

<hr>
<h2 id='rtrunc'>
Random Truncated Distributions
</h2><span id='topic+rtrunc'></span>

<h3>Description</h3>

<p>Provides samples from classical <span class="rlang"><b>R</b></span> distributions and &lsquo;<span class="samp">&#8288;mc2d&#8288;</span>&rsquo;
specific distributions truncated between &lsquo;<span class="samp">&#8288;linf&#8288;</span>&rsquo; (excluded) and
&lsquo;<span class="samp">&#8288;lsup&#8288;</span>&rsquo; (included).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtrunc(distr=runif, n, linf=-Inf, lsup=Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtrunc_+3A_distr">distr</code></td>
<td>
<p>A function providing random data or its name as
character. The function 'rdistr' should have a 'qdistr' form (with
argument 'p') and a 'pdistr' form (with argument 'q'). Example :
'rnorm' (has a 'qnorm' and a 'pnorm' form), 'rbeta', 'rbinom',
'rgamma', ...</p>
</td></tr>
<tr><td><code id="rtrunc_+3A_n">n</code></td>
<td>
<p>The size of the sample.</p>
</td></tr>
</table>
<p>.
</p>
<table>
<tr><td><code id="rtrunc_+3A_linf">linf</code></td>
<td>
<p>A vector of lower bounds.</p>
</td></tr>
<tr><td><code id="rtrunc_+3A_lsup">lsup</code></td>
<td>
<p>A vector of upper bounds, with &lsquo;<span class="samp">&#8288;lsup &lt; linf&#8288;</span>&rsquo;
(strictly).</p>
</td></tr>
<tr><td><code id="rtrunc_+3A_...">...</code></td>
<td>
<p>All arguments to be passed to &lsquo;<span class="samp">&#8288;pdistr&#8288;</span>&rsquo; and
&lsquo;<span class="samp">&#8288;qdistr&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function 1) evaluates the &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; values corresponding to
&lsquo;<span class="samp">&#8288;linf&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;lsup&#8288;</span>&rsquo; using &lsquo;<span class="samp">&#8288;pdistr&#8288;</span>&rsquo;; 2) samples &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo;
values using &lsquo;<span class="samp">&#8288;runif(n, min=pinf, max=psup)&#8288;</span>&rsquo;, and 3) takes the
&lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; corresponding quantiles from the specified distribution
using &lsquo;<span class="samp">&#8288;qdistr&#8288;</span>&rsquo;.
</p>
<p>All distributions (but sample) implemented in the stats library could
be used. The arguments in ... should be named. Do not use 'log' or
'log.p' or 'lower.tail'. For discrete distribution, rtrunc sample
within &lsquo;<span class="samp">&#8288;(linf, lsup]&#8288;</span>&rsquo;. See example.
</p>


<h3>Value</h3>

<p>A vector of &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; values.
</p>


<h3>Note</h3>

<p>The inversion of the quantile function leads to time consuming
functions for some distributions. WARNING: The method is flexible,
but can lead to problems linked to rounding errors in some extreme
situations. The function checks that the values are in the expected
range and returns an error if not. It also warns some extreme
situation that could lead to unexpected results. See Examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rtrunc("rnorm", n=10, linf=0)
range(rtrunc(rnorm, n=1000, linf=3, lsup=5, sd=10))
## Discrete distributions
range(rtrunc(rpois, 1000, linf=2, lsup=4, lambda=1))
##Examples of rounding problems. 
##The first one will provide a warning while the results are unexpected, 
##The second will provide an error.
## Not run: 
table(rtrunc(rbinom, n=1000, size=10, prob=1-1E-20, lsup=9))
table(rtrunc(rbinom, n=1000, size=10, prob=1E-14, linf=0))

## End(Not run)
</code></pre>

<hr>
<h2 id='spaghetti'>Spaghetti Plot of mc/mcnode Object</h2><span id='topic+spaghetti'></span><span id='topic+spaghetti.mc'></span><span id='topic+spaghetti.mcnode'></span>

<h3>Description</h3>

<p>Use plot to draw spaghetti plots for the mc/mcnode objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaghetti(x, ...)

## S3 method for class 'mc'
spaghetti(
  x,
  griddim = NULL,
  xlab = names(x),
  ylab = "F(n)",
  main = "",
  maxlines = 100,
  ...
)

## S3 method for class 'mcnode'
spaghetti(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spaghetti_+3A_x">x</code></td>
<td>
<p>mc/mcnode object</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to plot.stepfun()</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_griddim">griddim</code></td>
<td>
<p>a vector of two integers, indicating the size of the grid of the graph. If NULL, the grid is calculated to produce a &quot;nice&quot; graph.</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_xlab">xlab</code></td>
<td>
<p>vector of labels for the x-axis. If NULL, use the name of the node.</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_ylab">ylab</code></td>
<td>
<p>vector of labels for the y-axis.</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_main">main</code></td>
<td>
<p>vector of main titles of the graph.</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_maxlines">maxlines</code></td>
<td>
<p>the maximum number of ecdf to draw.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
spaghetti(mc(xVUM))
spaghetti(xVUM)

</code></pre>

<hr>
<h2 id='summary.mc'>
Summary of mcnode and mc Object
</h2><span id='topic+summary.mc'></span><span id='topic+summary.mcnode'></span><span id='topic+print.summary.mc'></span><span id='topic+summary.mccut'></span>

<h3>Description</h3>

<p>Provides a summary of a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;, a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo;
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
summary(object, probs=c(0, 0.025, 0.25, 0.5, 0.75, 0.975, 1), lim=c(0.025,
	  0.975), ...)
## S3 method for class 'mcnode'
summary(object, probs=c(0, 0.025, 0.25, 0.5, 0.75, 0.975, 1), lim=c(0.025,
	  0.975), digits=3, ...)
## S3 method for class 'mc'
print.summary(x, digits=3, ...)
## S3 method for class 'mccut'
summary(object, lim=c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mc_+3A_object">object</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object or a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo;
object.</p>
</td></tr>
<tr><td><code id="summary.mc_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;summary.mc&#8288;</span>&rsquo; object as provided by the
&lsquo;<span class="samp">&#8288;summary.mc&#8288;</span>&rsquo; function.</p>
</td></tr>
<tr><td><code id="summary.mc_+3A_probs">probs</code></td>
<td>
<p>A vector of values used for the quantile function
(variability dimension).</p>
</td></tr>
<tr><td><code id="summary.mc_+3A_digits">digits</code></td>
<td>
<p>Number of digits in the print.</p>
</td></tr>
<tr><td><code id="summary.mc_+3A_lim">lim</code></td>
<td>
<p>A vector of values used for the quantile function
(uncertainty dimension).</p>
</td></tr>
<tr><td><code id="summary.mc_+3A_...">...</code></td>
<td>
<p>For generic functions consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean, the standard deviation and the &lsquo;<span class="samp">&#8288;probs&#8288;</span>&rsquo; quantiles will
be evaluated in the variability dimension. The median, the mean and
the &lsquo;<span class="samp">&#8288;lim&#8288;</span>&rsquo; quantiles will then be evaluated on these statistics
in the uncertainty dimension.
</p>
<p>Multivariate nodes:
</p>
<p>If the &lsquo;<span class="samp">&#8288;"outm"&#8288;</span>&rsquo; attributes of the mcnode is &quot;none&quot;, the node is
not evaluated, if it is &quot;each&quot; the variates are evaluated one by one,
if it is a function (e.g. &quot;mean&quot;), the function is applied on the
&lsquo;<span class="samp">&#8288;nvariates&#8288;</span>&rsquo; dimension before providing a classical output.
</p>


<h3>Value</h3>

<p>a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnode">mcnode</a></code> for mcnode objects, <code><a href="#topic+mc">mc</a></code> for mc
objects, <code><a href="#topic+mccut">mccut</a></code> for mccut objects,
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
summary(xVUM3)
summary(total)



</code></pre>

<hr>
<h2 id='tornado'>
Computes Correlation between Inputs and Output in a mc Object
(tornado) in the Variability Dimension;
</h2><span id='topic+tornado'></span><span id='topic+print.tornado'></span>

<h3>Description</h3>

<p>Provides statistics for a tornado chart. Evaluates correlations
between output and inputs of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tornado(mc, output=length(mc), use="all.obs", method=c("spearman",
	  "kendall", "pearson"), lim=c(0.025, 0.975))
## S3 method for class 'tornado'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tornado_+3A_mc">mc</code></td>
<td>
<p>a <code><a href="#topic+mc">mc</a></code> object or a <code><a href="#topic+mccut">mccut</a></code> object.</p>
</td></tr>
<tr><td><code id="tornado_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo; object as provided by the &lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo;
function.</p>
</td></tr>
<tr><td><code id="tornado_+3A_output">output</code></td>
<td>
<p>(for &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects only). The rank or the name of
the output to be considered. By default: the last element of the
&lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="tornado_+3A_use">use</code></td>
<td>
<p>(for &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects only). An optional character string
giving a method for computing covariances in the presence of missing
values. This must be (an abbreviation of) one of the strings
&quot;all.obs&quot;, &quot;complete.obs&quot; or &quot;pairwise.complete.obs&quot; (see
<code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="tornado_+3A_method">method</code></td>
<td>
<p>(for &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; objects only). A character string
indicating which correlation coefficient (or covariance) is to be
computed. One of &quot;spearman&quot; (default), &quot;kendall&quot; or &quot;pearson&quot;, can be
abbreviated (see <code><a href="stats.html#topic+cor">cor</a></code>). Warning : the default is not the
same in <code><a href="stats.html#topic+cor">cor</a></code>.</p>
</td></tr>
<tr><td><code id="tornado_+3A_lim">lim</code></td>
<td>
<p>A vector of quantiles used to compute the credible
interval in two-dimensional models.</p>
</td></tr>
<tr><td><code id="tornado_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the final print
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tornado function computes the spearman's rho statistic. It is
used to estimate a rank-based measure of association between one set
of random variable of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object (the output) and the others
(the inputs).
</p>
<p>&lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo; may be applied on a &lsquo;<span class="samp">&#8288;mccut&#8288;</span>&rsquo; object if a
&lsquo;<span class="samp">&#8288;tornado&#8288;</span>&rsquo; function was used in the third block of the
<code><a href="#topic+evalmccut">evalmccut</a></code> call.
</p>
<p>If &quot;output&quot; refers to a &lsquo;<span class="samp">&#8288;"0" mcnode&#8288;</span>&rsquo;, it is an error. If
&quot;output&quot; refers to a &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;, correlations are only
provided for other &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;s. If &quot;output&quot; refers to a
&lsquo;<span class="samp">&#8288;"U" mcnode&#8288;</span>&rsquo;, correlations are only provided for other &lsquo;<span class="samp">&#8288;"U"
mcnode&#8288;</span>&rsquo;s. If &quot;output&quot; refers to a &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo;, correlations
are only provided for other &lsquo;<span class="samp">&#8288;"VU" mcnode&#8288;</span>&rsquo;s and &lsquo;<span class="samp">&#8288;"V"
mcnode&#8288;</span>&rsquo;s.
</p>
<p>If use is &quot;all.obs&quot;, then the presence of missing observations will
produce an error. If use is &quot;complete.obs&quot; then missing values are
handled by casewise deletion. Finally, if use has the value
&quot;pairwise.complete.obs&quot; then the correlation between each pair of
variables is computed using all complete pairs of observations on
those variables.
</p>


<h3>Value</h3>

<p>An invisible object of class tornado. A tornado object is a list of
objects containing the following objects: 
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>the value of correlation coefficients</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>the name of the output</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used</p>
</td></tr>
<tr><td><code>use</code></td>
<td>
<p>the use parameter</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>.
</p>
<p><code><a href="#topic+plot.tornado">plot.tornado</a></code> to draw the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
tornado(total, 2, "complete.obs", "spearman", c(0.025, 0.975))
tornado(total, 4, "pairwise.complete.obs", "spearman", c(0.025, 0.975))
tornado(total, 6, "complete.obs", "kendall", c(0.025, 0.975))
tornado(total, 8, "complete.obs", "spearman", c(0.025, 0.975))
(y &lt;- tornado(total, 10, "complete.obs", "spearman", c(0.025, 0.975)))
plot(y)

</code></pre>

<hr>
<h2 id='tornadounc'>
Computes Correlation between Inputs and Output in a mc Object
(tornado) in the Uncertainty Dimension
</h2><span id='topic+tornadounc'></span><span id='topic+tornadounc.mc'></span><span id='topic+tornadounc'></span><span id='topic+tornadounc.default'></span><span id='topic+print.tornadounc'></span><span id='topic+tornadounc.mccut'></span>

<h3>Description</h3>

<p>Provides statistics for a tornado chart. Evaluates correlations
between output and inputs of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object in the uncertainty
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc'
tornadounc(mc, output=length(mc), quant=c(0.5, 0.75, 0.975), use="all.obs",
	  method=c("spearman", "kendall", "pearson"), ...)
## Default S3 method:
tornadounc(mc, ...)
## S3 method for class 'tornadounc'
print(x, ...)
## S3 method for class 'mccut'
tornadounc(mc, output=length(mc), quant=c(0.5, 0.75, 0.975), use="all.obs",
	  method=c("spearman", "kendall", "pearson"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tornadounc_+3A_mc">mc</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_output">output</code></td>
<td>
<p>The rank or the name of the output to be considered.
Should be a &lsquo;<span class="samp">&#8288;"VU"&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;"U" type mcnode&#8288;</span>&rsquo;. By default: the
last element of &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_quant">quant</code></td>
<td>
<p>The vector of quantiles used in the variability
dimension.</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_use">use</code></td>
<td>
<p>An optional character string giving a method for computing
covariances in the presence of missing values. This must be (an
abbreviation of) one of the strings &quot;all.obs&quot;, &quot;complete.obs&quot; or
&quot;pairwise.complete.obs&quot; (see <code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_method">method</code></td>
<td>
<p>A character string indicating which correlation
coefficient (or covariance) is to be computed. One of &quot;spearman&quot;
(default), &quot;kendall&quot; or &quot;pearson&quot;, can be abbreviated (see
<code><a href="stats.html#topic+cor">cor</a></code>). Warning : &quot;pearson&quot; is the default for
<code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="tornadounc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the final print
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;<span class="samp">&#8288;tornadounc.mc&#8288;</span>&rsquo; function computes the spearman's rho
statistic between 
</p>

<ul>
<li><p> values (&lsquo;<span class="samp">&#8288;"U" type mcnode&#8288;</span>&rsquo;) or statistics calculated in the
variability dimension (&lsquo;<span class="samp">&#8288;"VU" type mcnode&#8288;</span>&rsquo;) of inputs and
</p>
</li>
<li><p> values (&lsquo;<span class="samp">&#8288;"U" type mcnode&#8288;</span>&rsquo;) or statistics calculated in the
variability dimension (&lsquo;<span class="samp">&#8288;"VU" type mcnode&#8288;</span>&rsquo;) of one output.</p>
</li></ul>

<p>The statistics are the mean, the median and the quantiles specified
by &lsquo;<span class="samp">&#8288;quant&#8288;</span>&rsquo;.
</p>
<p>It is useful to estimate a rank-based measure of association between
one set of random variable of a &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object (the output) and the
others in the uncertainty dimension.
</p>
<p>&lsquo;<span class="samp">&#8288;tornadounc.mccut&#8288;</span>&rsquo; may be applied on a <code><a href="#topic+mccut">mccut</a></code>
object if a &lsquo;<span class="samp">&#8288;summary.mc&#8288;</span>&rsquo; function was used in the third block of
the <code><a href="#topic+evalmccut">evalmccut</a></code> call.
</p>
<p>If output refers to a &lsquo;<span class="samp">&#8288;"0"&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;"V" mcnode&#8288;</span>&rsquo;, it is an
error.
</p>
<p>If use is &quot;all.obs&quot;, then the presence of missing observations will
produce an error. If use is &quot;complete.obs&quot; then missing values are
handled by casewise deletion. Finally, if use has the value
&quot;pairwise.complete.obs&quot; then the correlation between each pair of
variables is computed using all complete pairs of observations on
those variables.
</p>


<h3>Value</h3>

<p>An invisible object of class &lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo;. A &lsquo;<span class="samp">&#8288;tornadounc&#8288;</span>&rsquo;
object is a list of objects containing the following objects: 
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>a matrix of values of correlation coefficients. Each row
are the value or the statistics of inputs, each columns the value or
the statistics of outputs.</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>the name of the output</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used</p>
</td></tr>
<tr><td><code>use</code></td>
<td>
<p>the &lsquo;<span class="samp">&#8288;use&#8288;</span>&rsquo; parameter</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>.
</p>
<p><code><a href="#topic+tornado">tornado</a></code> for tornado in the variability dimension.
</p>
<p><code><a href="#topic+plot.tornadounc">plot.tornadounc</a></code> to draw the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
tornadounc(total, 3)
tornadounc(total, 4, use="complete")
tornadounc(total, 7, use="complete.obs")
tornadounc(total, 8, use="complete.obs")
(y &lt;- tornadounc(total, 10, use="complete.obs"))
plot(y, 1, 1)




</code></pre>

<hr>
<h2 id='total'>An Example of all Kind of mcnode</h2><span id='topic+total'></span><span id='topic+x0'></span><span id='topic+x0M'></span><span id='topic+xU'></span><span id='topic+xUM'></span><span id='topic+xV'></span><span id='topic+xVM'></span><span id='topic+xVU'></span><span id='topic+xVUM'></span><span id='topic+xVUM2'></span><span id='topic+xVUM3'></span>

<h3>Description</h3>

<p>An example for each kind of &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;s. They are used in some &lsquo;<span class="samp">&#8288;mc2d&#8288;</span>&rsquo; examples. They
have been built using the following code:
</p>
<p><code>ndvar(101)</code>
<code>ndunc(51)</code>
</p>
<p><code>x0 &lt;- mcstoc(type="0")</code>
</p>
<p><code>xV &lt;- mcstoc(type="V")</code>
</p>
<p><code>xU &lt;- mcstoc(type="U")</code>
</p>
<p><code>xVU &lt;- mcstoc(type="VU")</code>
</p>
<p><code>x0M &lt;- mcstoc(type="0",nvariates=2)</code>
</p>
<p><code>xVM &lt;- mcstoc(type="V",nvariates=2)</code>
</p>
<p><code>xUM &lt;- mcstoc(type="U",nvariates=2)</code>
</p>
<p><code>xVUM &lt;- mcstoc(type="VU",nvariates=2)</code>
</p>
<p><code>xVUM[c(1,12,35)] &lt;- NA</code>
</p>
<p><code>xVUM2 &lt;- mcstoc(type="VU",nvariates=2,outm="none")</code>
</p>
<p><code>xVUM3 &lt;- mcstoc(type="VU",nvariates=2,outm=c("mean","min"))</code>
</p>
<p><code>total &lt;- mc(x0,xV,xU,xVU,x0M,xVM,xUM,xVUM,xVUM2,xVUM3)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(total)</code></pre>


<h3>Format</h3>

<p>Some &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; objects and one &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object.
</p>


<h3>Source</h3>

<p>None</p>


<h3>References</h3>

<p>None
</p>

<hr>
<h2 id='triangular'>The Triangular Distribution</h2><span id='topic+triangular'></span><span id='topic+dtriang'></span><span id='topic+ptriang'></span><span id='topic+qtriang'></span><span id='topic+rtriang'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the triangular distribution with minimum equal to &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo;, mode equal &lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo;
(alternatively, mean equal &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo;) and maximum equal to &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtriang(x, min = -1, mode = 0, max = 1, log = FALSE, mean = 0)

ptriang(
  q,
  min = -1,
  mode = 0,
  max = 1,
  lower.tail = TRUE,
  log.p = FALSE,
  mean = 0
)

qtriang(
  p,
  min = -1,
  mode = 0,
  max = 1,
  lower.tail = TRUE,
  log.p = FALSE,
  mean = 0
)

rtriang(n, min = -1, mode = 0, max = 1, mean = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangular_+3A_x">x</code>, <code id="triangular_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="triangular_+3A_min">min</code></td>
<td>
<p>vector of minima.</p>
</td></tr>
<tr><td><code id="triangular_+3A_mode">mode</code></td>
<td>
<p>vector of modes.</p>
</td></tr>
<tr><td><code id="triangular_+3A_max">max</code></td>
<td>
<p>vector of maxima.</p>
</td></tr>
<tr><td><code id="triangular_+3A_log">log</code>, <code id="triangular_+3A_log.p">log.p</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, probabilities &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; are given as &lsquo;<span class="samp">&#8288;log(p)&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="triangular_+3A_mean">mean</code></td>
<td>
<p>Vector of means, can be specified in place of &lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo; as an alternative parametrization.</p>
</td></tr>
<tr><td><code id="triangular_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; (default), probabilities are &lsquo;<span class="samp">&#8288;P[X &lt;= x]&#8288;</span>&rsquo;, otherwise, &lsquo;<span class="samp">&#8288;P[X &gt; x]&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="triangular_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="triangular_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &lsquo;<span class="samp">&#8288;min == mode == max&#8288;</span>&rsquo;, there is no density in that case and 
&lsquo;<span class="samp">&#8288;dtriang&#8288;</span>&rsquo; will return &lsquo;<span class="samp">&#8288;NaN&#8288;</span>&rsquo; (the error condition) (Similarity with <code><a href="stats.html#topic+Uniform">Uniform</a></code>).
</p>
<p>&lsquo;<span class="samp">&#8288;mode&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; can be specified, but not both. Note: &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; is the last parameter for back-compatibility.
A warning will be provided if some combinations of &lsquo;<span class="samp">&#8288;min&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;mean&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;max&#8288;</span>&rsquo; leads to impossible mode.
</p>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;dtriang&#8288;</span>&rsquo; gives the density, &lsquo;<span class="samp">&#8288;ptriang&#8288;</span>&rsquo; gives the distribution function,
&lsquo;<span class="samp">&#8288;qtriang&#8288;</span>&rsquo; gives the quantile function, and &lsquo;<span class="samp">&#8288;rtriang&#8288;</span>&rsquo; generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(dtriang(x, min=3, mode=6, max=10), from = 2, to = 11, ylab="density")
## Alternative parametrization
curve(dtriang(x, min=3, mean=6, max=10), from = 2, to = 11, add=TRUE, lty=2)
##no density when  min == mode == max
dtriang(c(1,2,3),min=2,mode=2,max=2)
</code></pre>

<hr>
<h2 id='typemcnode'>
Provides the Type of a mcnode Object
</h2><span id='topic+typemcnode'></span>

<h3>Description</h3>

<p>Provide the type of a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typemcnode(x, index=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typemcnode_+3A_x">x</code></td>
<td>
<p>a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object</p>
</td></tr>
<tr><td><code id="typemcnode_+3A_index">index</code></td>
<td>
<p>if &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo; give the index of the type rather than
the type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&lsquo;<span class="samp">&#8288;"0", "V","U" or "VU"&#8288;</span>&rsquo; or the corresponding index if
&lsquo;<span class="samp">&#8288;index=TRUE&#8288;</span>&rsquo;.
</p>
<p>&lsquo;<span class="samp">&#8288;NULL&#8288;</span>&rsquo; if none of this element is found.
</p>


<h3>Note</h3>

<p>This function does not test if the object is correct. See
<code><a href="#topic+is.mcnode">is.mcnode</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
typemcnode(total$xVUM2)
</code></pre>

<hr>
<h2 id='unmc'>
Unclasses the mc or the mcnode Object
</h2><span id='topic+unmc'></span>

<h3>Description</h3>

<p>Unclasses the &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object in a list of arrays or the
&lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object in an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmc(x, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmc_+3A_x">x</code></td>
<td>
<p>A &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; or a &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo; object.</p>
</td></tr>
<tr><td><code id="unmc_+3A_drop">drop</code></td>
<td>
<p>Should the dimensions of size 1 be dropped (see
<code><a href="base.html#topic+drop">drop</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if x is an &lsquo;<span class="samp">&#8288;mc&#8288;</span>&rsquo; object: a list of arrays. If &lsquo;<span class="samp">&#8288;drop=TRUE&#8288;</span>&rsquo;, a
list of vectors, matrixes and arrays. if x is an &lsquo;<span class="samp">&#8288;mcnode&#8288;</span>&rsquo;
object: an array. If &lsquo;<span class="samp">&#8288;drop=TRUE&#8288;</span>&rsquo;, a vector, matrix or array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(total)
## A vector
unmc(total$xV, drop=TRUE)
## An array
unmc(total$xV, drop=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
