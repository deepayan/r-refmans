<!DOCTYPE html><html><head><title>Help for package flexsurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flexsurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flexsurv-package'><p>flexsurv: Flexible parametric survival and multi-state models</p></a></li>
<li><a href='#.hess_to_cov'><p>helper function to safely convert a Hessian matrix to covariance matrix</p></a></li>
<li><a href='#.hessian'><p>Numerical evaluation of the hessian of a function using numDeriv::hessian</p></a></li>
<li><a href='#ajfit'><p>Aalen-Johansen nonparametric estimates comparable to a fitted flexsurvmix</p>
model</a></li>
<li><a href='#ajfit_flexsurvmix'><p>Forms a tidy data frame for plotting the fit of parametric mixture</p>
multi-state models against nonparametric estimates</a></li>
<li><a href='#ajfit_fmsm'><p>Check the fit of Markov flexible parametric multi-state models against</p>
nonparametric estimates.</a></li>
<li><a href='#augment.flexsurvreg'><p>Augment data with information from a flexsurv model object</p></a></li>
<li><a href='#basis'><p>Natural cubic spline basis</p></a></li>
<li><a href='#bc'><p>Breast cancer survival data</p></a></li>
<li><a href='#bootci.fmsm'><p>Bootstrap confidence intervals for flexsurv output functions</p></a></li>
<li><a href='#bos'><p>Bronchiolitis obliterans syndrome after lung transplants</p></a></li>
<li><a href='#coef.flexsurvreg'><p>Extract model coefficients from fitted flexible survival models</p></a></li>
<li><a href='#coxsnell_flexsurvreg'><p>Cox-Snell residuals from a parametric survival model</p></a></li>
<li><a href='#flexsurvmix'><p>Flexible parametric mixture models for times to competing events</p></a></li>
<li><a href='#flexsurvreg'><p>Flexible parametric regression for time-to-event data</p></a></li>
<li><a href='#flexsurvrtrunc'><p>Flexible parametric models for right-truncated, uncensored data defined by times of initial and final events.</p></a></li>
<li><a href='#flexsurvspline'><p>Flexible survival regression using the Royston/Parmar spline model.</p></a></li>
<li><a href='#fmixmsm'><p>Constructor for a mixture multi-state model based on flexsurvmix</p></a></li>
<li><a href='#fmsm'><p>Construct a multi-state model from a set of parametric survival models</p></a></li>
<li><a href='#GenF'><p>Generalized F distribution</p></a></li>
<li><a href='#GenF.orig'><p>Generalized F distribution (original parameterisation)</p></a></li>
<li><a href='#GenGamma'><p>Generalized gamma distribution</p></a></li>
<li><a href='#GenGamma.orig'><p>Generalized gamma distribution (original parameterisation)</p></a></li>
<li><a href='#get_basepars'><p>Evaluate baseline time-to-event distribution parameters given covariate values in a flexsurvmix model</p></a></li>
<li><a href='#glance.flexsurvreg'><p>Glance at a flexsurv model object</p></a></li>
<li><a href='#Gompertz'><p>The Gompertz distribution</p></a></li>
<li><a href='#hexp'><p>Hazard and cumulative hazard functions</p></a></li>
<li><a href='#hr_flexsurvreg'><p>Hazard ratio as a function of time from a parametric survival model</p></a></li>
<li><a href='#lines.flexsurvreg'><p>Add fitted flexible survival curves to a plot</p></a></li>
<li><a href='#Llogis'><p>The log-logistic distribution</p></a></li>
<li><a href='#mean_exp'><p>Mean and restricted mean survival functions</p></a></li>
<li><a href='#mean_flexsurvmix'><p>Mean times to events from a flexsurvmix model</p></a></li>
<li><a href='#meanfinal_fmixmsm'><p>Mean time to final state in a mixture multi-state model</p></a></li>
<li><a href='#model.frame.flexsurvreg'><p>Extract original data from <code>flexsurvreg</code> objects.</p></a></li>
<li><a href='#msfit.flexsurvreg'><p>Cumulative intensity function for parametric multi-state models</p></a></li>
<li><a href='#nobs.flexsurvreg'><p>Number of observations contributing to a fitted flexible survival model</p></a></li>
<li><a href='#normboot.flexsurvreg'><p>Simulate from the asymptotic normal distribution of parameter estimates.</p></a></li>
<li><a href='#p_flexsurvmix'><p>Transition probabilities from a flexsurvmix model</p></a></li>
<li><a href='#pars.fmsm'><p>Transition-specific parameters in a flexible parametric multi-state model</p></a></li>
<li><a href='#pdf_flexsurvmix'><p>Fitted densities for times to events in a flexsurvmix model</p></a></li>
<li><a href='#pfinal_fmsm'><p>Probabilities of final states in a flexible parametric competing risks model</p></a></li>
<li><a href='#plot.flexsurvreg'><p>Plots of fitted flexible survival models</p></a></li>
<li><a href='#plot.standsurv'><p>Plot standardized metrics from a fitted flexsurv model</p></a></li>
<li><a href='#plot.survrtrunc'><p>Plot nonparametric estimates of survival from right-truncated data.</p></a></li>
<li><a href='#pmatrix.fs'><p>Transition probability matrix from a fully-parametric, time-inhomogeneous</p>
Markov multi-state model</a></li>
<li><a href='#pmatrix.simfs'><p>Transition probability matrix from a fully-parametric, semi-Markov</p>
multi-state model</a></li>
<li><a href='#ppath_fmixmsm'><p>Probability of each pathway taken through a mixture multi-state model</p></a></li>
<li><a href='#predict.flexsurvreg'><p>Predictions from flexible survival models</p></a></li>
<li><a href='#probs_flexsurvmix'><p>Probabilities of competing events from a flexsurvmix model</p></a></li>
<li><a href='#qfinal_fmixmsm'><p>Quantiles of the distribution of the time until reaching a final state in a</p>
mixture multi-state model</a></li>
<li><a href='#qgeneric'><p>Generic function to find quantiles of a distribution</p></a></li>
<li><a href='#quantile_flexsurvmix'><p>Quantiles of time-to-event distributions in a flexsurvmix model</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.flexsurvreg'><p>Calculate residuals for flexible survival models</p></a></li>
<li><a href='#rmst_flexsurvmix'><p>Restricted mean times to events from a flexsurvmix model</p></a></li>
<li><a href='#rmst_generic'><p>Generic function to find restricted mean survival of a distribution</p></a></li>
<li><a href='#sim.fmsm'><p>Simulate paths through a fully parametric semi-Markov multi-state model</p></a></li>
<li><a href='#simfinal_fmsm'><p>Simulate and summarise final outcomes from a flexible parametric multi-state</p>
model</a></li>
<li><a href='#simfs_bytrans'><p>Reformat simulated multi-state data with one row per simulated transition</p></a></li>
<li><a href='#simt_flexsurvmix'><p>Simulate times to competing events from a mixture multi-state model</p></a></li>
<li><a href='#simulate.flexsurvreg'><p>Simulate censored time-to-event data from a fitted flexsurvreg model</p></a></li>
<li><a href='#standsurv'><p>Marginal survival and hazards of fitted flexsurvreg models</p></a></li>
<li><a href='#summary.flexsurvreg'><p>Summaries of fitted flexible survival models</p></a></li>
<li><a href='#summary.flexsurvrtrunc'><p>Summarise quantities of interest from fitted flexsurvrtrunc models</p></a></li>
<li><a href='#survrtrunc'><p>Nonparametric estimator of survival from right-truncated, uncensored data</p></a></li>
<li><a href='#Survspline'><p>Royston/Parmar spline survival distribution</p></a></li>
<li><a href='#Survsplinek'><p>Royston/Parmar spline survival distribution functions</p></a></li>
<li><a href='#tidy.flexsurvreg'><p>Tidy a flexsurv model object</p></a></li>
<li><a href='#tidy.standsurv'><p>Tidy a standsurv object.</p></a></li>
<li><a href='#totlos.fs'><p>Total length of stay in particular states for a fully-parametric,</p>
time-inhomogeneous Markov multi-state model</a></li>
<li><a href='#totlos.simfs'><p>Expected total length of stay in specific states, from a fully-parametric,</p>
semi-Markov multi-state model</a></li>
<li><a href='#unroll.function'><p>Convert a function with matrix arguments to a function with vector</p>
arguments.</a></li>
<li><a href='#WeibullPH'><p>Weibull distribution in proportional hazards parameterisation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Parametric Survival and Multi-State Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible parametric models for time-to-event data,
    including the Royston-Parmar spline model, generalized gamma and
    generalized F distributions.  Any user-defined parametric
    distribution can be fitted, given at least an R function defining
    the probability density or hazard. There are also tools for
    fitting and predicting from fully parametric multi-state models,
    based on either cause-specific hazards or mixture models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, deSolve, generics, magrittr, mstate (&ge; 0.2.10),
Matrix, muhaz, mvtnorm, numDeriv, quadprog, Rcpp (&ge; 0.11.5),
rlang, rstpm2, purrr, statmod, tibble, tidyr, dplyr,
tidyselect, ggplot2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>flexsurvcure, survminer, lubridate, rmarkdown, colorspace,
eha, knitr, msm, testthat, TH.data</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chjackson/flexsurv-dev">https://github.com/chjackson/flexsurv-dev</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chjackson/flexsurv-dev/issues">https://github.com/chjackson/flexsurv-dev/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-31 19:23:29 UTC; Chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Jackson [aut, cre],
  Paul Metcalfe [ctb],
  Jordan Amdahl [ctb],
  Matthew T. Warkentin [ctb],
  Michael Sweeting [ctb],
  Kevin Kunzmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='flexsurv-package'>flexsurv: Flexible parametric survival and multi-state models</h2><span id='topic+flexsurv-package'></span><span id='topic+_PACKAGE'></span><span id='topic+flexsurv'></span>

<h3>Description</h3>

<p>flexsurv: Flexible parametric models for time-to-event data, including the
generalized gamma, the generalized F and the Royston-Parmar spline model,
and extensible to user-defined distributions.
</p>


<h3>Details</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code> fits parametric models for time-to-event
(survival) data.  Data may be right-censored, and/or left-censored, and/or
left-truncated.  Several built-in parametric distributions are available.
Any user-defined parametric model can also be employed by supplying a list
with basic information about the distribution, including the density or
hazard and ideally also the cumulative distribution or hazard.
</p>
<p>Covariates can be included using a linear model on any parameter of the
distribution, log-transformed to the real line if necessary.  This
typically defines an accelerated failure time or proportional hazards
model, depending on the distribution and parameter.
</p>
<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code> fits the flexible survival model of Royston
and Parmar (2002) in which the log cumulative hazard is modelled as a
natural cubic spline function of log time.  Covariates can be included on
any of the spline parameters, giving either a proportional hazards model or
an arbitrarily-flexible time-dependent effect.  Alternative proportional
odds or probit parameterisations are available.
</p>
<p>Output from the models can be presented as survivor, cumulative hazard and
hazard functions (<code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>).  These can be plotted
against nonparametric estimates (<code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code>) to assess
goodness-of-fit.  Any other user-defined function of the parameters may be
summarised in the same way.
</p>
<p>Multi-state models for time-to-event data can also be fitted with the same
functions.  Predictions from those models can then be made using the
functions <code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code>, <code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code>,
<code><a href="#topic+totlos.fs">totlos.fs</a></code>, <code><a href="#topic+totlos.simfs">totlos.simfs</a></code>, or
<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>, or alternatively by <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>
followed by <code>mssample</code> or <code>probtrans</code> from the package
<span class="pkg">mstate</span>.
</p>
<p>Distribution (&ldquo;dpqr&rdquo;) functions for the generalized gamma and F
distributions are given in <code><a href="#topic+GenGamma">GenGamma</a></code>, <code><a href="#topic+GenF">GenF</a></code>
(preferred parameterisations) and <code><a href="#topic+GenGamma.orig">GenGamma.orig</a></code>,
<code><a href="#topic+GenF.orig">GenF.orig</a></code> (original parameterisations).
<code><a href="#topic+flexsurv">flexsurv</a></code> also includes the standard Gompertz distribution
with unrestricted shape parameter, see <code><a href="#topic+Gompertz">Gompertz</a></code>.
</p>


<h3>User guide</h3>

<p>The <b>flexsurv user guide</b> vignette explains the
methods in detail, and gives several worked examples.  A further vignette
<b>flexsurv-examples</b> gives a few more complicated examples, and users
are encouraged to submit their own.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Jackson, C. (2016). flexsurv: A Platform for Parametric
Survival Modeling in R. Journal of Statistical Software, 70(8), 1-33.
doi:10.18637/jss.v070.i08
</p>
<p>Royston, P. and Parmar, M. (2002).  Flexible parametric
proportional-hazards and proportional-odds models for censored survival
data, with application to prognostic modelling and estimation of treatment
effects. Statistics in Medicine 21(1):2175-2197.
</p>
<p>Cox, C. (2008). The generalized <code class="reqn">F</code> distribution: An umbrella for
parametric survival analysis.  Statistics in Medicine 27:4301-4312.
</p>
<p>Cox, C., Chu, H., Schneider, M. F. and Mu√±oz, A. (2007).  Parametric
survival analysis and taxonomy of hazard functions for the generalized
gamma distribution.  Statistics in Medicine 26:4252-4374
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/chjackson/flexsurv-dev">https://github.com/chjackson/flexsurv-dev</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/chjackson/flexsurv-dev/issues">https://github.com/chjackson/flexsurv-dev/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.hess_to_cov'>helper function to safely convert a Hessian matrix to covariance matrix</h2><span id='topic+.hess_to_cov'></span>

<h3>Description</h3>

<p>helper function to safely convert a Hessian matrix to covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hess_to_cov(hessian, tol.solve = 1e-09, tol.evalues = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".hess_to_cov_+3A_hessian">hessian</code></td>
<td>
<p>hessian matrix to convert to covariance matrix (must be evaluated at MLE)</p>
</td></tr>
<tr><td><code id=".hess_to_cov_+3A_tol.solve">tol.solve</code></td>
<td>
<p>tolerance used for solve()</p>
</td></tr>
<tr><td><code id=".hess_to_cov_+3A_tol.evalues">tol.evalues</code></td>
<td>
<p>accepted tolerance for negative eigenvalues of the covariance matrix</p>
</td></tr>
<tr><td><code id=".hess_to_cov_+3A_...">...</code></td>
<td>
<p>arguments passed to Matrix::nearPD</p>
</td></tr>
</table>

<hr>
<h2 id='.hessian'>Numerical evaluation of the hessian of a function using numDeriv::hessian</h2><span id='topic+.hessian'></span>

<h3>Description</h3>

<p>We perform a quick check about the expected runtime and adjust the
precision accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hessian(f, x, seconds.warning = 60, default.r = 6, min.r = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".hessian_+3A_f">f</code></td>
<td>
<p>function to compute Hessian for</p>
</td></tr>
<tr><td><code id=".hessian_+3A_x">x</code></td>
<td>
<p>location to evaluate Hessian at</p>
</td></tr>
<tr><td><code id=".hessian_+3A_seconds.warning">seconds.warning</code></td>
<td>
<p>time threshold in seconds to trigger message and
reduce the number of iterations for Richardson extrapolation of
numDeriv::hessian</p>
</td></tr>
<tr><td><code id=".hessian_+3A_default.r">default.r</code></td>
<td>
<p>default number of iterations (high-precision recommendation
of numDeriv)</p>
</td></tr>
<tr><td><code id=".hessian_+3A_min.r">min.r</code></td>
<td>
<p>minial number of iteration, must be at least 2,</p>
</td></tr>
<tr><td><code id=".hessian_+3A_...">...</code></td>
<td>
<p>further arguments passed to method.args of numDeriv::hessian</p>
</td></tr>
</table>

<hr>
<h2 id='ajfit'>Aalen-Johansen nonparametric estimates comparable to a fitted flexsurvmix
model</h2><span id='topic+ajfit'></span>

<h3>Description</h3>

<p>Given a fitted flexsurvmix model, return the Aalen-Johansen estimates of the
probability of occupying each state at a series of times covering the
observed data.  State 1 represents not having experienced any of the
competing events, while state 2 and any further states correspond to having
experienced each of the competing events respectively.  These estimates can
be compared with the fitted probabilities returned by
<code><a href="#topic+p_flexsurvmix">p_flexsurvmix</a></code> to check the fit of a <code>flexsurvmix</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajfit(x, newdata = NULL, tidy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ajfit_+3A_x">x</code></td>
<td>
<p>Fitted model returned by <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="ajfit_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of alternative covariate values to check fit for.
Only factor covariates are supported.</p>
</td></tr>
<tr><td><code id="ajfit_+3A_tidy">tidy</code></td>
<td>
<p>If <code>TRUE</code> then a single tidy data frame is returned.
Otherwise the function returns the object returned by <code>survfit</code>, or a
list of these objects if we are computing subset-specific estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only supported for models with no covariates or models containing
only factor covariates.
</p>
<p>For models with factor covariates, the Aalen-Johansen estimates are computed
for the subsets of the data defined in <code>newdata</code>.  If <code>newdata</code> is
not supplied, then this function returns state occupancy probabilities for
all possible combinations of the factor levels.
</p>
<p>The Aalen-Johansen estimates are computed using
<code><a href="survival.html#topic+survfit">survfit</a></code> from the <code>survival</code> package (Therneau
2020).
</p>


<h3>References</h3>

<p>Therneau T (2020). _A Package for Survival Analysis in R_. R
package version 3.2-3, &lt;URL: https://CRAN.R-project.org/package=survival&gt;.
</p>

<hr>
<h2 id='ajfit_flexsurvmix'>Forms a tidy data frame for plotting the fit of parametric mixture
multi-state models against nonparametric estimates</h2><span id='topic+ajfit_flexsurvmix'></span>

<h3>Description</h3>

<p>This computes Aalen-Johansen estimates of the probability of occupying each
state at a series of times, using <code><a href="#topic+ajfit">ajfit</a></code>. The equivalent
estimates from the parametric model are then produced using
<code><a href="#topic+p_flexsurvmix">p_flexsurvmix</a></code>, and concatenated with the nonparametric
estimates to form a tidy data frame. This data frame can then simply be
plotted using <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajfit_flexsurvmix(x, maxt = NULL, startname = "Start", B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ajfit_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model returned by <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="ajfit_flexsurvmix_+3A_maxt">maxt</code></td>
<td>
<p>Maximum time to produce parametric estimates for.  By default
this is the maximum event time in the data, the maximum time we have
nonparametric estimates for.</p>
</td></tr>
<tr><td><code id="ajfit_flexsurvmix_+3A_startname">startname</code></td>
<td>
<p>Label to give the state corresponding to &quot;no event happened
yet&quot;.  By default this is <code>"Start"</code>.</p>
</td></tr>
<tr><td><code id="ajfit_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulation replications to use to calculate a confidence
interval for the parametric estimates in <code><a href="#topic+p_flexsurvmix">p_flexsurvmix</a></code>. 
Comparable intervals for the Aalen-Johansen estimates are returned if this
is set.  Otherwise if <code>B=NULL</code> then no intervals are returned.</p>
</td></tr>
</table>

<hr>
<h2 id='ajfit_fmsm'>Check the fit of Markov flexible parametric multi-state models against
nonparametric estimates.</h2><span id='topic+ajfit_fmsm'></span>

<h3>Description</h3>

<p>Computes both parametric and comparable Aalen-Johansen nonparametric
estimates from a flexible parametric multi-state model, and returns them
together in a tidy data frame.  Only models with no covariates, or only
factor covariates, are supported.  If there are factor covariates, then the
nonparametric estimates are computed for subgroups defined by combinations
of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajfit_fmsm(x, maxt = NULL, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ajfit_fmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmsm">fmsm</a></code> representing a flexible
parametric multi-state model.  This must be Markov, rather than
semi-Markov, and no check is performed for this.   Note that all
&quot;competing risks&quot; style models, with just one source state and multiple
destination states, are Markov, so those are fine here.</p>
</td></tr>
<tr><td><code id="ajfit_fmsm_+3A_maxt">maxt</code></td>
<td>
<p>Maximum time to compute parametric estimates to.</p>
</td></tr>
<tr><td><code id="ajfit_fmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame defining the subgroups to consider.  This must
have a column for each covariate in the model.  If omitted, then all
potential subgroups defined by combinations of factor covariates are
included.  Continuous covariates are not supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tidy data frame containing both Aalen-Johansen and parametric
estimates of state occupancy over time, and by subgroup if subgroups are
included.
</p>

<hr>
<h2 id='augment.flexsurvreg'>Augment data with information from a flexsurv model object</h2><span id='topic+augment.flexsurvreg'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds information about each observation in the dataset. Most commonly, this includes predicted values in the <code>.fitted</code> column, residuals in the <code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code> column. New columns always begin with a . prefix to avoid overwriting columns in the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
augment(
  x,
  data = NULL,
  newdata = NULL,
  type.predict = "response",
  type.residuals = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.flexsurvreg_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="augment.flexsurvreg_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="tibble.html#topic+tibble">tibble</a></code> containing the original data that was used to produce the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="augment.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="tibble.html#topic+tibble">tibble</a></code> containing all the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified, the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.flexsurvreg_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">predict</a></code> generic. Allowed arguments vary with model class, so be sure to read the <code>predict.my_class</code> documentation.</p>
</td></tr>
<tr><td><code id="augment.flexsurvreg_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed to the type argument of <code><a href="stats.html#topic+residuals">residuals</a></code> generic. Allowed arguments vary with model class, so be sure to read the <code>residuals.my_class</code> documentation.</p>
</td></tr>
<tr><td><code id="augment.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If neither of <code>data</code> or <code>newdata</code> are specified, then <code>model.frame(x)</code> will be used. It is worth noting that <code>model.frame(x)</code> will include a <code><a href="survival.html#topic+Surv">Surv</a></code> object and not the original time-to-event variables used when fitting the <code>flexsurvreg</code> object. If the original data is desired, specify <code>data</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> containing <code>data</code> or <code>newdata</code> and possible additional columns:
</p>

<ul>
<li> <p><code>.fitted</code> Fitted values of model
</p>
</li>
<li> <p><code>.se.fit</code> Standard errors of fitted values
</p>
</li>
<li> <p><code>.resid</code> Residuals (not present if <code>newdata</code> specified)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "exp")
augment(fit, data = ovarian)

</code></pre>

<hr>
<h2 id='basis'>Natural cubic spline basis</h2><span id='topic+basis'></span><span id='topic+dbasis'></span><span id='topic+fss'></span><span id='topic+dfss'></span>

<h3>Description</h3>

<p>Compute a basis for a natural cubic spline, using the parameterisation
described by Royston and Parmar (2002).  Used for flexible parametric
survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(knots, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_+3A_knots">knots</code></td>
<td>
<p>Vector of knot locations in increasing order, including the
boundary knots at the beginning and end.</p>
</td></tr>
<tr><td><code id="basis_+3A_x">x</code></td>
<td>
<p>Vector of ordinates to compute the basis for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact formula for the basis is given in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with one row for each ordinate and one column for each
knot.
</p>
<p><code>basis</code> returns the basis, and <code>dbasis</code> returns its derivative
with respect to <code>x</code>.
</p>
<p><code>fss</code> and <code>dfss</code> are the same, but with the order of the
arguments swapped around for consistency with similar functions in other R
packages.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Royston, P. and Parmar, M. (2002).  Flexible parametric
proportional-hazards and proportional-odds models for censored survival
data, with application to prognostic modelling and estimation of treatment
effects. Statistics in Medicine 21(1):2175-2197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>

<hr>
<h2 id='bc'>Breast cancer survival data</h2><span id='topic+bc'></span>

<h3>Description</h3>

<p>Survival times of 686 patients with primary node positive breast cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc
</code></pre>


<h3>Format</h3>

<p>A data frame with 686 rows.  </p>

<table>
<tr>
 <td style="text-align: right;"> <code>censrec</code> </td><td style="text-align: left;">
(numeric) </td><td style="text-align: left;"> 1=dead, 0=censored </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>rectime</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;">
Time of death or censoring in days</td>
</tr>
<tr>
 <td style="text-align: right;"> <code>group</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;">
Prognostic group: <code>"Good"</code>,<code>"Medium"</code> or <code>"Poor"</code>, </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;">
</td><td style="text-align: left;"> from a regression model developed by Sauerbrei and Royston (1999).</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>German Breast Cancer Study Group, 1984-1989.  Used as a reference
dataset for the spline-based survival model of Royston and Parmar (2002),
implemented here in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.  Originally provided with
the <code>stpm</code> (Royston 2001, 2004) and <code>stpm2</code> (Lambert 2009, 2010)
Stata modules.
</p>


<h3>References</h3>

<p>Royston, P. and Parmar, M. (2002).  Flexible parametric
proportional-hazards and proportional-odds models for censored survival
data, with application to prognostic modelling and estimation of treatment
effects. Statistics in Medicine 21(1):2175-2197.
</p>
<p>Sauerbrei, W. and Royston, P. (1999). Building multivariable prognostic and
diagnostic models: transformation of the predictors using fractional
polynomials.  Journal of the Royal Statistical Society, Series A 162:71-94.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code>
</p>

<hr>
<h2 id='bootci.fmsm'>Bootstrap confidence intervals for flexsurv output functions</h2><span id='topic+bootci.fmsm'></span>

<h3>Description</h3>

<p>Calculate a confidence interval for a model output by repeatedly replacing the parameters in a fitted model object with a draw from the multivariate normal distribution of the maximum likelihood estimates, then recalculating the output function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootci.fmsm(
  x,
  B,
  fn,
  cl = 0.95,
  attrs = NULL,
  cores = NULL,
  sample = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootci.fmsm_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.  Or a list of such objects, defining a multi-state model.</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_b">B</code></td>
<td>
<p>Number of parameter draws to use</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_fn">fn</code></td>
<td>
<p>Function to bootstrap the results of.  It must have an argument named 'codex giving a fitted flexsurv model object.  This may return a value with any format, e.g. list, matrix or vector, as long as it can be converted to a numeric vector with <code>unlist</code>.   See the example below.</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence interval, by default 0.95</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_attrs">attrs</code></td>
<td>
<p>Any attributes of the value returned from <code>fn</code> which we want confidence intervals for.  These will be unlisted, if possible, and appended to the result vector.</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel processing.</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_sample">sample</code></td>
<td>
<p>If <code>TRUE</code> then the bootstrap sample itself is returned.  If <code>FALSE</code> then the quantiles of the sample are returned giving a confidence interval.</p>
</td></tr>
<tr><td><code id="bootci.fmsm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two rows, giving the upper and lower confidence limits respectively.  Each row is a vector of the same length as the unlisted result of the function corresponding to <code>fncall</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## How to use bootci.msm

## Write a function with one argument called x giving a fitted model,
## and returning some results of the model.  The results may be in any form.   

tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))
bexp &lt;- flexsurvreg(Surv(Tstart, Tstop, status) ~ trans, data=bosms3, dist="exp")

summfn &lt;- function(x, t){
 resp &lt;-  pmatrix.fs(x, trans=tmat, t=t)
 rest &lt;- totlos.fs(x, trans=tmat, t=t)
 list(resp, rest)
}

## Use bootci.msm to obtain the confidence interval
## The matrix columns are in the order of the unlisted results of the original
## summfn.  You will have to rearrange them into the format that you want.
## If summfn has any extra arguments, in this case \code{t}, make sure they are
## passed through via the ... argument to bootci.fmsm

bootci.fmsm(bexp, B=3, fn=summfn, t=10)
bootci.fmsm(bexp, B=3, fn=summfn, t=5)

</code></pre>

<hr>
<h2 id='bos'>Bronchiolitis obliterans syndrome after lung transplants</h2><span id='topic+bos'></span><span id='topic+bosms3'></span><span id='topic+bosms4'></span>

<h3>Description</h3>

<p>A dataset containing histories of bronchiolitis obliterans syndrome (BOS)
from lung transplant recipients. BOS is a chronic decline in lung function,
often observed after lung transplantation.
</p>


<h3>Format</h3>

<p>A data frame containing a sequence of observed or censored
transitions to the next stage of severity or death.  It is grouped
by patient and includes histories of 204 patients.  All patients
start in state 1 (no BOS) at six months after transplant, and may
subsequently develop BOS or die.
</p>
<p><code>bosms3</code> contains the data for a three-state model: no BOS, BOS or
death. <code>bosms4</code> uses a four-state representation: no BOS, mild BOS,
moderate/severe BOS or death.  </p>

<table>
<tr>
 <td style="text-align: right;"> <code>id</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;">
Patient identification number </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>from</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Observed
starting state of the transition </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>to</code> </td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> Observed
or potential ending state of the transition </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>Tstart</code> </td><td style="text-align: left;">
(numeric) </td><td style="text-align: left;"> Time at the start of the interval </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>Tstop</code> </td><td style="text-align: left;">
(numeric) </td><td style="text-align: left;"> Time at the end of the interval </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>time</code> </td><td style="text-align: left;">
(numeric) </td><td style="text-align: left;"> Time difference <code>Tstart</code>-<code>Tstop</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>status</code>
</td><td style="text-align: left;"> (numeric) </td><td style="text-align: left;"> 1 if the transition to state <code>to</code> was observed, or
0 if the transition to state <code>to</code> was censored (for example, if the
patient was observed to move to a competing state) </td>
</tr>
<tr>
 <td style="text-align: right;"> <code>trans</code> </td><td style="text-align: left;">
(factor) </td><td style="text-align: left;"> Number of the transition <code>from</code>-<code>to</code> in the set of
all <code>ntrans</code> allowed transitions, numbered from 1 to <code>ntrans</code>.  </td>
</tr>

</table>



<h3>Details</h3>

<p>The entry time of each patient into each stage of BOS was estimated by
clinicians, based on their history of lung function measurements and acute
rejection and infection episodes.  BOS is only assumed to occur beyond six
months after transplant.  In the first six months the function of each
patient's new lung stabilises.  Subsequently BOS is diagnosed by comparing
the lung function against the &quot;baseline&quot; value.
</p>
<p>The same data are provided in the <span class="pkg">msm</span> package, but in the
native format of <span class="pkg">msm</span> to allow Markov models to be fitted.
In <span class="pkg">flexsurv</span>, much more flexible models can be fitted.
</p>


<h3>Source</h3>

<p>Papworth Hospital, U.K.
</p>


<h3>References</h3>

<p>Heng. D. et al. (1998).  Bronchiolitis Obliterans Syndrome:
Incidence, Natural History, Prognosis, and Risk Factors.  Journal of Heart
and Lung Transplantation 17(12)1255&ndash;1263.
</p>

<hr>
<h2 id='coef.flexsurvreg'>Extract model coefficients from fitted flexible survival models</h2><span id='topic+coef.flexsurvreg'></span>

<h3>Description</h3>

<p>Extract model coefficients from fitted flexible survival models.  This
presents all parameter estimates, transformed to the real line if necessary.
For example, shape or scale parameters, which are constrained to be
positive, are returned on the log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="coef.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.  Currently
unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This matches the behaviour of <code>coef.default</code> for standard R model
families such as <code><a href="stats.html#topic+glm">glm</a></code>, where intercepts in regression
models are presented on the same scale as the covariate effects.  Note that
any parameter in a distribution fitted by <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> may be an intercept in a regression model.
</p>


<h3>Value</h3>

<p>This returns the <code>mod$res.t[,"est"]</code> component of the fitted
model object <code>mod</code>.  See <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>,
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code> for full documentation of all components.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>

<hr>
<h2 id='coxsnell_flexsurvreg'>Cox-Snell residuals from a parametric survival model</h2><span id='topic+coxsnell_flexsurvreg'></span>

<h3>Description</h3>

<p>Cox-Snell residuals from a parametric survival model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxsnell_flexsurvreg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxsnell_flexsurvreg_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> representing a fitted survival model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column called <code>est</code> giving the Cox-Snell residual, defined as the fitted cumulative hazard at each data point.
fitted cumulative hazard at the given observed data point, and other columns indicating the observation time,
observed event status, and covariate values defining the data at this point.   
</p>
<p>The cumulative hazards <code>est</code> should form a censored sample from an Exponential(1).  
Therefore to check the fit of the model, plot a nonparametric estimate of the cumulative
hazard curve against a diagonal line through the origin, which is the theoretical cumulative
hazard trajectory of the Exponential(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")
  cs &lt;- coxsnell_flexsurvreg(fitg)
  
  ## Model appears to fit well, with some small sample noise 
  surv &lt;- survfit(Surv(cs$est, ovarian$fustat) ~ 1)
  plot(surv, fun="cumhaz")
  abline(0, 1, col="red")
  
</code></pre>

<hr>
<h2 id='flexsurvmix'>Flexible parametric mixture models for times to competing events</h2><span id='topic+flexsurvmix'></span>

<h3>Description</h3>

<p>In a mixture model for competing events, an individual can experience one of
a set of different events.  We specify a model for the probability that they
will experience each event before the others, and a model for the time to
the event conditionally on that event occurring first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvmix(
  formula,
  data,
  event,
  dists,
  pformula = NULL,
  anc = NULL,
  partial_events = NULL,
  initp = NULL,
  inits = NULL,
  fixedpars = NULL,
  dfns = NULL,
  method = "direct",
  em.control = NULL,
  optim.control = NULL,
  aux = NULL,
  sr.control = survreg.control(),
  integ.opts,
  hess.control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexsurvmix_+3A_formula">formula</code></td>
<td>
<p>Survival model formula.  The left hand side is a <code>Surv</code>
object specified as in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  This may define various
kinds of censoring, as described in <code><a href="survival.html#topic+Surv">Surv</a></code>. Any covariates on
the right hand side of this formula will be placed on the location
parameter for every component-specific distribution. Covariates on other
parameters of the component-specific distributions may be supplied  using
the <code>anc</code> argument.
</p>
<p>Alternatively, <code>formula</code> may be a list of formulae, with one
component for each alternative event.  This may be used to specify
different covariates on the location parameter for different components.
</p>
<p>A list of formulae may also be used to indicate that for particular
individuals, different events may be observed in different ways, with
different censoring mechanisms.  Each  list component specifies the data
and censoring scheme for that mixture component.
</p>
<p>For example, suppose we are studying people admitted to hospital,and the
competing states are death in hospital and discharge from hospital.  At
time t we know that a particular individual is still alive, but we do not
know whether they are still in hospital, or have been discharged.  In this
case, if the individual were to die in hospital, their death time would be
right censored at t.  If the individual will be (or has been) discharged
before death, their discharge time is completely unknown, thus
interval-censored on (0,Inf). Therefore,  we need to store different event
time and status variables in the data for different alternative events.
This is specified here as
</p>
<p><code>formula = list("discharge" = Surv(t1di, t2di, type="interval2"),
  "death" = Surv(t1de, status_de))</code>
</p>
<p>where for this individual, <code>(t1di, t2di) = (0, Inf)</code> and <code>(t1de,
  status_de)  = (t, 0)</code>.
</p>
<p>The &quot;dot&quot; notation commonly used to indicate &quot;all remaining variables&quot; in a
formula is not supported in <code>flexsurvmix</code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_data">data</code></td>
<td>
<p>Data frame containing variables mentioned in <code>formula</code>,
<code>event</code> and <code>anc</code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_event">event</code></td>
<td>
<p>Variable in the data that specifies which of the alternative
events is observed for which individual.  If the individual's follow-up is
right-censored, or if the event is otherwise unknown, this variable must
have the value <code>NA</code>.
</p>
<p>Ideally this should be a factor, since the mixture components can then be
easily identified in the results with a name instead of a number.  If this
is not already a factor, it is coerced to one.   Then the levels of the
factor define the required order for the components of the list arguments
<code>dists</code>, <code>anc</code>, <code>inits</code> and <code>dfns</code>.  Alternatively, if
the components of the list arguments are named according to the levels of
<code>event</code>, then the components can be arranged in any order.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_dists">dists</code></td>
<td>
<p>Vector specifying the parametric distribution to use for each
component. The same distributions are supported as in
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_pformula">pformula</code></td>
<td>
<p>Formula describing covariates to include on the component
membership proabilities by multinomial logistic regression.  The first
component is treated as the baseline.
</p>
<p>The &quot;dot&quot; notation commonly used to indicate &quot;all remaining variables&quot; in a
formula is not supported.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_anc">anc</code></td>
<td>
<p>List of component-specific lists, of length equal to the number
of components.   Each component-specific list is a list of formulae
representing covariate effects on parameters of the distribution.
</p>
<p>If there are covariates for one component but not others, then a list
containing one null formula on the location parameter should be supplied
for the component with no covariates, e.g <code>list(rate=~1)</code> if the
location parameter is called <code>rate</code>.
</p>
<p>Covariates on the location parameter may also be supplied here instead of
in <code>formula</code>.  Supplying them in <code>anc</code> allows some components
but not others to have covariates on their location parameter.  If a covariate
on the location parameter was provided in <code>formula</code>, and there are 
covariates on other parameters, then a null formula should be included 
for the location parameter in <code>anc</code>, e.g <code>list(rate=~1)</code></p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_partial_events">partial_events</code></td>
<td>
<p>List specifying the factor levels of <code>event</code>
which indicate knowledge that an individual will not experience particular
events, but may experience others.   The names of the list indicate codes
that indicate partial knowledge for some individuals.  The list component
is a vector, which must be a subset of <code>levels(event)</code> defining the
events that a person with the corresponding event code may experience.
</p>
<p>For example, suppose there are three alternative events called
<code>"disease1"</code>,<code>"disease2"</code> and <code>"disease3"</code>, and for some
individuals we know that they will not experience <code>"disease2"</code>, but
they may experience the other two events.  In that case we must create a
new factor level, called, for example <code>"disease1or3"</code>, and set the
value of <code>event</code> to be <code>"disease1or3"</code> for those individuals.
Then we use the <code>"partial_events"</code> argument to tell
<code>flexsurvmix</code> what the potential events are for individuals with this
new factor level.
</p>
<p><code>partial_events = list("disease1or3" = c("disease1","disease3"))</code></p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_initp">initp</code></td>
<td>
<p>Initial values for component membership probabilities.  By
default, these are assumed to be equal for each component.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_inits">inits</code></td>
<td>
<p>List of component-specific vectors. Each component-specific
vector contains the initial values for the parameters of the
component-specific model, as would be supplied as the <code>inits</code> argument of
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.   By default, a heuristic is used to obtain
initial values, which depends on the parametric distribution being used,
but is usually based on the empirical mean and/or variance of the survival
times.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_fixedpars">fixedpars</code></td>
<td>
<p>Indexes of parameters to fix at their initial values and
not optimise. Arranged in the order: baseline mixing probabilities,
covariates on mixing probabilities, time-to-event parameters by mixing
component.  Within mixing components, time-to-event parameters are ordered
in the same way as in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>
<p>If <code>fixedpars=TRUE</code> then all parameters will be fixed and the
function simply calculates the log-likelihood at the initial values.
</p>
<p>Not currently supported when using the EM algorithm.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_dfns">dfns</code></td>
<td>
<p>List of lists of user-defined distribution functions, one for
each mixture component.  Each list component is specified as the
<code>dfns</code> argument of <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_method">method</code></td>
<td>
<p>Method for maximising the likelihood.  Either <code>"em"</code> for
the EM algorithm, or <code>"direct"</code> for direct maximisation.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_em.control">em.control</code></td>
<td>
<p>List of settings to control EM algorithm fitting.  The
only options currently available are
</p>
<p><code>trace</code> set to 1 to print the parameter estimates at each iteration
of the EM algorithm
</p>
<p><code>reltol</code> convergence criterion.  The algorithm stops if the log
likelihood changes by a relative amount less than <code>reltol</code>.  The
default is the same as in <code><a href="stats.html#topic+optim">optim</a></code>, that is,
<code>sqrt(.Machine$double.eps)</code>.
</p>
<p><code>var.method</code> method to compute the covariance matrix. <code>"louis"</code>
for the method of Louis (1982), or <code>"direct"</code>for direct numerical
calculation of the Hessian of the log likelihood.
</p>
<p><code>optim.p.control</code> A list that is passed as the <code>control</code>
argument to  <code>optim</code> in the M step for the component membership
probability parameters. The optimisation in the M step for the
time-to-event parameters can be controlled by the <code>optim.control</code>
argument to <code>flexsurvmix</code>.
</p>
<p>For example, <code>em.control = list(trace=1, reltol=1e-12)</code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_optim.control">optim.control</code></td>
<td>
<p>List of options to pass as the <code>control</code> argument
to <code><a href="stats.html#topic+optim">optim</a></code>,  which is used by <code>method="direct"</code> or in the
M step for the time-to-event parameters in <code>method="em"</code>.  By
default, this uses <code>fnscale=10000</code> and <code>ndeps=rep(1e-06,p)</code>
where <code>p</code> is the number of parameters being estimated, unless the
user specifies these options explicitly.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_aux">aux</code></td>
<td>
<p>A named list of other arguments to pass to custom distribution
functions.  This is used, for example, by <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> to
supply the knot locations and modelling scale (e.g. hazard or odds).  This
cannot be used to fix parameters of a distribution &mdash; use
<code>fixedpars</code> for that.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_sr.control">sr.control</code></td>
<td>
<p>For the models which use <code><a href="survival.html#topic+survreg">survreg</a></code> to find the
maximum likelihood estimates (Weibull, exponential, log-normal), this list
is passed as the <code>control</code> argument to <code><a href="survival.html#topic+survreg">survreg</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_integ.opts">integ.opts</code></td>
<td>
<p>List of named arguments to pass to
<code><a href="stats.html#topic+integrate">integrate</a></code>, if a custom density or hazard is provided without
its cumulative version.  For example,
</p>
<p><code>integ.opts = list(rel.tol=1e-12)</code></p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_hess.control">hess.control</code></td>
<td>
<p>List of options to control inversion of the Hessian to
obtain a covariance matrix. Available options are <code>tol.solve</code>, the
tolerance used for <code><a href="base.html#topic+solve">solve</a></code> when inverting the Hessian (default
<code>.Machine$double.eps</code>), and <code>tol.evalues</code>, the accepted
tolerance for negative eigenvalues in the covariance matrix (default
<code>1e-05</code>).
</p>
<p>The Hessian is positive definite, thus invertible, at the maximum
likelihood.  If the Hessian computed after optimisation convergence can't
be inverted, this is either because the converged result is not the
maximum likelihood (e.g. it could be a &quot;saddle point&quot;), or because the
numerical methods used to obtain the Hessian were inaccurate. If you
suspect that the Hessian was computed wrongly enough that it is not
invertible, but not wrongly enough that the nearest valid inverse would be
an inaccurate estimate of the covariance matrix, then these tolerance
values can be modified (reducing <code>tol.solve</code> or increasing
<code>tol.evalues</code>) to allow the inverse to be computed.</p>
</td></tr>
<tr><td><code id="flexsurvmix_+3A_...">...</code></td>
<td>
<p>Optional arguments to the general-purpose optimisation routine
<code><a href="stats.html#topic+optim">optim</a></code>.  For example, the BFGS optimisation algorithm is the
default in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, but this can be changed, for example
to <code>method="Nelder-Mead"</code> which can be more robust to poor initial
values.  If the optimisation fails to converge, consider normalising the
problem using, for example, <code>control=list(fnscale = 2500)</code>, for
example, replacing 2500 by a number of the order of magnitude of the
likelihood. If 'false' convergence is reported with a
non-positive-definite Hessian, then consider tightening the tolerance
criteria for convergence. If the optimisation takes a long time,
intermediate steps can be printed using the <code>trace</code> argument of the
control list. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This differs from the more usual &quot;competing risks&quot; models, where we specify
&quot;cause-specific hazards&quot; describing the time to each competing event.  This
time will not be observed for an individual if one of the competing events
happens first.  The event that happens first is defined by the minimum of
the times to the alternative events.
</p>
<p>The <code>flexsurvmix</code> function fits a mixture model to data consisting of a
single time to an event for each individual, and an indicator for what type
of event occurs for that individual.   The time to event may be observed or
censored, just as in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, and the type of event may be
known or unknown. In a typical application, where we follow up a set of
individuals until they experience an event or a maximum follow-up time is
reached, the event type is known if the time is observed, and the event type
is unknown when follow-up ends and the time is right-censored.
</p>
<p>The model is fitted by maximum likelihood, either directly or by using an
expectation-maximisation (EM) algorithm, by wrapping
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> to compute the likelihood or to implement the E
and M steps.
</p>
<p>Some worked examples are given in the package vignette about multi-state
modelling, which can be viewed by running <code>vignette("multistate", package="flexsurv")</code>.
</p>


<h3>Value</h3>

<p>List of objects containing information about the fitted model.   The
important one is <code>res</code>, a data frame containing the parameter
estimates and associated information.
</p>


<h3>References</h3>

<p>Jackson, C. H. and Tom, B. D. M. and Kirwan, P. D. and Mandal, S.
and Seaman, S. R. and Kunzmann, K. and Presanis, A. M. and De Angelis, D. (2022)
A comparison of two frameworks for multi-state modelling, applied to outcomes
after hospital admissions with COVID-19.  Statistical Methods in Medical Research
31(9) 1656-1674. 
</p>
<p>Larson, M. G., &amp; Dinse, G. E. (1985). A mixture model for the
regression analysis of competing risks data. Journal of the Royal
Statistical Society: Series C (Applied Statistics), 34(3), 201-211.
</p>
<p>Lau, B., Cole, S. R., &amp; Gange, S. J. (2009). Competing risk regression
models for epidemiologic data. American Journal of Epidemiology, 170(2),
244-256.
</p>

<hr>
<h2 id='flexsurvreg'>Flexible parametric regression for time-to-event data</h2><span id='topic+flexsurvreg'></span><span id='topic+flexsurv.dists'></span>

<h3>Description</h3>

<p>Parametric modelling or regression for time-to-event data.  Several built-in
distributions are available, and users may supply their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvreg(
  formula,
  anc = NULL,
  data,
  weights,
  bhazard,
  rtrunc,
  subset,
  na.action,
  dist,
  inits,
  fixedpars = NULL,
  dfns = NULL,
  aux = NULL,
  cl = 0.95,
  integ.opts = NULL,
  sr.control = survreg.control(),
  hessian = TRUE,
  hess.control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexsurvreg_+3A_formula">formula</code></td>
<td>
<p>A formula expression in conventional R linear modelling
syntax. The response must be a survival object as returned by the
<code><a href="survival.html#topic+Surv">Surv</a></code> function, and any covariates are given on the
right-hand side.  For example,
</p>
<p><code>Surv(time, dead) ~ age + sex</code>
</p>
<p><code>Surv</code> objects of <code>type="right"</code>,<code>"counting"</code>,
<code>"interval1"</code> or <code>"interval2"</code> are supported, corresponding to
right-censored, left-truncated or interval-censored observations.
</p>
<p>If there are no covariates, specify <code>1</code> on the right hand side, for
example <code>Surv(time, dead) ~ 1</code>.
</p>
<p>If the right hand side is specified as <code>.</code> all remaining variables are
included as covariates. For example, <code>Surv(time, dead) ~ .</code>
corresponds to <code>Surv(time, dead) ~ age + sex</code> if <code>data</code> contains
the variables <code>time</code>, <code>dead</code>, <code>age</code>, and <code>sex</code>.
</p>
<p>By default, covariates are placed on the &ldquo;location&rdquo; parameter of the
distribution, typically the &quot;scale&quot; or &quot;rate&quot; parameter, through a linear
model, or a log-linear model if this parameter must be positive.  This
gives an accelerated failure time model or a proportional hazards model
(see <code>dist</code> below) depending on how the distribution is
parameterised.
</p>
<p>Covariates can be placed on other (&ldquo;ancillary&rdquo;) parameters by using the
name of the parameter as a &ldquo;function&rdquo; in the formula.  For example, in a
Weibull model, the following expresses the scale parameter in terms of age
and a treatment variable <code>treat</code>, and the shape parameter in terms of
sex and treatment.
</p>
<p><code>Surv(time, dead) ~ age + treat + shape(sex) + shape(treat)</code>
</p>
<p>However, if the names of the ancillary parameters clash with any real
functions that might be used in formulae (such as <code>I()</code>, or
<code>factor()</code>), then those functions will not work in the formula.  A
safer way to model covariates on ancillary parameters is through the
<code>anc</code> argument to <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>
<p><code><a href="survival.html#topic+survreg">survreg</a></code> users should also note that the function
<code>strata()</code> is ignored, so that any covariates surrounded by
<code>strata()</code> are applied to the location parameter.  Likewise the
function <code>frailty()</code> is not handled.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_anc">anc</code></td>
<td>
<p>An alternative and safer way to model covariates on ancillary
parameters, that is, parameters other than the main location parameter of
the distribution.  This is a named list of formulae, with the name of each
component giving the parameter to be modelled.  The model above can also
be defined as:
</p>
<p><code>Surv(time, dead) ~ age + treat, anc = list(shape = ~ sex + treat)</code></p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_data">data</code></td>
<td>
<p>A data frame in which to find variables supplied in
<code>formula</code>.  If not given, the variables should be in the working
environment.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_weights">weights</code></td>
<td>
<p>Optional variable giving case weights.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_bhazard">bhazard</code></td>
<td>
<p>Optional variable giving expected hazards for relative
survival models.  The model is described by Nelson et al. (2007).
</p>
<p><code>bhazard</code> should contain a vector of values for each person in
the data, but only the values for the individuals whose event is observed are
used. <code>bhazard</code> refers to the hazard at the observed event time.
</p>
<p>If <code>bhazard</code> is supplied, then the parameter estimates returned by
<code>flexsurvreg</code> and the outputs returned by <code>summary.flexsurvreg</code>
describe the parametric model for relative survival.
</p>
<p>For relative survival models, the log-likelihood returned by <code>flexsurvreg</code> is a partial
log-likelihood, which omits a constant term defined by the sum of the
cumulative hazards at the event or censoring time for each individual.   
Hence this constant must be added if a full likelihood is needed.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_rtrunc">rtrunc</code></td>
<td>
<p>Optional variable giving individual-specific right-truncation
times.  Used for analysing data with &quot;retrospective ascertainment&quot;.  For
example, suppose we want to estimate the distribution of the time from
onset of a disease to death, but have only observed cases known to have
died by the current date.   In this case, times from onset to death for
individuals in the data are right-truncated by the current date minus the
onset date.   Predicted survival times for new cases can then be described
by an un-truncated version of the fitted distribution.
</p>
<p>These models can suffer from weakly identifiable parameters and
badly-behaved likelihood functions, and it is advised to compare
convergence for different initial values by supplying different
<code>inits</code> arguments to <code>flexsurvreg</code>.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_subset">subset</code></td>
<td>
<p>Vector of integers or logicals specifying the subset of the
observations to be used in the fit.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_na.action">na.action</code></td>
<td>
<p>a missing-data filter function, applied after any 'subset'
argument has been used. Default is <code>options()$na.action</code>.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_dist">dist</code></td>
<td>
<p>Typically, one of the strings in the first column of the
following table, identifying a built-in distribution.  This table also
identifies the location parameters, and whether covariates on these
parameters represent a proportional hazards (PH) or accelerated failure
time (AFT) model.  In an accelerated failure time model, the covariate
speeds up or slows down the passage of time.  So if the coefficient
(presented on the log scale) is log(2), then doubling the covariate value
would give half the expected survival time.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>"gengamma"</code> </td><td style="text-align: left;"> Generalized gamma (stable) </td><td style="text-align: left;"> mu
  </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gengamma.orig"</code> </td><td style="text-align: left;"> Generalized gamma (original) </td><td style="text-align: left;">
  scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"genf"</code> </td><td style="text-align: left;"> Generalized F (stable) </td><td style="text-align: left;"> mu </td><td style="text-align: left;">
  AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"genf.orig"</code> </td><td style="text-align: left;"> Generalized F (original) </td><td style="text-align: left;"> mu </td><td style="text-align: left;"> AFT
  </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"weibull"</code> </td><td style="text-align: left;"> Weibull </td><td style="text-align: left;"> scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gamma"</code>
  </td><td style="text-align: left;"> Gamma </td><td style="text-align: left;"> rate </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"exp"</code> </td><td style="text-align: left;"> Exponential </td><td style="text-align: left;"> rate
  </td><td style="text-align: left;"> PH </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"llogis"</code> </td><td style="text-align: left;"> Log-logistic </td><td style="text-align: left;"> scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"lnorm"</code> </td><td style="text-align: left;"> Log-normal </td><td style="text-align: left;"> meanlog </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gompertz"</code>
  </td><td style="text-align: left;"> Gompertz </td><td style="text-align: left;"> rate </td><td style="text-align: left;"> PH </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p><code>"exponential"</code> and <code>"lognormal"</code> can be used as aliases for
<code>"exp"</code> and <code>"lnorm"</code>, for compatibility with
<code><a href="survival.html#topic+survreg">survreg</a></code>.
</p>
<p>Alternatively, <code>dist</code> can be a list specifying a custom distribution.
See section &ldquo;Custom distributions&rdquo; below for how to construct this list.
</p>
<p>Very flexible spline-based distributions can also be fitted with
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>
<p>The parameterisations of the built-in distributions used here are the same
as in their built-in distribution functions: <code><a href="#topic+dgengamma">dgengamma</a></code>,
<code><a href="#topic+dgengamma.orig">dgengamma.orig</a></code>, <code><a href="#topic+dgenf">dgenf</a></code>,
<code><a href="#topic+dgenf.orig">dgenf.orig</a></code>, <code><a href="stats.html#topic+dweibull">dweibull</a></code>, <code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="stats.html#topic+dexp">dexp</a></code>, <code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, <code><a href="#topic+dgompertz">dgompertz</a></code>,
respectively.  The functions in base R are used where available,
otherwise, they are provided in this package.
</p>
<p>A package vignette &quot;Distributions reference&quot; lists the survivor functions
and covariate effect parameterisations used by each built-in distribution.
</p>
<p>For the Weibull, exponential and log-normal distributions,
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> simply works by calling <code><a href="survival.html#topic+survreg">survreg</a></code> to
obtain the maximum likelihood estimates, then calling <code><a href="stats.html#topic+optim">optim</a></code>
to double-check convergence and obtain the covariance matrix for
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>'s preferred parameterisation.
</p>
<p>The Weibull parameterisation is different from that in
<code><a href="survival.html#topic+survreg">survreg</a></code>, instead it is consistent with
<code><a href="stats.html#topic+dweibull">dweibull</a></code>.  The <code>"scale"</code> reported by
<code><a href="survival.html#topic+survreg">survreg</a></code> is equivalent to <code>1/shape</code> as defined
by <code><a href="stats.html#topic+dweibull">dweibull</a></code> and hence <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  The first
coefficient <code>(Intercept)</code> reported by <code><a href="survival.html#topic+survreg">survreg</a></code>
is equivalent to <code>log(scale)</code> in <code><a href="stats.html#topic+dweibull">dweibull</a></code> and
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>
<p>Similarly in the exponential distribution, the rate, rather than the mean,
is modelled on covariates.
</p>
<p>The object <code>flexsurv.dists</code> lists the names of the built-in
distributions, their parameters, location parameter, functions used to
transform the parameter ranges to and from the real line, and the
functions used to generate initial values of each parameter for
estimation.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_inits">inits</code></td>
<td>
<p>An optional numeric vector giving initial values for each
unknown parameter.  These are numbered in the order: baseline parameters
(in the order they appear in the distribution function, e.g. shape before
scale in the Weibull), covariate effects on the location parameter,
covariate effects on the remaining parameters.  This is the same order as
the printed estimates in the fitted model.
</p>
<p>If not specified, default initial values are chosen from a simple summary
of the survival or censoring times, for example the mean is often used to
initialize scale parameters.  See the object <code>flexsurv.dists</code> for the
exact methods used.  If the likelihood surface may be uneven, it is
advised to run the optimisation starting from various different initial
values to ensure convergence to the true global maximum.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_fixedpars">fixedpars</code></td>
<td>
<p>Vector of indices of parameters whose values will be fixed
at their initial values during the optimisation.  The indices are ordered
as in <code>inits</code>.  For example, in a stable generalized Gamma model with
two covariates, to fix the third of three generalized gamma parameters
(the shape <code>Q</code>, see the help for <code><a href="#topic+GenGamma">GenGamma</a></code>) and the
second covariate, specify <code>fixedpars = c(3, 5)</code></p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_dfns">dfns</code></td>
<td>
<p>An alternative way to define a custom survival distribution (see
section &ldquo;Custom distributions&rdquo; below).  A list whose components may
include <code>"d"</code>, <code>"p"</code>, <code>"h"</code>, or <code>"H"</code> containing the
probability density, cumulative distribution, hazard, or cumulative hazard
functions of the distribution.  For example,
</p>
<p><code>list(d=dllogis, p=pllogis)</code>.
</p>
<p>If <code>dfns</code> is used, a custom <code>dlist</code> must still be provided, but
<code>dllogis</code> and <code>pllogis</code> need not be visible from the global
environment.  This is useful if <code>flexsurvreg</code> is called within other
functions or environments where the distribution functions are also
defined dynamically.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_aux">aux</code></td>
<td>
<p>A named list of other arguments to pass to custom distribution
functions.  This is used, for example, by <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> to
supply the knot locations and modelling scale (e.g. hazard or odds).  This
cannot be used to fix parameters of a distribution &mdash; use
<code>fixedpars</code> for that.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals for maximum likelihood
estimates, by default 0.95.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_integ.opts">integ.opts</code></td>
<td>
<p>List of named arguments to pass to
<code><a href="stats.html#topic+integrate">integrate</a></code>, if a custom density or hazard is provided without
its cumulative version.  For example,
</p>
<p><code>integ.opts = list(rel.tol=1e-12)</code></p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_sr.control">sr.control</code></td>
<td>
<p>For the models which use <code><a href="survival.html#topic+survreg">survreg</a></code> to find the
maximum likelihood estimates (Weibull, exponential, log-normal), this list
is passed as the <code>control</code> argument to <code><a href="survival.html#topic+survreg">survreg</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_hessian">hessian</code></td>
<td>
<p>Calculate the covariances and confidence intervals for the
parameters. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_hess.control">hess.control</code></td>
<td>
<p>List of options to control inversion of the Hessian to
obtain a covariance matrix. Available options are <code>tol.solve</code>, the
tolerance used for <code><a href="base.html#topic+solve">solve</a></code> when inverting the Hessian (default
<code>.Machine$double.eps</code>), and <code>tol.evalues</code>, the accepted
tolerance for negative eigenvalues in the covariance matrix (default
<code>1e-05</code>).
</p>
<p>The Hessian is positive definite, thus invertible, at the maximum
likelihood.  If the Hessian computed after optimisation convergence can't
be inverted, this is either because the converged result is not the
maximum likelihood (e.g. it could be a &quot;saddle point&quot;), or because the
numerical methods used to obtain the Hessian were inaccurate. If you
suspect that the Hessian was computed wrongly enough that it is not
invertible, but not wrongly enough that the nearest valid inverse would be
an inaccurate estimate of the covariance matrix, then these tolerance
values can be modified (reducing <code>tol.solve</code> or increasing
<code>tol.evalues</code>) to allow the inverse to be computed.</p>
</td></tr>
<tr><td><code id="flexsurvreg_+3A_...">...</code></td>
<td>
<p>Optional arguments to the general-purpose optimisation routine
<code><a href="stats.html#topic+optim">optim</a></code>.  For example, the BFGS optimisation algorithm is the
default in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, but this can be changed, for example
to <code>method="Nelder-Mead"</code> which can be more robust to poor initial
values.  If the optimisation fails to converge, consider normalising the
problem using, for example, <code>control=list(fnscale = 2500)</code>, for
example, replacing 2500 by a number of the order of magnitude of the
likelihood. If 'false' convergence is reported with a
non-positive-definite Hessian, then consider tightening the tolerance
criteria for convergence. If the optimisation takes a long time,
intermediate steps can be printed using the <code>trace</code> argument of the
control list. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are estimated by maximum likelihood using the algorithms
available in the standard R <code><a href="stats.html#topic+optim">optim</a></code> function.  Parameters
defined to be positive are estimated on the log scale.  Confidence intervals
are estimated from the Hessian at the maximum, and transformed back to the
original scale of the parameters.
</p>
<p>The usage of <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> is intended to be similar to
<code><a href="survival.html#topic+survreg">survreg</a></code> in the <span class="pkg">survival</span> package.
</p>


<h3>Value</h3>

<p>A list of class <code>"flexsurvreg"</code> containing information about
the fitted model.  Components of interest to users may include:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>A copy of the function call, for use in post-processing.</p>
</td></tr>
<tr><td><code>dlist</code></td>
<td>
<p>List defining the survival distribution used.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>Matrix of maximum likelihood estimates and confidence limits,
with parameters on their natural scales.</p>
</td></tr> <tr><td><code>res.t</code></td>
<td>
<p>Matrix of maximum
likelihood estimates and confidence limits, with parameters all
transformed to the real line (using a log transform for all built-in
models where this is necessary).  The
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>
and <code><a href="stats.html#topic+confint">confint</a></code> methods for <code>flexsurvreg</code> objects work on
this scale.</p>
</td></tr> <tr><td><code>coefficients</code></td>
<td>
<p>The transformed maximum likelihood
estimates, as in <code>res.t</code>. Calling <code>coef()</code> on a
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> object simply returns this component.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Log-likelihood. This will differ from Stata, where the sum
of the log uncensored survival times is added to the log-likelihood in
survival models, to remove dependency on the time scale.   
</p>
<p>For relative survival models specified with <code>bhazard</code>, this is a partial 
log-likelihood which omits a constant term defined by the sum of the
cumulative hazards over all event or censoring times. 
</p>
</td></tr>
<tr><td><code>logliki</code></td>
<td>
<p>Vector of individual contributions to the log-likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's information criterion (-2*log likelihood + 2*number of
estimated parameters)</p>
</td></tr> <tr><td><code>cov</code></td>
<td>
<p>Covariance matrix of the parameters, on
the real-line scale (e.g. log scale), which can be extracted with
<code><a href="stats.html#topic+vcov">vcov</a></code>.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>Data used in the model fit.  To extract
this in the standard R formats, use use
<code><a href="#topic+model.frame.flexsurvreg">model.frame.flexsurvreg</a></code> or
<code><a href="#topic+model.matrix.flexsurvreg">model.matrix.flexsurvreg</a></code>.</p>
</td></tr>
</table>


<h3>Custom distributions</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code> is intended to be
easy to extend to handle new distributions.  To define a new distribution
for use in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, construct a list with the following
elements:
</p>
 <dl>
<dt>&quot;name&quot;</dt><dd><p>A string naming the distribution.  If this
is called <code>"dist"</code>, for example, then there must be visible in the
working environment, at least, either
</p>
<p>a) a function called <code>ddist</code> which defines the probability density,
</p>
<p>or
</p>
<p>b) a function called <code>hdist</code> which defines the hazard.
</p>
<p>Ideally, in case a) there should also be a function called <code>pdist</code>
which defines the probability distribution or cumulative density, and in
case b) there should be a function called <code>Hdist</code> defining the
cumulative hazard.  If these additional functions are not provided,
<span class="pkg">flexsurv</span> attempts to automatically create them by numerically
integrating the density or hazard function.  However, model fitting will
be much slower, or may not even work at all, if the analytic versions of
these functions are not available.
</p>
<p>The functions must accept vector arguments (representing different times,
or alternative values for each parameter) and return the results as a
vector.  The function <code><a href="base.html#topic+Vectorize">Vectorize</a></code> may be helpful for doing
this: see the example below.
These functions may be in an add-on package (see below for an example) or
may be user-written.  If they are user-written they must be defined in the
global environment, or supplied explicitly through the <code>dfns</code> argument
to <code>flexsurvreg</code>.  The latter may be useful if the functions are
created dynamically (as in the source of <code>flexsurvspline</code>) and thus
not visible through R's scoping rules.
</p>
<p>Arguments other than parameters must be named in the conventional way &ndash;
for example <code>x</code> for the first argument of the density function or
hazard, as in <code><a href="stats.html#topic+dnorm">dnorm</a>(x, ...)</code> and <code>q</code> for the first
argument of the probability function.  Density functions should also have
an argument <code>log</code>, after the parameters, which when <code>TRUE</code>,
computes the log density, using a numerically stable additive formula if
possible.
</p>
<p>Additional functions with names beginning with <code>"DLd"</code> and
<code>"DLS"</code> may be defined to calculate the derivatives of the log density
and log survival probability, with respect to the parameters of the
distribution.  The parameters are expressed on the real line, for example
after log transformation if they are defined as positive.  The first
argument must be named <code>t</code>, representing the time, and the remaining
arguments must be named as the parameters of the density function. The
function must return a matrix with rows corresponding to times, and columns
corresponding to the parameters of the distribution.  The derivatives are
used, if available, to speed up the model fitting with <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</dd> <dt>&quot;pars&quot;</dt><dd><p>Vector of strings naming the parameters of the
distribution. These must be the same names as the arguments of the density
and probability functions.  </p>
</dd>
<dt>&quot;location&quot;</dt><dd><p>Name of the main parameter governing the mean of
the distribution.  This is the default parameter on which covariates are
placed in the <code>formula</code> supplied to <code>flexsurvreg</code>. </p>
</dd>
<dt>&quot;transforms&quot;</dt><dd><p>List of R
functions which transform the range of values taken by each parameter onto
the real line.  For example, <code>c(log, log)</code> for a distribution with two
positive parameters. </p>
</dd>
<dt>&quot;inv.transforms&quot;</dt><dd><p>List of R functions defining the
corresponding inverse transformations.  Note these must be lists, even for
single parameter distributions they should be supplied as, e.g.
<code>c(exp)</code> or <code>list(exp)</code>. </p>
</dd>
<dt>&quot;inits&quot;</dt><dd><p>A function of the
observed survival times <code>t</code> (including right-censoring times, and
using the halfway point for interval-censored times) which returns a vector
of reasonable initial values for maximum likelihood estimation of each
parameter.  For example, <code>function(t){ c(1, mean(t)) }</code> will always
initialize the first of two parameters at 1, and the second (a scale
parameter, for instance) at the mean of <code>t</code>.  </p>
</dd> </dl>

<p>For example, suppose we want to use an extreme value survival distribution.
This is available in the CRAN package <span class="pkg">eha</span>, which provides
conventionally-defined density and probability functions called
<code><a href="eha.html#topic+EV">eha::dEV</a></code> and <code><a href="eha.html#topic+EV">eha::pEV</a></code>.  See the Examples below
for the custom list in this case, and the subsequent command to fit the
model.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Jackson, C. (2016). flexsurv: A Platform for Parametric
Survival Modeling in R. Journal of Statistical Software, 70(8), 1-33.
doi:10.18637/jss.v070.i08
</p>
<p>Cox, C. (2008) The generalized <code class="reqn">F</code> distribution: An umbrella for
parametric survival analysis.  Statistics in Medicine 27:4301-4312.
</p>
<p>Cox, C., Chu, H., Schneider, M. F. and Mu√±oz, A. (2007) Parametric survival
analysis and taxonomy of hazard functions for the generalized gamma
distribution.  Statistics in Medicine 26:4252-4374
</p>
<p>Jackson, C. H. and Sharples, L. D. and Thompson, S. G. (2010) Survival
models in health economic evaluations: balancing fit and parsimony to
improve prediction. International Journal of Biostatistics 6(1):Article 34.
</p>
<p>Nelson, C. P., Lambert, P. C., Squire, I. B., &amp; Jones, D. R. (2007).
Flexible parametric models for relative survival, with application in
coronary heart disease. Statistics in medicine, 26(30), 5486-5498.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code> for flexible survival modelling using
the spline model of Royston and Parmar.
</p>
<p><code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code> and <code><a href="#topic+lines.flexsurvreg">lines.flexsurvreg</a></code> to plot
fitted survival, hazards and cumulative hazards from models fitted by
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> and <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compare generalized gamma fit with Weibull
fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian, dist="gengamma")
fitg
fitw &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian, dist="weibull")
fitw
plot(fitg)
lines(fitw, col="blue", lwd.ci=1, lty.ci=1)
## Identical AIC, probably not enough data in this simple example for a
## very flexible model to be worthwhile.

## Custom distribution
## make "dEV" and "pEV" from eha package (if installed)
##   available to the working environment
if (require("eha")) {
custom.ev &lt;- list(name="EV",
                      pars=c("shape","scale"),
                      location="scale",
                      transforms=c(log, log),
                      inv.transforms=c(exp, exp),
                      inits=function(t){ c(1, median(t)) })
fitev &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian,
                    dist=custom.ev)
fitev
lines(fitev, col="purple", col.ci="purple")
}


## Custom distribution: supply the hazard function only
hexp2 &lt;- function(x, rate=1){ rate } # exponential distribution
hexp2 &lt;- Vectorize(hexp2)
custom.exp2 &lt;- list(name="exp2", pars=c("rate"), location="rate",
                    transforms=c(log), inv.transforms=c(exp),
                    inits=function(t)1/mean(t))
flexsurvreg(Surv(futime, fustat) ~ 1, data = ovarian, dist=custom.exp2)
flexsurvreg(Surv(futime, fustat) ~ 1, data = ovarian, dist="exp")
## should give same answer

</code></pre>

<hr>
<h2 id='flexsurvrtrunc'>Flexible parametric models for right-truncated, uncensored data defined by times of initial and final events.</h2><span id='topic+flexsurvrtrunc'></span>

<h3>Description</h3>

<p>This function estimates the distribution of the time between an initial and final event, in situations where individuals are only observed if they have experienced both events before a certain time, thus they are right-truncated at this time.   The time of the initial event provides information about the time from initial to final event, given the truncated observation scheme, and initial events are assumed to occur with an exponential growth rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvrtrunc(
  t,
  tinit,
  rtrunc,
  tmax,
  data = NULL,
  method = "joint",
  dist,
  theta = NULL,
  fixed.theta = TRUE,
  inits = NULL,
  fixedpars = NULL,
  dfns = NULL,
  integ.opts = NULL,
  cl = 0.95,
  optim_control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexsurvrtrunc_+3A_t">t</code></td>
<td>
<p>Vector of time differences between an initial and final event for a set of individuals.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_tinit">tinit</code></td>
<td>
<p>Absolute time of the initial event for each individual.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_rtrunc">rtrunc</code></td>
<td>
<p>Individual-specific right truncation points on the same scale as <code>t</code>, so that each individual's survival time <code>t</code> would not have been observed if it was greater than the corresponding element of <code>rtrunc</code>.  Only used in <code>method="joint"</code>.  In <code>method="final"</code>, the right-truncation is implicit.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_tmax">tmax</code></td>
<td>
<p>Maximum possible time between initial and final events that could have been observed.  This is only used in <code>method="joint"</code>, and is ignored in <code>method="final"</code>.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_data">data</code></td>
<td>
<p>Data frame containing <code>t</code>, <code>rtrunc</code> and <code>tinit</code>.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_method">method</code></td>
<td>
<p>If <code>"joint"</code> then the &quot;joint-conditional&quot; method is used.  If <code>"final"</code> then the &quot;conditional-on-final&quot; method is used.   The &quot;conditional-on-initial&quot; method can be implemented by using <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> with a <code>rtrunc</code> argument.  These methods are all described in Seaman et al. (2020).</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_dist">dist</code></td>
<td>
<p>Typically, one of the strings in the first column of the
following table, identifying a built-in distribution.  This table also
identifies the location parameters, and whether covariates on these
parameters represent a proportional hazards (PH) or accelerated failure
time (AFT) model.  In an accelerated failure time model, the covariate
speeds up or slows down the passage of time.  So if the coefficient
(presented on the log scale) is log(2), then doubling the covariate value
would give half the expected survival time.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>"gengamma"</code> </td><td style="text-align: left;"> Generalized gamma (stable) </td><td style="text-align: left;"> mu
  </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gengamma.orig"</code> </td><td style="text-align: left;"> Generalized gamma (original) </td><td style="text-align: left;">
  scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"genf"</code> </td><td style="text-align: left;"> Generalized F (stable) </td><td style="text-align: left;"> mu </td><td style="text-align: left;">
  AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"genf.orig"</code> </td><td style="text-align: left;"> Generalized F (original) </td><td style="text-align: left;"> mu </td><td style="text-align: left;"> AFT
  </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"weibull"</code> </td><td style="text-align: left;"> Weibull </td><td style="text-align: left;"> scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gamma"</code>
  </td><td style="text-align: left;"> Gamma </td><td style="text-align: left;"> rate </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"exp"</code> </td><td style="text-align: left;"> Exponential </td><td style="text-align: left;"> rate
  </td><td style="text-align: left;"> PH </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"llogis"</code> </td><td style="text-align: left;"> Log-logistic </td><td style="text-align: left;"> scale </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"lnorm"</code> </td><td style="text-align: left;"> Log-normal </td><td style="text-align: left;"> meanlog </td><td style="text-align: left;"> AFT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>"gompertz"</code>
  </td><td style="text-align: left;"> Gompertz </td><td style="text-align: left;"> rate </td><td style="text-align: left;"> PH </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p><code>"exponential"</code> and <code>"lognormal"</code> can be used as aliases for
<code>"exp"</code> and <code>"lnorm"</code>, for compatibility with
<code><a href="survival.html#topic+survreg">survreg</a></code>.
</p>
<p>Alternatively, <code>dist</code> can be a list specifying a custom distribution.
See section &ldquo;Custom distributions&rdquo; below for how to construct this list.
</p>
<p>Very flexible spline-based distributions can also be fitted with
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>
<p>The parameterisations of the built-in distributions used here are the same
as in their built-in distribution functions: <code><a href="#topic+dgengamma">dgengamma</a></code>,
<code><a href="#topic+dgengamma.orig">dgengamma.orig</a></code>, <code><a href="#topic+dgenf">dgenf</a></code>,
<code><a href="#topic+dgenf.orig">dgenf.orig</a></code>, <code><a href="stats.html#topic+dweibull">dweibull</a></code>, <code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="stats.html#topic+dexp">dexp</a></code>, <code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, <code><a href="#topic+dgompertz">dgompertz</a></code>,
respectively.  The functions in base R are used where available,
otherwise, they are provided in this package.
</p>
<p>A package vignette &quot;Distributions reference&quot; lists the survivor functions
and covariate effect parameterisations used by each built-in distribution.
</p>
<p>For the Weibull, exponential and log-normal distributions,
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> simply works by calling <code><a href="survival.html#topic+survreg">survreg</a></code> to
obtain the maximum likelihood estimates, then calling <code><a href="stats.html#topic+optim">optim</a></code>
to double-check convergence and obtain the covariance matrix for
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>'s preferred parameterisation.
</p>
<p>The Weibull parameterisation is different from that in
<code><a href="survival.html#topic+survreg">survreg</a></code>, instead it is consistent with
<code><a href="stats.html#topic+dweibull">dweibull</a></code>.  The <code>"scale"</code> reported by
<code><a href="survival.html#topic+survreg">survreg</a></code> is equivalent to <code>1/shape</code> as defined
by <code><a href="stats.html#topic+dweibull">dweibull</a></code> and hence <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  The first
coefficient <code>(Intercept)</code> reported by <code><a href="survival.html#topic+survreg">survreg</a></code>
is equivalent to <code>log(scale)</code> in <code><a href="stats.html#topic+dweibull">dweibull</a></code> and
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>
<p>Similarly in the exponential distribution, the rate, rather than the mean,
is modelled on covariates.
</p>
<p>The object <code>flexsurv.dists</code> lists the names of the built-in
distributions, their parameters, location parameter, functions used to
transform the parameter ranges to and from the real line, and the
functions used to generate initial values of each parameter for
estimation.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_theta">theta</code></td>
<td>
<p>Initial value (or fixed value) for the exponential growth rate <code>theta</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_fixed.theta">fixed.theta</code></td>
<td>
<p>Should <code>theta</code> be fixed at its initial value or estimated.  This only applies to <code>method="joint"</code>.  For <code>method="final"</code>, <code>theta</code> must be fixed.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_inits">inits</code></td>
<td>
<p>Initial values for the parameters of the parametric survival distributon. If not supplied, a heuristic is used. as is done in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_fixedpars">fixedpars</code></td>
<td>
<p>Integer indices of the parameters of the survival distribution that should be fixed to their values supplied in <code>inits</code>.   Same length as <code>inits</code>.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_dfns">dfns</code></td>
<td>
<p>An alternative way to define a custom survival distribution (see
section &ldquo;Custom distributions&rdquo; below).  A list whose components may
include <code>"d"</code>, <code>"p"</code>, <code>"h"</code>, or <code>"H"</code> containing the
probability density, cumulative distribution, hazard, or cumulative hazard
functions of the distribution.  For example,
</p>
<p><code>list(d=dllogis, p=pllogis)</code>.
</p>
<p>If <code>dfns</code> is used, a custom <code>dlist</code> must still be provided, but
<code>dllogis</code> and <code>pllogis</code> need not be visible from the global
environment.  This is useful if <code>flexsurvreg</code> is called within other
functions or environments where the distribution functions are also
defined dynamically.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_integ.opts">integ.opts</code></td>
<td>
<p>List of named arguments to pass to
<code><a href="stats.html#topic+integrate">integrate</a></code>, if a custom density or hazard is provided without
its cumulative version.  For example,
</p>
<p><code>integ.opts = list(rel.tol=1e-12)</code></p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals for maximum likelihood
estimates, by default 0.95.</p>
</td></tr>
<tr><td><code id="flexsurvrtrunc_+3A_optim_control">optim_control</code></td>
<td>
<p>List to supply as the <code>control</code> argument to <code><a href="stats.html#topic+optim">optim</a></code> to control the likelihood maximisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariates are not currently supported.
</p>
<p>Note that <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, with an <code>rtrunc</code> argument, can fit models for a similar kind of data, but those models ignore the information provided by the time of the initial event.
</p>
<p>A nonparametric estimator of survival under right-truncation is also provided in <code><a href="#topic+survrtrunc">survrtrunc</a></code>.  See Seaman et al. (2020) for a full comparison of the alternative models.
</p>


<h3>References</h3>

<p>Seaman, S., Presanis, A. and Jackson, C. (2020) Estimating a Time-to-Event
Distribution from Right-Truncated Data in an Epidemic: a Review of Methods
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, <code><a href="#topic+survrtrunc">survrtrunc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1) 
## simulate time to initial event
X &lt;- rexp(1000, 0.2)
## simulate time between initial and final event
T &lt;- rgamma(1000, 2, 10) 

## right-truncate to keep only those with final event time
## before tmax
tmax &lt;- 40
obs &lt;- X + T &lt; tmax 
rtrunc &lt;- tmax - X
dat &lt;- data.frame(X, T, rtrunc)[obs,]

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gamma", theta=0.2)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gamma", theta=0.2, fixed.theta=FALSE)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gamma", theta=0.2, inits=c(1, 8))

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gamma", theta=0.2, method="final")

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gamma", fixed.theta=TRUE)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="weibull", fixed.theta=TRUE)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="lnorm", fixed.theta=TRUE)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gengamma", fixed.theta=TRUE)

flexsurvrtrunc(t=T, rtrunc=rtrunc, tinit=X, tmax=40, data=dat,
                dist="gompertz", fixed.theta=TRUE)

</code></pre>

<hr>
<h2 id='flexsurvspline'>Flexible survival regression using the Royston/Parmar spline model.</h2><span id='topic+flexsurvspline'></span>

<h3>Description</h3>

<p>Flexible parametric modelling of time-to-event data using the spline model
of Royston and Parmar (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvspline(
  formula,
  data,
  weights,
  bhazard,
  rtrunc,
  subset,
  k = 0,
  knots = NULL,
  bknots = NULL,
  scale = "hazard",
  timescale = "log",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexsurvspline_+3A_formula">formula</code></td>
<td>
<p>A formula expression in conventional R linear modelling
syntax. The response must be a survival object as returned by the
<code><a href="survival.html#topic+Surv">Surv</a></code> function, and any covariates are given on the right-hand
side.  For example,
</p>
<p><code>Surv(time, dead) ~ age + sex</code>
</p>
<p>specifies a model where the log cumulative hazard (by default, see
<code>scale</code>) is a linear function of the covariates <code>age</code> and
<code>sex</code>.
</p>
<p>If there are no covariates, specify <code>1</code> on the right hand side, for
example <code>Surv(time, dead) ~ 1</code>.
</p>
<p>Time-varying covariate effects can be specified using the method described
in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> for placing covariates on ancillary
parameters.  The ancillary parameters here are named <code>gamma1</code>,
..., <code>gammar</code> where <code>r</code> is the number of knots <code>k</code> plus
one (the &ldquo;degrees of freedom&rdquo; as defined by Royston and Parmar).  So for
the default Weibull model, there is just one ancillary parameter
<code>gamma1</code>.
</p>
<p>Therefore a model with one internal spline knot, where the equivalents of
the Weibull shape and scale parameters, but not the higher-order term
<code>gamma2</code>, vary with age and sex, can be specified as:
</p>
<p><code>Surv(time, dead) ~ age + sex + gamma1(age) + gamma1(sex)</code>
</p>
<p>or alternatively (and more safely, see <code>flexsurvreg</code>)
</p>
<p><code>Surv(time, dead) ~ age + sex, anc=list(gamma1=~age + sex)</code>
</p>
<p><code>Surv</code> objects of <code>type="right"</code>,<code>"counting"</code>,
<code>"interval1"</code> or <code>"interval2"</code> are supported, corresponding to
right-censored, left-truncated or interval-censored observations.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_data">data</code></td>
<td>
<p>A data frame in which to find variables supplied in
<code>formula</code>.  If not given, the variables should be in the working
environment.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_weights">weights</code></td>
<td>
<p>Optional variable giving case weights.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_bhazard">bhazard</code></td>
<td>
<p>Optional variable giving expected hazards for relative
survival models.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_rtrunc">rtrunc</code></td>
<td>
<p>Optional variable giving individual right-truncation times (see <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>).  Note that these models can suffer from weakly identifiable parameters and
badly-behaved likelihood functions, and it is advised to compare
convergence for different initial values by supplying different
<code>inits</code> arguments to <code>flexsurvspline</code>.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_subset">subset</code></td>
<td>
<p>Vector of integers or logicals specifying the subset of the
observations to be used in the fit.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_k">k</code></td>
<td>
<p>Number of knots in the spline. The default <code>k=0</code> gives a
Weibull, log-logistic or lognormal model, if <code>"scale"</code> is
<code>"hazard"</code>, <code>"odds"</code> or <code>"normal"</code> respectively.  <code>k</code>
is equivalent to <code>df-1</code> in the notation of <code>stpm</code> for Stata.  The
knots are then chosen as equally-spaced quantiles of the log uncensored
survival times, for example, at the median with one knot, or at the 33%
and 67% quantiles of log time (or time, see <code>"timescale"</code>) with two
knots.  To override this default knot placement, specify <code>knots</code>
instead.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_knots">knots</code></td>
<td>
<p>Locations of knots on the axis of log time (or time, see
<code>"timescale"</code>).  If not specified, knot locations are chosen as
described in <code>k</code> above.  Either <code>k</code> or <code>knots</code> must be
specified. If both are specified, <code>knots</code> overrides <code>k</code>.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_bknots">bknots</code></td>
<td>
<p>Locations of boundary knots, on the axis of log time (or
time, see <code>"timescale"</code>).  If not supplied, these are are chosen as
the minimum and maximum log death time.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_scale">scale</code></td>
<td>
<p>If <code>"hazard"</code>, the log cumulative hazard is modelled as a
spline function.
</p>
<p>If <code>"odds"</code>, the log cumulative odds is modelled as a spline function.
</p>
<p>If <code>"normal"</code>, <code class="reqn">-\Phi^{-1}(S(t))</code> is modelled as a
spline function, where <code class="reqn">\Phi^{-1}()</code> is the inverse normal
distribution function <code><a href="stats.html#topic+qnorm">qnorm</a></code>.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_timescale">timescale</code></td>
<td>
<p>If <code>"log"</code> (the default) the log cumulative hazard
(or alternative) is modelled as a spline function of log time.  If
<code>"identity"</code>, it is modelled as a spline function of time, however
this model would not satisfy the desirable property that the cumulative hazard
(or alternative) should approach 0 at time zero.</p>
</td></tr>
<tr><td><code id="flexsurvspline_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to or through
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, for example, <code>anc</code>, <code>inits</code>,
<code>fixedpars</code>, <code>weights</code>, <code>subset</code>, <code>na.action</code>, and any
options to control optimisation.  See <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works as a wrapper around <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> by
dynamically constructing a custom distribution using
<code><a href="#topic+dsurvspline">dsurvspline</a></code>, <code><a href="#topic+psurvspline">psurvspline</a></code> and
<code><a href="#topic+unroll.function">unroll.function</a></code>.
</p>
<p>In the spline-based survival model of Royston and Parmar (2002), a
transformation <code class="reqn">g(S(t,z))</code> of the survival function is modelled as a
natural cubic spline function of log time <code class="reqn">x = \log(t)</code>
plus linear effects of covariates <code class="reqn">z</code>.
</p>
<p style="text-align: center;"><code class="reqn">g(S(t,z)) = s(x, \bm{\gamma}) + \bm{\beta}^T \mathbf{z}</code>
</p>

<p>The proportional hazards model (<code>scale="hazard"</code>) defines
<code class="reqn">g(S(t,\mathbf{z})) = \log(-\log(S(t,\mathbf{z}))) =
\log(H(t,\mathbf{z}))</code>, the
log cumulative hazard.
</p>
<p>The proportional odds model (<code>scale="odds"</code>) defines
<code class="reqn">g(S(t,\mathbf{z})) </code><code class="reqn"> =
\log(S(t,\mathbf{z})^{-1} - 1)</code>, the log
cumulative odds.
</p>
<p>The probit model (<code>scale="normal"</code>) defines <code class="reqn">g(S(t,\mathbf{z})) =
</code><code class="reqn"> -\Phi^{-1}(S(t,\mathbf{z}))</code>, where <code class="reqn">\Phi^{-1}()</code> is the inverse normal
distribution function <code><a href="stats.html#topic+qnorm">qnorm</a></code>.
</p>
<p>With no knots, the spline reduces to a linear function, and these models
are equivalent to Weibull, log-logistic and lognormal models respectively.
</p>
<p>The spline coefficients <code class="reqn">\gamma_j: j=1, 2 \ldots </code>, which are called the &quot;ancillary parameters&quot; above, may also be
modelled as linear functions of covariates <code class="reqn">\mathbf{z}</code>, as
</p>
<p style="text-align: center;"><code class="reqn">\gamma_j(\mathbf{z}) = \gamma_{j0} + \gamma_{j1}z_1 + \gamma_{j2}z_2
+ ... </code>
</p>

<p>giving a model where the effects of covariates are arbitrarily flexible
functions of time: a non-proportional hazards or odds model.
</p>
<p>Natural cubic splines are cubic splines constrained to be linear beyond
boundary knots <code class="reqn">k_{min},k_{max}</code>.  The spline function is
defined as
</p>
<p style="text-align: center;"><code class="reqn">s(x,\bm{\gamma}) = \gamma_0 + \gamma_1 x + \gamma_2 v_1(x) + \ldots +
</code>
</p>
<p style="text-align: center;"><code class="reqn"> \gamma_{m+1} v_m(x)</code>
</p>

<p>where <code class="reqn">v_j(x)</code> is the <code class="reqn">j</code>th basis function
</p>
<p style="text-align: center;"><code class="reqn">v_j(x) = (x - k_j)^3_+ - \lambda_j(x - k_{min})^3_+ - (1 - </code>
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_j) (x - k_{max})^3_+</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda_j = \frac{k_{max} - k_j}{k_{max} - k_{min}}</code>
</p>

<p>and <code class="reqn">(x - a)_+ = max(0, x - a)</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"flexsurvreg"</code> with the same elements as
described in <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, and including extra components
describing the spline model.  See in particular:
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>Number of knots.</p>
</td></tr> <tr><td><code>knots</code></td>
<td>
<p>Location of knots on the log time
axis.</p>
</td></tr> <tr><td><code>scale</code></td>
<td>
<p>The <code>scale</code> of the model, hazard, odds or normal.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>Matrix of maximum likelihood estimates and confidence limits.
Spline coefficients are labelled <code>"gamma..."</code>, and covariate effects
are labelled with the names of the covariates.
</p>
<p>Coefficients <code>gamma1,gamma2,...</code> here are the equivalent of
<code>s0,s1,...</code> in Stata <code>streg</code>, and <code>gamma0</code> is the equivalent
of the <code>xb</code> constant term.  To reproduce results, use the
<code>noorthog</code> option in Stata, since no orthogonalisation is performed on
the spline basis here.
</p>
<p>In the Weibull model, for example, <code>gamma0,gamma1</code> are
<code>-shape*log(scale), shape</code> respectively in <code><a href="stats.html#topic+dweibull">dweibull</a></code> or
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> notation, or (<code>-Intercept/scale</code>,
<code>1/scale</code>) in <code><a href="survival.html#topic+survreg">survreg</a></code> notation.
</p>
<p>In the log-logistic model with shape <code>a</code> and scale <code>b</code> (as in
<code><a href="eha.html#topic+Loglogistic">eha::dllogis</a></code> from the <span class="pkg">eha</span> package), <code>1/b^a</code> is
equivalent to <code>exp(gamma0)</code>, and <code>a</code> is equivalent to
<code>gamma1</code>.
</p>
<p>In the log-normal model with log-scale mean <code>mu</code> and standard
deviation <code>sigma</code>, <code>-mu/sigma</code> is equivalent to <code>gamma0</code> and
<code>1/sigma</code> is equivalent to <code>gamma1</code>.  </p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>The
maximised log-likelihood.  This will differ from Stata, where the sum of
the log uncensored survival times is added to the log-likelihood in
survival models, to remove dependency on the time scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Royston, P. and Parmar, M. (2002).  Flexible parametric
proportional-hazards and proportional-odds models for censored survival
data, with application to prognostic modelling and estimation of treatment
effects. Statistics in Medicine 21(1):2175-2197.
</p>
<p>Jackson, C. (2016). flexsurv: A Platform for Parametric Survival Modeling
in R. Journal of Statistical Software, 70(8), 1-33.
doi:10.18637/jss.v070.i08
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code> for flexible survival modelling using
general parametric distributions.
</p>
<p><code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code> and <code><a href="#topic+lines.flexsurvreg">lines.flexsurvreg</a></code> to plot
fitted survival, hazards and cumulative hazards from models fitted by
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code> and <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Best-fitting model to breast cancer data from Royston and Parmar (2002)
## One internal knot (2 df) and cumulative odds scale

spl &lt;- flexsurvspline(Surv(recyrs, censrec) ~ group, data=bc, k=1, scale="odds")

## Fitted survival

plot(spl, lwd=3, ci=FALSE)

## Simple Weibull model fits much less well

splw &lt;- flexsurvspline(Surv(recyrs, censrec) ~ group, data=bc, k=0, scale="hazard")
lines(splw, col="blue", ci=FALSE)

## Alternative way of fitting the Weibull

## Not run: 
splw2 &lt;- flexsurvreg(Surv(recyrs, censrec) ~ group, data=bc, dist="weibull")

## End(Not run)

</code></pre>

<hr>
<h2 id='fmixmsm'>Constructor for a mixture multi-state model based on flexsurvmix</h2><span id='topic+fmixmsm'></span>

<h3>Description</h3>

<p>Constructor for a mixture multi-state model based on flexsurvmix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmixmsm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmixmsm_+3A_...">...</code></td>
<td>
<p>Named arguments.  Each argument should be a fitted model as
returned by <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.  The name of each argument names
the starting state for that model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+flexsurvmix">flexsurvmix</a></code> objects, with the following
attribute(s):
</p>
<p><code>pathways</code> A list of all potential pathways until absorption, for
models without cycles.   For models with cycles this will have an element
<code>has_cycle=TRUE</code>, plus the pathways discovered before the function
found the cycle and gave up.
</p>

<hr>
<h2 id='fmsm'>Construct a multi-state model from a set of parametric survival models</h2><span id='topic+fmsm'></span>

<h3>Description</h3>

<p>Construct a multi-state model from a set of parametric survival models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmsm(..., trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmsm_+3A_...">...</code></td>
<td>
<p>Objects returned by <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code> representing fitted survival models.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_trans">trans</code></td>
<td>
<p>A matrix of integers specifying which models correspond to
which transitions.  The <code class="reqn">r,s</code> entry is <code>i</code> if the <code class="reqn">i</code>th
argument specified in <code>...</code> is the model for the state <code class="reqn">r</code> to
state <code class="reqn">s</code> transition.  The entry should be <code>NA</code> if the 
transition is disallowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the objects given in <code>...</code>, and with
attributes <code>"trans"</code> and <code>"statenames"</code> defining the transition
structure matrix and state names, and with list components named to
describe the transitions they correspond to.  If any of the arguments in
<code>...</code> are named, then these are used to define the transition names,
otherwise default names are chosen based on the state names.
</p>

<hr>
<h2 id='GenF'>Generalized F distribution</h2><span id='topic+GenF'></span><span id='topic+dgenf'></span><span id='topic+pgenf'></span><span id='topic+qgenf'></span><span id='topic+rgenf'></span><span id='topic+Hgenf'></span><span id='topic+hgenf'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and
random generation for the generalized F distribution, using the
reparameterisation by Prentice (1975).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenf(x, mu = 0, sigma = 1, Q, P, log = FALSE)

pgenf(q, mu = 0, sigma = 1, Q, P, lower.tail = TRUE, log.p = FALSE)

Hgenf(x, mu = 0, sigma = 1, Q, P)

hgenf(x, mu = 0, sigma = 1, Q, P)

qgenf(p, mu = 0, sigma = 1, Q, P, lower.tail = TRUE, log.p = FALSE)

rgenf(n, mu = 0, sigma = 1, Q, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenF_+3A_x">x</code>, <code id="GenF_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GenF_+3A_mu">mu</code></td>
<td>
<p>Vector of location parameters.</p>
</td></tr>
<tr><td><code id="GenF_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scale parameters.</p>
</td></tr>
<tr><td><code id="GenF_+3A_q">Q</code></td>
<td>
<p>Vector of first shape parameters.</p>
</td></tr>
<tr><td><code id="GenF_+3A_p">P</code></td>
<td>
<p>Vector of second shape parameters.</p>
</td></tr>
<tr><td><code id="GenF_+3A_log">log</code>, <code id="GenF_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GenF_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="GenF_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GenF_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">y \sim F(2s_1, 2s_2)</code>, and <code class="reqn">w = </code><code class="reqn"> \log(y)</code> then <code class="reqn">x = \exp(w\sigma + \mu)</code> has the original generalized F distribution with
location parameter <code class="reqn">\mu</code>, scale parameter <code class="reqn">\sigma&gt;0</code>
and shape parameters <code class="reqn">s_1,s_2</code>.
</p>
<p>In this more stable version described by Prentice (1975),
<code class="reqn">s_1,s_2</code> are replaced by shape parameters <code class="reqn">Q,P</code>, with
<code class="reqn">P&gt;0</code>, and
</p>
<p style="text-align: center;"><code class="reqn">s_1 = 2(Q^2 + 2P + Q\delta)^{-1}, \quad s_2 = 2(Q^2 + 2P -
Q\delta)^{-1}</code>
</p>
<p> equivalently </p>
<p style="text-align: center;"><code class="reqn">Q = \left(\frac{1}{s_1} -
\frac{1}{s_2}\right)\left(\frac{1}{s_1} + \frac{1}{s_2}\right)^{-1/2},
\quad P = \frac{2}{s_1 + s_2} </code>
</p>

<p>Define <code class="reqn">\delta = (Q^2 + 2P)^{1/2}</code>, and
<code class="reqn">w = (\log(x) - \mu)\delta /\sigma</code>,
then the probability density function of <code class="reqn">x</code> is </p>
<p style="text-align: center;"><code class="reqn"> f(x) =
\frac{\delta (s_1/s_2)^{s_1} e^{s_1 w}}{\sigma x (1 + s_1 e^w/s_2) ^ {(s_1
+ s_2)} B(s_1, s_2)} </code>
</p>
<p style="text-align: center;"><code class="reqn"> </code>
</p>
<p> The
original parameterisation is available in this package as
<code><a href="#topic+dgenf.orig">dgenf.orig</a></code>, for the sake of completion / compatibility.  With
the above definitions,
</p>
<p><code>dgenf(x, mu=mu, sigma=sigma, Q=Q, P=P) = dgenf.orig(x, mu=mu,
sigma=sigma/delta, s1=s1, s2=s2)</code>
</p>
<p>The generalized F distribution with <code>P=0</code> is equivalent to the
generalized gamma distribution <code><a href="#topic+dgengamma">dgengamma</a></code>, so that
<code>dgenf(x, mu, sigma, Q, P=0)</code> equals <code>dgengamma(x, mu, sigma,
Q)</code>.  The generalized gamma reduces further to several common
distributions, as described in the <code><a href="#topic+GenGamma">GenGamma</a></code> help page.
</p>
<p>The generalized F distribution includes the log-logistic distribution (see
<code><a href="eha.html#topic+Loglogistic">eha::dllogis</a></code>) as a further special case:
</p>
<p><code>dgenf(x, mu=mu, sigma=sigma, Q=0, P=1) = <a href="eha.html#topic+Loglogistic">eha::dllogis</a>(x,
shape=sqrt(2)/sigma, scale=exp(mu))</code>
</p>
<p>The range of hazard trajectories available under this distribution are
discussed in detail by Cox (2008).  Jackson et al. (2010) give an
application to modelling oral cancer survival for use in a health economic
evaluation of screening.
</p>


<h3>Value</h3>

<p><code>dgenf</code> gives the density, <code>pgenf</code> gives the distribution
function, <code>qgenf</code> gives the quantile function, <code>rgenf</code> generates
random deviates, <code>Hgenf</code> retuns the cumulative hazard and <code>hgenf</code>
the hazard.
</p>


<h3>Note</h3>

<p>The parameters <code>Q</code> and <code>P</code> are usually called <code class="reqn">q</code> and
<code class="reqn">p</code> in the literature - they were made upper-case in these R functions
to avoid clashing with the conventional arguments <code>q</code> in the
probability function and <code>p</code> in the quantile function.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>R. L. Prentice (1975). Discrimination among some parametric
models. Biometrika 62(3):607-614.
</p>
<p>Cox, C. (2008). The generalized <code class="reqn">F</code> distribution: An umbrella for
parametric survival analysis.  Statistics in Medicine 27:4301-4312.
</p>
<p>Jackson, C. H. and Sharples, L. D. and Thompson, S. G. (2010).  Survival
models in health economic evaluations: balancing fit and parsimony to
improve prediction.  International Journal of Biostatistics 6(1):Article
34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenF.orig">GenF.orig</a></code>, <code><a href="#topic+GenGamma">GenGamma</a></code>
</p>

<hr>
<h2 id='GenF.orig'>Generalized F distribution (original parameterisation)</h2><span id='topic+GenF.orig'></span><span id='topic+dgenf.orig'></span><span id='topic+pgenf.orig'></span><span id='topic+qgenf.orig'></span><span id='topic+rgenf.orig'></span><span id='topic+Hgenf.orig'></span><span id='topic+hgenf.orig'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the generalized F distribution, using the less
flexible original parameterisation described by Prentice (1975).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenf.orig(x, mu = 0, sigma = 1, s1, s2, log = FALSE)

pgenf.orig(q, mu = 0, sigma = 1, s1, s2, lower.tail = TRUE, log.p = FALSE)

Hgenf.orig(x, mu = 0, sigma = 1, s1, s2)

hgenf.orig(x, mu = 0, sigma = 1, s1, s2)

qgenf.orig(p, mu = 0, sigma = 1, s1, s2, lower.tail = TRUE, log.p = FALSE)

rgenf.orig(n, mu = 0, sigma = 1, s1, s2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenF.orig_+3A_x">x</code>, <code id="GenF.orig_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_mu">mu</code></td>
<td>
<p>Vector of location parameters.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scale parameters.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_s1">s1</code></td>
<td>
<p>Vector of first F shape parameters.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_s2">s2</code></td>
<td>
<p>vector of second F shape parameters.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_log">log</code>, <code id="GenF.orig_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GenF.orig_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">y \sim F(2s_1, 2s_2)</code>, and <code class="reqn">w = </code><code class="reqn"> \log(y)</code> then <code class="reqn">x = \exp(w\sigma + \mu)</code> has the original generalized F distribution with
location parameter <code class="reqn">\mu</code>, scale parameter <code class="reqn">\sigma&gt;0</code>
and shape parameters <code class="reqn">s_1&gt;0,s_2&gt;0</code>.  The probability density
function of <code class="reqn">x</code> is
</p>
<p style="text-align: center;"><code class="reqn">f(x | \mu, \sigma, s_1, s_2) = \frac{(s_1/s_2)^{s_1} e^{s_1 w}}{\sigma x (1 + s_1 e^w/s_2) ^ {(s_1 + s_2)} B(s_1, s_2)}</code>
</p>

<p>where <code class="reqn">w = (\log(x) - \mu)/\sigma</code>, and
<code class="reqn">B(s_1,s_2) = \Gamma(s_1)\Gamma(s_2)/\Gamma(s_1+s_2)</code> is the beta function.
</p>
<p>As <code class="reqn">s_2 \rightarrow \infty</code>, the distribution
of <code class="reqn">x</code> tends towards an original generalized gamma
distribution with the following parameters:
</p>
<p><code><a href="#topic+dgengamma.orig">dgengamma.orig</a>(x, shape=1/sigma, scale=exp(mu) /
s1^sigma, k=s1)</code>
</p>
<p>See <code><a href="#topic+GenGamma.orig">GenGamma.orig</a></code> for how this includes several
other common distributions as special cases.
</p>
<p>The alternative parameterisation of the generalized F
distribution, originating from Prentice (1975) and given in this
package as <code><a href="#topic+GenF">GenF</a></code>, is preferred for statistical
modelling, since it is more stable as <code class="reqn">s_1</code> tends to
infinity, and includes a further new class of distributions with
negative first shape parameter.  The original is provided here for
the sake of completion and compatibility.
</p>


<h3>Value</h3>

<p><code>dgenf.orig</code> gives the density, <code>pgenf.orig</code> gives the
distribution function, <code>qgenf.orig</code> gives the quantile function,
<code>rgenf.orig</code> generates random deviates, <code>Hgenf.orig</code> retuns the
cumulative hazard and <code>hgenf.orig</code> the hazard.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>R. L. Prentice (1975). Discrimination among some parametric
models. Biometrika 62(3):607-614.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenF">GenF</a></code>, <code><a href="#topic+GenGamma.orig">GenGamma.orig</a></code>,
<code><a href="#topic+GenGamma">GenGamma</a></code>
</p>

<hr>
<h2 id='GenGamma'>Generalized gamma distribution</h2><span id='topic+GenGamma'></span><span id='topic+dgengamma'></span><span id='topic+pgengamma'></span><span id='topic+qgengamma'></span><span id='topic+rgengamma'></span><span id='topic+Hgengamma'></span><span id='topic+hgengamma'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and
random generation for the generalized gamma distribution, using
the parameterisation originating from Prentice (1974). Also known
as the (generalized) log-gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgengamma(x, mu = 0, sigma = 1, Q, log = FALSE)

pgengamma(q, mu = 0, sigma = 1, Q, lower.tail = TRUE, log.p = FALSE)

Hgengamma(x, mu = 0, sigma = 1, Q)

hgengamma(x, mu = 0, sigma = 1, Q)

qgengamma(p, mu = 0, sigma = 1, Q, lower.tail = TRUE, log.p = FALSE)

rgengamma(n, mu = 0, sigma = 1, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenGamma_+3A_x">x</code>, <code id="GenGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_mu">mu</code></td>
<td>
<p>Vector of &ldquo;location&rdquo; parameters.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_sigma">sigma</code></td>
<td>
<p>Vector of &ldquo;scale&rdquo; parameters.  Note the inconsistent
meanings of the term &ldquo;scale&rdquo; - this parameter is analogous to the
(log-scale) standard deviation of the log-normal distribution, &ldquo;sdlog&rdquo; in
<code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, rather than the &ldquo;scale&rdquo; parameter of the gamma
distribution <code><a href="stats.html#topic+dgamma">dgamma</a></code>. Constrained to be positive.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_q">Q</code></td>
<td>
<p>Vector of shape parameters.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_log">log</code>, <code id="GenGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GenGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\gamma \sim Gamma(Q^{-2}, 1)</code> , and <code class="reqn">w =
log(Q^2 \gamma) / Q</code>, then <code class="reqn">x = \exp(\mu + \sigma
w)</code> follows the generalized gamma distribution with
probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(x | \mu, \sigma, Q) = \frac{|Q|(Q^{-2})^{Q^{-2}}}{\sigma x
\Gamma(Q^{-2})} \exp(Q^{-2}(Qw - \exp(Qw)))</code>
</p>

<p>This parameterisation is preferred to the original
parameterisation of the generalized gamma by Stacy (1962) since it
is more numerically stable near to <code class="reqn">Q=0</code> (the log-normal
distribution), and allows <code class="reqn">Q&lt;=0</code>.  The original is available
in this package as <code><a href="#topic+dgengamma.orig">dgengamma.orig</a></code>, for the sake of
completion and compatibility with other software - this is
implicitly restricted to <code>Q</code>&gt;0 (or <code>k</code>&gt;0 in the original
notation). The parameters of <code><a href="#topic+dgengamma">dgengamma</a></code> and
<code><a href="#topic+dgengamma.orig">dgengamma.orig</a></code> are related as follows.
</p>
<p><code>dgengamma.orig(x, shape=shape, scale=scale, k=k) = </code>
</p>
<p><code>dgengamma(x, mu=log(scale) + log(k)/shape, sigma=1/(shape*sqrt(k)),
Q=1/sqrt(k))</code>
</p>
<p>The generalized gamma distribution simplifies to the gamma,
log-normal and Weibull distributions with the following
parameterisations:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>dgengamma(x, mu, sigma, Q=0)</code> </td><td style="text-align: center;"> <code>=</code> </td><td style="text-align: left;">
<code>dlnorm(x, mu, sigma)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>dgengamma(x, mu, sigma, Q=1)</code> </td><td style="text-align: center;">
<code>=</code> </td><td style="text-align: left;"> <code>dweibull(x, shape=1/sigma, scale=exp(mu))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>dgengamma(x, mu, sigma, Q=sigma)</code> </td><td style="text-align: center;"> <code>=</code> </td><td style="text-align: left;"> <code>dgamma(x,
shape=1/sigma^2, rate=exp(-mu) / sigma^2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> The properties of the
generalized gamma and its applications to survival analysis are discussed
in detail by Cox (2007).
</p>
<p>The generalized F distribution <code><a href="#topic+GenF">GenF</a></code> extends the generalized
gamma to four parameters.
</p>


<h3>Value</h3>

<p><code>dgengamma</code> gives the density, <code>pgengamma</code> gives the
distribution function, <code>qgengamma</code> gives the quantile function,
<code>rgengamma</code> generates random deviates, <code>Hgengamma</code> retuns the
cumulative hazard and <code>hgengamma</code> the hazard.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Prentice, R. L. (1974). A log gamma model and its maximum
likelihood estimation. Biometrika 61(3):539-544.
</p>
<p>Farewell, V. T. and Prentice, R. L. (1977). A study of
distributional shape in life testing. Technometrics 19(1):69-75.
</p>
<p>Lawless, J. F. (1980). Inference in the generalized gamma and log
gamma distributions.  Technometrics 22(3):409-419.
</p>
<p>Cox, C., Chu, H., Schneider, M. F. and Mu√±oz, A. (2007).
Parametric survival analysis and taxonomy of hazard functions for
the generalized gamma distribution.  Statistics in Medicine
26:4252-4374
</p>
<p>Stacy, E. W. (1962). A generalization of the gamma distribution.
Annals of Mathematical Statistics 33:1187-92
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenGamma.orig">GenGamma.orig</a></code>, <code><a href="#topic+GenF">GenF</a></code>,
<code><a href="stats.html#topic+Lognormal">Lognormal</a></code>, <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, <code><a href="stats.html#topic+Weibull">Weibull</a></code>.
</p>

<hr>
<h2 id='GenGamma.orig'>Generalized gamma distribution (original parameterisation)</h2><span id='topic+GenGamma.orig'></span><span id='topic+dgengamma.orig'></span><span id='topic+pgengamma.orig'></span><span id='topic+qgengamma.orig'></span><span id='topic+rgengamma.orig'></span><span id='topic+Hgengamma.orig'></span><span id='topic+hgengamma.orig'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and
random generation for the generalized gamma distribution, using
the original parameterisation from Stacy (1962).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgengamma.orig(x, shape, scale = 1, k, log = FALSE)

pgengamma.orig(q, shape, scale = 1, k, lower.tail = TRUE, log.p = FALSE)

Hgengamma.orig(x, shape, scale = 1, k)

hgengamma.orig(x, shape, scale = 1, k)

qgengamma.orig(p, shape, scale = 1, k, lower.tail = TRUE, log.p = FALSE)

rgengamma.orig(n, shape, scale = 1, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenGamma.orig_+3A_x">x</code>, <code id="GenGamma.orig_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_shape">shape</code></td>
<td>
<p>vector of &ldquo;Weibull&rdquo; shape parameters.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_scale">scale</code></td>
<td>
<p>vector of scale parameters.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_k">k</code></td>
<td>
<p>vector of &ldquo;Gamma&rdquo; shape parameters.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_log">log</code>, <code id="GenGamma.orig_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GenGamma.orig_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">w \sim Gamma(k,1)</code>, then <code class="reqn">x =
\exp(w/shape + \log(scale))</code>
follows the original generalised gamma distribution with the
parameterisation given here (Stacy 1962).  Defining
<code>shape</code><code class="reqn">=b&gt;0</code>, <code>scale</code><code class="reqn">=a&gt;0</code>, <code class="reqn">x</code> has
probability density
</p>
<p style="text-align: center;"><code class="reqn">f(x | a, b, k) = \frac{b}{\Gamma(k)} \frac{x^{bk - 1}}{a^{bk}} </code>
</p>
<p style="text-align: center;"><code class="reqn">
\exp(-(x/a)^b)</code>
</p>

<p>The original generalized gamma distribution simplifies to the
gamma, exponential and Weibull distributions with the following
parameterisations:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>dgengamma.orig(x, shape, scale, k=1)</code> </td><td style="text-align: center;"> <code>=</code>
</td><td style="text-align: left;"> <code><a href="stats.html#topic+dweibull">dweibull</a>(x, shape, scale)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>dgengamma.orig(x,
shape=1, scale, k)</code> </td><td style="text-align: center;"> <code>=</code> </td><td style="text-align: left;"> <code><a href="stats.html#topic+dgamma">dgamma</a>(x, shape=k,
scale)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>dgengamma.orig(x, shape=1, scale, k=1)</code> </td><td style="text-align: center;"> <code>=</code>
</td><td style="text-align: left;"> <code><a href="stats.html#topic+dexp">dexp</a>(x, rate=1/scale)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Also as k tends to infinity, it tends to the log normal (as in
<code><a href="stats.html#topic+dlnorm">dlnorm</a></code>) with the following parameters (Lawless,
1980):
</p>
<p><code>dlnorm(x, meanlog=log(scale) + log(k)/shape,
sdlog=1/(shape*sqrt(k)))</code>
</p>
<p>For more stable behaviour as the distribution tends to the log-normal, an
alternative parameterisation was developed by Prentice (1974).  This is
given in <code><a href="#topic+dgengamma">dgengamma</a></code>, and is now preferred for statistical
modelling.  It is also more flexible, including a further new class of
distributions with negative shape <code>k</code>.
</p>
<p>The generalized F distribution <code><a href="#topic+GenF.orig">GenF.orig</a></code>, and its similar
alternative parameterisation <code><a href="#topic+GenF">GenF</a></code>, extend the generalized
gamma to four parameters.
</p>


<h3>Value</h3>

<p><code>dgengamma.orig</code> gives the density, <code>pgengamma.orig</code>
gives the distribution function, <code>qgengamma.orig</code> gives the quantile
function, <code>rgengamma.orig</code> generates random deviates,
<code>Hgengamma.orig</code> retuns the cumulative hazard and
<code>hgengamma.orig</code> the hazard.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Stacy, E. W. (1962). A generalization of the gamma
distribution.  Annals of Mathematical Statistics 33:1187-92.
</p>
<p>Prentice, R. L. (1974). A log gamma model and its maximum likelihood
estimation. Biometrika 61(3):539-544.
</p>
<p>Lawless, J. F. (1980). Inference in the generalized gamma and log gamma
distributions.  Technometrics 22(3):409-419.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenGamma">GenGamma</a></code>, <code><a href="#topic+GenF.orig">GenF.orig</a></code>,
<code><a href="#topic+GenF">GenF</a></code>, <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>, <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>,
<code><a href="stats.html#topic+Weibull">Weibull</a></code>.
</p>

<hr>
<h2 id='get_basepars'>Evaluate baseline time-to-event distribution parameters given covariate values in a flexsurvmix model</h2><span id='topic+get_basepars'></span>

<h3>Description</h3>

<p>Evaluate baseline time-to-event distribution parameters given covariate values in a flexsurvmix model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_basepars(x, newdata, event)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_basepars_+3A_x">x</code></td>
<td>
<p>Fitted model object</p>
</td></tr>
<tr><td><code id="get_basepars_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of alternative covariate values</p>
</td></tr>
<tr><td><code id="get_basepars_+3A_event">event</code></td>
<td>
<p>Event</p>
</td></tr>
</table>

<hr>
<h2 id='glance.flexsurvreg'>Glance at a flexsurv model object</h2><span id='topic+glance.flexsurvreg'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a tibble with exactly one row of model summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.flexsurvreg_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="glance.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row <code><a href="tibble.html#topic+tibble">tibble</a></code> containing columns:
</p>

<ul>
<li> <p><code>N</code> Number of observations used in fitting
</p>
</li>
<li> <p><code>events</code> Number of events
</p>
</li>
<li> <p><code>censored</code> Number of censored events
</p>
</li>
<li> <p><code>trisk</code> Total length of time-at-risk (i.e. follow-up)
</p>
</li>
<li> <p><code>df</code> Degrees of freedom (i.e. number of estimated parameters)
</p>
</li>
<li> <p><code>logLik</code> Log-likelihood
</p>
</li>
<li> <p><code>AIC</code> Akaike's &quot;An Information Criteria&quot;
</p>
</li>
<li> <p><code>BIC</code> Bayesian Information Criteria
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")
glance(fitg)

</code></pre>

<hr>
<h2 id='Gompertz'>The Gompertz distribution</h2><span id='topic+Gompertz'></span><span id='topic+dgompertz'></span><span id='topic+pgompertz'></span><span id='topic+qgompertz'></span><span id='topic+hgompertz'></span><span id='topic+Hgompertz'></span><span id='topic+rgompertz'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and random
generation for the Gompertz distribution with unrestricted shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgompertz(x, shape, rate = 1, log = FALSE)

pgompertz(q, shape, rate = 1, lower.tail = TRUE, log.p = FALSE)

qgompertz(p, shape, rate = 1, lower.tail = TRUE, log.p = FALSE)

rgompertz(n, shape = 1, rate = 1)

hgompertz(x, shape, rate = 1, log = FALSE)

Hgompertz(x, shape, rate = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gompertz_+3A_x">x</code>, <code id="Gompertz_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_shape">shape</code>, <code id="Gompertz_+3A_rate">rate</code></td>
<td>
<p>vector of shape and rate parameters.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_log">log</code>, <code id="Gompertz_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gompertz distribution with <code>shape</code> parameter <code class="reqn">a</code> and
<code>rate</code> parameter <code class="reqn">b</code> has probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(x | a, b) = be^{ax}\exp(-b/a (e^{ax} - 1))</code>
</p>

<p>and hazard
</p>
<p style="text-align: center;"><code class="reqn">h(x | a, b) = b e^{ax}</code>
</p>

<p>The hazard is increasing for shape <code class="reqn">a&gt;0</code> and decreasing for <code class="reqn">a&lt;0</code>.
For <code class="reqn">a=0</code> the Gompertz is equivalent to the exponential distribution
with constant hazard and rate <code class="reqn">b</code>.
</p>
<p>The probability distribution function is </p>
<p style="text-align: center;"><code class="reqn">F(x | a, b) = 1 - \exp(-b/a
(e^{ax} - 1))</code>
</p>

<p>Thus if <code class="reqn">a</code> is negative, letting <code class="reqn">x</code> tend to infinity shows that
there is a non-zero probability <code class="reqn">\exp(b/a)</code> of living
forever.  On these occasions <code>qgompertz</code> and <code>rgompertz</code> will
return <code>Inf</code>.
</p>


<h3>Value</h3>

<p><code>dgompertz</code> gives the density, <code>pgompertz</code> gives the
distribution function, <code>qgompertz</code> gives the quantile function,
<code>hgompertz</code> gives the hazard function, <code>Hgompertz</code> gives the
cumulative hazard function, and <code>rgompertz</code> generates random deviates.
</p>


<h3>Note</h3>

<p>Some implementations of the Gompertz restrict <code class="reqn">a</code> to be strictly
positive, which ensures that the probability of survival decreases to zero
as <code class="reqn">x</code> increases to infinity.  The more flexible implementation given
here is consistent with <code>streg</code> in Stata.
</p>
<p>The functions <code><a href="eha.html#topic+Gompertz">eha::dgompertz</a></code> and similar available in the
package <span class="pkg">eha</span> label the parameters the other way round, so that what is
called the <code>shape</code> there is called the <code>rate</code> here, and what is
called <code>1 / scale</code> there is called the <code>shape</code> here. The
terminology here is consistent with the exponential <code><a href="stats.html#topic+dexp">dexp</a></code> and
Weibull <code><a href="stats.html#topic+dweibull">dweibull</a></code> distributions in R.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Stata Press (2007) Stata release 10 manual: Survival analysis
and epidemiological tables.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>
</p>

<hr>
<h2 id='hexp'>Hazard and cumulative hazard functions</h2><span id='topic+hexp'></span><span id='topic+Hexp'></span><span id='topic+hgamma'></span><span id='topic+Hgamma'></span><span id='topic+hlnorm'></span><span id='topic+Hlnorm'></span><span id='topic+hweibull'></span><span id='topic+Hweibull'></span><span id='topic+hazard'></span>

<h3>Description</h3>

<p>Hazard and cumulative hazard functions for distributions which are built
into flexsurv, and whose distribution functions are in base R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexp(x, rate = 1, log = FALSE)

Hexp(x, rate = 1, log = FALSE)

hgamma(x, shape, rate = 1, log = FALSE)

Hgamma(x, shape, rate = 1, log = FALSE)

hlnorm(x, meanlog = 0, sdlog = 1, log = FALSE)

Hlnorm(x, meanlog = 0, sdlog = 1, log = FALSE)

hweibull(x, shape, scale = 1, log = FALSE)

Hweibull(x, shape, scale = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="hexp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter (exponential and gamma)</p>
</td></tr>
<tr><td><code id="hexp_+3A_log">log</code></td>
<td>
<p>Compute log hazard or log cumulative hazard</p>
</td></tr>
<tr><td><code id="hexp_+3A_shape">shape</code></td>
<td>
<p>Shape parameter (Weibull and gamma)</p>
</td></tr>
<tr><td><code id="hexp_+3A_meanlog">meanlog</code></td>
<td>
<p>Mean on the log scale (log normal)</p>
</td></tr>
<tr><td><code id="hexp_+3A_sdlog">sdlog</code></td>
<td>
<p>Standard deviation on the log scale (log normal)</p>
</td></tr>
<tr><td><code id="hexp_+3A_scale">scale</code></td>
<td>
<p>Scale parameter (Weibull)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the exponential and the Weibull these are available analytically, and
so are programmed here in numerically stable and efficient forms.
</p>
<p>For the gamma and log-normal, these are simply computed as minus the log of
the survivor function (cumulative hazard) or the ratio of the density and
survivor function (hazard), so are not expected to be robust to extreme
values or quick to compute.
</p>


<h3>Value</h3>

<p>Hazard (functions beginning 'h') or cumulative hazard (functions
beginning 'H').
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>,<code><a href="stats.html#topic+dweibull">dweibull</a></code>,<code><a href="stats.html#topic+dgamma">dgamma</a></code>,<code><a href="stats.html#topic+dlnorm">dlnorm</a></code>,<code><a href="#topic+dgompertz">dgompertz</a></code>,<code><a href="#topic+dgengamma">dgengamma</a></code>,<code><a href="#topic+dgenf">dgenf</a></code>
</p>

<hr>
<h2 id='hr_flexsurvreg'>Hazard ratio as a function of time from a parametric survival model</h2><span id='topic+hr_flexsurvreg'></span>

<h3>Description</h3>

<p>Hazard ratio as a function of time from a parametric survival model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_flexsurvreg(
  x,
  newdata = NULL,
  t = NULL,
  start = 0,
  ci = TRUE,
  B = 1000,
  cl = 0.95,
  na.action = na.pass
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_flexsurvreg_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with two rows, each specifying a set of covariate values.
The hazard ratio is calculated as hazard(z2)/hazard(z1), where z1 is the first row 
of <code>newdata</code> and z2 is the second row.
</p>
<p><code>newdata</code> must be supplied unless the model <code>x</code> includes just one covariate.
With one covariate, a default is constructed, which defines the hazard ratio between
the second and first level of the factor (if the covariate is a factor), or between
a value of 1 and a value of 0 (if the covariate is numeric).</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_t">t</code></td>
<td>
<p>Times to calculate fitted values for. By default, these are the
sorted unique observation (including censoring) times in the data - for
left-truncated datasets these are the &quot;stop&quot; times.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
survival, hazard or cumulative hazard will be conditioned on survival up to
this time.   Predicted times returned with <code>"rmst"</code>, <code>"mean"</code>, <code>"median"</code> or <code>"quantile"</code>
will be times since time zero, not times since the <code>start</code> time.
</p>
<p>A vector of the same length as <code>t</code> can be supplied to allow different
truncation times for each prediction time, though this doesn't make sense
in the usual case where this function is used to calculate a predicted
trajectory for a single individual.  This is why the default <code>start</code>
time was changed for version 0.4 of <span class="pkg">flexsurv</span> - this was previously a
vector of the start times observed in the data.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_ci">ci</code></td>
<td>
<p>Set to <code>FALSE</code> to omit confidence intervals.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution of
the estimates used to calculate confidence intervals or standard errors.
Decrease for greater
speed at the expense of accuracy, or set <code>B=0</code> to turn off calculation
of CIs and SEs.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="hr_flexsurvreg_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what should be done with missing values in <code>newdata</code>.  If <code>na.pass</code> (the default) then summaries of <code>NA</code> are produced for missing covariate values.  If <code>na.omit</code>, then missing values are dropped, the behaviour of <code>summary.flexsurvreg</code> before <code>flexsurv</code> version 1.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with estimate and confidence limits for the hazard ratio, and
one row for each of the times requested in <code>t</code>.
</p>

<hr>
<h2 id='lines.flexsurvreg'>Add fitted flexible survival curves to a plot</h2><span id='topic+lines.flexsurvreg'></span>

<h3>Description</h3>

<p>Add fitted survival (or hazard or cumulative hazard) curves from a
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code> model fit to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
lines(
  x,
  newdata = NULL,
  X = NULL,
  type = "survival",
  t = NULL,
  est = TRUE,
  ci = NULL,
  B = 1000,
  cl = 0.95,
  col = "red",
  lty = 1,
  lwd = 2,
  col.ci = NULL,
  lty.ci = 2,
  lwd.ci = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.flexsurvreg_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, representing a fitted
survival model object.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Covariate values to produce fitted curves for, as a data
frame, as described in <code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_x">X</code></td>
<td>
<p>Covariate values to produce fitted curves for, as a matrix, as
described in <code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_type">type</code></td>
<td>
<p><code>"survival"</code> for survival, <code>"cumhaz"</code> for cumulative
hazard, or <code>"hazard"</code> for hazard, as in
<code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_t">t</code></td>
<td>
<p>Vector of times to plot fitted values for.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_est">est</code></td>
<td>
<p>Plot fitted curves (<code>TRUE</code> or <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_ci">ci</code></td>
<td>
<p>Plot confidence intervals for fitted curves.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of simulations controlling accuracy of confidence
intervals, as used in <code><a href="#topic+summary.flexsurvreg">summary</a></code>.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_cl">cl</code></td>
<td>
<p>Width of confidence intervals, by default 0.95 for 95%
intervals.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_col">col</code></td>
<td>
<p>Colour of the fitted curve(s).</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_lty">lty</code></td>
<td>
<p>Line type of the fitted curve(s).</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the fitted curve(s).</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_col.ci">col.ci</code></td>
<td>
<p>Colour of the confidence limits, defaulting to the same as
for the fitted curve.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_lty.ci">lty.ci</code></td>
<td>
<p>Line type of the confidence limits.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_lwd.ci">lwd.ci</code></td>
<td>
<p>Line width of the confidence limits, defaulting to the same
as for the fitted curve.</p>
</td></tr>
<tr><td><code id="lines.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the generic <code><a href="base.html#topic+plot">plot</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to <code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a>(...,add=TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>
</p>

<hr>
<h2 id='Llogis'>The log-logistic distribution</h2><span id='topic+Llogis'></span><span id='topic+dllogis'></span><span id='topic+pllogis'></span><span id='topic+qllogis'></span><span id='topic+hllogis'></span><span id='topic+Hllogis'></span><span id='topic+rllogis'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and
random generation for the log-logistic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dllogis(x, shape = 1, scale = 1, log = FALSE)

pllogis(q, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE)

qllogis(p, shape = 1, scale = 1, lower.tail = TRUE, log.p = FALSE)

rllogis(n, shape = 1, scale = 1)

hllogis(x, shape = 1, scale = 1, log = FALSE)

Hllogis(x, shape = 1, scale = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Llogis_+3A_x">x</code>, <code id="Llogis_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Llogis_+3A_shape">shape</code>, <code id="Llogis_+3A_scale">scale</code></td>
<td>
<p>vector of shape and scale parameters.</p>
</td></tr>
<tr><td><code id="Llogis_+3A_log">log</code>, <code id="Llogis_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as
log(p).</p>
</td></tr>
<tr><td><code id="Llogis_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P(X \le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Llogis_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Llogis_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the
length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-logistic distribution with <code>shape</code> parameter
<code class="reqn">a&gt;0</code> and <code>scale</code> parameter <code class="reqn">b&gt;0</code> has probability
density function
</p>
<p style="text-align: center;"><code class="reqn">f(x | a, b) = (a/b) (x/b)^{a-1} / (1 + (x/b)^a)^2</code>
</p>

<p>and hazard
</p>
<p style="text-align: center;"><code class="reqn">h(x | a, b) = (a/b) (x/b)^{a-1} / (1 + (x/b)^a)</code>
</p>

<p>for <code class="reqn">x&gt;0</code>. The hazard is decreasing for shape <code class="reqn">a\leq 1</code>, and unimodal for <code class="reqn">a &gt; 1</code>.
</p>
<p>The probability distribution function is </p>
<p style="text-align: center;"><code class="reqn">F(x | a, b) = 1 - 1
/ (1 + (x/b)^a)</code>
</p>

<p>If <code class="reqn">a &gt; 1</code>, the mean is <code class="reqn">b c / sin(c)</code>, and if <code class="reqn">a &gt; 2</code>
the variance is <code class="reqn">b^2 * (2*c/sin(2*c) - c^2/sin(c)^2)</code>, where
<code class="reqn">c = \pi/a</code>, otherwise these are undefined.
</p>


<h3>Value</h3>

<p><code>dllogis</code> gives the density, <code>pllogis</code> gives the
distribution function, <code>qllogis</code> gives the quantile function,
<code>hllogis</code> gives the hazard function, <code>Hllogis</code> gives the
cumulative hazard function, and <code>rllogis</code> generates random
deviates.
</p>


<h3>Note</h3>

<p>Various different parameterisations of this distribution are
used.  In the one used here, the interpretation of the parameters
is the same as in the standard Weibull distribution
(<code><a href="stats.html#topic+dweibull">dweibull</a></code>).  Like the Weibull, the survivor function
is a transformation of <code class="reqn">(x/b)^a</code> from the non-negative real line to [0,1],
but with a different link function.  Covariates on <code class="reqn">b</code>
represent time acceleration factors, or ratios of expected
survival.
</p>
<p>The same parameterisation is also used in
<code><a href="eha.html#topic+Loglogistic">eha::dllogis</a></code> in the <span class="pkg">eha</span> package.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Stata Press (2007) Stata release 10 manual: Survival analysis
and epidemiological tables.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code>
</p>

<hr>
<h2 id='mean_exp'>Mean and restricted mean survival functions</h2><span id='topic+mean_exp'></span><span id='topic+rmst_exp'></span><span id='topic+mean_gamma'></span><span id='topic+rmst_gamma'></span><span id='topic+rmst_genf'></span><span id='topic+mean_genf'></span><span id='topic+rmst_genf.orig'></span><span id='topic+mean_genf.orig'></span><span id='topic+rmst_gengamma'></span><span id='topic+mean_gengamma'></span><span id='topic+rmst_gengamma.orig'></span><span id='topic+mean_gengamma.orig'></span><span id='topic+rmst_gompertz'></span><span id='topic+mean_gompertz'></span><span id='topic+mean_llogis'></span><span id='topic+rmst_llogis'></span><span id='topic+mean_lnorm'></span><span id='topic+rmst_lnorm'></span><span id='topic+mean_weibull'></span><span id='topic+rmst_weibull'></span><span id='topic+rmst_weibullPH'></span><span id='topic+mean_weibullPH'></span><span id='topic+means'></span>

<h3>Description</h3>

<p>Mean and restricted mean survival time functions for distributions which are built
into flexsurv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_exp(rate = 1)

rmst_exp(t, rate = 1, start = 0)

mean_gamma(shape, rate = 1)

rmst_gamma(t, shape, rate = 1, start = 0)

rmst_genf(t, mu, sigma, Q, P, start = 0)

mean_genf(mu, sigma, Q, P)

rmst_genf.orig(t, mu, sigma, s1, s2, start = 0)

mean_genf.orig(mu, sigma, s1, s2)

rmst_gengamma(t, mu = 0, sigma = 1, Q, start = 0)

mean_gengamma(mu = 0, sigma = 1, Q)

rmst_gengamma.orig(t, shape, scale = 1, k, start = 0)

mean_gengamma.orig(shape, scale = 1, k)

rmst_gompertz(t, shape, rate = 1, start = 0)

mean_gompertz(shape, rate = 1)

mean_llogis(shape = 1, scale = 1)

rmst_llogis(t, shape = 1, scale = 1, start = 0)

mean_lnorm(meanlog = 0, sdlog = 1)

rmst_lnorm(t, meanlog = 0, sdlog = 1, start = 0)

mean_weibull(shape, scale = 1)

rmst_weibull(t, shape, scale = 1, start = 0)

rmst_weibullPH(t, shape, scale = 1, start = 0)

mean_weibullPH(shape, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_exp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter (exponential and gamma)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_t">t</code></td>
<td>
<p>Vector of times to which restricted mean survival time is evaluated</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
restricted mean survival will be conditioned on survival up to
this time.</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_shape">shape</code></td>
<td>
<p>Shape parameter (Weibull, gamma, log-logistic, generalized gamma [orig],
generalized F [orig])</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_mu">mu</code></td>
<td>
<p>Mean on the log scale (generalized gamma, generalized F)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation on the log scale (generalized gamma, generalized F)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_q">Q</code></td>
<td>
<p>Vector of first shape parameters (generalized gamma, generalized F)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_p">P</code></td>
<td>
<p>Vector of second shape parameters (generalized F)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_s1">s1</code></td>
<td>
<p>Vector of first F shape parameters (generalized F [orig])</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_s2">s2</code></td>
<td>
<p>vector of second F shape parameters (generalized F [orig])</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_scale">scale</code></td>
<td>
<p>Scale parameter (Weibull, log-logistic, generalized gamma [orig],
generalized F [orig])</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_k">k</code></td>
<td>
<p>vector of shape parameters (generalized gamma [orig]).</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_meanlog">meanlog</code></td>
<td>
<p>Mean on the log scale (log normal)</p>
</td></tr>
<tr><td><code id="mean_exp_+3A_sdlog">sdlog</code></td>
<td>
<p>Standard deviation on the log scale (log normal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the exponential, Weibull, log-logistic, lognormal, and gamma, mean survival is
provided analytically.  Restricted mean survival for the exponential distribution
is also provided analytically.  Mean and restricted means for other distributions
are calculated via numeric integration.
</p>


<h3>Value</h3>

<p>mean survival (functions beginning 'mean') or restricted mean survival
(functions beginning 'rmst_').
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>,<code><a href="stats.html#topic+dweibull">dweibull</a></code>,<code><a href="stats.html#topic+dgamma">dgamma</a></code>,<code><a href="stats.html#topic+dlnorm">dlnorm</a></code>,<code><a href="#topic+dgompertz">dgompertz</a></code>,<code><a href="#topic+dgengamma">dgengamma</a></code>,<code><a href="#topic+dgenf">dgenf</a></code>
</p>

<hr>
<h2 id='mean_flexsurvmix'>Mean times to events from a flexsurvmix model</h2><span id='topic+mean_flexsurvmix'></span>

<h3>Description</h3>

<p>This returns the mean of each event-specific parametric time-to-event
distribution in the mixture model, which is the mean time to event
conditionally on that event being the one that happens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_flexsurvmix(x, newdata = NULL, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="mean_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="mean_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean times to next event conditionally on each alternative event,
given the specified covariate values.
</p>

<hr>
<h2 id='meanfinal_fmixmsm'>Mean time to final state in a mixture multi-state model</h2><span id='topic+meanfinal_fmixmsm'></span>

<h3>Description</h3>

<p>Calculate the mean time from the start of the process to a final (or
&quot;absorbing&quot;) state in a mixture multi-state model.  Models with cycles are
not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanfinal_fmixmsm(x, newdata = NULL, final = FALSE, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanfinal_fmixmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmixmsm">fmixmsm</a></code>, representing a multi-state
model built from piecing together mixture models fitted by
<code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="meanfinal_fmixmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="meanfinal_fmixmsm_+3A_final">final</code></td>
<td>
<p>If <code>TRUE</code> then the mean time to the final state is
calculated for each final state, by taking a weighted average of the mean
time to travel each pathway ending in that final state, weighted by the
probability of the pathway.   If <code>FALSE</code>  (the default) then a
separate mean is calculated for each pathway.</p>
</td></tr>
<tr><td><code id="meanfinal_fmixmsm_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of mean times to absorption, by covariate values and
pathway (or by final state)
</p>

<hr>
<h2 id='model.frame.flexsurvreg'>Extract original data from <code>flexsurvreg</code> objects.</h2><span id='topic+model.frame.flexsurvreg'></span><span id='topic+model.matrix.flexsurvreg'></span>

<h3>Description</h3>

<p>Extract the data from a model fitted with <code>flexsurvreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
model.frame(formula, ...)

## S3 method for class 'flexsurvreg'
model.matrix(object, par = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.flexsurvreg_+3A_formula">formula</code></td>
<td>
<p>A fitted model object, as returned by
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Further arguments (not used).</p>
</td></tr>
<tr><td><code id="model.frame.flexsurvreg_+3A_object">object</code></td>
<td>
<p>A fitted model object, as returned by
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.flexsurvreg_+3A_par">par</code></td>
<td>
<p>String naming the parameter whose linear model matrix is
desired.
</p>
<p>The default value of <code>par=NULL</code> returns a matrix consisting of the
model matrices for all models in the object <code>cbind</code>ed together, with
the intercepts excluded.  This is not really a &ldquo;model matrix&rdquo; in the
usual sense, however, the columns directly correspond to the covariate
coefficients in the matrix of estimates from the fitted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>model.frame</code> returns a data frame with all the original
variables used for the model fit.
</p>
<p><code>model.matrix</code> returns a design matrix for a part of the model that
includes covariates.  The required part is indicated by the <code>"par"</code>
argument (see above).
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>

<hr>
<h2 id='msfit.flexsurvreg'>Cumulative intensity function for parametric multi-state models</h2><span id='topic+msfit.flexsurvreg'></span>

<h3>Description</h3>

<p>Cumulative transition-specific intensity/hazard functions for
fully-parametric multi-state or competing risks models, using a
piecewise-constant approximation that will allow prediction using the
functions in the <span class="pkg">mstate</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msfit.flexsurvreg(
  object,
  t,
  newdata = NULL,
  variance = TRUE,
  tvar = "trans",
  trans,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msfit.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.
</p>
<p>The model should have been fitted to data consisting of one row for each
observed transition and additional rows corresponding to censored times to
competing transitions.  This is the &quot;long&quot; format, or counting process
format, as explained in the <span class="pkg">flexsurv</span> vignette.
</p>
<p>The model should contain a categorical covariate indicating the transition.
In <code>flexsurv</code> this variable can have any name, indicated here by the
<code>tvar</code> argument.  In the Cox models demonstrated by <span class="pkg">mstate</span> it is
usually included in model formulae as <code>strata(trans)</code>, but note that
the <code>strata</code> function does not do anything in <span class="pkg">flexsurv</span>.  The
formula supplied to <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> should be precise about which
parameters are assumed to vary with the transition type.
</p>
<p>Alternatively, if the parameters (including covariate effects) are assumed
to be different between different transitions, then a list of
transition-specific models can be formed.  This list has one component for
each permitted transition in the multi-state model.  This is more
computationally efficient, particularly for larger models and datasets.
See the example below, and the vignette.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_t">t</code></td>
<td>
<p>Vector of times.  These do not need to be the same as the observed
event times, and since the model is parametric, they can be outside the
range of the data.  A grid of more frequent times will provide a better
approximation to the cumulative hazard trajectory for prediction with
<code><a href="mstate.html#topic+probtrans">probtrans</a></code> or <code><a href="mstate.html#topic+mssample">mssample</a></code>, at the
cost of greater computational expense.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  This must be specified if
there are other covariates. The variable names should be the same as those
in the fitted model formula.  There must be either one value per covariate
(the typical situation) or <code class="reqn">n</code> values per covariate, a different one
for each of the <code class="reqn">n</code> allowed transitions.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_variance">variance</code></td>
<td>
<p>Calculate the variances and covariances of the transition
cumulative hazards (<code>TRUE</code> or <code>FALSE</code>).  This is based on
simulation from the normal asymptotic distribution of the estimates, which
is computationally-expensive.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_tvar">tvar</code></td>
<td>
<p>Name of the categorical variable in the model formula that
represents the transition number. The values of this variable should
correspond to elements of <code>trans</code>, conventionally a sequence of
integers starting from 1.  Not required if <code>x</code> is a list of
transition-specific models.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions in the multi-state
model, in the format understood by <span class="pkg">mstate</span>: a matrix of integers whose
<code class="reqn">r,s</code> entry is <code class="reqn">i</code> if the <code class="reqn">i</code>th transition type (reading across
rows) is <code class="reqn">r,s</code>, and has <code>NA</code>s on the diagonal and where the
<code class="reqn">r,s</code> transition is disallowed.</p>
</td></tr>
<tr><td><code id="msfit.flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution used
to calculate variances.  Decrease for greater speed at the expense of
accuracy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"msfit"</code>, in the same form as the objects
used in the <span class="pkg">mstate</span> package.  The <code><a href="mstate.html#topic+msfit">msfit</a></code> method
from <span class="pkg">mstate</span> returns the equivalent cumulative intensities for Cox
regression models fitted with <code><a href="survival.html#topic+coxph">coxph</a></code>.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Liesbeth C. de Wreede, Marta Fiocco, Hein Putter (2011).
<span class="pkg">mstate</span>: An R Package for the Analysis of Competing Risks and
Multi-State Models. <em>Journal of Statistical Software</em>, 38(7), 1-30.
<a href="https://doi.org/10.18637/jss.v038.i07">doi:10.18637/jss.v038.i07</a>
</p>
<p>Mandel, M. (2013). &quot;Simulation based confidence intervals for functions
with complicated derivatives.&quot; The American Statistician 67(2):76-81
</p>


<h3>See Also</h3>

<p><span class="pkg">flexsurv</span> provides alternative functions designed
specifically for predicting from parametric multi-state models without
calling <span class="pkg">mstate</span>.  These include <code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code> and
<code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code> for the transition probability matrix, and
<code><a href="#topic+totlos.fs">totlos.fs</a></code> and <code><a href="#topic+totlos.simfs">totlos.simfs</a></code> for expected total
lengths of stay in states.  These are generally more efficient than going
via <span class="pkg">mstate</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 3 state illness-death model for bronchiolitis obliterans
## Compare clock-reset / semi-Markov multi-state models

## Simple exponential model (reduces to Markov)

bexp &lt;- flexsurvreg(Surv(years, status) ~ trans,
                    data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))
mexp &lt;- msfit.flexsurvreg(bexp, t=seq(0,12,by=0.1),
                          trans=tmat, tvar="trans", variance=FALSE)

## Cox semi-parametric model within each transition

bcox &lt;- coxph(Surv(years, status) ~ strata(trans), data=bosms3)

if (require("mstate")){

mcox &lt;- mstate::msfit(bcox, trans=tmat)

## Flexible parametric spline-based model 

bspl &lt;- flexsurvspline(Surv(years, status) ~ trans + gamma1(trans),
                       data=bosms3, k=3)
mspl &lt;- msfit.flexsurvreg(bspl, t=seq(0,12,by=0.1),
                         trans=tmat, tvar="trans", variance=FALSE)

## Compare fit: exponential model is OK but the spline is better

plot(mcox, lwd=1, xlim=c(0, 12), ylim=c(0,4))
cols &lt;- c("black","red","green")
for (i in 1:3){
    lines(mexp$Haz$time[mexp$Haz$trans==i], mexp$Haz$Haz[mexp$Haz$trans==i],
             col=cols[i], lwd=2, lty=2)
    lines(mspl$Haz$time[mspl$Haz$trans==i], mspl$Haz$Haz[mspl$Haz$trans==i],
             col=cols[i], lwd=3)
}
legend("topright", lwd=c(1,2,3), lty=c(1,2,1),
   c("Cox", "Exponential", "Flexible parametric"), bty="n")

}

## Fit a list of models, one for each transition
## More computationally efficient, but only valid if parameters
## are different between transitions.

## Not run: 
bexp.list &lt;- vector(3, mode="list")
for (i in 1:3) { 
  bexp.list[[i]] &lt;- flexsurvreg(Surv(years, status) ~ 1, subset=(trans==i),
                                data=bosms3, dist="exp")
}

## The list of models can be passed to this and other functions,
## as if it were a single multi-state model. 

msfit.flexsurvreg(bexp.list, t=seq(0,12,by=0.1), trans=tmat)

## End(Not run)

</code></pre>

<hr>
<h2 id='nobs.flexsurvreg'>Number of observations contributing to a fitted flexible survival model</h2><span id='topic+nobs.flexsurvreg'></span>

<h3>Description</h3>

<p>Number of observations contributing to a fitted flexible survival model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="nobs.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.  Currently
unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This matches the behaviour of the <code>nobs</code> method for <code><a href="survival.html#topic+survreg">survreg</a></code> objects, including both censored and uncensored observations.
</p>


<h3>Value</h3>

<p>This returns the <code>mod$N</code> component of the fitted
model object <code>mod</code>.  See <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>,
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code> for full documentation of all components.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>

<hr>
<h2 id='normboot.flexsurvreg'>Simulate from the asymptotic normal distribution of parameter estimates.</h2><span id='topic+normboot.flexsurvreg'></span>

<h3>Description</h3>

<p>Produce a matrix of alternative parameter estimates under sampling
uncertainty, at covariate values supplied by the user.  Used by
<code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code> for obtaining confidence intervals around
functions of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normboot.flexsurvreg(
  x,
  B,
  newdata = NULL,
  X = NULL,
  transform = FALSE,
  raw = FALSE,
  tidy = FALSE,
  rawsim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normboot.flexsurvreg_+3A_x">x</code></td>
<td>
<p>A fitted model from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> (or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>).</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list containing the covariate values to
evaluate the parameters at.  If there are covariates in the model, at least
one of <code>newdata</code> or <code>X</code> must be supplied, unless <code>raw=TRUE</code>.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_x">X</code></td>
<td>
<p>Alternative (less convenient) format for covariate values: a
matrix with one row, with one column for each covariate or factor contrast.
Formed from all the &quot;model matrices&quot;, one for each named parameter of the
distribution, with intercepts excluded, <code>cbind</code>ed together.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_transform">transform</code></td>
<td>
<p><code>TRUE</code> if the results should be transformed to the
real-line scale, typically by log if the parameter is defined as positive.
The default <code>FALSE</code> returns parameters on the natural scale.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_raw">raw</code></td>
<td>
<p>Return samples of the baseline parameters and the covariate
effects, rather than the default of adjusting the baseline parameters for
covariates.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_tidy">tidy</code></td>
<td>
<p>If <code>FALSE</code> (the default) then
a list is returned.  If <code>TRUE</code> a data frame is returned, consisting
of the list elements <code>rbind</code>ed together, with integer variables
labelling the covariate number and simulation replicate number.</p>
</td></tr>
<tr><td><code id="normboot.flexsurvreg_+3A_rawsim">rawsim</code></td>
<td>
<p>allows input of raw samples from a previous run of
<code>normboot.flexsurvreg</code>. This is useful if running
<code>normboot.flexsurvreg</code> multiple time on the same dataset but with
counterfactual contrasts, e.g. treat =0 vs. treat  =1.
Used in <code>standsurv.flexsurvreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>newdata</code> includes only one covariate combination, a matrix
will be returned with <code>B</code> rows, and one column for each named
parameter of the survival distribution.
</p>
<p>If more than one covariate combination is requested (e.g. <code>newdata</code> is
a data frame with more than one row), then a list of matrices will be
returned, one for each covariate combination.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Mandel, M. (2013). &quot;Simulation based confidence intervals for
functions with complicated derivatives.&quot; The American Statistician (in
press).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    fite &lt;- flexsurvreg(Surv(futime, fustat) ~ age, data = ovarian, dist="exp")
    normboot.flexsurvreg(fite, B=10, newdata=list(age=50))
    normboot.flexsurvreg(fite, B=10, X=matrix(50,nrow=1))
    normboot.flexsurvreg(fite, B=10, newdata=list(age=0))  ## closer to...
    fite$res
</code></pre>

<hr>
<h2 id='p_flexsurvmix'>Transition probabilities from a flexsurvmix model</h2><span id='topic+p_flexsurvmix'></span>

<h3>Description</h3>

<p>These quantities are variously known as transition probabilities, or state
occupancy probabilities, or values of the &quot;cumulative incidence&quot; function,
or values of the &quot;subdistribution&quot; function. They are the probabilities that
an individual has experienced an event of a particular kind by time
<code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_flexsurvmix(x, newdata = NULL, startname = "start", t = 1, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="p_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="p_flexsurvmix_+3A_startname">startname</code></td>
<td>
<p>Name of the state where individuals start. This considers
the model as a multi-state model where people start in this state, and may
transition to one of the competing events.</p>
</td></tr>
<tr><td><code id="p_flexsurvmix_+3A_t">t</code></td>
<td>
<p>Vector of times <code>t</code> to calculate the probabilities of
transition by.</p>
</td></tr>
<tr><td><code id="p_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that &quot;cumulative incidence&quot; is a misnomer, as &quot;incidence&quot; typically
means a hazard, and the quantities computed here are not cumulative hazards,
but probabilities.
</p>


<h3>Value</h3>

<p>A data frame with transition probabilities by time, covariate value
and destination state.
</p>

<hr>
<h2 id='pars.fmsm'>Transition-specific parameters in a flexible parametric multi-state model</h2><span id='topic+pars.fmsm'></span>

<h3>Description</h3>

<p>List of maximum likelihood estimates of transition-specific parameters in
a flexible parametric multi-state model, at given covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pars.fmsm(x, trans, newdata = NULL, tvar = "trans")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pars.fmsm_+3A_x">x</code></td>
<td>
<p>A multi-state model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.
</p>
<p><code>x</code> can also be a list of <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> models, with one
component for each permitted transition in the multi-state model, as
illustrated in <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pars.fmsm_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pars.fmsm_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pars.fmsm_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one component for each permitted transition. Each component
has one element for each parameter of the parametric distribution that generates
the corresponding event in the multi-state model.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>

<hr>
<h2 id='pdf_flexsurvmix'>Fitted densities for times to events in a flexsurvmix model</h2><span id='topic+pdf_flexsurvmix'></span>

<h3>Description</h3>

<p>This returns an estimate of the probability density for the time to each
competing event, at a vector of times supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf_flexsurvmix(x, newdata = NULL, t = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdf_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="pdf_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="pdf_flexsurvmix_+3A_t">t</code></td>
<td>
<p>Vector of times at which to evaluate the probability density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row giving the fitted density <code>dens</code> for
a combination of covariate values, time and competing event.
</p>

<hr>
<h2 id='pfinal_fmsm'>Probabilities of final states in a flexible parametric competing risks model</h2><span id='topic+pfinal_fmsm'></span>

<h3>Description</h3>

<p>This requires the model to be Markov, and is not valid for semi-Markov
models, as it works by wrapping <code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code> to calculate the
transition probability over a very large time.    As it also works on a
<code>fmsm</code> object formed from transition-specific time-to-event models,
it therefore only works on competing risks models, defined by just one starting
state with multiple destination states representing competing events. 
For these models, this function returns the probability governing which
competing event happens next.   However this function simply wraps <code>pmatrix.fs</code>,
so for other models, <code>pmatrix.fs</code> or <code>pmatrix.simfs</code> can be used with a
large forecast time <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfinal_fmsm(x, newdata = NULL, fromstate, maxt = 1e+05, B = 0, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfinal_fmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmsm">fmsm</a></code>, representing a multi-state
model formed from transition-specific time-to-event models fitted by
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pfinal_fmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of covariate values, with one column per
covariate, and one row per alternative value.</p>
</td></tr>
<tr><td><code id="pfinal_fmsm_+3A_fromstate">fromstate</code></td>
<td>
<p>State from which to calculate the transition probability
state.  This should refer to the name of a row of the transition matrix
<code>attr(x,trans)</code>.</p>
</td></tr>
<tr><td><code id="pfinal_fmsm_+3A_maxt">maxt</code></td>
<td>
<p>Large time to use for forecasting final state probabilities.
The transition probability from zero to this time is used.  Note
<code>Inf</code> will not work. The default is <code>100000</code>.</p>
</td></tr>
<tr><td><code id="pfinal_fmsm_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to calculate 95% confidence intervals
based on the asymptotic normal distribution of the basic parameter
estimates. If <code>B=0</code> then no intervals are calculated.</p>
</td></tr>
<tr><td><code id="pfinal_fmsm_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to use.  If <code>NULL</code> (the default)
then a single core is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per covariate value and destination state,
giving the state in column <code>state</code>, and probability in column
<code>val</code>. Additional columns <code>lower</code> and <code>upper</code> for the
confidence limits are returned if <code>B=0</code>.
</p>

<hr>
<h2 id='plot.flexsurvreg'>Plots of fitted flexible survival models</h2><span id='topic+plot.flexsurvreg'></span>

<h3>Description</h3>

<p>Plot fitted survival, cumulative hazard or hazard from a parametric model
against nonparametric estimates to diagnose goodness-of-fit.  Alternatively
plot a user-defined function of the model parameters against time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
plot(
  x,
  newdata = NULL,
  X = NULL,
  type = "survival",
  fn = NULL,
  t = NULL,
  start = 0,
  est = TRUE,
  ci = NULL,
  B = 1000,
  cl = 0.95,
  col.obs = "black",
  lty.obs = 1,
  lwd.obs = 1,
  col = "red",
  lty = 1,
  lwd = 2,
  col.ci = NULL,
  lty.ci = 2,
  lwd.ci = 1,
  ylim = NULL,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flexsurvreg_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing covariate values to produce fitted
values for.  See <code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>.
</p>
<p>If there are only factor covariates in the model, then Kaplan-Meier (or
nonparametric hazard...)  curves are plotted for all distinct groups, and
by default, fitted curves are also plotted for these groups.  To plot
Kaplan-Meier and fitted curves for only a subset of groups, use
<code>plot(survfit())</code> followed by <code>lines.flexsurvreg()</code>.
</p>
<p>If there are any continuous covariates, then a single population
Kaplan-Meier curve is drawn. By default, a single fitted curve is drawn
with the covariates set to their mean values in the data - for categorical
covariates, the means of the 0/1 indicator variables are taken.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_x">X</code></td>
<td>
<p>Alternative way to supply covariate values, as a model matrix.
See <code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>.  <code>newdata</code> is an easier way.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_type">type</code></td>
<td>
<p><code>"survival"</code> for survival, to be plotted against
Kaplan-Meier estimates from <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.
</p>
<p><code>"cumhaz"</code> for cumulative hazard, plotted against transformed
Kaplan-Meier estimates from <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.
</p>
<p><code>"hazard"</code> for hazard, to be plotted against smooth nonparametric
estimates from <code><a href="muhaz.html#topic+muhaz">muhaz</a></code>.  The nonparametric estimates
tend to be unstable, and these plots are intended just to roughly indicate
the shape of the hazards through time.  The <code>min.time</code> and
<code>max.time</code> options to <code><a href="muhaz.html#topic+muhaz">muhaz</a></code> may sometimes need to
be passed as arguments to <code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code> to avoid an error
here.
</p>
<p>Ignored if <code>"fn"</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_fn">fn</code></td>
<td>
<p>Custom function of the parameters to summarise against time.  The
first two arguments of the function must be <code>t</code> representing time, and
<code>start</code> representing left-truncation points, and any remaining
arguments must be parameters of the distribution.  It should return a
vector of the same length as <code>t</code>.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_t">t</code></td>
<td>
<p>Vector of times to plot fitted values for, see
<code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_start">start</code></td>
<td>
<p>Left-truncation points, see <code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_est">est</code></td>
<td>
<p>Plot fitted curves (<code>TRUE</code> or <code>FALSE</code>.)</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_ci">ci</code></td>
<td>
<p>Plot confidence intervals for fitted curves. By default, this is
<code>TRUE</code> if one observed/fitted curve is plotted, and <code>FALSE</code> if
multiple curves are plotted.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of simulations controlling accuracy of confidence
intervals, as used in <code><a href="#topic+summary.flexsurvreg">summary</a></code>.
Decrease for greater speed at the expense of accuracy, or set <code>B=0</code> to
turn off calculation of CIs.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_cl">cl</code></td>
<td>
<p>Width of confidence intervals, by default 0.95 for 95%
intervals.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_col.obs">col.obs</code></td>
<td>
<p>Colour of the nonparametric curve.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lty.obs">lty.obs</code></td>
<td>
<p>Line type of the nonparametric curve.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lwd.obs">lwd.obs</code></td>
<td>
<p>Line width of the nonparametric curve.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_col">col</code></td>
<td>
<p>Colour of the fitted parametric curve(s).</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lty">lty</code></td>
<td>
<p>Line type of the fitted parametric curve(s).</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the fitted parametric curve(s).</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_col.ci">col.ci</code></td>
<td>
<p>Colour of the fitted confidence limits, defaulting to the
same as for the fitted curve.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lty.ci">lty.ci</code></td>
<td>
<p>Line type of the fitted confidence limits.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_lwd.ci">lwd.ci</code></td>
<td>
<p>Line width of the fitted confidence limits.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits: vector of two elements.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add lines to an existing plot, otherwise new
axes are drawn.</p>
</td></tr>
<tr><td><code id="plot.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Other options to be passed to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> or
<code><a href="muhaz.html#topic+muhaz">muhaz</a></code>, for example, to control the smoothness of the
nonparametric hazard estimates.  The <code>min.time</code> and <code>max.time</code>
options to <code><a href="muhaz.html#topic+muhaz">muhaz</a></code> may sometimes need to be changed from
the defaults.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Some standard plot arguments such as <code>"xlim","xlab"</code> may not
work.  This function was designed as a quick check of model fit.  Users
wanting publication-quality graphs are advised to set up an empty plot with
the desired axes first (e.g. with <code>plot(...,type="n",...)</code>), then use
suitable <code><a href="graphics.html#topic+lines">lines</a></code> functions to add lines.
</p>
<p>If case weights were used to fit the model, these are used when producing
nonparametric estimates of survival and cumulative hazard, but not for
the hazard estimates.
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>
</p>

<hr>
<h2 id='plot.standsurv'>Plot standardized metrics from a fitted flexsurv model</h2><span id='topic+plot.standsurv'></span>

<h3>Description</h3>

<p>Plot standardized metrics such as the marginal survival, restricted mean 
survival and hazard, based on a fitted flexsurv model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'standsurv'
plot(x, contrast = FALSE, ci = FALSE, expected = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.standsurv_+3A_x">x</code></td>
<td>
<p>A standsurv object returned by <code>standsurv</code></p>
</td></tr>
<tr><td><code id="plot.standsurv_+3A_contrast">contrast</code></td>
<td>
<p>Should contrasts of standardized metrics be plotted. Defaults
to FALSE</p>
</td></tr>
<tr><td><code id="plot.standsurv_+3A_ci">ci</code></td>
<td>
<p>Should confidence intervals be plotted (if calculated in 
<code>standsurv</code>)?</p>
</td></tr>
<tr><td><code id="plot.standsurv_+3A_expected">expected</code></td>
<td>
<p>Should the marginal expected survival / hazard also be 
plotted? This can only be invoked if <code>rmap</code> and <code>ratetable</code> have 
been passed to <code>standsurv</code></p>
</td></tr>
<tr><td><code id="plot.standsurv_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot showing the standardized metric calculated by 
<code>standsurv</code> over time. Modification of the plot is
possible by adding further ggplot objects, see Examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use bc dataset, with an age variable appended
## mean age is higher in those with smaller observed survival times 
newbc &lt;- bc
newbc$age &lt;- rnorm(dim(bc)[1], mean = 65-scale(newbc$recyrs, scale=FALSE), 
sd = 5)

## Fit a Weibull flexsurv model with group and age as covariates
weib_age &lt;- flexsurvreg(Surv(recyrs, censrec) ~ group+age, data=newbc,
                       dist="weibull")
## Calculate standardized survival and the difference in standardized survival
## for the three levels of group across a grid of survival times
standsurv_weib_age &lt;- standsurv(weib_age,
                                           at = list(list(group="Good"),
                                                     list(group="Medium"),
                                                     list(group="Poor")),
                                           t=seq(0,7, length=100),
                                           contrast = "difference", ci=TRUE,
                                           boot = TRUE, B=10, seed=123)
plot(standsurv_weib_age)
plot(standsurv_weib_age) + ggplot2::theme_bw() + ggplot2::ylab("Survival") +
 ggplot2::xlab("Time (years)") + 
 ggplot2::guides(color=ggplot2::guide_legend(title="Prognosis"),
                               fill=ggplot2::guide_legend(title="Prognosis"))
plot(standsurv_weib_age, contrast=TRUE, ci=TRUE) + 
 ggplot2::ylab("Difference in survival") 
</code></pre>

<hr>
<h2 id='plot.survrtrunc'>Plot nonparametric estimates of survival from right-truncated data.</h2><span id='topic+plot.survrtrunc'></span><span id='topic+lines.survrtrunc'></span>

<h3>Description</h3>

<p><code>plot.survrtrunc</code> creates a new plot, while <code>lines.survrtrunc</code> adds lines to an exising plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survrtrunc'
plot(x, ...)

## S3 method for class 'survrtrunc'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survrtrunc_+3A_x">x</code></td>
<td>
<p>Object of class <code>"survrtrunc"</code> as returned by <code><a href="#topic+survrtrunc">survrtrunc</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survrtrunc_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> or <code><a href="survival.html#topic+lines.survfit">lines.survfit</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pmatrix.fs'>Transition probability matrix from a fully-parametric, time-inhomogeneous
Markov multi-state model</h2><span id='topic+pmatrix.fs'></span>

<h3>Description</h3>

<p>The transition probability matrix for time-inhomogeneous Markov multi-state
models fitted to time-to-event data with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  This
has <code class="reqn">r,s</code> entry giving the probability that an individual is in state
<code class="reqn">s</code> at time <code class="reqn">t</code>, given they are in state <code class="reqn">r</code> at time <code class="reqn">0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatrix.fs(
  x,
  trans = NULL,
  t = 1,
  newdata = NULL,
  condstates = NULL,
  ci = FALSE,
  tvar = "trans",
  sing.inf = 1e+10,
  B = 1000,
  cl = 0.95,
  tidy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmatrix.fs_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.  Additionally, this must be a Markov / clock-forward model, but can
be time-inhomogeneous.  See the package vignette for further explanation.
</p>
<p><code>x</code> can also be a list of models, with one component for each
permitted transition, as illustrated in <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_t">t</code></td>
<td>
<p>Time or vector of times to predict state occupancy probabilities
for.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_condstates">condstates</code></td>
<td>
<p>xInstead of the unconditional probability of being in state <code class="reqn">s</code> at time <code class="reqn">t</code> given state <code class="reqn">r</code> at time 0, return the probability conditional on being in a particular subset of states at time <code class="reqn">t</code>.  This subset is specified in the <code>condstates</code> argument, as a vector of character labels or integers. 
</p>
<p>This is used, for example, in competing risks situations, e.g. if the competing states are death or recovery from a disease, and we want to compute the probability a patient has died, given they have died or recovered.   If these are absorbing states, then as <code class="reqn">t</code> increases, this converges to the case fatality ratio.  To compute this, set <code class="reqn">t</code> to a very large number, <code>Inf</code> will not work.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_ci">ci</code></td>
<td>
<p>Return a confidence interval calculated by simulating from the
asymptotic normal distribution of the maximum likelihood estimates.  Turned
off by default, since this is computationally intensive.  If turned on,
users should increase <code>B</code> until the results reach the desired
precision.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_sing.inf">sing.inf</code></td>
<td>
<p>If there is a singularity in the observed hazard, for
example a Weibull distribution with <code>shape &lt; 1</code> has infinite hazard at
<code>t=0</code>, then as a workaround, the hazard is assumed to be a large
finite number, <code>sing.inf</code>, at this time.  The results should not be
sensitive to the exact value assumed, but users should make sure by
adjusting this parameter in these cases.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution used
to calculate variances.  Decrease for greater speed at the expense of
accuracy.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_tidy">tidy</code></td>
<td>
<p>If TRUE then return the results as a tidy data frame</p>
</td></tr>
<tr><td><code id="pmatrix.fs_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="deSolve.html#topic+ode">ode</a></code> in <span class="pkg">deSolve</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is computed by solving the Kolmogorov forward differential equation
numerically, using the methods in the <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> package.  The
equation is
</p>
<p style="text-align: center;"><code class="reqn">\frac{dP(t)}{dt} = P(t) Q(t)</code>
</p>

<p>where <code class="reqn">P(t)</code> is the transition probability matrix for time <code class="reqn">t</code>, and
<code class="reqn">Q(t)</code> is the transition hazard or intensity as a function of <code class="reqn">t</code>.
The initial condition is <code class="reqn">P(0) = I</code>.
</p>
<p>Note that the package <span class="pkg">msm</span> has a similar method <code>pmatrix.msm</code>.
<code>pmatrix.fs</code> should give the same results as <code>pmatrix.msm</code> when
both of these conditions hold:
</p>
 <ul>
<li><p> the time-to-event distribution is exponential for all
transitions, thus the <code>flexsurvreg</code> model was fitted with
<code>dist="exp"</code> and the model is time-homogeneous.  </p>
</li>
<li><p> the <span class="pkg">msm</span>
model was fitted with <code>exacttimes=TRUE</code>, thus all the event times are
known, and there are no time-dependent covariates.  </p>
</li></ul>

<p><span class="pkg">msm</span> only allows exponential or piecewise-exponential time-to-event
distributions, while <span class="pkg">flexsurvreg</span> allows more flexible models.
<span class="pkg">msm</span> however was designed in particular for panel data, where the
process is observed only at arbitrary times, thus the times of transition
are unknown, which makes flexible models difficult.
</p>
<p>This function is only valid for Markov (&quot;clock-forward&quot;) multi-state
models, though no warning or error is currently given if the model is not
Markov.  See <code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code> for the equivalent for semi-Markov
(&quot;clock-reset&quot;) models.
</p>


<h3>Value</h3>

<p>The transition probability matrix, if <code>t</code> is of length 1.  If <code>t</code> is longer, return a list of matrices, or a data frame if <code>tidy</code> is TRUE. 
</p>
<p>If <code>ci=TRUE</code>, each element has attributes <code>"lower"</code> and
<code>"upper"</code> giving matrices of the corresponding confidence limits.
These are formatted for printing but may be extracted using <code>attr()</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code>, <code><a href="#topic+totlos.fs">totlos.fs</a></code>,
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# BOS example in vignette, and in msfit.flexsurvreg
bexp &lt;- flexsurvreg(Surv(Tstart, Tstop, status) ~ trans,
                    data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))
# more likely to be dead (state 3) as time moves on, or if start with
# BOS (state 2)
pmatrix.fs(bexp, t=c(5,10), trans=tmat)
</code></pre>

<hr>
<h2 id='pmatrix.simfs'>Transition probability matrix from a fully-parametric, semi-Markov
multi-state model</h2><span id='topic+pmatrix.simfs'></span>

<h3>Description</h3>

<p>The transition probability matrix for semi-Markov multi-state models fitted
to time-to-event data with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  This has <code class="reqn">r,s</code>
entry giving the probability that an individual is in state <code class="reqn">s</code> at time
<code class="reqn">t</code>, given they are in state <code class="reqn">r</code> at time <code class="reqn">0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmatrix.simfs(
  x,
  trans,
  t = 1,
  newdata = NULL,
  ci = FALSE,
  tvar = "trans",
  tcovs = NULL,
  M = 1e+05,
  B = 1000,
  cl = 0.95,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmatrix.simfs_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.  Additionally this should be semi-Markov, so that the time variable
represents the time since the last transition.  In other words the response
should be of the form <code>Surv(time,status)</code>. See the package vignette
for further explanation.
</p>
<p><code>x</code> can also be a list of models, with one component for each
permitted transition, as illustrated in <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_t">t</code></td>
<td>
<p>Time to predict state occupancy probabilities for.  This must be a
single number, unlike <code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_ci">ci</code></td>
<td>
<p>Return a confidence interval calculated by simulating from the
asymptotic normal distribution of the maximum likelihood estimates.  This
is turned off by default, since two levels of simulation are required.  If
turned on, users should adjust <code>B</code> and/or <code>M</code> until the results
reach the desired precision.  The simulation over <code>M</code> is generally
vectorised, therefore increasing <code>B</code> is usually more expensive than
increasing <code>M</code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_tcovs">tcovs</code></td>
<td>
<p>Predictable time-dependent covariates such as age, see
<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_m">M</code></td>
<td>
<p>Number of individuals to simulate in order to approximate the
transition probabilities.  Users should adjust this to obtain the required
precision.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution used
to calculate confidence limits.  Decrease for greater speed at the expense of
accuracy.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="pmatrix.simfs_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores used when calculating confidence limits bu repeated simulation.  The default uses single-core processing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is computed by simulating a large number of individuals <code>M</code> using
the maximum likelihood estimates of the fitted model and the function
<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.  Therefore this requires a random sampling function
for the parametric survival model to be available: see the &quot;Details&quot;
section of <code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.  This will be available for all built-in
distributions, though users may need to write this for custom models.
</p>
<p>Note the random sampling method for <code>flexsurvspline</code> models is
currently very inefficient, so that looping over the <code>M</code> individuals
will be very slow.
</p>
<p><code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code> is a more efficient method based on solving the
Kolmogorov forward equation numerically, which requires the multi-state
model to be Markov.  No error or warning is given if running
<code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code> with a Markov model, but this is still invalid.
</p>


<h3>Value</h3>

<p>The transition probability matrix.  If <code>ci=TRUE</code>, there are
attributes <code>"lower"</code> and <code>"upper"</code> giving matrices of the
corresponding confidence limits.  These are formatted for printing but may
be extracted using <code>attr()</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code>,<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>,<code><a href="#topic+totlos.simfs">totlos.simfs</a></code>,
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# BOS example in vignette, and in msfit.flexsurvreg

bexp &lt;- flexsurvreg(Surv(years, status) ~ trans, data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))

# more likely to be dead (state 3) as time moves on, or if start with
# BOS (state 2)

pmatrix.simfs(bexp, t=5, trans=tmat)
pmatrix.simfs(bexp, t=10, trans=tmat)

# these results should converge to those in help(pmatrix.fs), as M
# increases here and ODE solving precision increases there, since with
# an exponential distribution, the semi-Markov model is the same as the
# Markov model.
</code></pre>

<hr>
<h2 id='ppath_fmixmsm'>Probability of each pathway taken through a mixture multi-state model</h2><span id='topic+ppath_fmixmsm'></span>

<h3>Description</h3>

<p>Probability of each pathway taken through a mixture multi-state model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppath_fmixmsm(x, newdata = NULL, final = FALSE, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppath_fmixmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmixmsm">fmixmsm</a></code>, representing a multi-state
model built from piecing together mixture models fitted by
<code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="ppath_fmixmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="ppath_fmixmsm_+3A_final">final</code></td>
<td>
<p>If <code>TRUE</code> then the probabilities of pathways with the same
final state are added together, to produce the probability  of each
ultimate outcome or absorbing state from the multi-state model.</p>
</td></tr>
<tr><td><code id="ppath_fmixmsm_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of pathway probabilities by covariate value and pathway.
</p>

<hr>
<h2 id='predict.flexsurvreg'>Predictions from flexible survival models</h2><span id='topic+predict.flexsurvreg'></span>

<h3>Description</h3>

<p>Predict outcomes from flexible survival models at the covariate values
specified in <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
predict(
  object,
  newdata,
  type = "response",
  times,
  start = 0,
  conf.int = FALSE,
  conf.level = 0.95,
  se.fit = FALSE,
  p = c(0.1, 0.9),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing covariate values at which to produce
fitted values. There must be a column for every covariate in the model
formula used to fit <code>object</code>, and one row for every combination of
covariate values at which to obtain the fitted predictions.
</p>
<p>If <code>newdata</code> is omitted, then the original data used to fit the model
are used, as extracted by <code>model.frame(object)</code>. However this will
currently not work if the model formula contains functions, e.g.
<code>~ factor(x)</code>. The names of the model frame must correspond to
variables in the original data.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_type">type</code></td>
<td>
<p>Character vector for the type of predictions desired.
</p>

<ul>
<li> <p><code>"response"</code> for mean survival time (the default). <code>"mean"</code> is
an acceptable synonym
</p>
</li>
<li> <p><code>"quantile"</code> for quantiles of the survival distribution as specified
by <code>p</code>
</p>
</li>
<li> <p><code>"rmst"</code> for restricted mean survival time
</p>
</li>
<li> <p><code>"survival"</code> for survival probabilities
</p>
</li>
<li> <p><code>"cumhaz"</code> for cumulative hazards
</p>
</li>
<li> <p><code>"hazard"</code> for hazards
</p>
</li>
<li> <p><code>"link"</code> for fitted values of the location parameter, analogous to
the linear predictor in generalized linear models (<code>type = "lp"</code> and
<code>type = "linear"</code> are acceptable synonyms). This is on the natural
scale of the parameter, not the log scale.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_times">times</code></td>
<td>
<p>Vector of time horizons at which to compute fitted values.
Only applies when <code>type</code> is <code>"survival"</code>, <code>"cumhaz"</code>,
<code>"hazard"</code>, or <code>"rmst"</code>. Will be silently ignored for all other
types.
</p>
<p>If not specified, predictions for <code>"survival"</code>, <code>"cumhaz"</code>, and
<code>"hazard"</code> will be made at each observed event time in
<code>model.frame(object)</code>.
</p>
<p>For <code>"rmst"</code>, when <code>times</code> is not specified predictions will be
made at the maximum observed event time from the data used to fit
<code>object</code>. Specifying <code>times = Inf</code> is valid, and will return
mean survival (equal to <code>type = "response"</code>).</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times. The returned
survival, hazard, or cumulative hazard will be conditioned on survival up
to this time. <code>start</code> must be length 1 or the same length as <code>times</code>.
Predicted times returned with <code>type</code> <code>"rmst"</code> or <code>"quantile"</code>
will be times since time zero, not times since the <code>start</code> time.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Should confidence intervals be returned?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_conf.level">conf.level</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical. Should standard errors of fitted values be returned?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_p">p</code></td>
<td>
<p>Vector of quantiles at which to return fitted values when
<code>type = "quantile"</code>. Default is <code>c(0.1, 0.9)</code>.</p>
</td></tr>
<tr><td><code id="predict.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with same number of rows as <code>newdata</code>
and in the same order. If multiple predictions are requested, a
<code><a href="tibble.html#topic+tibble">tibble</a></code> containing a single list-column of data frames.
</p>
<p>For the list-column of data frames - the dimensions of each data frame
will be identical. Rows are added for each value of <code>times</code> or
<code>p</code> requested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.flexsurvreg">summary.flexsurvreg</a></code>,
<code><a href="#topic+residuals.flexsurvreg">residuals.flexsurvreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")

## Simplest prediction: mean or median, for covariates defined by original dataset
predict(fitg)
predict(fitg, type = "quantile", p = 0.5)

## Simple prediction for user-defined covariate values
predict(fitg, newdata = data.frame(age = c(40, 50, 60)))
predict(fitg, type = "quantile", p = 0.5, newdata = data.frame(age = c(40,50,60)))

## Predict multiple quantiles and unnest
require(tidyr)
pr &lt;- predict(fitg, type = "survival", times = c(600, 800))
tidyr::unnest(pr, .pred)

</code></pre>

<hr>
<h2 id='probs_flexsurvmix'>Probabilities of competing events from a flexsurvmix model</h2><span id='topic+probs_flexsurvmix'></span>

<h3>Description</h3>

<p>Probabilities of competing events from a flexsurvmix model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_flexsurvmix(x, newdata = NULL, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="probs_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="probs_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the probability that each of the competing
events will occur next, by event and by any covariate values specified in
<code>newdata</code>.
</p>

<hr>
<h2 id='qfinal_fmixmsm'>Quantiles of the distribution of the time until reaching a final state in a
mixture multi-state model</h2><span id='topic+qfinal_fmixmsm'></span>

<h3>Description</h3>

<p>Calculate the quantiles of the time from the start of the process to each
possible final (or &quot;absorbing&quot;) state in a mixture multi-state model.
Models with cycles are not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfinal_fmixmsm(
  x,
  newdata = NULL,
  final = FALSE,
  B = NULL,
  n = 10000,
  probs = c(0.025, 0.5, 0.975)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfinal_fmixmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmixmsm">fmixmsm</a></code>, representing a multi-state
model built from piecing together mixture models fitted by
<code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="qfinal_fmixmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="qfinal_fmixmsm_+3A_final">final</code></td>
<td>
<p>If <code>TRUE</code> then the mean time to the final state is
calculated for each final state, by taking a weighted average of the mean
time to travel each pathway ending in that final state, weighted by the
probability of the pathway.   If <code>FALSE</code>  (the default) then a
separate mean is calculated for each pathway.</p>
</td></tr>
<tr><td><code id="qfinal_fmixmsm_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
<tr><td><code id="qfinal_fmixmsm_+3A_n">n</code></td>
<td>
<p>Number of individual-level simulations to use to characterise the
time-to-event distributions</p>
</td></tr>
<tr><td><code id="qfinal_fmixmsm_+3A_probs">probs</code></td>
<td>
<p>Quantiles to calculate, by default, <code>c(0.025, 0.5, 0.975)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of quantiles of the time to final state by pathway and
covariate value, or by final state and covariate value.
</p>

<hr>
<h2 id='qgeneric'>Generic function to find quantiles of a distribution</h2><span id='topic+qgeneric'></span>

<h3>Description</h3>

<p>Generic function to find the quantiles of a distribution, given the
equivalent probability distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgeneric(pdist, p, matargs = NULL, scalarargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgeneric_+3A_pdist">pdist</code></td>
<td>
<p>Probability distribution function, for example,
<code><a href="stats.html#topic+pnorm">pnorm</a></code> for the normal distribution, which must be defined in
the current workspace.  This should accept and return vectorised parameters
and values.  It should also return the correct values for the entire real
line, for example a positive distribution should have <code>pdist(x)==0</code>
for <code class="reqn">x&lt;0</code>.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_p">p</code></td>
<td>
<p>Vector of probabilities to find the quantiles for.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_matargs">matargs</code></td>
<td>
<p>Character vector giving the elements of <code>...</code> which
represent vector parameters of the distribution.  Empty by default.  When
vectorised, these will become matrices.  This is used for the arguments
<code>gamma</code> and <code>knots</code> in <code><a href="#topic+qsurvspline">qsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_scalarargs">scalarargs</code></td>
<td>
<p>Character vector naming scalar arguments of the distribution function that cannot be vectorised.  This is used for the arguments <code>scale</code> and <code>timescale</code> in <code><a href="#topic+qsurvspline">qsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="qgeneric_+3A_...">...</code></td>
<td>
<p>The remaining arguments define parameters of the distribution
<code>pdist</code>.  These MUST be named explicitly.
</p>
<p>This may also contain the standard arguments <code>log.p</code> (logical; default
<code>FALSE</code>, if <code>TRUE</code>, probabilities p are given as log(p)), and
<code>lower.tail</code> (logical; if <code>TRUE</code> (default), probabilities are P[X
&lt;= x] otherwise, P[X &gt; x].).
</p>
<p>If the distribution is bounded above or below, then this should contain
arguments <code>lbound</code> and <code>ubound</code> respectively, and these will be
returned if <code>p</code> is 0 or 1 respectively.  Defaults to <code>-Inf</code> and
<code>Inf</code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by default for custom distributions for which a
quantile function is not provided.
</p>
<p>It works by finding the root of the equation <code class="reqn">h(q) = pdist(q) - p = 0</code>.
Starting from the interval <code class="reqn">(-1, 1)</code>, the interval width is expanded by
50% until <code class="reqn">h()</code> is of opposite sign at either end.  The root is then
found using <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>
<p>This assumes a suitably smooth, continuous distribution.
</p>


<h3>Value</h3>

<p>Vector of quantiles of the distribution at <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qnorm(c(0.025, 0.975), 0, 1)
qgeneric(pnorm, c(0.025, 0.975), mean=0, sd=1) # must name the arguments
</code></pre>

<hr>
<h2 id='quantile_flexsurvmix'>Quantiles of time-to-event distributions in a flexsurvmix model</h2><span id='topic+quantile_flexsurvmix'></span>

<h3>Description</h3>

<p>This returns the quantiles of each event-specific parametric time-to-event
distribution in the mixture model, which describes the time to the event
conditionally on that event being the one that happens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_flexsurvmix(x, newdata = NULL, B = NULL, probs = c(0.025, 0.5, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="quantile_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="quantile_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
<tr><td><code id="quantile_flexsurvmix_+3A_probs">probs</code></td>
<td>
<p>Vector of alternative quantiles, by default <code>c(0.025, 0.95, 0.975)</code>
giving the median and a 95% interval.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.flexsurvreg'>Calculate residuals for flexible survival models</h2><span id='topic+residuals.flexsurvreg'></span>

<h3>Description</h3>

<p>Calculates residuals for <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
residuals(object, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="residuals.flexsurvreg_+3A_type">type</code></td>
<td>
<p>Character string for the type of residual desired. Currently only <code>"response"</code> and <code>"coxsnell"</code> are supported. More residual types may become available in future versions.</p>
</td></tr>
<tr><td><code id="residuals.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals of <code>type = "response"</code> are calculated as the naive difference between the observed survival and the covariate-specific predicted mean survival from <code><a href="#topic+predict.flexsurvreg">predict.flexsurvreg</a></code>, ignoring whether the event time is observed or censored.
</p>
<p><code>type="coxsnell"</code> returns the Cox-Snell residual, defined as the estimated cumulative hazard at each data point.  To check the fit of the
A more fully featured utility for this is provided in the function <code><a href="#topic+coxsnell_flexsurvreg">coxsnell_flexsurvreg</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector with the same length as <code>nobs(object)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.flexsurvreg">predict.flexsurvreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")
residuals(fitg, type="response")



</code></pre>

<hr>
<h2 id='rmst_flexsurvmix'>Restricted mean times to events from a flexsurvmix model</h2><span id='topic+rmst_flexsurvmix'></span>

<h3>Description</h3>

<p>This returns the restricted mean of each event-specific parametric time-to-event
distribution in the mixture model, which is the mean time to event
conditionally on that event being the one that happens, and conditionally
on the event time being less than some time horizon <code>tot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmst_flexsurvmix(x, newdata = NULL, tot = Inf, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmst_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="rmst_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="rmst_flexsurvmix_+3A_tot">tot</code></td>
<td>
<p>Time horizon to compute the restricted mean until.</p>
</td></tr>
<tr><td><code id="rmst_flexsurvmix_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to compute 95% confidence intervals,
based on the asymptotic multivariate normal distribution of the basic
parameter estimates.  If <code>B=NULL</code> then intervals are not computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Restricted mean times to next event conditionally on each alternative event,
given the specified covariate values.
</p>

<hr>
<h2 id='rmst_generic'>Generic function to find restricted mean survival of a distribution</h2><span id='topic+rmst_generic'></span>

<h3>Description</h3>

<p>Generic function to find the restricted mean of a distribution, given the
equivalent probability distribution function using numeric integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmst_generic(pdist, t, start = 0, matargs = NULL, scalarargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmst_generic_+3A_pdist">pdist</code></td>
<td>
<p>Probability distribution function, for example,
<code><a href="stats.html#topic+pnorm">pnorm</a></code> for the normal distribution, which must be defined in
the current workspace.  This should accept and return vectorised parameters
and values.  It should also return the correct values for the entire real
line, for example a positive distribution should have <code>pdist(x)==0</code>
for <code class="reqn">x&lt;0</code>.</p>
</td></tr>
<tr><td><code id="rmst_generic_+3A_t">t</code></td>
<td>
<p>Vector of times at which rmst is evaluated</p>
</td></tr>
<tr><td><code id="rmst_generic_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
restricted mean survival will be conditioned on survival up to
this time.</p>
</td></tr>
<tr><td><code id="rmst_generic_+3A_matargs">matargs</code></td>
<td>
<p>Character vector giving the elements of <code>...</code> which
represent vector parameters of the distribution.  Empty by default.  When
vectorised, these will become matrices.  This is used for the arguments
<code>gamma</code> and <code>knots</code> in <code><a href="#topic+psurvspline">psurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="rmst_generic_+3A_scalarargs">scalarargs</code></td>
<td>
<p>Character vector naming scalar arguments of the distribution function that cannot be vectorised.  This is used for the arguments <code>scale</code> and <code>timescale</code> in <code><a href="#topic+psurvspline">psurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="rmst_generic_+3A_...">...</code></td>
<td>
<p>The remaining arguments define parameters of the distribution
<code>pdist</code>.  These MUST be named explicitly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by default for custom distributions for which an
rmst function is not provided.
</p>
<p>This assumes a suitably smooth, continuous distribution.
</p>


<h3>Value</h3>

<p>Vector of restricted mean survival times of the distribution at
<code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmst_lnorm(500, start=250, meanlog=7.4225, sdlog = 1.1138)
rmst_generic(plnorm, 500, start=250, meanlog=7.4225, sdlog = 1.1138)
# must name the arguments

</code></pre>

<hr>
<h2 id='sim.fmsm'>Simulate paths through a fully parametric semi-Markov multi-state model</h2><span id='topic+sim.fmsm'></span>

<h3>Description</h3>

<p>Simulate changes of state and transition times from a semi-Markov
multi-state model fitted using <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fmsm(
  x,
  trans = NULL,
  t,
  newdata = NULL,
  start = 1,
  M = 10,
  tvar = "trans",
  tcovs = NULL,
  tidy = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.fmsm_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>. See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.
</p>
<p>Alternatively <code>x</code> can be a list of fitted <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>
model objects.  The <code>i</code>th element of this list is the model
corresponding to the <code>i</code>th transition in <code>trans</code>.  This is a more
efficient way to fit a multi-state model, but only valid if the parameters
are different between different transitions.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_t">t</code></td>
<td>
<p>Time, or vector of times for each of the <code>M</code> individuals, to
simulate trajectories until.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_start">start</code></td>
<td>
<p>Starting state, or vector of starting states for each of the
<code>M</code> individuals.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_m">M</code></td>
<td>
<p>Number of individual trajectories to simulate.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_tcovs">tcovs</code></td>
<td>
<p>Names of &quot;predictable&quot; time-dependent covariates in
<code>newdata</code>, i.e. those whose values change at the same rate as time.
Age is a typical example.  During simulation, their values will be updated
after each transition time, by adding the current time to the value
supplied in <code>newdata</code>.  This assumes the covariate is measured in the
same unit as time. <code>tcovs</code> is supplied as a character vector.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_tidy">tidy</code></td>
<td>
<p>If <code>TRUE</code> then the simulated data are returned as a tidy data frame with one row per simulated transition.  See <code><a href="#topic+simfs_bytrans">simfs_bytrans</a></code> for a function to rearrange the data into this format if it was simulated in non-tidy format.</p>
</td></tr>
<tr><td><code id="sim.fmsm_+3A_debug">debug</code></td>
<td>
<p>Print intermediate outputs: for development use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim.fmsm</code> relies on the presence of a function to sample random
numbers from the parametric survival distribution used in the fitted model
<code>x</code>, for example <code><a href="stats.html#topic+rweibull">rweibull</a></code> for Weibull models. If
<code>x</code> was fitted using a custom distribution, called <code>dist</code> say,
then there must be a function called (something like) <code>rdist</code> either
in the working environment, or supplied through the <code>dfns</code> argument to
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  This must be in the same format as standard R
functions such as <code><a href="stats.html#topic+rweibull">rweibull</a></code>, with first argument <code>n</code>, and
remaining arguments giving the parameters of the distribution.  It must be
vectorised with respect to the parameter arguments.
</p>
<p>This function is only valid for semi-Markov (&quot;clock-reset&quot;) models, though
no warning or error is currently given if the model is not of this type. An
equivalent for time-inhomogeneous Markov (&quot;clock-forward&quot;) models has
currently not been implemented.
</p>


<h3>Value</h3>

<p>If <code>tidy=TRUE</code>, a data frame with one row for each simulated transition, giving the individual ID <code>id</code>, start state <code>start</code>, end state <code>end</code>, transition label <code>trans</code>, time of the transition since the start of the process (<code>time</code>), and time since the previous transition (<code>delay</code>).
</p>
<p>If <code>tidy=FALSE</code>, a list of two matrices named <code>st</code> and <code>t</code>.  The rows of
each matrix represent simulated individuals.  The columns of <code>t</code>
contain the times when the individual changes state, to the corresponding
states in <code>st</code>.
</p>
<p>The first columns will always contain the starting states and the starting
times. The last column of <code>t</code> represents either the time when the
individual moves to an absorbing state, or right-censoring in a transient
state at the time given in the <code>t</code> argument to <code>sim.fmsm</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code>,<code><a href="#topic+totlos.simfs">totlos.simfs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bexp &lt;- flexsurvreg(Surv(years, status) ~ trans, data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))
sim.fmsm(bexp, M=10, t=5, trans=tmat)
</code></pre>

<hr>
<h2 id='simfinal_fmsm'>Simulate and summarise final outcomes from a flexible parametric multi-state
model</h2><span id='topic+simfinal_fmsm'></span>

<h3>Description</h3>

<p>Estimates the probability of each final outcome (&quot;absorbing&quot; state), and the
mean and quantiles of the time to that outcome for people who experience it,
by simulating a large sample of individuals from the model.  This can be used
for both Markov and semi-Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simfinal_fmsm(
  x,
  newdata = NULL,
  probs = c(0.025, 0.5, 0.975),
  t = 1000,
  M = 1e+05,
  B = 0,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simfinal_fmsm_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+fmsm">fmsm</a></code>, representing a multi-state
model formed from transition-specific time-to-event models fitted by
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of covariate values, with one column per
covariate, and one row per alternative value.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_probs">probs</code></td>
<td>
<p>Quantiles to calculate, by default, <code>c(0.025, 0.5, 0.975)</code>
for a median and 95% interval.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_t">t</code></td>
<td>
<p>Maximum time to simulate to, passed to <code><a href="#topic+sim.fmsm">sim.fmsm</a></code>, so
that the summaries are taken from the subset of individuals in the
simulated data who are in the absorbing state at this time.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_m">M</code></td>
<td>
<p>Number of individuals to simulate.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_b">B</code></td>
<td>
<p>Number of simulations to use to calculate 95% confidence intervals
based on the asymptotic normal distribution of the basic parameter
estimates. If <code>B=0</code> then no intervals are calculated.</p>
</td></tr>
<tr><td><code id="simfinal_fmsm_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to use.  If <code>NULL</code> (the default)
then a single core is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a competing risks model, i.e. a model defined by just one starting state
and multiple destination states representing competing events, this returns
the probability governing the next event that happens, and the distribution 
of the time to each event conditionally on that event happening.
</p>


<h3>Value</h3>

<p>A tidy data frame with rows for each combination of covariate values
and quantity of interest.  The quantity of interest is identified in the
column <code>quantity</code>, and the value of the quantity is in <code>val</code>,
with additional columns <code>lower</code> and <code>upper</code> giving 95%
confidence intervals for the quantity, if <code>B&gt;0</code>.
</p>

<hr>
<h2 id='simfs_bytrans'>Reformat simulated multi-state data with one row per simulated transition</h2><span id='topic+simfs_bytrans'></span>

<h3>Description</h3>

<p>Reformat simulated multi-state data with one row per simulated transition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simfs_bytrans(simfs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simfs_bytrans_+3A_simfs">simfs</code></td>
<td>
<p>Output from <code><a href="#topic+sim.fmsm">sim.fmsm</a></code> representing simulated histories from a multi-state model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with four columns giving transition start state, transition end state, transition name and the time taken by the transition.
</p>

<hr>
<h2 id='simt_flexsurvmix'>Simulate times to competing events from a mixture multi-state model</h2><span id='topic+simt_flexsurvmix'></span>

<h3>Description</h3>

<p>Simulate times to competing events from a mixture multi-state model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simt_flexsurvmix(x, newdata = NULL, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simt_flexsurvmix_+3A_x">x</code></td>
<td>
<p>Fitted model object returned from <code><a href="#topic+flexsurvmix">flexsurvmix</a></code>.</p>
</td></tr>
<tr><td><code id="simt_flexsurvmix_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list of covariate values.   If omitted for a
model with covariates, a default is used, defined by all combinations of
factors if the only covariates in the model are factors, or all covariate
values of zero if there are any non-factor covariates in the model.</p>
</td></tr>
<tr><td><code id="simt_flexsurvmix_+3A_n">n</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with <code>n*m</code> rows and a column for each competing
event, where <code>m</code> is the number of alternative covariate values, that
is the number of rows of <code>newdata</code>.   The simulated time represents
the time to that event conditionally on that event being the one that
occurs.  This function doesn't simulate which event occurs.
</p>

<hr>
<h2 id='simulate.flexsurvreg'>Simulate censored time-to-event data from a fitted flexsurvreg model</h2><span id='topic+simulate.flexsurvreg'></span>

<h3>Description</h3>

<p>Simulate censored time-to-event data from a fitted flexsurvreg model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  newdata = NULL,
  start = NULL,
  censtime = NULL,
  tidy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Object returned by <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations per row in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_seed">seed</code></td>
<td>
<p>Random number seed. This is returned with the result of this
function, as described in <code><a href="stats.html#topic+simulate">simulate</a></code> for the <code>lm</code> method.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame defining alternative sets of covariate values to simulate with.
If omitted, this defaults to the data originally used to fit the model.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
survival, hazard or cumulative hazard will be conditioned on survival up to
this time.   Predicted times returned with <code>"rmst"</code>, <code>"mean"</code>, <code>"median"</code> or <code>"quantile"</code>
will be times since time zero, not times since the <code>start</code> time.
</p>
<p>A vector of the same length as <code>t</code> can be supplied to allow different
truncation times for each prediction time, though this doesn't make sense
in the usual case where this function is used to calculate a predicted
trajectory for a single individual.  This is why the default <code>start</code>
time was changed for version 0.4 of <span class="pkg">flexsurv</span> - this was previously a
vector of the start times observed in the data.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_censtime">censtime</code></td>
<td>
<p>A right-censoring time, or vector of times matching the rows
of <code>newdata</code>.  If <code>NULL</code> (the default) then uncensored times to events
are simulated.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_tidy">tidy</code></td>
<td>
<p>If <code>TRUE</code> then a &quot;tidy&quot; or &quot;long&quot;-format data frame is
returned, with rows defined by combinations of covariates and simulation
replicates.  The simulation replicate is indicated in the column named <code>i</code>.
</p>
<p>If <code>FALSE</code>, then a data frame is returned with one row per set of
covariate values, and different columns for different simulation
replicates.  This is the traditional format for 'simulate' methods in base
R.
</p>
<p>In either case, the simulated time and indicator for whether the time is
an event time (rather than a time of right-censoring) are returned in
different columns.</p>
</td></tr>
<tr><td><code id="simulate.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, with format determined by whether <code>tidy</code> was specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ rx, data = ovarian, dist="weibull")
fit2 &lt;- flexsurvspline(formula = Surv(futime, fustat) ~ rx, data = ovarian, k=3)
nd = data.frame(rx=1:2)
simulate(fit, seed=1002, newdata=nd)
simulate(fit, seed=1002, newdata=nd, start=500)
simulate(fit2, nsim=3, seed=1002, newdata=nd)
simulate(fit2, nsim=3, seed=1002, newdata=nd, start=c(500,1000))

</code></pre>

<hr>
<h2 id='standsurv'>Marginal survival and hazards of fitted flexsurvreg models</h2><span id='topic+standsurv'></span>

<h3>Description</h3>

<p>Returns a tidy data.frame of marginal survival probabilities or the hazards 
of the marginal survival at user-defined time points and covariate patterns.
Standardization is performed over any undefined covariates in the model. 
The user provides the data to standardize over. Contrasts can be calculated 
resulting in estimates of the average treatment effect or the average 
treatment effect in the treated if a treated subset of the data are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standsurv(
  object,
  newdata = NULL,
  at = list(list()),
  atreference = 1,
  type = "survival",
  t = NULL,
  ci = FALSE,
  se = FALSE,
  boot = FALSE,
  B = NULL,
  cl = 0.95,
  trans = "log",
  contrast = NULL,
  trans.contrast = NULL,
  seed = NULL,
  rmap,
  ratetable,
  scale.ratetable = 365.25,
  n.gauss.quad = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standsurv_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing covariate values to produce marginal
values for. If not specified then the fitted model data.frame is used.
There must be a column for every covariate in the model formula
for which the user wishes to standardize over.  These are in the same format
as the original data, with factors as a single variable, not 0/1 contrasts.
Any covariates that are to be fixed should be specified in <code>at</code>. 
There should be one row for every combination of covariates in which to 
standardize over. If newdata contains a variable named '(weights)' then a 
weighted mean will be used to create the standardized estimates. This is the
default behaviour if the fitted model contains case weights, which are stored 
in the fitted model data.frame.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_at">at</code></td>
<td>
<p>A list of scenarios in which specific covariates are fixed to 
certain values. Each element of <code>at</code> must itself be a list. For example,
for a covariate <code>group</code> with levels &quot;Good&quot;, &quot;Medium&quot; and &quot;Poor&quot;, the 
standardized survival plots for each group averaging over all other 
covariates is specified using 
<code>at=list(list(group="Good"), list(group="Medium"), list(group="Poor"))</code>.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_atreference">atreference</code></td>
<td>
<p>The reference scenario for making contrasts. Default is 1
(i.e. the first element of <code>at</code>).</p>
</td></tr>
<tr><td><code id="standsurv_+3A_type">type</code></td>
<td>
<p><code>"survival"</code> for marginal survival probabilities. In a 
relative survival framework this returns the marginal all-cause survival 
(see details).
</p>
<p><code>"hazard"</code> for the hazard of the marginal survival probability. In a 
relative survival framework this returns the marginal all-cause hazard 
(see details).
</p>
<p><code>"rmst"</code> for standardized restricted mean survival.
</p>
<p><code>"relsurvival"</code> for marginal relative survival (can only be specified
if a relative survival model has been fitted in flexsurv).
</p>
<p><code>"excesshazard"</code> for marginal excess hazards (can only be specified
if a relative survival model has been fitted in flexsurv).</p>
</td></tr>
<tr><td><code id="standsurv_+3A_t">t</code></td>
<td>
<p>Times to calculate marginal values at.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_ci">ci</code></td>
<td>
<p>Should confidence intervals be calculated? 
Defaults to FALSE</p>
</td></tr>
<tr><td><code id="standsurv_+3A_se">se</code></td>
<td>
<p>Should standard errors be calculated? 
Defaults to FALSE</p>
</td></tr>
<tr><td><code id="standsurv_+3A_boot">boot</code></td>
<td>
<p>Should bootstrapping be used to calculate standard error and 
confidence intervals? Defaults to FALSE, in which case the delta method is 
used</p>
</td></tr>
<tr><td><code id="standsurv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap simulations from the normal asymptotic 
distribution of the estimates used to calculate confidence intervals or 
standard errors. Decrease for greater speed at the expense of accuracy. Only 
specify if <code>boot = TRUE</code></p>
</td></tr>
<tr><td><code id="standsurv_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_trans">trans</code></td>
<td>
<p>Transformation to apply when calculating standard errors via the
delta method to obtain confidence intervals. The default transformation is 
&quot;log&quot;. Other possible names are &quot;none&quot;, &quot;loglog&quot;, &quot;logit&quot;.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_contrast">contrast</code></td>
<td>
<p>Contrasts between standardized measures defined by <code>at</code>
scenarios. Options are <code>"difference"</code> and <code>"ratio"</code>. There will be
n-1 new columns created where n is the number of <code>at</code> scenarios. Default
is NULL (i.e. no contrasts are calculated).</p>
</td></tr>
<tr><td><code id="standsurv_+3A_trans.contrast">trans.contrast</code></td>
<td>
<p>Transformation to apply when calculating standard errors
for contrasts via the delta method to obtain confidence intervals. The default
transformation is &quot;none&quot; for differences in survival, hazard or RMST, 
and &quot;log&quot; for ratios of survival, hazard or RMST.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_seed">seed</code></td>
<td>
<p>The random seed to use (for bootstrapping confidence intervals)</p>
</td></tr>
<tr><td><code id="standsurv_+3A_rmap">rmap</code></td>
<td>
<p>An list that maps data set names to expected ratetable names. 
This must be specified if all-cause survival and hazards are required after
fitting a relative survival model. This can also be specified if expected
rates are required for plotting purposes. See the details section below.</p>
</td></tr>
<tr><td><code id="standsurv_+3A_ratetable">ratetable</code></td>
<td>
<p>A table of expected event rates 
(see <code><a href="survival.html#topic+ratetable">ratetable</a></code>)</p>
</td></tr>
<tr><td><code id="standsurv_+3A_scale.ratetable">scale.ratetable</code></td>
<td>
<p>Transformation from the time scale of the fitted 
flexsurv model to the time scale in <code>ratetable</code>. For example, if the 
analysis time of the fitted model is in years and the ratetable is in 
units/day then we should use <code>scale.ratetable = 365.25</code>. This is the 
default as often the ratetable will be in units/day (see example).</p>
</td></tr>
<tr><td><code id="standsurv_+3A_n.gauss.quad">n.gauss.quad</code></td>
<td>
<p>Number of Gaussian quadrature points used for integrating 
the all-cause survival function when calculating RMST in a relative survival 
framework (default = 100)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The syntax of <code>standsurv</code> follows closely that of Stata's 
<code>standsurv</code> command written by Paul Lambert and Michael Crowther. The 
function calculates standardized (marginal) measures including standardized
survival functions, standardized restricted mean survival times and the 
hazard of standardized survival. The standardized survival is defined as
</p>
<p style="text-align: center;"><code class="reqn">S_s(t|X=x) = E(S(t|X=x,Z)) = \frac{1}{N} \sum_{i=1}^N S(t|X=x,Z=z_i)</code>
</p>

<p>The hazard of the standardized survival is a weighted average of 
individual hazard functions at time t, weighted by the survival
function at this time:
</p>
<p style="text-align: center;"><code class="reqn">h_s(t|X=x) = \frac{\sum_{i=1}^N S(t|X=x,Z=z_i)h(t|X=x,Z=z_i)}{\sum_{i=1}^N S(t|X=x,Z=z_i)}</code>
</p>

<p>Marginal expected survival and hazards can be calculated by providing a 
population-based lifetable of class ratetable in <code>ratetable</code> and a 
mapping between stratification factors in the lifetable and the user dataset
using <code>rmap</code>. If these stratification factors are not in the fitted
survival model then the user must specify them in <code>newdata</code> along with
the covariates of the model. The marginal expected survival is calculated 
using the &quot;Ederer&quot; method that assumes no censoring as this is most relevant 
approach for forecasting (see 
<code><a href="survival.html#topic+survexp">survexp</a></code>). A worked example is given below.
</p>
<p>Marginal all-cause survival and hazards can be calculated after fitting a
relative survival model, which utilise the expected survival from a population
ratetable. See Rutherford et al. (Chapter 6) for further details.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> containing one row for each 
time-point. The column naming convention is <code>at{i}</code> for the ith scenario
with corresponding confidence intervals (if specified) named <code>at{i}_lci</code>
and <code>at{i}_uci</code>. Contrasts are named <code>contrast{k}_{j}</code> for the 
comparison of the kth versus the jth <code>at</code> scenario.
</p>
<p>In addition tidy long-format data.frames are returned in the attributes
<code>standsurv_at</code> and <code>standsurv_contrast</code>. These can be passed to 
<code>ggplot</code> for plotting purposes (see <code><a href="#topic+plot.standsurv">plot.standsurv</a></code>).
</p>


<h3>Author(s)</h3>

<p>Michael Sweeting &lt;mikesweeting79@gmail.com&gt;
</p>


<h3>References</h3>

<p>Paul Lambert, 2021. &quot;STANDSURV: Stata module to compute 
standardized (marginal) survival and related functions,&quot; 
Statistical Software Components S458991, Boston College Department of 
Economics. https://ideas.repec.org/c/boc/bocode/s458991.html
</p>
<p>Rutherford, MJ, Lambert PC, Sweeting MJ, Pennington B, Crowther MJ, Abrams KR,
Latimer NR. 2020. &quot;NICE DSU Technical Support Document 21: Flexible Methods 
for Survival Analysis&quot; 
https://nicedsu.sites.sheffield.ac.uk/tsds/flexible-methods-for-survival-analysis-tsd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## mean age is higher in those with smaller observed survival times 
newbc &lt;- bc
set.seed(1)
newbc$age &lt;- rnorm(dim(bc)[1], mean = 65-scale(newbc$recyrs, scale=FALSE),
 sd = 5)

## Fit a Weibull flexsurv model with group and age as covariates
weib_age &lt;- flexsurvreg(Surv(recyrs, censrec) ~ group+age, data=newbc, 
                       dist="weibull")
                       
## Calculate standardized survival and the difference in standardized survival
## for the three levels of group across a grid of survival times                        
standsurv_weib_age &lt;- standsurv(weib_age, 
                                           at = list(list(group="Good"), 
                                                     list(group="Medium"), 
                                                     list(group="Poor")), 
                                           t=seq(0,7, length.out=100),
                                           contrast = "difference", ci=FALSE)
standsurv_weib_age

## Calculate hazard of standardized survival and the marginal hazard ratio
## for the three levels of group across a grid of survival times
## 10 bootstraps for confidence intervals (this should be larger)
## Not run:           
haz_standsurv_weib_age &lt;- standsurv(weib_age, 
                                           at = list(list(group="Good"), 
                                                     list(group="Medium"), 
                                                     list(group="Poor")), 
                                           t=seq(0,7, length.out=100),
                                           type="hazard",
                                           contrast = "ratio", boot = TRUE,
                                           B=10, ci=TRUE)
haz_standsurv_weib_age                                            
plot(haz_standsurv_weib_age, ci=TRUE)
## Hazard ratio plot shows a decreasing marginal HR 
## Whereas the conditional HR is constant (model is a PH model)
plot(haz_standsurv_weib_age, contrast=TRUE, ci=TRUE)

## Calculate standardized survival from a Weibull model together with expected
## survival matching to US lifetables

# age at diagnosis in days. This is required to match to US ratetable, whose
# timescale is measured in days
newbc$agedays &lt;- floor(newbc$age * 365.25)  
## Create some random diagnosis dates centred on 01/01/2010 with SD=1 year
## These will be used to match to expected rates in the lifetable
newbc$diag &lt;- as.Date(floor(rnorm(dim(newbc)[1], 
                     mean = as.Date("01/01/2010", "%d/%m/%Y"), sd=365)), 
                     origin="1970-01-01")
## Create sex (assume all are female)
newbc$sex &lt;- factor("female")
standsurv_weib_expected &lt;- standsurv(weib_age, 
                                           at = list(list(group="Good"), 
                                                     list(group="Medium"), 
                                                     list(group="Poor")), 
                                           t=seq(0,7, length.out=100),
                                           rmap=list(sex = sex,
                                                     year = diag,
                                                     age = agedays),
                                           ratetable = survival::survexp.us,
                                           scale.ratetable = 365.25,
                                           newdata = newbc)
## Plot marginal survival with expected survival superimposed                                            
plot(standsurv_weib_expected, expected=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.flexsurvreg'>Summaries of fitted flexible survival models</h2><span id='topic+summary.flexsurvreg'></span>

<h3>Description</h3>

<p>Return fitted survival, cumulative hazard or hazard at a series of times
from a fitted <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
summary(
  object,
  newdata = NULL,
  X = NULL,
  type = "survival",
  fn = NULL,
  t = NULL,
  quantiles = 0.5,
  start = 0,
  cross = TRUE,
  ci = TRUE,
  se = FALSE,
  B = 1000,
  cl = 0.95,
  tidy = FALSE,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flexsurvreg_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing covariate values to produce fitted
values for.  Or a list that can be coerced to such a data frame.  There
must be a column for every covariate in the model formula, and one row for
every combination of covariates the fitted values are wanted for.  These
are in the same format as the original data, with factors as a single
variable, not 0/1 contrasts.
</p>
<p>If this is omitted, if there are any continuous covariates, then a single
summary is provided with all covariates set to their mean values in the
data - for categorical covariates, the means of the 0/1 indicator variables
are taken.  If there are only factor covariates in the model, then all
distinct groups are used by default.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_x">X</code></td>
<td>
<p>Alternative way of defining covariate values to produce fitted
values for.  Since version 0.4, <code>newdata</code> is an easier way that
doesn't require the user to create factor contrasts, but <code>X</code> has been
kept for backwards compatibility.
</p>
<p>Columns of <code>X</code> represent different covariates, and rows represent
multiple combinations of covariate values.  For example
<code>matrix(c(1,2),nrow=2)</code> if there is only one covariate in the model,
and we want survival for covariate values of 1 and 2.  A vector can also be
supplied if just one combination of covariates is needed.
</p>
<p>For &ldquo;factor&rdquo; (categorical) covariates, the values of the contrasts
representing factor levels (as returned by the <code><a href="stats.html#topic+contrasts">contrasts</a></code>
function) should be used.  For example, for a covariate <code>agegroup</code>
specified as an unordered factor with levels <code>20-29, 30-39, 40-49,
50-59</code>, and baseline level <code>20-29</code>, there are three contrasts.  To
return summaries for groups <code>20-29</code> and <code>40-49</code>, supply <code>X =
rbind(c(0,0,0), c(0,1,0))</code>, since all contrasts are zero for the baseline
level, and the second contrast is &ldquo;turned on&rdquo; for the third level
<code>40-49</code>.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_type">type</code></td>
<td>
<p><code>"survival"</code> for survival probabilities.
</p>
<p><code>"cumhaz"</code> for cumulative hazards.
</p>
<p><code>"hazard"</code> for hazards.
</p>
<p><code>"rmst"</code> for restricted mean survival.
</p>
<p><code>"mean"</code> for mean survival.
</p>
<p><code>"median"</code> for median survival (alternative to <code>type="quantile"</code> with <code>quantiles=0.5</code>).
</p>
<p><code>"quantile"</code> for quantiles of the survival time distribution.
</p>
<p><code>"link"</code> for the fitted value of the location parameter (i.e. the &quot;linear predictor&quot; but on the natural scale of the parameter, not on the log scale)
</p>
<p>Ignored if <code>"fn"</code> is specified.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_fn">fn</code></td>
<td>
<p>Custom function of the parameters to summarise against time.
This has optional first two arguments <code>t</code> representing time, and
<code>start</code> representing left-truncation points, and any remaining
arguments must be parameters of the distribution.  It should be vectorised, and
return a vector corresponding to the vectors given by <code>t</code>, <code>start</code> and
the parameter vectors.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_t">t</code></td>
<td>
<p>Times to calculate fitted values for. By default, these are the
sorted unique observation (including censoring) times in the data - for
left-truncated datasets these are the &quot;stop&quot; times.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_quantiles">quantiles</code></td>
<td>
<p>If <code>type="quantile"</code>, this specifies the quantiles of the survival time distribution to return estimates for.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
survival, hazard or cumulative hazard will be conditioned on survival up to
this time.   Predicted times returned with <code>"rmst"</code>, <code>"mean"</code>, <code>"median"</code> or <code>"quantile"</code>
will be times since time zero, not times since the <code>start</code> time.
</p>
<p>A vector of the same length as <code>t</code> can be supplied to allow different
truncation times for each prediction time, though this doesn't make sense
in the usual case where this function is used to calculate a predicted
trajectory for a single individual.  This is why the default <code>start</code>
time was changed for version 0.4 of <span class="pkg">flexsurv</span> - this was previously a
vector of the start times observed in the data.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_cross">cross</code></td>
<td>
<p>If <code>TRUE</code> (the default) then summaries are calculated for all combinations of times
specified in <code>t</code> and covariate vectors specifed in <code>newdata</code>.
</p>
<p>If <code>FALSE</code>,
then the times <code>t</code> should be of length equal to the number of rows in <code>newdata</code>,
and one summary is produced for each row of <code>newdata</code> paired with the corresponding
element of <code>t</code>. This is used, e.g. when determining Cox-Snell residuals.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_ci">ci</code></td>
<td>
<p>Set to <code>FALSE</code> to omit confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_se">se</code></td>
<td>
<p>Set to <code>TRUE</code> to include standard errors.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution of
the estimates used to calculate confidence intervals or standard errors.
Decrease for greater
speed at the expense of accuracy, or set <code>B=0</code> to turn off calculation
of CIs and SEs.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_tidy">tidy</code></td>
<td>
<p>If <code>TRUE</code>, then the results are returned as a tidy data
frame instead of a list.  This can help with using the <span class="pkg">ggplot2</span>
package to compare summaries for different covariate values.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what should be done with missing values in <code>newdata</code>.  If <code>na.pass</code> (the default) then summaries of <code>NA</code> are produced for missing covariate values.  If <code>na.omit</code>, then missing values are dropped, the behaviour of <code>summary.flexsurvreg</code> before <code>flexsurv</code> version 1.2.</p>
</td></tr>
<tr><td><code id="summary.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.  Currently
unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-dependent covariates are not currently supported.  The covariate
values are assumed to be constant through time for each fitted curve.
</p>


<h3>Value</h3>

<p>If <code>tidy=FALSE</code>, a list with one component for each unique
covariate value (if there are only categorical covariates) or one component
(if there are no covariates or any continuous covariates).  Each of these
components is a matrix with one row for each time in <code>t</code>, giving the
estimated survival (or cumulative hazard, or hazard) and 95% confidence
limits.  These list components are named with the covariate names and
values which define them.
</p>
<p>If <code>tidy=TRUE</code>, a data frame is returned instead.  This is formed by
stacking the above list components, with additional columns to identify the
covariate values that each block corresponds to.
</p>
<p>If there are multiple summaries, an additional list component named
<code>X</code> contains a matrix with the exact values of contrasts (dummy
covariates) defining each summary.
</p>
<p>The <code><a href="#topic+plot.flexsurvreg">plot.flexsurvreg</a></code> function can be used to quickly plot
these model-based summaries against empirical summaries such as
Kaplan-Meier curves, to diagnose model fit.
</p>
<p>Confidence intervals are obtained by sampling randomly from the asymptotic
normal distribution of the maximum likelihood estimates and then taking quantiles
(see, e.g. Mandel (2013)).
</p>


<h3>Author(s)</h3>

<p>C. H. Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>
</p>


<h3>References</h3>

<p>Mandel, M. (2013). &quot;Simulation based confidence intervals for
functions with complicated derivatives.&quot; The American Statistician (in
press).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvreg">flexsurvreg</a></code>, <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>

<hr>
<h2 id='summary.flexsurvrtrunc'>Summarise quantities of interest from fitted flexsurvrtrunc models</h2><span id='topic+summary.flexsurvrtrunc'></span>

<h3>Description</h3>

<p>This function extracts quantities of interest from the untruncated 
version of a model with individual-specific right truncation points 
fitted by <code><a href="#topic+flexsurvrtrunc">flexsurvrtrunc</a></code>.  Note that covariates are
currently not supported by <code><a href="#topic+flexsurvrtrunc">flexsurvrtrunc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvrtrunc'
summary(
  object,
  type = "survival",
  fn = NULL,
  t = NULL,
  quantiles = 0.5,
  ci = TRUE,
  se = FALSE,
  B = 1000,
  cl = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flexsurvrtrunc_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_type">type</code></td>
<td>
<p><code>"survival"</code> for survival probabilities.
</p>
<p><code>"cumhaz"</code> for cumulative hazards.
</p>
<p><code>"hazard"</code> for hazards.
</p>
<p><code>"rmst"</code> for restricted mean survival.
</p>
<p><code>"mean"</code> for mean survival.
</p>
<p><code>"median"</code> for median survival (alternative to <code>type="quantile"</code> with <code>quantiles=0.5</code>).
</p>
<p><code>"quantile"</code> for quantiles of the survival time distribution.
</p>
<p>Ignored if <code>"fn"</code> is specified.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_fn">fn</code></td>
<td>
<p>Custom function of the parameters to summarise against time.
This has optional first argument <code>t</code> representing time, and any remaining
arguments must be parameters of the distribution.  It should return a
vector of the same length as <code>t</code>.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_t">t</code></td>
<td>
<p>Times to calculate fitted values for. By default, these are the
sorted unique observation (including censoring) times in the data - for
left-truncated datasets these are the &quot;stop&quot; times.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_quantiles">quantiles</code></td>
<td>
<p>If <code>type="quantile"</code>, this specifies the quantiles of the survival time distribution to return estimates for.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_ci">ci</code></td>
<td>
<p>Set to <code>FALSE</code> to omit confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_se">se</code></td>
<td>
<p>Set to <code>TRUE</code> to include standard errors.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution of
the estimates used to calculate confidence intervals or standard errors.
Decrease for greater
speed at the expense of accuracy, or set <code>B=0</code> to turn off calculation
of CIs and SEs.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="summary.flexsurvrtrunc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.  Currently
unused.</p>
</td></tr>
</table>

<hr>
<h2 id='survrtrunc'>Nonparametric estimator of survival from right-truncated, uncensored data</h2><span id='topic+survrtrunc'></span>

<h3>Description</h3>

<p>Estimates the survivor function from right-truncated, uncensored data by
reversing time, interpreting the data as left-truncated, applying the
Kaplan-Meier / Lynden-Bell estimator and transforming back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survrtrunc(t, rtrunc, tmax, data = NULL, eps = 0.001, conf.int = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survrtrunc_+3A_t">t</code></td>
<td>
<p>Vector of observed times from an initial event to a final event.</p>
</td></tr>
<tr><td><code id="survrtrunc_+3A_rtrunc">rtrunc</code></td>
<td>
<p>Individual-specific right truncation points, so that each
individual's survival time <code>t</code> would not have been observed if it was
greater than the corresponding element of <code>rtrunc</code>.   If any of these
are greater than <code>tmax</code>, then the actual individual-level truncation
point for these individuals is taken to be <code>tmax</code>.</p>
</td></tr>
<tr><td><code id="survrtrunc_+3A_tmax">tmax</code></td>
<td>
<p>Maximum possible time to event that could have been observed.</p>
</td></tr>
<tr><td><code id="survrtrunc_+3A_data">data</code></td>
<td>
<p>Data frame to find <code>t</code> and <code>rtrunc</code> in.  If not
supplied, these should be in the working environment.</p>
</td></tr>
<tr><td><code id="survrtrunc_+3A_eps">eps</code></td>
<td>
<p>Small number that is added to <code>t</code> before implementing the
time-reversed estimator, to ensure the risk set is consistent between
forward and reverse time scales. It should be just large enough that
<code>t+eps</code> is not <code>==t</code>. This should not need changing from the
default of 0.001, unless <code>t</code> are extremely large or small and the
data are rounded to integer.</p>
</td></tr>
<tr><td><code id="survrtrunc_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level, defaulting to 0.95.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this does not estimate the untruncated survivor function - instead
it estimates the survivor function truncated above at a time defined by the
maximum possible time that might have been observed in the data.
</p>
<p>Define <code class="reqn">X</code> as the time of the initial event, <code class="reqn">Y</code> as the time of the
final event, then we wish to determine the distribution of <code class="reqn">T = Y- X</code>.
</p>
<p>Observations are only recorded if <code class="reqn">Y \leq t_{max}</code>.  Then the
distribution of <code class="reqn">T</code> in the resulting sample is right-truncated by
<code>rtrunc</code> <code class="reqn"> = t_{max} - X</code>.
</p>
<p>Equivalently, the distribution of <code class="reqn">t_{max} - T</code> is left-truncated, since
it is only observed if <code class="reqn">t_{max} - T \geq X</code>.  Then the standard
Kaplan-Meier type estimator as implemented in
<code><a href="survival.html#topic+survfit">survfit</a></code> is used (as described by Lynden-Bell, 1971)
and the results transformed back.
</p>
<p>This situation might happen in a disease epidemic, where <code class="reqn">X</code> is the date
of disease onset for an individual, <code class="reqn">Y</code> is the date of death, and we
wish to estimate the distribution of the time <code class="reqn">T</code> from onset to death,
given we have only observed people who have died by the date <code class="reqn">t_{max}</code>.
</p>
<p>If the estimated survival is unstable at the highest times, then consider
replacing <code>tmax</code> by a slightly lower value, then if necessary, removing
individuals with <code>t &gt; tmax</code>, so that the estimand is changed to the
survivor function truncated over a slightly narrower interval.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<p><code>time</code> Time points where the estimated survival changes.
</p>
<p><code>surv</code> Estimated survival at <code>time</code>, truncated above at
<code>tmax</code>.
</p>
<p><code>se.surv</code> Standard error of survival.
</p>
<p><code>std.err</code> Standard error of -log(survival). Named this way for consistency with <code>survfit</code>.
</p>
<p><code>lower</code> Lower confidence limits for survival.
</p>
<p><code>upper</code> Upper confidence limits for survival.
</p>


<h3>References</h3>

<p>D. Lynden-Bell (1971)  A method of allowing for known observational
selection in small samples applied to 3CR quasars. Monthly Notices of the
Royal Astronomical Society, 155:95‚Äì118.
</p>
<p>Seaman, S., Presanis, A. and Jackson, C. (2020) Review of methods for
estimating distribution of time to event from right-truncated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate some event time data
set.seed(1)
X &lt;- rweibull(100, 2, 10)
T &lt;- rweibull(100, 2, 10)

## truncate above
tmax &lt;- 20
obs &lt;- X + T &lt; tmax
rtrunc &lt;- tmax - X
dat &lt;- data.frame(X, T, rtrunc)[obs,]
sf &lt;-    survrtrunc(T, rtrunc, data=dat, tmax=tmax)
plot(sf, conf.int=TRUE)
## Kaplan-Meier estimate ignoring truncation is biased
sfnaive &lt;- survfit(Surv(T) ~ 1, data=dat)
lines(sfnaive, conf.int=TRUE, lty=2, col="red")

## truncate above the maximum observed time
tmax &lt;- max(X + T) + 10
obs &lt;- X + T &lt; tmax
rtrunc &lt;- tmax - X
dat &lt;- data.frame(X, T, rtrunc)[obs,]
sf &lt;-    survrtrunc(T, rtrunc, data=dat, tmax=tmax)
plot(sf, conf.int=TRUE)
## estimates identical to the standard Kaplan-Meier
sfnaive &lt;- survfit(Surv(T) ~ 1, data=dat)
lines(sfnaive, conf.int=TRUE, lty=2, col="red")


</code></pre>

<hr>
<h2 id='Survspline'>Royston/Parmar spline survival distribution</h2><span id='topic+Survspline'></span><span id='topic+dsurvspline'></span><span id='topic+psurvspline'></span><span id='topic+qsurvspline'></span><span id='topic+rsurvspline'></span><span id='topic+hsurvspline'></span><span id='topic+Hsurvspline'></span><span id='topic+mean_survspline'></span><span id='topic+rmst_survspline'></span>

<h3>Description</h3>

<p>Probability density, distribution, quantile, random generation, hazard, 
cumulative hazard, mean and restricted mean functions for the Royston/Parmar
spline model. These functions have all parameters of the distribution collected
together in a single argument <code>gamma</code>. For the equivalent functions with
one argument per parameter, see <code><a href="#topic+Survsplinek">Survsplinek</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsurvspline(
  x,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0,
  log = FALSE
)

psurvspline(
  q,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline(
  p,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rsurvspline(
  n,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0
)

Hsurvspline(
  x,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0
)

hsurvspline(
  x,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0
)

rmst_survspline(
  t,
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0,
  start = 0
)

mean_survspline(
  gamma,
  beta = 0,
  X = 0,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  offset = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Survspline_+3A_x">x</code>, <code id="Survspline_+3A_q">q</code>, <code id="Survspline_+3A_t">t</code></td>
<td>
<p>Vector of times.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_gamma">gamma</code></td>
<td>
<p>Parameters describing the baseline spline function, as
described in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.  This may be supplied as a
vector with number of elements equal to the length of <code>knots</code>, in
which case the parameters are common to all times.  Alternatively a matrix
may be supplied, with rows corresponding to different times, and columns
corresponding to <code>knots</code>.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_beta">beta</code></td>
<td>
<p>Vector of covariate effects (deprecated).</p>
</td></tr>
<tr><td><code id="Survspline_+3A_x">X</code></td>
<td>
<p>Matrix of covariate values (deprecated).</p>
</td></tr>
<tr><td><code id="Survspline_+3A_knots">knots</code></td>
<td>
<p>Locations of knots on the axis of log time, supplied in
increasing order.  Unlike in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, these include
the two boundary knots.  If there are no additional knots, the boundary
locations are not used.  If there are one or more additional knots, the
boundary knots should be at or beyond the minimum and maximum values of the
log times.  In <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> these are exactly at the
minimum and maximum values.
</p>
<p>This may in principle be supplied as a matrix, in the same way as for
<code>gamma</code>, but in most applications the knots will be fixed.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_scale">scale</code></td>
<td>
<p><code>"hazard"</code>, <code>"odds"</code>, or <code>"normal"</code>, as
described in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.  With the default of no knots in
addition to the boundaries, this model reduces to the Weibull, log-logistic
and log-normal respectively.  The scale must be common to all times.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_timescale">timescale</code></td>
<td>
<p><code>"log"</code> or <code>"identity"</code> as described in
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_offset">offset</code></td>
<td>
<p>An extra constant to add to the linear predictor
<code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_log">log</code>, <code id="Survspline_+3A_log.p">log.p</code></td>
<td>
<p>Return log density or probability.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_n">n</code></td>
<td>
<p>Number of random numbers to simulate.</p>
</td></tr>
<tr><td><code id="Survspline_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
restricted mean survival will be conditioned on survival up to
this time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dsurvspline</code> gives the density, <code>psurvspline</code> gives the
distribution function, <code>hsurvspline</code> gives the hazard and
<code>Hsurvspline</code> gives the cumulative hazard, as described in
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>
<p><code>qsurvspline</code> gives the quantile function, which is computed by crude
numerical inversion (using <code><a href="#topic+qgeneric">qgeneric</a></code>).
</p>
<p><code>rsurvspline</code> generates random survival times by using
<code>qsurvspline</code> on a sample of uniform random numbers.  Due to the
numerical root-finding involved in <code>qsurvspline</code>, it is slow compared
to typical random number generation functions.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Royston, P. and Parmar, M. (2002).  Flexible parametric
proportional-hazards and proportional-odds models for censored survival
data, with application to prognostic modelling and estimation of treatment
effects. Statistics in Medicine 21(1):2175-2197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## reduces to the weibull
regscale &lt;- 0.786; cf &lt;- 1.82
a &lt;- 1/regscale; b &lt;- exp(cf)
dweibull(1, shape=a, scale=b)
dsurvspline(1, gamma=c(log(1 / b^a), a)) # should be the same

## reduces to the log-normal
meanlog &lt;- 1.52; sdlog &lt;- 1.11
dlnorm(1, meanlog, sdlog) 
dsurvspline(1, gamma = c(-meanlog/sdlog, 1/sdlog), scale="normal")
# should be the same
</code></pre>

<hr>
<h2 id='Survsplinek'>Royston/Parmar spline survival distribution functions</h2><span id='topic+Survsplinek'></span><span id='topic+dsurvspline0'></span><span id='topic+dsurvspline1'></span><span id='topic+dsurvspline2'></span><span id='topic+dsurvspline3'></span><span id='topic+dsurvspline4'></span><span id='topic+dsurvspline5'></span><span id='topic+dsurvspline6'></span><span id='topic+dsurvspline7'></span><span id='topic+psurvspline0'></span><span id='topic+psurvspline1'></span><span id='topic+psurvspline2'></span><span id='topic+psurvspline3'></span><span id='topic+psurvspline4'></span><span id='topic+psurvspline5'></span><span id='topic+psurvspline6'></span><span id='topic+psurvspline7'></span><span id='topic+qsurvspline0'></span><span id='topic+qsurvspline1'></span><span id='topic+qsurvspline2'></span><span id='topic+qsurvspline3'></span><span id='topic+qsurvspline4'></span><span id='topic+qsurvspline5'></span><span id='topic+qsurvspline6'></span><span id='topic+qsurvspline7'></span><span id='topic+rsurvspline0'></span><span id='topic+rsurvspline1'></span><span id='topic+rsurvspline2'></span><span id='topic+rsurvspline3'></span><span id='topic+rsurvspline4'></span><span id='topic+rsurvspline5'></span><span id='topic+rsurvspline6'></span><span id='topic+rsurvspline7'></span><span id='topic+hsurvspline0'></span><span id='topic+hsurvspline1'></span><span id='topic+hsurvspline2'></span><span id='topic+hsurvspline3'></span><span id='topic+hsurvspline4'></span><span id='topic+hsurvspline5'></span><span id='topic+hsurvspline6'></span><span id='topic+hsurvspline7'></span><span id='topic+Hsurvspline0'></span><span id='topic+Hsurvspline1'></span><span id='topic+Hsurvspline2'></span><span id='topic+Hsurvspline3'></span><span id='topic+Hsurvspline4'></span><span id='topic+Hsurvspline5'></span><span id='topic+Hsurvspline6'></span><span id='topic+Hsurvspline7'></span><span id='topic+mean_survspline0'></span><span id='topic+mean_survspline1'></span><span id='topic+mean_survspline2'></span><span id='topic+mean_survspline3'></span><span id='topic+mean_survspline4'></span><span id='topic+mean_survspline5'></span><span id='topic+mean_survspline6'></span><span id='topic+mean_survspline7'></span><span id='topic+rmst_survspline0'></span><span id='topic+rmst_survspline1'></span><span id='topic+rmst_survspline2'></span><span id='topic+rmst_survspline3'></span><span id='topic+rmst_survspline4'></span><span id='topic+rmst_survspline5'></span><span id='topic+rmst_survspline6'></span><span id='topic+rmst_survspline7'></span>

<h3>Description</h3>

<p>Probability density, distribution, quantile, random generation, hazard, 
cumulative hazard, mean and restricted mean functions for the Royston/Parmar
spline model, with one argument per parameter.   For the equivalent functions with all parameters collected together in a single argument, see <code><a href="#topic+Survspline">Survspline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_survspline0(
  gamma0,
  gamma1,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline1(
  gamma0,
  gamma1,
  gamma2,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline2(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline3(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline4(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline5(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline6(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

mean_survspline7(
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log"
)

rmst_survspline0(
  t,
  gamma0,
  gamma1,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline1(
  t,
  gamma0,
  gamma1,
  gamma2,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline2(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline3(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline4(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline5(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline6(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

rmst_survspline7(
  t,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots = c(-10, 10),
  scale = "hazard",
  timescale = "log",
  start = 0
)

dsurvspline0(
  x,
  gamma0,
  gamma1,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline1(
  x,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline2(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline3(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline4(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline5(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline6(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

dsurvspline7(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log",
  log = FALSE
)

psurvspline0(
  q,
  gamma0,
  gamma1,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline1(
  q,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline2(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline3(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline4(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline5(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline6(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

psurvspline7(
  q,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline0(
  p,
  gamma0,
  gamma1,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline1(
  p,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline2(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline3(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline4(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline5(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline6(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

qsurvspline7(
  p,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log",
  lower.tail = TRUE,
  log.p = FALSE
)

rsurvspline0(n, gamma0, gamma1, knots, scale = "hazard", timescale = "log")

rsurvspline1(
  n,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline2(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline3(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline4(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline5(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline6(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log"
)

rsurvspline7(
  n,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline0(x, gamma0, gamma1, knots, scale = "hazard", timescale = "log")

hsurvspline1(
  x,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline2(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline3(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline4(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline5(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline6(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log"
)

hsurvspline7(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline0(x, gamma0, gamma1, knots, scale = "hazard", timescale = "log")

Hsurvspline1(
  x,
  gamma0,
  gamma1,
  gamma2,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline2(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline3(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline4(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline5(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline6(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  knots,
  scale = "hazard",
  timescale = "log"
)

Hsurvspline7(
  x,
  gamma0,
  gamma1,
  gamma2,
  gamma3,
  gamma4,
  gamma5,
  gamma6,
  gamma7,
  gamma8,
  knots,
  scale = "hazard",
  timescale = "log"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Survsplinek_+3A_gamma0">gamma0</code>, <code id="Survsplinek_+3A_gamma1">gamma1</code>, <code id="Survsplinek_+3A_gamma2">gamma2</code>, <code id="Survsplinek_+3A_gamma3">gamma3</code>, <code id="Survsplinek_+3A_gamma4">gamma4</code>, <code id="Survsplinek_+3A_gamma5">gamma5</code>, <code id="Survsplinek_+3A_gamma6">gamma6</code>, <code id="Survsplinek_+3A_gamma7">gamma7</code>, <code id="Survsplinek_+3A_gamma8">gamma8</code></td>
<td>
<p>Parameters describing the baseline spline function, as
described in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_knots">knots</code></td>
<td>
<p>Locations of knots on the axis of log time, supplied in
increasing order.  Unlike in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, these include
the two boundary knots.  If there are no additional knots, the boundary
locations are not used.  If there are one or more additional knots, the
boundary knots should be at or beyond the minimum and maximum values of the
log times.  In <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> these are exactly at the
minimum and maximum values.
</p>
<p>This may in principle be supplied as a matrix, in the same way as for
<code>gamma</code>, but in most applications the knots will be fixed.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_scale">scale</code></td>
<td>
<p><code>"hazard"</code>, <code>"odds"</code>, or <code>"normal"</code>, as
described in <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.  With the default of no knots in
addition to the boundaries, this model reduces to the Weibull, log-logistic
and log-normal respectively.  The scale must be common to all times.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_timescale">timescale</code></td>
<td>
<p><code>"log"</code> or <code>"identity"</code> as described in
<code><a href="#topic+flexsurvspline">flexsurvspline</a></code>.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times.  The returned
restricted mean survival will be conditioned on survival up to
this time.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_x">x</code>, <code id="Survsplinek_+3A_q">q</code>, <code id="Survsplinek_+3A_t">t</code></td>
<td>
<p>Vector of times.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_log">log</code>, <code id="Survsplinek_+3A_log.p">log.p</code></td>
<td>
<p>Return log density or probability.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Survsplinek_+3A_n">n</code></td>
<td>
<p>Number of random numbers to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions go up to 7 spline knots, or 9 parameters.  If you'd like higher-dimension versions, just submit an issue at <a href="https://github.com/chjackson/flexsurv-dev/issues">https://github.com/chjackson/flexsurv-dev/issues</a>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>

<hr>
<h2 id='tidy.flexsurvreg'>Tidy a flexsurv model object</h2><span id='topic+tidy.flexsurvreg'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the model into a tidy data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  pars = "all",
  transform = "none",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.flexsurvreg_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+flexsurvreg">flexsurvreg</a></code> or <code><a href="#topic+flexsurvspline">flexsurvspline</a></code>, representing a fitted survival model object.</p>
</td></tr>
<tr><td><code id="tidy.flexsurvreg_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Should confidence intervals be returned? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.flexsurvreg_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval if <code>conf.int = TRUE</code>. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="tidy.flexsurvreg_+3A_pars">pars</code></td>
<td>
<p>One of <code>"all"</code>, <code>"baseline"</code>, or <code>"coefs"</code> for all parameters, baseline distribution parameters, or covariate effects (i.e. regression betas), respectively. Default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="tidy.flexsurvreg_+3A_transform">transform</code></td>
<td>
<p>Character vector of transformations to apply to requested <code>pars</code>. Default is <code>"none"</code>, which returns <code>pars</code> as-is.
</p>
<p>Users can specify one or both types of transformations:
</p>

<ul>
<li> <p><code>"baseline.real"</code> which transforms the baseline distribution parameters to the real number line used for estimation.
</p>
</li>
<li> <p><code>"coefs.exp"</code> which exponentiates the covariate effects.
</p>
</li></ul>

<p>See <code>Details</code> for a more complete explanation.</p>
</td></tr>
<tr><td><code id="tidy.flexsurvreg_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flexsurvreg</code> models estimate two types of coefficients, baseline distribution parameters, and covariate effects which act on the baseline distribution. By design, <code>flexsurvreg</code> returns distribution parameters on the same scale as is found in the relevant <code>d/p/q/r</code> functions. Covariate effects are returned on the log-scale, which represents either log-time ratios (accelerated failure time models) or log-hazard ratios for proportional hazard models. By default, <code>tidy()</code> will return baseline distribution parameters on their natural scale and covariate effects on the log-scale.
</p>
<p>To transform the baseline distribution parameters to the real-value number line (the scale used for estimation), pass the character argument <code>"baseline.real"</code> to <code>transform</code>. To get time ratios or hazard ratios, pass <code>"coefs.exp"</code> to <code>transform</code>. These transformations may be done together by submitting both arguments as a character vector.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> containing the columns: <code>term</code>, <code>estimate</code>, <code>std.error</code>, <code>statistic</code>, <code>p.value</code>, <code>conf.low</code>, and <code>conf.high</code>, by default.
</p>
<p><code>statistic</code> and <code>p.value</code> are only provided for covariate effects (<code>NA</code> for baseline distribution parameters). These are computed as Wald-type test statistics with p-values from a standard normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")
tidy(fitg)
tidy(fitg, pars = "coefs", transform = "coefs.exp")

</code></pre>

<hr>
<h2 id='tidy.standsurv'>Tidy a standsurv object.</h2><span id='topic+tidy.standsurv'></span>

<h3>Description</h3>

<p>This function is used internally by <code>standsurv</code> and tidy
data.frames are automatically returned by the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'standsurv'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.standsurv_+3A_x">x</code></td>
<td>
<p>A standsurv object.</p>
</td></tr>
<tr><td><code id="tidy.standsurv_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns additional tidy data.frames (tibbles)
stored as attributes named standpred_at and standpred_contrast.
</p>

<hr>
<h2 id='totlos.fs'>Total length of stay in particular states for a fully-parametric,
time-inhomogeneous Markov multi-state model</h2><span id='topic+totlos.fs'></span>

<h3>Description</h3>

<p>The matrix whose <code class="reqn">r,s</code> entry is the expected amount of time spent in
state <code class="reqn">s</code> for a time-inhomogeneous, continuous-time Markov multi-state
process that starts in state <code class="reqn">r</code>, up to a maximum time <code class="reqn">t</code>. This is
defined as the integral of the corresponding transition probability up to
that time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totlos.fs(
  x,
  trans = NULL,
  t = 1,
  newdata = NULL,
  ci = FALSE,
  tvar = "trans",
  sing.inf = 1e+10,
  B = 1000,
  cl = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totlos.fs_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.  Additionally, this must be a Markov / clock-forward model, but can
be time-inhomogeneous.  See the package vignette for further explanation.
</p>
<p><code>x</code> can also be a list of models, with one component for each
permitted transition, as illustrated in <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_t">t</code></td>
<td>
<p>Time or vector of times to predict up to.  Must be finite.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_ci">ci</code></td>
<td>
<p>Return a confidence interval calculated by simulating from the
asymptotic normal distribution of the maximum likelihood estimates.  Turned
off by default, since this is computationally intensive.  If turned on,
users should increase <code>B</code> until the results reach the desired
precision.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_sing.inf">sing.inf</code></td>
<td>
<p>If there is a singularity in the observed hazard, for
example a Weibull distribution with <code>shape &lt; 1</code> has infinite hazard at
<code>t=0</code>, then as a workaround, the hazard is assumed to be a large
finite number, <code>sing.inf</code>, at this time.  The results should not be
sensitive to the exact value assumed, but users should make sure by
adjusting this parameter in these cases.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution used
to calculate variances.  Decrease for greater speed at the expense of
accuracy.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="totlos.fs_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="deSolve.html#topic+ode">ode</a></code> in <span class="pkg">deSolve</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is computed by solving a second order extension of the Kolmogorov
forward differential equation numerically, using the methods in the
<code><a href="deSolve.html#topic+deSolve">deSolve</a></code> package.  The equation is expressed as a linear
system
</p>
<p style="text-align: center;"><code class="reqn">\frac{dT(t)}{dt} = P(t)</code>
</p>
 <p style="text-align: center;"><code class="reqn">\frac{dP(t)}{dt} = P(t) Q(t)</code>
</p>

<p>and solved for <code class="reqn">T(t)</code> and <code class="reqn">P(t)</code> simultaneously, where <code class="reqn">T(t)</code>
is the matrix of total lengths of stay, <code class="reqn">P(t)</code> is the transition
probability matrix for time <code class="reqn">t</code>, and <code class="reqn">Q(t)</code> is the transition
hazard or intensity as a function of <code class="reqn">t</code>.  The initial conditions are
<code class="reqn">T(0) = 0</code> and <code class="reqn">P(0) = I</code>.
</p>
<p>Note that the package <span class="pkg">msm</span> has a similar method <code>totlos.msm</code>.
<code>totlos.fs</code> should give the same results as <code>totlos.msm</code> when
both of these conditions hold:
</p>
 <ul>
<li><p> the time-to-event distribution is exponential for all
transitions, thus the <code>flexsurvreg</code> model was fitted with
<code>dist="exp"</code>, and is time-homogeneous.  </p>
</li>
<li><p> the <span class="pkg">msm</span> model was
fitted with <code>exacttimes=TRUE</code>, thus all the event times are known, and
there are no time-dependent covariates.  </p>
</li></ul>

<p><span class="pkg">msm</span> only allows exponential or piecewise-exponential time-to-event
distributions, while <span class="pkg">flexsurvreg</span> allows more flexible models.
<span class="pkg">msm</span> however was designed in particular for panel data, where the
process is observed only at arbitrary times, thus the times of transition
are unknown, which makes flexible models difficult.
</p>
<p>This function is only valid for Markov (&quot;clock-forward&quot;) multi-state
models, though no warning or error is currently given if the model is not
Markov.  See <code><a href="#topic+totlos.simfs">totlos.simfs</a></code> for the equivalent for semi-Markov
(&quot;clock-reset&quot;) models.
</p>


<h3>Value</h3>

<p>The matrix of lengths of stay <code class="reqn">T(t)</code>, if <code>t</code> is of length
1, or a list of matrices if <code>t</code> is longer.
</p>
<p>If <code>ci=TRUE</code>, each element has attributes <code>"lower"</code> and
<code>"upper"</code> giving matrices of the corresponding confidence limits.
These are formatted for printing but may be extracted using <code>attr()</code>.
</p>
<p>The result also has an attribute <code>P</code> giving the transition probability
matrices, since these are unavoidably computed as a side effect.  These are
suppressed for printing, but can be extracted with <code>attr(...,"P")</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+totlos.simfs">totlos.simfs</a></code>, <code><a href="#topic+pmatrix.fs">pmatrix.fs</a></code>,
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# BOS example in vignette, and in msfit.flexsurvreg
bexp &lt;- flexsurvreg(Surv(Tstart, Tstop, status) ~ trans,
                    data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))

# predict 4 years spent without BOS, 3 years with BOS, before death
# As t increases, this should converge

totlos.fs(bexp, t=10, trans=tmat)
totlos.fs(bexp, t=1000, trans=tmat)
totlos.fs(bexp, t=c(5,10), trans=tmat)

# Answers should match results in help(totlos.simfs) up to Monte Carlo
# error there / ODE solving precision here, since with an exponential
# distribution, the "semi-Markov" model there is the same as the Markov
# model here
</code></pre>

<hr>
<h2 id='totlos.simfs'>Expected total length of stay in specific states, from a fully-parametric,
semi-Markov multi-state model</h2><span id='topic+totlos.simfs'></span>

<h3>Description</h3>

<p>The expected total time spent in each state for semi-Markov multi-state
models fitted to time-to-event data with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  This
is defined by the integral of the transition probability matrix, though
this is not analytically possible and is computed by simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totlos.simfs(
  x,
  trans,
  t = 1,
  start = 1,
  newdata = NULL,
  ci = FALSE,
  tvar = "trans",
  tcovs = NULL,
  group = NULL,
  M = 1e+05,
  B = 1000,
  cl = 0.95,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totlos.simfs_+3A_x">x</code></td>
<td>
<p>A model fitted with <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code> for the required form of the model and the
data.  Additionally this should be semi-Markov, so that the time variable
represents the time since the last transition.  In other words the response
should be of the form <code>Surv(time,status)</code>. See the package vignette
for further explanation.
</p>
<p><code>x</code> can also be a list of models, with one component for each
permitted transition, as illustrated in <code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_trans">trans</code></td>
<td>
<p>Matrix indicating allowed transitions.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_t">t</code></td>
<td>
<p>Maximum time to predict to.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_start">start</code></td>
<td>
<p>Starting state.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_newdata">newdata</code></td>
<td>
<p>A data frame specifying the values of covariates in the
fitted model, other than the transition number.  See
<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_ci">ci</code></td>
<td>
<p>Return a confidence interval calculated by simulating from the
asymptotic normal distribution of the maximum likelihood estimates.  This
is turned off by default, since two levels of simulation are required.  If
turned on, users should adjust <code>B</code> and/or <code>M</code> until the results
reach the desired precision.  The simulation over <code>M</code> is generally
vectorised, therefore increasing <code>B</code> is usually more expensive than
increasing <code>M</code>.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_tvar">tvar</code></td>
<td>
<p>Variable in the data representing the transition type. Not
required if <code>x</code> is a list of models.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_tcovs">tcovs</code></td>
<td>
<p>Predictable time-dependent covariates such as age, see
<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_group">group</code></td>
<td>
<p>Optional grouping for the states.  For example, if there are
four states, and <code>group=c(1,1,2,2)</code>, then <code><a href="#topic+totlos.simfs">totlos.simfs</a></code>
returns the expected total time in states 1 and 2 combined, and states 3
and 4 combined.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_m">M</code></td>
<td>
<p>Number of individuals to simulate in order to approximate the
transition probabilities.  Users should adjust this to obtain the required
precision.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_b">B</code></td>
<td>
<p>Number of simulations from the normal asymptotic distribution used
to calculate variances.  Decrease for greater speed at the expense of
accuracy.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_cl">cl</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td></tr>
<tr><td><code id="totlos.simfs_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores used when calculating confidence limits bu repeated simulation.  The default uses single-core processing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is computed by simulating a large number of individuals <code>M</code> using
the maximum likelihood estimates of the fitted model and the function
<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.  Therefore this requires a random sampling function
for the parametric survival model to be available: see the &quot;Details&quot;
section of <code><a href="#topic+sim.fmsm">sim.fmsm</a></code>.  This will be available for all built-in
distributions, though users may need to write this for custom models.
</p>
<p>Note the random sampling method for <code>flexsurvspline</code> models is
currently very inefficient, so that looping over <code>M</code> will be very
slow.
</p>
<p>The equivalent function for time-inhomogeneous Markov models is
<code><a href="#topic+totlos.fs">totlos.fs</a></code>.  Note neither of these functions give errors or
warnings if used with the wrong type of model, but the results will be
invalid.
</p>


<h3>Value</h3>

<p>The expected total time spent in each state (or group of states
given by <code>group</code>) up to time <code>t</code>, and corresponding confidence
intervals if requested.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmatrix.simfs">pmatrix.simfs</a></code>,<code><a href="#topic+sim.fmsm">sim.fmsm</a></code>,<code><a href="#topic+msfit.flexsurvreg">msfit.flexsurvreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# BOS example in vignette, and in msfit.flexsurvreg
bexp &lt;- flexsurvreg(Surv(years, status) ~ trans, data=bosms3, dist="exp")
tmat &lt;- rbind(c(NA,1,2),c(NA,NA,3),c(NA,NA,NA))

# predict 4 years spent without BOS, 3 years with BOS, before death
# As t increases, this should converge
totlos.simfs(bexp, t=10, trans=tmat)
totlos.simfs(bexp, t=1000, trans=tmat)
</code></pre>

<hr>
<h2 id='unroll.function'>Convert a function with matrix arguments to a function with vector
arguments.</h2><span id='topic+unroll.function'></span>

<h3>Description</h3>

<p>Given a function with matrix arguments, construct an equivalent function
which takes vector arguments defined by the columns of the matrix.  The new
function simply uses <code>cbind</code> on the vector arguments to make a matrix,
and calls the old one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unroll.function(mat.fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unroll.function_+3A_mat.fn">mat.fn</code></td>
<td>
<p>A function with any number of arguments, some of which are
matrices.</p>
</td></tr>
<tr><td><code id="unroll.function_+3A_...">...</code></td>
<td>
<p>A series of other arguments.  Their names define which
arguments of <code>mat.fn</code> are matrices.  Their values define a vector of
strings to be appended to the names of the arguments in the new function.
For example
</p>
<p><code>fn &lt;- unroll.function(oldfn, gamma=1:3, alpha=0:1)</code>
</p>
<p>will make a new function <code>fn</code> with arguments
<code>gamma1</code>,<code>gamma2</code>,<code>gamma3</code>,<code>alpha0</code>,<code>alpha1</code>.
</p>
<p>Calling
</p>
<p><code>fn(gamma1=a,gamma2=b,gamma3=c,alpha0=d,alpha1=e)</code>
</p>
<p>should give the same answer as
</p>
<p><code>oldfn(gamma=cbind(a,b,c),alpha=cbind(d,e))</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new function, with vector arguments.
</p>


<h3>Usage in <span class="pkg">flexsurv</span></h3>

<p>This is used by <code><a href="#topic+flexsurvspline">flexsurvspline</a></code> to allow spline models, which
have an arbitrary number of parameters, to be fitted using
<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>.
</p>
<p>The &ldquo;custom distributions&rdquo; facility of <code><a href="#topic+flexsurvreg">flexsurvreg</a></code>
expects the user-supplied probability density and distribution
functions to have one explicitly named argument for each scalar
parameter, and given R vectorisation, each of those arguments
could be supplied as a vector of alternative parameter values.
</p>
<p>However, spline models have a varying number of scalar parameters,
determined by the number of knots in the spline.
<code><a href="#topic+dsurvspline">dsurvspline</a></code> and <code><a href="#topic+psurvspline">psurvspline</a></code> have an
argument called <code>gamma</code>.  This can be supplied as a matrix,
with number of columns <code>n</code> determined by the number of knots
(plus 2), and rows referring to alternative parameter values.  The
following statements are used in the source of
<code>flexsurvspline</code>: </p>
<pre> dfn &lt;-
unroll.function(dsurvspline, gamma=0:(nk-1)) pfn &lt;-
unroll.function(psurvspline, gamma=0:(nk-1)) </pre>
<p>to convert these into functions with arguments <code>gamma0</code>,
<code>gamma1</code>,...,<code>gamman</code>, corresponding to the columns
of <code>gamma</code>, where <code>n = nk-1</code>, and with other arguments
in the same format.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexsurvspline">flexsurvspline</a></code>,<code><a href="#topic+flexsurvreg">flexsurvreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fn &lt;- unroll.function(ncol, x=1:3)
fn(1:3, 1:3, 1:3) # equivalent to...
ncol(cbind(1:3,1:3,1:3))
</code></pre>

<hr>
<h2 id='WeibullPH'>Weibull distribution in proportional hazards parameterisation</h2><span id='topic+WeibullPH'></span><span id='topic+dweibullPH'></span><span id='topic+pweibullPH'></span><span id='topic+qweibullPH'></span><span id='topic+rweibullPH'></span><span id='topic+HweibullPH'></span><span id='topic+hweibullPH'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and random
generation for the Weibull distribution in its proportional hazards
parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dweibullPH(x, shape, scale = 1, log = FALSE)

pweibullPH(q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)

qweibullPH(p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)

hweibullPH(x, shape, scale = 1, log = FALSE)

HweibullPH(x, shape, scale = 1, log = FALSE)

rweibullPH(n, shape, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeibullPH_+3A_x">x</code>, <code id="WeibullPH_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_shape">shape</code></td>
<td>
<p>Vector of shape parameters.</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_scale">scale</code></td>
<td>
<p>Vector of scale parameters.</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_log">log</code>, <code id="WeibullPH_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="WeibullPH_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Weibull distribution in proportional hazards parameterisation with
&lsquo;shape&rsquo; parameter a and &lsquo;scale&rsquo; parameter m has density given by
</p>
<p style="text-align: center;"><code class="reqn">f(x) = a m x^{a-1} exp(- m x^a) </code>
</p>

<p>cumulative distribution function <code class="reqn">F(x) = 1 - exp( -m x^a )</code>, survivor
function <code class="reqn">S(x) = exp( -m x^a )</code>, cumulative hazard <code class="reqn">m x^a</code> and
hazard <code class="reqn">a m x^{a-1}</code>.
</p>
<p><code><a href="stats.html#topic+dweibull">dweibull</a></code> in base R has the alternative 'accelerated failure
time' (AFT) parameterisation with shape a and scale b.  The shape parameter
<code class="reqn">a</code> is the same in both versions.  The scale parameters are related as
<code class="reqn">b = m^{-1/a}</code>, equivalently m = b^-a.
</p>
<p>In survival modelling, covariates are typically included through a linear
model on the log scale parameter.  Thus, in the proportional hazards model,
the coefficients in such a model on <code class="reqn">m</code> are interpreted as log hazard
ratios.
</p>
<p>In the AFT model, covariates on <code class="reqn">b</code> are interpreted as time
acceleration factors.  For example, doubling the value of a covariate with
coefficient <code class="reqn">beta=log(2)</code> would give half the expected survival time.
These coefficients are related to the log hazard ratios <code class="reqn">\gamma</code> as
<code class="reqn">\beta = -\gamma / a</code>.
</p>


<h3>Value</h3>

<p><code>dweibullPH</code> gives the density, <code>pweibullPH</code> gives the
distribution function, <code>qweibullPH</code> gives the quantile function,
<code>rweibullPH</code> generates random deviates, <code>HweibullPH</code> retuns the
cumulative hazard and <code>hweibullPH</code> the hazard.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
