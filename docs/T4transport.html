<!DOCTYPE html><html><head><title>Help for package T4transport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {T4transport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bary14C'><p>Barycenter by Cuturi &amp; Doucet (2014)</p></a></li>
<li><a href='#bary15B'><p>Barycenter by Benamou et al. (2015)</p></a></li>
<li><a href='#digit3'><p>MNIST Images of Digit 3</p></a></li>
<li><a href='#digits'><p>MNIST Images of All Digits</p></a></li>
<li><a href='#ecdfbary'><p>Barycenter of Empirical CDFs</p></a></li>
<li><a href='#ecdfmed'><p>Wasserstein Median of Empirical CDFs</p></a></li>
<li><a href='#gaussbary1d'><p>Barycenter of Gaussian Distributions in <code class="reqn">\mathbf{R}</code></p></a></li>
<li><a href='#gaussbarypd'><p>Barycenter of Gaussian Distributions in <code class="reqn">\mathbf{R}^p</code></p></a></li>
<li><a href='#gaussmed1d'><p>Wasserstein Median of Gaussian Distributions in <code class="reqn">\mathbf{R}</code></p></a></li>
<li><a href='#gaussmedpd'><p>Wasserstein Median of Gaussian Distributions in <code class="reqn">\mathbf{R}^p</code></p></a></li>
<li><a href='#gaussvis2d'><p>Sampling from a Bivariate Gaussian Distribution for Visualization</p></a></li>
<li><a href='#histbary14C'><p>Barycenter of Histograms by Cuturi &amp; Doucet (2014)</p></a></li>
<li><a href='#histbary15B'><p>Barycenter of Histograms by Benamou et al. (2015)</p></a></li>
<li><a href='#histmed22Y'><p>Wasserstein Median of Histograms by You et al. (2022)</p></a></li>
<li><a href='#imagebary14C'><p>Barycenter of Images according to Cuturi &amp; Doucet (2014)</p></a></li>
<li><a href='#imagebary15B'><p>Barycenter of Images according to Benamou et al. (2015)</p></a></li>
<li><a href='#imagemed22Y'><p>Wasserstein Median of Images by You et al. (2022)</p></a></li>
<li><a href='#ipot'><p>Wasserstein Distance by Inexact Proximal Point Method</p></a></li>
<li><a href='#sinkhorn'><p>Wasserstein Distance by Entropic Regularization</p></a></li>
<li><a href='#swdist'><p>Sliced Wasserstein Distance</p></a></li>
<li><a href='#wasserstein'><p>Wasserstein Distance between Empirical Measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Computational Optimal Transport</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Transport theory has seen much success in many fields of statistics and machine learning. We provide a variety of algorithms to compute Wasserstein distance, barycenter, and others. See Peyré and Cuturi (2019) &lt;<a href="https://doi.org/10.1561%2F2200000073">doi:10.1561/2200000073</a>&gt; for the general exposition to the study of computational optimal transport.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>CVXR, Rcpp (&ge; 1.0.5), Rdpack, lpSolve, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-11 18:59:43 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-11 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bary14C'>Barycenter by Cuturi &amp; Doucet (2014)</h2><span id='topic+bary14C'></span><span id='topic+bary14Cdist'></span>

<h3>Description</h3>

<p>Given <code class="reqn">K</code> empirical measures <code class="reqn">\mu_1, \mu_2, \ldots, \mu_K</code> of possibly different cardinalities,
wasserstein barycenter <code class="reqn">\mu^*</code> is the solution to the following problem
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k=1}^K \pi_k \mathcal{W}_p^p (\mu, \mu_k)</code>
</p>

<p>where <code class="reqn">\pi_k</code>'s are relative weights of empirical measures. Here we assume
either (1) support atoms in Euclidean space are given, or (2) all pairwise distances between
atoms of the fixed support and empirical measures are given.
Algorithmically, it is a subgradient method where the each subgradient is
approximated using the entropic regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary14C(
  support,
  atoms,
  marginals = NULL,
  weights = NULL,
  lambda = 0.1,
  p = 2,
  ...
)

bary14Cdist(
  distances,
  marginals = NULL,
  weights = NULL,
  lambda = 0.1,
  p = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bary14C_+3A_support">support</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of rows being atoms for the fixed support.</p>
</td></tr>
<tr><td><code id="bary14C_+3A_atoms">atoms</code></td>
<td>
<p>a length-<code class="reqn">K</code> list where each element is an <code class="reqn">(N_k \times P)</code> matrix of atoms.</p>
</td></tr>
<tr><td><code id="bary14C_+3A_marginals">marginals</code></td>
<td>
<p>marginal distribution for empirical measures; if <code>NULL</code> (default), uniform weights are set for all measures. Otherwise, it should be a length-<code class="reqn">K</code> list where each element is a length-<code class="reqn">N_i</code> vector of nonnegative weights that sum to 1.</p>
</td></tr>
<tr><td><code id="bary14C_+3A_weights">weights</code></td>
<td>
<p>weights for each individual measure; if <code>NULL</code> (default), each measure is considered equally. Otherwise, it should be a length-<code class="reqn">K</code> vector.</p>
</td></tr>
<tr><td><code id="bary14C_+3A_lambda">lambda</code></td>
<td>
<p>regularization parameter (default: 0.1).</p>
</td></tr>
<tr><td><code id="bary14C_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="bary14C_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
<dt>init.vec</dt><dd><p>an initial vector (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: FALSE).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bary14C_+3A_distances">distances</code></td>
<td>
<p>a length-<code class="reqn">K</code> list where each element is an <code class="reqn">(N\times N_k)</code> pairwise distance between atoms of the fixed support and given measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-<code class="reqn">N</code> vector of probability vector.
</p>


<h3>References</h3>

<p>Cuturi M, Doucet A (2014).
&ldquo;Fast computation of wasserstein barycenters.&rdquo;
In Xing EP, Jebara T (eds.), <em>Proceedings of the 31st international conference on international conference on machine learning - volume 32</em>, volume 32 of <em>Proceedings of machine learning research</em>, 685&ndash;693.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------
#     Wasserstein Barycenter for Fixed Atoms with Two Gaussians
#
# * class 1 : samples from Gaussian with mean=(-4, -4)
# * class 2 : samples from Gaussian with mean=(+4, +4)
# * target support consists of 7 integer points from -6 to 6,
#   where ideally, weight is concentrated near 0 since it's average!
#-------------------------------------------------------------------
## GENERATE DATA
#  Empirical Measures
set.seed(100)
ndat = 100
dat1 = matrix(rnorm(ndat*2, mean=-4, sd=0.5),ncol=2)
dat2 = matrix(rnorm(ndat*2, mean=+4, sd=0.5),ncol=2) 

myatoms = list()
myatoms[[1]] = dat1
myatoms[[2]] = dat2
mydata = rbind(dat1, dat2)

#  Fixed Support
support = cbind(seq(from=-8,to=8,by=2),
                seq(from=-8,to=8,by=2))
## COMPUTE
comp1 = bary14C(support, myatoms, lambda=0.5, maxiter=10)
comp2 = bary14C(support, myatoms, lambda=1,   maxiter=10)
comp3 = bary14C(support, myatoms, lambda=5,   maxiter=10)

## VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
barplot(comp1, main="lambda=0.5")
barplot(comp2, main="lambda=1")
barplot(comp3, main="lambda=5")
par(opar)

</code></pre>

<hr>
<h2 id='bary15B'>Barycenter by Benamou et al. (2015)</h2><span id='topic+bary15B'></span><span id='topic+bary15Bdist'></span>

<h3>Description</h3>

<p>Given <code class="reqn">K</code> empirical measures <code class="reqn">\mu_1, \mu_2, \ldots, \mu_K</code> of possibly different cardinalities,
wasserstein barycenter <code class="reqn">\mu^*</code> is the solution to the following problem
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k=1}^K \pi_k \mathcal{W}_p^p (\mu, \mu_k)</code>
</p>

<p>where <code class="reqn">\pi_k</code>'s are relative weights of empirical measures. Here we assume
either (1) support atoms in Euclidean space are given, or (2) all pairwise distances between
atoms of the fixed support and empirical measures are given.
Authors proposed iterative Bregman projections in conjunction with entropic regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary15B(
  support,
  atoms,
  marginals = NULL,
  weights = NULL,
  lambda = 0.1,
  p = 2,
  ...
)

bary15Bdist(
  distances,
  marginals = NULL,
  weights = NULL,
  lambda = 0.1,
  p = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bary15B_+3A_support">support</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of rows being atoms for the fixed support.</p>
</td></tr>
<tr><td><code id="bary15B_+3A_atoms">atoms</code></td>
<td>
<p>a length-<code class="reqn">K</code> list where each element is an <code class="reqn">(N_k \times P)</code> matrix of atoms.</p>
</td></tr>
<tr><td><code id="bary15B_+3A_marginals">marginals</code></td>
<td>
<p>marginal distribution for empirical measures; if <code>NULL</code> (default), uniform weights are set for all measures. Otherwise, it should be a length-<code class="reqn">K</code> list where each element is a length-<code class="reqn">N_i</code> vector of nonnegative weights that sum to 1.</p>
</td></tr>
<tr><td><code id="bary15B_+3A_weights">weights</code></td>
<td>
<p>weights for each individual measure; if <code>NULL</code> (default), each measure is considered equally. Otherwise, it should be a length-<code class="reqn">K</code> vector.</p>
</td></tr>
<tr><td><code id="bary15B_+3A_lambda">lambda</code></td>
<td>
<p>regularization parameter (default: 0.1).</p>
</td></tr>
<tr><td><code id="bary15B_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="bary15B_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
<dt>init.vec</dt><dd><p>an initial vector (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: FALSE).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bary15B_+3A_distances">distances</code></td>
<td>
<p>a length-<code class="reqn">K</code> list where each element is an <code class="reqn">(N\times N_k)</code> pairwise distance between atoms of the fixed support and given measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-<code class="reqn">N</code> vector of probability vector.
</p>


<h3>References</h3>

<p>Benamou J, Carlier G, Cuturi M, Nenna L, Peyré G (2015).
&ldquo;Iterative Bregman Projections for Regularized Transportation Problems.&rdquo;
<em>SIAM Journal on Scientific Computing</em>, <b>37</b>(2), A1111&ndash;A1138.
ISSN 1064-8275, 1095-7197.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------
#     Wasserstein Barycenter for Fixed Atoms with Two Gaussians
#
# * class 1 : samples from Gaussian with mean=(-4, -4)
# * class 2 : samples from Gaussian with mean=(+4, +4)
# * target support consists of 7 integer points from -6 to 6,
#   where ideally, weight is concentrated near 0 since it's average!
#-------------------------------------------------------------------
## GENERATE DATA
#  Empirical Measures
set.seed(100)
ndat = 500
dat1 = matrix(rnorm(ndat*2, mean=-4, sd=0.5),ncol=2)
dat2 = matrix(rnorm(ndat*2, mean=+4, sd=0.5),ncol=2) 

myatoms = list()
myatoms[[1]] = dat1
myatoms[[2]] = dat2
mydata = rbind(dat1, dat2)

#  Fixed Support
support = cbind(seq(from=-8,to=8,by=2),
                seq(from=-8,to=8,by=2))
## COMPUTE
comp1 = bary15B(support, myatoms, lambda=0.5, maxiter=10)
comp2 = bary15B(support, myatoms, lambda=1,   maxiter=10)
comp3 = bary15B(support, myatoms, lambda=5,   maxiter=10)

## VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
barplot(comp1, main="lambda=0.5")
barplot(comp2, main="lambda=1")
barplot(comp3, main="lambda=5")
par(opar)

</code></pre>

<hr>
<h2 id='digit3'>MNIST Images of Digit 3</h2><span id='topic+digit3'></span>

<h3>Description</h3>

<p><code>digit3</code> contains 2000 images from the famous MNIST dataset of digit 3.
Each element of the list is an image represented as an <code class="reqn">(28\times 28)</code>
matrix that sums to 1. This normalization is conventional and it does not
hurt its visualization via a basic <code>image()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(digit3)
</code></pre>


<h3>Format</h3>

<p>a length-<code class="reqn">2000</code> named list <code>"digit3"</code> of <code class="reqn">(28\times 28)</code> matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## LOAD THE DATA
data(digit3)

## SHOW A FEW
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,4), pty="s")
for (i in 1:8){
  image(digit3[[i]])
}
par(opar)

</code></pre>

<hr>
<h2 id='digits'>MNIST Images of All Digits</h2><span id='topic+digits'></span>

<h3>Description</h3>

<p><code>digits</code> contains 5000 images from the famous MNIST dataset of all digits,
consisting of 500 images per digit class from 0 to 9.
Each digit image is represented as an <code class="reqn">(28\times 28)</code>
matrix that sums to 1. This normalization is conventional and it does not
hurt its visualization via a basic <code>image()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(digits)
</code></pre>


<h3>Format</h3>

<p>a named list <code>"digits"</code> containing </p>

<dl>
<dt>image</dt><dd><p>length-5000 list of <code class="reqn">(28\times 28)</code> image matrices.</p>
</dd>
<dt>label</dt><dd><p>length-5000 vector of class labels from 0 to 9.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## LOAD THE DATA
data(digits)

## SHOW A FEW
#  Select 9 random images
subimgs = digits$image[sample(1:5000, 9)]

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(3,3), pty="s")
for (i in 1:9){
  image(subimgs[[i]])
}
par(opar)

</code></pre>

<hr>
<h2 id='ecdfbary'>Barycenter of Empirical CDFs</h2><span id='topic+ecdfbary'></span>

<h3>Description</h3>

<p>Given a collection of empirical cumulative distribution functions
<code class="reqn">F^i (x)</code> for <code class="reqn">i=1,\ldots,N</code>, compute the Wasserstein barycenter
of order 2. This is obtained by taking a weighted average on a set of
corresponding quantile functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfbary(ecdfs, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfbary_+3A_ecdfs">ecdfs</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of <code>"ecdf"</code> objects by <code><a href="stats.html#topic+ecdf">stats::ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="ecdfbary_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="ecdfbary_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>"ecdf"</code> object of the Wasserstein barycenter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------------------------------------------
#                         Two Gaussians
#
# Two Gaussian distributions are parametrized as follows.
# Type 1 : (mean, var) = (-4, 1/4)
# Type 2 : (mean, var) = (+4, 1/4)
#----------------------------------------------------------------------
# GENERATE ECDFs
ecdf_list = list()
ecdf_list[[1]] = stats::ecdf(stats::rnorm(200, mean=-4, sd=0.5))
ecdf_list[[2]] = stats::ecdf(stats::rnorm(200, mean=+4, sd=0.5))

# COMPUTE THE BARYCENTER OF EQUAL WEIGHTS
emean = ecdfbary(ecdf_list)

# QUANTITIES FOR PLOTTING
x_grid  = seq(from=-8, to=8, length.out=100)
y_type1 = ecdf_list[[1]](x_grid)
y_type2 = ecdf_list[[2]](x_grid)
y_bary  = emean(x_grid)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(x_grid, y_bary, lwd=3, col="red", type="l",
     main="Barycenter", xlab="x", ylab="Fn(x)")
lines(x_grid, y_type1, col="gray50", lty=3)
lines(x_grid, y_type2, col="gray50", lty=3)
par(opar)

</code></pre>

<hr>
<h2 id='ecdfmed'>Wasserstein Median of Empirical CDFs</h2><span id='topic+ecdfmed'></span>

<h3>Description</h3>

<p>Given a collection of empirical cumulative distribution functions
<code class="reqn">F^i (x)</code> for <code class="reqn">i=1,\ldots,N</code>, compute the Wasserstein median. This is
obtained by a functional variant of the Weiszfeld algorithm on a set of
quantile functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfmed(ecdfs, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfmed_+3A_ecdfs">ecdfs</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of <code>"ecdf"</code> objects by <code><a href="stats.html#topic+ecdf">stats::ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="ecdfmed_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="ecdfmed_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>"ecdf"</code> object of the Wasserstein median.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                         Tree Gaussians
#
# Three Gaussian distributions are parametrized as follows.
# Type 1 : (mean, sd) = (-4, 1)
# Type 2 : (mean, sd) = ( 0, 1/5)
# Type 3 : (mean, sd) = (+6, 1/2)
#----------------------------------------------------------------------
# GENERATE ECDFs
ecdf_list = list()
ecdf_list[[1]] = stats::ecdf(stats::rnorm(200, mean=-4, sd=1))
ecdf_list[[2]] = stats::ecdf(stats::rnorm(200, mean=+4, sd=0.2))
ecdf_list[[3]] = stats::ecdf(stats::rnorm(200, mean=+6, sd=0.5))

# COMPUTE THE MEDIAN
emeds = ecdfmed(ecdf_list)

# COMPUTE THE BARYCENTER
emean = ecdfbary(ecdf_list)

# QUANTITIES FOR PLOTTING
x_grid  = seq(from=-8, to=10, length.out=500)
y_type1 = ecdf_list[[1]](x_grid)
y_type2 = ecdf_list[[2]](x_grid)
y_type3 = ecdf_list[[3]](x_grid)

y_bary = emean(x_grid)
y_meds = emeds(x_grid)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(x_grid, y_bary, lwd=3, col="orange", type="l",
     main="Wasserstein Median &amp; Barycenter", 
     xlab="x", ylab="Fn(x)", lty=2)
lines(x_grid, y_meds, lwd=3, col="blue", lty=2)
lines(x_grid, y_type1, col="gray50", lty=3)
lines(x_grid, y_type2, col="gray50", lty=3)
lines(x_grid, y_type3, col="gray50", lty=3)
legend("topleft", legend=c("Median","Barycenter"),
        lwd=3, lty=2, col=c("blue","orange"))
par(opar)


</code></pre>

<hr>
<h2 id='gaussbary1d'>Barycenter of Gaussian Distributions in <code class="reqn">\mathbf{R}</code></h2><span id='topic+gaussbary1d'></span>

<h3>Description</h3>

<p>Given a collection of Gaussian distributions <code class="reqn">\mathcal{N}(\mu_i, \sigma_i^2)</code> for <code class="reqn">i=1,\ldots,n</code>,
compute the Wasserstein barycenter of order 2. For the barycenter computation of
variance components, we use a fixed-point algorithm by Álvarez-Esteban et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussbary1d(means, vars, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussbary1d_+3A_means">means</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector of mean parameters.</p>
</td></tr>
<tr><td><code id="gaussbary1d_+3A_vars">vars</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector of variance parameters.</p>
</td></tr>
<tr><td><code id="gaussbary1d_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">n</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="gaussbary1d_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>mean</dt><dd><p>mean of the estimated barycenter distribution.</p>
</dd>
<dt>var</dt><dd><p>variance of the estimated barycenter distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Álvarez-Esteban PC, del Barrio E, Cuesta-Albertos JA, Matrán C (2016).
&ldquo;A Fixed-Point Approach to Barycenters in Wasserstein Space.&rdquo;
<em>Journal of Mathematical Analysis and Applications</em>, <b>441</b>(2), 744&ndash;762.
ISSN 0022247X.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussbarypd">gaussbarypd()</a></code> for multivariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------------------------------------------
#                         Two Gaussians
#
# Two Gaussian distributions are parametrized as follows.
# Type 1 : (mean, var) = (-4, 1/4)
# Type 2 : (mean, var) = (+4, 1/4)
#----------------------------------------------------------------------
# GENERATE PARAMETERS
par_mean = c(-4, 4)
par_vars = c(0.25, 0.25)

# COMPUTE THE BARYCENTER OF EQUAL WEIGHTS
gmean = gaussbary1d(par_mean, par_vars)

# QUANTITIES FOR PLOTTING
x_grid  = seq(from=-6, to=6, length.out=200)
y_dist1 = stats::dnorm(x_grid, mean=-4, sd=0.5)
y_dist2 = stats::dnorm(x_grid, mean=+4, sd=0.5)
y_gmean = stats::dnorm(x_grid, mean=gmean$mean, sd=sqrt(gmean$var)) 

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(x_grid, y_gmean, lwd=2, col="red", type="l",
     main="Barycenter", xlab="x", ylab="density")
lines(x_grid, y_dist1)
lines(x_grid, y_dist2)
par(opar)

</code></pre>

<hr>
<h2 id='gaussbarypd'>Barycenter of Gaussian Distributions in <code class="reqn">\mathbf{R}^p</code></h2><span id='topic+gaussbarypd'></span>

<h3>Description</h3>

<p>Given a collection of <code class="reqn">n</code>-dimensional Gaussian distributions <code class="reqn">\mathcal{N}(\mu_i, \Sigma_i^2)</code>
for <code class="reqn">i=1,\ldots,n</code>, compute the Wasserstein barycenter of order 2.
For the barycenter computation of variance components, we use a fixed-point
algorithm by Álvarez-Esteban et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussbarypd(means, vars, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussbarypd_+3A_means">means</code></td>
<td>
<p>an <code class="reqn">(n\times p)</code> matrix whose rows are mean vectors.</p>
</td></tr>
<tr><td><code id="gaussbarypd_+3A_vars">vars</code></td>
<td>
<p>a <code class="reqn">(p\times p\times n)</code> array where each slice is covariance matrix.</p>
</td></tr>
<tr><td><code id="gaussbarypd_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">n</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="gaussbarypd_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>mean</dt><dd><p>a length-<code class="reqn">p</code> vector for mean of the estimated barycenter distribution.</p>
</dd>
<dt>var</dt><dd><p>a <code class="reqn">(p\times p)</code> matrix for variance of the estimated barycenter distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Álvarez-Esteban PC, del Barrio E, Cuesta-Albertos JA, Matrán C (2016).
&ldquo;A Fixed-Point Approach to Barycenters in Wasserstein Space.&rdquo;
<em>Journal of Mathematical Analysis and Applications</em>, <b>441</b>(2), 744&ndash;762.
ISSN 0022247X.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussbary1d">gaussbary1d()</a></code> for univariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                         Two Gaussians in R^2
#----------------------------------------------------------------------
# GENERATE PARAMETERS
# means
par_mean = rbind(c(-4,0), c(4,0))

# covariances
par_vars = array(0,c(2,2,2))
par_vars[,,1] = cbind(c(4,-2),c(-2,4))
par_vars[,,2] = cbind(c(4,+2),c(+2,4))

# COMPUTE THE BARYCENTER OF EQUAL WEIGHTS
gmean = gaussbarypd(par_mean, par_vars)

# GET COORDINATES FOR DRAWING
pt_type1 = gaussvis2d(par_mean[1,], par_vars[,,1])
pt_type2 = gaussvis2d(par_mean[2,], par_vars[,,2])
pt_gmean = gaussvis2d(gmean$mean, gmean$var)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(pt_gmean, lwd=2, col="red", type="l",
     main="Barycenter", xlab="", ylab="", 
     xlim=c(-6,6))
lines(pt_type1)
lines(pt_type2)
par(opar)


</code></pre>

<hr>
<h2 id='gaussmed1d'>Wasserstein Median of Gaussian Distributions in <code class="reqn">\mathbf{R}</code></h2><span id='topic+gaussmed1d'></span>

<h3>Description</h3>

<p>Given a collection of Gaussian distributions <code class="reqn">\mathcal{N}(\mu_i, \sigma_i^2)</code> for <code class="reqn">i=1,\ldots,n</code>,
compute the Wasserstein median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussmed1d(means, vars, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussmed1d_+3A_means">means</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector of mean parameters.</p>
</td></tr>
<tr><td><code id="gaussmed1d_+3A_vars">vars</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector of variance parameters.</p>
</td></tr>
<tr><td><code id="gaussmed1d_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">n</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="gaussmed1d_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>mean</dt><dd><p>mean of the estimated median distribution.</p>
</dd>
<dt>var</dt><dd><p>variance of the estimated median distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+gaussmedpd">gaussmedpd()</a></code> for multivariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                         Tree Gaussians
#
# Three Gaussian distributions are parametrized as follows.
# Type 1 : (mean, sd) = (-4, 1)
# Type 2 : (mean, sd) = ( 0, 1/5)
# Type 3 : (mean, sd) = (+6, 1/2)
#----------------------------------------------------------------------
# GENERATE PARAMETERS
par_mean = c(-4, 0, +6)
par_vars = c(1, 0.04, 0.25)

# COMPUTE THE WASSERSTEIN MEDIAN
gmeds = gaussmed1d(par_mean, par_vars)

# COMPUTE THE BARYCENTER 
gmean = gaussbary1d(par_mean, par_vars)

# QUANTITIES FOR PLOTTING
x_grid  = seq(from=-6, to=8, length.out=1000)
y_dist1 = stats::dnorm(x_grid, mean=par_mean[1], sd=sqrt(par_vars[1]))
y_dist2 = stats::dnorm(x_grid, mean=par_mean[2], sd=sqrt(par_vars[2]))
y_dist3 = stats::dnorm(x_grid, mean=par_mean[3], sd=sqrt(par_vars[3]))

y_gmean = stats::dnorm(x_grid, mean=gmean$mean, sd=sqrt(gmean$var)) 
y_gmeds = stats::dnorm(x_grid, mean=gmeds$mean, sd=sqrt(gmeds$var))

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(x_grid, y_gmeds, lwd=3, col="red", type="l",
     main="Three Gaussians", xlab="x", ylab="density", 
     xlim=range(x_grid), ylim=c(0,2.5))
lines(x_grid, y_gmean, lwd=3, col="blue")
lines(x_grid, y_dist1, lwd=1.5, lty=2)
lines(x_grid, y_dist2, lwd=1.5, lty=2)
lines(x_grid, y_dist3, lwd=1.5, lty=2)
legend("topleft", legend=c("Median","Barycenter"),
       col=c("red","blue"), lwd=c(3,3), lty=c(1,2))
par(opar)


</code></pre>

<hr>
<h2 id='gaussmedpd'>Wasserstein Median of Gaussian Distributions in <code class="reqn">\mathbf{R}^p</code></h2><span id='topic+gaussmedpd'></span>

<h3>Description</h3>

<p>Given a collection of <code class="reqn">p</code>-dimensional Gaussian distributions <code class="reqn">\mathcal{N}(\mu_i, \sigma_i^2)</code> for <code class="reqn">i=1,\ldots,n</code>,
compute the Wasserstein median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussmedpd(means, vars, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussmedpd_+3A_means">means</code></td>
<td>
<p>an <code class="reqn">(n\times p)</code> matrix whose rows are mean vectors.</p>
</td></tr>
<tr><td><code id="gaussmedpd_+3A_vars">vars</code></td>
<td>
<p>a <code class="reqn">(p\times p\times n)</code> array where each slice is covariance matrix.</p>
</td></tr>
<tr><td><code id="gaussmedpd_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise, it should be a length-<code class="reqn">n</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="gaussmedpd_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>mean</dt><dd><p>a length-<code class="reqn">p</code> vector for mean of the estimated median distribution.</p>
</dd>
<dt>var</dt><dd><p>a <code class="reqn">(p\times p)</code> matrix for variance of the estimated median distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+gaussmed1d">gaussmed1d()</a></code> for univariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                         Three Gaussians in R^2
#----------------------------------------------------------------------
# GENERATE PARAMETERS
# means
par_mean = rbind(c(-4,0), c(0,0), c(5,-1))

# covariances
par_vars = array(0,c(2,2,3))
par_vars[,,1] = cbind(c(2,-1),c(-1,2))
par_vars[,,2] = cbind(c(4,+1),c(+1,4))
par_vars[,,3] = diag(c(4,1))

# COMPUTE THE MEDIAN
gmeds = gaussmedpd(par_mean, par_vars)

# COMPUTE THE BARYCENTER 
gmean = gaussbarypd(par_mean, par_vars)

# GET COORDINATES FOR DRAWING
pt_type1 = gaussvis2d(par_mean[1,], par_vars[,,1])
pt_type2 = gaussvis2d(par_mean[2,], par_vars[,,2])
pt_type3 = gaussvis2d(par_mean[3,], par_vars[,,3])
pt_gmean = gaussvis2d(gmean$mean, gmean$var)
pt_gmeds = gaussvis2d(gmeds$mean, gmeds$var)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(pt_gmean, lwd=2, col="red", type="l",
     main="Three Gaussians", xlab="", ylab="", 
     xlim=c(-6,8), ylim=c(-2.5,2.5))
lines(pt_gmeds, lwd=2, col="blue")
lines(pt_type1, lty=2, lwd=5)
lines(pt_type2, lty=2, lwd=5)
lines(pt_type3, lty=2, lwd=5)
abline(h=0, col="grey80", lty=3)
abline(v=0, col="grey80", lty=3)
legend("topright", legend=c("Median","Barycenter"),
       lwd=2, lty=1, col=c("blue","red"))
par(opar)


</code></pre>

<hr>
<h2 id='gaussvis2d'>Sampling from a Bivariate Gaussian Distribution for Visualization</h2><span id='topic+gaussvis2d'></span>

<h3>Description</h3>

<p>This function samples points along the contour of an ellipse represented
by mean and variance parameters for a 2-dimensional Gaussian distribution
to help ease manipulating visualization of the specified distribution. For example,
you can directly use a basic <code>plot()</code> function directly for drawing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussvis2d(mean, var, n = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussvis2d_+3A_mean">mean</code></td>
<td>
<p>a length-<code class="reqn">2</code> vector for mean parameter.</p>
</td></tr>
<tr><td><code id="gaussvis2d_+3A_var">var</code></td>
<td>
<p>a <code class="reqn">(2\times 2)</code> matrix for covariance parameter.</p>
</td></tr>
<tr><td><code id="gaussvis2d_+3A_n">n</code></td>
<td>
<p>the number of points to be drawn (default: 500).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(n\times 2)</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                        Three Gaussians in R^2
#----------------------------------------------------------------------
# MEAN PARAMETERS
loc1 = c(-3,0)
loc2 = c(0,5)
loc3 = c(3,0)

# COVARIANCE PARAMETERS
var1 = cbind(c(4,-2),c(-2,4))
var2 = diag(c(9,1))
var3 = cbind(c(4,2),c(2,4))

# GENERATE POINTS
visA = gaussvis2d(loc1, var1)
visB = gaussvis2d(loc2, var2)
visC = gaussvis2d(loc3, var3)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
plot(visA[,1], visA[,2], type="l", xlim=c(-5,5), ylim=c(-2,9),
     lwd=3, col="red", main="3 Gaussian Distributions")
lines(visB[,1], visB[,2], lwd=3, col="blue")
lines(visC[,1], visC[,2], lwd=3, col="orange")
legend("top", legend=c("Type 1","Type 2","Type 3"),
       lwd=3, col=c("red","blue","orange"), horiz=TRUE)
par(opar)


</code></pre>

<hr>
<h2 id='histbary14C'>Barycenter of Histograms by Cuturi &amp; Doucet (2014)</h2><span id='topic+histbary14C'></span>

<h3>Description</h3>

<p>Given multiple histograms represented as <code>"histogram"</code> S3 objects, compute
Wasserstein barycenter. We need one requirement that all histograms in an
input list <code>hists</code> must have <b>same breaks</b>. See the example on how to
construct a histogram on predefined breaks/bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histbary14C(hists, p = 2, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histbary14C_+3A_hists">hists</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of histograms (<code>"histogram"</code> object) of same breaks.</p>
</td></tr>
<tr><td><code id="histbary14C_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="histbary14C_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="histbary14C_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="histbary14C_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.vec</dt><dd><p>an initial weight vector (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>"histogram"</code> object of barycenter.
</p>


<h3>References</h3>

<p>Cuturi M, Doucet A (2014).
&ldquo;Fast computation of wasserstein barycenters.&rdquo;
In Xing EP, Jebara T (eds.), <em>Proceedings of the 31st international conference on international conference on machine learning - volume 32</em>, volume 32 of <em>Proceedings of machine learning research</em>, 685&ndash;693.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bary14C">bary14C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                      Binned from Two Gaussians
#
# EXAMPLE : Very Small Example for CRAN; just showing how to use it!
#----------------------------------------------------------------------
# GENERATE FROM TWO GAUSSIANS WITH DIFFERENT MEANS
set.seed(100)
x  = stats::rnorm(1000, mean=-4, sd=0.5)
y  = stats::rnorm(1000, mean=+4, sd=0.5)
bk = seq(from=-10, to=10, length.out=20)

# HISTOGRAMS WITH COMMON BREAKS
histxy = list()
histxy[[1]] = hist(x, breaks=bk, plot=FALSE)
histxy[[2]] = hist(y, breaks=bk, plot=FALSE)

# COMPUTE
hh = histbary14C(histxy, maxiter=5)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2))
barplot(histxy[[1]]$density, col=rgb(0,0,1,1/4), 
        ylim=c(0, 0.75), main="Two Histograms")
barplot(histxy[[2]]$density, col=rgb(1,0,0,1/4), 
        ylim=c(0, 0.75), add=TRUE)
barplot(hh$density, main="Barycenter",
        ylim=c(0, 0.75))
par(opar)


</code></pre>

<hr>
<h2 id='histbary15B'>Barycenter of Histograms by Benamou et al. (2015)</h2><span id='topic+histbary15B'></span>

<h3>Description</h3>

<p>Given multiple histograms represented as <code>"histogram"</code> S3 objects, compute
Wasserstein barycenter. We need one requirement that all histograms in an
input list <code>hists</code> must have <b>same breaks</b>. See the example on how to
construct a histogram on predefined breaks/bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histbary15B(hists, p = 2, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histbary15B_+3A_hists">hists</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of histograms (<code>"histogram"</code> object) of same breaks.</p>
</td></tr>
<tr><td><code id="histbary15B_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="histbary15B_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="histbary15B_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="histbary15B_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.vec</dt><dd><p>an initial weight vector (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>"histogram"</code> object of barycenter.
</p>


<h3>References</h3>

<p>Benamou J, Carlier G, Cuturi M, Nenna L, Peyré G (2015).
&ldquo;Iterative Bregman Projections for Regularized Transportation Problems.&rdquo;
<em>SIAM Journal on Scientific Computing</em>, <b>37</b>(2), A1111&ndash;A1138.
ISSN 1064-8275, 1095-7197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bary15B">bary15B</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------------------------------------------
#                      Binned from Two Gaussians
#
# EXAMPLE : Very Small Example for CRAN; just showing how to use it!
#----------------------------------------------------------------------
# GENERATE FROM TWO GAUSSIANS WITH DIFFERENT MEANS
set.seed(100)
x  = stats::rnorm(1000, mean=-4, sd=0.5)
y  = stats::rnorm(1000, mean=+4, sd=0.5)
bk = seq(from=-10, to=10, length.out=20)

# HISTOGRAMS WITH COMMON BREAKS
histxy = list()
histxy[[1]] = hist(x, breaks=bk, plot=FALSE)
histxy[[2]] = hist(y, breaks=bk, plot=FALSE)

# COMPUTE
hh = histbary15B(histxy, maxiter=5)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2))
barplot(histxy[[1]]$density, col=rgb(0,0,1,1/4), 
        ylim=c(0, 0.75), main="Two Histograms")
barplot(histxy[[2]]$density, col=rgb(1,0,0,1/4), 
        ylim=c(0, 0.75), add=TRUE)
barplot(hh$density, main="Barycenter",
        ylim=c(0, 0.75))
par(opar)

</code></pre>

<hr>
<h2 id='histmed22Y'>Wasserstein Median of Histograms by You et al. (2022)</h2><span id='topic+histmed22Y'></span>

<h3>Description</h3>

<p>Given multiple histograms represented as <code>"histogram"</code> S3 objects, compute the
Wasserstein median of order 2. We need one requirement that all histograms in an
input list <code>hists</code> must have <b>same breaks</b>. See the example on how to
construct a histogram on predefined breaks/bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histmed22Y(hists, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histmed22Y_+3A_hists">hists</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of histograms (<code>"histogram"</code> object) of same breaks.</p>
</td></tr>
<tr><td><code id="histmed22Y_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="histmed22Y_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="histmed22Y_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.vec</dt><dd><p>an initial weight vector (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>FALSE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>"histogram"</code> object of the Wasserstein median histogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------
#                      Binned from Two Gaussians
#
# EXAMPLE : small example for CRAN for visualization purpose.
#----------------------------------------------------------------------
# GENERATE FROM TWO GAUSSIANS WITH DIFFERENT MEANS
set.seed(100)
x  = stats::rnorm(1000, mean=-4, sd=0.5)
y  = stats::rnorm(1000, mean=+4, sd=0.5)
bk = seq(from=-10, to=10, length.out=20)

# HISTOGRAMS WITH COMMON BREAKS
histxy = list()
histxy[[1]] = hist(x, breaks=bk, plot=FALSE)
histxy[[2]] = hist(y, breaks=bk, plot=FALSE)

# COMPUTE
hmean = histbary15B(histxy)
hmeds = histmed22Y(histxy)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
barplot(histxy[[1]]$density, col=rgb(0,0,1,1/4), 
        ylim=c(0, 1.05), main="Two Histograms")
barplot(histxy[[2]]$density, col=rgb(1,0,0,1/4), 
        ylim=c(0, 1.05), add=TRUE)
barplot(hmean$density, main="Barycenter",
        ylim=c(0, 1.05))
barplot(hmeds$density, main="Wasserstein Median",
        ylim=c(0, 1.05))
par(opar)


</code></pre>

<hr>
<h2 id='imagebary14C'>Barycenter of Images according to Cuturi &amp; Doucet (2014)</h2><span id='topic+imagebary14C'></span>

<h3>Description</h3>

<p>Using entropic regularization for Wasserstein barycenter computation, <code>imagebary14C</code>
finds a <em>barycentric</em> image <code class="reqn">X^*</code> given multiple images <code class="reqn">X_1,X_2,\ldots,X_N</code>.
Please note the followings; (1) we only take a matrix as an image so please
make it grayscale if not, (2) all images should be of same size - no resizing is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagebary14C(images, p = 2, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imagebary14C_+3A_images">images</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of same-size image matrices of size <code class="reqn">(m\times n)</code>.</p>
</td></tr>
<tr><td><code id="imagebary14C_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="imagebary14C_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="imagebary14C_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="imagebary14C_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.image</dt><dd><p>an initial weight image (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(m\times n)</code> matrix of the barycentric image.
</p>


<h3>References</h3>

<p>Cuturi M, Doucet A (2014).
&ldquo;Fast computation of wasserstein barycenters.&rdquo;
In Xing EP, Jebara T (eds.), <em>Proceedings of the 31st international conference on international conference on machine learning - volume 32</em>, volume 32 of <em>Proceedings of machine learning research</em>, 685&ndash;693.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bary14C">bary14C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#----------------------------------------------------------------------
#                       MNIST Data with Digit 3
#
# EXAMPLE 1 : Very Small  Example for CRAN; just showing how to use it!
# EXAMPLE 2 : Medium-size Example for Evolution of Output
#----------------------------------------------------------------------
# EXAMPLE 1
data(digit3)
datsmall = digit3[1:2]
outsmall = imagebary14C(datsmall, maxiter=3)

# EXAMPLE 2 : Barycenter of 100 Images
# RANDOMLY SELECT THE IMAGES
data(digit3)
dat2 = digit3[sample(1:2000, 100)]  # select 100 images

# RUN SEQUENTIALLY
run10 = imagebary14C(dat2, maxiter=10)                   # first 10 iterations
run20 = imagebary14C(dat2, maxiter=10, init.image=run10) # run 40 more
run50 = imagebary14C(dat2, maxiter=30, init.image=run20) # run 50 more

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(run10, axes=FALSE, main="barycenter after 10 iter")
image(run20, axes=FALSE, main="barycenter after 20 iter")
image(run50, axes=FALSE, main="barycenter after 50 iter")
par(opar)

## End(Not run)

</code></pre>

<hr>
<h2 id='imagebary15B'>Barycenter of Images according to Benamou et al. (2015)</h2><span id='topic+imagebary15B'></span>

<h3>Description</h3>

<p>Using entropic regularization for Wasserstein barycenter computation, <code>imagebary15B</code>
finds a <em>barycentric</em> image <code class="reqn">X^*</code> given multiple images <code class="reqn">X_1,X_2,\ldots,X_N</code>.
Please note the followings; (1) we only take a matrix as an image so please
make it grayscale if not, (2) all images should be of same size - no resizing is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagebary15B(images, p = 2, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imagebary15B_+3A_images">images</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of same-size image matrices of size <code class="reqn">(m\times n)</code>.</p>
</td></tr>
<tr><td><code id="imagebary15B_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="imagebary15B_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="imagebary15B_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="imagebary15B_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.image</dt><dd><p>an initial weight image (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(m\times n)</code> matrix of the barycentric image.
</p>


<h3>References</h3>

<p>Benamou J, Carlier G, Cuturi M, Nenna L, Peyré G (2015).
&ldquo;Iterative Bregman Projections for Regularized Transportation Problems.&rdquo;
<em>SIAM Journal on Scientific Computing</em>, <b>37</b>(2), A1111&ndash;A1138.
ISSN 1064-8275, 1095-7197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bary15B">bary15B</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#----------------------------------------------------------------------
#                       MNIST Data with Digit 3
#
# EXAMPLE 1 : Very Small  Example for CRAN; just showing how to use it!
# EXAMPLE 2 : Medium-size Example for Evolution of Output
#----------------------------------------------------------------------
# EXAMPLE 1
data(digit3)
datsmall = digit3[1:2]
outsmall = imagebary15B(datsmall, maxiter=3)

## Not run: 
# EXAMPLE 2 : Barycenter of 100 Images
# RANDOMLY SELECT THE IMAGES
data(digit3)
dat2 = digit3[sample(1:2000, 100)]  # select 100 images

# RUN SEQUENTIALLY
run05 = imagebary15B(dat2, maxiter=5)                    # first 5 iterations
run10 = imagebary15B(dat2, maxiter=5,  init.image=run05) # run 5 more
run50 = imagebary15B(dat2, maxiter=40, init.image=run10) # run 40 more

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(dat2[[sample(100,1)]], axes=FALSE, main="a random image")
image(run05, axes=FALSE, main="barycenter after 05 iter")
image(run10, axes=FALSE, main="barycenter after 10 iter")
image(run50, axes=FALSE, main="barycenter after 50 iter")
par(opar)

## End(Not run)

</code></pre>

<hr>
<h2 id='imagemed22Y'>Wasserstein Median of Images by You et al. (2022)</h2><span id='topic+imagemed22Y'></span>

<h3>Description</h3>

<p>Given multiple images <code class="reqn">X_1,\ldots,X_N</code>, the Wasserstein median of
order 2 is computed. The proposed method relies on a choice of barycenter computation
in that we opt for an algorithm of <code><a href="#topic+imagebary15B">imagebary15B</a></code>, which uses
entropic regularization for barycenter computation. Please note the followings; (1) we only take a matrix as an image so please
make it grayscale if not, (2) all images should be of same size - no resizing is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagemed22Y(images, weights = NULL, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imagemed22Y_+3A_images">images</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of same-size image matrices of size <code class="reqn">(m\times n)</code>.</p>
</td></tr>
<tr><td><code id="imagemed22Y_+3A_weights">weights</code></td>
<td>
<p>a weight of each image; if <code>NULL</code> (default), uniform weight is set. Otherwise,
it should be a length-<code class="reqn">N</code> vector of nonnegative weights.</p>
</td></tr>
<tr><td><code id="imagemed22Y_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter; if <code>NULL</code> (default), a paper's suggestion
would be taken, or it should be a nonnegative real number.</p>
</td></tr>
<tr><td><code id="imagemed22Y_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-8).</p>
</dd>
<dt>init.image</dt><dd><p>an initial weight image (default: uniform weight).</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>nthread</dt><dd><p>number of threads for OpenMP run (default: 1).</p>
</dd>
<dt>print.progress</dt><dd><p>a logical to show current iteration (default: <code>TRUE</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(m\times n)</code> matrix of the Wasserstein median image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#----------------------------------------------------------------------
#                       MNIST Data with Digit 3
#
# EXAMPLE : Very Small Example for CRAN; just showing how to use it!
#----------------------------------------------------------------------
# LOAD THE DATA
data(digit3)
datsmall = digit3[1:10]
 
# COMPUTE
outsmall = imagemed22Y(datsmall, maxiter=5)

# VISUALIZE
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
image(outsmall, xaxt='n', yaxt='n', main="Wasserstein Median")
image(datsmall[[3]], xaxt='n', yaxt='n', main="3rd image")
image(datsmall[[6]], xaxt='n', yaxt='n', main="6th image")
image(datsmall[[9]], xaxt='n', yaxt='n', main="9th image")
par(opar)

## End(Not run) 

</code></pre>

<hr>
<h2 id='ipot'>Wasserstein Distance by Inexact Proximal Point Method</h2><span id='topic+ipot'></span><span id='topic+ipotD'></span>

<h3>Description</h3>

<p>Due to high computational cost for linear programming approaches to compute
Wasserstein distance, Cuturi (2013) proposed an entropic regularization
scheme as an efficient approximation to the original problem. This comes with
a regularization parameter <code class="reqn">\lambda &gt; 0</code> in the term
</p>
<p style="text-align: center;"><code class="reqn">\lambda h(\Gamma) = \lambda \sum_{m,n} \Gamma_{m,n} \log (\Gamma_{m,n}).</code>
</p>

<p>IPOT algorithm is known to be relatively robust to the choice of
regularization parameter <code class="reqn">\lambda</code>. Empirical observation says that
very small number of inner loop iteration like <code>L=1</code> is sufficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipot(X, Y, p = 2, wx = NULL, wy = NULL, lambda = 1, ...)

ipotD(D, p = 2, wx = NULL, wy = NULL, lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipot_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="ipot_+3A_y">Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="ipot_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="ipot_+3A_wx">wx</code></td>
<td>
<p>a length-<code class="reqn">M</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="ipot_+3A_wy">wy</code></td>
<td>
<p>a length-<code class="reqn">N</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="ipot_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter (default: 0.1).</p>
</td></tr>
<tr><td><code id="ipot_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
<dt>L</dt><dd><p>small number of inner loop iterations (default: 1).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ipot_+3A_d">D</code></td>
<td>
<p>an <code class="reqn">(M\times N)</code> distance matrix <code class="reqn">d(x_m, y_n)</code> between two sets of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt><dd><p><code class="reqn">\mathcal{W}_p</code> distance value</p>
</dd>
<dt>iteration</dt><dd><p>the number of iterations it took to converge.</p>
</dd>
<dt>plan</dt><dd><p>an <code class="reqn">(M\times N)</code> nonnegative matrix for the optimal transport plan.</p>
</dd>
</dl>



<h3>References</h3>

<p>Xie Y, Wang X, Wang R, Zha H (2020).
&ldquo;A fast proximal point method for computing exact wasserstein distance.&rdquo;
In Adams RP, Gogate V (eds.), <em>Proceedings of The 35th Uncertainty in Artificial Intelligence Conference</em>, volume 115 of <em>Proceedings of machine learning research</em>, 433&ndash;453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------
#  Wasserstein Distance between Samples from Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
## SMALL EXAMPLE
set.seed(100)
m = 20
n = 30
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

## COMPARE WITH WASSERSTEIN 
outw = wasserstein(X, Y)
ipt1 = ipot(X, Y, lambda=1)
ipt2 = ipot(X, Y, lambda=10)

## VISUALIZE : SHOW THE PLAN AND DISTANCE
pmw = paste0("wasserstein plan ; dist=",round(outw$distance,2))
pm1 = paste0("ipot lbd=1 ; dist=",round(ipt1$distance,2))
pm2 = paste0("ipot lbd=10; dist=",round(ipt2$distance,2))

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(outw$plan, axes=FALSE, main=pmw)
image(ipt1$plan, axes=FALSE, main=pm1)
image(ipt2$plan, axes=FALSE, main=pm2)
par(opar)


</code></pre>

<hr>
<h2 id='sinkhorn'>Wasserstein Distance by Entropic Regularization</h2><span id='topic+sinkhorn'></span><span id='topic+sinkhornD'></span>

<h3>Description</h3>

<p>Due to high computational cost for linear programming approaches to compute
Wasserstein distance, Cuturi (2013) proposed an entropic regularization
scheme as an efficient approximation to the original problem. This comes with
a regularization parameter <code class="reqn">\lambda &gt; 0</code> in the term
</p>
<p style="text-align: center;"><code class="reqn">\lambda h(\Gamma) = \lambda \sum_{m,n} \Gamma_{m,n} \log (\Gamma_{m,n}).</code>
</p>

<p>As <code class="reqn">\lambda\rightarrow 0</code>,
the solution to an approximation problem approaches to the solution of a
true problem. However, we have an issue with numerical underflow. Our
implementation returns an error when it happens, so please use a larger number
when necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinkhorn(X, Y, p = 2, wx = NULL, wy = NULL, lambda = 0.1, ...)

sinkhornD(D, p = 2, wx = NULL, wy = NULL, lambda = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinkhorn_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_y">Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_wx">wx</code></td>
<td>
<p>a length-<code class="reqn">M</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_wy">wy</code></td>
<td>
<p>a length-<code class="reqn">N</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_lambda">lambda</code></td>
<td>
<p>a regularization parameter (default: 0.1).</p>
</td></tr>
<tr><td><code id="sinkhorn_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>maxiter</dt><dd><p>maximum number of iterations (default: 496).</p>
</dd>
<dt>abstol</dt><dd><p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sinkhorn_+3A_d">D</code></td>
<td>
<p>an <code class="reqn">(M\times N)</code> distance matrix <code class="reqn">d(x_m, y_n)</code> between two sets of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt><dd><p><code class="reqn">\mathcal{W}_p</code> distance value.</p>
</dd>
<dt>iteration</dt><dd><p>the number of iterations it took to converge.</p>
</dd>
<dt>plan</dt><dd><p>an <code class="reqn">(M\times N)</code> nonnegative matrix for the optimal transport plan.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cuturi M (2013).
&ldquo;Sinkhorn distances: Lightspeed computation of optimal transport.&rdquo;
In <em>Proceedings of the 26th international conference on neural information processing systems - volume 2</em>,  NIPS'13, 2292&ndash;2300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------
#  Wasserstein Distance between Samples from Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
## SMALL EXAMPLE
set.seed(100)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

## COMPARE WITH WASSERSTEIN 
outw = wasserstein(X, Y)
skh1 = sinkhorn(X, Y, lambda=0.05)
skh2 = sinkhorn(X, Y, lambda=0.10)

## VISUALIZE : SHOW THE PLAN AND DISTANCE
pm1 = paste0("wasserstein plan ; distance=",round(outw$distance,2))
pm2 = paste0("sinkhorn lbd=0.05; distance=",round(skh1$distance,2))
pm5 = paste0("sinkhorn lbd=0.1 ; distance=",round(skh2$distance,2))

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(outw$plan, axes=FALSE, main=pm1)
image(skh1$plan, axes=FALSE, main=pm2)
image(skh2$plan, axes=FALSE, main=pm5)
par(opar)


</code></pre>

<hr>
<h2 id='swdist'>Sliced Wasserstein Distance</h2><span id='topic+swdist'></span>

<h3>Description</h3>

<p>Sliced Wasserstein (SW) Distance (Rabin et al. 2012)
is a popular alternative to the standard Wasserstein distance due to its computational
efficiency on top of nice theoretical properties. For the <code class="reqn">d</code>-dimensional probability
measures <code class="reqn">\mu</code> and <code class="reqn">\nu</code>, the SW distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{SW}_p (\mu, \nu) = 
\left( \int_{\mathbf{S}^{d-1}} \mathcal{W}_p^p (
\langle \theta, \mu\rangle, \langle \theta, \nu \rangle d\lambda (\theta) \right)^{1/p},</code>
</p>

<p>where <code class="reqn">\mathbf{S}^{d-1}</code> is the <code class="reqn">(d-1)</code>-dimensional unit hypersphere and
<code class="reqn">\lambda</code> is the uniform distribution on <code class="reqn">\mathbf{S}^{d-1}</code>. Practically,
it is computed via Monte Carlo integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdist(X, Y, p = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdist_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="swdist_+3A_y">Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="swdist_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="swdist_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>nproj</dt><dd><p>the number of Monte Carlo samples for SW computation (default: 496).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt><dd><p><code class="reqn">\mathcal{SW}_p</code> distance value.</p>
</dd>
<dt>projdist</dt><dd><p>a length-<code>niter</code> vector of projected univariate distances.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rabin J, Peyré G, Delon J, Bernot M (2012).
&ldquo;Wasserstein Barycenter and Its Application to Texture Mixing.&rdquo;
In Bruckstein AM, ter Haar Romeny BM, Bronstein AM, Bronstein MM (eds.), <em>Scale Space and Variational Methods in Computer Vision</em>, volume 6667, 435&ndash;446.
Springer Berlin Heidelberg, Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------
#  Sliced-Wasserstein Distance between Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
# SMALL EXAMPLE
set.seed(100)
m = 20
n = 30
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

# COMPUTE THE SLICED-WASSERSTEIN DISTANCE
outsw &lt;- swdist(X, Y, nproj=100)

# VISUALIZE
# prepare ingredients for plotting
plot_x = 1:1000
plot_y = base::cumsum(outsw$projdist)/plot_x

# draw
opar &lt;- par(no.readonly=TRUE)
plot(plot_x, plot_y, type="b", cex=0.1, lwd=2,
     xlab="number of MC samples", ylab="distance",
     main="Effect of MC Sample Size")
abline(h=outsw$distance, col="red", lwd=2)
legend("bottomright", legend="SW Distance", 
       col="red", lwd=2)
par(opar)


</code></pre>

<hr>
<h2 id='wasserstein'>Wasserstein Distance between Empirical Measures</h2><span id='topic+wasserstein'></span><span id='topic+wassersteinD'></span>

<h3>Description</h3>

<p>Given two empirical measures <code class="reqn">\mu, \nu</code> consisting of <code class="reqn">M</code> and <code class="reqn">N</code> observations on <code class="reqn">\mathcal{X}</code>, <code class="reqn">p</code>-Wasserstein distance for <code class="reqn">p\geq 1</code> between two empirical measures
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{W}_p (\mu, \nu) = \left( \inf_{\gamma \in \Gamma(\mu, \nu)} \int_{\mathcal{X}\times \mathcal{X}} d(x,y)^p d \gamma(x,y) \right)^{1/p}</code>
</p>

<p>where <code class="reqn">\Gamma(\mu, \nu)</code> denotes the collection of all measures/couplings on <code class="reqn">\mathcal{X}\times \mathcal{X}</code>
whose marginals are <code class="reqn">\mu</code> and <code class="reqn">\nu</code> on the first and second factors, respectively. Please see the section
for detailed description on the usage of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(X, Y, p = 2, wx = NULL, wy = NULL)

wassersteinD(D, p = 2, wx = NULL, wy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_y">Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_wx">wx</code></td>
<td>
<p>a length-<code class="reqn">M</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_wy">wy</code></td>
<td>
<p>a length-<code class="reqn">N</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_d">D</code></td>
<td>
<p>an <code class="reqn">(M\times N)</code> distance matrix <code class="reqn">d(x_m, y_n)</code> between two sets of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt><dd><p><code class="reqn">\mathcal{W}_p</code> distance value.</p>
</dd>
<dt>plan</dt><dd><p>an <code class="reqn">(M\times N)</code> nonnegative matrix for the optimal transport plan.</p>
</dd>
</dl>



<h3>Using <code>wasserstein()</code> function</h3>

<p>We assume empirical measures are defined on the Euclidean space <code class="reqn">\mathcal{X}=\mathbf{R}^d</code>,
</p>
<p style="text-align: center;"><code class="reqn">\mu = \sum_{m=1}^M \mu_m \delta_{X_m}\quad\textrm{and}\quad \nu = \sum_{n=1}^N \nu_n \delta_{Y_n}</code>
</p>

<p>and the distance metric used here is standard Euclidean norm <code class="reqn">d(x,y) = \|x-y\|</code>. Here, the
marginals <code class="reqn">(\mu_1,\mu_2,\ldots,\mu_M)</code> and <code class="reqn">(\nu_1,\nu_2,\ldots,\nu_N)</code> correspond to
<code>wx</code> and <code>wy</code>, respectively.
</p>


<h3>Using <code>wassersteinD()</code> function</h3>

<p>If other distance measures or underlying spaces are one's interests, we have an option for users to provide
a distance matrix <code>D</code> rather than vectors, where
</p>
<p style="text-align: center;"><code class="reqn">D := D_{M\times N} = d(X_m, Y_n)</code>
</p>

<p>for flexible modeling.
</p>


<h3>References</h3>

<p>Peyré G, Cuturi M (2019).
&ldquo;Computational Optimal Transport: With Applications to Data Science.&rdquo;
<em>Foundations and Trends® in Machine Learning</em>, <b>11</b>(5-6), 355&ndash;607.
ISSN 1935-8237, 1935-8245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------------------------------
#  Wasserstein Distance between Samples from Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
## SMALL EXAMPLE
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

## COMPUTE WITH DIFFERENT ORDERS
out1 = wasserstein(X, Y, p=1)
out2 = wasserstein(X, Y, p=2)
out5 = wasserstein(X, Y, p=5)

## VISUALIZE : SHOW THE PLAN AND DISTANCE
pm1 = paste0("plan p=1; distance=",round(out1$distance,2))
pm2 = paste0("plan p=2; distance=",round(out2$distance,2))
pm5 = paste0("plan p=5; distance=",round(out5$distance,2))

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(out1$plan, axes=FALSE, main=pm1)
image(out2$plan, axes=FALSE, main=pm2)
image(out5$plan, axes=FALSE, main=pm5)
par(opar)

## Not run: 
## COMPARE WITH ANALYTIC RESULTS
#  For two Gaussians with same covariance, their 
#  2-Wasserstein distance is known so let's compare !

niter = 1000          # number of iterations
vdist = rep(0,niter)
for (i in 1:niter){
  mm = sample(30:50, 1)
  nn = sample(30:50, 1)
  
  X = matrix(rnorm(mm*2, mean=-1),ncol=2)
  Y = matrix(rnorm(nn*2, mean=+1),ncol=2)
  
  vdist[i] = wasserstein(X, Y, p=2)$distance
  if (i%%10 == 0){
    print(paste0("iteration ",i,"/", niter," complete.")) 
  }
}

# Visualize
opar &lt;- par(no.readonly=TRUE)
hist(vdist, main="Monte Carlo Simulation")
abline(v=sqrt(8), lwd=2, col="red")
par(opar)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
