<!DOCTYPE html><html><head><title>Help for package ENMeval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ENMeval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#aic.maxent'><p>Calculate AICc from Maxent model prediction</p></a></li>
<li><a href='#buildRMM'><p>Build metadata object from ENMeval results</p></a></li>
<li><a href='#bvariegatus'><p>Example occurrence dataset.</p></a></li>
<li><a href='#calc.10p.trainThresh'><p>Calculate 10 percentile threshold</p></a></li>
<li><a href='#calc.niche.overlap'><p>Calculate Similarity of ENMs in Geographic Space</p></a></li>
<li><a href='#clamp.vars'><p>Clamp predictor variables</p></a></li>
<li><a href='#corrected.var'><p>Corrected variance function</p></a></li>
<li><a href='#emp.bg'><p>emp.bg generic for ENMnull object</p></a></li>
<li><a href='#emp.bg.grp'><p>emp.bg.grp generic for ENMnull object</p></a></li>
<li><a href='#emp.occs'><p>emp.occs generic for ENMnull object</p></a></li>
<li><a href='#emp.occs.grp'><p>emp.occs.grp generic for ENMnull object</p></a></li>
<li><a href='#enm.args'><p>enm.args generic for ENMdetails object</p></a></li>
<li><a href='#enm.bioclim'><p>ENMdetails bioclim</p></a></li>
<li><a href='#enm.errors'><p>enm.errors generic for ENMdetails object</p></a></li>
<li><a href='#enm.fun'><p>enm.fun generic for ENMdetails object</p></a></li>
<li><a href='#enm.maxent.jar'><p>ENMdetails maxent.jar</p></a></li>
<li><a href='#enm.maxnet'><p>ENMdetails maxnet</p></a></li>
<li><a href='#enm.msgs'><p>enm.msgs generic for ENMdetails object</p></a></li>
<li><a href='#enm.name'><p>eval.name generic for ENMdetails object</p></a></li>
<li><a href='#enm.ncoefs'><p>enm.ncoefs generic for ENMdetails object</p></a></li>
<li><a href='#enm.predict'><p>enm.predict generic for ENMdetails object</p></a></li>
<li><a href='#enm.variable.importance'><p>enm.variable.importance generic for ENMdetails object</p></a></li>
<li><a href='#ENMdetails-class'><p>ENMdetails class</p></a></li>
<li><a href='#enmeval_results'><p>Example ENMevaluation object.</p></a></li>
<li><a href='#ENMeval-package'><p>Automated runs and evaluations of ecological niche models</p></a></li>
<li><a href='#ENMevaluate'><p>Tune ecological niche model (ENM) settings and calculate evaluation statistics</p></a></li>
<li><a href='#ENMevaluation_convert'><p>Convert old ENMevaluation objects to new ones</p></a></li>
<li><a href='#ENMevaluation-class'><p>ENMevaluation class</p></a></li>
<li><a href='#ENMnull-class'><p>ENMnull class</p></a></li>
<li><a href='#ENMnulls'><p>Generate null ecological niche models (ENMs) and compare null with empirical performance metrics</p></a></li>
<li><a href='#eval.algorithm'><p>eval.algorithm generic for ENMevaluation object</p></a></li>
<li><a href='#eval.bg'><p>eval.bg generic for ENMevaluation object</p></a></li>
<li><a href='#eval.bg.grp'><p>eval.bg.grp generic for ENMevaluation object</p></a></li>
<li><a href='#eval.clamp.directions'><p>eval.clamp.directions generic for ENMevaluation object</p></a></li>
<li><a href='#eval.doClamp'><p>eval.doClamp generic for ENMevaluation object</p></a></li>
<li><a href='#eval.models'><p>eval.models generic for ENMevaluation object</p></a></li>
<li><a href='#eval.occs'><p>eval.occs generic for ENMevaluation object</p></a></li>
<li><a href='#eval.occs.grp'><p>eval.occs.grp generic for ENMevaluation object</p></a></li>
<li><a href='#eval.occs.testing'><p>eval.occs.testing generic for ENMevaluation object</p></a></li>
<li><a href='#eval.other.settings'><p>eval.other.settings generic for ENMevaluation object</p></a></li>
<li><a href='#eval.overlap'><p>eval.overlap generic for ENMevaluation object</p></a></li>
<li><a href='#eval.partition.method'><p>eval.partition.method generic for ENMevaluation object</p></a></li>
<li><a href='#eval.partition.settings'><p>eval.partition.settings generic for ENMevaluation object</p></a></li>
<li><a href='#eval.predictions'><p>eval.predictions generic for ENMevaluation object</p></a></li>
<li><a href='#eval.results'><p>eval.results generic for ENMevaluation object</p></a></li>
<li><a href='#eval.results.partitions'><p>eval.results.partitions generic for ENMevaluation object</p></a></li>
<li><a href='#eval.rmm'><p>eval.rmm generic for ENMevaluation object</p></a></li>
<li><a href='#eval.taxon.name'><p>eval.taxon.name generic for ENMevaluation object</p></a></li>
<li><a href='#eval.tune.settings'><p>eval.tune.settings generic for ENMevaluation object</p></a></li>
<li><a href='#eval.variable.importance'><p>eval.variable.importance (variable importance) generic for ENMevaluation object</p></a></li>
<li><a href='#evalplot.envSim.hist'><p>Similarity histogram plots for partition groups</p></a></li>
<li><a href='#evalplot.envSim.map'><p>Similarity maps for partition groups</p></a></li>
<li><a href='#evalplot.grps'><p>Partition group plots</p></a></li>
<li><a href='#evalplot.nulls'><p>ENMnulls statistics plot</p></a></li>
<li><a href='#evalplot.stats'><p>ENMevaluation statistics plot</p></a></li>
<li><a href='#lookup.enm'><p>Look up ENMdetails abject</p></a></li>
<li><a href='#maxentJARversion'><p>Look up version of maxent.jar</p></a></li>
<li><a href='#null.algorithm'><p>null.algorithm generic for ENMnull object</p></a></li>
<li><a href='#null.doClamp'><p>null.doClamp generic for ENMnull object</p></a></li>
<li><a href='#null.emp.results'><p>null.emp.results generic for ENMnull object</p></a></li>
<li><a href='#null.mod.settings'><p>null.mod.settings generic for ENMnull object</p></a></li>
<li><a href='#null.no.iter'><p>null.no.iter generic for ENMnull object</p></a></li>
<li><a href='#null.other.settings'><p>null.other.settings generic for ENMnull object</p></a></li>
<li><a href='#null.partition.method'><p>null.partition.method generic for ENMnull object</p></a></li>
<li><a href='#null.partition.settings'><p>null.partition.settings generic for ENMnull object</p></a></li>
<li><a href='#null.results'><p>null.results generic for ENMnull object</p></a></li>
<li><a href='#null.results.partitions'><p>null.results.partitions generic for ENMnull object</p></a></li>
<li><a href='#partitions'><p>Methods to partition data for evaluation</p></a></li>
<li><a href='#rasStackNAs'><p>Find NA cells in a RasterStack</p></a></li>
<li><a href='#similarity'><p>Calculate Multivariate Environmental Similarity</p></a></li>
<li><a href='#tune.enm'><p>Iterate tuning of ENMs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated Tuning and Evaluations of Ecological Niche Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jamie M. Kass &lt;jamie.m.kass@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Runs ecological niche models over all combinations of user-defined settings (i.e., tuning), performs cross validation to evaluate models, and returns data tables to aid in selection of optimal model settings that balance goodness-of-fit and model complexity. Also has functions to partition data spatially (or not) for cross validation, to plot multiple visualizations of results, to run null models to estimate significance and effect sizes of performance metrics, and to calculate niche overlap between model predictions, among others. The package was originally built for Maxent models (Phillips et al. 2006, Phillips et al. 2017), but the current version allows possible extensions for any modeling algorithm. The extensive vignette, which guides users through most package functionality but unfortunately has a file size too big for CRAN, can be found here on the package's Github Pages website: <a href="https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html">https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.5.0), magrittr</td>
</tr>
<tr>
<td>Imports:</td>
<td>raster, dismo, doSNOW, doParallel, parallel, foreach, utils,
stats, grDevices, maxnet, dplyr, tidyr, ggplot2, glmnet,
rangeModelMetadata, rlang</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, graphics, testthat, knitr, rJava (&ge; 0.5-0),
spocc, RColorBrewer, rasterVis, sp, sf, blockCV, devtools,
tibble, latticeExtra, ecospat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jamiemkass.github.io/ENMeval/">https://jamiemkass.github.io/ENMeval/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-09 10:38:25 UTC; kass1</td>
</tr>
<tr>
<td>Author:</td>
<td>Jamie M. Kass [aut, cre],
  Robert Muscarella [aut],
  Peter J. Galante [aut],
  Corentin Bohl [aut],
  Gonzalo E. Buitrago-Pinilla [aut],
  Robert A. Boria [aut],
  Mariano Soley-Guardia [aut],
  Robert P. Anderson [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 11:53:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='aic.maxent'>Calculate AICc from Maxent model prediction</h2><span id='topic+aic.maxent'></span><span id='topic+calc.aicc'></span>

<h3>Description</h3>

<p>This function calculates AICc for Maxent models based on Warren 
and Seifert (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic.maxent(p.occs, ncoefs, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic.maxent_+3A_p.occs">p.occs</code></td>
<td>
<p>data frame: raw (maxent.jar) or exponential (maxnet) predictions for
the occurrence localities based on one or more models</p>
</td></tr>
<tr><td><code id="aic.maxent_+3A_ncoefs">ncoefs</code></td>
<td>
<p>numeric: number of non-zero model coefficients</p>
</td></tr>
<tr><td><code id="aic.maxent_+3A_p">p</code></td>
<td>
<p>RasterStack: raw (maxent.jar) or exponential (maxnet) model predictions;
if NULL, AICc will be calculated based on the background points, which already
have predictions that sum to 1 and thus need no correction &ndash; this assumes that
the background points represent a good sample of the study extent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As motivated by Warren and Seifert (2011) and implemented in ENMTools (Warren 
<em>et al.</em> 2010), this function calculates the small sample size version of Akaike 
Information Criterion for ENMs (Akaike 1974). We use AICc (instead of AIC) regardless of 
sample size based on the recommendation of Burnham and Anderson (1998, 2004).  The number of 
coefficients is determined by counting the number of non-zero coefficients in the 
<code>maxent</code> lambda file (<code>m@lambdas</code> for maxent.jar and <code>m$betas</code> for maxnet.  
See Warren <em>et al.</em> (2014) for limitations of this approach, namely that the number of 
non-zero coefficients is an estimate of the true degrees of freedom. For Maxent ENMs, AICc 
is calculated by first standardizing the raw predictions such that all cells in the study 
extent sum to 1, then extracting the occurrence record predictions. The predictions of the
study extent may not sum to 1 if the background does not cover every grid cell &ndash; as the 
background predictions sum to 1 by definition, extra predictions for grid cells not in 
the training data will add to this sum. When no raster data is provided, the raw predictions 
of the occurrence records are used to calculate AICc without standardization, with the 
assumption that the background records have adequately represented the occurrence records. 
The standardization is not necessary here because the background predictions sum to 1 
already, and the occurrence data is a subset of the background. This will not be true if 
the background does not adequately represent the occurrence records, in which case the 
occurrences are not a subset of the background and the raster approach should be used 
instead. The likelihood of the data for a given model is then calculated by taking the 
product of the raw occurrence predictions (Warren and Seifert 2011), or the sum of their 
logs, as is implemented here.
</p>


<h3>Value</h3>

<p>data frame with three columns:
<code>AICc</code> is the Akaike Information Criterion corrected for small sample
sizes calculated as:
</p>
<p style="text-align: center;"><code class="reqn"> (2 * K - 2 * logLikelihood) + (2 * K) * (K+1) / (n - K - 1)</code>
</p>

<p>where <em>K</em> is the number of non-zero coefficients in the model and <em>n</em> is the number of
occurrence localities.  The <em>logLikelihood</em> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn"> sum(log(vals))</code>
</p>

<p>where <em>vals</em> is a vector of Maxent raw/exponential values at occurrence localities
and the sum of these values across the study extent is equal to 1.
<code>delta.AICc</code> is the difference between the AICc of a given model and
the AICc of the model with the lowest AICc.
<code>w.AICc</code> is the Akaike weight (calculated as the relative likelihood of
a model (exp(-0.5 * <code>delta.AICc</code>)) divided by the sum of the likelihood
values of all models included in a run.  These can be used for model
averaging (Burnham and Anderson 2002).
</p>


<h3>Note</h3>

<p>Returns all <code>NA</code>s if the number of non-zero coefficients is larger than the
number of observations (occurrence localities).
</p>


<h3>References</h3>

<p>Akaike, H. (1974) A new look at the statistical model identification. <em>IEEE Transactions on Automatic Control</em>, <b>19</b>: 716-723. <a href="https://doi.org/10.1109/TAC.1974.1100705">doi:10.1109/TAC.1974.1100705</a>
</p>
<p>Burnham, K. P. and Anderson, D. R. (1998) Model selection and multimodel inference: a practical information-theoretic approach. Springer, New York.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2004) Multimodel inference: understanding AIC and BIC in model selection. <em>Sociological Methods and Research</em>, <b>33</b>: 261-304. <a href="https://doi.org/10.1177/0049124104268644">doi:10.1177/0049124104268644</a>
</p>
<p>Warren, D. L., Glor, R. E, and Turelli, M. (2010) ENMTools: a toolbox for comparative studies of environmental niche models. <em>Ecography</em>, <b>33</b>: 607-611. <a href="https://doi.org/10.1111/j.1600-0587.2009.06142.x">doi:10.1111/j.1600-0587.2009.06142.x</a>
</p>
<p>Warren, D. L., &amp; Seifert, S. N. (2011). Ecological niche modeling in Maxent: the importance of model complexity and the performance of model selection criteria. <em>Ecological Applications</em>, <b>21</b>: 335-342. <a href="https://doi.org/10.1890/10-1171.1">doi:10.1890/10-1171.1</a>
</p>
<p>Warren, D. L., Wright, A. N., Seifert, S. N., and Shaffer, H. B. (2014). Incorporating model complexity and sampling bias into ecological niche models of climate change risks faced by 90 California vertebrate species of concern. <em>Diversity and Distributions</em>, <b>20</b>: 334-343. <a href="https://doi.org/10.1111/ddi.12160">doi:10.1111/ddi.12160</a>
</p>


<h3>See Also</h3>

<p><code>maxent</code> in the <span class="pkg">dismo</span> package.
</p>

<hr>
<h2 id='buildRMM'>Build metadata object from ENMeval results</h2><span id='topic+buildRMM'></span>

<h3>Description</h3>

<p>Builds a <code>rangeModelMetadata</code> object from the output of <code>ENMevaluate</code>.
See Merow <em>et al.</em> (2019) for more details on the nature of the metadata and the <code>rangeModelMetadata</code> package.
To improve reproducibility of the study, this metadata object can be used as supplemental information for a manuscript, shared with collaborators, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRMM(e, envs, rmm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRMM_+3A_e">e</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
<tr><td><code id="buildRMM_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variables used in analysis; needed to pull information on the predictor variables
not included in the ENMevaluation object</p>
</td></tr>
<tr><td><code id="buildRMM_+3A_rmm">rmm</code></td>
<td>
<p>rangeModelMetadata object: if included, fields are appended to this RMM object as opposed to returning a new RMM object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Merow, C., Maitner, B. S., Owens, H. L., Kass, J. M., Enquist, B. J., Jetz, W., &amp; Guralnick, R. (2019). Species' range model metadata standards: RMMS. <em>Global Ecology and Biogeography</em>, <b>28</b>: 1912-1924. <a href="https://doi.org/10.1111/geb.12993">doi:10.1111/geb.12993</a>
</p>

<hr>
<h2 id='bvariegatus'>Example occurrence dataset.</h2><span id='topic+bvariegatus'></span>

<h3>Description</h3>

<p>An example occurrence dataset for the Brown Throated Sloth (<em>Bradypus variegatus</em>) downloaded from GBIF with the <code>spocc</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvariegatus
</code></pre>


<h3>Format</h3>

<p>A data frame with 476 rows and 2 variables:
</p>

<dl>
<dt>longitude</dt><dd><p>The longitude coordinate (x).</p>
</dd>
<dt>latitude</dt><dd><p>The latitude coordinate (y).</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.gbif.org/">https://www.gbif.org/</a>
</p>

<hr>
<h2 id='calc.10p.trainThresh'>Calculate 10 percentile threshold</h2><span id='topic+calc.10p.trainThresh'></span>

<h3>Description</h3>

<p>Function to calculate the 10 percentile threshold from training predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.10p.trainThresh(pred.train)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.10p.trainThresh_+3A_pred.train">pred.train</code></td>
<td>
<p>numeric vector: training occurrence predictions</p>
</td></tr>
</table>

<hr>
<h2 id='calc.niche.overlap'>Calculate Similarity of ENMs in Geographic Space</h2><span id='topic+calc.niche.overlap'></span>

<h3>Description</h3>

<p>Compute pairwise &quot;niche overlap&quot; in geographic space for Maxent predictions. The value ranges from 0 (no overlap) to 1 (identical predictions).  The function uses the <code>nicheOverlap</code> function of the <span class="pkg">dismo</span> package (Hijmans <em>et al.</em> 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.niche.overlap(predictors, overlapStat, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.niche.overlap_+3A_predictors">predictors</code></td>
<td>
<p>RasterStack: at least 2 Maxent raster predictions</p>
</td></tr>
<tr><td><code id="calc.niche.overlap_+3A_overlapstat">overlapStat</code></td>
<td>
<p>character: either &quot;D&quot; or &quot;I&quot;, the statistic calculated by the <code>nicheOverlap</code> function of the <span class="pkg">dismo</span> package (default: &quot;D&quot;)</p>
</td></tr>
<tr><td><code id="calc.niche.overlap_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;D&quot; refers to Schoeners <em>D</em> (Schoener 1968), while &quot;I&quot; refers to the <em>I</em> similarity statistic from Warren <em>et al.</em> (2008).
</p>


<h3>Value</h3>

<p>A matrix with the lower triangle giving values of pairwise &quot;niche overlap&quot; in geographic space.  Row and column names correspond to the results table output by <code><a href="#topic+ENMevaluate">ENMevaluate</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Based on <span class="pkg">dismo</span>::<code>nicheOverlap</code>, which is based on <span class="pkg">SDMTools</span>::<code>Istat</code>
Robert Muscarella &lt;bob.muscarella@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hijmans, R. J., Phillips, S., Leathwick, J. &amp; Elith, J. (2011) dismo package for R. Available online at: <a href="https://cran.r-project.org/package=dismo">https://cran.r-project.org/package=dismo</a>.
</p>
<p>Schoener, T. W. (1968) The <em>Anolis</em> lizards of Bimini: resource partitioning in a complex fauna. <em>Ecology</em>, <b>49</b>: 704-726. <a href="https://doi.org/10.2307/1935534">doi:10.2307/1935534</a>
</p>
<p>Warren, D. L., Glor, R. E., Turelli, M. &amp; Funk, D. (2008) Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. <em>Evolution</em>, <b>62</b>: 2868-2883. <a href="https://doi.org/10.1111/j.1558-5646.2008.00482.x">doi:10.1111/j.1558-5646.2008.00482.x</a>
</p>


<h3>See Also</h3>

<p>'nicheOverlap' in the <span class="pkg">dismo</span> package
</p>

<hr>
<h2 id='clamp.vars'>Clamp predictor variables</h2><span id='topic+clamp.vars'></span>

<h3>Description</h3>

<p>This function restricts the values of one or more predictor variable rasters
to stay within the bounds of the input occurrence and background data (argument &quot;ref.vals&quot;).
This is termed &quot;clamping&quot;, and is mainly used to avoid making extreme extrapolations
when making model predictions to environmental conditions outside the range of the
occurrence / background data used to train the model. Clamping can be done on variables of
choice on one or both tails of their distributions (i.e., arguments &quot;left&quot; and &quot;right&quot; for
minimum and maximum clamps, respectively). If &quot;left&quot; and/or &quot;right&quot; are not specified and 
left at the default NULL, the function will clamp all variables for that tail (thus, the 
function default is to clamp all variables on both sides). To turn off clamping for one side, 
enter &quot;none&quot; for either &quot;left&quot; or &quot;right&quot;.
</p>
<p>Categorical variables need to be declared with the argument &quot;categoricals&quot;. These variables
are excluded from the clamping analysis, but are put back into the RasterStack that is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clamp.vars(orig.vals, ref.vals, left = NULL, right = NULL, categoricals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clamp.vars_+3A_orig.vals">orig.vals</code></td>
<td>
<p>RasterStack / matrix / data frame: environmental predictor variables (must be in same geographic 
projection as occurrence data), or predictor variables values for the original records</p>
</td></tr>
<tr><td><code id="clamp.vars_+3A_ref.vals">ref.vals</code></td>
<td>
<p>matrix / data frame: predictor variable values for the reference records
(not including coordinates), used to determine the minimums and maximums &ndash; 
this should ideally be the occurrences + background (can be made with raster::extract())</p>
</td></tr>
<tr><td><code id="clamp.vars_+3A_left">left</code></td>
<td>
<p>character vector: names of variables to get a minimum clamp; can be &quot;none&quot; to turn
off minimum clamping</p>
</td></tr>
<tr><td><code id="clamp.vars_+3A_right">right</code></td>
<td>
<p>character vector: names of variables to get a maximum clamp, can be &quot;none&quot; to turn
off maximum clamping</p>
</td></tr>
<tr><td><code id="clamp.vars_+3A_categoricals">categoricals</code></td>
<td>
<p>character vector: name or names of categorical environmental variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The clamped Raster* object.
</p>


<h3>Author(s)</h3>

<p>Stephen J. Phillips, Jamie M. Kass, Gonzalo Pinilla-Buitrago
</p>

<hr>
<h2 id='corrected.var'>Corrected variance function</h2><span id='topic+corrected.var'></span>

<h3>Description</h3>

<p>Calculate variance corrected for non-independence of <em>k</em>-fold iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrected.var(x, nk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrected.var_+3A_x">x</code></td>
<td>
<p>numeric vector: input values</p>
</td></tr>
<tr><td><code id="corrected.var_+3A_nk">nk</code></td>
<td>
<p>numeric: number of <em>k</em>-fold iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'corrected.var' calculates variance corrected for non-independence of <em>k</em>-fold iterations.  
See Appendix of Shcheglovitova &amp; Anderson (2013) and other references (Miller 1974; Parr 1985; Shao and Wu 1989) for additional details. 
This function calculates variance that is corrected for the non-independence of <em>k</em> cross-validation iterations.  
Following Shao and Wu (1989): 
</p>
<p style="text-align: center;"><code class="reqn">Sum Of Squares * ((n-1)/n)</code>
</p>
 
<p>where <em>n</em> = the number of <em>k</em>-fold iterations.
</p>


<h3>Value</h3>

<p>A numeric value of the corrected variance.
</p>


<h3>Author(s)</h3>

<p>Robert Muscarella &lt;bob.muscarella@gmail.com&gt;
</p>


<h3>References</h3>

<p>Miller, R. G. (1974) The jackknife - a review. <em>Biometrika</em>, <b>61</b>: 1-15. <a href="https://doi.org/10.1093/biomet/61.1.1">doi:10.1093/biomet/61.1.1</a>
</p>
<p>Parr, W. C. (1985) Jackknifing differentiable statistical functionals. <em>Journal of the Royal Statistics Society, Series B</em>, <b>47</b>: 56-66. <a href="https://doi.org/10.1111/j.2517-6161.1985.tb01330.x">doi:10.1111/j.2517-6161.1985.tb01330.x</a>
</p>
<p>Shao J. and Wu, C. F. J. (1989) A general theory for jackknife variance estimation. <em>Annals of Statistics</em>, <b>17</b>: 1176-1197. <a href="https://doi.org/10.1214/aos/1176347263">doi:10.1214/aos/1176347263</a>
</p>
<p>Shcheglovitova, M. and Anderson, R. P. (2013) Estimating optimal complexity for ecological niche models: a jackknife approach for species with small sample sizes. <em>Ecological Modelling</em>, <b>269</b>: 9-17. <a href="https://doi.org/10.1016/j.ecolmodel.2013.08.011">doi:10.1016/j.ecolmodel.2013.08.011</a>
</p>

<hr>
<h2 id='emp.bg'>emp.bg generic for ENMnull object</h2><span id='topic+emp.bg'></span><span id='topic+emp.bg+2CENMnull-method'></span>

<h3>Description</h3>

<p>emp.bg generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.bg(x)

## S4 method for signature 'ENMnull'
emp.bg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp.bg_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='emp.bg.grp'>emp.bg.grp generic for ENMnull object</h2><span id='topic+emp.bg.grp'></span><span id='topic+emp.bg.grp+2CENMnull-method'></span>

<h3>Description</h3>

<p>emp.bg.grp generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.bg.grp(x)

## S4 method for signature 'ENMnull'
emp.bg.grp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp.bg.grp_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='emp.occs'>emp.occs generic for ENMnull object</h2><span id='topic+emp.occs'></span><span id='topic+emp.occs+2CENMnull-method'></span>

<h3>Description</h3>

<p>emp.occs generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.occs(x)

## S4 method for signature 'ENMnull'
emp.occs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp.occs_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='emp.occs.grp'>emp.occs.grp generic for ENMnull object</h2><span id='topic+emp.occs.grp'></span><span id='topic+emp.occs.grp+2CENMnull-method'></span>

<h3>Description</h3>

<p>emp.occs.grp generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.occs.grp(x)

## S4 method for signature 'ENMnull'
emp.occs.grp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp.occs.grp_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='enm.args'>enm.args generic for ENMdetails object</h2><span id='topic+enm.args'></span><span id='topic+enm.args+3C-'></span><span id='topic+enm.args+2CENMdetails-method'></span><span id='topic+enm.args+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.args generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.args(x)

enm.args(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.args(x)

## S4 replacement method for signature 'ENMdetails'
enm.args(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.args_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.args_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.bioclim'>ENMdetails bioclim</h2><span id='topic+enm.bioclim'></span>

<h3>Description</h3>

<p>This is the ENMdetails implementation for bioclim, implemented by dismo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.bioclim
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ENMdetails</code> of length 1.
</p>

<hr>
<h2 id='enm.errors'>enm.errors generic for ENMdetails object</h2><span id='topic+enm.errors'></span><span id='topic+enm.errors+3C-'></span><span id='topic+enm.errors+2CENMdetails-method'></span><span id='topic+enm.errors+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.errors generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.errors(x)

enm.errors(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.errors(x)

## S4 replacement method for signature 'ENMdetails'
enm.errors(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.errors_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.errors_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.fun'>enm.fun generic for ENMdetails object</h2><span id='topic+enm.fun'></span><span id='topic+enm.fun+3C-'></span><span id='topic+enm.fun+2CENMdetails-method'></span><span id='topic+enm.fun+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.fun generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.fun(x)

enm.fun(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.fun(x)

## S4 replacement method for signature 'ENMdetails'
enm.fun(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.fun_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.fun_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.maxent.jar'>ENMdetails maxent.jar</h2><span id='topic+enm.maxent.jar'></span>

<h3>Description</h3>

<p>This is the ENMdetails implementation for maxent.jar, the Java version of
the Maxent algorithm. The configuration for running the model differs slightly from that
in previous versions of ENMeval (0.3.0 and before) in that this version (&gt;=2.0.0) uses the
default of adding presences to the background for model training, while previous versions
had turned this off. Specifically, previous versions ran maxent() with &quot;noaddsamplestobackground&quot;
in the &quot;args&quot; vector argument, while this version does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.maxent.jar
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ENMdetails</code> of length 1.
</p>

<hr>
<h2 id='enm.maxnet'>ENMdetails maxnet</h2><span id='topic+enm.maxnet'></span>

<h3>Description</h3>

<p>This is the ENMdetails implementation for maxnet, the R version of
the Maxent algorithm. The configuration for running the model now includes addsamplestobackground = TRUE,
which explicitly adds presences to the background for model training, though as the current 
version of maxnet has this set to TRUE as default, behavior between ENMeval versions should not differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.maxnet
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ENMdetails</code> of length 1.
</p>

<hr>
<h2 id='enm.msgs'>enm.msgs generic for ENMdetails object</h2><span id='topic+enm.msgs'></span><span id='topic+enm.msgs+3C-'></span><span id='topic+enm.msgs+2CENMdetails-method'></span><span id='topic+enm.msgs+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.msgs generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.msgs(x)

enm.msgs(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.msgs(x)

## S4 replacement method for signature 'ENMdetails'
enm.msgs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.msgs_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.msgs_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.name'>eval.name generic for ENMdetails object</h2><span id='topic+enm.name'></span><span id='topic+enm.name+3C-'></span><span id='topic+enm.name+2CENMdetails-method'></span><span id='topic+enm.name+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>eval.name generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.name(x)

enm.name(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.name(x)

## S4 replacement method for signature 'ENMdetails'
enm.name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.name_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.name_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.ncoefs'>enm.ncoefs generic for ENMdetails object</h2><span id='topic+enm.ncoefs'></span><span id='topic+enm.ncoefs+3C-'></span><span id='topic+enm.ncoefs+2CENMdetails-method'></span><span id='topic+enm.ncoefs+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.ncoefs generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.ncoefs(x)

enm.ncoefs(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.ncoefs(x)

## S4 replacement method for signature 'ENMdetails'
enm.ncoefs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.ncoefs_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.ncoefs_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.predict'>enm.predict generic for ENMdetails object</h2><span id='topic+enm.predict'></span><span id='topic+enm.predict+3C-'></span><span id='topic+enm.predict+2CENMdetails-method'></span><span id='topic+enm.predict+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.predict generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.predict(x)

enm.predict(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.predict(x)

## S4 replacement method for signature 'ENMdetails'
enm.predict(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.predict_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.predict_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='enm.variable.importance'>enm.variable.importance generic for ENMdetails object</h2><span id='topic+enm.variable.importance'></span><span id='topic+enm.variable.importance+3C-'></span><span id='topic+enm.variable.importance+2CENMdetails-method'></span><span id='topic+enm.variable.importance+3C-+2CENMdetails-method'></span>

<h3>Description</h3>

<p>enm.variable.importance generic for ENMdetails object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm.variable.importance(x)

enm.variable.importance(x) &lt;- value

## S4 method for signature 'ENMdetails'
enm.variable.importance(x)

## S4 replacement method for signature 'ENMdetails'
enm.variable.importance(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enm.variable.importance_+3A_x">x</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
<tr><td><code id="enm.variable.importance_+3A_value">value</code></td>
<td>
<p>input value</p>
</td></tr>
</table>

<hr>
<h2 id='ENMdetails-class'>ENMdetails class</h2><span id='topic+ENMdetails-class'></span><span id='topic+ENMdetails'></span><span id='topic+show+2CENMdetails-method'></span>

<h3>Description</h3>

<p>An S4 class that details packages, functions, messages associated with a specific species distribution model (SDM) or ecological niche model (ENM). 
Objects of this class are generated by <code>ENMdetails()</code>. For examples, look in the package's R folder for scripts beginning with &quot;enm&quot; &ndash; these are 
pre-made ENMdetails object specifications that work with ENMeval out of the box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ENMdetails'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMdetails-class_+3A_object">object</code></td>
<td>
<p>ENMdetails object</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>character: name of algorithm</p>
</dd>
<dt><code>fun</code></dt><dd><p>function: function that runs the algorithm</p>
</dd>
<dt><code>errors</code></dt><dd><p>function: returns errors chosen by the user to prevent any malfunction in the analysis.
The available arguments are: occs, envs, bg, tune.args, partitions, algorithm, partition.settings, other.settings, 
categoricals, doClamp, clamp.directions.</p>
</dd>
<dt><code>msgs</code></dt><dd><p>function: prints messages showing the package version number, etc., and those related to the input tuning parameters <code>tune.args</code>.
The available arguments are: tune.args, other.settings.</p>
</dd>
<dt><code>args</code></dt><dd><p>function: returns the parameters needed to run the algorithm function.
The available arguments are: occs.z, bg.z, tune.tbl.i, other.settings (where x.z is a data.frame of the envs values at
coordinates of x, and tune.tbl.i is a single set of tuning parameters).</p>
</dd>
<dt><code>predict</code></dt><dd><p>function: specifies how to calculate a model prediction for a Raster* or a data frame.
The available arguments are: mod, envs, other.settings.</p>
</dd>
<dt><code>ncoefs</code></dt><dd><p>function: counts the number of non-zero model coefficients.
The available arguments are: mod.</p>
</dd>
<dt><code>variable.importance</code></dt><dd><p>function: generates a data frame of variable importance from the model object (if functionality is available).
The available arguments are: mod.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Jamie M. Kass, <a href="mailto:jamie.m.kass@gmail.com">jamie.m.kass@gmail.com</a>
</p>

<hr>
<h2 id='enmeval_results'>Example ENMevaluation object.</h2><span id='topic+enmeval_results'></span>

<h3>Description</h3>

<p>An example ENMevaluation object produced after running ENMevaluate() with feature classes L, LQ, LQH, H and regularization multipliers 1 through 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enmeval_results
</code></pre>


<h3>Format</h3>

<p>An ENMevaluation object
</p>

<hr>
<h2 id='ENMeval-package'>Automated runs and evaluations of ecological niche models</h2><span id='topic+ENMeval'></span><span id='topic+ENMeval-package'></span>

<h3>Description</h3>

<p>Runs ecological niche models over all combinations of user-defined settings (i.e., tuning), performs cross validation to evaluate models, and returns data tables to aid in selection of optimal model settings that balance goodness-of-fit and model complexity. Also has functions to partition data spatially (or not) for cross validation, to plot multiple visualizations of results, to run null models to estimate significance and effect sizes of performance metrics, and to calculate niche overlap between model predictions, among others. The package was originally built for Maxent models (Phillips et al. 2006, Phillips et al. 2017), but the current version allows possible extensions for any modeling algorithm. The extensive vignette, which guides users through most package functionality but unfortunately has a file size too big for CRAN, can be found here on the package's Github Pages website: <a href="https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html">https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html</a>.
</p>


<h3>Details</h3>

<p>See README for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jamie M. Kass <a href="mailto:jamie.m.kass@gmail.com">jamie.m.kass@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Robert Muscarella
</p>
</li>
<li><p> Peter J. Galante
</p>
</li>
<li><p> Corentin Bohl
</p>
</li>
<li><p> Gonzalo E. Buitrago-Pinilla
</p>
</li>
<li><p> Robert A. Boria
</p>
</li>
<li><p> Mariano Soley-Guardia
</p>
</li>
<li><p> Robert P. Anderson
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jamiemkass.github.io/ENMeval/">https://jamiemkass.github.io/ENMeval/</a>
</p>
</li></ul>


<hr>
<h2 id='ENMevaluate'>Tune ecological niche model (ENM) settings and calculate evaluation statistics</h2><span id='topic+ENMevaluate'></span>

<h3>Description</h3>

<p><code>ENMevaluate()</code> is the primary function for the <span class="pkg">ENMeval</span> package. This
function builds ecological niche models iteratively across a range of user-specified tuning 
settings. Users can choose to evaluate models with cross validation or a full-withheld testing 
dataset. <code>ENMevaluate()</code> returns an <code>ENMevaluation</code> object with slots containing 
evaluation statistics for each combination of settings and for each cross validation fold therein, as
well as raster predictions for each model when raster data is input. The evaluation statistics in the 
results table should aid users in identifying model settings that balance fit and predictive ability. See
the extensive vignette for fully worked examples: 
&lt;https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENMevaluate(
  occs,
  envs = NULL,
  bg = NULL,
  tune.args = NULL,
  partitions = NULL,
  algorithm = NULL,
  partition.settings = NULL,
  other.settings = NULL,
  categoricals = NULL,
  doClamp = TRUE,
  clamp.directions = NULL,
  user.enm = NULL,
  user.grp = NULL,
  occs.testing = NULL,
  taxon.name = NULL,
  n.bg = 10000,
  overlap = FALSE,
  overlapStat = c("D", "I"),
  user.val.grps = NULL,
  user.eval = NULL,
  rmm = NULL,
  parallel = FALSE,
  numCores = NULL,
  parallelType = "doSNOW",
  updateProgress = FALSE,
  quiet = FALSE,
  occ = NULL,
  env = NULL,
  bg.coords = NULL,
  RMvalues = NULL,
  fc = NULL,
  occ.grp = NULL,
  bg.grp = NULL,
  method = NULL,
  bin.output = NULL,
  rasterPreds = NULL,
  clamp = NULL,
  progbar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMevaluate_+3A_occs">occs</code></td>
<td>
<p>matrix / data frame: occurrence records with two columns for longitude and latitude 
of occurrence localities, in that order. If specifying predictor variable values
assigned to presence/background localities (without inputting raster data), this table should also have 
one column for each predictor variable. See Note for important distinctions between running the function
with and without rasters.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variables. These should be in same geographic projection as occurrence data.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_bg">bg</code></td>
<td>
<p>matrix / data frame: background records with two columns for longitude and latitude of 
background (or pseudo-absence) localities, in that order. If NULL, points will be randomly sampled across <code>envs</code> 
with the number specified by argument <code>n.bg</code>. If specifying predictor variable values
assigned to presence/background localities (without inputting raster data), this table should also have 
one column for each predictor variable. See Details for important distinctions between running the function
with and without rasters.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_tune.args">tune.args</code></td>
<td>
<p>named list: model settings to be tuned (i.e., for Maxent models:  <code>list(fc = c("L","Q"), rm = 1:3)</code>)</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_partitions">partitions</code></td>
<td>
<p>character: name of partitioning technique. Currently available options are
the nonspatial partitions &quot;randomkfold&quot; and &quot;jackknife&quot;, and the spatial partitions &quot;block&quot;,
&quot;checkerboard1&quot;, and &quot;checkerboard2&quot;, &quot;testing&quot; for partitioning with fully withheld data (see 
argument occs.testing), the &quot;user&quot; option (see argument user.grp), and &quot;none&quot; for no partitioning 
(see <code>?partitions</code> for details).</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_algorithm">algorithm</code></td>
<td>
<p>character: name of the algorithm used to build models. Currently one of &quot;maxnet&quot;,
&quot;maxent.jar&quot;, or &quot;bioclim&quot;, else the name from a custom ENMdetails implementation.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_partition.settings">partition.settings</code></td>
<td>
<p>named list: used to specify certain settings for partitioning schema.
See Details and ?partitions for descriptions of these settings.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_other.settings">other.settings</code></td>
<td>
<p>named list: used to specify extra settings for the analysis. 
All of these settings have internal defaults, so if they are not specified the analysis will be run 
with default settings. See Details for descriptions of these settings, including how to specify arguments
for maxent.jar.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_categoricals">categoricals</code></td>
<td>
<p>character vector: name or names of categorical environmental variables. If not specified,
all predictor variables will be treated as continuous unless they are factors. If categorical variables
are already factors, specifying names of such variables in this argument is not needed.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_doclamp">doClamp</code></td>
<td>
<p>boolean: if TRUE (default), model prediction extrapolations will be restricted to the upper and lower
bounds of the predictor variables. Clamping avoids extreme predictions for environment values outside
the range of the training data. If free extrapolation is a study aim, this should be set to FALSE, but
for most applications leaving this at the default of TRUE is advisable to avoid unrealistic predictions. 
When predictor variables are input, they are clamped internally before making model predictions when clamping is on.
When no predictor variables are input and data frames of variable values are used instead (SWD format),
validation data is clamped before making model predictions when clamping is on.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_clamp.directions">clamp.directions</code></td>
<td>
<p>named list: specifies the direction (&quot;left&quot; for minimum, &quot;right&quot; for maximum) 
of clamping for predictor variables &ndash; (e.g., <code>list(left = c("bio1","bio5"), right = c("bio10","bio15"))</code>).</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_user.enm">user.enm</code></td>
<td>
<p>ENMdetails object: a custom ENMdetails object used to build models. 
This is an alternative to specifying <code>algorithm</code> with a character string.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_user.grp">user.grp</code></td>
<td>
<p>named list: specifies user-defined partition groups, where <code>occs.grp</code> = vector of partition group 
(fold) for each occurrence locality, intended for user-defined partitions, and <code>bg.grp</code> = same vector for 
background (or pseudo-absence) localities.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_occs.testing">occs.testing</code></td>
<td>
<p>matrix / data frame: a fully withheld testing dataset with two columns for longitude and latitude 
of occurrence localities, in that order when <code>partitions = "testing"</code>. These occurrences will be used only 
for evaluation but not for model training, and thus no cross validation will be performed.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_taxon.name">taxon.name</code></td>
<td>
<p>character: name of the focal species or taxon. This is used primarily for annotating
the ENMevaluation object and output metadata (rmm), but not necessary for analysis.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_n.bg">n.bg</code></td>
<td>
<p>numeric: the number of background (or pseudo-absence) points to randomly sample over the environmental
raster data (default: 10000) if background records were not already provided.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_overlap">overlap</code></td>
<td>
<p>boolean: if TRUE, calculate niche overlap statistics (Warren <em>et al.</em> 2008).</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_overlapstat">overlapStat</code></td>
<td>
<p>character: niche overlap statistics to be calculated &ndash; 
&quot;D&quot; (Schoener's D) and or &quot;I&quot; (Hellinger's I) &ndash; see ?calc.niche.overlap for more details.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_user.val.grps">user.val.grps</code></td>
<td>
<p>matrix / data frame: user-defined validation record coordinates and predictor variable values. 
This is used internally by <code>ENMnulls()</code> to force each null model to evaluate with empirical validation data,
and does not have any current use when running <code>ENMevaluate()</code> independently.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_user.eval">user.eval</code></td>
<td>
<p>function: custom function for specifying performance metrics not included in <span class="pkg">ENMeval</span>.
The function must first be defined and then input as the argument <code>user.eval</code>. 
This function should have a single argument called <code>vars</code>, which is a list that includes different data 
that can be used to calculate the metric. See Details below and the vignette for a worked example.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_rmm">rmm</code></td>
<td>
<p>rangeModelMetadata object: if specified, <code>ENMevaluate()</code> will write metadata details for the analysis into
this object, but if not, a new <code>rangeModelMetadata</code> object will be generated and included in the output
<code>ENMevaluation</code> object.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_parallel">parallel</code></td>
<td>
<p>boolean: if TRUE, run with parallel processing.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_numcores">numCores</code></td>
<td>
<p>numeric: number of cores to use for parallel processing. If NULL, all available cores will be used.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_paralleltype">parallelType</code></td>
<td>
<p>character: either &quot;doParallel&quot; or &quot;doSNOW&quot; (default: &quot;doSNOW&quot;) .</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_updateprogress">updateProgress</code></td>
<td>
<p>boolean: if TRUE, use shiny progress bar. This is only for use in shiny apps.</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors).</p>
</td></tr>
<tr><td><code id="ENMevaluate_+3A_occ">occ</code>, <code id="ENMevaluate_+3A_env">env</code>, <code id="ENMevaluate_+3A_bg.coords">bg.coords</code>, <code id="ENMevaluate_+3A_rmvalues">RMvalues</code>, <code id="ENMevaluate_+3A_fc">fc</code>, <code id="ENMevaluate_+3A_occ.grp">occ.grp</code>, <code id="ENMevaluate_+3A_bg.grp">bg.grp</code>, <code id="ENMevaluate_+3A_method">method</code>, <code id="ENMevaluate_+3A_bin.output">bin.output</code>, <code id="ENMevaluate_+3A_rasterpreds">rasterPreds</code>, <code id="ENMevaluate_+3A_clamp">clamp</code>, <code id="ENMevaluate_+3A_progbar">progbar</code></td>
<td>
<p>These arguments from previous versions are backward-compatible to avoid unnecessary errors for older scripts, but in a later version
these arguments will be permanently deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a few methodological details in the implementation of ENMeval &gt;=2.0.0 that are important to mention.
There is also a brief discussion of some points relevant to null models in ?ENMnulls.
</p>
<p>1. By default, validation AUC is calculated with respect to the full background (training + validation).
This approach follows Radosavljevic &amp; Anderson (2014).This setting can be changed by assigning 
other.settings$validation.bg to &quot;partition&quot;, which will calculate AUC with respect 
to the validation background only. The default value for other.settings$validation.bg is &quot;full&quot;.
</p>
<p>2. The continuous Boyce index (always) and AICc (when no raster is provided) are not calculated using 
the predicted values of the RasterStack delineating the full study extent, but instead using the predicted
values for the background records. This decision to use the background only for calculating the continuous 
Boyce index was made to simplify the code and improve running time. The decision for AICc was made in order
to allow AICc calculations for datasets that do not include raster data. See ?calc.aicc for more details,
and for caveats when calculating AICc without raster data (mainly, that if the background does not 
adequately represent the occurrence records, users should use the raster approach, for reasons explained
in the calc.aicc documentation). For both metrics, if the background records are a good representation 
of the study extent, there should not be much difference between this approach using the background 
data and the approach that uses rasters.
</p>
<p>3. When running <code>ENMevaluate()</code> without raster data, and instead adding the environmental predictor values
to the occurrence and background data tables, users may notice some differences in the results. Occurrence records
that share a raster grid cell are automatically removed when raster data is provided, but without raster data
this functionality cannot operate, and thus any such duplicate occurrence records can remain in the training data.
The Java implementation of Maxent (maxent.jar) should automatically remove these records, but the R implementation 
<code>maxnet</code> does not, and the <code>bioclim()</code> function from the R package <code>dismo</code> does not as well. Therefore,  
it is up to the user to remove such records before running <code>ENMevaluate()</code> when raster data are not included.
</p>
<p>Below are descriptions of the parameters used in the other.settings, partition.settings, and user.eval arguments.
</p>
<p>For other.settings, the options are:<br />*
abs.auc.diff - boolean: if TRUE, take absolute value of AUCdiff (default: TRUE)<br />*
pred.type - character: specifies which prediction type should be used to generate maxnet or 
maxent.jar prediction rasters (default: &quot;cloglog&quot;).<br />*
validation.bg - character: either &quot;full&quot; to calculate training and validation AUC and CBI 
for cross-validation with respect to the full background (default), or &quot;partition&quot; (meant for 
spatial partitions only) to calculate each with respect to the partitioned background only 
(i.e., training occurrences are compared to training background, and validation occurrences 
compared to validation background).<br />*
other.args - named list: any additional model arguments not specified for tuning; this can
include arguments for maxent.jar, which are described in the software's Help file.<br />
</p>
<p>For partition.settings, the current options are:<br />*
orientation - character: one of &quot;lat_lon&quot; (default), &quot;lon_lat&quot;, &quot;lat_lat&quot;, or &quot;lon_lon&quot; (required for block partition).<br />* 
aggregation.factor - numeric vector: one or two numbers specifying the factor with which to aggregate the envs (default: 2)
raster to assign partitions (required for the checkerboard partitions).<br />*
kfolds - numeric: the number of folds (i.e., partitions) for random partitions (default: 5).<br />
</p>
<p>For the block partition, the orientation specifications are abbreviations for &quot;latitude&quot; and &quot;longitude&quot;, 
and they determine the order and orientations with which the block partitioning function creates the partition groups. 
For example, &quot;lat_lon&quot; will split the occurrence localities first by latitude, then by longitude. For the checkerboard 
partitions, the aggregation factor specifies how much to aggregate the existing cells in the envs raster
to make new spatial partitions. For example, checkerboard1 with an aggregation factor value of 2 will make the grid cells 
4 times larger and then assign occurrence and background records to partition groups based on which cell they are in. 
The checkerboard2 partition is hierarchical, so cells are first aggregated to define groups like checkerboard1, but a 
second aggregation is then made to separate the resulting 2 bins into 4 bins. For checkerboard2, two different numbers 
can be used to specify the two levels of the hierarchy, or if a single number is inserted, that value will be used 
for both levels.
</p>
<p>For user.eval, the accessible variables you have access to in order to run your custom function are below. 
See the vignette for a worked example.<br />*
enm - ENMdetails object<br />*
occs.train.z - data frame: predictor variable values for training occurrences<br />*
occs.val.z - data frame: predictor variable values for validation occurrences<br />*
bg.train.z - data frame: predictor variable values for training background<br />*
bg.val.z - data frame: predictor variable values for validation background<br />*
mod.k - Model object for current partition (k)<br />*
nk - numeric: number of folds (i.e., partitions)<br />*
other.settings - named list: other settings specified in ENMevaluate()<br />*
partitions - character: name of the partition method (e.g., &quot;block&quot;)<br />*
occs.train.pred - numeric: predictions made by mod.k for training occurrences<br />*
occs.val.pred - numeric: predictions made by mod.k for validation occurrences<br />*
bg.train.pred - numeric: predictions made by mod.k for training background<br />*
bg.val.pred - numeric: predictions made by mod.k for validation background
</p>


<h3>Value</h3>

<p>An ENMevaluation object. See ?ENMevaluation for details and description of the columns
in the results table.
</p>


<h3>References</h3>

<p>Muscarella, R., Galante, P. J., Soley-Guardia, M., Boria, R. A., Kass, J. M., Uriarte, M., &amp; Anderson, R. P. (2014). ENMeval: An R package for conducting spatially independent evaluations and estimating optimal model complexity for Maxent ecological niche models. <em>Methods in Ecology and Evolution</em>, <b>5</b>: 1198-1205. <a href="https://doi.org/10.1111/2041-210X.12261">doi:10.1111/2041-210X.12261</a>
</p>
<p>Warren, D. L., Glor, R. E., Turelli, M. &amp; Funk, D. (2008) Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. <em>Evolution</em>, <b>62</b>: 2868-2883. <a href="https://doi.org/10.1111/j.1558-5646.2008.00482.x">doi:10.1111/j.1558-5646.2008.00482.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occs &lt;- read.csv(file.path(system.file(package="dismo"), "/ex/bradypus.csv"))[,2:3]
envs &lt;- raster::stack(list.files(path=paste(system.file(package="dismo"), "/ex", sep=""), 
                                 pattern="grd", full.names=TRUE))
occs.z &lt;- cbind(occs, raster::extract(envs, occs))
occs.z$biome &lt;- factor(occs.z$biome)
bg &lt;- as.data.frame(dismo::randomPoints(envs, 1000))
names(bg) &lt;- names(occs)
bg.z &lt;- cbind(bg, raster::extract(envs, bg))
bg.z$biome &lt;- factor(bg.z$biome)

# set other.settings -- pred.type is only for Maxent models
os &lt;- list(abs.auc.diff = FALSE, pred.type = "cloglog", validation.bg = "partition")
# set partition.settings -- here's an example for the block method
# see Details for the required settings for other partition methods
ps &lt;- list(orientation = "lat_lat")

# here's a run with maxnet -- note the tune.args for feature classes (fc)
# and regularization multipliers (rm), as well as the designation of the
# categorical variable we are using (this can be a vector if multiple
# categorical variables are used)
e.maxnet &lt;- ENMevaluate(occs, envs, bg, 
tune.args = list(fc = c("L","LQ","LQH","H"), rm = 1:5), 
partitions = "block", other.settings = os, partition.settings = ps,
algorithm = "maxnet", categoricals = "biome", overlap = TRUE)

# print the tuning results
eval.results(e.maxnet)

# there is currently no native function to make raster model predictions for
# maxnet models, but ENMeval can be used to make them like this:
# here's an example where we make a prediction based on the L2 model
# (feature class: Linear, regularization multiplier: 2) for our envs data
mods.maxnet &lt;- eval.models(e.maxnet)
pred.L2 &lt;- enm.maxnet@predict(mods.maxnet$fc.L_rm.2, envs, os)
raster::plot(pred.L2)

#' # here's a run with maxent.jar -- note that if the R package rJava cannot 
install or load, or if other issues with Java exist on your computer, 
maxent.jar will not function
e.maxnet &lt;- ENMevaluate(occs, envs, bg, 
tune.args = list(fc = c("L","LQ","LQH","H"), rm = 1:5), 
partitions = "block", other.settings = os, partition.settings = ps,
algorithm = "maxent.jar", categoricals = "biome", overlap = TRUE)

# print the tuning results
eval.results(e.maxent.jar)
# raster predictions can be made for maxent.jar models with dismo or ENMeval
mods.maxent.jar &lt;- eval.models(e.maxent.jar)
pred.L2 &lt;- dismo::predict(mods.maxent.jar$fc.L_rm.2, envs, args = "outputform=cloglog")
pred.L2 &lt;- enm.maxent.jar@predict(mods.maxent.jar$fc.L_rm.2, envs, os)
raster::plot(pred.L2)

# this will give you the percent contribution (not deterministic) and
# permutation importance (deterministic) values of variable importance for
# Maxent models, and it only works with maxent.jar
eval.variable.importance(e.maxent.jar)

# here's a run with BIOCLIM -- note that 1) we need to remove the categorical
# variable here because this algorithm only takes continuous variables, and
# that 2) the way BIOCLIM makes predicted is getting tuned (as opposed to the
way the model is fit like maxnet or maxent.jar), namely, the tails of the 
# distribution that are ignored when predicting (see ?dismo::bioclim)

# print the tuning results
eval.results(e.bioclim)
# make raster predictions with dismo or ENMeval
mods.bioclim &lt;- eval.models(e.bioclim)
# note: the models for low, high, and both are actually all the same, and
# the only difference for tuning is how they are predicted during
# cross-validation
pred.both &lt;- dismo::predict(mods.bioclim$tails.both, envs, tails = "both")
os &lt;- c(os, list(tails = "both"))
pred.both &lt;- enm.bioclim@predict(mods.bioclim$tails.both, envs, os)
raster::plot(pred.both)

# please see the vignette for more examples of model tuning, 
# partitioning, plotting functions, and null models
# https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html

## End(Not run)

</code></pre>

<hr>
<h2 id='ENMevaluation_convert'>Convert old ENMevaluation objects to new ones</h2><span id='topic+ENMevaluation_convert'></span>

<h3>Description</h3>

<p>Converts ENMevaluation objects made with version &lt;=0.3.1 to
new ones made with version &gt;=2.0.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENMevaluation_convert(e, envs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMevaluation_convert_+3A_e">e</code></td>
<td>
<p>ENMevaluation object: the old object to convert</p>
</td></tr>
<tr><td><code id="ENMevaluation_convert_+3A_envs">envs</code></td>
<td>
<p>RasterStack: the original predictor variables used to generate
the old ENMevaluation object (these are used to make the new occs and bg slots
which contain the predictor variable values)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If bin.output was set to TRUE, <code>`e@results`</code> will be equivalent to 
the new results.partitions slot. Some slots are unable to be filled in because
previous versions of ENMeval did not record them in ENMevaluation objects:
variable.importance, partition.settings, other.settings, doClamp (set to TRUE
arbitrarily to avoid errors, but may actually have been FALSE), clamp.directions,
taxon.name, and rmm.
</p>

<hr>
<h2 id='ENMevaluation-class'>ENMevaluation class</h2><span id='topic+ENMevaluation-class'></span><span id='topic+ENMevaluation'></span><span id='topic+show+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>An S4 class that contains the ENMevaluate results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ENMevaluation'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMevaluation-class_+3A_object">object</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following are brief descriptions of the columns in the results table, which prints
when accessing 'e@results' or 'results(e)' if 'e' is the ENMevaluation object. Those columns
that represent evaluations of validation data (__.val.__) end in either &quot;avg&quot; (average of the
metric across the models trained on withheld data during cross-validation) or &quot;sd&quot; (standard
deviation of the metric across these models).<br />*
fc = feature class<br />*
rm = regularization multiplier<br />*
tune.args = combination of arguments that define the complexity settings used for tuning (i.e., fc and rm for Maxent)<br />*
auc.train = AUC calculated on the full dataset<br />*
cbi.train = Continuous Boyce Index calculated on the full dataset<br />*
auc.val = average/sd AUC calculated on the validation datasets (the data withheld during cross-validation)<br />*
auc.diff = average/sd difference between auc.train and auc.val<br />*
or.mtp = average/sd omission rate with threshold as the minimum suitability value across occurrence records<br />*
or.10p = average/sd omission rate with threshold as the minimum suitability value across occurrence records after removing the lowest 10
cbi.val = average/sd Continuous Boyce Index calculated on the validation datasets (the data withheld during cross-validation)<br />*
AICc = AIC corrected for small sample sizes<br />*
delta.AICc = highest AICc value across all models minus this model's AICc value, where lower values mean higher performance and 0 is the highest performing model<br />*
w.AIC = AIC weights, calculated by exp( -0.5 * delta.AIC), where higher values mean higher performance<br />*
ncoef = number of non-zero beta values (model coefficients)
</p>


<h3>Slots</h3>


<dl>
<dt><code>algorithm</code></dt><dd><p>character: algorithm used</p>
</dd>
<dt><code>tune.settings</code></dt><dd><p>data frame: settings that were tuned</p>
</dd>
<dt><code>partition.method</code></dt><dd><p>character: partition method used</p>
</dd>
<dt><code>partition.settings</code></dt><dd><p>list: partition settings used (i.e., value of *k* or aggregation factor)</p>
</dd>
<dt><code>other.settings</code></dt><dd><p>list: other modeling settings used (i.e., decisions about clamping, AUC diff calculation)</p>
</dd>
<dt><code>doClamp</code></dt><dd><p>logical: whether or not clamping was used</p>
</dd>
<dt><code>clamp.directions</code></dt><dd><p>list: the clamping directions specified</p>
</dd>
<dt><code>results</code></dt><dd><p>data frame: evaluation summary statistics</p>
</dd>
<dt><code>results.partitions</code></dt><dd><p>data frame: evaluation k-fold statistics</p>
</dd>
<dt><code>models</code></dt><dd><p>list: model objects</p>
</dd>
<dt><code>variable.importance</code></dt><dd><p>list: variable importance data frames (when available)</p>
</dd>
<dt><code>predictions</code></dt><dd><p>RasterStack: model predictions</p>
</dd>
<dt><code>taxon.name</code></dt><dd><p>character: the name of the focal taxon (optional)</p>
</dd>
<dt><code>occs</code></dt><dd><p>data frame: occurrence coordinates and predictor variable values used for model training</p>
</dd>
<dt><code>occs.testing</code></dt><dd><p>data frame: when provided, the coordinates of the fully-withheld testing records</p>
</dd>
<dt><code>occs.grp</code></dt><dd><p>vector: partition groups for occurrence points</p>
</dd>
<dt><code>bg</code></dt><dd><p>data frame: background coordinates and predictor variable values used for model training</p>
</dd>
<dt><code>bg.grp</code></dt><dd><p>vector: partition groups for background points</p>
</dd>
<dt><code>overlap</code></dt><dd><p>list: matrices of pairwise niche overlap statistics</p>
</dd>
<dt><code>rmm</code></dt><dd><p>list: the rangeModelMetadata objects for each model</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Jamie M. Kass, <a href="mailto:jamie.m.kass@gmail.com">jamie.m.kass@gmail.com</a>, Bob Muscarella, <a href="mailto:bob.muscarella@gmail.com">bob.muscarella@gmail.com</a>
</p>


<h3>References</h3>

<p>For references on performance metrics, see the following:
</p>
<p>In general for ENMeval: 
</p>
<p>Muscarella, R., Galante, P. J., Soley-Guardia, M., Boria, R. A., Kass, J. M., Uriarte, M., &amp; Anderson, R. P. (2014). ENMeval: An R package for conducting spatially independent evaluations and estimating optimal model complexity for Maxent ecological niche models. <em>Methods in Ecology and Evolution</em>, <b>5</b>: 1198-1205. <a href="https://doi.org/10.1111/2041-210X.12261">doi:10.1111/2041-210X.12261</a>
</p>
<p><em>AUC</em>
</p>
<p>Fielding, A. H., &amp; Bell, J. F. (1997). A review of methods for the assessment of prediction errors in conservation presence/absence models. <em>Environmental Conservation</em>, <b>24</b>: 38-49. <a href="https://doi.org/10.1017/S0376892997000088">doi:10.1017/S0376892997000088</a>
</p>
<p>JimnezValverde, A. (2012). Insights into the area under the receiver operating characteristic curve (AUC) as a discrimination measure in species distribution modelling. <em>Global Ecology and Biogeography</em>, <b>21</b>: 498-507. <a href="https://doi.org/10.1111/j.1466-8238.2011.00683.x">doi:10.1111/j.1466-8238.2011.00683.x</a>
</p>
<p><em>AUC diff</em>
</p>
<p>Warren, D. L., Glor, R. E., Turelli, M. &amp; Funk, D. (2008) Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. <em>Evolution</em>, <b>62</b>: 2868-2883. <a href="https://doi.org/10.1111/j.1558-5646.2008.00482.x">doi:10.1111/j.1558-5646.2008.00482.x</a>
</p>
<p>Radosavljevic, A., &amp; Anderson, R. P. (2014). Making better Maxent models of species distributions: complexity, overfitting and evaluation. <em>Journal of Biogeography</em>, <b>41</b>(4), 629-643. <a href="https://doi.org/10.1111/jbi.12227">doi:10.1111/jbi.12227</a> 
</p>
<p><em>Omission rates</em>
</p>
<p>Radosavljevic, A., &amp; Anderson, R. P. (2014). Making better Maxent models of species distributions: complexity, overfitting and evaluation. <em>Journal of Biogeography</em>, <b>41</b>(4), 629-643. <a href="https://doi.org/10.1111/jbi.12227">doi:10.1111/jbi.12227</a>
</p>
<p><em>Continuous Boyce Index</em>
</p>
<p>Hirzel, A. H., Le Lay, G., Helfer, V., Randin, C., &amp; Guisan, A. (2006). Evaluating the ability of habitat suitability models to predict species presences. <em>Ecological Modelling</em>, <b>199</b>: 142-152. <a href="https://doi.org/10.1016/j.ecolmodel.2006.05.017">doi:10.1016/j.ecolmodel.2006.05.017</a>
</p>

<hr>
<h2 id='ENMnull-class'>ENMnull class</h2><span id='topic+ENMnull-class'></span><span id='topic+ENMnull'></span><span id='topic+show+2CENMnull-method'></span>

<h3>Description</h3>

<p>An S4 class that contains the ENMnulls results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ENMnull'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMnull-class_+3A_object">object</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>null.algorithm</code></dt><dd><p>character: algorithm used</p>
</dd>
<dt><code>null.mod.settings</code></dt><dd><p>data frame: model settings used</p>
</dd>
<dt><code>null.partition.method</code></dt><dd><p>character: partition method used</p>
</dd>
<dt><code>null.partition.settings</code></dt><dd><p>list: partition settings used (i.e., value of *k* or aggregation factor)</p>
</dd>
<dt><code>null.doClamp</code></dt><dd><p>logical: whether to clamp model predictions or not</p>
</dd>
<dt><code>null.other.settings</code></dt><dd><p>list: other modeling settings used (i.e., decisions about clamping, AUC diff calculation)</p>
</dd>
<dt><code>null.no.iter</code></dt><dd><p>numeric: number of null model iterations</p>
</dd>
<dt><code>null.results</code></dt><dd><p>data frame: evaluation summary statistics for null models</p>
</dd>
<dt><code>null.results.partitions</code></dt><dd><p>data frame: evaluation k-fold statistics for null models</p>
</dd>
<dt><code>null.emp.results</code></dt><dd><p>data frame: evaluation summary statistics for the empirical model, means for all null models, z-scores, and p-values</p>
</dd>
<dt><code>emp.occs</code></dt><dd><p>data frame: occurrence coordinates and predictor variable values used for model training (empirical model)</p>
</dd>
<dt><code>emp.occs.grp</code></dt><dd><p>vector: partition groups for occurrence points (empirical model)</p>
</dd>
<dt><code>emp.bg</code></dt><dd><p>data frame: background coordinates and predictor variable values used for model training (empirical model)</p>
</dd>
<dt><code>emp.bg.grp</code></dt><dd><p>vector: partition groups for background points (empirical model)</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Jamie M. Kass, <a href="mailto:jamie.m.kass@gmail.com">jamie.m.kass@gmail.com</a>, Corentin Bohl, <a href="mailto:corentinbohl@gmail.com">corentinbohl@gmail.com</a>
</p>

<hr>
<h2 id='ENMnulls'>Generate null ecological niche models (ENMs) and compare null with empirical performance metrics</h2><span id='topic+ENMnulls'></span>

<h3>Description</h3>

<p><code>ENMnulls()</code> iteratively builds null ENMs for a single set of 
user-specified model settings based on an input ENMevaluation object, from which all other analysis 
settings are extracted. Summary statistics of the performance metrics for the null ENMs are taken
(averages and standard deviations) and effect sizes and <em>p</em>-values are calculated by comparing these 
summary statistics to the empirical values of the performance metrics (i.e., from the model built with
the empirical data). See the references below for more details on this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENMnulls(
  e,
  mod.settings,
  no.iter,
  eval.stats = c("auc.val", "auc.diff", "cbi.val", "or.mtp", "or.10p"),
  user.enm = NULL,
  user.eval.type = NULL,
  userStats.signs = NULL,
  removeMxTemp = TRUE,
  parallel = FALSE,
  numCores = NULL,
  parallelType = "doSNOW",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMnulls_+3A_e">e</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_mod.settings">mod.settings</code></td>
<td>
<p>named list: one set of model settings with which to build null ENMs</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_no.iter">no.iter</code></td>
<td>
<p>numeric: number of null model iterations</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_eval.stats">eval.stats</code></td>
<td>
<p>character vector: the performance metrics that will be used to calculate null model statistics</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_user.enm">user.enm</code></td>
<td>
<p>ENMdetails object: if implementing a user-specified model</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_user.eval.type">user.eval.type</code></td>
<td>
<p>character: if implementing a user-specified model, specify here which
evaluation type to use &ndash; either &quot;knonspatial&quot;, &quot;kspatial&quot;, &quot;testing&quot;, or &quot;none&quot;</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_userstats.signs">userStats.signs</code></td>
<td>
<p>named list: user-defined evaluation statistics attributed with
either 1 or -1 to designate whether the expected difference between empirical and null models is 
positive or negative; this is used to calculate the p-value of the z-score</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_removemxtemp">removeMxTemp</code></td>
<td>
<p>boolean: if TRUE, delete all temporary data generated when using maxent.jar for modeling</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_parallel">parallel</code></td>
<td>
<p>boolean: if TRUE, use parallel processing</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_numcores">numCores</code></td>
<td>
<p>numeric: number of cores to use for parallel processing; if NULL, all available cores will be used</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_paralleltype">parallelType</code></td>
<td>
<p>character:: either &quot;doParallel&quot; or &quot;doSNOW&quot; (default: &quot;doSNOW&quot;)</p>
</td></tr>
<tr><td><code id="ENMnulls_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This null ENM technique is based on the implementation in Bohl <em>et al.</em> (2019),
which follows the original methodology of Raes &amp; ter Steege (2007) but makes an important modification:
instead of evaluating each null model on random validation data, here we evaluate the null models on the same withheld
validation data used to evaluate the empirical model. Bohl <em>et al.</em> (2019) demonstrates this approach using a single
defined withheld partition group, but Kass <em>et al.</em> (2020) extended it to use spatial partitions by drawing null occurrences
from the area of the predictor raster data defining each partition. Please see the vignette for a brief example: &lt;
</p>
<p>This function avoids using raster data to speed up each iteration, and instead samples null occurrences from the 
partitioned background records. Thus, you should avoid running this when your background records are not well 
sampled across the study extent, as this limits the extent that null occurrences can be sampled from.
</p>


<h3>Value</h3>

<p>An <code>ENMnull</code> object with slots containing evaluation summary statistics for the null models 
and their cross-validation results, as well as differences in results between the empirical and null models. 
This comparison table includes z-scores of these differences and their associated p-values (under a normal distribution).
See ?ENMnull for more details.
</p>


<h3>References</h3>

<p>Bohl, C. L., Kass, J. M., &amp; Anderson, R. P. (2019). A new null model approach to quantify performance and significance for ecological niche models of species distributions. <em>Journal of Biogeography</em>, <b>46</b>: 1101-1111. <a href="https://doi.org/10.1111/jbi.13573">doi:10.1111/jbi.13573</a>
</p>
<p>Kass, J. M., Anderson, R. P., Espinosa-Lucas, A., Jurez-Jaimes, V., Martnez-Salas, E., Botello, F.,  Tavera, G., Flores-Martnez, J. J., &amp; Snchez-Cordero, V. (2020). Biotic predictors with phenological information improve range estimates for migrating monarch butterflies in Mexico. <em>Ecography</em>, <b>43</b>: 341-352. <a href="https://doi.org/10.1111/ecog.04886">doi:10.1111/ecog.04886</a>
</p>
<p>Raes, N., &amp; ter Steege, H. (2007). A null-model for significance testing of presence-only species distribution models. <em>Ecography</em>, <b>30</b>: 727-736. <a href="https://doi.org/10.1111/j.2007.0906-7590.05041.x">doi:10.1111/j.2007.0906-7590.05041.x</a>
</p>

<hr>
<h2 id='eval.algorithm'>eval.algorithm generic for ENMevaluation object</h2><span id='topic+eval.algorithm'></span><span id='topic+eval.algorithm+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.algorithm generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.algorithm(x)

## S4 method for signature 'ENMevaluation'
eval.algorithm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.algorithm_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.bg'>eval.bg generic for ENMevaluation object</h2><span id='topic+eval.bg'></span><span id='topic+eval.bg+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.bg generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.bg(x)

## S4 method for signature 'ENMevaluation'
eval.bg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.bg_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.bg.grp'>eval.bg.grp generic for ENMevaluation object</h2><span id='topic+eval.bg.grp'></span><span id='topic+eval.bg.grp+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.bg.grp generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.bg.grp(x)

## S4 method for signature 'ENMevaluation'
eval.bg.grp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.bg.grp_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.clamp.directions'>eval.clamp.directions generic for ENMevaluation object</h2><span id='topic+eval.clamp.directions'></span><span id='topic+eval.clamp.directions+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.clamp.directions generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.clamp.directions(x)

## S4 method for signature 'ENMevaluation'
eval.clamp.directions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.clamp.directions_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.doClamp'>eval.doClamp generic for ENMevaluation object</h2><span id='topic+eval.doClamp'></span><span id='topic+eval.doClamp+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.doClamp generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.doClamp(x)

## S4 method for signature 'ENMevaluation'
eval.doClamp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.doClamp_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.models'>eval.models generic for ENMevaluation object</h2><span id='topic+eval.models'></span><span id='topic+eval.models+2CENMevaluation-method'></span><span id='topic+eval.variable.importance+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.models generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.models(x)

## S4 method for signature 'ENMevaluation'
eval.models(x)

## S4 method for signature 'ENMevaluation'
eval.variable.importance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.models_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.occs'>eval.occs generic for ENMevaluation object</h2><span id='topic+eval.occs'></span><span id='topic+eval.occs+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.occs generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.occs(x)

## S4 method for signature 'ENMevaluation'
eval.occs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.occs_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.occs.grp'>eval.occs.grp generic for ENMevaluation object</h2><span id='topic+eval.occs.grp'></span><span id='topic+eval.occs.grp+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.occs.grp generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.occs.grp(x)

## S4 method for signature 'ENMevaluation'
eval.occs.grp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.occs.grp_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.occs.testing'>eval.occs.testing generic for ENMevaluation object</h2><span id='topic+eval.occs.testing'></span><span id='topic+eval.occs.testing+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.occs.testing generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.occs.testing(x)

## S4 method for signature 'ENMevaluation'
eval.occs.testing(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.occs.testing_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.other.settings'>eval.other.settings generic for ENMevaluation object</h2><span id='topic+eval.other.settings'></span><span id='topic+eval.other.settings+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.other.settings generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.other.settings(x)

## S4 method for signature 'ENMevaluation'
eval.other.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.other.settings_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.overlap'>eval.overlap generic for ENMevaluation object</h2><span id='topic+eval.overlap'></span><span id='topic+eval.overlap+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.overlap generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.overlap(x)

## S4 method for signature 'ENMevaluation'
eval.overlap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.overlap_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.partition.method'>eval.partition.method generic for ENMevaluation object</h2><span id='topic+eval.partition.method'></span><span id='topic+eval.partition.method+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.partition.method generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.partition.method(x)

## S4 method for signature 'ENMevaluation'
eval.partition.method(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.partition.method_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.partition.settings'>eval.partition.settings generic for ENMevaluation object</h2><span id='topic+eval.partition.settings'></span><span id='topic+eval.partition.settings+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.partition.settings generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.partition.settings(x)

## S4 method for signature 'ENMevaluation'
eval.partition.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.partition.settings_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.predictions'>eval.predictions generic for ENMevaluation object</h2><span id='topic+eval.predictions'></span><span id='topic+eval.predictions+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.predictions generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.predictions(x)

## S4 method for signature 'ENMevaluation'
eval.predictions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.predictions_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.results'>eval.results generic for ENMevaluation object</h2><span id='topic+eval.results'></span><span id='topic+eval.results+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.results generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.results(x)

## S4 method for signature 'ENMevaluation'
eval.results(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.results_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.results.partitions'>eval.results.partitions generic for ENMevaluation object</h2><span id='topic+eval.results.partitions'></span><span id='topic+eval.results.partitions+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.results.partitions generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.results.partitions(x)

## S4 method for signature 'ENMevaluation'
eval.results.partitions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.results.partitions_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.rmm'>eval.rmm generic for ENMevaluation object</h2><span id='topic+eval.rmm'></span><span id='topic+eval.rmm+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.rmm generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.rmm(x)

## S4 method for signature 'ENMevaluation'
eval.rmm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.rmm_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.taxon.name'>eval.taxon.name generic for ENMevaluation object</h2><span id='topic+eval.taxon.name'></span><span id='topic+eval.taxon.name+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.taxon.name generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.taxon.name(x)

## S4 method for signature 'ENMevaluation'
eval.taxon.name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.taxon.name_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.tune.settings'>eval.tune.settings generic for ENMevaluation object</h2><span id='topic+eval.tune.settings'></span><span id='topic+eval.tune.settings+2CENMevaluation-method'></span>

<h3>Description</h3>

<p>eval.tune.settings generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.tune.settings(x)

## S4 method for signature 'ENMevaluation'
eval.tune.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.tune.settings_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='eval.variable.importance'>eval.variable.importance (variable importance) generic for ENMevaluation object</h2><span id='topic+eval.variable.importance'></span>

<h3>Description</h3>

<p>eval.variable.importance (variable importance) generic for ENMevaluation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.variable.importance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.variable.importance_+3A_x">x</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
</table>

<hr>
<h2 id='evalplot.envSim.hist'>Similarity histogram plots for partition groups</h2><span id='topic+evalplot.envSim.hist'></span>

<h3>Description</h3>

<p>Plots environmental similarity of reference partitions (occurrences or 
background) to remaining data (occurrence and background for all other partitions). This 
function does not use raster data, and thus only calculates similarity values for data used 
in model training. Further, this function does not calculate similarity for categorical 
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalplot.envSim.hist(
  e = NULL,
  occs.z = NULL,
  bg.z = NULL,
  occs.grp = NULL,
  bg.grp = NULL,
  ref.data = "occs",
  sim.type = "mess",
  categoricals = NULL,
  envs.vars = NULL,
  occs.testing.z = NULL,
  hist.bins = 30,
  return.tbl = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalplot.envSim.hist_+3A_e">e</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_occs.z">occs.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for occurrence records, in that order (optional);
the first two columns must be named &quot;longitude&quot; and &quot;latitude&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_bg.z">bg.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for background records, in that order (optional);
the first two columns must be named &quot;longitude&quot; and &quot;latitude&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_occs.grp">occs.grp</code></td>
<td>
<p>numeric vector: partition groups for occurrence records (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_bg.grp">bg.grp</code></td>
<td>
<p>numeric vector: partition groups for background records (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_ref.data">ref.data</code></td>
<td>
<p>character: the reference to calculate MESS based on occurrences (&quot;occs&quot;) or background (&quot;bg&quot;), with default &quot;occs&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_sim.type">sim.type</code></td>
<td>
<p>character: either &quot;mess&quot; for Multivariate Environmental Similarity Surface, &quot;most_diff&quot; for most different variable,
or &quot;most_sim&quot; for most similar variable; uses similarity function from package rmaxent</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_categoricals">categoricals</code></td>
<td>
<p>character vector: names of categorical variables in input RasterStack or data frames to be removed from the analysis;
these must be specified as this function was intended for use with continuous data only; these must be specified when inputting tabular data instead of an ENMevaluation object</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_envs.vars">envs.vars</code></td>
<td>
<p>character vector: names of a predictor variable to plot similarities for; if left NULL, calculations are done
with respect to all variables (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_occs.testing.z">occs.testing.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for fully withheld testing records, 
in that order; this is for use only with the &quot;testing&quot; partition option when an ENMevaluation object is not input (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_hist.bins">hist.bins</code></td>
<td>
<p>numeric: number of histogram bins for histogram plots; default is 30</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_return.tbl">return.tbl</code></td>
<td>
<p>boolean: if TRUE, return the data frames of similarity values used to make the ggplot instead of the plot itself</p>
</td></tr>
<tr><td><code id="evalplot.envSim.hist_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When fully withheld testing groups are used, make sure to input either an 
ENMevaluation object or the argument occs.testing.z. In the resulting plot, partition 1 
refers to the training data, while partition 2 refers to the fully withheld testing group.
</p>
<p>Histograms are plotted showing the environmental similarity estimates for each 
partition group. The similarity between environmental values associated with the 
validation occurrence or background records per partition group and those associated with 
the remaining data (occurrences and background) are calculated, and the minimum similarity 
per grid is returned. For option &quot;mess&quot;, higher negative values indicate greater 
environmental difference between the validation occurrences and the study extent, and higher 
positive values indicate greater similarity. This function uses the 'similarity()' function 
from the package 'rmaxent' (https://github.com/johnbaums/rmaxent/) to calculate the 
similarities. Please see the below reference for details on MESS.
</p>


<h3>Value</h3>

<p>A ggplot of environmental similarities between the occurrence or background data 
for each partition and the rest of the data (all other occurrences and background data).
</p>


<h3>References</h3>

<p>Baumgartner J, Wilson P (2021). _rmaxent: Tools for working with Maxent in R_. R package version 0.8.5.9000, &lt;URL: https://github.com/johnbaums/rmaxent&gt;.
Elith, J., Kearney, M., and Phillips, S. (2010) The art of modelling range-shifting species. <em>Methods in Ecology and Evolution</em>, <b>1</b>: 330-342. <a href="https://doi.org/10.1111/j.2041-210X.2010.00036.x">doi:10.1111/j.2041-210X.2010.00036.x</a>
</p>

<hr>
<h2 id='evalplot.envSim.map'>Similarity maps for partition groups</h2><span id='topic+evalplot.envSim.map'></span>

<h3>Description</h3>

<p>Maps environmental similarity of reference partitions (occurrences or 
background) to all cells with values in the predictor variable rasters. This function uses 
raster data, and thus cannot map similarity values using only tables of environmental values f
or occurrences or background. Further, this function does not calculate similarity for 
categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalplot.envSim.map(
  e = NULL,
  envs,
  occs.z = NULL,
  bg.z = NULL,
  occs.grp = NULL,
  bg.grp = NULL,
  ref.data = "occs",
  sim.type = "mess",
  categoricals = NULL,
  envs.vars = NULL,
  bb.buf = 0,
  occs.testing.z = NULL,
  plot.bg.pts = FALSE,
  sim.palette = NULL,
  pts.size = 1.5,
  gradient.colors = c("red", "white", "blue"),
  na.color = "gray",
  return.tbl = FALSE,
  return.ras = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalplot.envSim.map_+3A_e">e</code></td>
<td>
<p>ENMevaluation object (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variables used to build the models in &quot;e&quot;; categorical variables should be 
removed before input or identified with the argument &quot;categoricals&quot;, as they cannot be used to calculate MESS</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_occs.z">occs.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for occurrence records, in that order (optional);
the first two columns must be named &quot;longitude&quot; and &quot;latitude&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_bg.z">bg.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for background records, in that order (optional);
the first two columns must be named &quot;longitude&quot; and &quot;latitude&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_occs.grp">occs.grp</code></td>
<td>
<p>numeric vector: partition groups for occurrence records (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_bg.grp">bg.grp</code></td>
<td>
<p>numeric vector: partition groups for background records (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_ref.data">ref.data</code></td>
<td>
<p>character: the reference to calculate MESS based on occurrences (&quot;occs&quot;) or background (&quot;bg&quot;), with default &quot;occs&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_sim.type">sim.type</code></td>
<td>
<p>character: either &quot;mess&quot; for Multivariate Environmental Similarity Surface, &quot;most_diff&quot; for most different variable,
or &quot;most_sim&quot; for most similar variable; uses similarity function from package rmaxent</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_categoricals">categoricals</code></td>
<td>
<p>character vector: names of categorical variables in input RasterStack or data frames to be removed from the analysis;
these must be specified as this function was intended for use with continuous data only</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_envs.vars">envs.vars</code></td>
<td>
<p>character vector: names of a predictor variable to plot similarities for; if left NULL, calculations are done
with respect to all variables (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_bb.buf">bb.buf</code></td>
<td>
<p>numeric: distance used to buffer (extend) the mapping extent in map units; for latitude/longitude, this is in degrees (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_occs.testing.z">occs.testing.z</code></td>
<td>
<p>data frame: longitude, latitude, and environmental predictor variable values for fully withheld testing records, 
in that order; this is for use only with the &quot;testing&quot; partition option when an ENMevaluation object is not input (optional)</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_plot.bg.pts">plot.bg.pts</code></td>
<td>
<p>boolean: if TRUE, plot background points when using ref.data = &quot;bg&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_sim.palette">sim.palette</code></td>
<td>
<p>character: RColorBrewer palette name to use for plotting discrete variables; if NULL, default is &quot;Set1&quot;</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_pts.size">pts.size</code></td>
<td>
<p>numeric: custom point size for ggplot</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_gradient.colors">gradient.colors</code></td>
<td>
<p>character vector: colors used for ggplot2::scale_fill_gradient2</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_na.color">na.color</code></td>
<td>
<p>character: color used for NA values</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_return.tbl">return.tbl</code></td>
<td>
<p>boolean: if TRUE, return the data frames of similarity values used to make the ggplot instead of the plot itself</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_return.ras">return.ras</code></td>
<td>
<p>boolean: if TRUE, return the RasterStack of similarity values used to make the ggplot instead of the plot itself</p>
</td></tr>
<tr><td><code id="evalplot.envSim.map_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When fully withheld testing groups are used, make sure to input either an ENMevaluation 
object or the argument occs.testing.z. In the resulting plot, partition 1 refers to the training data,
while partition 2 refers to the fully withheld testing group.
</p>
<p>Rasters are plotted showing the environmental similarity estimates for each 
partition group. The similarity between environmental values associated with the 
validation occurrence or background records per partition group and those associated with 
the entire study extent (specified by the extent of the input RasterStack &quot;envs&quot;) are 
calculated, and the minimum similarity per grid is returned. For option &quot;mess&quot;, higher 
negative values indicate greater environmental difference between the validation occurrences 
and the study extent, and higher positive values indicate greater similarity. This function 
uses the 'similarity()' function from the package 'rmaxent' 
(https://github.com/johnbaums/rmaxent/) to calculate the similarities. Please see the below 
reference for details on MESS.
</p>


<h3>Value</h3>

<p>A ggplot of environmental similarities between the occurrence or background data 
for each partition and all predictor variable values in the extent.
</p>


<h3>References</h3>

<p>Baumgartner J, Wilson P (2021). _rmaxent: Tools for working with Maxent in R_. R package version 0.8.5.9000, &lt;URL: https://github.com/johnbaums/rmaxent&gt;.
Elith, J., Kearney, M., and Phillips, S. (2010) The art of modelling range-shifting species. <em>Methods in Ecology and Evolution</em>, <b>1</b>: 330-342. <a href="https://doi.org/10.1111/j.2041-210X.2010.00036.x">doi:10.1111/j.2041-210X.2010.00036.x</a>
</p>

<hr>
<h2 id='evalplot.grps'>Partition group plots</h2><span id='topic+evalplot.grps'></span>

<h3>Description</h3>

<p>Plot occurrence partition groups over an environmental predictor raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalplot.grps(
  e = NULL,
  envs,
  pts = NULL,
  pts.grp = NULL,
  ref.data = "occs",
  pts.size = 1.5,
  return.tbl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalplot.grps_+3A_e">e</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variable used to build the models in &quot;e&quot;</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_pts">pts</code></td>
<td>
<p>matrix / data frame: coordinates for occurrence or background data</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_pts.grp">pts.grp</code></td>
<td>
<p>numeric vector: partition groups corresponding to data in &quot;pts&quot;</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_ref.data">ref.data</code></td>
<td>
<p>character: plot occurrences (&quot;occs&quot;) or background (&quot;bg&quot;), with default &quot;occs&quot;</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_pts.size">pts.size</code></td>
<td>
<p>numeric: custom point size for ggplot</p>
</td></tr>
<tr><td><code id="evalplot.grps_+3A_return.tbl">return.tbl</code></td>
<td>
<p>boolean: if TRUE, return the data frames used to make the ggplot instead of the plot itself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a quick way to visualize occurrence or background partitions over the extent of an environmental predictor raster.
It can be run with an existing ENMevaluation object, or alternatively with occurrence or background coordinates and the corresponding partitions.
</p>

<hr>
<h2 id='evalplot.nulls'>ENMnulls statistics plot</h2><span id='topic+evalplot.nulls'></span>

<h3>Description</h3>

<p>Plot histogram of evaluation statistics for null ENM simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalplot.nulls(
  e.null,
  stats,
  plot.type,
  facet.labels = NULL,
  metric.levels = NULL,
  return.tbl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalplot.nulls_+3A_e.null">e.null</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
<tr><td><code id="evalplot.nulls_+3A_stats">stats</code></td>
<td>
<p>character vector: metrics from results table to be plotted; examples are
&quot;auc.val&quot; or &quot;or.10p&quot;; if more than one statistic is specified, the histogram plot will be faceted</p>
</td></tr>
<tr><td><code id="evalplot.nulls_+3A_plot.type">plot.type</code></td>
<td>
<p>character: either &quot;violin&quot; or &quot;histogram&quot;</p>
</td></tr>
<tr><td><code id="evalplot.nulls_+3A_facet.labels">facet.labels</code></td>
<td>
<p>named list: custom names for the metric facets, in the form list(old_name = &quot;new_name&quot;, ...)</p>
</td></tr>
<tr><td><code id="evalplot.nulls_+3A_metric.levels">metric.levels</code></td>
<td>
<p>character vector: custom factor levels for metrics; this controls the order that metric statistics are plotted</p>
</td></tr>
<tr><td><code id="evalplot.nulls_+3A_return.tbl">return.tbl</code></td>
<td>
<p>boolean: if TRUE, return the data frames of null results used to make the ggplot instead of the plot itself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two variations for this plot, but both show null quantiles (0.01, 0.05, 0.5, 0.95, 0.99). 
For violin plots, the null distribution is displayed as a vertical shape (i.e., the violin) with horizontal lines showing 
the quantiles and the empirical value is plotted as a red point along the vertical axis. 
For histogram plots, the null distribution is displayed as a histogram with vertical lines showing the quantiles 
and the empirical value as a vertical red line on the distribution.
</p>


<h3>Value</h3>

<p>A ggplot of null model statistics.
</p>

<hr>
<h2 id='evalplot.stats'>ENMevaluation statistics plot</h2><span id='topic+evalplot.stats'></span>

<h3>Description</h3>

<p>Plot evaluation statistics over tuning parameter ranges to visualize differences in performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalplot.stats(
  e,
  stats,
  x.var,
  color.var,
  dodge = NULL,
  error.bars = TRUE,
  facet.labels = NULL,
  metric.levels = NULL,
  return.tbl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalplot.stats_+3A_e">e</code></td>
<td>
<p>ENMevaluation object</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_stats">stats</code></td>
<td>
<p>character vector: names of statistics from results table to be plotted; if more than
one statistic is specified, the plot will be faceted</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_x.var">x.var</code></td>
<td>
<p>character: variable to be plotted on x-axis</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_color.var">color.var</code></td>
<td>
<p>character: variable used to assign symbology colors</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_dodge">dodge</code></td>
<td>
<p>numeric: dodge width for points and lines; this improves visibility when there is high overlap (optional)</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_error.bars">error.bars</code></td>
<td>
<p>boolean: if TRUE, plot error bars</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_facet.labels">facet.labels</code></td>
<td>
<p>character vector: custom names for the metric facets</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_metric.levels">metric.levels</code></td>
<td>
<p>character vector: custom factor levels for metrics; this controls the order that metric statistics are plotted</p>
</td></tr>
<tr><td><code id="evalplot.stats_+3A_return.tbl">return.tbl</code></td>
<td>
<p>boolean: if TRUE, return the data frames of results used to make the ggplot instead of the plot itself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this plot, the x-axis represents a tuning parameter range, while the y-axis represents the average of a statistic over all partitions.
Different colors represent the categories or values of another tuning parameter. 
Error bars represent the standard deviation of a statistic around the mean. 
Currently, this function can only plot two tuning parameters at a time.
</p>


<h3>Value</h3>

<p>A ggplot of evaluation statistics.
</p>

<hr>
<h2 id='lookup.enm'>Look up ENMdetails abject</h2><span id='topic+lookup.enm'></span>

<h3>Description</h3>

<p>Internal function to look up ENMdetails objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup.enm(algorithm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup.enm_+3A_algorithm">algorithm</code></td>
<td>
<p>character: algorithm name (must be implemented as ENMdetails object)</p>
</td></tr>
</table>

<hr>
<h2 id='maxentJARversion'>Look up version of maxent.jar</h2><span id='topic+maxentJARversion'></span>

<h3>Description</h3>

<p>Internal function to look up the version of the maxent.jar being used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxentJARversion()
</code></pre>

<hr>
<h2 id='null.algorithm'>null.algorithm generic for ENMnull object</h2><span id='topic+null.algorithm'></span><span id='topic+null.algorithm+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.algorithm generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.algorithm(x)

## S4 method for signature 'ENMnull'
null.algorithm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.algorithm_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.doClamp'>null.doClamp generic for ENMnull object</h2><span id='topic+null.doClamp'></span><span id='topic+null.doClamp+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.doClamp generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.doClamp(x)

## S4 method for signature 'ENMnull'
null.doClamp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.doClamp_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.emp.results'>null.emp.results generic for ENMnull object</h2><span id='topic+null.emp.results'></span><span id='topic+null.emp.results+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.emp.results generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.emp.results(x)

## S4 method for signature 'ENMnull'
null.emp.results(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.emp.results_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.mod.settings'>null.mod.settings generic for ENMnull object</h2><span id='topic+null.mod.settings'></span><span id='topic+null.mod.settings+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.mod.settings generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.mod.settings(x)

## S4 method for signature 'ENMnull'
null.mod.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.mod.settings_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.no.iter'>null.no.iter generic for ENMnull object</h2><span id='topic+null.no.iter'></span><span id='topic+null.no.iter+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.no.iter generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.no.iter(x)

## S4 method for signature 'ENMnull'
null.no.iter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.no.iter_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.other.settings'>null.other.settings generic for ENMnull object</h2><span id='topic+null.other.settings'></span><span id='topic+null.other.settings+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.other.settings generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.other.settings(x)

## S4 method for signature 'ENMnull'
null.other.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.other.settings_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.partition.method'>null.partition.method generic for ENMnull object</h2><span id='topic+null.partition.method'></span><span id='topic+null.partition.method+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.partition.method generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.partition.method(x)

## S4 method for signature 'ENMnull'
null.partition.method(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.partition.method_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.partition.settings'>null.partition.settings generic for ENMnull object</h2><span id='topic+null.partition.settings'></span><span id='topic+null.partition.settings+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.partition.settings generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.partition.settings(x)

## S4 method for signature 'ENMnull'
null.partition.settings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.partition.settings_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.results'>null.results generic for ENMnull object</h2><span id='topic+null.results'></span><span id='topic+null.results+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.results generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.results(x)

## S4 method for signature 'ENMnull'
null.results(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.results_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='null.results.partitions'>null.results.partitions generic for ENMnull object</h2><span id='topic+null.results.partitions'></span><span id='topic+null.results.partitions+2CENMnull-method'></span>

<h3>Description</h3>

<p>null.results.partitions generic for ENMnull object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.results.partitions(x)

## S4 method for signature 'ENMnull'
null.results.partitions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.results.partitions_+3A_x">x</code></td>
<td>
<p>ENMnull object</p>
</td></tr>
</table>

<hr>
<h2 id='partitions'>Methods to partition data for evaluation</h2><span id='topic+partitions'></span><span id='topic+get.block'></span><span id='topic+get.checkerboard1'></span><span id='topic+get.checkerboard2'></span><span id='topic+get.jackknife'></span><span id='topic+get.randomkfold'></span>

<h3>Description</h3>

<p><span class="pkg">ENMeval</span> provides several ways to partition occurrence and background localities into bins for training and validation (or, evaluation and calibration). 
Users should carefully consider the objectives of their study and the influence of spatial bias when deciding on a method of data partitioning.
</p>
<p>These functions are used internally to partition data during a call of <code><a href="#topic+ENMevaluate">ENMevaluate</a></code> but can also be used independently to generate data partitions. 
For user-specified partitions, users can simply define groups of occurrence records and background points directly with <code>ENMevaluate</code>.
</p>
<p>The <code>get.block</code> method partitions occurrence localities by finding the latitude and/or longitude lines that divide the occurrence localities into four groups of (insofar as possible) equal numbers.
The order and nature of the divisions can be controlled with the &quot;orientation&quot; parameter.
The default is &quot;lat_lon&quot;, which divides first by a latitudinal line, then second by longitudinal lines.
This method is based on the spatial partitioning technique described in Radosavljevic &amp; Anderson (2014), where the &quot;lon_lon&quot; option was used.
Background localities are assigned to each of the four groups based on their position with respect to these lines. 
While the <code>get.block</code> method results in (approximately) equal division of occurrence localities among four groups, the number of background localities (and, consequently, environmental and geographic space) in each group depends on the distribution of occurrence localities across the study area.
</p>
<p>The <code>get.checkerboard1</code> and <code>get.checkerboard2</code> methods are variants of a checkerboard approach to partition occurrence localities. 
These methods use the <code>dismo::gridSample</code> function of the <span class="pkg">dismo</span> package (Hijmans <em>et al.</em> 2011) to partition records according to checkerboard grids across the study extent. 
The spatial grain of these grids is determined by resampling (or aggregating) the original environmental input grids based on the user-defined <code>aggregation factor</code> (e.g., an aggregation factor of 2 results in a checkerboard with grid cells four times as large in area as the original input grids). 
The <code>get.checkerboard1</code> method partitions data into two groups according to a single checkerboard pattern, and the <code>get.checkerboard2</code> method partitions data into four groups according to two nested checkerboard grids. 
In contrast to the <code>get.block</code> method, both the <code>get.checkerboard1</code> and <code>get.checkerboard2</code> methods subdivide geographic space equally but do not ensure a balanced number of occurrence localities in each group. 
The two <code>get.checkerboard</code> methods give warnings (and potentially errors) if zero points (occurrence or background) fall in any of the expected bins.
</p>
<p>The <code>get.jackknife</code> method is a special case of <em>k</em>-fold cross validation where the number of bins (<em>k</em>) is equal to the number of occurrence localities (<em>n</em>) in the dataset. 
It is suggested for occurrence datasets of relatively small sample size (generally &lt; 25 localities) (Pearson <em>et al.</em> 2007; Shcheglovitova and Anderson 2013).
</p>
<p>The <code>get.randomkfold</code> method partitions occurrence localities randomly into a user-specified number of (<em>k</em>) bins. 
This is equivalent to the method of <em>k</em>-fold cross validation currently provided by Maxent. 
</p>
<p>Users can also define custom partitions for occurrence and background data in the call to 'ENMevaluate' with the &quot;user.grp&quot; parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.block(occs, bg, orientation = "lat_lon")

get.checkerboard1(occs, envs, bg, aggregation.factor, gridSampleN = 10000)

get.checkerboard2(occs, envs, bg, aggregation.factor, gridSampleN = 10000)

get.jackknife(occs, bg)

get.randomkfold(occs, bg, kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitions_+3A_occs">occs</code></td>
<td>
<p>matrix / data frame: longitude and latitude (in that order) of occurrence localities</p>
</td></tr>
<tr><td><code id="partitions_+3A_bg">bg</code></td>
<td>
<p>matrix / data frame: longitude and latitude (in that order) of background localities</p>
</td></tr>
<tr><td><code id="partitions_+3A_orientation">orientation</code></td>
<td>
<p>character vector: the order of spatial partitioning for the <code>get.block</code> method;
the first direction bisects the points into two groups, and the second direction bisects each of these further into two groups each, resulting in four groups; 
options are &quot;lat_lon&quot; (default), &quot;lon_lat&quot;, &quot;lon_lon&quot;, and &quot;lat_lat&quot;</p>
</td></tr>
<tr><td><code id="partitions_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variables</p>
</td></tr>
<tr><td><code id="partitions_+3A_aggregation.factor">aggregation.factor</code></td>
<td>
<p>numeric vector: the aggregation scale for the <code>get.checkerboard1</code> and <code>get.checkerboard2</code> methods;
if a single number is given and <code>get.checkerboard2</code> partitioning method is used, the single value is used for both scales of aggregation</p>
</td></tr>
<tr><td><code id="partitions_+3A_gridsamplen">gridSampleN</code></td>
<td>
<p>numeric: the number of points sampled from the input raster using gridSample() by the checkerboard partitioning functions</p>
</td></tr>
<tr><td><code id="partitions_+3A_kfolds">kfolds</code></td>
<td>
<p>numeric: number of random <em>k</em>-folds for <code>get.randomkfold</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of two items:
</p>
<table>
<tr><td><code>$occs.grp</code></td>
<td>
<p> A vector of bin designation for occurrence localities in the same order they were provided.</p>
</td></tr>
<tr><td><code>$bg.grp</code></td>
<td>
<p> A vector of bin designation for background localities in the same order they were provided.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>checkerboard1</code> and <code>checkerboard2</code> methods are designed to partition occurrence localities into two and four evaluation bins, respectively. 
They may give fewer bins, however, depending on where the occurrence localities fall with respect to the grid cells (e.g., all records happen to fall in the &quot;black&quot; squares). 
A warning is given if the number of bins is &lt; 4 for the <code>checkerboard2</code> method, and an error is given if all localities fall into a single evaluation bin.
</p>


<h3>Author(s)</h3>

<p>Robert Muscarella &lt;bob.muscarella@gmail.com&gt; and Jamie M. Kass &lt;jkass@gc.cuny.edu&gt;
</p>


<h3>References</h3>

<p>Hijmans, R. J., Phillips, S., Leathwick, J. and Elith, J. (2011). dismo package for R. Available online at: <a href="https://cran.r-project.org/package=dismo">https://cran.r-project.org/package=dismo</a>.
</p>
<p>Pearson, R. G., Raxworthy, C. J., Nakamura, M. and Peterson, A. T. (2007). Predicting species distributions from small numbers of occurrence records: a test case using cryptic geckos in Madagascar. <em>Journal of Biogeography</em>, <b>34</b>: 102-117. <a href="https://doi.org/10.1111/j.1365-2699.2006.01594.x">doi:10.1111/j.1365-2699.2006.01594.x</a>
</p>
<p>Radosavljevic, A., &amp; Anderson, R. P. (2014). Making better Maxent models of species distributions: complexity, overfitting and evaluation. <em>Journal of Biogeography</em>, <b>41</b>: 629-643. <a href="https://doi.org/10.1111/jbi.12227">doi:10.1111/jbi.12227</a>
</p>
<p>Shcheglovitova, M. and Anderson, R. P. (2013). Estimating optimal complexity for ecological niche models: a jackknife approach for species with small sample sizes. <em>Ecological Modelling</em>, <b>269</b>: 9-17. <a href="https://doi.org/10.1016/j.ecolmodel.2013.08.011">doi:10.1016/j.ecolmodel.2013.08.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(raster)

set.seed(1)

### Create environmental extent (raster)
envs &lt;- raster(matrix(nrow=25, ncol=25))

### Create occurrence localities
set.seed(1)
nocc &lt;- 25
xocc &lt;- rnorm(nocc, sd=0.25) + 0.5
yocc &lt;- runif(nocc, 0, 1)
occs &lt;- as.data.frame(cbind(xocc, yocc))

### Create background points
nbg &lt;- 500
xbg &lt;- runif(nbg, 0, 1)
ybg &lt;- runif(nbg, 0, 1)
bg &lt;- as.data.frame(cbind(xbg, ybg))

### Plot points on environmental raster
plot(envs)
points(bg)
points(occs, pch=21, bg=2)

### Block partitioning method (default orientation is "lat_lon"))
blk.latLon &lt;- get.block(occs, bg)
plot(envs)
points(occs, pch=23, bg=blk.latLon$occs.grp)
plot(envs)
points(bg, pch=21, bg=blk.latLon$bg.grp)
# Can partition with other orientations
blk.latLat &lt;- get.block(occs, bg, orientation = "lat_lat")
plot(envs)
points(occs, pch=23, bg=blk.latLat$occs.grp)
plot(envs)
points(bg, pch=21, bg=blk.latLat$bg.grp)

### Checkerboard1 partitioning method with aggregation factor of 4
chk1.ag4 &lt;- get.checkerboard1(occs, envs, bg, aggregation.factor = 4)
plot(envs)
points(occs, pch=23, bg=chk1.ag4$occs.grp)
plot(envs)
points(bg, pch=21, bg=chk1.ag4$bg.grp)
# Higher aggregation factors result in bigger checkerboard blocks
chk1.ag8 &lt;- get.checkerboard1(occs, envs, bg, aggregation.factor = 8)
plot(envs)
points(occs, pch=23, bg=chk1.ag8$occs.grp)
plot(envs)
points(bg, pch=21, bg=chk1.ag8$bg.grp)

### Checkerboard2 partitioning method with aggregation factors of 2, 2
chk2.ag2_2 &lt;- get.checkerboard2(occs, envs, bg, c(2,2))
plot(envs)
points(occs, pch=23, bg=chk2.ag2_2$occs.grp)
plot(envs)
points(bg, pch=21, bg=chk2.ag2_2$bg.grp)
# Higher aggregation factors result in bigger checkerboard blocks,
# and can vary between hierarchical levels
chk2.ag4_6 &lt;- get.checkerboard2(occs, envs, bg, c(4,6))
plot(envs)
points(occs, pch=23, bg=chk2.ag4_6$occs.grp)
plot(envs)
points(bg, pch=21, bg=chk2.ag4_6$bg.grp)

### Random partitions with 4 folds
# Note that get.randomkkfold does not partition the background
krandom &lt;- get.randomkfold(occs, bg, 4)
plot(envs)
points(occs, pch=23, bg=krandom$occs.grp)
plot(envs)
points(bg, pch=21, bg=krandom$bg.grp)

### k-1 jackknife partitions
# Note that get.jackknife does not partition the background
jack &lt;- get.jackknife(occs, bg)
plot(envs)
points(occs, pch=23, bg=rainbow(length(jack$occs.grp)))
plot(envs)
points(bg, pch=21, bg=jack$bg.grp)

</code></pre>

<hr>
<h2 id='rasStackNAs'>Find NA cells in a RasterStack</h2><span id='topic+rasStackNAs'></span>

<h3>Description</h3>

<p>Finds cells that are NA for at least one raster in a RasterStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasStackNAs(envs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasStackNAs_+3A_envs">envs</code></td>
<td>
<p>RasterStack</p>
</td></tr>
</table>

<hr>
<h2 id='similarity'>Calculate Multivariate Environmental Similarity</h2><span id='topic+similarity'></span>

<h3>Description</h3>

<p>NOTICE: This function was borrowed from the rmaxent package written by John Baumgartner (https://github.com/johnbaums/rmaxent/).
</p>
<p>Calculate Multivariate Environmental Similarity and most dissimilar/similar 
variables with respect to a reference dataset, for a set of environmental 
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(x, ref, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_x">x</code></td>
<td>
<p>a 'Raster*', 'list', 'matrix', or 'data.frame'
where each layer/column/element represents focal values of an environmental
variable.</p>
</td></tr>
<tr><td><code id="similarity_+3A_ref">ref</code></td>
<td>
<p>a 'list', 'matrix', or 'data.frame' where each
column/element represents reference values for an environmental variable
(corresponding to those given in 'x').</p>
</td></tr>
<tr><td><code id="similarity_+3A_full">full</code></td>
<td>
<p>(logical) should similarity values be returned for all variables?
If 'FALSE' (the default), then only the minimum similarity scores
across variables will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'similarity' uses the MESS algorithm described in Appendix S3
of Elith <em>et al.</em> 2010.
</p>


<h3>Value</h3>

<p>If 'x' is a 'Raster*' object, this function returns a list 
containing:
- 'similarity': a 'RasterStack' giving the environmental similarities for
each variable in 'x' (only included when 'full=TRUE'); 
- 'similarity_min': a 'Raster' layer giving the minimum similarity value 
across all variables for each location (i.e. the MESS);
- 'mod': a factor 'Raster' layer indicating which variable was most 
dissimilar to its reference range (i.e. the MoD map, Elith <em>et al.</em> 2010); 
and
- 'mos': a factor 'Raster' layer indicating which variable was most 
similar to its reference range.
</p>
<p>If 'x' is a 'list', 'matrix', or 'data.frame', the function will return
a list as above, but with 'RasterStack' and 'Raster' objects replaced by 
matrix and vectors.
</p>


<h3>References</h3>

<p>Elith, J., Kearney, M., and Phillips, S. (2010) The art of modelling range-shifting species. <em>Methods in Ecology and Evolution</em>, <b>1</b>: 330-342. <a href="https://doi.org/10.1111/j.2041-210X.2010.00036.x">doi:10.1111/j.2041-210X.2010.00036.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dismo)
library(raster)
ff &lt;- list.files(system.file('ex', package='dismo'), '\\.grd$', 
                 full.names=TRUE )
predictors &lt;- stack(grep('biome', ff, value=TRUE, invert=TRUE))
occ &lt;- read.csv(system.file('ex/bradypus.csv', package='dismo'))[, -1]
ref &lt;- extract(predictors, occ)
mess &lt;- similarity(predictors, ref, full=TRUE)

## Not run: 
library(rasterVis)
library(RColorBrewer)
levelplot(mess$mod, col.regions=brewer.pal(8, 'Set1'))
levelplot(mess$mos, col.regions=brewer.pal(8, 'Set1'))

## End(Not run)
</code></pre>

<hr>
<h2 id='tune.enm'>Iterate tuning of ENMs</h2><span id='topic+tune.enm'></span><span id='topic+tune.parallel'></span><span id='topic+tune.regular'></span><span id='topic+cv.enm'></span><span id='topic+tune.train'></span><span id='topic+tune.validate'></span>

<h3>Description</h3>

<p>Internal functions to tune and summarize results for ecological niche models (ENMs) iteratively across a range of user-specified tuning settings. 
See <a href="#topic+ENMevaluate">ENMevaluate</a> for descriptions of shared arguments.
Function <code>tune.parallel()</code> tunes ENMs with parallelization. Function <code>cv.enm()</code> calculates training and validation evaluation statistics for one set of specified tuning parameters.
</p>
<p>Validation CBI is calculated here with background values, not raster data, in order
to standardize the methodology for both training and validation data for spatial partitions, as ENMeval
does not mask rasters to partition areas and hence does not have partitioned raster data. Further, 
predictions for occurrence and background localities are combined as input for the parameter &quot;fit&quot; in 
<code>ecospat::ecospat_boyce()</code> because the interval is determined from &quot;fit&quot; only, and if test occurrences 
all have higher predictions than the background, the interval will be cut short.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.train(
  enm,
  occs.z,
  bg.z,
  mod.full,
  envs,
  tune.tbl.i,
  other.settings,
  partitions,
  quiet
)

tune.validate(
  enm,
  occs.train.z,
  occs.val.z,
  bg.train.z,
  bg.val.z,
  mod.k,
  nk,
  tune.tbl.i,
  other.settings,
  partitions,
  user.eval,
  quiet
)

tune.parallel(
  d,
  envs,
  enm,
  partitions,
  tune.tbl,
  doClamp,
  other.settings,
  partition.settings,
  user.val.grps,
  occs.testing.z,
  numCores,
  parallelType,
  user.eval,
  algorithm,
  quiet
)

tune.regular(
  d,
  envs,
  enm,
  partitions,
  tune.tbl,
  doClamp,
  other.settings,
  partition.settings,
  user.val.grps,
  occs.testing.z,
  updateProgress,
  user.eval,
  algorithm,
  quiet
)

cv.enm(
  d,
  envs,
  enm,
  partitions,
  tune.tbl.i,
  doClamp,
  other.settings,
  partition.settings,
  user.val.grps,
  occs.testing.z,
  user.eval,
  algorithm,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.enm_+3A_enm">enm</code></td>
<td>
<p><a href="#topic+ENMdetails">ENMdetails</a> object</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_occs.z">occs.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the full dataset occurrence records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_bg.z">bg.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the full dataset background records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_mod.full">mod.full</code></td>
<td>
<p>model object: the model trained on the full dataset</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_envs">envs</code></td>
<td>
<p>RasterStack: environmental predictor variables. These should be in same geographic projection as occurrence data.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_tune.tbl.i">tune.tbl.i</code></td>
<td>
<p>vector: single set of tuning parameters</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_other.settings">other.settings</code></td>
<td>
<p>named list: used to specify extra settings for the analysis. 
All of these settings have internal defaults, so if they are not specified the analysis will be run 
with default settings. See Details for descriptions of these settings, including how to specify arguments
for maxent.jar.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_partitions">partitions</code></td>
<td>
<p>character: name of partitioning technique (see <code>?partitions</code>)</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_quiet">quiet</code></td>
<td>
<p>boolean: if TRUE, silence all function messages (but not errors).</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_occs.train.z">occs.train.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the training occurrence records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_occs.val.z">occs.val.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the validation occurrence records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_bg.train.z">bg.train.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the training background records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_bg.val.z">bg.val.z</code></td>
<td>
<p>data.frame: the envs values for the coordinates at the validation background records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_mod.k">mod.k</code></td>
<td>
<p>model object: the model trained on the training dataset that becomes evaluated on the validation data</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_nk">nk</code></td>
<td>
<p>numeric: the number of folds (i.e., partitions) &ndash; will be equal to <code>kfolds</code> for random partitions</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_user.eval">user.eval</code></td>
<td>
<p>function: custom function for specifying performance metrics not included in <span class="pkg">ENMeval</span>.
The function must first be defined and then input as the argument <code>user.eval</code>. 
This function should have a single argument called <code>vars</code>, which is a list that includes different data 
that can be used to calculate the metric. See Details below and the vignette for a worked example.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_d">d</code></td>
<td>
<p>data frame: data frame from <code>ENMevaluate()</code> with occurrence and background coordinates (or coordinates plus predictor variable values) and partition group values</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_tune.tbl">tune.tbl</code></td>
<td>
<p>data frame: all combinations of tuning parameters</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_doclamp">doClamp</code></td>
<td>
<p>boolean: if TRUE (default), model prediction extrapolations will be restricted to the upper and lower
bounds of the predictor variables. Clamping avoids extreme predictions for environment values outside
the range of the training data. If free extrapolation is a study aim, this should be set to FALSE, but
for most applications leaving this at the default of TRUE is advisable to avoid unrealistic predictions. 
When predictor variables are input, they are clamped internally before making model predictions when clamping is on.
When no predictor variables are input and data frames of variable values are used instead (SWD format),
validation data is clamped before making model predictions when clamping is on.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_partition.settings">partition.settings</code></td>
<td>
<p>named list: used to specify certain settings for partitioning schema.
See Details and ?partitions for descriptions of these settings.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_user.val.grps">user.val.grps</code></td>
<td>
<p>matrix / data frame: user-defined validation record coordinates and predictor variable values. 
This is used internally by <code>ENMnulls()</code> to force each null model to evaluate with empirical validation data,
and does not have any current use when running <code>ENMevaluate()</code> independently.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_occs.testing.z">occs.testing.z</code></td>
<td>
<p>data.frame: when fully withheld testing data is provided, the envs values for the 
coordinates at the testing occurrence records</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_numcores">numCores</code></td>
<td>
<p>numeric: number of cores to use for parallel processing. If NULL, all available cores will be used.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_paralleltype">parallelType</code></td>
<td>
<p>character: either &quot;doParallel&quot; or &quot;doSNOW&quot; (default: &quot;doSNOW&quot;) .</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_algorithm">algorithm</code></td>
<td>
<p>character: name of the algorithm used to build models. Currently one of &quot;maxnet&quot;,
&quot;maxent.jar&quot;, or &quot;bioclim&quot;, else the name from a custom ENMdetails implementation.</p>
</td></tr>
<tr><td><code id="tune.enm_+3A_updateprogress">updateProgress</code></td>
<td>
<p>boolean: if TRUE, use shiny progress bar. This is only for use in shiny apps.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
