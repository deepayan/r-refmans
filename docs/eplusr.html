<!DOCTYPE html><html><head><title>Help for package eplusr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eplusr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_idf_object'><p>Add new objects</p></a></li>
<li><a href='#as_EpwDate'><p>Convert to EnergyPlus Weather File date</p></a></li>
<li><a href='#as.character.IddObject'><p>Coerce an IddObject into a Character Vector</p></a></li>
<li><a href='#as.character.Idf'><p>Coerce an Idf object into a Character Vector</p></a></li>
<li><a href='#as.character.IdfObject'><p>Coerce an IdfObject into a Character Vector</p></a></li>
<li><a href='#assign_idf_value_default'><p>Assign default field values</p></a></li>
<li><a href='#clean_wd'><p>Clean working directory of a previous EnergyPlus simulation</p></a></li>
<li><a href='#custom_validate'><p>Customize validation components</p></a></li>
<li><a href='#del_idf_object'><p>Delete existing objects</p></a></li>
<li><a href='#download_weather'><p>Download EnergyPlus Weather File (EPW) and Design Day File (DDY)</p></a></li>
<li><a href='#dt_to_load'><p>Format Long Table to Standard Input for <code>Idf$load()</code> Method</p></a></li>
<li><a href='#dup_idf_object'><p>Duplicate existing objects</p></a></li>
<li><a href='#duplicated_idf_object'><p>Determine duplicate objects</p></a></li>
<li><a href='#empty_idf'><p>Create an Empty Idf</p></a></li>
<li><a href='#eplus_sql'><p>Read an Energy SQLite Output File</p></a></li>
<li><a href='#EplusGroupJob'><p>Create and Run Parametric Analysis, and Collect Results</p></a></li>
<li><a href='#EplusJob'><p>Run EnergyPlus Simulation and Collect Outputs</p></a></li>
<li><a href='#eplusr_option'><p>Get and Set eplusr options</p></a></li>
<li><a href='#eplusr-package'><p>eplusr: A Toolkit for Using EnergyPlus in R</p></a></li>
<li><a href='#EplusSql'><p>Retrieve Simulation Outputs Using EnergyPlus SQLite Output File</p></a></li>
<li><a href='#EPMacro'><p>Run EnergyPlus and its various processors</p></a></li>
<li><a href='#Epw'><p>Read, and modify an EnergyPlus Weather File (EPW)</p></a></li>
<li><a href='#expand_idf_dots_literal'><p>Parse object values given in literal character vectors or data.frames</p></a></li>
<li><a href='#expand_idf_dots_name'><p>Parse object ID or name specifications given in list format</p></a></li>
<li><a href='#expand_idf_dots_object'><p>Parse object values given in a list of Idf or IdfObject format</p></a></li>
<li><a href='#expand_idf_dots_value'><p>Parse object field values given in list format</p></a></li>
<li><a href='#expand_idf_regex'><p>Parse regular expression of object field values</p></a></li>
<li><a href='#format.Idd'><p>Format an Idd</p></a></li>
<li><a href='#format.IddObject'><p>Format an IddObject</p></a></li>
<li><a href='#format.Idf'><p>Format an Idf Object</p></a></li>
<li><a href='#format.IdfObject'><p>Format an IdfObject</p></a></li>
<li><a href='#get_env'><p>Get the enclosed environment of an R6 object</p></a></li>
<li><a href='#get_idd_class'><p>Get class data</p></a></li>
<li><a href='#get_idd_field'><p>Get field data</p></a></li>
<li><a href='#get_idd_relation'><p>Get field relation data</p></a></li>
<li><a href='#get_idf_node_relation'><p>Extract node relations</p></a></li>
<li><a href='#get_idf_object'><p>Get object data</p></a></li>
<li><a href='#get_idf_relation'><p>Extract object and value reference relations</p></a></li>
<li><a href='#get_idf_table'><p>Extract value data in a data.table</p></a></li>
<li><a href='#get_idf_value'><p>Get value data</p></a></li>
<li><a href='#get_object_info'><p>Format object information string</p></a></li>
<li><a href='#Idd'><p>Parse, Query and Modify EnergyPlus Input Data Dictionary (IDD)</p></a></li>
<li><a href='#idd_object'><p>Create an <code>IddObject</code> object.</p></a></li>
<li><a href='#IddObject'><p>EnergyPlus IDD object</p></a></li>
<li><a href='#Idf'><p>Read, Modify, and Run an EnergyPlus Model</p></a></li>
<li><a href='#idf_object'><p>Create an <code>IdfObject</code> object.</p></a></li>
<li><a href='#IdfGeometry'><p>Modify and Visualize an EnergyPlus Model Geometry</p></a></li>
<li><a href='#IdfObject'><p>Create and Modify an EnergyPlus Object</p></a></li>
<li><a href='#IdfSchedule'><p>Create an <code>IdfScheduleCompact</code> object.</p></a></li>
<li><a href='#IdfViewer'><p>Visualize an EnergyPlus Model Geometry and Simulation Results</p></a></li>
<li><a href='#init_idf_object'><p>Initialize object data</p></a></li>
<li><a href='#init_idf_value'><p>Initialize value data</p></a></li>
<li><a href='#install_eplus'><p>Download and Install EnergyPlus</p></a></li>
<li><a href='#is_eplus_ver'><p>Check for Idd, Idf and Epw objects</p></a></li>
<li><a href='#level_checks'><p>Show components of validation strictness level</p></a></li>
<li><a href='#make_idf_object_name'><p>Initialize object data</p></a></li>
<li><a href='#ParametricJob'><p>Create and Run Parametric Analysis, and Collect Results</p></a></li>
<li><a href='#parse_dots_value'><p>Parse object field values given in list format</p></a></li>
<li><a href='#path_eplus'><p>Get file path from EnergyPlus installation directory</p></a></li>
<li><a href='#print.ErrFile'><p>Print EnergyPlus Error File</p></a></li>
<li><a href='#purge_idf_object'><p>Purge not-used resource objects</p></a></li>
<li><a href='#rdd_to_load'><p>Format RddFile Object to Standard Input for <code>Idf$load()</code> Method</p></a></li>
<li><a href='#read_epw'><p>Read and Parse EnergyPlus Weather File (EPW)</p></a></li>
<li><a href='#read_err'><p>Read an EnergyPlus Simulation Error File</p></a></li>
<li><a href='#read_idf'><p>Read an EnergyPlus Input Data File (IDF)</p></a></li>
<li><a href='#read_idfeditor_copy'><p>Parse objects from IDF Editor</p></a></li>
<li><a href='#read_rdd'><p>Read an EnergyPlus Report Data Dictionary File</p></a></li>
<li><a href='#reload'><p>Reload Idf data</p></a></li>
<li><a href='#remove_duplicated_objects'><p>Remove duplicated objects in inputs</p></a></li>
<li><a href='#remove_empty_fields'><p>Remove trailing empty object fields</p></a></li>
<li><a href='#rename_idf_object'><p>Rename existing objects</p></a></li>
<li><a href='#run_idf'><p>Run simulations of EnergyPlus models.</p></a></li>
<li><a href='#set_idf_object'><p>Modifying existing objects</p></a></li>
<li><a href='#standardize_idf_value'><p>Standardize Value Data</p></a></li>
<li><a href='#transition'><p>Perform version transition of EnergyPlus model</p></a></li>
<li><a href='#unique_idf_object'><p>Remove duplicate objects</p></a></li>
<li><a href='#use_eplus'><p>Configure which version of EnergyPlus to use</p></a></li>
<li><a href='#use_idd'><p>Use a specific EnergyPlus Input Data Dictionary (IDD) file</p></a></li>
<li><a href='#validate_objects'><p>Validate input IDF data in terms of various aspects</p></a></li>
<li><a href='#version_updater'><p>Run IDFVersionUpdater to Update Model Versions</p></a></li>
<li><a href='#with_option'><p>Evaluate an expression with temporary eplusr options</p></a></li>
<li><a href='#with_speed'><p>Evaluates an expression without checking</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Toolkit for Using Whole Building Simulation Program
'EnergyPlus'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.16.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A rich toolkit of using the whole building
    simulation program 'EnergyPlus'(<a href="https://energyplus.net">https://energyplus.net</a>), which
    enables programmatic navigation, modification of 'EnergyPlus' models
    and makes it less painful to do parametric simulations and analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hongyuanjia.github.io/eplusr/">https://hongyuanjia.github.io/eplusr/</a>,
<a href="https://github.com/hongyuanjia/eplusr">https://github.com/hongyuanjia/eplusr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hongyuanjia/eplusr/issues">https://github.com/hongyuanjia/eplusr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>callr (&ge; 2.0.4), checkmate, cli (&ge; 3.0.0), data.table (&ge;
1.14.6), lubridate, processx (&ge; 3.2.0), R6, RSQLite, stringi,
units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hms, decido, rgl (&ge; 0.105.13), testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>EnergyPlus (optional) (&lt;https://energyplus.net&gt;);
udunits2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'constants.R' 'assert.R' 'diagram.R' 'eplusr.R' 'utils.R'
'impl.R' 'parse.R' 'impl-epw.R' 'impl-idd.R' 'impl-idf.R'
'idf.R' 'idd.R' 'epw.R' 'err.R' 'format.R' 'geom.R' 'group.R'
'iddobj.R' 'idfobj-sch.R' 'impl-idfobj.R' 'idfobj.R'
'impl-geom.R' 'impl-iddobj.R' 'impl-idfobj-sch.R' 'impl-sql.R'
'impl-viewer.R' 'install.R' 'job.R' 'options.R' 'param.R'
'rdd.R' 'reload.R' 'run.R' 'sql.R' 'transition.R' 'units.R'
'validate.R' 'viewer.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 15:22:29 UTC; hongy</td>
</tr>
<tr>
<td>Author:</td>
<td>Hongyuan Jia <a href="https://orcid.org/0000-0002-0075-8183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Adrian Chong <a href="https://orcid.org/0000-0002-9486-4728"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hongyuan Jia &lt;hongyuanjia@cqust.edu.cn&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_idf_object'>Add new objects</h2><span id='topic+add_idf_object'></span>

<h3>Description</h3>

<p>Add new objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_idf_object(
  idd_env,
  idf_env,
  dt_object,
  dt_value,
  default = TRUE,
  unique = FALSE,
  empty = FALSE,
  level = eplusr_option("validate_level")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_dt_value">dt_value</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains value data.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_default">default</code></td>
<td>
<p>If <code>TRUE</code>, default values are used for those blank
fields if possible. If <code>FALSE</code>, empty fields are kept blank.
Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_unique">unique</code></td>
<td>
<p>If <code>TRUE</code>, there are same objects in current <a href="#topic+Idf">Idf</a> as input,
duplications in input are removed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_empty">empty</code></td>
<td>
<p>If <code>TRUE</code>, trailing empty fields are kept. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_idf_object_+3A_level">level</code></td>
<td>
<p>Validate level. Default: <code>eplusr_option("validate_level")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='as_EpwDate'>Convert to EnergyPlus Weather File date</h2><span id='topic+as_EpwDate'></span>

<h3>Description</h3>

<p><code>as_EpwDate()</code> converts inputs to EnergyPlus Weather File (EPW) dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_EpwDate(x, leapyear = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_EpwDate_+3A_x">x</code></td>
<td>
<p>An integer vector or a character vector.</p>
</td></tr>
<tr><td><code id="as_EpwDate_+3A_leapyear">leapyear</code></td>
<td>
<p>Whether support leap year. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>EnergyPlus supports multiple formats of date specification
Reference: Table 2.14, Chap 2 Weather Converter Program, Auxiliary Program
</p>
<p>Those formats include:
</p>

<ol>
<li><p> Julian day of year
</p>
</li>
<li><p> num_Month/num_Day
</p>
</li>
<li><p> num_Month/num_Day/num_Year (only for DataPeriod)
</p>
</li>
<li><p> num_Day alpha_Month
</p>
</li>
<li><p> alpha_Month num_Day
</p>
</li>
<li><p> num Weekday In Month (only for Holiday/DaylightSavingPeriod)
</p>
</li>
<li><p> last Weekday In Month (only for Holiday/DaylightSavingPeriod)
</p>
</li></ol>


<hr>
<h2 id='as.character.IddObject'>Coerce an IddObject into a Character Vector</h2><span id='topic+as.character.IddObject'></span>

<h3>Description</h3>

<p>Coerce an <a href="#topic+IddObject">IddObject</a> into an empty object of current class in a character
vector format. It is formatted exactly the same as in IDF Editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IddObject'
as.character(x, comment = NULL, leading = 4L, sep_at = 29L, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.IddObject_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+IddObject">IddObject</a> object.</p>
</td></tr>
<tr><td><code id="as.character.IddObject_+3A_comment">comment</code></td>
<td>
<p>A character vector to be used as comments of returned string
format object. If <code>NULL</code>, no comments are inserted. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="as.character.IddObject_+3A_leading">leading</code></td>
<td>
<p>Leading spaces added to each field. Default: <code>4</code>.</p>
</td></tr>
<tr><td><code id="as.character.IddObject_+3A_sep_at">sep_at</code></td>
<td>
<p>The character width to separate value string and field string.
Default: <code>29</code> which is the same as IDF Editor.'</p>
</td></tr>
<tr><td><code id="as.character.IddObject_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, all fields in current class are returned, otherwise
only minimum fields are returned.</p>
</td></tr>
<tr><td><code id="as.character.IddObject_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
as.character(use_idd(8.8, download = "auto")$Materal, leading = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.character.Idf'>Coerce an Idf object into a Character Vector</h2><span id='topic+as.character.Idf'></span>

<h3>Description</h3>

<p>Coerce an <a href="#topic+Idf">Idf</a> object into a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Idf'
as.character(
  x,
  comment = TRUE,
  header = TRUE,
  format = eplusr_option("save_format"),
  leading = 4L,
  sep_at = 29L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.Idf_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object.</p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_comment">comment</code></td>
<td>
<p>If <code>FALSE</code>, all comments will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_header">header</code></td>
<td>
<p>If <code>FALSE</code>, the header will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_format">format</code></td>
<td>
<p>Specific format used when formatting. For details, please see
<code style="white-space: pre;">&#8288;$save()&#8288;</code>. Default: <code>eplusr_option("save_format")</code></p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_leading">leading</code></td>
<td>
<p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_sep_at">sep_at</code></td>
<td>
<p>The character width to separate value string and field string.
Default: <code>29L</code> which is the same as IDF Editor.</p>
</td></tr>
<tr><td><code id="as.character.Idf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf_path &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")
as.character(read_idf(idf_path, use_idd(8.8, "auto")), leading = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.character.IdfObject'>Coerce an IdfObject into a Character Vector</h2><span id='topic+as.character.IdfObject'></span>

<h3>Description</h3>

<p>Coerce an <a href="#topic+IdfObject">IdfObject</a> into a character vector in the same way as in IDF Editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IdfObject'
as.character(x, comment = TRUE, leading = 4L, sep_at = 29L, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.IdfObject_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+IdfObject">IdfObject</a> object.</p>
</td></tr>
<tr><td><code id="as.character.IdfObject_+3A_comment">comment</code></td>
<td>
<p>If <code>FALSE</code>, all comments will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.character.IdfObject_+3A_leading">leading</code></td>
<td>
<p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</td></tr>
<tr><td><code id="as.character.IdfObject_+3A_sep_at">sep_at</code></td>
<td>
<p>The character width to separate value string and field string.
Default: <code>29L</code> which is the same as IDF Editor.</p>
</td></tr>
<tr><td><code id="as.character.IdfObject_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, values of all possible fields in current class the
<a href="#topic+IdfObject">IdfObject</a> belongs to are returned. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="as.character.IdfObject_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"),
    idd = use_idd("8.8", download = "auto"))

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]

as.character(mat, leading = 0, sep_at = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='assign_idf_value_default'>Assign default field values</h2><span id='topic+assign_idf_value_default'></span>

<h3>Description</h3>

<p>Assign default field values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_idf_value_default(idd_env, idf_env, dt_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_idf_value_default_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="assign_idf_value_default_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="assign_idf_value_default_+3A_dt_value">dt_value</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object value data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated version of <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>

<hr>
<h2 id='clean_wd'>Clean working directory of a previous EnergyPlus simulation</h2><span id='topic+clean_wd'></span>

<h3>Description</h3>

<p>Clean working directory of an EnergyPlus simulation by deleting all input and
output files of previous simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_wd(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_wd_+3A_path">path</code></td>
<td>
<p>An <code>.idf</code> or <code>.imf</code> file path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clean_wd()</code> imitates the same process that EnergyPlus does whenever a new
simulation is getting to start. It deletes all related output files that
have the same name prefix as the input path. The input model itself and
any weather file are not deleted. <code>clean_wd()</code> is called internally when
running EnergyPlus models using <code><a href="#topic+run_idf">run_idf()</a></code> and <code><a href="#topic+run_multi">run_multi()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# run a test simulation
idf_path &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")
epw_path &lt;- path_eplus_weather("8.8",
     "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
)
dir &lt;- file.path(tempdir(), "test")
run_idf(idf_path, epw_path, output_dir = dir, echo = FALSE)

list.files(dir)

# remove all output files
clean_wd(file.path(dir, basename(idf_path)))

list.files(dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='custom_validate'>Customize validation components</h2><span id='topic+custom_validate'></span>

<h3>Description</h3>

<p><code>custom_validate()</code> makes it easy to customize what validation components
should be included during IDF object modifications using <code style="white-space: pre;">&#8288;$dup()&#8288;</code>, <code style="white-space: pre;">&#8288;$add()&#8288;</code>,
<code style="white-space: pre;">&#8288;$set()&#8288;</code> and other methods in <a href="#topic+Idf">Idf</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_validate(
  required_object = FALSE,
  unique_object = FALSE,
  unique_name = FALSE,
  extensible = FALSE,
  required_field = FALSE,
  auto_field = FALSE,
  type = FALSE,
  choice = FALSE,
  range = FALSE,
  reference = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_validate_+3A_required_object">required_object</code></td>
<td>
<p>Check if required objects are missing in current
model. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_unique_object">unique_object</code></td>
<td>
<p>Check if there are multiple objects in one unique-object
class. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_unique_name">unique_name</code></td>
<td>
<p>Check if all objects in every class have unique names.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_extensible">extensible</code></td>
<td>
<p>Check if all fields in an extensible group have values.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_required_field">required_field</code></td>
<td>
<p>Check if all required fields have values. Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_auto_field">auto_field</code></td>
<td>
<p>Check if all fields with value <code>"Autosize"</code> and
<code>"Autocalculate"</code> are valid or not. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_type">type</code></td>
<td>
<p>Check if all fields have values with valid types, i.e.
character, numeric and integer fields should be filled with corresponding
type of values. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_choice">choice</code></td>
<td>
<p>Check if all choice fields have valid choice values. Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_range">range</code></td>
<td>
<p>Check if all numeric fields have values within defined ranges.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="custom_validate_+3A_reference">reference</code></td>
<td>
<p>Check if all fields whose values refer to other fields are
valid. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 10 different validation check components in total. Three predefined
validation level are included, i.e. <code>"none"</code>, <code>"draft"</code> and <code>"final"</code>. To get
what validation components those levels contain, see <code><a href="#topic+level_checks">level_checks()</a></code>.
</p>


<h3>Value</h3>

<p>A named list with 10 elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>custom_validate(unique_object = TRUE)

# only check unique name during validation
eplusr_option(validate_level = custom_validate(unique_name = TRUE))
</code></pre>

<hr>
<h2 id='del_idf_object'>Delete existing objects</h2><span id='topic+del_idf_object'></span>

<h3>Description</h3>

<p>Delete existing objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>del_idf_object(
  idd_env,
  idf_env,
  dt_object,
  ref_to = FALSE,
  ref_by = FALSE,
  recursive = FALSE,
  force = FALSE,
  level = eplusr_option("validate_level")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="del_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_ref_to">ref_to</code></td>
<td>
<p>If <code>TRUE</code>, objects whose fields are referred by input
objects will also be deleted. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_ref_by">ref_by</code></td>
<td>
<p>If <code>TRUE</code>, objects whose fields refer to input objects
will also be deleted. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_recursive">recursive</code></td>
<td>
<p>If <code>TRUE</code>, relation searching is performed
recursively, in case that objects whose fields refer to target
object are also referred by another object, and also objects
whose fields are referred by target object are also referred
by another object. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_force">force</code></td>
<td>
<p>If <code>TRUE</code>, objects are deleted even if they are
referred by other objects.</p>
</td></tr>
<tr><td><code id="del_idf_object_+3A_level">level</code></td>
<td>
<p>Validate level. Default: <code>eplusr_option("validate_level")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='download_weather'>Download EnergyPlus Weather File (EPW) and Design Day File (DDY)</h2><span id='topic+download_weather'></span>

<h3>Description</h3>

<p><code>download_weather()</code> makes it easy to download EnergyPlus weather files (EPW)
and design day files (DDY).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_weather(
  pattern,
  filename = NULL,
  dir = ".",
  type = c("all", "epw", "ddy", "stat"),
  ask = TRUE,
  max_match = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_weather_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression used to search locations, e.g. <code>"los angeles.*tmy3"</code>. The search is case-insensitive.</p>
</td></tr>
<tr><td><code id="download_weather_+3A_filename">filename</code></td>
<td>
<p>File names (without extension) used to save downloaded files.
Internally, <code><a href="base.html#topic+make.unique">make.unique()</a></code> is called to ensure unique names.</p>
</td></tr>
<tr><td><code id="download_weather_+3A_dir">dir</code></td>
<td>
<p>Directory to save downloaded files. Will create if not exist.</p>
</td></tr>
<tr><td><code id="download_weather_+3A_type">type</code></td>
<td>
<p>File type to download. Only applicable to data provided by
EnergyPlus website. For OneBuilding.org, <code>"all"</code> will always be used.
Should be one of <code>"all"</code>, <code>"epw"</code>, <code>"ddy"</code> and <code>"stat"</code>. If <code>"all"</code>, all
weather data will be downloaded in a ZIP file. Default: <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="download_weather_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, a command line menu will be shown to let you select
which one to download. If <code>FALSE</code> and the number of returned results is
less than <code>max_match</code>, files are downloaded automatically without asking.</p>
</td></tr>
<tr><td><code id="download_weather_+3A_max_match">max_match</code></td>
<td>
<p>The max results allowed to download when <code>ask</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing paths of downloaded files.
</p>


<h3>Data sources</h3>

<p>There are 2 data sources:
</p>

<ul>
<li> <p><a href="https://energyplus.net/">EnergyPlus.net</a>
</p>
</li>
<li> <p><a href="https://climate.onebuilding.org/">OneBuilding.org</a>
</p>
</li></ul>

<p>EnergyPlus sources allow downloading EPW, STAT, and DDY files separately
while OneBuilding sources can only download them all through a ZIP file.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
download_weather("los angeles.*tmy3", "LosAngeles", tempdir(), ask = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dt_to_load'>Format Long Table to Standard Input for <code>Idf$load()</code> Method</h2><span id='topic+dt_to_load'></span>

<h3>Description</h3>

<p><code>dt_to_load()</code> takes a <a href="data.table.html#topic+data.table">data.table</a>, usually
created from <code><a href="#topic+Idf">Idf$to_table()</a></code> or <code><a href="#topic+IdfObject">IdfObject$to_table()</a></code>
with <code>wide</code> being <code>TRUE</code>, and format it into a
<a href="data.table.html#topic+data.table">data.table</a> in acceptable format for <code style="white-space: pre;">&#8288;$load()&#8288;</code>
method in <a href="#topic+Idf">Idf</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_to_load(dt, string_value = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_to_load_+3A_dt">dt</code></td>
<td>
<p>A data.table created using <code>Idf$to_table()</code> and
<code>IdfObject$to_table()</code>. <code>dt</code> should at least contain column <code>id</code>
(indicator used to distinguish object definitions), <code>class</code> (class
names). If a <code>name</code> column exists, it will be preserved.</p>
</td></tr>
<tr><td><code id="dt_to_load_+3A_string_value">string_value</code></td>
<td>
<p>If <code>TRUE</code>, all value will be coerced into character and
the <code>value</code> column of returned <a href="data.table.html#topic+data.table">datat.table</a>
will be character type. If <code>FALSE</code>, the original value will be
preserved and the <code>value</code> column of returned
<a href="data.table.html#topic+data.table">data.table</a> will be list type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 5 or 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Used to distinguish each object definition.
</p>
</li>
<li> <p><code>name</code>: Character type. Only exists when input <code>dt</code> has a <code>name</code> column.
</p>
</li>
<li> <p><code>class</code>: Character type.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indices.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character or list type. The value of each field to be added.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read an example distributed with eplusr
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")
idf &lt;- read_idf(path_idf)

# extract all material object data and return it as a wide table
dt &lt;- idf$to_table(class = "Material", wide = TRUE)

dt_to_load(dt)

## End(Not run)

</code></pre>

<hr>
<h2 id='dup_idf_object'>Duplicate existing objects</h2><span id='topic+dup_idf_object'></span>

<h3>Description</h3>

<p>Duplicate existing objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup_idf_object(
  idd_env,
  idf_env,
  dt_object,
  level = eplusr_option("validate_level")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dup_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="dup_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="dup_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="dup_idf_object_+3A_level">level</code></td>
<td>
<p>Validate level. Default: <code>eplusr_option("validate_level")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='duplicated_idf_object'>Determine duplicate objects</h2><span id='topic+duplicated_idf_object'></span>

<h3>Description</h3>

<p>Determine duplicate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated_idf_object(idd_env, idf_env, dt_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="duplicated_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="duplicated_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A same <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> as input <code>dt_object</code> (updated by
reference) with appended integer column <code>unique_object_id</code> indicating the
object is a duplicated one of that object.
</p>

<hr>
<h2 id='empty_idf'>Create an Empty Idf</h2><span id='topic+empty_idf'></span>

<h3>Description</h3>

<p><code>empty_idf()</code> takes a valid IDD version and creates an empty <a href="#topic+Idf">Idf</a> object
that only contains a Version object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_idf(ver = "latest")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_idf_+3A_ver">ver</code></td>
<td>
<p>Any acceptable input of <code><a href="#topic+use_idd">use_idd()</a></code>. If <code>latest</code>, which is the
default, the latest IDD released version is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Idf">Idf</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (is_avail_idd(8.8)) empty_idf(8.8)

## End(Not run)

</code></pre>

<hr>
<h2 id='eplus_sql'>Read an Energy SQLite Output File</h2><span id='topic+eplus_sql'></span>

<h3>Description</h3>

<p><code>eplus_sql()</code> takes an EnergyPlus SQLite output file as input, and returns an
<code>EplusSQL</code> object for collecting simulation outputs. For more details, please
see <a href="#topic+EplusSql">EplusSql</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplus_sql(sql)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eplus_sql_+3A_sql">sql</code></td>
<td>
<p>A path to an local EnergyPlus SQLite output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+EplusSql">EplusSql</a> object.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (is_avail_eplus(8.8)) {
    idf_name &lt;- "1ZoneUncontrolled.idf"
    epw_name &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    idf_path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles", idf_name)
    epw_path &lt;- file.path(eplus_config(8.8)$dir, "WeatherData", epw_name)

    # copy to tempdir and run the model
    idf &lt;- read_idf(idf_path)
    idf$run(epw_path, tempdir(), echo = FALSE)

    # create from local file
    sql &lt;- eplus_sql(file.path(tempdir(), "1ZoneUncontrolled.sql"))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='EplusGroupJob'>Create and Run Parametric Analysis, and Collect Results</h2><span id='topic+EplusGroupJob'></span><span id='topic+group_job'></span>

<h3>Description</h3>

<p><code>EplusGroupJob</code> class is a wrapper of <code><a href="#topic+run_multi">run_multi()</a></code> and provides an interface
to group multiple EnergyPlus simulations together for running and collecting
outputs.
</p>
<p><code>group_job()</code> takes IDFs and EPWs as input and returns a <code>EplusGroupJob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_job(idfs, epws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EplusGroupJob_+3A_idfs">idfs</code></td>
<td>
<p>Paths to EnergyPlus IDF files or a list of IDF files and <a href="#topic+Idf">Idf</a>
objects.</p>
</td></tr>
<tr><td><code id="EplusGroupJob_+3A_epws">epws</code></td>
<td>
<p>Paths to EnergyPlus EPW files or a list of EPW files and <a href="#topic+Epw">Epw</a>
objects. Each element in the list can be <code>NULL</code>, which will force
design-day-only simulation when <code><a href="#topic+EplusGroupJob">$run()</a></code> method is
called. Note this needs at least one <code>Sizing:DesignDay</code> object exists
in that <a href="#topic+Idf">Idf</a>. If <code>epws</code> is <code>NULL</code>, design-day-only simulation will be
conducted for all input models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>EplusGroupJob</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EplusGroupJob-new"><code>EplusGroupJob$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-run"><code>EplusGroupJob$run()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-kill"><code>EplusGroupJob$kill()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-status"><code>EplusGroupJob$status()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-errors"><code>EplusGroupJob$errors()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-output_dir"><code>EplusGroupJob$output_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-list_files"><code>EplusGroupJob$list_files()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-locate_output"><code>EplusGroupJob$locate_output()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-list_table"><code>EplusGroupJob$list_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-read_table"><code>EplusGroupJob$read_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-read_rdd"><code>EplusGroupJob$read_rdd()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-read_mdd"><code>EplusGroupJob$read_mdd()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-report_data_dict"><code>EplusGroupJob$report_data_dict()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-report_data"><code>EplusGroupJob$report_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-tabular_data"><code>EplusGroupJob$tabular_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusGroupJob-print"><code>EplusGroupJob$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EplusGroupJob-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>EplusGroupJob</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$new(idfs, epws)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>idfs</code></dt><dd><p>Paths to EnergyPlus IDF files or a list of IDF files and
<a href="#topic+Idf">Idf</a> objects. If only one IDF supplied, it will be used for
simulations with all EPWs.</p>
</dd>
<dt><code>epws</code></dt><dd><p>Paths to EnergyPlus EPW files or a list of EPW files and
<a href="#topic+Epw">Epw</a> objects. Each element in the list can be <code>NULL</code>, which
will force design-day-only simulation. Note this needs at
least one <code>Sizing:DesignDay</code> object exists in that <a href="#topic+Idf">Idf</a>. If
<code>epws</code> is <code>NULL</code>, design-day-only simulation will be conducted
for all input models. If only one EPW supplied, it will be
used for simulations with all IDFs.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>EplusGroupJob</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus(8.8)) {
    dir &lt;- eplus_config(8.8)$dir
    path_idfs &lt;- list.files(file.path(dir, "ExampleFiles"), "\\.idf",
        full.names = TRUE)[1:5]
    path_epws &lt;- list.files(file.path(dir, "WeatherData"), "\\.epw",
        full.names = TRUE)[1:5]

    # create from local files
    group &lt;- group_job(path_idfs, path_epws)

    # create from Idfs and Epws object
    group_job(lapply(path_idfs, read_idf), lapply(path_epws, read_epw))
}
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run grouped simulations
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$run(
  dir = NULL,
  wait = TRUE,
  force = FALSE,
  copy_external = FALSE,
  echo = wait,
  separate = TRUE,
  readvars = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir</code></dt><dd><p>The parent output directory for specified simulations.
Outputs of each simulation are placed in a separate folder
under the parent directory.</p>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, R will hang on and wait all EnergyPlus
simulations finish. If <code>FALSE</code>, all EnergyPlus simulations are
run in the background.  Default: <code>TRUE</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>Only applicable when the last simulation runs with
<code>wait</code> equals to <code>FALSE</code> and is still running. If <code>TRUE</code>,
current running job is forced to stop and a new one will
start. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>If <code>TRUE</code>, the external files that current <code>Idf</code>
object depends on will also be copied into the simulation
output directory. The values of file paths in the Idf will be
changed automatically. This ensures that the output directory
will have all files needed for the model to run. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>echo</code></dt><dd><p>Only applicable when <code>wait</code> is <code>TRUE</code>. Whether to
simulation status. Default: same as <code>wait</code>.</p>
</dd>
<dt><code>separate</code></dt><dd><p>If <code>TRUE</code>, all models are saved in a separate folder
with each model's name under <code>dir</code> when simulation. If <code>FALSE</code>,
all models are saved in <code>dir</code> when simulation. Default:
<code>TRUE</code>.</p>
</dd>
<dt><code>readvars</code></dt><dd><p>If <code>TRUE</code>, the <code>ReadVarESO</code> post-processor will run
to generate CSV files from the ESO output. Since those CSV
files are never used when extracting simulation data in eplusr,
setting it to <code>FALSE</code> can speed up the simulation if there are
hundreds of output variables or meters. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$run()&#8288;</code> runs all grouped simulations in parallel. The number of
parallel EnergyPlus process can be controlled by
<code>eplusr_option("num_parallel")</code>. If <code>wait</code> is FALSE, then the job
will be run in the background. You can get updated job status by just
printing the <code>EplusGroupJob</code> object.
</p>



<h5>Returns</h5>

<p>The <code>EplusGroupJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# only run design day
group$run(NULL)

# do not show anything in the console
group$run(echo = FALSE)

# specify output directory
group$run(tempdir(), echo = FALSE)

# run in the background
group$run(wait = TRUE, echo = FALSE)
# see group job status
group$status()

# force to kill background group job before running the new one
group$run(force = TRUE, echo = FALSE)

# copy external files used in the model to simulation output directory
group$run(copy_external = TRUE, echo = FALSE)
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-kill"></a>



<h4>Method <code>kill()</code></h4>

<p>Kill current running jobs
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$kill()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$kill()&#8288;</code> kills all background EnergyPlus processes that are current
running if possible. It only works when simulations run in
non-waiting mode.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$kill()
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-status"></a>



<h4>Method <code>status()</code></h4>

<p>Get the group job status
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$status()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$status()&#8288;</code> returns a named list of values indicates the status of the job:
</p>

<ul>
<li> <p><code>run_before</code>: <code>TRUE</code> if the job has been run before. <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>alive</code>: <code>TRUE</code> if the job is still running in the background. <code>FALSE</code>
otherwise.
</p>
</li>
<li> <p><code>terminated</code>: <code>TRUE</code> if the job was terminated during last
simulation. <code>FALSE</code> otherwise. <code>NA</code> if the job has not been run yet.
</p>
</li>
<li> <p><code>successful</code>: <code>TRUE</code> if all simulations ended successfully. <code>FALSE</code> if
there is any simulation failed. <code>NA</code> if the job has not been run yet.
</p>
</li>
<li> <p><code>changed_after</code>: <code>TRUE</code> if the models has been modified since last
simulation. <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>job_status</code>: A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> contains meta data
for each simulation job. For details, please see <code><a href="#topic+run_multi">run_multi()</a></code>. If the
job has not been run before, a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
with 4 columns is returned:
</p>

<ul>
<li> <p><code>index</code>: The index of simulation
</p>
</li>
<li> <p><code>status</code>: The status of simulation. As the simulation has not been run,
<code>status</code> will always be &quot;idle&quot;.
</p>
</li>
<li> <p><code>idf</code>: The path of input IDF file.
</p>
</li>
<li> <p><code>epw</code>: The path of input EPW file. If not provided, <code>NA</code> will be
assigned.
</p>
</li></ul>

</li></ul>




<h5>Returns</h5>

<p>A named list of 6 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$status()
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-errors"></a>



<h4>Method <code>errors()</code></h4>

<p>Read group simulation errors
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$errors(which = NULL, info = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>info</code></dt><dd><p>If <code>FALSE</code>, only warnings and errors are printed.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>$errors() returns a list of <a href="#topic+read_err">ErrFile</a> objects which
contain all contents of the simulation error files (<code>.err</code>). If
<code>info</code> is <code>FALSE</code>, only warnings and errors are printed.
</p>



<h5>Returns</h5>

<p>A list of <a href="#topic+read_err">ErrFile</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$errors()

# show all information
group$errors(info = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-output_dir"></a>



<h4>Method <code>output_dir()</code></h4>

<p>Get simulation output directory
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$output_dir(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$output_dir()&#8288;</code> returns the output directory of simulation results.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get output directories of all simulations
group$output_dir()

# get output directories of specified simulations
group$output_dir(c(1, 4))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-list_files"></a>



<h4>Method <code>list_files()</code></h4>

<p>List all output files in simulations
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$list_files(which = NULL, simplify = FALSE, full = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>If <code>TRUE</code>, a list of character vectors of EnergyPlus
input and output file names in the output directory for each
simulation is given. If <code>FALSE</code>, a
<a href="data.table.html#topic+data.table">data.table</a> giving all possible input and
output types is given. <code>NA</code> is returned if no input or output files
are found for that type. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>full</code></dt><dd><p>If <code>TRUE</code>, the full file paths in the output directory
are returned. Otherwise, only the file names are returned. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$list_files()&#8288;</code> returns all input and output files for the grouped
EnergyPlus simulations.
</p>
<p>Description of all possible outputs from EnergyPlus can be found in
EnergyPlus documentation &quot;Output Details and Examples&quot;.
</p>
<p>Below gives a brief summary on the meaning of elements in the
returned list.</p>

<table>
<tr>
 <td style="text-align: left;">
   # </td><td style="text-align: left;"> Element </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> <code>ads</code> </td><td style="text-align: left;"> EnergyPlus AirflowNetwork related output </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> <code>audit</code> </td><td style="text-align: left;"> EnergyPlus inputs echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> <code>bnd</code> </td><td style="text-align: left;"> EnergyPlus branch node details </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> <code>bsmt_audit</code> </td><td style="text-align: left;"> Basement input Echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   5 </td><td style="text-align: left;"> <code>bsmt_csv</code> </td><td style="text-align: left;"> Basement CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   6 </td><td style="text-align: left;"> <code>bsmt_idf</code> </td><td style="text-align: left;"> Basement IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   7 </td><td style="text-align: left;"> <code>bsmt_out</code> </td><td style="text-align: left;"> Basement Output </td>
</tr>
<tr>
 <td style="text-align: left;">
   8 </td><td style="text-align: left;"> <code>cbor</code> </td><td style="text-align: left;"> Energyplus CBOR binary output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   9 </td><td style="text-align: left;"> <code>dbg</code> </td><td style="text-align: left;"> Energyplus debug output </td>
</tr>
<tr>
 <td style="text-align: left;">
   10 </td><td style="text-align: left;"> <code>delight</code> </td><td style="text-align: left;"> EnergyPlus DElight simulation inputs and outputs </td>
</tr>
<tr>
 <td style="text-align: left;">
   11 </td><td style="text-align: left;"> <code>dfs</code> </td><td style="text-align: left;"> EnergyPlus daylighting factor for exterior windows </td>
</tr>
<tr>
 <td style="text-align: left;">
   12 </td><td style="text-align: left;"> <code>dxf</code> </td><td style="text-align: left;"> EnergyPlus surface drawing output </td>
</tr>
<tr>
 <td style="text-align: left;">
   13 </td><td style="text-align: left;"> <code>edd</code> </td><td style="text-align: left;"> EnergyPlus EMS report </td>
</tr>
<tr>
 <td style="text-align: left;">
   14 </td><td style="text-align: left;"> <code>eio</code> </td><td style="text-align: left;"> EnergyPlus standard and optional reports </td>
</tr>
<tr>
 <td style="text-align: left;">
   15 </td><td style="text-align: left;"> <code>end</code> </td><td style="text-align: left;"> EnergyPlus simulation status in one line </td>
</tr>
<tr>
 <td style="text-align: left;">
   16 </td><td style="text-align: left;"> <code>epjson</code> </td><td style="text-align: left;"> EnergyPlus epJSON input converted from IDF </td>
</tr>
<tr>
 <td style="text-align: left;">
   17 </td><td style="text-align: left;"> <code>epmdet</code> </td><td style="text-align: left;"> EPMacro inputs echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   18 </td><td style="text-align: left;"> <code>epmidf</code> </td><td style="text-align: left;"> EPMacro IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   19 </td><td style="text-align: left;"> <code>epw</code> </td><td style="text-align: left;"> EnergyPlus Weather File input </td>
</tr>
<tr>
 <td style="text-align: left;">
   20 </td><td style="text-align: left;"> <code>err</code> </td><td style="text-align: left;"> EnergyPlus error summarry </td>
</tr>
<tr>
 <td style="text-align: left;">
   21 </td><td style="text-align: left;"> <code>eso</code> </td><td style="text-align: left;"> EnergyPlus standard output </td>
</tr>
<tr>
 <td style="text-align: left;">
   22 </td><td style="text-align: left;"> <code>experr</code> </td><td style="text-align: left;"> ExpandObjects error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   23 </td><td style="text-align: left;"> <code>expidf</code> </td><td style="text-align: left;"> ExpandObjects IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   24 </td><td style="text-align: left;"> <code>glhe</code> </td><td style="text-align: left;"> EnergyPlus ground heat exchange file </td>
</tr>
<tr>
 <td style="text-align: left;">
   25 </td><td style="text-align: left;"> <code>idf</code> </td><td style="text-align: left;"> EnergyPlus IDF input </td>
</tr>
<tr>
 <td style="text-align: left;">
   26 </td><td style="text-align: left;"> <code>imf</code> </td><td style="text-align: left;"> EPMacro IMF input </td>
</tr>
<tr>
 <td style="text-align: left;">
   27 </td><td style="text-align: left;"> <code>iperr</code> </td><td style="text-align: left;"> convertESOMTR error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   28 </td><td style="text-align: left;"> <code>ipeso</code> </td><td style="text-align: left;"> convertESOMTR standard output in IP units </td>
</tr>
<tr>
 <td style="text-align: left;">
   29 </td><td style="text-align: left;"> <code>ipmtr</code> </td><td style="text-align: left;"> convertESOMTR meter output in IP units </td>
</tr>
<tr>
 <td style="text-align: left;">
   30 </td><td style="text-align: left;"> <code>json</code> </td><td style="text-align: left;"> EnergyPlus JSON time series output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   31 </td><td style="text-align: left;"> <code>log</code> </td><td style="text-align: left;"> EnergyPlus log output </td>
</tr>
<tr>
 <td style="text-align: left;">
   32 </td><td style="text-align: left;"> <code>map</code> </td><td style="text-align: left;"> EnergyPlus daylighting intensity map output </td>
</tr>
<tr>
 <td style="text-align: left;">
   33 </td><td style="text-align: left;"> <code>mdd</code> </td><td style="text-align: left;"> EnergyPlus meter list </td>
</tr>
<tr>
 <td style="text-align: left;">
   34 </td><td style="text-align: left;"> <code>meter</code> </td><td style="text-align: left;"> EnergyPlus meter CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   35 </td><td style="text-align: left;"> <code>msgpack</code> </td><td style="text-align: left;"> EnergyPlus MessagePack binary output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   36 </td><td style="text-align: left;"> <code>mtd</code> </td><td style="text-align: left;"> EnergyPlus meter details </td>
</tr>
<tr>
 <td style="text-align: left;">
   37 </td><td style="text-align: left;"> <code>mtr</code> </td><td style="text-align: left;"> EnergyPlus meter output </td>
</tr>
<tr>
 <td style="text-align: left;">
   38 </td><td style="text-align: left;"> <code>perflog</code> </td><td style="text-align: left;"> EnergyPlus log for `PerformancePrecisionTradeoffs </td>
</tr>
<tr>
 <td style="text-align: left;">
   39 </td><td style="text-align: left;"> <code>rdd</code> </td><td style="text-align: left;"> EnergyPlus report variable names </td>
</tr>
<tr>
 <td style="text-align: left;">
   40 </td><td style="text-align: left;"> <code>rvaudit</code> </td><td style="text-align: left;"> ReadVarsESO input echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   41 </td><td style="text-align: left;"> <code>sci</code> </td><td style="text-align: left;"> EnergyPlus cost benefit calculation information </td>
</tr>
<tr>
 <td style="text-align: left;">
   42 </td><td style="text-align: left;"> <code>screen</code> </td><td style="text-align: left;"> EnergyPlus window scrren transmittance map output </td>
</tr>
<tr>
 <td style="text-align: left;">
   43 </td><td style="text-align: left;"> <code>shading</code> </td><td style="text-align: left;"> EnergyPlus surface shading CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   44 </td><td style="text-align: left;"> <code>shd</code> </td><td style="text-align: left;"> EnergyPlus surface shading combination report </td>
</tr>
<tr>
 <td style="text-align: left;">
   45 </td><td style="text-align: left;"> <code>slab_ger</code> </td><td style="text-align: left;"> Slab error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   46 </td><td style="text-align: left;"> <code>slab_gtp</code> </td><td style="text-align: left;"> Slab ground temperature output </td>
</tr>
<tr>
 <td style="text-align: left;">
   47 </td><td style="text-align: left;"> <code>slab_out</code> </td><td style="text-align: left;"> Slab IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   48 </td><td style="text-align: left;"> <code>sln</code> </td><td style="text-align: left;"> EnergyPlus <code style="white-space: pre;">&#8288;Output:Surfaces:List, Lines&#8288;</code> output </td>
</tr>
<tr>
 <td style="text-align: left;">
   49 </td><td style="text-align: left;"> <code>sqlite</code> </td><td style="text-align: left;"> EnergyPlus SQLite output </td>
</tr>
<tr>
 <td style="text-align: left;">
   50 </td><td style="text-align: left;"> <code>sqlite_err</code> </td><td style="text-align: left;"> EnergyPlus SQLite error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   51 </td><td style="text-align: left;"> <code>ssz</code> </td><td style="text-align: left;"> EnergyPlus system sizing outputs in CSV, TAB or TXT format </td>
</tr>
<tr>
 <td style="text-align: left;">
   52 </td><td style="text-align: left;"> <code>svg</code> </td><td style="text-align: left;"> HVAC-Diagram HVAC diagram output </td>
</tr>
<tr>
 <td style="text-align: left;">
   53 </td><td style="text-align: left;"> <code>table</code> </td><td style="text-align: left;"> EnergyPlus tabular outputs in CSV, TAB, TXT, HTM, or XML format </td>
</tr>
<tr>
 <td style="text-align: left;">
   54 </td><td style="text-align: left;"> <code>variable</code> </td><td style="text-align: left;"> EnergyPlus report variable CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   55 </td><td style="text-align: left;"> <code>wrl</code> </td><td style="text-align: left;"> EnergyPlus <code style="white-space: pre;">&#8288;Output:Surfaces:List, VRML&#8288;</code> output </td>
</tr>
<tr>
 <td style="text-align: left;">
   56 </td><td style="text-align: left;"> <code>zsz</code> </td><td style="text-align: left;"> EnergyPlus system sizing outputs in CSV, TAB or TXT format </td>
</tr>
<tr>
 <td style="text-align: left;">
   57 </td><td style="text-align: left;"> <code>resource</code> </td><td style="text-align: left;"> External file resources used for the simulation, e.g. <code>Schedule:File</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h5>Returns</h5>

<p>If simplify is <code>TRUE</code>, a list. Otherwise, a
<a href="data.table.html#topic+data.table">data.table</a> of 3 columns:
</p>

<ul>
<li> <p><code>index</code>: Integer type. Simulation indices.
</p>
</li>
<li> <p><code>type</code>: Character type. Input or output types. See table above for
the meaning
</p>
</li>
<li> <p><code>file</code>: List type. File names if <code>full</code> is <code>FALSE</code>. Full file paths
if <code>full</code> is <code>TRUE</code>
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# list all files in the output directory
group$list_files(simplify = TRUE)

# get a data.table that contains a full list of all possible inputs
# and outputs even though they may not exist for current simulation
group$list_files()

# return the full paths instead of just file names
group$locate_output(full = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-locate_output"></a>



<h4>Method <code>locate_output()</code></h4>

<p>Get paths of output file
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$locate_output(which = NULL, suffix = ".err", strict = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>suffix</code></dt><dd><p>A string that indicates the file extension of
simulation output. Default: <code>".err"</code>.</p>
</dd>
<dt><code>strict</code></dt><dd><p>If <code>TRUE</code>, it will check if the simulation was
terminated, is still running or the file exists or not.
Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$locate_output()&#8288;</code> returns the path of a single output file of specified
simulations.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get the file path of the error file
group$locate_output(c(1, 4), ".err", strict = FALSE)

# can detect if certain output file exists
group$locate_output(c(1, 4), ".expidf", strict = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-list_table"></a>



<h4>Method <code>list_table()</code></h4>

<p>List all table names in EnergyPlus SQL outputs
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$list_table(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$list_table()&#8288;</code> returns a list of character vectors that contain all
available table and view names in the EnergyPlus SQLite files for
group simulations. The list is named using IDF names.
</p>



<h5>Returns</h5>

<p>A named list of character vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$list_table(c(1, 4))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-read_table"></a>



<h4>Method <code>read_table()</code></h4>

<p>Read the same table from EnergyPlus SQL outputs
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$read_table(which = NULL, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A single string specifying the name of table to read.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_table()&#8288;</code> takes a simulation index and a valid table <code>name</code> of
those from
<a href="../../eplusr/html/EplusGroupJob.html#method-list_table"><code>$list_table()</code></a>
and returns that table data in a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> format.
The two column will always be <code>index</code> and <code>case</code> which can be used to
distinguish output from different simulations. <code>index</code> contains the
indices of simulated models and <code>case</code> contains the model names
without extensions.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read a specific table
group$read_table(c(1, 4), "Zones")
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-read_rdd"></a>



<h4>Method <code>read_rdd()</code></h4>

<p>Read Report Data Dictionary (RDD) files
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$read_rdd(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_rdd()&#8288;</code> return the core data of Report Data Dictionary (RDD)
files. For details, please see <code><a href="#topic+read_rdd">read_rdd()</a></code>.
The two column will always be <code>index</code> and <code>case</code> which can be used to
distinguish output from different simulations. <code>index</code> contains the
indices of simulated models and <code>case</code> contains the model names
without extensions.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$read_rdd(c(1, 4))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-read_mdd"></a>



<h4>Method <code>read_mdd()</code></h4>

<p>Read Meter Data Dictionary (MDD) files
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$read_mdd(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_mdd()&#8288;</code> return the core data of Meter Data Dictionary (MDD)
files. For details, please see <code><a href="#topic+read_mdd">read_mdd()</a></code>.
The two column will always be <code>index</code> and <code>case</code> which can be used to
distinguish output from different simulations. <code>index</code> contains the
indices of simulated models and <code>case</code> contains the model names
without extensions.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$read_mdd(c(1, 4))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-report_data_dict"></a>



<h4>Method <code>report_data_dict()</code></h4>

<p>Read report data dictionary from EnergyPlus SQL outputs
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$report_data_dict(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> which
contains all information about report data.
</p>
<p>For details on the meaning of each columns, please see &quot;2.20.2.1
ReportDataDictionary Table&quot; in EnergyPlus &quot;Output Details and
Examples&quot; documentation.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 10 columns:
</p>

<ul>
<li> <p><code>index</code>: The index of simulated model. This column can be used
to distinguish output from different simulations
</p>
</li>
<li> <p><code>case</code>: The model name without extension. This column can be used
to distinguish output from different simulations
</p>
</li>
<li> <p><code>report_data_dictionary_index</code>: The integer used to link the
dictionary data to the variable data. Mainly useful when joining
different tables
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values:
<code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and
<code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>reporting_frequency</code>:
</p>
</li>
<li> <p><code>schedule_name</code>: Name of the the schedule that controls reporting
frequency.
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$report_data_dict(c(1, 4))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-report_data"></a>



<h4>Method <code>report_data()</code></h4>

<p>Read report data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$report_data(
  which = NULL,
  key_value = NULL,
  name = NULL,
  year = NULL,
  tz = "UTC",
  all = FALSE,
  wide = FALSE,
  period = NULL,
  month = NULL,
  day = NULL,
  hour = NULL,
  minute = NULL,
  interval = NULL,
  simulation_days = NULL,
  day_type = NULL,
  environment_name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>key_value</code></dt><dd><p>A character vector to identify key values of the
data. If <code>NULL</code>, all keys of that variable will be returned.
<code>key_value</code> can also be data.frame that contains <code>key_value</code>
and <code>name</code> columns. In this case, <code>name</code> argument in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> is ignored. All available <code>key_value</code> for
current simulation output can be obtained using
<a href="../../eplusr/html/EplusGroupJob.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A character vector to identify names of the data. If
<code>NULL</code>, all names of that variable will be returned. If
<code>key_value</code> is a data.frame, <code>name</code> is ignored. All available
<code>name</code> for current simulation output can be obtained using
<a href="../../eplusr/html/EplusGroupJob.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of the date time in column <code>datetime</code>. If <code>NULL</code>, it
will calculate a year value that meets the start day of week
restriction for each environment. Default: <code>NULL</code>.</p>
</dd>
<dt><code>tz</code></dt><dd><p>Time zone of date time in column <code>datetime</code>. Default:
<code>"UTC"</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, extra columns are also included in the returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, the output is formatted in the same way as
standard EnergyPlus csv output file.</p>
</dd>
<dt><code>period</code></dt><dd><p>A Date or POSIXt vector used to specify which time
period to return. The year value does not matter and only
month, day, hour and minute value will be used when
subsetting. If <code>NULL</code>, all time period of data is returned.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>month, day, hour, minute</code></dt><dd><p>Each is an integer vector for month,
day, hour, minute subsetting of <code>datetime</code> column when
querying on the SQL database. If <code>NULL</code>, no subsetting is
performed on those components. All possible <code>month</code>, <code>day</code>,
<code>hour</code> and <code>minute</code> can be obtained using
<a href="../../eplusr/html/EplusGroupJob.html#method-read_table"><code>$read_table(NULL, "Time")</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>interval</code></dt><dd><p>An integer vector used to specify which interval
length of report to extract. If <code>NULL</code>, all interval will be
used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simulation_days</code></dt><dd><p>An integer vector to specify which simulation
day data to extract. Note that this number resets after warmup
and at the beginning of an environment period. All possible
<code>simulation_days</code> can be obtained using
<a href="../../eplusr/html/EplusGroupJob.html#method-read_table"><code>$read_table(NULL, "Time")</code></a>.
If <code>NULL</code>, all simulation days will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>day_type</code></dt><dd><p>A character vector to specify which day type of data
to extract. All possible day types are: <code>Sunday</code>, <code>Monday</code>,
<code>Tuesday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>, <code>Saturday</code>,
<code>Holiday</code>, <code>SummerDesignDay</code>, <code>WinterDesignDay</code>, <code>CustomDay1</code>,
and <code>CustomDay2</code>. All possible values for current simulation
output can be obtained using
<a href="../../eplusr/html/EplusGroupJob.html#method-read_table"><code>$read_table(NULL, "Time")</code></a>.
A few grouped options are also provided:
</p>

<ul>
<li> <p><code>"Weekday"</code>: All working days, i.e. from Monday to Friday
</p>
</li>
<li> <p><code>"Weekend"</code>: Saturday and Sunday
</p>
</li>
<li> <p><code>"DesignDay"</code>: Equivalent to <code>"SummerDesignDay"</code> plus <code>"WinterDesignDay"</code>
</p>
</li>
<li> <p><code>"CustomDay"</code>: CustomDay1 and CustomDay2
</p>
</li>
<li> <p><code>"SpecialDay"</code>: Equivalent to <code>"DesignDay"</code> plus <code>"CustomDay"</code>
</p>
</li>
<li> <p><code>"NormalDay"</code>: Equivalent to <code>"Weekday"</code> and <code>"Weekend"</code> plus <code>"Holiday"</code>
</p>
</li></ul>
</dd>
<dt><code>environment_name</code></dt><dd><p>A character vector to specify which
environment data to extract. If <code>NULL</code>, all environment data
are returned. Default: <code>NULL</code>. All possible
<code>environment_name</code> for current simulation output can be
obtained using:
</p>
<div class="sourceCode"><pre>$read_table(NULL, "EnvironmentPeriods")
</pre></div></dd>
<dt><code>case</code></dt><dd><p>If not <code>NULL</code>, a character column will be added indicates
the case of this simulation. If <code>"auto"</code>, the name of the IDF
file without extension is used.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> extracts the report data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using key values, variable names and other
specifications.
</p>
<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> can also directly take all or subset output from
<code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> as input, and extract all data specified.
</p>
<p>The returned column numbers varies depending on <code>all</code> argument.
</p>

<ul>
<li> <p><code>all</code> is <code>FALSE</code>, the returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has 6 columns:
</p>

<ul>
<li> <p><code>index</code>: The index of simulated model. This column can be used
to distinguish output from different simulations
</p>
</li>
<li> <p><code>case</code>: The model name. This column can be used to distinguish
output from different simulations
</p>
</li>
<li> <p><code>datetime</code>: The date time of simulation result
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li>
<li> <p><code>value</code>: The data value
</p>
</li></ul>

</li>
<li> <p><code>all</code> is <code>TRUE</code>, besides columns described above, extra columns are also
included:
</p>

<ul>
<li> <p><code>month</code>: The month of reported date time
</p>
</li>
<li> <p><code>day</code>: The day of month of reported date time
</p>
</li>
<li> <p><code>hour</code>: The hour of reported date time
</p>
</li>
<li> <p><code>minute</code>: The minute of reported date time
</p>
</li>
<li> <p><code>dst</code>: Daylight saving time indicator. Possible values: <code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>interval</code>: Length of reporting interval
</p>
</li>
<li> <p><code>simulation_days</code>: Day of simulation
</p>
</li>
<li> <p><code>day_type</code>: The type of day, e.g. <code>Monday</code>, <code>Tuesday</code> and etc.
</p>
</li>
<li> <p><code>environment_period_index</code>: The indices of environment.
</p>
</li>
<li> <p><code>environment_name</code>: A text string identifying the environment.
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values: <code>0</code> and
<code>1</code>
</p>
</li>
<li> <p><code>type</code>: Nature of data type with respect to state. Possible values: <code>Sum</code>
and <code>Avg</code>
</p>
</li>
<li> <p><code>index_group</code>: The report group, e.g. <code>Zone</code>, <code>System</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and <code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>reporting_frequency</code>: The reporting frequency of the variable, e.g.
<code style="white-space: pre;">&#8288;HVAC System Timestep&#8288;</code>, <code style="white-space: pre;">&#8288;Zone Timestep&#8288;</code>.
</p>
</li>
<li> <p><code>schedule_name</code>: Name of the the schedule that controls reporting
frequency.
</p>
</li></ul>

</li></ul>

<p>With the <code>datetime</code> column, it is quite straightforward to apply time-series
analysis on the simulation output. However, another painful thing is that
every simulation run period has its own <code style="white-space: pre;">&#8288;Day of Week for Start Day&#8288;</code>. Randomly
setting the <code>year</code> may result in a date time series that does not have
the same start day of week as specified in the RunPeriod objects.
</p>
<p>eplusr provides a simple solution for this. By setting <code>year</code> to <code>NULL</code>,
which is the default behavior, eplusr will calculate a year value (from
year 2017 backwards) for each run period that compliances with the start
day of week restriction.
</p>
<p>It is worth noting that EnergyPlus uses 24-hour clock system where 24 is only
used to denote midnight at the end of a calendar day. In EnergyPlus output,
&quot;00:24:00&quot; with a time interval being 15 mins represents a time period from
&quot;00:23:45&quot; to &quot;00:24:00&quot;, and similarly &quot;00:15:00&quot; represents a time period
from &quot;00:24:00&quot; to &quot;00:15:00&quot; of the next day. This means that if current day
is Friday, day of week rule applied in schedule time period &quot;00:23:45&quot; to
&quot;00:24:00&quot; (presented as &quot;00:24:00&quot; in the output) is also Friday, but not
Saturday. However, if you try to get the day of week of time &quot;00:24:00&quot; in R,
you will get Saturday, but not Friday. This introduces inconsistency and may
cause problems when doing data analysis considering day of week value.
</p>
<p>With <code>wide</code> equals <code>TRUE</code>, <code style="white-space: pre;">&#8288;$report_data()&#8288;</code> will format the simulation output
in the same way as standard EnergyPlus csv output file. Sometimes this can be
useful as there may be existing tools/workflows that depend on this format.
When both <code>wide</code> and <code>all</code> are <code>TRUE</code>, columns of runperiod environment names
and date time components are also returned, including:
<code style="white-space: pre;">&#8288;environment_period_index", "environment_name&#8288;</code>, <code>simulation_days</code>,
<code>datetime</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>day_type</code>.
</p>
<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read report data
group$report_data(c(1, 4))

# specify output variables using report data dictionary
dict &lt;- group$report_data_dict(1)
group$report_data(c(1, 4), dict[units == "C"])

# specify output variables using 'key_value' and 'name'
group$report_data(c(1, 4), "environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
group$report_data(c(1, 4), dict[1], year = 2020, tz = "Etc/GMT+8")

# get all possible columns
group$report_data(c(1, 4), dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
group$report_data(c(1, 4), dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
group$report_data(c(1, 4), dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
group$report_data(c(1, 4), dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-tabular_data"></a>



<h4>Method <code>tabular_data()</code></h4>

<p>Read tabular data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$tabular_data(
  which = NULL,
  report_name = NULL,
  report_for = NULL,
  table_name = NULL,
  column_name = NULL,
  row_name = NULL,
  wide = FALSE,
  string_value = !wide
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of the indexes or a character vector
or names of parametric simulations. If <code>NULL</code>, results of all
parametric simulations are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>report_name, report_for, table_name, column_name, row_name</code></dt><dd><p>Each is
a character vector for subsetting when querying the SQL
database.  For the meaning of each argument, please see the
description above.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, each table will be converted into the similar
format as it is shown in EnergyPlus HTML output file. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>string_value</code></dt><dd><p>Only applicable when <code>wide</code> is <code>TRUE</code>. If
<code>string_value</code> is <code>FALSE</code>, instead of keeping all values as
characters, values in possible numeric columns are converted
into numbers. Default: the opposite of <code>wide</code>. Possible
numeric columns indicate column that:
</p>

<ul>
<li><p> columns that have associated units
</p>
</li>
<li><p> columns that contents numbers
</p>
</li></ul>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> extracts the tabular data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using report, table, column and row name
specifications. The returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has
9 columns:
</p>

<ul>
<li> <p><code>index</code>: The index of simulated model. This column can be used
to distinguish output from different simulations
</p>
</li>
<li> <p><code>case</code>: The model name. This column can be used to distinguish
output from different simulations
</p>
</li>
<li> <p><code>index</code>: Tabular data index
</p>
</li>
<li> <p><code>report_name</code>: The name of the report that the record belongs to
</p>
</li>
<li> <p><code>report_for</code>: The <code>For</code> text that is associated with the record
</p>
</li>
<li> <p><code>table_name</code>: The name of the table that the record belongs to
</p>
</li>
<li> <p><code>column_name</code>: The name of the column that the record belongs to
</p>
</li>
<li> <p><code>row_name</code>: The name of the row that the record belongs to
</p>
</li>
<li> <p><code>units</code>: The units of the record
</p>
</li>
<li> <p><code>value</code>: The value of the record <strong>in string format</strong> by default
</p>
</li></ul>

<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 9 columns (when <code>wide</code> is
<code>FALSE</code>) or a named list of <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s where the
names are the combination of <code>report_name</code>, <code>report_for</code> and
<code>table_name</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read all tabular data
group$tabular_data(c(1, 4))

# explicitly specify data you want
str(group$tabular_data(c(1, 4),
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(group$tabular_data(c(1, 4),
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))
}

</pre>
</div>


<hr>
<a id="method-EplusGroupJob-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>EplusGroupJob</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusGroupJob$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> shows the core information of this <code>EplusGroupJob</code>, including the
path of IDFs and EPWs and also the simulation job status.
</p>
<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> is quite useful to get the simulation status, especially when
<code>wait</code> is <code>FALSE</code> in <code style="white-space: pre;">&#8288;$run()&#8288;</code>. The job status will be updated and printed
whenever <code style="white-space: pre;">&#8288;$print()&#8288;</code> is called.
</p>



<h5>Returns</h5>

<p>The <code>EplusGroupJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
group$print()
}

</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eplus_job">eplus_job()</a></code> for creating an EnergyPlus single simulation job.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `EplusGroupJob$new`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus(8.8)) {
    dir &lt;- eplus_config(8.8)$dir
    path_idfs &lt;- list.files(file.path(dir, "ExampleFiles"), "\\.idf",
        full.names = TRUE)[1:5]
    path_epws &lt;- list.files(file.path(dir, "WeatherData"), "\\.epw",
        full.names = TRUE)[1:5]

    # create from local files
    group &lt;- group_job(path_idfs, path_epws)

    # create from Idfs and Epws object
    group_job(lapply(path_idfs, read_idf), lapply(path_epws, read_epw))
}

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$run`
## ------------------------------------------------

## Not run: 
# only run design day
group$run(NULL)

# do not show anything in the console
group$run(echo = FALSE)

# specify output directory
group$run(tempdir(), echo = FALSE)

# run in the background
group$run(wait = TRUE, echo = FALSE)
# see group job status
group$status()

# force to kill background group job before running the new one
group$run(force = TRUE, echo = FALSE)

# copy external files used in the model to simulation output directory
group$run(copy_external = TRUE, echo = FALSE)

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$kill`
## ------------------------------------------------

## Not run: 
group$kill()

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$status`
## ------------------------------------------------

## Not run: 
group$status()

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$errors`
## ------------------------------------------------

## Not run: 
group$errors()

# show all information
group$errors(info = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$output_dir`
## ------------------------------------------------

## Not run: 
# get output directories of all simulations
group$output_dir()

# get output directories of specified simulations
group$output_dir(c(1, 4))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$list_files`
## ------------------------------------------------

## Not run: 
# list all files in the output directory
group$list_files(simplify = TRUE)

# get a data.table that contains a full list of all possible inputs
# and outputs even though they may not exist for current simulation
group$list_files()

# return the full paths instead of just file names
group$locate_output(full = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$locate_output`
## ------------------------------------------------

## Not run: 
# get the file path of the error file
group$locate_output(c(1, 4), ".err", strict = FALSE)

# can detect if certain output file exists
group$locate_output(c(1, 4), ".expidf", strict = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$list_table`
## ------------------------------------------------

## Not run: 
group$list_table(c(1, 4))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$read_table`
## ------------------------------------------------

## Not run: 
# read a specific table
group$read_table(c(1, 4), "Zones")

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$read_rdd`
## ------------------------------------------------

## Not run: 
group$read_rdd(c(1, 4))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$read_mdd`
## ------------------------------------------------

## Not run: 
group$read_mdd(c(1, 4))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$report_data_dict`
## ------------------------------------------------

## Not run: 
group$report_data_dict(c(1, 4))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$report_data`
## ------------------------------------------------

## Not run: 
# read report data
group$report_data(c(1, 4))

# specify output variables using report data dictionary
dict &lt;- group$report_data_dict(1)
group$report_data(c(1, 4), dict[units == "C"])

# specify output variables using 'key_value' and 'name'
group$report_data(c(1, 4), "environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
group$report_data(c(1, 4), dict[1], year = 2020, tz = "Etc/GMT+8")

# get all possible columns
group$report_data(c(1, 4), dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
group$report_data(c(1, 4), dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
group$report_data(c(1, 4), dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
group$report_data(c(1, 4), dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$tabular_data`
## ------------------------------------------------

## Not run: 
# read all tabular data
group$tabular_data(c(1, 4))

# explicitly specify data you want
str(group$tabular_data(c(1, 4),
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(group$tabular_data(c(1, 4),
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))

## End(Not run)


## ------------------------------------------------
## Method `EplusGroupJob$print`
## ------------------------------------------------

## Not run: 
group$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='EplusJob'>Run EnergyPlus Simulation and Collect Outputs</h2><span id='topic+EplusJob'></span><span id='topic+eplus_job'></span>

<h3>Description</h3>

<p><code>EplusJob</code> class wraps the EnergyPlus command line interface and provides
methods to extract simulation outputs.
</p>
<p><code>eplus_job()</code> takes an IDF and EPW as input, and returns an <code>EplusJob</code> object
for running EnergyPlus simulation and collecting outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplus_job(idf, epw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EplusJob_+3A_idf">idf</code></td>
<td>
<p>A path to an local EnergyPlus IDF file or an <code>Idf</code> object.</p>
</td></tr>
<tr><td><code id="EplusJob_+3A_epw">epw</code></td>
<td>
<p>A path to an local EnergyPlus EPW file or an <code>Epw</code> object. <code>epw</code>
can also be <code>NULL</code> which will force design-day-only simulation when
<code><a href="#topic+EplusJob">$run()</a></code> method is called. Note this needs at least one
<code>Sizing:DesignDay</code> object exists in the <a href="#topic+Idf">Idf</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>eplusr uses the EnergyPlus SQL output for extracting simulation outputs.
</p>
<p><code>EplusJob</code> has provide some wrappers that do SQL query to get report data
results, i.e. results from <code>Output:Variable</code> and <code style="white-space: pre;">&#8288;Output:Meter*&#8288;</code>. But for
<code>Output:Table</code> results, you have to be familiar with the structure of the
EnergyPlus SQL results, especially for table <em>&quot;TabularDataWithStrings&quot;</em>. For
details, please see <em>&quot;2.20 eplusout.sql&quot;</em>, especially <em>&quot;2.20.4.4 TabularData
Table&quot;</em> in EnergyPlus <em>&quot;Output Details and Examples&quot;</em> documentation. An
object in <code>Output:SQLite</code> with <code style="white-space: pre;">&#8288;Option Type&#8288;</code> value of <code>SimpleAndTabular</code> will
be automatically created if it does not exists, to ensure that the output
collection functionality works successfully.
</p>
<p>In order to make sure <code>.rdd</code> (Report Data Dictionary) and <code>.mdd</code> (Meter Data
Dictionary) files are created during simulation, an object in
<code>Output:VariableDictionary</code> class with <code style="white-space: pre;">&#8288;Key Field&#8288;</code> value being <code>IDF</code> will be
automatically created if it does not exists.
</p>


<h3>Value</h3>

<p>An <code>EplusJob</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EplusJob-new"><code>EplusJob$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-version"><code>EplusJob$version()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-path"><code>EplusJob$path()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-run"><code>EplusJob$run()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-kill"><code>EplusJob$kill()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-status"><code>EplusJob$status()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-errors"><code>EplusJob$errors()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-output_dir"><code>EplusJob$output_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-list_files"><code>EplusJob$list_files()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-locate_output"><code>EplusJob$locate_output()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-read_rdd"><code>EplusJob$read_rdd()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-read_mdd"><code>EplusJob$read_mdd()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-list_table"><code>EplusJob$list_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-read_table"><code>EplusJob$read_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-report_data_dict"><code>EplusJob$report_data_dict()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-report_data"><code>EplusJob$report_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-tabular_data"><code>EplusJob$tabular_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusJob-print"><code>EplusJob$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EplusJob-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>EplusJob</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$new(idf, epw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>idf</code></dt><dd><p>Path to an local EnergyPlus IDF file or an <a href="#topic+Idf">Idf</a> object.</p>
</dd>
<dt><code>epw</code></dt><dd><p>Path to an local EnergyPlus EPW file or an <a href="#topic+Epw">Epw</a> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>EplusJob</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus("8.8")) {
    name_idf &lt;- "1ZoneUncontrolled.idf"
    name_epw &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    path_idf &lt;- path_eplus_example("8.8", name_idf)
    path_epw &lt;- path_eplus_weather("8.8", name_epw)

    # create from local files
    job &lt;- eplus_job(path_idf, path_epw)

    # create from an Idf and an Epw object
    job &lt;- eplus_job(read_idf(path_idf), read_epw(path_epw))
}
}
</pre>
</div>


<hr>
<a id="method-EplusJob-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of IDF in current job
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of IDF that current <code>EplusJob</code> uses.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$version()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the paths of file that current <code>EpwSql</code> uses
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$path(type = c("all", "idf", "epw"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>If <code>"all"</code>, both the <a href="#topic+Idf">Idf</a> path and <a href="#topic+Epw">Epw</a> path are
returned. If <code>"idf"</code>, only IDF path is returned. If <code>"epw"</code>,
only EPW path is returned. If <code>epw</code> is <code>NULL</code>, <code>NA</code> is
returned for EPW path. Default: <code>"all"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path()&#8288;</code> returns the path of IDF or EPW of current job.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$path()
job$path("idf")
job$path("epw")
}

</pre>
</div>


<hr>
<a id="method-EplusJob-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run simulationA
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$run(
  epw,
  dir = NULL,
  wait = TRUE,
  force = FALSE,
  echo = wait,
  copy_external = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>epw</code></dt><dd><p>A path to an <code>.epw</code> file or an <a href="#topic+Epw">Epw</a> object. <code>epw</code> can
also be <code>NULL</code> which will force design-day-only simulation.
Note this needs EnergyPlus v8.3 and later, and at least one
<code>Sizing:DesignDay</code> object exists in the <code>Idf</code>. If not given,
the <code>epw</code> input used when creating this <code>EplusJob</code> object will
be used.</p>
</dd>
<dt><code>dir</code></dt><dd><p>The directory to save the simulation results. If <code>NULL</code>,
the input <code>idf</code> folder will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, R will hang on and wait for the simulation to
complete. EnergyPlus standard output (stdout) and error
(stderr) is printed to R console. If <code>FALSE</code>, simulation will
be run in a background process.  Default: <code>TRUE</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>Only applicable when the last job runs with <code>wait</code>
equals to <code>FALSE</code> and is still running. If <code>TRUE</code>, current
running job is forced to stop and a new one will start.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>echo</code></dt><dd><p>Only applicable when <code>wait</code> is <code>TRUE</code>. Whether to show
standard output and error from EnergyPlus. Default: same as
<code>wait</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>If <code>TRUE</code>, the external files that current <code>Idf</code>
object depends on will also be copied into the simulation
output directory. The values of file paths in the Idf will be
changed automatically. This ensures that the output directory
will have all files needed for the model to run. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>readvars</code></dt><dd><p>If <code>TRUE</code>, the <code>ReadVarESO</code> post-processor will run
to generate CSV files from the ESO output. Since those CSV
files are never used when extracting simulation data in eplusr,
setting it to <code>FALSE</code> can speed up the simulation if there are
hundreds of output variables or meters. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$run()&#8288;</code> runs the simulation using input IDF and EPW file. If <code>wait</code>
is <code>FALSE</code>, the job is run in the background. You can get updated job
status by just
<a href="../../eplusr/html/EplusJob.html#method-print">printing</a>
the <code>EplusJob</code> object.
</p>
<p>Parameter <code>epw</code> can be used to reset the EPW file to use for
simulation. If not given, the <code>epw</code> input used when creating
this <code>EplusJob</code> object will be used.
</p>



<h5>Returns</h5>

<p>The <code>EplusJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# only run design day
job$run(NULL)

# specify output directory
job$run(dir = tempdir())

# run in the background
job$run(wait = TRUE)
# see job status
job$status()

# force to kill background job before running the new one
job$run(force = TRUE)

# do not show anything in the console
job$run(echo = FALSE)

# copy external files used in the model to simulation output directory
job$run(copy_external = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusJob-kill"></a>



<h4>Method <code>kill()</code></h4>

<p>Kill current running job
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$kill()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$kill()&#8288;</code> kills the background EnergyPlus process if possible. It
only works when simulation runs in non-waiting mode.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$kill()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-status"></a>



<h4>Method <code>status()</code></h4>

<p>Get the job status
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$status()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$status()&#8288;</code> returns a named list of values that indicates the status of the
job:
</p>

<ul>
<li> <p><code>run_before</code>: <code>TRUE</code> if the job has been run before. <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>alive</code>: <code>TRUE</code> if the simulation is still running in the background.
<code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>terminated</code>: <code>TRUE</code> if the simulation was terminated during last
simulation. <code>FALSE</code> otherwise. <code>NA</code> if the job has not been run yet.
</p>
</li>
<li> <p><code>successful</code>: <code>TRUE</code> if last simulation ended successfully. <code>FALSE</code>
otherwise. <code>NA</code> if the job has not been run yet.
</p>
</li>
<li> <p><code>changed_after</code>: <code>TRUE</code> if the IDF file has been changed since last
simulation. <code>FALSE</code> otherwise. <code>NA</code> if the job has not been run yet.
</p>
</li></ul>




<h5>Returns</h5>

<p>A named list of 5 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$status()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-errors"></a>



<h4>Method <code>errors()</code></h4>

<p>Read simulation errors
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$errors(info = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>info</code></dt><dd><p>If <code>FALSE</code>, only warnings and errors are printed.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>$errors() returns an <a href="#topic+read_err">ErrFile</a> object which contains all
contents of the simulation error file (<code>.err</code>). If <code>info</code> is <code>FALSE</code>,
only warnings and errors are printed.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+read_err">ErrFile</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$errors()

# show all information
job$errors(info = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusJob-output_dir"></a>



<h4>Method <code>output_dir()</code></h4>

<p>Get simulation output directory
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$output_dir(open = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>open</code></dt><dd><p>If <code>TRUE</code>, the output directory will be opened.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$output_dir()&#8288;</code> returns the output directory of simulation results.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$output_dir()

# Below will open output directory
# job$output_dir(open = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusJob-list_files"></a>



<h4>Method <code>list_files()</code></h4>

<p>List all output files in current simulation
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$list_files(simplify = FALSE, full = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simplify</code></dt><dd><p>If <code>TRUE</code>, a character vector of EnergyPlus input
and output file names in the output directory is given. If <code>FALSE</code>, a
full named list of all possible input and output types is given. <code>NA</code>
is returned if no input or output files are found for that type.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>full</code></dt><dd><p>If <code>TRUE</code>, the full file paths in the output directory
are returned. Otherwise, only the file names are returned. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$list_files()&#8288;</code> returns all input and output files for current
EnergyPlus simulation.
</p>
<p>Description of all possible outputs from EnergyPlus can be found in
EnergyPlus documentation &quot;Output Details and Examples&quot;.
</p>
<p>Below gives a brief summary on the meaning of elements in the
returned list.</p>

<table>
<tr>
 <td style="text-align: left;">
   # </td><td style="text-align: left;"> Element </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> <code>ads</code> </td><td style="text-align: left;"> EnergyPlus AirflowNetwork related output </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> <code>audit</code> </td><td style="text-align: left;"> EnergyPlus inputs echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> <code>bnd</code> </td><td style="text-align: left;"> EnergyPlus branch node details </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> <code>bsmt_audit</code> </td><td style="text-align: left;"> Basement input Echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   5 </td><td style="text-align: left;"> <code>bsmt_csv</code> </td><td style="text-align: left;"> Basement CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   6 </td><td style="text-align: left;"> <code>bsmt_idf</code> </td><td style="text-align: left;"> Basement IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   7 </td><td style="text-align: left;"> <code>bsmt_out</code> </td><td style="text-align: left;"> Basement Output </td>
</tr>
<tr>
 <td style="text-align: left;">
   8 </td><td style="text-align: left;"> <code>cbor</code> </td><td style="text-align: left;"> Energyplus CBOR binary output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   9 </td><td style="text-align: left;"> <code>dbg</code> </td><td style="text-align: left;"> Energyplus debug output </td>
</tr>
<tr>
 <td style="text-align: left;">
   10 </td><td style="text-align: left;"> <code>delight</code> </td><td style="text-align: left;"> EnergyPlus DElight simulation inputs and outputs </td>
</tr>
<tr>
 <td style="text-align: left;">
   11 </td><td style="text-align: left;"> <code>dfs</code> </td><td style="text-align: left;"> EnergyPlus daylighting factor for exterior windows </td>
</tr>
<tr>
 <td style="text-align: left;">
   12 </td><td style="text-align: left;"> <code>dxf</code> </td><td style="text-align: left;"> EnergyPlus surface drawing output </td>
</tr>
<tr>
 <td style="text-align: left;">
   13 </td><td style="text-align: left;"> <code>edd</code> </td><td style="text-align: left;"> EnergyPlus EMS report </td>
</tr>
<tr>
 <td style="text-align: left;">
   14 </td><td style="text-align: left;"> <code>eio</code> </td><td style="text-align: left;"> EnergyPlus standard and optional reports </td>
</tr>
<tr>
 <td style="text-align: left;">
   15 </td><td style="text-align: left;"> <code>end</code> </td><td style="text-align: left;"> EnergyPlus simulation status in one line </td>
</tr>
<tr>
 <td style="text-align: left;">
   16 </td><td style="text-align: left;"> <code>epjson</code> </td><td style="text-align: left;"> EnergyPlus epJSON input converted from IDF </td>
</tr>
<tr>
 <td style="text-align: left;">
   17 </td><td style="text-align: left;"> <code>epmdet</code> </td><td style="text-align: left;"> EPMacro inputs echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   18 </td><td style="text-align: left;"> <code>epmidf</code> </td><td style="text-align: left;"> EPMacro IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   19 </td><td style="text-align: left;"> <code>epw</code> </td><td style="text-align: left;"> EnergyPlus Weather File input </td>
</tr>
<tr>
 <td style="text-align: left;">
   20 </td><td style="text-align: left;"> <code>err</code> </td><td style="text-align: left;"> EnergyPlus error summarry </td>
</tr>
<tr>
 <td style="text-align: left;">
   21 </td><td style="text-align: left;"> <code>eso</code> </td><td style="text-align: left;"> EnergyPlus standard output </td>
</tr>
<tr>
 <td style="text-align: left;">
   22 </td><td style="text-align: left;"> <code>experr</code> </td><td style="text-align: left;"> ExpandObjects error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   23 </td><td style="text-align: left;"> <code>expidf</code> </td><td style="text-align: left;"> ExpandObjects IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   24 </td><td style="text-align: left;"> <code>glhe</code> </td><td style="text-align: left;"> EnergyPlus ground heat exchange file </td>
</tr>
<tr>
 <td style="text-align: left;">
   25 </td><td style="text-align: left;"> <code>idf</code> </td><td style="text-align: left;"> EnergyPlus IDF input </td>
</tr>
<tr>
 <td style="text-align: left;">
   26 </td><td style="text-align: left;"> <code>imf</code> </td><td style="text-align: left;"> EPMacro IMF input </td>
</tr>
<tr>
 <td style="text-align: left;">
   27 </td><td style="text-align: left;"> <code>iperr</code> </td><td style="text-align: left;"> convertESOMTR error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   28 </td><td style="text-align: left;"> <code>ipeso</code> </td><td style="text-align: left;"> convertESOMTR standard output in IP units </td>
</tr>
<tr>
 <td style="text-align: left;">
   29 </td><td style="text-align: left;"> <code>ipmtr</code> </td><td style="text-align: left;"> convertESOMTR meter output in IP units </td>
</tr>
<tr>
 <td style="text-align: left;">
   30 </td><td style="text-align: left;"> <code>json</code> </td><td style="text-align: left;"> EnergyPlus JSON time series output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   31 </td><td style="text-align: left;"> <code>log</code> </td><td style="text-align: left;"> EnergyPlus log output </td>
</tr>
<tr>
 <td style="text-align: left;">
   32 </td><td style="text-align: left;"> <code>map</code> </td><td style="text-align: left;"> EnergyPlus daylighting intensity map output </td>
</tr>
<tr>
 <td style="text-align: left;">
   33 </td><td style="text-align: left;"> <code>mdd</code> </td><td style="text-align: left;"> EnergyPlus meter list </td>
</tr>
<tr>
 <td style="text-align: left;">
   34 </td><td style="text-align: left;"> <code>meter</code> </td><td style="text-align: left;"> EnergyPlus meter CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   35 </td><td style="text-align: left;"> <code>msgpack</code> </td><td style="text-align: left;"> EnergyPlus MessagePack binary output introduced since v9.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
   36 </td><td style="text-align: left;"> <code>mtd</code> </td><td style="text-align: left;"> EnergyPlus meter details </td>
</tr>
<tr>
 <td style="text-align: left;">
   37 </td><td style="text-align: left;"> <code>mtr</code> </td><td style="text-align: left;"> EnergyPlus meter output </td>
</tr>
<tr>
 <td style="text-align: left;">
   38 </td><td style="text-align: left;"> <code>perflog</code> </td><td style="text-align: left;"> EnergyPlus log for `PerformancePrecisionTradeoffs </td>
</tr>
<tr>
 <td style="text-align: left;">
   39 </td><td style="text-align: left;"> <code>rdd</code> </td><td style="text-align: left;"> EnergyPlus report variable names </td>
</tr>
<tr>
 <td style="text-align: left;">
   40 </td><td style="text-align: left;"> <code>rvaudit</code> </td><td style="text-align: left;"> ReadVarsESO input echo </td>
</tr>
<tr>
 <td style="text-align: left;">
   41 </td><td style="text-align: left;"> <code>sci</code> </td><td style="text-align: left;"> EnergyPlus cost benefit calculation information </td>
</tr>
<tr>
 <td style="text-align: left;">
   42 </td><td style="text-align: left;"> <code>screen</code> </td><td style="text-align: left;"> EnergyPlus window scrren transmittance map output </td>
</tr>
<tr>
 <td style="text-align: left;">
   43 </td><td style="text-align: left;"> <code>shading</code> </td><td style="text-align: left;"> EnergyPlus surface shading CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   44 </td><td style="text-align: left;"> <code>shd</code> </td><td style="text-align: left;"> EnergyPlus surface shading combination report </td>
</tr>
<tr>
 <td style="text-align: left;">
   45 </td><td style="text-align: left;"> <code>slab_ger</code> </td><td style="text-align: left;"> Slab error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   46 </td><td style="text-align: left;"> <code>slab_gtp</code> </td><td style="text-align: left;"> Slab ground temperature output </td>
</tr>
<tr>
 <td style="text-align: left;">
   47 </td><td style="text-align: left;"> <code>slab_out</code> </td><td style="text-align: left;"> Slab IDF output </td>
</tr>
<tr>
 <td style="text-align: left;">
   48 </td><td style="text-align: left;"> <code>sln</code> </td><td style="text-align: left;"> EnergyPlus <code style="white-space: pre;">&#8288;Output:Surfaces:List, Lines&#8288;</code> output </td>
</tr>
<tr>
 <td style="text-align: left;">
   49 </td><td style="text-align: left;"> <code>sqlite</code> </td><td style="text-align: left;"> EnergyPlus SQLite output </td>
</tr>
<tr>
 <td style="text-align: left;">
   50 </td><td style="text-align: left;"> <code>sqlite_err</code> </td><td style="text-align: left;"> EnergyPlus SQLite error summary </td>
</tr>
<tr>
 <td style="text-align: left;">
   51 </td><td style="text-align: left;"> <code>ssz</code> </td><td style="text-align: left;"> EnergyPlus system sizing outputs in CSV, TAB or TXT format </td>
</tr>
<tr>
 <td style="text-align: left;">
   52 </td><td style="text-align: left;"> <code>svg</code> </td><td style="text-align: left;"> HVAC-Diagram HVAC diagram output </td>
</tr>
<tr>
 <td style="text-align: left;">
   53 </td><td style="text-align: left;"> <code>table</code> </td><td style="text-align: left;"> EnergyPlus tabular outputs in CSV, TAB, TXT, HTM, or XML format </td>
</tr>
<tr>
 <td style="text-align: left;">
   54 </td><td style="text-align: left;"> <code>variable</code> </td><td style="text-align: left;"> EnergyPlus report variable CSV output </td>
</tr>
<tr>
 <td style="text-align: left;">
   55 </td><td style="text-align: left;"> <code>wrl</code> </td><td style="text-align: left;"> EnergyPlus <code style="white-space: pre;">&#8288;Output:Surfaces:List, VRML&#8288;</code> output </td>
</tr>
<tr>
 <td style="text-align: left;">
   56 </td><td style="text-align: left;"> <code>zsz</code> </td><td style="text-align: left;"> EnergyPlus system sizing outputs in CSV, TAB or TXT format </td>
</tr>
<tr>
 <td style="text-align: left;">
   57 </td><td style="text-align: left;"> <code>resource</code> </td><td style="text-align: left;"> External file resources used for the simulation, e.g. <code>Schedule:File</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h5>Returns</h5>

<p>If <code>FALSE</code>, a character vector. Otherwise, a named list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# list all files in the output directory
job$list_files(simplify = TRUE)

# get a full list of all possible inputs and outputs even though they
# may not exist for current simulation
job$list_files()

# return the full paths instead of just file names
job$locate_output(full = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusJob-locate_output"></a>



<h4>Method <code>locate_output()</code></h4>

<p>Get path of output file
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$locate_output(suffix = ".err", strict = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>suffix</code></dt><dd><p>A string that indicates the file extension of
simulation output. Default: <code>".err"</code>.</p>
</dd>
<dt><code>strict</code></dt><dd><p>If <code>TRUE</code>, it will check if the simulation was
terminated, is still running or the file exists or not.
Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$locate_output()&#8288;</code> returns the path of a single output file specified
by file suffix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get the file path of the error file
job$locate_output(".err", strict = FALSE)

# can use to detect if certain output file exists
job$locate_output(".expidf", strict = TRUE)
}

</pre>
</div>


<hr>
<a id="method-EplusJob-read_rdd"></a>



<h4>Method <code>read_rdd()</code></h4>

<p>Read Report Data Dictionary (RDD) file
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$read_rdd()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_rdd()&#8288;</code> return the core data of Report Data Dictionary (RDD)
file. For details, please see <code><a href="#topic+read_rdd">read_rdd()</a></code>.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+read_rdd">RddFile</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$read_rdd()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-read_mdd"></a>



<h4>Method <code>read_mdd()</code></h4>

<p>Read Report Data Dictionary (RDD) file
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$read_mdd()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_mdd()&#8288;</code> return the core data of Meter Data Dictionary (MDD)
file. For details, please see <code><a href="#topic+read_mdd">read_mdd()</a></code>.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+read_mdd">MddFile</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$read_mdd()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-list_table"></a>



<h4>Method <code>list_table()</code></h4>

<p>List all table names in EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$list_table()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$list_table()&#8288;</code> returns all available table and view names in the
EnergyPlus SQLite file.
</p>



<h5>Returns</h5>

<p>A character vector
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$list_table()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-read_table"></a>



<h4>Method <code>read_table()</code></h4>

<p>Read a single table from EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$read_table(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A single string specifying the name of table to read.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_table()&#8288;</code> takes a valid table <code>name</code> of those from
<a href="../../eplusr/html/EplusJob.html#method-list_table"><code>$list_table()</code></a>
and returns that table data in a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> format.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read a specific table
job$read_table("Zones")
}

</pre>
</div>


<hr>
<a id="method-EplusJob-report_data_dict"></a>



<h4>Method <code>report_data_dict()</code></h4>

<p>Read report data dictionary from EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$report_data_dict()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> which
contains all information about report data.
</p>
<p>For details on the meaning of each columns, please see &quot;2.20.2.1
ReportDataDictionary Table&quot; in EnergyPlus &quot;Output Details and
Examples&quot; documentation.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 10 columns:
</p>

<ul>
<li> <p><code>report_data_dictionary_index</code>: The integer used to link the
dictionary data to the variable data. Mainly useful when joining
different tables
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values:
<code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and
<code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>reporting_frequency</code>: Data reporting frequency
</p>
</li>
<li> <p><code>schedule_name</code>: Name the the schedule that controls reporting
frequency.
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$report_data_dict()
}

</pre>
</div>


<hr>
<a id="method-EplusJob-report_data"></a>



<h4>Method <code>report_data()</code></h4>

<p>Read report data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$report_data(
  key_value = NULL,
  name = NULL,
  year = NULL,
  tz = "UTC",
  case = "auto",
  all = FALSE,
  wide = FALSE,
  period = NULL,
  month = NULL,
  day = NULL,
  hour = NULL,
  minute = NULL,
  interval = NULL,
  simulation_days = NULL,
  day_type = NULL,
  environment_name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key_value</code></dt><dd><p>A character vector to identify key values of the
data. If <code>NULL</code>, all keys of that variable will be returned.
<code>key_value</code> can also be data.frame that contains <code>key_value</code>
and <code>name</code> columns. In this case, <code>name</code> argument in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> is ignored. All available <code>key_value</code> for
current simulation output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A character vector to identify names of the data. If
<code>NULL</code>, all names of that variable will be returned. If
<code>key_value</code> is a data.frame, <code>name</code> is ignored. All available
<code>name</code> for current simulation output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of the date time in column <code>datetime</code>. If <code>NULL</code>, it
will calculate a year value that meets the start day of week
restriction for each environment. Default: <code>NULL</code>.</p>
</dd>
<dt><code>tz</code></dt><dd><p>Time zone of date time in column <code>datetime</code>. Default:
<code>"UTC"</code>.</p>
</dd>
<dt><code>case</code></dt><dd><p>If not <code>NULL</code>, a character column will be added indicates
the case of this simulation. If <code>"auto"</code>, the name of the IDF
file without extension is used.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, extra columns are also included in the returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, the output is formatted in the same way as
standard EnergyPlus csv output file.</p>
</dd>
<dt><code>period</code></dt><dd><p>A Date or POSIXt vector used to specify which time
period to return. The year value does not matter and only
month, day, hour and minute value will be used when
subsetting. If <code>NULL</code>, all time period of data is returned.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>month, day, hour, minute</code></dt><dd><p>Each is an integer vector for month,
day, hour, minute subsetting of <code>datetime</code> column when
querying on the SQL database. If <code>NULL</code>, no subsetting is
performed on those components. All possible <code>month</code>, <code>day</code>,
<code>hour</code> and <code>minute</code> can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>interval</code></dt><dd><p>An integer vector used to specify which interval
length of report to extract. If <code>NULL</code>, all interval will be
used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simulation_days</code></dt><dd><p>An integer vector to specify which simulation
day data to extract. Note that this number resets after warmup
and at the beginning of an environment period. All possible
<code>simulation_days</code> can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.
If <code>NULL</code>, all simulation days will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>day_type</code></dt><dd><p>A character vector to specify which day type of data
to extract. All possible day types are: <code>Sunday</code>, <code>Monday</code>,
<code>Tuesday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>, <code>Saturday</code>,
<code>Holiday</code>, <code>SummerDesignDay</code>, <code>WinterDesignDay</code>, <code>CustomDay1</code>,
and <code>CustomDay2</code>. All possible values for current simulation
output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.</p>
</dd>
<dt><code>environment_name</code></dt><dd><p>A character vector to specify which
environment data to extract. If <code>NULL</code>, all environment data
are returned. Default: <code>NULL</code>. All possible
<code>environment_name</code> for current simulation output can be
obtained using:
</p>
<div class="sourceCode"><pre>$read_table("EnvironmentPeriods")
</pre></div></dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> extracts the report data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using key values, variable names and other
specifications.
</p>
<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> can also directly take all or subset output from
<code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> as input, and extract all data specified.
</p>
<p>The returned column numbers varies depending on <code>all</code> argument.
</p>

<ul>
<li> <p><code>all</code> is <code>FALSE</code>, the returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has 6 columns:
</p>

<ul>
<li> <p><code>case</code>: Simulation case specified using <code>case</code> argument
</p>
</li>
<li> <p><code>datetime</code>: The date time of simulation result
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li>
<li> <p><code>value</code>: The data value
</p>
</li></ul>

</li>
<li> <p><code>all</code> is <code>TRUE</code>, besides columns described above, extra columns are also
included:
</p>

<ul>
<li> <p><code>month</code>: The month of reported date time
</p>
</li>
<li> <p><code>day</code>: The day of month of reported date time
</p>
</li>
<li> <p><code>hour</code>: The hour of reported date time
</p>
</li>
<li> <p><code>minute</code>: The minute of reported date time
</p>
</li>
<li> <p><code>dst</code>: Daylight saving time indicator. Possible values: <code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>interval</code>: Length of reporting interval
</p>
</li>
<li> <p><code>simulation_days</code>: Day of simulation
</p>
</li>
<li> <p><code>day_type</code>: The type of day, e.g. <code>Monday</code>, <code>Tuesday</code> and etc.
</p>
</li>
<li> <p><code>environment_period_index</code>: The indices of environment.
</p>
</li>
<li> <p><code>environment_name</code>: A text string identifying the environment.
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values: <code>0</code> and
<code>1</code>
</p>
</li>
<li> <p><code>type</code>: Nature of data type with respect to state. Possible values: <code>Sum</code>
and <code>Avg</code>
</p>
</li>
<li> <p><code>index_group</code>: The report group, e.g. <code>Zone</code>, <code>System</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and <code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>reporting_frequency</code>: The reporting frequency of the variable, e.g.
<code style="white-space: pre;">&#8288;HVAC System Timestep&#8288;</code>, <code style="white-space: pre;">&#8288;Zone Timestep&#8288;</code>.
</p>
</li>
<li> <p><code>schedule_name</code>: Name of the the schedule that controls reporting
frequency.
</p>
</li></ul>

</li></ul>

<p>With the <code>datetime</code> column, it is quite straightforward to apply time-series
analysis on the simulation output. However, another painful thing is that
every simulation run period has its own <code style="white-space: pre;">&#8288;Day of Week for Start Day&#8288;</code>. Randomly
setting the <code>year</code> may result in a date time series that does not have
the same start day of week as specified in the RunPeriod objects.
</p>
<p>eplusr provides a simple solution for this. By setting <code>year</code> to <code>NULL</code>,
which is the default behavior, eplusr will calculate a year value (from
year 2017 backwards) for each run period that compliances with the start
day of week restriction.
</p>
<p>It is worth noting that EnergyPlus uses 24-hour clock system where 24 is only
used to denote midnight at the end of a calendar day. In EnergyPlus output,
&quot;00:24:00&quot; with a time interval being 15 mins represents a time period from
&quot;00:23:45&quot; to &quot;00:24:00&quot;, and similarly &quot;00:15:00&quot; represents a time period
from &quot;00:24:00&quot; to &quot;00:15:00&quot; of the next day. This means that if current day
is Friday, day of week rule applied in schedule time period &quot;00:23:45&quot; to
&quot;00:24:00&quot; (presented as &quot;00:24:00&quot; in the output) is also Friday, but not
Saturday. However, if you try to get the day of week of time &quot;00:24:00&quot; in R,
you will get Saturday, but not Friday. This introduces inconsistency and may
cause problems when doing data analysis considering day of week value.
</p>
<p>With <code>wide</code> equals <code>TRUE</code>, <code style="white-space: pre;">&#8288;$report_data()&#8288;</code> will format the simulation output
in the same way as standard EnergyPlus csv output file. Sometimes this can be
useful as there may be existing tools/workflows that depend on this format.
When both <code>wide</code> and <code>all</code> are <code>TRUE</code>, columns of runperiod environment names
and date time components are also returned, including:
<code style="white-space: pre;">&#8288;environment_period_index", "environment_name&#8288;</code>, <code>simulation_days</code>,
<code>datetime</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>day_type</code>.
</p>
<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read all report data
job$report_data()

# specify output variables using report data dictionary
dict &lt;- job$report_data_dict()
job$report_data(dict[units == "C"])

# specify output variables using 'key_value' and 'name'
job$report_data("environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
job$report_data(dict[1], year = 2020, tz = "Etc/GMT+8")

# explicitly specify case name
job$report_data(dict[1], case = "example")

# get all possible columns
job$report_data(dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
job$report_data(dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
job$report_data(dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
job$report_data(dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)

# only get specified run period data
job$read_table("EnvironmentPeriods") # possible environment name
job$report_data(dict[1], environment_name = "San Francisco Intl Ap CA USA TMY3 WMO#=724940")
# can also be done using 'environment_period_index' column
job$report_data(dict[1], all = TRUE)[environment_period_index == 3L]
}

</pre>
</div>


<hr>
<a id="method-EplusJob-tabular_data"></a>



<h4>Method <code>tabular_data()</code></h4>

<p>Read tabular data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$tabular_data(
  report_name = NULL,
  report_for = NULL,
  table_name = NULL,
  column_name = NULL,
  row_name = NULL,
  wide = FALSE,
  string_value = !wide
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>report_name, report_for, table_name, column_name, row_name</code></dt><dd><p>Each is
a character vector for subsetting when querying the SQL
database.  For the meaning of each argument, please see the
description above.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, each table will be converted into the similar
format as it is shown in EnergyPlus HTML output file. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>string_value</code></dt><dd><p>Only applicable when <code>wide</code> is <code>TRUE</code>. If
<code>string_value</code> is <code>FALSE</code>, instead of keeping all values as
characters, values in possible numeric columns are converted
into numbers. Default: the opposite of <code>wide</code>. Possible
numeric columns indicate column that:
</p>

<ul>
<li><p> columns that have associated units
</p>
</li>
<li><p> columns that contents numbers
</p>
</li></ul>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> extracts the tabular data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using report, table, column and row name
specifications. The returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has
9 columns:
</p>

<ul>
<li> <p><code>case</code>: Simulation case specified using <code>case</code> argument
</p>
</li>
<li> <p><code>index</code>: Tabular data index
</p>
</li>
<li> <p><code>report_name</code>: The name of the report that the record belongs to
</p>
</li>
<li> <p><code>report_for</code>: The <code>For</code> text that is associated with the record
</p>
</li>
<li> <p><code>table_name</code>: The name of the table that the record belongs to
</p>
</li>
<li> <p><code>column_name</code>: The name of the column that the record belongs to
</p>
</li>
<li> <p><code>row_name</code>: The name of the row that the record belongs to
</p>
</li>
<li> <p><code>units</code>: The units of the record
</p>
</li>
<li> <p><code>value</code>: The value of the record <strong>in string format</strong> by default
</p>
</li></ul>

<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 8 columns (when <code>wide</code> is
<code>FALSE</code>) or a named list of <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s where the
names are the combination of <code>report_name</code>, <code>report_for</code> and
<code>table_name</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read all tabular data
job$tabular_data()

# explicitly specify data you want
str(job$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(job$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))
}

</pre>
</div>


<hr>
<a id="method-EplusJob-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>EplusSql</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusJob$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> shows the core information of this <code>EplusJob</code> object,
including the path of model and weather, the version and path of
EnergyPlus used to run simulations, and the simulation job status.
</p>
<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> is quite useful to get the simulation status, especially
when <code>wait</code> is <code>FALSE</code> in <code style="white-space: pre;">&#8288;$run()&#8288;</code>. The job status will be updated
and printed whenever <code style="white-space: pre;">&#8288;$print()&#8288;</code> is called.
</p>



<h5>Returns</h5>

<p>The <code>EplusSql</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
job$print()
}

</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+ParametricJob">ParametricJob</a> class for EnergyPlus parametric simulations.
</p>
<p><code><a href="#topic+param_job">param_job()</a></code> for creating an EnergyPlus parametric job.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `EplusJob$new`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus("8.8")) {
    name_idf &lt;- "1ZoneUncontrolled.idf"
    name_epw &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    path_idf &lt;- path_eplus_example("8.8", name_idf)
    path_epw &lt;- path_eplus_weather("8.8", name_epw)

    # create from local files
    job &lt;- eplus_job(path_idf, path_epw)

    # create from an Idf and an Epw object
    job &lt;- eplus_job(read_idf(path_idf), read_epw(path_epw))
}

## End(Not run)

## ------------------------------------------------
## Method `EplusJob$version`
## ------------------------------------------------

## Not run: 
job$version()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$path`
## ------------------------------------------------

## Not run: 
job$path()
job$path("idf")
job$path("epw")

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$run`
## ------------------------------------------------

## Not run: 
# only run design day
job$run(NULL)

# specify output directory
job$run(dir = tempdir())

# run in the background
job$run(wait = TRUE)
# see job status
job$status()

# force to kill background job before running the new one
job$run(force = TRUE)

# do not show anything in the console
job$run(echo = FALSE)

# copy external files used in the model to simulation output directory
job$run(copy_external = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$kill`
## ------------------------------------------------

## Not run: 
job$kill()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$status`
## ------------------------------------------------

## Not run: 
job$status()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$errors`
## ------------------------------------------------

## Not run: 
job$errors()

# show all information
job$errors(info = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$output_dir`
## ------------------------------------------------

## Not run: 
job$output_dir()

# Below will open output directory
# job$output_dir(open = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$list_files`
## ------------------------------------------------

## Not run: 
# list all files in the output directory
job$list_files(simplify = TRUE)

# get a full list of all possible inputs and outputs even though they
# may not exist for current simulation
job$list_files()

# return the full paths instead of just file names
job$locate_output(full = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$locate_output`
## ------------------------------------------------

## Not run: 
# get the file path of the error file
job$locate_output(".err", strict = FALSE)

# can use to detect if certain output file exists
job$locate_output(".expidf", strict = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$read_rdd`
## ------------------------------------------------

## Not run: 
job$read_rdd()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$read_mdd`
## ------------------------------------------------

## Not run: 
job$read_mdd()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$list_table`
## ------------------------------------------------

## Not run: 
job$list_table()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$read_table`
## ------------------------------------------------

## Not run: 
# read a specific table
job$read_table("Zones")

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$report_data_dict`
## ------------------------------------------------

## Not run: 
job$report_data_dict()

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$report_data`
## ------------------------------------------------

## Not run: 
# read all report data
job$report_data()

# specify output variables using report data dictionary
dict &lt;- job$report_data_dict()
job$report_data(dict[units == "C"])

# specify output variables using 'key_value' and 'name'
job$report_data("environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
job$report_data(dict[1], year = 2020, tz = "Etc/GMT+8")

# explicitly specify case name
job$report_data(dict[1], case = "example")

# get all possible columns
job$report_data(dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
job$report_data(dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
job$report_data(dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
job$report_data(dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)

# only get specified run period data
job$read_table("EnvironmentPeriods") # possible environment name
job$report_data(dict[1], environment_name = "San Francisco Intl Ap CA USA TMY3 WMO#=724940")
# can also be done using 'environment_period_index' column
job$report_data(dict[1], all = TRUE)[environment_period_index == 3L]

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$tabular_data`
## ------------------------------------------------

## Not run: 
# read all tabular data
job$tabular_data()

# explicitly specify data you want
str(job$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(job$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))

## End(Not run)


## ------------------------------------------------
## Method `EplusJob$print`
## ------------------------------------------------

## Not run: 
job$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='eplusr_option'>Get and Set eplusr options</h2><span id='topic+eplusr_option'></span>

<h3>Description</h3>

<p>Get and set eplusr options which affect the way in which eplusr computes and
displays its results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplusr_option(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eplusr_option_+3A_...">...</code></td>
<td>
<p>Any available options to define, using <code>name = value</code>. All
available options are shown below. If no options are given, all values of
current options are returned. If a single option name, its value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>validate_level</code>: The strictness level of validation during field value
modification and model error checking. Possible value: <code>"none"</code>,
<code>"draft"</code> and <code>"final"</code> or a custom validation level using
<code><a href="#topic+custom_validate">custom_validate()</a></code>. Default: <code>"final"</code>. For what validation
components each level contains, see <code><a href="#topic+level_checks">level_checks()</a></code>.
</p>
</li>
<li> <p><code>view_in_ip</code>: Whether models should be presented in IP units. Default:
<code>FALSE</code>. It is not recommended to set this option to <code>TRUE</code> as currently
IP-units support in eplusr is not fully tested.
</p>
</li>
<li> <p><code>save_format</code>: The default format to use when saving Idf objects to <code>.idf</code> files.
Possible values: <code>"asis"</code>, <code>"sorted"</code>, <code>"new_top"</code> and <code>"new_bot"</code>.
The later three have the same effect as <code style="white-space: pre;">&#8288;Save Options&#8288;</code> settings
<code>"Sorted"</code>, <code>"Original with New at Top"</code> and <code>"Original with New at Bottom"</code> in IDF Editor, respectively. For <code>"asis"</code>, the saving format
will be set according to the header of IDF file. If no header found,
<code>"sorted"</code> is used. Default: <code>"asis"</code>.
</p>
</li>
<li> <p><code>num_parallel</code>: Maximum number of parallel simulations to run. Default:
<code>parallel::detectCores()</code>.
</p>
</li>
<li> <p><code>verbose_info</code>: Whether to show information messages. Default: <code>TRUE</code>.
</p>
</li>
<li> <p><code>autocomplete</code>: <strong>Deprecated</strong>. Whether to turn on autocompletion on class
and field names. Now autocompletion is enabled all the time.
</p>
</li></ul>



<h3>Value</h3>

<p>If called directly, a named list of input option values. If input is
a single option name, a length-one vector whose type is determined by
that option. If input is new option values, a named list of newly set
option values.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list all current options
eplusr_option() # a named list

# get a specific option value
eplusr_option("verbose_info")

# set options
eplusr_option(verbose_info = TRUE, view_in_ip = FALSE)
</code></pre>

<hr>
<h2 id='eplusr-package'>eplusr: A Toolkit for Using EnergyPlus in R</h2><span id='topic+eplusr'></span><span id='topic+eplusr-package'></span>

<h3>Description</h3>

<p>A rich toolkit of using the whole building simulation program 'EnergyPlus'(<a href="https://energyplus.net">https://energyplus.net</a>), which enables programmatic navigation, modification of 'EnergyPlus' models and makes it less painful to do parametric simulations and analysis.
</p>


<h3>Details</h3>

<p>eplusr provides a rich toolkit of using EnergyPlus directly in
R, which enables programmatic navigation, modification of EnergyPlus models
and makes it less painful to do parametric simulations and analysis.
</p>


<h3>Features</h3>


<ul>
<li><p> Download and install EnergyPlus in R
</p>
</li>
<li><p> Read, parse and modify EnergyPlus:
</p>

<ul>
<li><p> Input Data File (IDF)
</p>
</li>
<li><p> Weather File (EPW)
</p>
</li>
<li><p> Report Data Dictionary (RDD) &amp; Meter Data Dictionary (MDD)
</p>
</li>
<li><p> Error File (ERR)
</p>
</li></ul>

</li>
<li><p> Modify multiple versions of IDFs and run corresponding EnergyPlus
both in the background and in the front
</p>
</li>
<li><p> Rich-featured interfaces to query and modify IDFs
</p>
</li>
<li><p> Automatically handle referenced fields and validate input during
modification
</p>
</li>
<li><p> Take fully advantage of most common used data structure for data
science in R – data.frame
</p>

<ul>
<li><p> Extract model, weather data into data.frames
</p>
</li>
<li><p> Modify multiple objects via data.frames input
</p>
</li>
<li><p> Query output via SQL in Tidy format which is much better for
data analysis and visualization
</p>
</li></ul>

</li>
<li><p> Provide a simple yet extensible prototype of conducting parametric
simulations and collect all results in one go
</p>
</li>
<li><p> A pure R-based version updater <code><a href="#topic+transition">transition()</a></code> which is much faster than
VersionUpdater distributed with EnergyPlus
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://hongyuanjia.github.io/eplusr/">https://hongyuanjia.github.io/eplusr/</a>
</p>
</li>
<li> <p><a href="https://github.com/hongyuanjia/eplusr">https://github.com/hongyuanjia/eplusr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hongyuanjia/eplusr/issues">https://github.com/hongyuanjia/eplusr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='EplusSql'>Retrieve Simulation Outputs Using EnergyPlus SQLite Output File</h2><span id='topic+EplusSql'></span>

<h3>Description</h3>

<p><code>EplusSql</code> class wraps SQL queries that can retrieve simulation outputs using
EnergyPlus SQLite output file.
</p>


<h3>Details</h3>

<p>SQLite output is an optional output format for EnergyPlus. It will be created
if there is an object in class <code>Output:SQLite</code>. If the value of field
<code>Option</code> in class <code>Output:SQLite</code> is set to <code>"SimpleAndTabular"</code>, then
database tables related to the tabular reports will be also included.
</p>
<p>There are more than 30 tables in the SQLite output file which contains all of
the data found in EnergyPlus's tabular output files, standard variable and
meter output files, plus a number of reports that are found in the
eplusout.eio output file. The full description for SQLite outputs can be
found in the EnergyPlus <em>&quot;Output Details and Examples&quot;</em> documentation.  Note
that all column names of tables returned have been tidied, i.e. <code>"KeyValue"</code>
becomes <code>"key_value"</code>, <code>"IsMeter"</code> becomes <code>"is_meter"</code> and etc.
</p>
<p><code>EplusSql</code> class makes it possible to directly retrieve simulation results
without creating an <a href="#topic+EplusJob">EplusJob</a> object. <a href="#topic+EplusJob">EplusJob</a> can only get simulation
outputs after the job was successfully run before.
</p>
<p>However, it should be noted that, unlike <a href="#topic+EplusJob">EplusJob</a>, there is no checking on
whether the simulation is terminated or completed unsuccessfully or, the
parent Idf has been changed since last simulation. This means that you may
encounter some problems when retrieve data from an unsuccessful simulation.
It is suggested to carefully go through the <code>.err</code> file using <code><a href="#topic+read_err">read_err()</a></code> to
make sure the output data in the SQLite is correct and reliable.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EplusSql-new"><code>EplusSql$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-path"><code>EplusSql$path()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-path_idf"><code>EplusSql$path_idf()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-list_table"><code>EplusSql$list_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-read_table"><code>EplusSql$read_table()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-report_data_dict"><code>EplusSql$report_data_dict()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-report_data"><code>EplusSql$report_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-tabular_data"><code>EplusSql$tabular_data()</code></a>
</p>
</li>
<li> <p><a href="#method-EplusSql-print"><code>EplusSql$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EplusSql-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>EplusSql</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$new(sql)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>A path to an local EnergyPlus SQLite output file.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>EplusSql</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus("8.8")) {
    idf_name &lt;- "1ZoneUncontrolled.idf"
    epw_name &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    idf_path &lt;- path_eplus_example("8.8", idf_name)
    epw_path &lt;- path_eplus_weather("8.8", epw_name)

    # copy to tempdir and run the model
    idf &lt;- read_idf(idf_path)
    idf$run(epw_path, tempdir(), echo = FALSE)

    # create from local file
    sql &lt;- eplus_sql(file.path(tempdir(), "1ZoneUncontrolled.sql"))
}
}

</pre>
</div>


<hr>
<a id="method-EplusSql-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the file path of current <code>EpwSql</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$path()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path()&#8288;</code> returns the path of EnergyPlus SQLite file.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
sql$path()
}

</pre>
</div>


<hr>
<a id="method-EplusSql-path_idf"></a>



<h4>Method <code>path_idf()</code></h4>

<p>Get the path of corresponding IDF file
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$path_idf()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path_idf()&#8288;</code> returns the IDF file path with same name as the SQLite
file in the same folder. <code>NULL</code> is returned if no corresponding IDF
is found.
</p>



<h5>Returns</h5>

<p>NULL or a single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
sql$path_idf()
}

</pre>
</div>


<hr>
<a id="method-EplusSql-list_table"></a>



<h4>Method <code>list_table()</code></h4>

<p>List all table names in current EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$list_table()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$list_table()&#8288;</code> returns all available table and view names in the
EnergyPlus SQLite file.
</p>



<h5>Returns</h5>

<p>A character vector
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sql$list_table()
}

</pre>
</div>


<hr>
<a id="method-EplusSql-read_table"></a>



<h4>Method <code>read_table()</code></h4>

<p>Read a single table from current EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$read_table(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A single string specifying the name of table to read.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$read_table()&#8288;</code> takes a valid table <code>name</code> of those from
<a href="../../eplusr/html/EplusSql.html#method-list_table"><code>$list_table()</code></a>
and returns that table data in a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> format.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read a specific table
sql$read_table("Zones")
}

</pre>
</div>


<hr>
<a id="method-EplusSql-report_data_dict"></a>



<h4>Method <code>report_data_dict()</code></h4>

<p>Read report data dictionary from current EnergyPlus SQL output
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$report_data_dict()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> which
contains all information about report data.
</p>
<p>For details on the meaning of each columns, please see &quot;2.20.2.1
ReportDataDictionary Table&quot; in EnergyPlus &quot;Output Details and
Examples&quot; documentation.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 10 columns:
</p>

<ul>
<li> <p><code>report_data_dictionary_index</code>: The integer used to link the
dictionary data to the variable data. Mainly useful when joining
different tables
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values:
<code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and
<code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>reporting_frequency</code>:
</p>
</li>
<li> <p><code>schedule_name</code>: Name of the the schedule that controls reporting
frequency.
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sql$report_data_dict()
}

</pre>
</div>


<hr>
<a id="method-EplusSql-report_data"></a>



<h4>Method <code>report_data()</code></h4>

<p>Read report data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$report_data(
  key_value = NULL,
  name = NULL,
  year = NULL,
  tz = "UTC",
  case = "auto",
  all = FALSE,
  wide = FALSE,
  period = NULL,
  month = NULL,
  day = NULL,
  hour = NULL,
  minute = NULL,
  interval = NULL,
  simulation_days = NULL,
  day_type = NULL,
  environment_name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key_value</code></dt><dd><p>A character vector to identify key values of the
data. If <code>NULL</code>, all keys of that variable will be returned.
<code>key_value</code> can also be data.frame that contains <code>key_value</code>
and <code>name</code> columns. In this case, <code>name</code> argument in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> is ignored. All available <code>key_value</code> for
current simulation output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A character vector to identify names of the data. If
<code>NULL</code>, all names of that variable will be returned. If
<code>key_value</code> is a data.frame, <code>name</code> is ignored. All available
<code>name</code> for current simulation output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-report_data_dict"><code>$report_data_dict()</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of the date time in column <code>datetime</code>. If <code>NULL</code>, it
will calculate a year value that meets the start day of week
restriction for each environment. Default: <code>NULL</code>.</p>
</dd>
<dt><code>tz</code></dt><dd><p>Time zone of date time in column <code>datetime</code>. Default:
<code>"UTC"</code>.</p>
</dd>
<dt><code>case</code></dt><dd><p>A single string used to add a character column <code>case</code> in
the returned results to indicate the case of this simulation.
If <code>NULL</code>, no column is added. If <code>"auto"</code>, the name of the
IDF file without extension is used. Default: <code>"auto"</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, extra columns are also included in the returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, the output is formatted in the same way as
standard EnergyPlus csv output file.</p>
</dd>
<dt><code>period</code></dt><dd><p>A Date or POSIXt vector used to specify which time
period to return. The year value does not matter and only
month, day, hour and minute value will be used when
subsetting. If <code>NULL</code>, all time period of data is returned.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>month, day, hour, minute</code></dt><dd><p>Each is an integer vector for month,
day, hour, minute subsetting of <code>datetime</code> column when
querying on the SQL database. If <code>NULL</code>, no subsetting is
performed on those components. All possible <code>month</code>, <code>day</code>,
<code>hour</code> and <code>minute</code> can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>interval</code></dt><dd><p>An integer vector used to specify which interval
length of report to extract. If <code>NULL</code>, all interval will be
used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simulation_days</code></dt><dd><p>An integer vector to specify which simulation
day data to extract. Note that this number resets after warmup
and at the beginning of an environment period. All possible
<code>simulation_days</code> can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.
If <code>NULL</code>, all simulation days will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>day_type</code></dt><dd><p>A character vector to specify which day type of data
to extract. All possible day types are: <code>Sunday</code>, <code>Monday</code>,
<code>Tuesday</code>, <code>Wednesday</code>, <code>Thursday</code>, <code>Friday</code>, <code>Saturday</code>,
<code>Holiday</code>, <code>SummerDesignDay</code>, <code>WinterDesignDay</code>, <code>CustomDay1</code>,
and <code>CustomDay2</code>. All possible values for current simulation
output can be obtained using
<a href="../../eplusr/html/EplusSql.html#method-read_table"><code>$read_table("Time")</code></a>.
A few grouped options are also provided:
</p>

<ul>
<li> <p><code>"Weekday"</code>: All working days, i.e. from Monday to Friday
</p>
</li>
<li> <p><code>"Weekend"</code>: Saturday and Sunday
</p>
</li>
<li> <p><code>"DesignDay"</code>: Equivalent to <code>"SummerDesignDay"</code> plus <code>"WinterDesignDay"</code>
</p>
</li>
<li> <p><code>"CustomDay"</code>: CustomDay1 and CustomDay2
</p>
</li>
<li> <p><code>"SpecialDay"</code>: Equivalent to <code>"DesignDay"</code> plus <code>"CustomDay"</code>
</p>
</li>
<li> <p><code>"NormalDay"</code>: Equivalent to <code>"Weekday"</code> and <code>"Weekend"</code> plus <code>"Holiday"</code>
</p>
</li></ul>
</dd>
<dt><code>environment_name</code></dt><dd><p>A character vector to specify which
environment data to extract. If <code>NULL</code>, all environment data
are returned. Default: <code>NULL</code>. All possible
<code>environment_name</code> for current simulation output can be
obtained using:
</p>
<div class="sourceCode"><pre>$read_table("EnvironmentPeriods")
</pre></div></dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> extracts the report data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using key values, variable names and other
specifications.
</p>
<p><code style="white-space: pre;">&#8288;$report_data()&#8288;</code> can also directly take all or subset output from
<code style="white-space: pre;">&#8288;$report_data_dict()&#8288;</code> as input, and extract all data specified.
</p>
<p>The returned column numbers varies depending on <code>all</code> argument.
</p>

<ul>
<li> <p><code>all</code> is <code>FALSE</code>, the returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has 6 columns:
</p>

<ul>
<li> <p><code>case</code>: Simulation case specified using <code>case</code> argument
</p>
</li>
<li> <p><code>datetime</code>: The date time of simulation result
</p>
</li>
<li> <p><code>key_value</code>: Key name of the data
</p>
</li>
<li> <p><code>name</code>: Actual report data name
</p>
</li>
<li> <p><code>units</code>: The data units
</p>
</li>
<li> <p><code>value</code>: The data value
</p>
</li></ul>

</li>
<li> <p><code>all</code> is <code>TRUE</code>, besides columns described above, extra columns are also
included:
</p>

<ul>
<li> <p><code>month</code>: The month of reported date time
</p>
</li>
<li> <p><code>day</code>: The day of month of reported date time
</p>
</li>
<li> <p><code>hour</code>: The hour of reported date time
</p>
</li>
<li> <p><code>minute</code>: The minute of reported date time
</p>
</li>
<li> <p><code>dst</code>: Daylight saving time indicator. Possible values: <code>0</code> and <code>1</code>
</p>
</li>
<li> <p><code>interval</code>: Length of reporting interval
</p>
</li>
<li> <p><code>simulation_days</code>: Day of simulation
</p>
</li>
<li> <p><code>day_type</code>: The type of day, e.g. <code>Monday</code>, <code>Tuesday</code> and etc.
</p>
</li>
<li> <p><code>environment_period_index</code>: The indices of environment.
</p>
</li>
<li> <p><code>environment_name</code>: A text string identifying the environment.
</p>
</li>
<li> <p><code>is_meter</code>: Whether report data is a meter data. Possible values: <code>0</code> and
<code>1</code>
</p>
</li>
<li> <p><code>type</code>: Nature of data type with respect to state. Possible values: <code>Sum</code>
and <code>Avg</code>
</p>
</li>
<li> <p><code>index_group</code>: The report group, e.g. <code>Zone</code>, <code>System</code>
</p>
</li>
<li> <p><code>timestep_type</code>: Type of data timestep. Possible values: <code>Zone</code> and <code style="white-space: pre;">&#8288;HVAC System&#8288;</code>
</p>
</li>
<li> <p><code>reporting_frequency</code>: The reporting frequency of the variable, e.g.
<code style="white-space: pre;">&#8288;HVAC System Timestep&#8288;</code>, <code style="white-space: pre;">&#8288;Zone Timestep&#8288;</code>.
</p>
</li>
<li> <p><code>schedule_name</code>: Name of the the schedule that controls reporting
frequency.
</p>
</li></ul>

</li></ul>

<p>With the <code>datetime</code> column, it is quite straightforward to apply time-series
analysis on the simulation output. However, another painful thing is that
every simulation run period has its own <code style="white-space: pre;">&#8288;Day of Week for Start Day&#8288;</code>. Randomly
setting the <code>year</code> may result in a date time series that does not have
the same start day of week as specified in the RunPeriod objects.
</p>
<p>eplusr provides a simple solution for this. By setting <code>year</code> to <code>NULL</code>,
which is the default behavior, eplusr will calculate a year value (from
year 2017 backwards) for each run period that compliances with the start
day of week restriction.
</p>
<p>It is worth noting that EnergyPlus uses 24-hour clock system where 24 is only
used to denote midnight at the end of a calendar day. In EnergyPlus output,
&quot;00:24:00&quot; with a time interval being 15 mins represents a time period from
&quot;00:23:45&quot; to &quot;00:24:00&quot;, and similarly &quot;00:15:00&quot; represents a time period
from &quot;00:24:00&quot; to &quot;00:15:00&quot; of the next day. This means that if current day
is Friday, day of week rule applied in schedule time period &quot;00:23:45&quot; to
&quot;00:24:00&quot; (presented as &quot;00:24:00&quot; in the output) is also Friday, but not
Saturday. However, if you try to get the day of week of time &quot;00:24:00&quot; in R,
you will get Saturday, but not Friday. This introduces inconsistency and may
cause problems when doing data analysis considering day of week value.
</p>
<p>With <code>wide</code> equals <code>TRUE</code>, <code style="white-space: pre;">&#8288;$report_data()&#8288;</code> will format the simulation output
in the same way as standard EnergyPlus csv output file. Sometimes this can be
useful as there may be existing tools/workflows that depend on this format.
When both <code>wide</code> and <code>all</code> are <code>TRUE</code>, columns of runperiod environment names
and date time components are also returned, including:
<code style="white-space: pre;">&#8288;environment_period_index", "environment_name&#8288;</code>, <code>simulation_days</code>,
<code>datetime</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>day_type</code>.
</p>
<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$report_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read all report data
sql$report_data()

# specify output variables using report data dictionary
dict &lt;- sql$report_data_dict()
sql$report_data(dict[units == "C"])

# specify output variables using 'key_value' and 'name'
sql$report_data("environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
sql$report_data(dict[1], year = 2020, tz = "Etc/GMT+8")

# explicitly specify case name
sql$report_data(dict[1], case = "example")

# get all possible columns
sql$report_data(dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
sql$report_data(dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
sql$report_data(dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
sql$report_data(dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)

# only get specified run period data
sql$read_table("EnvironmentPeriods") # possible environment name
sql$report_data(dict[1], environment_name = "San Francisco Intl Ap CA USA TMY3 WMO#=724940")
# can also be done using 'environment_period_index' column
sql$report_data(dict[1], all = TRUE)[environment_period_index == 3L]
}

</pre>
</div>


<hr>
<a id="method-EplusSql-tabular_data"></a>



<h4>Method <code>tabular_data()</code></h4>

<p>Read tabular data
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$tabular_data(
  report_name = NULL,
  report_for = NULL,
  table_name = NULL,
  column_name = NULL,
  row_name = NULL,
  case = "auto",
  wide = FALSE,
  string_value = !wide
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>report_name, report_for, table_name, column_name, row_name</code></dt><dd><p>Each is
a character vector for subsetting when querying the SQL
database.  For the meaning of each argument, please see the
description above.</p>
</dd>
<dt><code>case</code></dt><dd><p>A single string used to add a character column <code>case</code> in
the returned results to indicate the case of this simulation.
If <code>NULL</code>, no column is added. If <code>"auto"</code>, the name of the
IDF file without extension is used. Default: <code>"auto"</code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>If <code>TRUE</code>, each table will be converted into the similar
format as it is shown in EnergyPlus HTML output file. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>string_value</code></dt><dd><p>Only applicable when <code>wide</code> is <code>TRUE</code>. If
<code>string_value</code> is <code>FALSE</code>, instead of keeping all values as
characters, values in possible numeric columns are converted
into numbers. Default: the opposite of <code>wide</code>. Possible
numeric columns indicate column that:
</p>

<ul>
<li><p> columns that have associated units
</p>
</li>
<li><p> columns that contents numbers
</p>
</li></ul>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> extracts the tabular data in a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> using report, table, column and row name
specifications. The returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> has
9 columns:
</p>

<ul>
<li> <p><code>case</code>: Simulation case specified using <code>case</code> argument
</p>
</li>
<li> <p><code>index</code>: Tabular data index
</p>
</li>
<li> <p><code>report_name</code>: The name of the report that the record belongs to
</p>
</li>
<li> <p><code>report_for</code>: The <code>For</code> text that is associated with the record
</p>
</li>
<li> <p><code>table_name</code>: The name of the table that the record belongs to
</p>
</li>
<li> <p><code>column_name</code>: The name of the column that the record belongs to
</p>
</li>
<li> <p><code>row_name</code>: The name of the row that the record belongs to
</p>
</li>
<li> <p><code>units</code>: The units of the record
</p>
</li>
<li> <p><code>value</code>: The value of the record <strong>in string format</strong> by default.
</p>
</li></ul>

<p>For convenience, input character arguments matching in
<code style="white-space: pre;">&#8288;$tabular_data()&#8288;</code> are <strong>case-insensitive</strong>.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 9 columns (when <code>wide</code> is
<code>FALSE</code>) or a named list of <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s where the
names are the combination of <code>report_name</code>, <code>report_for</code> and
<code>table_name</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read all tabular data
sql$tabular_data()

# explicitly specify data you want
str(sql$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(sql$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))
}

</pre>
</div>


<hr>
<a id="method-EplusSql-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>EplusSql</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>EplusSql$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> shows the core information of this <code>EplusSql</code> object,
including the path of the EnergyPlus SQLite file, last modified
time of the SQLite file and the path of the IDF file with the
same name in the same folder.
</p>



<h5>Returns</h5>

<p>The <code>EplusSql</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sql$print()
}

</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `EplusSql$new`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus("8.8")) {
    idf_name &lt;- "1ZoneUncontrolled.idf"
    epw_name &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    idf_path &lt;- path_eplus_example("8.8", idf_name)
    epw_path &lt;- path_eplus_weather("8.8", epw_name)

    # copy to tempdir and run the model
    idf &lt;- read_idf(idf_path)
    idf$run(epw_path, tempdir(), echo = FALSE)

    # create from local file
    sql &lt;- eplus_sql(file.path(tempdir(), "1ZoneUncontrolled.sql"))
}

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$path`
## ------------------------------------------------

## Not run: 
# get path
sql$path()

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$path_idf`
## ------------------------------------------------

## Not run: 
# get path
sql$path_idf()

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$list_table`
## ------------------------------------------------

## Not run: 
sql$list_table()

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$read_table`
## ------------------------------------------------

## Not run: 
# read a specific table
sql$read_table("Zones")

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$report_data_dict`
## ------------------------------------------------

## Not run: 
sql$report_data_dict()

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$report_data`
## ------------------------------------------------

## Not run: 
# read all report data
sql$report_data()

# specify output variables using report data dictionary
dict &lt;- sql$report_data_dict()
sql$report_data(dict[units == "C"])

# specify output variables using 'key_value' and 'name'
sql$report_data("environment", "site outdoor air drybulb temperature")

# explicitly specify year value and time zone
sql$report_data(dict[1], year = 2020, tz = "Etc/GMT+8")

# explicitly specify case name
sql$report_data(dict[1], case = "example")

# get all possible columns
sql$report_data(dict[1], all = TRUE)

# return in a format that is similar as EnergyPlus CSV output
sql$report_data(dict[1], wide = TRUE)

# return in a format that is similar as EnergyPlus CSV output with
# extra columns
sql$report_data(dict[1], wide = TRUE, all = TRUE)

# only get data at the working hour on the first Monday
sql$report_data(dict[1], hour = 8:18, day_type = "monday", simulation_days = 1:7)

# only get specified run period data
sql$read_table("EnvironmentPeriods") # possible environment name
sql$report_data(dict[1], environment_name = "San Francisco Intl Ap CA USA TMY3 WMO#=724940")
# can also be done using 'environment_period_index' column
sql$report_data(dict[1], all = TRUE)[environment_period_index == 3L]

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$tabular_data`
## ------------------------------------------------

## Not run: 
# read all tabular data
sql$tabular_data()

# explicitly specify data you want
str(sql$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy"
))

# get tabular data in wide format and coerce numeric values
str(sql$tabular_data(
    report_name = "AnnualBuildingUtilityPerformanceSummary",
    table_name = "Site and Source Energy",
    column_name = "Total Energy",
    row_name = "Total Site Energy",
    wide = TRUE, string_value = FALSE
))

## End(Not run)


## ------------------------------------------------
## Method `EplusSql$print`
## ------------------------------------------------

## Not run: 
sql$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='EPMacro'>Run EnergyPlus and its various processors</h2><span id='topic+EPMacro'></span><span id='topic+ExpandObjects'></span><span id='topic+Basement'></span><span id='topic+Slab'></span><span id='topic+EnergyPlus'></span><span id='topic+convertESOMTR'></span><span id='topic+ReadVarsESO'></span><span id='topic+HVAC_Diagram'></span><span id='topic+energyplus'></span>

<h3>Description</h3>

<p>Run EnergyPlus and its various processors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPMacro(
  model,
  output_dir = NULL,
  output_prefix = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)

ExpandObjects(
  model,
  output_dir = NULL,
  output_prefix = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL,
  idd = NULL
)

Basement(
  model,
  weather,
  output_dir = NULL,
  output_prefix = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL,
  idd = NULL
)

Slab(
  model,
  weather,
  output_dir = NULL,
  output_prefix = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL,
  idd = NULL
)

EnergyPlus(
  model,
  weather,
  output_dir = NULL,
  output_prefix = NULL,
  output_suffix = c("C", "L", "D"),
  wait = TRUE,
  echo = TRUE,
  annual = FALSE,
  design_day = FALSE,
  idd = NULL,
  eplus = NULL
)

convertESOMTR(
  eso,
  output_dir = NULL,
  output_prefix = NULL,
  rules = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)

ReadVarsESO(
  eso,
  output_dir = NULL,
  output_prefix = NULL,
  output_suffix = c("C", "L", "D"),
  max_col = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)

HVAC_Diagram(
  bnd,
  output_dir = NULL,
  output_prefix = NULL,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)

energyplus(
  model,
  weather,
  output_dir = NULL,
  output_prefix = NULL,
  output_suffix = c("C", "L", "D"),
  epmacro = TRUE,
  expand_obj = TRUE,
  annual = FALSE,
  design_day = FALSE,
  eso_to_ip = FALSE,
  readvars = TRUE,
  echo = TRUE,
  wait = TRUE,
  idd = NULL,
  eplus = NULL,
  resources = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPMacro_+3A_model">model</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A path of an EnergyPlus IDF or IMF file.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_output_dir">output_dir</code></td>
<td>
<p>[<code>character(1)</code> or <code>NULL</code>]<br />
Output directory of EnergyPlus simulation outputs. If <code>NULL</code>, the directory
where the input <code>model</code> locates is used. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_output_prefix">output_prefix</code></td>
<td>
<p>[<code>character(1)</code> or <code>NULL</code>]<br />
Prefix for EnergyPlus output file names. If <code>NULL</code>, the input <code>model</code> file
name is used.  Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_wait">wait</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>FALSE</code>, simulation is run in the background and a <a href="processx.html#topic+process">processx::process</a>
object is returned. Extra steps are needed to collect the results after the
process completes.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_echo">echo</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Wheter to show standard output and error from EnergyPlus and its pre- and
post- processors. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_eplus">eplus</code></td>
<td>
<p>[<code>character(1)</code> or <code>NULL</code>]<br />
An EnergyPlus version or a path of EnergyPlus installation directory. If
<code>NULL</code>, the version of EnergyPlus to use is determined by the version of
input <code>model</code>. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_idd">idd</code></td>
<td>
<p>[<code>character(1)</code> or <code>NULL</code>]<br />
The full path of EnergyPlus IDD (Input Data Dictionary). If <code>NULL</code>,
<code>Energy+.idd</code> file in EnergyPlus installation directory is used. Default:
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_weather">weather</code></td>
<td>
<p>[<code>character(1)</code> or <code>NULL</code>]<br />
A path of an EnergyPlus weather (EPW) file. If <code>NULL</code>, design-day-only
simulation is triggered, regardless of the <code>design_day</code> value.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_output_suffix">output_suffix</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Suffix style for EnergyPlus output file names. Should be one of the
followings:
</p>

<ul>
<li> <p><code>C</code>: <strong>Capital</strong>, e.g. <code>eplusTable.csv</code>. This is the default.
</p>
</li>
<li> <p><code>L</code>: <strong>Legacy</strong>, e.g. <code>eplustbl.csv</code>.
</p>
</li>
<li> <p><code>D</code>: <strong>Dash</strong>, e.g. <code>eplus-table.csv</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="EPMacro_+3A_annual">annual</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, annual simulation is forced. Currently, only support EnergyPlus &gt;=
v8.3. Note that <code>annual</code> and <code>design_day</code> cannot both be <code>TRUE</code>. Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_design_day">design_day</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, design-day-only simulation is forced. Currently, only support
EnergyPlus &gt;= v8.3. Note that <code>annual</code> and <code>design_day</code> cannot both be
<code>TRUE</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_eso">eso</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A path of an EnergyPlus standard output (<code>.eso</code>) or EnergyPlus meter output
(<code>.mtr</code>) file.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_bnd">bnd</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A path of an EnergyPlus branch node details (<code>.bnd</code>) file.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_epmacro">epmacro</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, EPMacro processor is called perior to simulation. Only applicable
if input file is an <code>IMF</code> file. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_expand_obj">expand_obj</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, ExpandObjects processor is called perior to simulation. Should be
<code>TRUE</code> if calling Basement or Slab preprocessors is desired. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_eso_to_ip">eso_to_ip</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, convertESOMTR post-processor is called after simulation to convert
the units of data in <code>eso</code> file from SI units to IP units. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_readvars">readvars</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, ReadVarsESO post-processor is called after to simulation. Default:
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EPMacro_+3A_resources">resources</code></td>
<td>
<p>[<code>character()</code> or <code>NULL</code>]<br />
Any external file dependencies that EnergyPlus will use for simulation. If
not <code>NULL</code>, files will be copied to the output directory. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>EPMacro()</code> calls the EnergyPlus EPMacro processor.
</p>
<p><code>ExpandObjects()</code> calls the EnergyPlus ExpandObjects processor.
</p>
<p><code>Basement()</code> calls the EnergyPlus Basement preprocessor.
</p>
<p><code>Slab()</code> calls the EnergyPlus Slab preprocessor.
</p>
<p><code>EnergyPlus()</code> calls EnergyPlus itself.
</p>
<p><code>convertESOMTR()</code> calls EnergyPlus convertESOMTR post-processor.
</p>
<p><code>ReadVarsESO()</code> calls EnergyPlus ReadVarsESO post-processor.
</p>
<p><code>HVAC_Diagram()</code> calls EnergyPlus HVAC-Diagram post-processor.
</p>
<p><code>energyplus()</code> is the one which correctly chains all the steps that call
those pre- and post- processors to form a complete EnergyPlus simulation.
</p>


<h3>Value</h3>

<p>Functions except for <code>energyplus()</code> return a list of two elements:
</p>

<ul>
<li> <p><code>file</code>: a named list of full paths of output files
</p>
</li>
<li> <p><code>run</code>: a named list of outputs from the process.
</p>
</li></ul>

<p><code>energyplus()</code> returns a list of 7 elements:
</p>

<ul>
<li> <p><code>ver</code>: EnergyPlus <a href="base.html#topic+numeric_version">version</a> used
</p>
</li>
<li> <p><code>energyplus</code>: EnergyPlus installation directory
</p>
</li>
<li> <p><code>start_time</code>: a <code><a href="base.html#topic+POSIXct">POSIXct()</a></code> giving the local time when the simulation
starts
</p>
</li>
<li> <p><code>end_time</code>: a <code><a href="base.html#topic+POSIXct">POSIXct()</a></code> giving the local time when the simulation ends
</p>
</li>
<li> <p><code>output_dir</code>: full path of output directory of simulation outputs
</p>
</li>
<li> <p><code>file</code>: a named list of relative paths of output files under <code>output_dir</code>
</p>
</li>
<li> <p><code>run</code>: a <a href="data.table.html#topic+data.table">data.table</a> of each outputs from the
all called processes
</p>
</li></ul>



<h3>Note</h3>

<p><code>energyplus()</code> can only run in waiting mode.
</p>

<hr>
<h2 id='Epw'>Read, and modify an EnergyPlus Weather File (EPW)</h2><span id='topic+Epw'></span>

<h3>Description</h3>

<p>Reading an EPW file starts with function <code><a href="#topic+read_epw">read_epw()</a></code>, which parses an EPW
file and returns an <code>Epw</code> object. The parsing process is basically the same
as [EnergyPlus/WeatherManager.cc] in EnergyPlus, with some simplifications.
</p>


<h3>Details</h3>

<p>An EPW file can be divided into two parts, headers and weather data. The
first eight lines of a standard EPW file are normally headers which contains
data of location, design conditions, typical/extreme periods, ground
temperatures, holidays/daylight savings, data periods and other comments.
<code>Epw</code> class provides methods to directly extract those data. For details on
the data structure of EPW file, please see &quot;Chapter 2 - Weather Converter
Program&quot; in EnergyPlus &quot;Auxiliary Programs&quot; documentation. An online version
can be found <a href="https://bigladdersoftware.com/epx/docs/">here</a>.
</p>
<p>There are about 35 variables in the core weather data. However, not all of
them are used by EnergyPlus. Actually, despite of date and time columns, only
13 columns are used:
</p>

<ol>
<li><p> dry bulb temperature
</p>
</li>
<li><p> dew point temperature
</p>
</li>
<li><p> relative humidity
</p>
</li>
<li><p> atmospheric pressure
</p>
</li>
<li><p> horizontal infrared radiation intensity from sky
</p>
</li>
<li><p> direct normal radiation
</p>
</li>
<li><p> diffuse horizontal radiation
</p>
</li>
<li><p> wind direction
</p>
</li>
<li><p> wind speed
</p>
</li>
<li><p> present weather observation
</p>
</li>
<li><p> present weather codes
</p>
</li>
<li><p> snow depth
</p>
</li>
<li><p> liquid precipitation depth
</p>
</li></ol>

<p><strong>Note</strong> the <code>hour</code> column in the core weather data corresponds to the period
from <strong>(Hour-1)th</strong> to <strong>(Hour)th</strong>. For instance, if the number of interval
per hour is 1, hour of 1 on a certain day corresponds to the period between
00:00:01 to 01:00:00, Hour of 2 corresponds to the period between
01:00:01 to 02:00:00, and etc. Currently, in EnergyPlus the minute column is
<strong>not used</strong> to determine currently sub-hour time. For instance, if the
number of interval per hour is 2, there is no difference between two rows
with following time columns (a) Hour 1, Minute 0; Hour 1, Minute 30 and (b)
Hour 1, Minute 30; Hour 1, Minute 60. Only the number of rows count.
When EnergyPlus reads the EPW file, both (a) and (b) represent the same time
period: 00:00:00 - 00:30:00 and 00:30:00 - 01:00:00.
Missing data on the weather file used can be summarized in the eplusout.err
file, if <code>DisplayWeatherMissingDataWarnings</code> is turned on in
<code>Output:Diagnostics</code> object. In EnergyPlus, missing data is shown only for
fields that EnergyPlus will use. EnergyPlus will fill some missing data
automatically during simulation. Likewise out of range values are counted for
each occurrence and summarized. However, note that the out of range values
will <strong>not be changed</strong> by EnergyPlus and could affect your simulation.
</p>
<p><code>Epw</code> class provides methods to easily extract and inspect those abnormal
(missing and out of range) weather data and also to know what kind of actions
that EnergyPlus will perform on those data.
</p>
<p>EnergyPlus energy model calibration often uses actual measured weather data.
In order to streamline the error-prone process of creating custom EPW file,
<code>Epw</code> provides methods to direction add, replace the core weather data.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Epw-new"><code>Epw$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-path"><code>Epw$path()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-definition"><code>Epw$definition()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-location"><code>Epw$location()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-design_condition"><code>Epw$design_condition()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-typical_extreme_period"><code>Epw$typical_extreme_period()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-ground_temperature"><code>Epw$ground_temperature()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-holiday"><code>Epw$holiday()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-comment1"><code>Epw$comment1()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-comment2"><code>Epw$comment2()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-num_period"><code>Epw$num_period()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-interval"><code>Epw$interval()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-period"><code>Epw$period()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-missing_code"><code>Epw$missing_code()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-initial_missing_value"><code>Epw$initial_missing_value()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-range_exist"><code>Epw$range_exist()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-range_valid"><code>Epw$range_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-fill_action"><code>Epw$fill_action()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-data"><code>Epw$data()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-abnormal_data"><code>Epw$abnormal_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-redundant_data"><code>Epw$redundant_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-make_na"><code>Epw$make_na()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-fill_abnormal"><code>Epw$fill_abnormal()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-add_unit"><code>Epw$add_unit()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-drop_unit"><code>Epw$drop_unit()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-purge"><code>Epw$purge()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-add"><code>Epw$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-set"><code>Epw$set()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-del"><code>Epw$del()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-is_unsaved"><code>Epw$is_unsaved()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-save"><code>Epw$save()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-print"><code>Epw$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Epw-clone"><code>Epw$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Epw-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>Epw</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$new(path, encoding = "unknown")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Either a path, a connection, or literal data (either a
single string or a raw vector) to an EnergyPlus Weather File
(EPW).  If a file path, that file usually has a extension
<code>.epw</code>.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The file encoding of input IDD. Should be one of
<code>"unknown"</code>, <code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that the file is encoded in the native
encoding.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It takes an EnergyPlus Weather File (EPW) as input and returns an
<code>Epw</code> object.
</p>



<h5>Returns</h5>

<p>An <code>Epw</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# read an EPW file from EnergyPlus website
path_base &lt;- "https://energyplus.net/weather-download"
path_region &lt;- "north_and_central_america_wmo_region_4/USA/CA"
path_file &lt;- "USA_CA_San.Francisco.Intl.AP.724940_TMY3/USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
path_epw &lt;- file.path(path_base, path_region, path_file)
epw &lt;- read_epw(path_epw)

# read an EPW file distributed with EnergyPlus
if (is_avail_eplus(8.8)) {
    path_epw &lt;- file.path(
        eplus_config(8.8)$dir,
        "WeatherData",
        "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
    )
    epw &lt;- read_epw(path_epw)
}
}

</pre>
</div>


<hr>
<a id="method-Epw-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the file path of current <code>Epw</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$path()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path()&#8288;</code> returns the full path of current <code>Epw</code> or <code>NULL</code> if the
<code>Epw</code> object is created using a character vector and not saved
locally.
</p>



<h5>Returns</h5>

<p><code>NULL</code> or a single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
epw$path()
}

</pre>
</div>


<hr>
<a id="method-Epw-definition"></a>



<h4>Method <code>definition()</code></h4>

<p>Get the <a href="#topic+IddObject">IddObject</a> object for specified EPW class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$definition(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A single string.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$definition()&#8288;</code> returns an <a href="#topic+IddObject">IddObject</a> of given EPW class. <a href="#topic+IddObject">IddObject</a>
contains all data used for parsing that EPW class.
</p>
<p>Currently, all supported EPW classes are:
</p>

<ul>
<li> <p><code>LOCATION</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;DESIGN CONDITIONS&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;TYPICAL/EXTREME PERIODS&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;GROUND TEMPERATURES&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;HOLIDAYS/DAYLIGHT SAVINGS&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;COMMENTS 1&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;COMMENTS 2&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;DATA PERIODS&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;WEATHER DATA&#8288;</code>
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
epw$definition("LOCATION")
}

</pre>
</div>


<hr>
<a id="method-Epw-location"></a>



<h4>Method <code>location()</code></h4>

<p>Get and modify LOCATION header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$location(
  city,
  state_province,
  country,
  data_source,
  wmo_number,
  latitude,
  longitude,
  time_zone,
  elevation
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>city</code></dt><dd><p>A string of city name recorded in the <code>LOCATION</code> header.</p>
</dd>
<dt><code>state_province</code></dt><dd><p>A string of state or province name recorded in
the <code>LOCATION</code> header.</p>
</dd>
<dt><code>country</code></dt><dd><p>A string of country name recorded in the <code>LOCATION</code>
header.</p>
</dd>
<dt><code>data_source</code></dt><dd><p>A string of data source recorded in the <code>LOCATION</code>
header.</p>
</dd>
<dt><code>wmo_number</code></dt><dd><p>A string of WMO (World Meteorological Organization)
number recorded in the <code>LOCATION</code> header.</p>
</dd>
<dt><code>latitude</code></dt><dd><p>A number of latitude recorded in the <code>LOCATION</code>
header. North latitude is positive and south latitude is
negative. Should in range <code style="white-space: pre;">&#8288;[-90, +90]&#8288;</code>.</p>
</dd>
<dt><code>longitude</code></dt><dd><p>A number of longitude recorded in the <code>LOCATION</code>
header. East longitude is positive and west longitude is
negative. Should in range <code style="white-space: pre;">&#8288;[-180, +180]&#8288;</code>.</p>
</dd>
<dt><code>time_zone</code></dt><dd><p>A number of time zone recorded in the <code>LOCATION</code>
header. Usually presented as the offset hours from UTC time.
Should in range <code style="white-space: pre;">&#8288;[-12, +14]&#8288;</code>.</p>
</dd>
<dt><code>elevation</code></dt><dd><p>A number of elevation recorded in the <code>LOCATION</code>
header. Should in range <code style="white-space: pre;">&#8288;[-1000, 9999.9)&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$location()&#8288;</code> takes new values for <code>LOCATION</code> header fields and
returns the parsed values of <code>LOCATION</code> header in a list format. If
no input is given, current <code>LOCATION</code> header value is returned.
</p>



<h5>Returns</h5>

<p>A named list of 9 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$location()

# modify location data
epw$location(city = "MyCity")
}

</pre>
</div>


<hr>
<a id="method-Epw-design_condition"></a>



<h4>Method <code>design_condition()</code></h4>

<p>Get DESIGN CONDITION header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$design_condition()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$design_condition()&#8288;</code> returns the parsed values of <code style="white-space: pre;">&#8288;DESIGN CONDITION&#8288;</code>
header in a list format with 4 elements:
</p>

<ul>
<li> <p><code>source</code>: A string of source field
</p>
</li>
<li> <p><code>heating</code>: A list, usually of length 16, of the heading design conditions
</p>
</li>
<li> <p><code>cooling</code>: A list, usually of length 32, of the cooling design conditions
</p>
</li>
<li> <p><code>extremes</code>: A list, usually of length 16, of the extreme design conditions
</p>
</li></ul>

<p>For the meaning of each element, please see ASHRAE Handbook of Fundamentals.
</p>



<h5>Returns</h5>

<p>A named list of 4 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$design_condition()
}

</pre>
</div>


<hr>
<a id="method-Epw-typical_extreme_period"></a>



<h4>Method <code>typical_extreme_period()</code></h4>

<p>Get TYPICAL/EXTREME header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$typical_extreme_period()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$typical_extreme_period()&#8288;</code> returns the parsed values of <code style="white-space: pre;">&#8288;TYPICAL/EXTREME PERIOD&#8288;</code> header in a <a href="data.table.html#topic+data.table">data.table</a> format with 6
columns:
</p>

<ul>
<li> <p><code>index</code>: Integer type. The index of typical or extreme period record
</p>
</li>
<li> <p><code>name</code>: Character type. The name of typical or extreme period record
</p>
</li>
<li> <p><code>type</code>: Character type. The type of period. Possible value: <code>typical</code> and
<code>extreme</code>
</p>
</li>
<li> <p><code>start_day</code>: Date type with customized formatting. The start day of the
period
</p>
</li>
<li> <p><code>start_day</code>: Date type with customized formatting. The end day of the
period
</p>
</li></ul>




<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 6 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$typical_extreme_period()
}

</pre>
</div>


<hr>
<a id="method-Epw-ground_temperature"></a>



<h4>Method <code>ground_temperature()</code></h4>

<p>Get GROUND TEMPERATURE header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$ground_temperature()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$ground_temperature()&#8288;</code> returns the parsed values of <code style="white-space: pre;">&#8288;GROUND TEMPERATURE&#8288;</code>
header in a <a href="data.table.html#topic+data.table">data.table</a> format with 17 columns:
</p>

<ul>
<li> <p><code>index</code>: Integer type. The index of ground temperature record
</p>
</li>
<li> <p><code>depth</code>: Numeric type. The depth of the ground temperature is measured
</p>
</li>
<li> <p><code>soil_conductivity</code>: Numeric type. The soil conductivity at measured depth
</p>
</li>
<li> <p><code>soil_density</code>: Numeric type. The soil density at measured depth
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;soil_specific heat&#8288;</code>: Numeric type. The soil specific heat at measured depth
</p>
</li>
<li> <p><code>January</code> to <code>December</code>: Numeric type. The measured group
temperature for each month.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 17 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$ground_temperature()
}

</pre>
</div>


<hr>
<a id="method-Epw-holiday"></a>



<h4>Method <code>holiday()</code></h4>

<p>Get and modify HOLIDAYS/DAYLIGHT SAVINGS header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$holiday(leapyear, dst, holiday)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>leapyear</code></dt><dd><p>Either <code>TRUE</code> or <code>FALSE</code>.</p>
</dd>
<dt><code>dst</code></dt><dd><p>A length 2 EPW date specifications identifying the start
and end of daylight saving time. For example, <code>c(3.10, 10.3)</code>.</p>
</dd>
<dt><code>holiday</code></dt><dd><p>a list or a data.frame containing two elements
(columns) <code>name</code> and <code>day</code> where <code>name</code> are the holiday names
and <code>day</code> are valid EPW date specifications. For example:
</p>
<div class="sourceCode"><pre>list(name = c("New Year's Day", "Christmas Day"), day = c("1.1", "25 Dec"))
</pre></div></dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$holiday()&#8288;</code> takes new value for leap year indicator, daylight saving time
and holiday specifications, set these new values and returns the parsed values
of <code style="white-space: pre;">&#8288;HOLIDAYS/DAYLIGHT SAVINGS&#8288;</code> header. If no input is given, current values
of <code style="white-space: pre;">&#8288;HOLIDAYS/DAYLIGHT SAVINGS&#8288;</code> header is returned. It returns a list of 3
elements:
</p>

<ul>
<li> <p><code>leapyear</code>: A single logical vector. <code>TRUE</code> means that the weather data
contains leap year data
</p>
</li>
<li> <p><code>dst</code>: A Date vector contains the start and end day of daylight saving time
</p>
</li>
<li> <p><code>holiday</code>: A <a href="data.table.html#topic+data.table">data.table</a> contains 2 columns. If
no holiday specified, an empty <a href="data.table.html#topic+data.table">data.table</a>
</p>

<ul>
<li> <p><code>name</code>: Name of the holiday
</p>
</li>
<li> <p><code>day</code>: Date of the holiday
</p>
</li></ul>

</li></ul>

<p>Validation process below is performed when changing the <code>leapyear</code>
indicator:
</p>

<ul>
<li><p> If current record of <code>leapyear</code> is <code>TRUE</code>, but new input is <code>FALSE</code>, the
modification is only conducted when all data periods do not cover Feb 29.
</p>
</li>
<li><p> If current record of <code>leapyear</code> is <code>FALSE</code>, but new input is <code>TRUE</code>, the
modification is only conducted when TMY data periods do not across Feb,
e.g. [01/02, 02/28], [03/01, 12/31]; for AMY data, it is always OK.
</p>
</li></ul>

<p>The date specifications in <code>dst</code> and <code>holiday</code> should follow the rules of
<strong>&quot;Table 2.14: Weather File Date File Interpretation&quot;</strong> in
&quot;AuxiliaryPrograms&quot; documentation. eplusr is able to handle all those kinds of
formats automatically. Basically, 5 formats are allowed:
</p>

<ol>
<li><p> A single integer is interpreted as the Julian day of year. For example,
<code>1</code>, <code>2</code>, <code>3</code> and <code>4</code> will be parsed and presented as <code style="white-space: pre;">&#8288;1st day&#8288;</code>, <code style="white-space: pre;">&#8288;2nd day&#8288;</code>, <code style="white-space: pre;">&#8288;3rd day&#8288;</code> and <code style="white-space: pre;">&#8288;4th day&#8288;</code>.
</p>
</li>
<li><p> A single number is interpreted as <code>Month.Day</code>. For example, <code>1.2</code> and <code>5.6</code>
will be parsed and presented as <code style="white-space: pre;">&#8288;Jan 02&#8288;</code> and <code style="white-space: pre;">&#8288;May 06&#8288;</code>.
</p>
</li>
<li><p> A string giving <code>MonthName / DayNumber</code>, <code>DayNumber / MonthName</code>, and
<code>MonthNumber / DayNumber</code>. A year number can be also included. For
example, <code>"Jan/1"</code>, <code>"05/Dec"</code>, <code>"7/8"</code>, <code>"02/10/2019"</code>, and
<code>"2019/04/05"</code> will be parsed and presented as <code style="white-space: pre;">&#8288;Jan 02&#8288;</code>, <code style="white-space: pre;">&#8288;Dec 06&#8288;</code>, <code style="white-space: pre;">&#8288;Jul 8&#8288;</code>, <code>2019-02-10</code> and <code>2019-04-15</code>.
</p>
</li>
<li><p> A string giving <code style="white-space: pre;">&#8288;number Weekday in Month&#8288;</code>. For example, <code>"2 Sunday in Jan"</code> will be parsed and presented as <code style="white-space: pre;">&#8288;2th Sunday in January&#8288;</code>.
</p>
</li>
<li><p> A string giving <code style="white-space: pre;">&#8288;Last Weekday in Month&#8288;</code>. For example, <code>"last Sunday in Dec"</code> will be parsed and presented as <code style="white-space: pre;">&#8288;Last Sunday in December&#8288;</code>.
</p>
</li></ol>

<p>For convenience, besides all the formats described above, <code>dst</code> and days in
<code>holiday</code> also accept standard Dates input. They will be treated as the same
way as No.3 format described above.
</p>



<h5>Returns</h5>

<p>A named list of 3 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$holiday()

# add daylight saving time
epw$holiday(dst = c(3.10, 11.3))
}

</pre>
</div>


<hr>
<a id="method-Epw-comment1"></a>



<h4>Method <code>comment1()</code></h4>

<p>Get and modify COMMENT1 header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$comment1(comment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>A string of new comments.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$comment1()&#8288;</code> takes a single string of new comments and replaces the
old comment with input one. If <code>NULL</code> is given, the comment is
removed. Empty string or a string that contains only spaces will be
treated as <code>NULL</code>. If no input is given, current comment is returned.
If no comments exist, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$comment1()

epw$comment1("Comment1")
}

</pre>
</div>


<hr>
<a id="method-Epw-comment2"></a>



<h4>Method <code>comment2()</code></h4>

<p>Get and modify COMMENT2 header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$comment2(comment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>A string of new comments.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$comment2()&#8288;</code> takes a single string of new comments and replaces the
old comment with input one. If <code>NULL</code> is given, the comment is
removed. Empty string or a string that contains only spaces will be
treated as <code>NULL</code>. If no input is given, current comment is returned.
If no comments exist, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$comment2()

epw$comment2("Comment2")
}

</pre>
</div>


<hr>
<a id="method-Epw-num_period"></a>



<h4>Method <code>num_period()</code></h4>

<p>Get number of data periods in DATA PERIODS header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$num_period()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$num_period()&#8288;</code> returns a single positive integer of how many data
periods current <code>Epw</code> contains.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$num_period()
}

</pre>
</div>


<hr>
<a id="method-Epw-interval"></a>



<h4>Method <code>interval()</code></h4>

<p>Get the time interval in DATA PERIODS header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$interval()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$interval()&#8288;</code> returns a single positive integer of how many records
of weather data exist in one hour.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$interval()
}

</pre>
</div>


<hr>
<a id="method-Epw-period"></a>



<h4>Method <code>period()</code></h4>

<p>Get and modify data period meta data in DATA PERIODS header
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$period(period, name, start_day_of_week)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>period</code></dt><dd><p>A positive integer vector identifying the data period
indexes.</p>
</dd>
<dt><code>name</code></dt><dd><p>A character vector used as new names for specified data
periods. Should have the same length as <code>index</code>.</p>
</dd>
<dt><code>start_day_of_week</code></dt><dd><p>A character vector or an integer vector used
as the new start days of week of specified data periods.
Should have the same length as <code>index</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$period()&#8288;</code> takes a data period index, a new period name and start
day of week specification, and uses that input to replace the data
period's name and start day of week. If no input is given, data
periods in current <code>Epw</code> is returned.
</p>



<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 5 columns:
</p>

<ul>
<li> <p><code>index</code>: Integer type. The index of data period.
</p>
</li>
<li> <p><code>name</code>: Character type. The name of data period.
</p>
</li>
<li> <p><code>start_day_of_week</code>: Character type. The start day of week of data period.
</p>
</li>
<li> <p><code>start_day</code>: Date (EpwDate) type. The start day of data period.
</p>
</li>
<li> <p><code>end_day</code>: Date (EpwDate) type. The end day of data period.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# modify data period name
epw$period(1, name = "test")

# change start day of week
epw$period(1, start_day_of_week = 3)
}

</pre>
</div>


<hr>
<a id="method-Epw-missing_code"></a>



<h4>Method <code>missing_code()</code></h4>

<p>Get missing code for weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$missing_code()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$missing_code()&#8288;</code> returns a list of 29 elements containing the value
used as missing value identifier for all weather data.
</p>



<h5>Returns</h5>

<p>A named list of 29 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$missing_code()
}

</pre>
</div>


<hr>
<a id="method-Epw-initial_missing_value"></a>



<h4>Method <code>initial_missing_value()</code></h4>

<p>Get initial value for missing data of weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$initial_missing_value()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$initial_missing_value()&#8288;</code> returns a list of 16 elements containing
the initial value used to replace missing values for corresponding
weather data.
</p>



<h5>Returns</h5>

<p>A named list of 16 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$initial_missing_value()
}

</pre>
</div>


<hr>
<a id="method-Epw-range_exist"></a>



<h4>Method <code>range_exist()</code></h4>

<p>Get value ranges for existing values of weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$range_exist()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$range_exist()&#8288;</code> returns a list of 28 elements containing the range
each numeric weather data should fall in. Any values out of this
range are treated as missing.
</p>



<h5>Returns</h5>

<p>A named list of 28 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$range_exist()
}

</pre>
</div>


<hr>
<a id="method-Epw-range_valid"></a>



<h4>Method <code>range_valid()</code></h4>

<p>Get value ranges for valid values of weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$range_valid()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$range_valid()&#8288;</code> returns a list of 28 elements containing the range
each numeric weather data should fall in. Any values out of this
range are treated as invalid.
</p>



<h5>Returns</h5>

<p>A named list of 28 elements.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$range_valid()
}

</pre>
</div>


<hr>
<a id="method-Epw-fill_action"></a>



<h4>Method <code>fill_action()</code></h4>

<p>Get fill actions for abnormal values of weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$fill_action(type = c("missing", "out_of_range"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>What abnormal type of actions to return. Should be one of
<code>"missing"</code> and <code>"out_of_range"</code>. Default: <code>"missing"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$fill_action()&#8288;</code> returns a list containing <code>action</code>s that EnergyPlus
will perform when certain abnormal data found for corresponding
weather data. There are 3 types of actions in total:
</p>

<ul>
<li> <p><code>do_nothing</code>: All abnormal values are left as they are.
</p>
</li>
<li> <p><code>use_zero</code>: All abnormal values are reset to zeros.
</p>
</li>
<li> <p><code>use_previous</code>: The first abnormal values of variables will be set to the
initial missing values. All after are set to previous valid one.
</p>
</li></ul>




<h5>Returns</h5>

<p>A named list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$fill_action("missing")

epw$fill_action("out_of_range")
}

</pre>
</div>


<hr>
<a id="method-Epw-data"></a>



<h4>Method <code>data()</code></h4>

<p>Get weather data
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$data(
  period = 1L,
  start_year = NULL,
  align_wday = TRUE,
  tz = "UTC",
  update = FALSE,
  line = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>period</code></dt><dd><p>A single positive integer identifying the data period
index. Data periods information can be obtained using
<a href="../../eplusr/html/Epw.html#method-period"><code>$period()</code></a>
described above.</p>
</dd>
<dt><code>start_year</code></dt><dd><p>A positive integer identifying the year of first
date time in specified data period. If <code>NULL</code>, the values in
the <code>year</code> column are used as years of <code>datetime</code> column.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>align_wday</code></dt><dd><p>Only applicable when <code>start_year</code> is <code>NULL</code>. If
<code>TRUE</code>, a year value is automatically calculated for specified
data period that compliance with the start day of week value
specified in <code style="white-space: pre;">&#8288;DATA PERIODS&#8288;</code> header.</p>
</dd>
<dt><code>tz</code></dt><dd><p>A valid time zone to be assigned to the <code>datetime</code> column.
All valid time zone names can be obtained using
<code>OlsonNames()</code>. Default:<code>"UTC"</code>.</p>
</dd>
<dt><code>update</code></dt><dd><p>If <code>TRUE</code>, the <code>year</code> column are updated according to
the newly created <code>datetime</code> column using <code>start_year</code>. If
<code>FALSE</code>, original year data in the <code>Epw</code> object is kept.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>line</code></dt><dd><p>If <code>TRUE</code>, a column named <code>line</code> is prepended indicating
the line numbers where data occur in the actual EPW file.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$data()&#8288;</code> returns weather data of specific data period.
</p>
<p>Usually, EPW file downloaded from <a href="https://energyplus.net/">EnergyPlus website</a>
contains TMY weather data. As years of weather data is not
consecutive, it may be more convenient to align the year values to be
consecutive, which will makes it possible to direct analyze and plot
weather data. The <code>start_year</code> argument in <code style="white-space: pre;">&#8288;$data()&#8288;</code> method can help
to achieve this. However, randomly setting the <code>year</code> may result in a
date time series that does not have the same start day of week as
specified in the <code style="white-space: pre;">&#8288;DATA PERIODS&#8288;</code> header.  eplusr provides a simple
solution for this. By setting <code>year</code> to <code>NULL</code> and <code>align_wday</code> to
<code>TRUE</code>, eplusr will calculate a year value (from current year
backwards) for each data period that compliance with the start day of
week restriction.
</p>
<p>Note that if current data period contains AMY data and <code>start_year</code>
is given, a warning is given because the actual year values will be
overwritten by input <code>start_year</code>. An error is given if:
</p>

<ul>
<li><p> Using input <code>start_year</code> introduces invalid date time. This may
happen when weather data contains leap year but input <code>start_year</code>
is not a leap year.
</p>
</li>
<li><p> Applying specified time zone specified using <code>tz</code> introduces
invalid date time.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 36 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get weather data
str(epw$data())

# get weather data but change the year to 2018
# the year column is not changed by default, only the returned datetime column
head(epw$data(start_year = 2018)$datetime)
str(epw$data(start_year = 2018)$year)
# you can update the year column too
head(epw$data(start_year = 2018, update = TRUE)$year)

# change the time zone of datetime column in the returned weather data
attributes(epw$data()$datetime)
attributes(epw$data(tz = "Etc/GMT+8")$datetime)
}

</pre>
</div>


<hr>
<a id="method-Epw-abnormal_data"></a>



<h4>Method <code>abnormal_data()</code></h4>

<p>Get abnormal weather data
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$abnormal_data(
  period = 1L,
  cols = NULL,
  keep_all = TRUE,
  type = c("both", "missing", "out_of_range")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>period</code></dt><dd><p>A single positive integer identifying the data period
index. Data periods information can be obtained using
<a href="../../eplusr/html/Epw.html#method-period"><code>$period()</code></a>
described above.</p>
</dd>
<dt><code>cols</code></dt><dd><p>A character vector identifying what data columns, i.e.
all columns except <code>datetime</code>, <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>
<code>minute</code>, and character columns, to search abnormal values. If
<code>NULL</code>, all data columns are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>keep_all</code></dt><dd><p>If <code>TRUE</code>, all columns are returned. If <code>FALSE</code>, only
<code>line</code>, <code>datetime</code>, <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> and
<code>minute</code>, together with columns specified in <code>cols</code> are
returned. Default: <code>TRUE</code></p>
</dd>
<dt><code>type</code></dt><dd><p>What abnormal type of data to return. Should be one of
<code>"all"</code>, <code>"missing"</code> and <code>"out_of_range"</code>. Default: <code>"all"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$abnormal_data()&#8288;</code> returns abnormal data of specific data period.
Basically, there are 2 types of abnormal data in <code>Epw</code>, i.e. missing
values and out-of-range values. Sometimes, it may be useful to
extract and inspect those data especially when inserting measured
weather data. <code style="white-space: pre;">&#8288;$abnormal_data()&#8288;</code> does this.
</p>
<p>In the returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>, a column named <code>line</code>
is created indicating the line numbers where abnormal data occur in
the actual EPW file.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$abnormal_data()

# only check if there are any abnormal values in air temperature and
# liquid precipitation rate
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"))

# save as above, but only return date time columns plus those 2 columns
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    keep_all = FALSE
)

# same as above, but only check for missing values
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    type = "missing"
)

# same as above, but only check for out-of-range values
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    type = "out_of_range"
)
}

</pre>
</div>


<hr>
<a id="method-Epw-redundant_data"></a>



<h4>Method <code>redundant_data()</code></h4>

<p>Get redundant weather data
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$redundant_data()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$redundant_data()&#8288;</code> returns weather data in <code>Epw</code> object that do not
belong to any data period. This data can be further removed using
<a href="../../eplusr/html/Epw.html#method-purge"><code>$purge()</code></a>'
method described below.
</p>
<p>In the returned <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>, a column named <code>line</code>
is created indicating the line numbers where redundant data occur in
the actual EPW file.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 37 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$redundant_data()
}

</pre>
</div>


<hr>
<a id="method-Epw-make_na"></a>



<h4>Method <code>make_na()</code></h4>

<p>Convert abnormal data into NAs
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$make_na(missing = FALSE, out_of_range = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>missing</code></dt><dd><p>If <code>TRUE</code>, missing values are included. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>out_of_range</code></dt><dd><p>If <code>TRUE</code>, out-of-range values are included.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$make_na()&#8288;</code> converts specified abnormal data into <code>NA</code>s in specified
data period. This makes it easier to find abnormal data directly
using <code>is.na()</code> instead of using
<a href="../../eplusr/html/Epw.html#method-missing_code"><code>$missing_code()</code></a>
</p>
<p><code style="white-space: pre;">&#8288;$make_na()&#8288;</code> and
<a href="../../eplusr/html/Epw.html#method-fill_abnormal"><code>$fill_abnormal()</code></a>
are reversible, i.e.
<code style="white-space: pre;">&#8288;$make_na()&#8288;</code> can be used to counteract the effects introduced by
<a href="../../eplusr/html/Epw.html#method-make_na"><code>$make_na()</code></a>,
and vise a versa.
</p>
<p><strong>Note</strong> that <code style="white-space: pre;">&#8288;$make_na&#8288;</code> modify the weather data in-place, meaning
that the returned data from
<a href="../../eplusr/html/Epw.html#method-data"><code>$data()</code></a>
and
<a href="../../eplusr/html/Epw.html#method-abnormal_data"><code>$abnormal_data()</code></a>
may be different after calling <code style="white-space: pre;">&#8288;$make_na()&#8288;</code>.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# turn all missing values into NAs
summary(epw$data()$liquid_precip_rate)
epw$make_na(missing = TRUE)
summary(epw$data()$liquid_precip_rate)
}

</pre>
</div>


<hr>
<a id="method-Epw-fill_abnormal"></a>



<h4>Method <code>fill_abnormal()</code></h4>

<p>Fill abnormal data using prescribed pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$fill_abnormal(missing = FALSE, out_of_range = FALSE, special = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>missing</code></dt><dd><p>If <code>TRUE</code>, missing values are included. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>out_of_range</code></dt><dd><p>If <code>TRUE</code>, out-of-range values are included.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>special</code></dt><dd><p>If <code>TRUE</code>, abnormal data are filled using
corresponding actions listed
<a href="../../eplusr/html/Epw.html#method-fill_action"><code>$fill_action()</code></a>.
If <code>FALSE</code>, all abnormal data are fill with missing code
described in
<a href="../../eplusr/html/Epw.html#method-missing_code"><code>$missing_code()</code></a>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$fill_abnormal()&#8288;</code> fills specified abnormal data using corresponding
actions listed in
<a href="../../eplusr/html/Epw.html#method-fill_action"><code>$fill_action()</code></a>.
For what kinds of actions to be performed, please see
<a href="../../eplusr/html/Epw.html#method-fill_action"><code>$fill_action()</code></a>.
method described above. Note that only if <code>special</code> is <code>TRUE</code>,
special actions listed in <code style="white-space: pre;">&#8288;$fill_action()&#8288;</code> is performed. If <code>special</code>
is <code>FALSE</code>, all abnormal data, including both missing values and
out-of-range values, are filled with corresponding missing codes.
</p>
<p><a href="../../eplusr/html/Epw.html#method-make_na"><code>$make_na()</code></a>
and <code style="white-space: pre;">&#8288;$fill_abnormal()&#8288;</code> are reversible, i.e.
<a href="../../eplusr/html/Epw.html#method-make_na"><code>$make_na()</code></a>
can be used to counteract the effects introduced by
<code style="white-space: pre;">&#8288;$fill_abnormal()&#8288;</code>, and vise a versa.
</p>
<p><strong>Note</strong> that <code style="white-space: pre;">&#8288;$fill_abnormal&#8288;</code> modify the weather data in-place,
meaning that the returned data from
<a href="../../eplusr/html/Epw.html#method-data"><code>$data()</code></a>
and
<a href="../../eplusr/html/Epw.html#method-abnormal_data"><code>$abnormal_data()</code></a>
may be different after calling <code style="white-space: pre;">&#8288;$fill_abnormal()&#8288;</code>.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# turn all missing values into NAs
summary(epw$data()$liquid_precip_rate)
epw$fill_abnormal(missing = TRUE)
summary(epw$data()$liquid_precip_rate)
}

</pre>
</div>


<hr>
<a id="method-Epw-add_unit"></a>



<h4>Method <code>add_unit()</code></h4>

<p>Add units to weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$add_unit()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$add_unit()&#8288;</code> assigns units to numeric weather data using
<code><a href="units.html#topic+units">units::set_units()</a></code> if applicable.
</p>
<p><code style="white-space: pre;">&#8288;$add_unit()&#8288;</code>
and
<a href="../../eplusr/html/Epw.html#method-drop_unit"><code>$drop_unit()</code></a>
are reversible, i.e.
<code style="white-space: pre;">&#8288;$add_unit()&#8288;</code>
can be used to counteract the effects introduced by
<a href="../../eplusr/html/Epw.html#method-drop_unit"><code>$drop_unit()</code></a>,
and vise a versa.
</p>
<p><strong>Note</strong> that <code style="white-space: pre;">&#8288;$add_unit&#8288;</code> modify the weather data in-place,
meaning that the returned data from
<a href="../../eplusr/html/Epw.html#method-data"><code>$data()</code></a>
and
<a href="../../eplusr/html/Epw.html#method-abnormal_data"><code>$abnormal_data()</code></a>
may be different after calling <code style="white-space: pre;">&#8288;$add_unit()&#8288;</code>.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get weather data with units
epw$add_unit()
head(epw$data())

# with units specified, you can easily perform unit conversion using units
# package
t_dry_bulb &lt;- epw$data()$dry_bulb_temperature
units(t_dry_bulb) &lt;- with(units::ud_units, "kelvin")

head(t_dry_bulb)
}

</pre>
</div>


<hr>
<a id="method-Epw-drop_unit"></a>



<h4>Method <code>drop_unit()</code></h4>

<p>Remove units in weather data variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$drop_unit()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$drop_unit()&#8288;</code> removes all units of numeric weather data.
</p>
<p><a href="../../eplusr/html/Epw.html#method-add_unit"><code>$add_unit()</code></a>
and
<code style="white-space: pre;">&#8288;$drop_unit()&#8288;</code>
are reversible, i.e.
<a href="../../eplusr/html/Epw.html#method-drop_unit"><code>$add_unit()</code></a>
can be used to counteract the effects introduced by
<code style="white-space: pre;">&#8288;$drop_unit()&#8288;</code>,
and vise a versa.
</p>
<p><strong>Note</strong> that <code style="white-space: pre;">&#8288;$add_unit&#8288;</code> modify the weather data in-place,
meaning that the returned data from
<a href="../../eplusr/html/Epw.html#method-data"><code>$data()</code></a>
and
<a href="../../eplusr/html/Epw.html#method-abnormal_data"><code>$abnormal_data()</code></a>
may be different after calling <code style="white-space: pre;">&#8288;$add_unit()&#8288;</code>.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$drop_unit()
epw$data()
}

</pre>
</div>


<hr>
<a id="method-Epw-purge"></a>



<h4>Method <code>purge()</code></h4>

<p>Delete redundant weather data observations
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$purge()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$purge()&#8288;</code> deletes weather data in <code>Epw</code> object that do not belong to
any data period.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$purge()
}

</pre>
</div>


<hr>
<a id="method-Epw-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add a data period
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$add(
  data,
  realyear = FALSE,
  name = NULL,
  start_day_of_week = NULL,
  after = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of new weather data to add
or set. Validation is performed according to rules described
above.</p>
</dd>
<dt><code>realyear</code></dt><dd><p>Whether input data is AMY data. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A new string used as name of added or set data period.
Should not be the same as existing data period names. If
<code>NULL</code>, it is generated automatically in format <code>Data</code>,
<code>Data_1</code> and etc., based on existing data period names.
Default: <code>NULL</code></p>
</dd>
<dt><code>start_day_of_week</code></dt><dd><p>A single integer or character specifying
start day of week of input data period. If <code>NULL</code>, Sunday is
used for TMY data and the actual start day of week is used for
AMY data.  Default: <code>NULL</code>.</p>
</dd>
<dt><code>after</code></dt><dd><p>A single integer identifying the index of data period
where input new data period to be inserted after. IF <code>0</code>,
input new data period will be the first data period. Default:
<code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$add()&#8288;</code> adds a new data period into current <code>Epw</code> object at
specified position.
</p>
<p>The validity of input data is checked before adding according to
rules following:
</p>

<ul>
<li><p> Column <code>datetime</code> exists and has type of <code>POSIXct</code>. Note that time
zone of input date time will be reset to <code>UTC</code>.
</p>
</li>
<li><p> It assumes that input data is already sorted, i.e. no further
sorting is made during validation. This is because when input data
is TMY data, there is no way to properly sort input data rows only
using <code>datetime</code> column.
</p>
</li>
<li><p> Number of data records per hour should be consistent across input
data.
</p>
</li>
<li><p> Input number of data records per hour should be the same as
existing data periods.
</p>
</li>
<li><p> The date time of input data should not overlap with existing data
periods.
</p>
</li>
<li><p> Input data should have all 29 weather data columns with correct
types. The <code>year</code>, <code>month</code>, <code>day</code>, and <code>minute</code> column are not
compulsory. They will be created according to values in the
<code>datetime</code> column. Existing values will be overwritten.
</p>
</li></ul>




<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# will fail since date time in input data has already been covered by
# existing data period
try(epw$add(epw$data()), silent = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Epw-set"></a>



<h4>Method <code>set()</code></h4>

<p>Replace a data period
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$set(
  data,
  realyear = FALSE,
  name = NULL,
  start_day_of_week = NULL,
  period = 1L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of new weather data to add
or set. Validation is performed according to rules described
above.</p>
</dd>
<dt><code>realyear</code></dt><dd><p>Whether input data is AMY data. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>A new string used as name of added or set data period.
Should not be the same as existing data period names. If
<code>NULL</code>, it is generated automatically in format <code>Data</code>,
<code>Data_1</code> and etc., based on existing data period names.
Default: <code>NULL</code></p>
</dd>
<dt><code>start_day_of_week</code></dt><dd><p>A single integer or character specifying
start day of week of input data period. If <code>NULL</code>, Sunday is
used for TMY data and the actual start day of week is used for
AMY data.  Default: <code>NULL</code>.</p>
</dd>
<dt><code>period</code></dt><dd><p>A single integer identifying the index of data period
to set.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$set()&#8288;</code> replaces existing data period using input new weather data.
</p>
<p>The validity of input data is checked before replacing according to
rules following:
</p>

<ul>
<li><p> Column <code>datetime</code> exists and has type of <code>POSIXct</code>. Note that time
zone of input date time will be reset to <code>UTC</code>.
</p>
</li>
<li><p> It assumes that input data is already sorted, i.e. no further
sorting is made during validation. This is because when input data
is TMY data, there is no way to properly sort input data rows only
using <code>datetime</code> column.
</p>
</li>
<li><p> Number of data records per hour should be consistent across input
data.
</p>
</li>
<li><p> Input number of data records per hour should be the same as
existing data periods.
</p>
</li>
<li><p> The date time of input data should not overlap with existing data
periods.
</p>
</li>
<li><p> Input data should have all 29 weather data columns with right
types. The <code>year</code>, <code>month</code>, <code>day</code>, and <code>minute</code> column are not
compulsory. They will be created according to values in the
<code>datetime</code> column. Existing values will be overwritten.
</p>
</li></ul>




<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# change the weather data
epw$set(epw$data())
}

</pre>
</div>


<hr>
<a id="method-Epw-del"></a>



<h4>Method <code>del()</code></h4>

<p>Delete a data period
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$del(period)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>period</code></dt><dd><p>A single integer identifying the index of data period
to set.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$del()&#8288;</code> removes a specified data period. Note that an error will be
given if current <code>Epw</code> only contains one data period.
</p>



<h5>Returns</h5>

<p>The modified <code>Epw</code> object itself, invisibly.
</p>


<hr>
<a id="method-Epw-is_unsaved"></a>



<h4>Method <code>is_unsaved()</code></h4>

<p>Check if there are unsaved changes in current <code>Epw</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$is_unsaved()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_unsaved()&#8288;</code> returns <code>TRUE</code> if there are modifications on the
<code>Epw</code> object since it was read or since last time it was saved, and
returns <code>FALSE</code> otherwise.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$is_unsaved()
}

</pre>
</div>


<hr>
<a id="method-Epw-save"></a>



<h4>Method <code>save()</code></h4>

<p>Save <code>Epw</code> object as an EPW file
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$save(path = NULL, overwrite = FALSE, purge = FALSE, format_digit = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>A path where to save the weather file. If <code>NULL</code>, the
path of the weather file itself is used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>Whether to overwrite the file if it already exists.
Default is <code>FALSE</code>.</p>
</dd>
<dt><code>purge</code></dt><dd><p>Whether to remove redundant data when saving. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>format_digit</code></dt><dd><p>Whether to remove trailing digits in weather
data. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$save()&#8288;</code> saves current <code>Epw</code> to an EPW file. Note that if missing
values and out-of-range values are converted to <code>NA</code>s using
<a href="../../eplusr/html/Epw.html#method-make_na"><code>$make_na()</code></a>,
they will be filled with corresponding missing codes during saving.
</p>



<h5>Returns</h5>

<p>A length-one character vector, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# save the weather file
epw$save(file.path(tempdir(), "weather.epw"), overwrite = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Epw-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>Idf</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the <code>Epw</code> object, including location, elevation,
data source, WMO station, leap year indicator, interval and data
periods.
</p>



<h5>Returns</h5>

<p>The <code>Epw</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
epw$print()
}

</pre>
</div>


<hr>
<a id="method-Epw-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Epw$clone(deep = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Epw$new`
## ------------------------------------------------

## Not run: 
# read an EPW file from EnergyPlus website
path_base &lt;- "https://energyplus.net/weather-download"
path_region &lt;- "north_and_central_america_wmo_region_4/USA/CA"
path_file &lt;- "USA_CA_San.Francisco.Intl.AP.724940_TMY3/USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
path_epw &lt;- file.path(path_base, path_region, path_file)
epw &lt;- read_epw(path_epw)

# read an EPW file distributed with EnergyPlus
if (is_avail_eplus(8.8)) {
    path_epw &lt;- file.path(
        eplus_config(8.8)$dir,
        "WeatherData",
        "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
    )
    epw &lt;- read_epw(path_epw)
}

## End(Not run)


## ------------------------------------------------
## Method `Epw$path`
## ------------------------------------------------

## Not run: 
# get path
epw$path()

## End(Not run)


## ------------------------------------------------
## Method `Epw$definition`
## ------------------------------------------------

## Not run: 
# get path
epw$definition("LOCATION")

## End(Not run)


## ------------------------------------------------
## Method `Epw$location`
## ------------------------------------------------

## Not run: 
epw$location()

# modify location data
epw$location(city = "MyCity")

## End(Not run)


## ------------------------------------------------
## Method `Epw$design_condition`
## ------------------------------------------------

## Not run: 
epw$design_condition()

## End(Not run)


## ------------------------------------------------
## Method `Epw$typical_extreme_period`
## ------------------------------------------------

## Not run: 
epw$typical_extreme_period()

## End(Not run)


## ------------------------------------------------
## Method `Epw$ground_temperature`
## ------------------------------------------------

## Not run: 
epw$ground_temperature()

## End(Not run)


## ------------------------------------------------
## Method `Epw$holiday`
## ------------------------------------------------

## Not run: 
epw$holiday()

# add daylight saving time
epw$holiday(dst = c(3.10, 11.3))

## End(Not run)


## ------------------------------------------------
## Method `Epw$comment1`
## ------------------------------------------------

## Not run: 
epw$comment1()

epw$comment1("Comment1")

## End(Not run)


## ------------------------------------------------
## Method `Epw$comment2`
## ------------------------------------------------

## Not run: 
epw$comment2()

epw$comment2("Comment2")

## End(Not run)


## ------------------------------------------------
## Method `Epw$num_period`
## ------------------------------------------------

## Not run: 
epw$num_period()

## End(Not run)


## ------------------------------------------------
## Method `Epw$interval`
## ------------------------------------------------

## Not run: 
epw$interval()

## End(Not run)


## ------------------------------------------------
## Method `Epw$period`
## ------------------------------------------------

## Not run: 
# modify data period name
epw$period(1, name = "test")

# change start day of week
epw$period(1, start_day_of_week = 3)

## End(Not run)


## ------------------------------------------------
## Method `Epw$missing_code`
## ------------------------------------------------

## Not run: 
epw$missing_code()

## End(Not run)


## ------------------------------------------------
## Method `Epw$initial_missing_value`
## ------------------------------------------------

## Not run: 
epw$initial_missing_value()

## End(Not run)


## ------------------------------------------------
## Method `Epw$range_exist`
## ------------------------------------------------

## Not run: 
epw$range_exist()

## End(Not run)


## ------------------------------------------------
## Method `Epw$range_valid`
## ------------------------------------------------

## Not run: 
epw$range_valid()

## End(Not run)


## ------------------------------------------------
## Method `Epw$fill_action`
## ------------------------------------------------

## Not run: 
epw$fill_action("missing")

epw$fill_action("out_of_range")

## End(Not run)


## ------------------------------------------------
## Method `Epw$data`
## ------------------------------------------------

## Not run: 
# get weather data
str(epw$data())

# get weather data but change the year to 2018
# the year column is not changed by default, only the returned datetime column
head(epw$data(start_year = 2018)$datetime)
str(epw$data(start_year = 2018)$year)
# you can update the year column too
head(epw$data(start_year = 2018, update = TRUE)$year)

# change the time zone of datetime column in the returned weather data
attributes(epw$data()$datetime)
attributes(epw$data(tz = "Etc/GMT+8")$datetime)

## End(Not run)


## ------------------------------------------------
## Method `Epw$abnormal_data`
## ------------------------------------------------

## Not run: 
epw$abnormal_data()

# only check if there are any abnormal values in air temperature and
# liquid precipitation rate
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"))

# save as above, but only return date time columns plus those 2 columns
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    keep_all = FALSE
)

# same as above, but only check for missing values
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    type = "missing"
)

# same as above, but only check for out-of-range values
epw$abnormal_data(cols = c("dry_bulb_temperature", "liquid_precip_rate"),
    type = "out_of_range"
)

## End(Not run)


## ------------------------------------------------
## Method `Epw$redundant_data`
## ------------------------------------------------

## Not run: 
epw$redundant_data()

## End(Not run)


## ------------------------------------------------
## Method `Epw$make_na`
## ------------------------------------------------

## Not run: 
# turn all missing values into NAs
summary(epw$data()$liquid_precip_rate)
epw$make_na(missing = TRUE)
summary(epw$data()$liquid_precip_rate)

## End(Not run)


## ------------------------------------------------
## Method `Epw$fill_abnormal`
## ------------------------------------------------

## Not run: 
# turn all missing values into NAs
summary(epw$data()$liquid_precip_rate)
epw$fill_abnormal(missing = TRUE)
summary(epw$data()$liquid_precip_rate)

## End(Not run)


## ------------------------------------------------
## Method `Epw$add_unit`
## ------------------------------------------------

## Not run: 
# get weather data with units
epw$add_unit()
head(epw$data())

# with units specified, you can easily perform unit conversion using units
# package
t_dry_bulb &lt;- epw$data()$dry_bulb_temperature
units(t_dry_bulb) &lt;- with(units::ud_units, "kelvin")

head(t_dry_bulb)

## End(Not run)


## ------------------------------------------------
## Method `Epw$drop_unit`
## ------------------------------------------------

## Not run: 
epw$drop_unit()
epw$data()

## End(Not run)


## ------------------------------------------------
## Method `Epw$purge`
## ------------------------------------------------

## Not run: 
epw$purge()

## End(Not run)


## ------------------------------------------------
## Method `Epw$add`
## ------------------------------------------------

## Not run: 
# will fail since date time in input data has already been covered by
# existing data period
try(epw$add(epw$data()), silent = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Epw$set`
## ------------------------------------------------

## Not run: 
# change the weather data
epw$set(epw$data())

## End(Not run)


## ------------------------------------------------
## Method `Epw$is_unsaved`
## ------------------------------------------------

## Not run: 
epw$is_unsaved()

## End(Not run)


## ------------------------------------------------
## Method `Epw$save`
## ------------------------------------------------

## Not run: 
# save the weather file
epw$save(file.path(tempdir(), "weather.epw"), overwrite = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Epw$print`
## ------------------------------------------------

## Not run: 
epw$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='expand_idf_dots_literal'>Parse object values given in literal character vectors or data.frames</h2><span id='topic+expand_idf_dots_literal'></span>

<h3>Description</h3>

<p>Parse object values given in literal character vectors or data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_idf_dots_literal(idd_env, idf_env, ..., .default = TRUE, .exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_idf_dots_literal_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_literal_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_literal_+3A_...">...</code></td>
<td>
<p>Character vectors or data.frames.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_literal_+3A_.default">.default</code></td>
<td>
<p>If <code>TRUE</code>, all empty fields will be filled with default
values if possible. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_literal_+3A_.exact">.exact</code></td>
<td>
<p>If <code>TRUE</code>, all inputs should match existing objects in the
<a href="#topic+Idf">Idf</a>. In this case, <code>id</code> column is require for data.frame input.
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For object definitions in character vector format, they follow the
same rules as a normal IDF file:
</p>

<ul>
<li><p> Each object starts with a class name and a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Separates each values with a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Ends an object with a semicolon (<code style="white-space: pre;">&#8288;;&#8288;</code>) for the last value.
</p>
</li></ul>

<p>Each character vector can contain:
</p>

<ul>
<li><p> One single object, e.g. <code>c("Building,", "MyBuilding;")</code>, or &quot;Building, MyBuilding;&quot;.
</p>
</li>
<li><p> Multiple objects, e.g. <code>c("Building, MyBuilding;", "SimulationControl, Yes")</code>.
</p>
</li></ul>

<p>You can also provide an option header to indicate if input objects are
presented in IP units, using <code style="white-space: pre;">&#8288;!-Option ViewInIPunits&#8288;</code>. If this header does
not exist, then all values are treated as in SI units.
</p>
<p>For object definitions in data.frame format, a valid definition requires at
least three columns described below. Note that column order does not matter.
</p>

<ul>
<li> <p><code>class</code>:Character type. Valid class names in the underlying
<a href="#topic+Idd">Idd</a> object.
</p>
</li>
<li> <p><code>index</code>:Integer type. Valid field indices for each class.
</p>
</li>
<li> <p><code>value</code>:Character type or list type. Value for each field
to be added.
</p>

<ul>
<li><p> If character type, each value should be given as a string even if the
corresponding field is a numeric type.
</p>
</li>
<li><p> If list type, each value should have the right type as the corresponding
field definition.
</p>
</li></ul>

</li>
<li> <p><code>id</code>: <strong>Optional</strong> when <code>.exact</code> is <code>FALSE</code>. Integer type.
If input data.frame includes multiple object definitions in a same class,
values in <code>id</code> column will be used to distinguish each definition. If <code>id</code>
column does not exists, it assumes that each definition is separated by
<code>class</code> column and will issue an error if there is any duplication in the
<code>index</code> column.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list of 2 element <code>object</code> and <code>value</code> which is a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with object data and value data respectively.
</p>


<h3>Note</h3>

<p>Objects from character vectors will always be at the top of each table.
</p>

<hr>
<h2 id='expand_idf_dots_name'>Parse object ID or name specifications given in list format</h2><span id='topic+expand_idf_dots_name'></span>

<h3>Description</h3>

<p>Parse object ID or name specifications given in list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_idf_dots_name(
  idd_env,
  idf_env,
  ...,
  .keep_name = TRUE,
  .property = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_idf_dots_name_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_name_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_name_+3A_...">...</code></td>
<td>
<p>Lists of object ID or name pair, e.g. <code>c(Name1, Name2)</code>, <code>c(ID1, ID2)</code>, <code>NewName = OldName</code> and <code>NewName = ID</code>. <code>NewName</code> is optional.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_name_+3A_.keep_name">.keep_name</code></td>
<td>
<p>If <code>TRUE</code>, input new names will be kept in a column named
<code>new_object_name</code>, otherwise they will be dropped. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_name_+3A_.property">.property</code></td>
<td>
<p>A character vector of column names in class table to return.
Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> containing extracted object data.
</p>

<hr>
<h2 id='expand_idf_dots_object'>Parse object values given in a list of Idf or IdfObject format</h2><span id='topic+expand_idf_dots_object'></span>

<h3>Description</h3>

<p>Parse object values given in a list of Idf or IdfObject format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_idf_dots_object(
  idd_env,
  idf_env,
  ...,
  .unique = TRUE,
  .strict = TRUE,
  .complete = TRUE,
  .all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_idf_dots_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_...">...</code></td>
<td>
<p>Lists of <a href="#topic+Idf">Idf</a>s or <a href="#topic+IdfObject">IdfObject</a>s.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_.unique">.unique</code></td>
<td>
<p>If <code>TRUE</code>, make sure there are no duplicated objects in the
input. If <code>FALSE</code>, duplicates are kept. If <code>NULL</code>, duplicates are
removed. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_.strict">.strict</code></td>
<td>
<p>If <code>TRUE</code>, make sure all input objects come from the same
version as that from <code>idf_env</code>. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_.complete">.complete</code></td>
<td>
<p>If <code>TRUE</code>, make sure the returned field number meets the
<code style="white-space: pre;">&#8288;\min-fields&#8288;</code> requirement. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="expand_idf_dots_object_+3A_.all">.all</code></td>
<td>
<p>If <code>TRUE</code>, make sure the all possible fields are returned.
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 3 <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>: <code>meta</code>, <code>object</code> and
<code>value</code>.
</p>

<hr>
<h2 id='expand_idf_dots_value'>Parse object field values given in list format</h2><span id='topic+expand_idf_dots_value'></span>

<h3>Description</h3>

<p>Parse object field values given in list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_idf_dots_value(
  idd_env,
  idf_env,
  ...,
  .type = "class",
  .complete = TRUE,
  .all = FALSE,
  .scalar = TRUE,
  .pair = FALSE,
  .ref_assign = TRUE,
  .unique = TRUE,
  .empty = TRUE,
  .default = TRUE,
  .env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_idf_dots_value_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_...">...</code></td>
<td>
<p>Lists of object definitions. Each list should be named
with a valid class/object id/name. ID should be denoted in style
<code>..ID</code>. There is a special element <code>.comment</code> in each list, which will
be used as new comments of the object. If <code>.ref_assign</code> is <code>TRUE</code>,
<code style="white-space: pre;">&#8288;:=&#8288;</code> can be used to group ids/names:
</p>

<ul>
<li><p> When <code>.type</code> equals <code>"class"</code>, LHS multiple class indices/names should be
wrapped by <code>.()</code>, <code>c()</code>.
</p>
</li>
<li><p> When <code>.type</code> equals <code>"object"</code>, LHS multiple object ids/names should be
wrapped by <code>.()</code> or <code>c()</code>. LHS <strong>SINGLE</strong> class name should be
wrapped by <code>..()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.type">.type</code></td>
<td>
<p>Should be either <code>"class"</code> or <code>"object"</code>. If <code>"class"</code>,
id/name of each input will be treated as class index/name. If <code>"object"</code>,
id/name of each input will be treated as object id/name.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.complete">.complete</code></td>
<td>
<p>If <code>TRUE</code>, make sure the returned field number meets the
<code style="white-space: pre;">&#8288;\min-fields&#8288;</code> requirement. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.all">.all</code></td>
<td>
<p>If <code>TRUE</code>, make sure the all possible fields are returned.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.scalar">.scalar</code></td>
<td>
<p>If <code>TRUE</code>, make sure the value of each field in the object is a
scalar value. If <code>FALSE</code>, <code>value_chr</code> and <code>value_num</code> column will be
list type. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.pair">.pair</code></td>
<td>
<p>Only works when <code>.scalar</code> is <code>FALSE</code>. If <code>.pair</code> is <code>TRUE</code>,
vector field values will be paired to each id/name on the LHS. In this
case, <code>value_chr</code> and <code>value_num</code> will be character type and double
type, respectively. When there is only one id/name on the LHS, it will
be replicated to match the length of the value vector. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.ref_assign">.ref_assign</code></td>
<td>
<p>If <code>TRUE</code>, allow using <code style="white-space: pre;">&#8288;:=&#8288;</code> to gather multiple
classes/objects on the LHS when defining the objects. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.unique">.unique</code></td>
<td>
<p>If <code>TRUE</code>, make sure there are no duplicated classes/objects in
the input. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.empty">.empty</code></td>
<td>
<p>If <code>TRUE</code>, allow using an empty list, i.e. <code>list()</code> to define an
object with all default values. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.default">.default</code></td>
<td>
<p>If <code>TRUE</code>, all empty fields will be filled with default
values if possible. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expand_idf_dots_value_+3A_.env">.env</code></td>
<td>
<p>An environment specifying the environment to evaluate the <code>...</code>.
Default: <code><a href="base.html#topic+parent.frame">parent.frame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 2 element <code>object</code> and <code>value</code> which is a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with object data and value data respectively.
</p>

<hr>
<h2 id='expand_idf_regex'>Parse regular expression of object field values</h2><span id='topic+expand_idf_regex'></span>

<h3>Description</h3>

<p>Parse regular expression of object field values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_idf_regex(
  idd_env,
  idf_env,
  pattern,
  replacement = NULL,
  class = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_idf_regex_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_regex_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="expand_idf_regex_+3A_pattern">pattern</code></td>
<td>
<p>A single string of regular expression used to match field
values</p>
</td></tr>
<tr><td><code id="expand_idf_regex_+3A_class">class</code></td>
<td>
<p>A character vector specifying the target class names</p>
</td></tr>
<tr><td><code id="expand_idf_regex_+3A_ignore.case">ignore.case</code>, <code id="expand_idf_regex_+3A_perl">perl</code>, <code id="expand_idf_regex_+3A_fixed">fixed</code>, <code id="expand_idf_regex_+3A_usebytes">useBytes</code></td>
<td>
<p>All of them are
directly passed to <a href="base.html#topic+grep">base::grepl</a> and
<a href="base.html#topic+grep">base::gsub</a> with the same default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 2 <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>: <code>object</code> and <code>value</code>.
</p>

<hr>
<h2 id='format.Idd'>Format an Idd</h2><span id='topic+format.Idd'></span>

<h3>Description</h3>

<p>Format an <a href="#topic+Idd">Idd</a> into a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Idd'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.Idd_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Idd">Idd</a> object.</p>
</td></tr>
<tr><td><code id="format.Idd_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single length character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
format(use_idd(8.8, download = "auto"))

## End(Not run)

</code></pre>

<hr>
<h2 id='format.IddObject'>Format an IddObject</h2><span id='topic+format.IddObject'></span>

<h3>Description</h3>

<p>Format an <a href="#topic+IddObject">IddObject</a> into a string. It is formatted the same way as
<code>IddObject$print(brief = TRUE)</code> but with a suffix of current IDD version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IddObject'
format(x, ver = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.IddObject_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+IddObject">IddObject</a> object.</p>
</td></tr>
<tr><td><code id="format.IddObject_+3A_ver">ver</code></td>
<td>
<p>If <code>TRUE</code>, a suffix of version string is added. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="format.IddObject_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single length character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
format(use_idd(8.8, download = "auto")$Material)

## End(Not run)

</code></pre>

<hr>
<h2 id='format.Idf'>Format an Idf Object</h2><span id='topic+format.Idf'></span>

<h3>Description</h3>

<p>Format an <a href="#topic+Idf">Idf</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Idf'
format(
  x,
  comment = TRUE,
  header = TRUE,
  format = eplusr_option("save_format"),
  leading = 4L,
  sep_at = 29L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.Idf_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object.</p>
</td></tr>
<tr><td><code id="format.Idf_+3A_comment">comment</code></td>
<td>
<p>If <code>FALSE</code>, all comments will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="format.Idf_+3A_header">header</code></td>
<td>
<p>If <code>FALSE</code>, the header will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="format.Idf_+3A_format">format</code></td>
<td>
<p>Specific format used when formatting. For details, please see
<code style="white-space: pre;">&#8288;$save()&#8288;</code>. Default: <code>eplusr_option("save_format")</code></p>
</td></tr>
<tr><td><code id="format.Idf_+3A_leading">leading</code></td>
<td>
<p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</td></tr>
<tr><td><code id="format.Idf_+3A_sep_at">sep_at</code></td>
<td>
<p>The character width to separate value string and field string.
Default: <code>29L</code> which is the same as IDF Editor.</p>
</td></tr>
<tr><td><code id="format.Idf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single length string.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf_path &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")
cat(format(read_idf(idf_path, use_idd(8.8, "auto")), leading = 0))

## End(Not run)
</code></pre>

<hr>
<h2 id='format.IdfObject'>Format an IdfObject</h2><span id='topic+format.IdfObject'></span>

<h3>Description</h3>

<p>Format an <a href="#topic+IddObject">IddObject</a> into a character vector in the same way as in IDF Editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IdfObject'
format(x, comment = TRUE, leading = 4L, sep_at = 29L, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.IdfObject_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+IdfObject">IdfObject</a> object.</p>
</td></tr>
<tr><td><code id="format.IdfObject_+3A_comment">comment</code></td>
<td>
<p>If <code>FALSE</code>, all comments will not be included. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="format.IdfObject_+3A_leading">leading</code></td>
<td>
<p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</td></tr>
<tr><td><code id="format.IdfObject_+3A_sep_at">sep_at</code></td>
<td>
<p>The character width to separate value string and field string.
Default: <code>29L</code> which is the same as IDF Editor.</p>
</td></tr>
<tr><td><code id="format.IdfObject_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, values of all possible fields in current class the
<a href="#topic+IdfObject">IdfObject</a> belongs to are returned. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="format.IdfObject_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"),
    idd = use_idd("8.8", download = "auto"))

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]

cat(format(mat, leading = 0, sep_at = 10))

## End(Not run)

</code></pre>

<hr>
<h2 id='get_env'>Get the enclosed environment of an R6 object</h2><span id='topic+get_env'></span><span id='topic+get_self_env'></span><span id='topic+get_priv_env'></span><span id='topic+get_super_env'></span>

<h3>Description</h3>

<p>Get the enclosed environment of an R6 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_self_env(x)

get_priv_env(x)

get_super_env(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_env_+3A_x">x</code></td>
<td>
<p>An R6 object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_super_env()</code> returns the <code>super</code> enclosed environment of an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code>
object.
</p>
<p><code>get_self_env()</code> returns the <code>self</code> enclosed environment of an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code>
object.
</p>
<p><code>get_priv_env()</code> returns the <code>private</code> enclosed environment of an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code>
object.
</p>


<h3>Value</h3>

<p>An environment.
</p>

<hr>
<h2 id='get_idd_class'>Get class data</h2><span id='topic+get_idd_class'></span>

<h3>Description</h3>

<p>Get class data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idd_class(idd_env, class = NULL, property = NULL, underscore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idd_class_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idd_class_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. If <code>NULL</code>, all classes are returned.</p>
</td></tr>
<tr><td><code id="get_idd_class_+3A_property">property</code></td>
<td>
<p>A character vector of column names in class table to return.
If <code>NULL</code>, only class index columns are returned, plus column <code>rleid</code>.</p>
</td></tr>
<tr><td><code id="get_idd_class_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name will be converted into
underscore style name first and column <code>class_name_us</code> will be used
for matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing specified columns.
</p>

<hr>
<h2 id='get_idd_field'>Get field data</h2><span id='topic+get_idd_field'></span>

<h3>Description</h3>

<p>Get field data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idd_field(
  idd_env,
  class,
  field = NULL,
  property = NULL,
  all = FALSE,
  underscore = TRUE,
  no_ext = FALSE,
  complete = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idd_field_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_field">field</code></td>
<td>
<p>An integer vector of valid field indexes or a character
vector of valid field names (can be in in underscore style).  <code>class</code>
and <code>field</code> should have the same length.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_property">property</code></td>
<td>
<p>A character vector of column names in field table to return.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name and field names will be
converted into underscore style name first and column <code>class_name_us</code>
and <code>field_name_us</code> will be used for matching.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_no_ext">no_ext</code></td>
<td>
<p>If <code>TRUE</code>, no new extensible groups will be added even if there
are no matched input found and an error will be issued right away.</p>
</td></tr>
<tr><td><code id="get_idd_field_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code>, at least fields till the current whole extensible
group will be returned. A new column named &quot;matched_rleid&quot; will be
created (when <code>property</code> is NULL) indicating if given field has been
matched or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing specified columns.
</p>

<hr>
<h2 id='get_idd_relation'>Get field relation data</h2><span id='topic+get_idd_relation'></span>

<h3>Description</h3>

<p>Get field relation data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idd_relation(
  idd_env,
  class_id = NULL,
  field_id = NULL,
  direction = c("ref_to", "ref_by"),
  depth = 0L,
  name = FALSE,
  class = NULL,
  group = NULL,
  keep_all = FALSE,
  class_ref = c("both", "none", "all"),
  match_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idd_relation_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_class_id">class_id</code></td>
<td>
<p>An integer vector of valid class indexes. Should be <code>NULL</code> if
<code>field_id</code> is given.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_field_id">field_id</code></td>
<td>
<p>An integer vector of valid field id. Should be <code>NULL</code> if
<code>class_id</code> is given.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_direction">direction</code></td>
<td>
<p>The relation direction to extract. Should be one of
<code>"ref_to"</code> or <code>"ref_by"</code>.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_depth">depth</code></td>
<td>
<p>If &gt; 0, the relation is searched recursively. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_name">name</code></td>
<td>
<p>If <code>TRUE</code>, additional formatting columns are added and an
<code>IddRelation</code> object is returned. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_class">class</code>, <code id="get_idd_relation_+3A_group">group</code></td>
<td>
<p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_class_ref">class_ref</code></td>
<td>
<p>Specify how to handle class-name-references. There are 3
options in total, i.e. <code>"none"</code>, <code>"both"</code> and <code>"all"</code>, with <code>"both"</code>
being the default.
* <code>"none"</code>: just ignore class-name-references.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. This is the default
option.
* <code>"all"</code>: include all class-name-references. This is the most aggressive
option.</p>
</td></tr>
<tr><td><code id="get_idd_relation_+3A_match_all">match_all</code></td>
<td>
<p>If <code>TRUE</code>, relation search will continue even though one
relation has been found. If <code>FALSE</code>, searching is stopped whenever one
relation is found in specified classes/groups. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>

<hr>
<h2 id='get_idf_node_relation'>Extract node relations</h2><span id='topic+get_idf_node_relation'></span>

<h3>Description</h3>

<p>Extract node relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf_node_relation(
  idd_env,
  idf_env,
  object_id = NULL,
  value_id = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  name = FALSE,
  keep_all = FALSE,
  depth = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idf_node_relation_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_object_id">object_id</code></td>
<td>
<p>An integer vector of valid object IDs. If <code>NULL</code>, all object
IDs in current IDF will be used.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_value_id">value_id</code></td>
<td>
<p>An integer vector of valid value IDs. If <code>NULL</code>, all value
IDs in current IDF will be used.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_object">object</code></td>
<td>
<p>An integer vector of valid object IDs or a character vector
of valid object names to specify the targeting relation objects.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names to specify the targeting relation classes.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_group">group</code></td>
<td>
<p>A character vector of valid group names to specify the targeting
relation groups. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_name">name</code></td>
<td>
<p>If <code>TRUE</code>, all class, object, field value ID and name columns
will be added and a <code>IdfRelationTo</code> or <code>IdfRelationBy</code> object is
returned with customized printing method. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>TRUE</code>, all input ID are kept. Otherwise, only input IDs
that have relations are kept. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_node_relation_+3A_depth">depth</code></td>
<td>
<p>Recursive reference relation depth. <code>NULL</code> means infinite.
Default: <code>0L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>

<hr>
<h2 id='get_idf_object'>Get object data</h2><span id='topic+get_idf_object'></span>

<h3>Description</h3>

<p>Get object data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf_object(
  idd_env,
  idf_env,
  class = NULL,
  object = NULL,
  property = NULL,
  underscore = FALSE,
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_object">object</code></td>
<td>
<p>An integer vector of valid object IDs or a character vector
of valid object names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_property">property</code></td>
<td>
<p>A character vector of column names in class table to return.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name will be converted into
underscore style name first and column <code>class_name_us</code> will be used
for matching. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_object_+3A_ignore_case">ignore_case</code></td>
<td>
<p>If <code>TRUE</code>, input object name will be converted into lower
case and column <code>object_name_lower</code> will be used for matching.
converted into underscore style name first and column <code>class_name_us</code>
and <code>field_name_us</code> will be used for matching. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>

<hr>
<h2 id='get_idf_relation'>Extract object and value reference relations</h2><span id='topic+get_idf_relation'></span>

<h3>Description</h3>

<p>Extract object and value reference relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf_relation(
  idd_env,
  idf_env,
  object_id = NULL,
  value_id = NULL,
  direction = c("ref_to", "ref_by"),
  depth = 0L,
  name = FALSE,
  object = NULL,
  class = NULL,
  group = NULL,
  keep_all = FALSE,
  class_ref = c("both", "none", "all"),
  match_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idf_relation_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_object_id">object_id</code></td>
<td>
<p>An integer vector of valid object IDs. If <code>NULL</code>, all object
IDs in current IDF will be used.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_value_id">value_id</code></td>
<td>
<p>An integer vector of valid value IDs. If <code>NULL</code>, all value
IDs in current IDF will be used.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_direction">direction</code></td>
<td>
<p>Reference relation direction. Should be one of <code>"ref_to"</code>
and <code>"ref_by"</code>. Default: <code>"ref_to"</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_depth">depth</code></td>
<td>
<p>Recursive reference relation depth. <code>NULL</code> means infinite.
Default: <code>0L</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_name">name</code></td>
<td>
<p>If <code>TRUE</code>, all class, object, field value ID and name columns
will be added and a <code>IdfRelationTo</code> or <code>IdfRelationBy</code> object is
returned with customized printing method. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_object">object</code></td>
<td>
<p>An integer vector of valid object IDs or a character vector
of valid object names to specify the targeting relation objects.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names to specify the targeting relation classes.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_group">group</code></td>
<td>
<p>A character vector of valid group names to specify the targeting
relation groups. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>TRUE</code>, all input ID are kept. Otherwise, only input IDs
that have relations are kept. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_class_ref">class_ref</code></td>
<td>
<p>Specify how to handle class-name-references. There are 3
options in total, i.e. <code>"none"</code>, <code>"both"</code> and <code>"all"</code>, with <code>"both"</code>
being the default.
* <code>"none"</code>: just ignore class-name-references.
* <code>"both"</code>: only include class-name-references if this object also
reference field values of the same one. This is the default option.
* <code>"all"</code>: include all class-name-references. This is the most aggressive
option.</p>
</td></tr>
<tr><td><code id="get_idf_relation_+3A_match_all">match_all</code></td>
<td>
<p>If <code>TRUE</code>, relation search will continue even though one
relation has been found. If <code>FALSE</code>, searching is stopped whenever one
relation is found in specified classes/groups. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>

<hr>
<h2 id='get_idf_table'>Extract value data in a data.table</h2><span id='topic+get_idf_table'></span>

<h3>Description</h3>

<p>Extract value data in a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf_table(
  idd_env,
  idf_env,
  class = NULL,
  object = NULL,
  string_value = TRUE,
  unit = FALSE,
  wide = FALSE,
  align = FALSE,
  all = FALSE,
  group_ext = c("none", "group", "index"),
  force = FALSE,
  init = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idf_table_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_object">object</code></td>
<td>
<p>An integer vector of valid object IDs or a character vector
of valid object names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_string_value">string_value</code></td>
<td>
<p>If <code>TRUE</code>, all field values are returned as
character. If <code>FALSE</code>, <code>value</code> column in returned
<a href="data.table.html#topic+data.table">data.table</a> is a list column with
each value stored as corresponding type. Note that if the
value of numeric field is set to <code>"Autosize"</code> or
<code>"Autocalculate"</code>, it is left as it is, leaving the returned
type being a string instead of a number. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_unit">unit</code></td>
<td>
<p>Only applicable when <code>string_value</code> is <code>FALSE</code>. If
<code>TRUE</code>, values of numeric fields are assigned with units using
<code><a href="units.html#topic+units">units::set_units()</a></code> if applicable. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_wide">wide</code></td>
<td>
<p>Only applicable if target objects belong to a same class.
If <code>TRUE</code>, a wide table will be returned, i.e. first three
columns are always <code>id</code>, <code>name</code> and <code>class</code>, and then every
field in a separate column. Note that this requires all
objects specified must from the same class.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_align">align</code></td>
<td>
<p>If <code>TRUE</code>, all objects in the same class will have the
same field number. The number of fields is the same as the
object that have the most fields among objects specified.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_group_ext">group_ext</code></td>
<td>
<p>Should be one of <code>"none"</code>, <code>"group"</code> or <code>"index"</code>.
If not <code>"none"</code>, <code>value</code> column in returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> will be converted into a list.
If <code>"group"</code>, values from extensible fields will be grouped by the
extensible group they belong to. For example, coordinate
values of each vertex in class <code>BuildingSurface:Detailed</code> will
be put into a list. If <code>"index"</code>, values from extensible fields
will be grouped by the extensible field indice they belong to.
For example, coordinate values of all x coordinates will be
put into a list. If <code>"none"</code>, nothing special will be done.
Default: <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_force">force</code></td>
<td>
<p>If <code>TRUE</code>, <code>wide</code> can be <code>TRUE</code> even though there are
multiple classes in input. This can result in a data.table
with lots of columns. But may be useful when you know that
target classes have the exact same fields, e.g.
<code>Ceiling:Adiabatic</code> and <code>Floor:Adiabatic</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_table_+3A_init">init</code></td>
<td>
<p>If <code>TRUE</code>, a table for new object input will be returned
with all values filled with defaults. In this case, <code>object</code>
input will be ignored. The <code>id</code> column will be filled with
possible new object IDs. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 6 columns (if
<code>wide</code> is <code>FALSE</code>) or at least 5 columns (if <code>wide</code> is <code>TRUE</code>).
</p>
<p>When <code>wide</code> is <code>FALSE</code>, the 5 columns are:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type if <code>string_value</code> is <code>TRUE</code> or list type if
<code>string_value</code> is <code>FALSE</code> or <code>group_ext</code> is not <code>"none"</code>. Field values.
</p>
</li></ul>


<hr>
<h2 id='get_idf_value'>Get value data</h2><span id='topic+get_idf_value'></span>

<h3>Description</h3>

<p>Get value data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_idf_value(
  idd_env,
  idf_env,
  class = NULL,
  object = NULL,
  field = NULL,
  property = NULL,
  underscore = FALSE,
  ignore_case = FALSE,
  align = FALSE,
  complete = FALSE,
  all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_idf_value_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_object">object</code></td>
<td>
<p>An integer vector of valid object IDs or a character vector
of valid object names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_field">field</code></td>
<td>
<p>An integer vector of valid field indexes or a character
vector of valid field names (can be in in underscore style). <code>class</code>
and <code>field</code> should have the same length.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_property">property</code></td>
<td>
<p>A character vector of column names in field table to return.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name will be converted into
underscore style name first and column <code>class_name_us</code> will be used
for matching. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_ignore_case">ignore_case</code></td>
<td>
<p>If <code>TRUE</code>, input object name will be converted into lower
case and column <code>object_name_lower</code> will be used for matching.
converted into underscore style name first and column <code>class_name_us</code>
and <code>field_name_us</code> will be used for matching. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_align">align</code></td>
<td>
<p>If <code>TRUE</code>, all objects in the same class will have the same
field number. The number of fields is the same as the object that have
the most fields among objects specified.  Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code>, at least fields till the current whole extensible
group will be returned. A new column named &quot;matched_rleid&quot; will be
created (when <code>property</code> is NULL) indicating if given field has been
matched or not.</p>
</td></tr>
<tr><td><code id="get_idf_value_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, all available fields defined in IDD for the class that
objects belong to will be returned. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing specified columns.
</p>

<hr>
<h2 id='get_object_info'>Format object information string</h2><span id='topic+get_object_info'></span>

<h3>Description</h3>

<p>Format object information string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_object_info(
  dt_object,
  component = c("id", "name", "class"),
  by_class = FALSE,
  numbered = TRUE,
  collapse = NULL,
  prefix = NULL,
  name_prefix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_object_info_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of object data</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_component">component</code></td>
<td>
<p>A character vector specifying what information to be
formatted. Should be a subset of <code>"id"</code>, <code>"name"</code> and <code>"class"</code>.
Defaults are all of them.</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_by_class">by_class</code></td>
<td>
<p>If <code>TRUE</code>, multiple objects in the same class will be
concatenated. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_numbered">numbered</code></td>
<td>
<p>If <code>TRUE</code>, a index number will be prepended. If <code>rleid</code>
column exists in <code>dt_object</code>, its values will be used as the index
numbers.</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_collapse">collapse</code></td>
<td>
<p>A single string used to collapse the results into a single
string. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_prefix">prefix</code></td>
<td>
<p>A character vector used to add at the beginning of object
information. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_object_info_+3A_name_prefix">name_prefix</code></td>
<td>
<p>If <code>TRUE</code>, Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as the row number of input
<code>dt_object</code> if <code>collapse</code> is <code>NULL</code>. Otherwise a single string.
</p>

<hr>
<h2 id='Idd'>Parse, Query and Modify EnergyPlus Input Data Dictionary (IDD)</h2><span id='topic+Idd'></span>

<h3>Description</h3>

<p>eplusr provides parsing of and programmatic access to EnergyPlus
Input Data Dictionary (IDD) files, and objects. It contains all data needed
to parse EnergyPlus models. <code>Idd</code> class provides parsing and printing while
<a href="#topic+IddObject">IddObject</a> provides detailed information of curtain class.
</p>


<h3>Overview</h3>

<p>EnergyPlus operates off of text input files written in its own Input
Data File (IDF) format. IDF files are similar to XML files in that they are
intended to conform to a data schema written using similar syntax. For XML,
the schema format is XSD; for IDF, the schema format is IDD. For each release
of EnergyPlus, valid IDF files are defined by the &quot;Energy+.idd&quot; file shipped
with the release.
</p>
<p>eplusr tries to detect all installed EnergyPlus in default installation
locations when loading, i.e. <code style="white-space: pre;">&#8288;C:\\EnergyPlusVX-X-0&#8288;</code> on Windows,
<code style="white-space: pre;">&#8288;/usr/local/EnergyPlus-X-Y-0&#8288;</code> on Linux, and
<code style="white-space: pre;">&#8288;/Applications/EnergyPlus-X-Y-0&#8288;</code> on macOS and stores all found locations
internally. This data is used to locate the distributed &quot;Energy+.idd&quot; file of
each EnergyPlus version. And also, every time an IDD file is parsed, an <code>Idd</code>
object is created and cached in an environment.
</p>
<p>Parsing an IDD file starts from <code><a href="#topic+use_idd">use_idd()</a></code>. When using <code><a href="#topic+use_idd">use_idd()</a></code>, eplusr
will first try to find the cached <code>Idd</code> object of that version, if possible.
If failed, and EnergyPlus of that version is available (see <code><a href="#topic+avail_eplus">avail_eplus()</a></code>),
the <code>"Energy+.idd"</code> distributed with EnergyPlus will be parsed and cached. So
each IDD file only needs to be parsed once and can be used when parsing every
IDF file of that version.
</p>
<p>Internally, the powerful <a href="https://cran.r-project.org/package=data.table">data.table</a>
package is used to speed up the whole IDD parsing process and store the
results. However, it will still take about 2-3 sec per IDD. Under the hook,
eplusr uses a SQL-like structure to store both IDF and IDD data in
<a href="data.table.html#topic+data.table">data.table::data.table</a> format. Every IDD will be parsed and stored in
four tables:
</p>

<ul>
<li> <p><code>group</code>: contains group index and group names.
</p>
</li>
<li> <p><code>class</code>: contains class names and properties.
</p>
</li>
<li> <p><code>field</code>: contains field names and field properties.
</p>
</li>
<li> <p><code>reference</code>: contains cross-reference data of fields.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Idd-new"><code>Idd$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-version"><code>Idd$version()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-build"><code>Idd$build()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-path"><code>Idd$path()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-group_name"><code>Idd$group_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-from_group"><code>Idd$from_group()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-class_name"><code>Idd$class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-required_class_name"><code>Idd$required_class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-unique_class_name"><code>Idd$unique_class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-extensible_class_name"><code>Idd$extensible_class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-group_index"><code>Idd$group_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-class_index"><code>Idd$class_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-is_valid_group"><code>Idd$is_valid_group()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-is_valid_class"><code>Idd$is_valid_class()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-object"><code>Idd$object()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-objects"><code>Idd$objects()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-object_relation"><code>Idd$object_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-objects_in_relation"><code>Idd$objects_in_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-objects_in_group"><code>Idd$objects_in_group()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-to_table"><code>Idd$to_table()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-to_string"><code>Idd$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-Idd-print"><code>Idd$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Idd-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>Idd</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$new(path, encoding = "unknown")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Either a path, a connection, or literal data (either a single
string or a raw vector) to an EnergyPlus Input Data Dictionary
(IDD). If a file path, that file usually has a extension
<code>.idd</code>.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The file encoding of input IDD. Should be one of
<code>"unknown"</code>, <code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that the file is encoded in the native
encoding.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It takes an EnergyPlus Input Data Dictionary (IDD) as input and
returns an <code>Idd</code> object.
</p>
<p>It is suggested to use helper <code><a href="#topic+use_idd">use_idd()</a></code> which supports to directly
take a valid IDD version as input and search automatically the
corresponding file path.
</p>



<h5>Returns</h5>

<p>An <code>Idd</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{Idd$new(file.path(eplus_config(8.8)$dir, "Energy+.idd"))

# Preferable way
idd &lt;- use_idd(8.8, download = "auto")
}

</pre>
</div>


<hr>
<a id="method-Idd-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of current <code>Idd</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of current <code>Idd</code> in a
<code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> format. This makes it easy to direction
compare versions of different <code>Idd</code>s, e.g. <code>idd$version() &gt; 8.6</code> or
<code>idd1$version() &gt; idd2$version()</code>.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get version
idd$version()
}

</pre>
</div>


<hr>
<a id="method-Idd-build"></a>



<h4>Method <code>build()</code></h4>

<p>Get the build tag of current <code>Idd</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$build()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$build()&#8288;</code> returns the build tag of current <code>Idd</code>. If no build tag is
found, <code>NA</code> is returned.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get build tag
idd$build()
}

</pre>
</div>


<hr>
<a id="method-Idd-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the file path of current <code>Idd</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$path()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path()&#8288;</code> returns the full path of current <code>Idd</code> or <code>NULL</code> if the
<code>Idd</code> object is created using a character vector and not saved
locally.
</p>



<h5>Returns</h5>

<p><code>NULL</code> or a single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
idd$path()
}

</pre>
</div>


<hr>
<a id="method-Idd-group_name"></a>



<h4>Method <code>group_name()</code></h4>

<p>Get names of groups
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$group_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_name()&#8288;</code> returns names of groups current <code>Idd</code> contains.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get names of all groups Idf contains
idd$group_name()
}

</pre>
</div>


<hr>
<a id="method-Idd-from_group"></a>



<h4>Method <code>from_group()</code></h4>

<p>Get the name of group that specified class belongs to
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$from_group(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in current
<code>Idd</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$from_group()&#8288;</code> returns the name of group that specified class
belongs to.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$from_group(c("Version", "Schedule:Compact"))
}

</pre>
</div>


<hr>
<a id="method-Idd-class_name"></a>



<h4>Method <code>class_name()</code></h4>

<p>Get names of classes
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$class_name(index = NULL, by_group = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>An integer vector of class indices.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>If <code>TRUE</code>, a list is returned which separates class
names by the group they belong to. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_name()&#8288;</code> returns names of classes current <code>Idd</code> contains
</p>



<h5>Returns</h5>

<p>A character vector if <code>by_group</code> is <code>FALSE</code> and a list of
character vectors when <code>by_group</code> is <code>TRUE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get names of the 10th to 20th class
idd$class_name(10:20)

# get names of all classes in Idf
idd$class_name()

# get names of all classes grouped by group names in Idf
idd$class_name(by_group = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idd-required_class_name"></a>



<h4>Method <code>required_class_name()</code></h4>

<p>Get the names of required classes
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$required_class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$required_class_name()&#8288;</code> returns the names of required classes in
current <code>Idd</code>. &quot;Require&quot; means that for any <a href="#topic+Idf">Idf</a> there should be at
least one object.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$required_class_name()
}

</pre>
</div>


<hr>
<a id="method-Idd-unique_class_name"></a>



<h4>Method <code>unique_class_name()</code></h4>

<p>Get the names of unique-object classes
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$unique_class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$unique_class_name()&#8288;</code> returns the names of unique-object classes in
current <code>Idd</code>. &quot;Unique-object&quot; means that for any <a href="#topic+Idf">Idf</a> there should
be at most one object in those classes.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$unique_class_name()
}

</pre>
</div>


<hr>
<a id="method-Idd-extensible_class_name"></a>



<h4>Method <code>extensible_class_name()</code></h4>

<p>Get the names of classes with extensible fields
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$extensible_class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$extensible_class_name()&#8288;</code> returns the names of classes with
extensible fields in current <code>Idd</code>. &quot;Extensible fields&quot; indicate
fields that can be added dynamically, such like the X, Y and Z
vertices of a building surface.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$extensible_class_name()
}

</pre>
</div>


<hr>
<a id="method-Idd-group_index"></a>



<h4>Method <code>group_index()</code></h4>

<p>Get the indices of specified groups
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$group_index(group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A character vector of valid group names.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_index()&#8288;</code> returns the indices of specified groups in
current <code>Idd</code>. A group index is just an integer indicating its
appearance order in the <code>Idd</code>.
</p>



<h5>Returns</h5>

<p>An integer vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$group_index()
}

</pre>
</div>


<hr>
<a id="method-Idd-class_index"></a>



<h4>Method <code>class_index()</code></h4>

<p>Get the indices of specified classes
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$class_index(class = NULL, by_group = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of valid class names.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>If <code>TRUE</code>, a list is returned which separates class
names by the group they belong to. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_index()&#8288;</code> returns the indices of specified classes in
current <code>Idd</code>. A class index is just an integer indicating its
appearance order in the <code>Idd</code>.
</p>



<h5>Returns</h5>

<p>An integer vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$class_index()
}

</pre>
</div>


<hr>
<a id="method-Idd-is_valid_group"></a>



<h4>Method <code>is_valid_group()</code></h4>

<p>Check if elements in input character vector are valid group names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$is_valid_group(group)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A character vector to check.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_group()&#8288;</code> returns <code>TRUE</code>s if given character vector
contains valid group names in the context of current <code>Idd</code>, and
<code>FALSE</code>s otherwise.
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Location and Climate"</code> is a valid group name but <code>"location and climate"</code> is not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input character
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$is_valid_group(c("Schedules", "Compliance Objects"))
}

</pre>
</div>


<hr>
<a id="method-Idd-is_valid_class"></a>



<h4>Method <code>is_valid_class()</code></h4>

<p>Check if elements in input character vector are valid class names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$is_valid_class(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector to check.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_class()&#8288;</code> returns <code>TRUE</code>s if given character vector
contains valid class names in the context of current <code>Idd</code>, and
<code>FALSE</code>s otherwise.
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Version"</code> is a valid class name but <code>"version"</code> is not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input character
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$is_valid_class(c("Building", "ShadowCalculation"))
}

</pre>
</div>


<hr>
<a id="method-Idd-object"></a>



<h4>Method <code>object()</code></h4>

<p>Extract an <a href="#topic+IddObject">IddObject</a> object using class index or name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$object(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A single integer specifying the class index or a single
string specifying the class name.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$object()&#8288;</code> returns an <a href="#topic+IddObject">IddObject</a> object specified by a class ID
or name.
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Version"</code> is a valid class name but <code>"version"</code> is not.
</p>
<p>For convenience, underscore-style names are allowed, e.g.
<code>Site_Location</code> is equivalent to <code>Site:Location</code>.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IddObject">IddObject</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$object(3)

idd$object("Building")
}

</pre>
</div>


<hr>
<a id="method-Idd-objects"></a>



<h4>Method <code>objects()</code></h4>

<p>Extract multiple <a href="#topic+IddObject">IddObject</a> objects using class indices or names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$objects(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>An integer vector specifying class indices or a character
vector specifying class names.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects()&#8288;</code> returns a named list of <a href="#topic+IddObject">IddObject</a> objects using class
indices or names. The returned list is named using class names.
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Version"</code> is a valid class name but <code>"version"</code> is not.
</p>
<p>For convenience, underscore-style names are allowed, e.g.
<code>Site_Location</code> is equivalent to <code>Site:Location</code>.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IddObject">IddObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$objects(c(3,10))

idd$objects(c("Version", "Material"))
}

</pre>
</div>


<hr>
<a id="method-Idd-object_relation"></a>



<h4>Method <code>object_relation()</code></h4>

<p>Extract the relationship between class fields.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$object_relation(
  which,
  direction = c("all", "ref_to", "ref_by"),
  class = NULL,
  group = NULL,
  depth = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>A single integer specifying the class index or a single
string specifying the class name.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be one of
<code>"all"</code>, <code>"ref_to"</code> or <code>"ref_by"</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Many fields in <a href="#topic+Idd">Idd</a> can be referred by others. For example, the
<code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> and other fields in <code>Construction</code> class refer to the
<code>Name</code> field in <code>Material</code> class and other material related classes.
Here it means that the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> field <strong>refers to</strong> the <code>Name</code>
field and the <code>Name</code> field is <strong>referred by</strong> the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code>.
</p>
<p><code style="white-space: pre;">&#8288;$object_relation()&#8288;</code> provides a simple interface to get this kind of
relation. It takes a single class index or name and also a relation
direction, and returns an <code>IddRelation</code> object which contains data
presenting such relation above. For instance, if
<code>idd$object_relation("Construction", "ref_to")</code> gives results below:
</p>
<div class="sourceCode"><pre>-- Refer to Others ---------------------------
  Class: &lt;Construction&gt;
  |- Field: &lt;02: Outside Layer&gt;
  |  v~~~~~~~~~~~~~~~~~~~~~~~~~
  |  |- Class: &lt;Material&gt;
  |  |  \- Field: &lt;1: Name&gt;
  |  |
  |  |- Class: &lt;Material:NoMass&gt;
  |  |  \- Field: &lt;1: Name&gt;
  |  |
  |  |- Class: &lt;Material:InfraredTransparent&gt;
  |  |  \- Field: &lt;1: Name&gt;
  |  |
  ......
</pre></div>
<p>This means that the value of field <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> in class
<code>Construction</code> can be one of values from field <code>Name</code> in class
<code>Material</code>, field <code>Name</code> in class <code>Material:NoMass</code>, field <code>Name</code> in
class <code>Material:InfraredTransparent</code> and etc. All those classes can
be further easily extracted using <code style="white-space: pre;">&#8288;$objects_in_relation()&#8288;</code> method
described below.
</p>



<h5>Returns</h5>

<p>An <code>IddRelation</code> object, which is a list of 3
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s named <code>ref_to</code> and <code>ref_by</code>.
Each <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> contains 12 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check each construction layer's possible references
idd$object_relation("Construction", "ref_to")

# check where construction being used
idd$object_relation("Construction", "ref_by")
}

</pre>
</div>


<hr>
<a id="method-Idd-objects_in_relation"></a>



<h4>Method <code>objects_in_relation()</code></h4>

<p>Extract multiple <a href="#topic+IddObject">IddObject</a> objects referencing each others.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$objects_in_relation(
  which,
  direction = c("ref_to", "ref_by"),
  class = NULL,
  group = NULL,
  depth = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>A single integer specifying the class index or a single
string specifying the class name.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be either
<code>"ref_to"</code> or <code>"ref_by"</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in the
current Idd. It is used to restrict the classes to be
returned. If <code>NULL</code>, all possible classes are considered and
corresponding <a href="#topic+IddObject">IddObject</a> objects are returned if
relationships are found. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of valid group names in the
current Idd. It is used to restrict the groups to be
returned. If <code>NULL</code>, all possible groups are considered and
corresponding <a href="#topic+IddObject">IddObject</a> objects are returned if
relationships are found. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects_in_relation()&#8288;</code> returns a named list of <a href="#topic+IddObject">IddObject</a> objects
that have specified relationship with given class. The first element of
returned list is always the specified class itself. If that
class does not have specified relationship with other classes, a list
that only contains specified class itself is returned.
</p>
<p>For instance, <code>idd$objects_in_relation("Construction", "ref_by")</code>
will return a named list of an <a href="#topic+IddObject">IddObject</a> object named
<code>Construction</code> and also all other <a href="#topic+IddObject">IddObject</a> objects that can refer
to field values in class <code>Construction</code>. Similarly,
<code>idd$objects_in_relation("Construction", "ref_to")</code> will return a
named list of an <a href="#topic+IddObject">IddObject</a> object named <code>Construction</code> and also all
other <a href="#topic+IddObject">IddObject</a> objects that <code>Construction</code> can refer to.
</p>



<h5>Returns</h5>

<p>An named list of <a href="#topic+IddObject">IddObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get class Construction and all classes that it can refer to
idd$objects_in_relation("Construction", "ref_to")

# get class Construction and all classes that refer to it
idd$objects_in_relation("Construction", "ref_by")
}

</pre>
</div>


<hr>
<a id="method-Idd-objects_in_group"></a>



<h4>Method <code>objects_in_group()</code></h4>

<p>Extract all <a href="#topic+IddObject">IddObject</a> objects in one group.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$objects_in_group(group)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A single string of valid group name for current <code>Idd</code>
object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects_in_group()&#8288;</code> returns a named list of all <a href="#topic+IddObject">IddObject</a> objects
in specified group. The returned list is named using class names.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IddObject">IddObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all classes in Schedules group
idd$objects_in_group("Schedules")
}

</pre>
</div>


<hr>
<a id="method-Idd-to_table"></a>



<h4>Method <code>to_table()</code></h4>

<p>Format <code>Idd</code> classes as a data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$to_table(class, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of class names.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for
specified class will be returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_table()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> that
contains basic data of specified classes.
The returned <a href="data.table.html#topic+data.table">data.table</a> has 3 columns:
</p>

<ul>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 3 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# extract data of class Material
idd$to_table(class = "Material")

# extract multiple class data
idd$to_table(c("Construction", "Material"))
}

</pre>
</div>


<hr>
<a id="method-Idd-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Format <code>Idf</code> classes as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$to_string(class, leading = 4L, sep_at = 29L, sep_each = 0L, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of class names.</p>
</dd>
<dt><code>leading</code></dt><dd><p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</dd>
<dt><code>sep_at</code></dt><dd><p>The character width to separate value string and field
string. Default: <code>29L</code> which is the same as IDF Editor.</p>
</dd>
<dt><code>sep_each</code></dt><dd><p>A single integer of how many empty strings to insert
between different classes. Default: <code>0</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for
specified class will be returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_string()&#8288;</code> returns the text format of specified classes. The
returned character vector can be pasted into an IDF file as empty
objects of specified classes.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get text format of class Material
head(idd$to_string(class = "Material"))

# get text format of multiple class
idd$to_string(c("Material", "Construction"))

# tweak output formatting
idd$to_string(c("Material", "Construction"), leading = 0, sep_at = 0, sep_each = 5)
}

</pre>
</div>


<hr>
<a id="method-Idd-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>Idd</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Idd$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the <code>Idd</code> object giving the information of version,
build tag and total class numbers.
</p>



<h5>Returns</h5>

<p>The <code>Idd</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idd$print()
}

</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>References</h3>

<p><a href="https://github.com/NREL/EnergyPlus/tree/develop/src/IDF_Editor">IDFEditor</a>,
<a href="https://openstudio-sdk-documentation.s3.amazonaws.com/cpp/OpenStudio-2.5.1-doc/utilities/html/idf_page.html">OpenStudio utilities library</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+IddObject">IddObject</a> class which provides detailed information of
curtain class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Idd$new`
## ------------------------------------------------

## Not run: Idd$new(file.path(eplus_config(8.8)$dir, "Energy+.idd"))

# Preferable way
idd &lt;- use_idd(8.8, download = "auto")

## End(Not run)


## ------------------------------------------------
## Method `Idd$version`
## ------------------------------------------------

## Not run: 
# get version
idd$version()

## End(Not run)


## ------------------------------------------------
## Method `Idd$build`
## ------------------------------------------------

## Not run: 
# get build tag
idd$build()

## End(Not run)


## ------------------------------------------------
## Method `Idd$path`
## ------------------------------------------------

## Not run: 
# get path
idd$path()

## End(Not run)


## ------------------------------------------------
## Method `Idd$group_name`
## ------------------------------------------------

## Not run: 
# get names of all groups Idf contains
idd$group_name()

## End(Not run)


## ------------------------------------------------
## Method `Idd$from_group`
## ------------------------------------------------

## Not run: 
idd$from_group(c("Version", "Schedule:Compact"))

## End(Not run)


## ------------------------------------------------
## Method `Idd$class_name`
## ------------------------------------------------

## Not run: 
# get names of the 10th to 20th class
idd$class_name(10:20)

# get names of all classes in Idf
idd$class_name()

# get names of all classes grouped by group names in Idf
idd$class_name(by_group = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idd$required_class_name`
## ------------------------------------------------

## Not run: 
idd$required_class_name()

## End(Not run)


## ------------------------------------------------
## Method `Idd$unique_class_name`
## ------------------------------------------------

## Not run: 
idd$unique_class_name()

## End(Not run)


## ------------------------------------------------
## Method `Idd$extensible_class_name`
## ------------------------------------------------

## Not run: 
idd$extensible_class_name()

## End(Not run)


## ------------------------------------------------
## Method `Idd$group_index`
## ------------------------------------------------

## Not run: 
idd$group_index()

## End(Not run)


## ------------------------------------------------
## Method `Idd$class_index`
## ------------------------------------------------

## Not run: 
idd$class_index()

## End(Not run)


## ------------------------------------------------
## Method `Idd$is_valid_group`
## ------------------------------------------------

## Not run: 
idd$is_valid_group(c("Schedules", "Compliance Objects"))

## End(Not run)


## ------------------------------------------------
## Method `Idd$is_valid_class`
## ------------------------------------------------

## Not run: 
idd$is_valid_class(c("Building", "ShadowCalculation"))

## End(Not run)


## ------------------------------------------------
## Method `Idd$object`
## ------------------------------------------------

## Not run: 
idd$object(3)

idd$object("Building")

## End(Not run)


## ------------------------------------------------
## Method `Idd$objects`
## ------------------------------------------------

## Not run: 
idd$objects(c(3,10))

idd$objects(c("Version", "Material"))

## End(Not run)


## ------------------------------------------------
## Method `Idd$object_relation`
## ------------------------------------------------

## Not run: 
# check each construction layer's possible references
idd$object_relation("Construction", "ref_to")

# check where construction being used
idd$object_relation("Construction", "ref_by")

## End(Not run)


## ------------------------------------------------
## Method `Idd$objects_in_relation`
## ------------------------------------------------

## Not run: 
# get class Construction and all classes that it can refer to
idd$objects_in_relation("Construction", "ref_to")

# get class Construction and all classes that refer to it
idd$objects_in_relation("Construction", "ref_by")

## End(Not run)


## ------------------------------------------------
## Method `Idd$objects_in_group`
## ------------------------------------------------

## Not run: 
# get all classes in Schedules group
idd$objects_in_group("Schedules")

## End(Not run)


## ------------------------------------------------
## Method `Idd$to_table`
## ------------------------------------------------

## Not run: 
# extract data of class Material
idd$to_table(class = "Material")

# extract multiple class data
idd$to_table(c("Construction", "Material"))

## End(Not run)


## ------------------------------------------------
## Method `Idd$to_string`
## ------------------------------------------------

## Not run: 
# get text format of class Material
head(idd$to_string(class = "Material"))

# get text format of multiple class
idd$to_string(c("Material", "Construction"))

# tweak output formatting
idd$to_string(c("Material", "Construction"), leading = 0, sep_at = 0, sep_each = 5)

## End(Not run)


## ------------------------------------------------
## Method `Idd$print`
## ------------------------------------------------

## Not run: 
idd$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='idd_object'>Create an <code>IddObject</code> object.</h2><span id='topic+idd_object'></span>

<h3>Description</h3>

<p><code>idd_object()</code> takes a parent <code>Idd</code> object, a class name, and returns a
corresponding <a href="#topic+IddObject">IddObject</a>. For details, see <a href="#topic+IddObject">IddObject</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idd_object(parent, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idd_object_+3A_parent">parent</code></td>
<td>
<p>An <a href="#topic+Idd">Idd</a> object or a valid input for <code><a href="#topic+use_idd">use_idd()</a></code>.</p>
</td></tr>
<tr><td><code id="idd_object_+3A_class">class</code></td>
<td>
<p>A valid class name (a string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+IddObject">IddObject</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idd &lt;- use_idd("8.8", download = "auto")

# get an IddObject using class name
idd_object(idd, "Material")
idd_object("8.8", "Material")

## End(Not run)

</code></pre>

<hr>
<h2 id='IddObject'>EnergyPlus IDD object</h2><span id='topic+IddObject'></span>

<h3>Description</h3>

<p><code>IddObject</code> is an abstraction of a single object in an <a href="#topic+Idd">Idd</a> object. It
provides more detail methods to query field properties. <code>IddObject</code> can only
be created from the parent <a href="#topic+Idd">Idd</a> object, using <code style="white-space: pre;">&#8288;$object()&#8288;</code>,
<code style="white-space: pre;">&#8288;$object_in_group()&#8288;</code> and other equivalent. This is because that
initialization of an <code>IddObject</code> needs some shared data from parent <a href="#topic+Idd">Idd</a>
object.
</p>


<h3>Details</h3>

<p>There are lots of properties for every class and field. For details on the
meaning of each property, please see the heading comments in the
<code>Energy+.idd</code> file in the EnergyPlus installation path.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IddObject-new"><code>IddObject$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-version"><code>IddObject$version()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-parent"><code>IddObject$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-group_name"><code>IddObject$group_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-group_index"><code>IddObject$group_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-class_name"><code>IddObject$class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-class_index"><code>IddObject$class_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-class_format"><code>IddObject$class_format()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-min_fields"><code>IddObject$min_fields()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-num_fields"><code>IddObject$num_fields()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-memo"><code>IddObject$memo()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-num_extensible"><code>IddObject$num_extensible()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-first_extensible_index"><code>IddObject$first_extensible_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-extensible_group_num"><code>IddObject$extensible_group_num()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-add_extensible_group"><code>IddObject$add_extensible_group()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-del_extensible_group"><code>IddObject$del_extensible_group()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-has_name"><code>IddObject$has_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_required"><code>IddObject$is_required()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_unique"><code>IddObject$is_unique()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_extensible"><code>IddObject$is_extensible()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_name"><code>IddObject$field_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_index"><code>IddObject$field_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_type"><code>IddObject$field_type()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_note"><code>IddObject$field_note()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_unit"><code>IddObject$field_unit()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_default"><code>IddObject$field_default()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_choice"><code>IddObject$field_choice()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_range"><code>IddObject$field_range()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_relation"><code>IddObject$field_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-field_possible"><code>IddObject$field_possible()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_valid_field_num"><code>IddObject$is_valid_field_num()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_extensible_index"><code>IddObject$is_extensible_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_valid_field_name"><code>IddObject$is_valid_field_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_valid_field_index"><code>IddObject$is_valid_field_index()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_autosizable_field"><code>IddObject$is_autosizable_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_autocalculatable_field"><code>IddObject$is_autocalculatable_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_numeric_field"><code>IddObject$is_numeric_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_real_field"><code>IddObject$is_real_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_integer_field"><code>IddObject$is_integer_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-is_required_field"><code>IddObject$is_required_field()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-has_ref"><code>IddObject$has_ref()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-has_ref_to"><code>IddObject$has_ref_to()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-has_ref_by"><code>IddObject$has_ref_by()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-outputs"><code>IddObject$outputs()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-to_table"><code>IddObject$to_table()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-to_string"><code>IddObject$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-IddObject-print"><code>IddObject$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IddObject-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>IddObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$new(class, parent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A single integer specifying the class index or a single
string specifying the class name.</p>
</dd>
<dt><code>parent</code></dt><dd><p>An <a href="#topic+Idd">Idd</a> object or a valid input for <code><a href="#topic+use_idd">use_idd()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Note that an <code>IddObject</code> can be created from the parent <a href="#topic+Idd">Idd</a> object,
using <code style="white-space: pre;">&#8288;$object()&#8288;</code>, <a href="#topic+idd_object">idd_object</a> and other equivalent.
</p>



<h5>Returns</h5>

<p>An <code>IddObject</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf &lt;- IddObject$new("BuildingSurface:Detailed", use_idd(8.8, download = "auto"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of parent <code>Idd</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of parent <code>Idd</code> in a
<code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> format. This makes it easy to direction
compare versions of different <code>IddObject</code>s, e.g. <code>iddobj$version() &gt; 8.6</code> or
<code>iddobj1$version() &gt; iddobj2$version()</code>.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get version
surf$version()
}

</pre>
</div>


<hr>
<a id="method-IddObject-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>Get parent <a href="#topic+Idd">Idd</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$parent()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$parent()&#8288;</code> returns parent <a href="#topic+Idd">Idd</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="#topic+Idd">Idd</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$parent()
}

</pre>
</div>


<hr>
<a id="method-IddObject-group_name"></a>



<h4>Method <code>group_name()</code></h4>

<p>Get the group name
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$group_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_name()&#8288;</code> returns the group name of current <code>IddObject</code>.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$group_name()
}

</pre>
</div>


<hr>
<a id="method-IddObject-group_index"></a>



<h4>Method <code>group_index()</code></h4>

<p>Get the group index
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$group_index()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_index()&#8288;</code> returns the group index of current <code>IddObject</code>. A
group index is just an integer indicating its appearance order in the
<a href="#topic+Idd">Idd</a>.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$group_index()
}

</pre>
</div>


<hr>
<a id="method-IddObject-class_name"></a>



<h4>Method <code>class_name()</code></h4>

<p>Get the class name of current <code>IddObject</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_name()&#8288;</code> returns the class name of current <code>IddObject</code>.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$class_name()
}

</pre>
</div>


<hr>
<a id="method-IddObject-class_index"></a>



<h4>Method <code>class_index()</code></h4>

<p>Get the class index
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$class_index()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_index()&#8288;</code> returns the class index of current <code>IddObject</code>. A
class index is just an integer indicating its appearance order in the
<a href="#topic+Idd">Idd</a>.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$class_index()
}

</pre>
</div>


<hr>
<a id="method-IddObject-class_format"></a>



<h4>Method <code>class_format()</code></h4>

<p>Get the class format
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$class_format()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_format()&#8288;</code> returns the format of this IDD class. This format
indicator is currently not used by eplusr.
</p>



<h5>Returns</h5>

<p>A single character.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$class_format()
}

</pre>
</div>


<hr>
<a id="method-IddObject-min_fields"></a>



<h4>Method <code>min_fields()</code></h4>

<p>Get the minimum field number of current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$min_fields()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$min_fields()&#8288;</code> returns the minimum fields required for current class.
If no required, <code>0</code> is returned.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$min_fields()
}

</pre>
</div>


<hr>
<a id="method-IddObject-num_fields"></a>



<h4>Method <code>num_fields()</code></h4>

<p>Get the total field number of current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$num_fields()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$num_fields()&#8288;</code> returns current total number of fields in current
class.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$num_fields()
}

</pre>
</div>


<hr>
<a id="method-IddObject-memo"></a>



<h4>Method <code>memo()</code></h4>

<p>Get the memo string of current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$memo()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$memo()&#8288;</code> returns memo of current class, usually a brief description
of this class.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$memo()
}

</pre>
</div>


<hr>
<a id="method-IddObject-num_extensible"></a>



<h4>Method <code>num_extensible()</code></h4>

<p>Get the field number of the extensible group in current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$num_extensible()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$num_extensible()&#8288;</code> returns the field number of the extensible group
in current class.
</p>
<p>An extensible group is a set of fields that should be treated as a
whole, such like the X, Y and Z vertices of a building surfaces. An
extensible group should be added or deleted together.
</p>
<p>If there is no extensible group in current class, <code>0</code> is returned.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$num_extensible()
}

</pre>
</div>


<hr>
<a id="method-IddObject-first_extensible_index"></a>



<h4>Method <code>first_extensible_index()</code></h4>

<p>Get the minimum field number of current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$first_extensible_index()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$first_extensible_index()&#8288;</code> returns the field index of first
extensible field in current class.
</p>
<p>An extensible group is a set of fields that should be treated as a
whole, such like the X, Y and Z vertices of a building surfaces. An
extensible group should be added or deleted together.
</p>
<p>If there is no extensible group in current class, <code>0</code> is returned.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$first_extensible_index()
}

</pre>
</div>


<hr>
<a id="method-IddObject-extensible_group_num"></a>



<h4>Method <code>extensible_group_num()</code></h4>

<p>Get the number of extensible groups in current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$extensible_group_num()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$extensible_group_num()&#8288;</code> returns the number of extensible groups in
current class.
</p>
<p>An extensible group is a set of fields that should be treated as a
whole, such like the X, Y and Z vertices of a building surfaces. An
extensible group should be added or deleted together.
</p>
<p>If there is no extensible group in current class, <code>0</code> is returned.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$extensible_group_num()
}

</pre>
</div>


<hr>
<a id="method-IddObject-add_extensible_group"></a>



<h4>Method <code>add_extensible_group()</code></h4>

<p>Add extensible groups in current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$add_extensible_group(num = 1L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num</code></dt><dd><p>An integer indicating the number of extensible groups to
be added.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$add_extensible_groups()&#8288;</code> adds extensible groups in this class.
</p>
<p>An extensible group is a set of fields that should be treated as a
whole, such like the X, Y and Z vertices of a building surfaces. An
extensible group should be added or deleted together.
</p>
<p>An error will be issued if current class contains no extensible
group.
</p>



<h5>Returns</h5>

<p>The modified <code>IddObject</code> itself.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# field number before adding
surf$num_fields()
# extensible group number before adding
surf$extensible_group_num()

# add 2 more extensible groups
surf$add_extensible_group(2)

# field number after adding
surf$num_fields()
# extensible group number after adding
surf$extensible_group_num()
}

</pre>
</div>


<hr>
<a id="method-IddObject-del_extensible_group"></a>



<h4>Method <code>del_extensible_group()</code></h4>

<p>Delete extensible groups in current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$del_extensible_group(num = 1L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num</code></dt><dd><p>An integer indicating the number of extensible groups to
be deleted.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$del_extensible_groups()&#8288;</code> deletes extensible groups in this class.
</p>
<p>An extensible group is a set of fields that should be treated as a
whole, such like the X, Y and Z vertices of a building surfaces. An
extensible group should be added or deleted together.
</p>
<p>An error will be issued if current class contains no extensible
group.
</p>



<h5>Returns</h5>

<p>The modified <code>IddObject</code> itself.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# field number before deleting
surf$num_fields()
# extensible group number before deleting
surf$extensible_group_num()

# delete 2 more extensible groups
surf$del_extensible_group(2)

# field number after deleting
surf$num_fields()
# extensible group number after deleting
surf$extensible_group_num()
}

</pre>
</div>


<hr>
<a id="method-IddObject-has_name"></a>



<h4>Method <code>has_name()</code></h4>

<p>Check if current class has name attribute
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$has_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$has_name()&#8288;</code> return <code>TRUE</code> if current class has name attribute, and
<code>FALSE</code> otherwise.
</p>
<p>A class with name attribute means that objects in this class can have
names.
</p>



<h5>Returns</h5>

<p>A single logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$has_name()
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_required"></a>



<h4>Method <code>is_required()</code></h4>

<p>Check if current class is required
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_required()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_required()&#8288;</code> returns <code>TRUE</code> if current class is required and
<code>FALSE</code> otherwise.
</p>
<p>A required class means that for any model, there should be at least
one object in this class. One example is <code>Building</code> class.
</p>



<h5>Returns</h5>

<p>A single logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_required()
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_unique"></a>



<h4>Method <code>is_unique()</code></h4>

<p>Check if current class is unique
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_unique()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_unique()&#8288;</code> returns <code>TRUE</code> if current class is unique and
<code>FALSE</code> otherwise.
</p>
<p>A unique class means that for any model, there should be at most
one object in this class. One example is <code>Building</code> class.
</p>



<h5>Returns</h5>

<p>A single logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_unique()
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_extensible"></a>



<h4>Method <code>is_extensible()</code></h4>

<p>Check if current class is extensible
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_extensible()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_extensible()&#8288;</code> returns <code>TRUE</code> if current class is extensible and
<code>FALSE</code> otherwise.
</p>
<p>A extensible class means that for there are curtain number of fields
in this class that can be dynamically added or deleted, such like the
X, Y and Z vertices of a building surface.
</p>



<h5>Returns</h5>

<p>A single logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_extensible()
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_name"></a>



<h4>Method <code>field_name()</code></h4>

<p>Get field names
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_name(
  index = NULL,
  unit = FALSE,
  in_ip = eplusr_option("view_in_ip")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>An integer vector of field indices. If <code>NULL</code>, names of
all fields in this class are returned. Default: <code>NULL</code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>If <code>TRUE</code>, the units of those fields are also returned.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>in_ip</code></dt><dd><p>If <code>in_ip</code>, corresponding imperial units are returned.
It only has effect when <code>unit</code> is <code>TRUE</code>. Default:
<code>eplusr_option("view_in_ip")</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_name()&#8288;</code> returns a character vector of names of fields
specified by field indices in current class.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field names
surf$field_name()

# get field units also
surf$field_name(unit = TRUE)

# get field units in IP
surf$field_name(unit = TRUE)

# change field name to lower-style
surf$field_name(unit = TRUE, in_ip = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_index"></a>



<h4>Method <code>field_index()</code></h4>

<p>Get field indices
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_index(name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A character vector of field names. Can be in
&quot;lower-style&quot;, i.e. all spaces and dashes is replaced by
underscores. If <code>NULL</code>, indices of all fields in this class
are returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_index()&#8288;</code> returns an integer vector of names of fields
specified by field names in current class.
</p>



<h5>Returns</h5>

<p>An integer vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field indices
surf$field_index()

# get field indices for specific fields
surf$field_index(c("number of vertices", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_type"></a>



<h4>Method <code>field_type()</code></h4>

<p>Get field types
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_type(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_type()&#8288;</code> returns a character vector of field types of
specified fields in current class. All possible values are:
</p>

<ul>
<li> <p><code>"integer"</code>
</p>
</li>
<li> <p><code>"real"</code>
</p>
</li>
<li> <p><code>"alpha"</code> (arbitrary string)
</p>
</li>
<li> <p><code>"choice"</code> (alpha with specific list of choices)
</p>
</li>
<li> <p><code>"object-list"</code> (link to a list of objects defined elsewhere)
</p>
</li>
<li> <p><code>"external-list"</code> (uses a special list from an external source)
</p>
</li>
<li> <p><code>"node"</code> (name used in connecting HVAC components).
</p>
</li></ul>




<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field types
surf$field_type()

# get field types for specific fields
surf$field_type(c("name", "zone name", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_note"></a>



<h4>Method <code>field_note()</code></h4>

<p>Get field notes
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_note(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_note()&#8288;</code> returns a list of character vectors that contains
field notes of specified fields in current class, usually serving as
field descriptions. If no notes are found for current fields, <code>NULL</code>
is returned.
</p>



<h5>Returns</h5>

<p>A list of character vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field notes
surf$field_note()

# get field types for specific fields
surf$field_note(c("name", "zone name", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_unit"></a>



<h4>Method <code>field_unit()</code></h4>

<p>Get field units
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_unit(which = NULL, in_ip = eplusr_option("view_in_ip"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>in_ip</code></dt><dd><p>If <code>in_ip</code>, corresponding imperial units are returned.
Default: <code>eplusr_option("view_in_ip")</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_unit()&#8288;</code> returns a character vector that contains units of
specified fields in current class. If there is no unit found for
current field, <code>NA</code> is returned.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field units
surf$field_unit()

# get field units for specific fields
surf$field_unit(c("name", "zone name", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_default"></a>



<h4>Method <code>field_default()</code></h4>

<p>Get field default value
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_default(which = NULL, in_ip = eplusr_option("view_in_ip"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>in_ip</code></dt><dd><p>If <code>in_ip</code>, values in corresponding imperial units are
returned. Default: <code>eplusr_option("view_in_ip")</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_default()&#8288;</code> returns a list that contains default values of
specified fields in current class. If there is no default value found
for current field, <code>NA</code> is returned.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field default values
surf$field_default()

# get default values for specific fields
surf$field_default(c("name", "zone name", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_choice"></a>



<h4>Method <code>field_choice()</code></h4>

<p>Get choices of field values
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_choice(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_value()&#8288;</code> returns a list of character vectors that contains
choices of specified field values in current class. If there is no
choice found for current field, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p>A list of character vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field value choices
surf$field_choice()

# get field value choices for specific fields
surf$field_choice(c("name", "sun exposure", "wind exposure"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_range"></a>



<h4>Method <code>field_range()</code></h4>

<p>Get field value ranges
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_range(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_range()&#8288;</code> returns a list of value ranges of specified fields
in current class.
</p>
<p>Every range has four components:
</p>

<ul>
<li> <p><code>minimum</code>: lower limit
</p>
</li>
<li> <p><code>lower_incbounds</code>: <code>TRUE</code> if the lower limit should be included
</p>
</li>
<li> <p><code>maximum</code>: upper limit
</p>
</li>
<li> <p><code>upper_incbounds</code>: <code>TRUE</code> if the upper limit should be included
</p>
</li></ul>

<p>For fields of character type,
</p>

<ul>
<li> <p><code>minimum</code> and <code>maximum</code> are always set to <code>NA</code>
</p>
</li>
<li> <p><code>lower_incbounds</code> and <code>upper_incbounds</code> are always set to <code>FALSE</code>
</p>
</li></ul>

<p>For fields of numeric types with no specified ranges,
</p>

<ul>
<li> <p><code>minimum</code> is set to <code>-Inf</code>
</p>
</li>
<li> <p><code>lower_incbounds</code> is set to <code>FALSE</code>
</p>
</li>
<li> <p><code>upper</code> is set to <code>Inf</code>
</p>
</li>
<li> <p><code>upper_incbounds</code> is set to <code>FALSE</code>
</p>
</li></ul>

<p>The field range is printed in number interval denotation.
</p>



<h5>Returns</h5>

<p>A list of ranges.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all field value ranges
surf$field_range()

# get value ranges for specific fields
surf$field_range(c("name", "number of vertices", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_relation"></a>



<h4>Method <code>field_relation()</code></h4>

<p>Extract the relationship among fields
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_relation(
  which = NULL,
  direction = c("all", "ref_by", "ref_to"),
  class = NULL,
  group = NULL,
  depth = 0L,
  keep = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be one of
<code>"all"</code>, <code>"ref_to"</code> or <code>"ref_by"</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>keep</code></dt><dd><p>If <code>TRUE</code>, all input fields are returned regardless they
have any relations with other objects or not. If <code>FALSE</code>, only
fields in input that have relations with other objects are
returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Many fields in <a href="#topic+Idd">Idd</a> can be referred by others. For example, the
<code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> and other fields in <code>Construction</code> class refer to the
<code>Name</code> field in <code>Material</code> class and other material related classes.
Here it means that the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> field <strong>refers to</strong> the <code>Name</code>
field and the <code>Name</code> field is <strong>referred by</strong> the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code>.
</p>
<p><code style="white-space: pre;">&#8288;$field_relation()&#8288;</code> provides a simple interface to get this kind of
relation. It takes a field specification and a relation
direction, and returns an <code>IddRelation</code> object which contains data
presenting such relation above.
</p>
<p><code style="white-space: pre;">&#8288;$field_relation()&#8288;</code> returns a list of references for those fields
that have the <code>object-list</code> and/or <code>reference</code> and
<code>reference-class-name</code> attribute. Basically, it is a list of two
elements <code>ref_to</code> and <code>ref_by</code>. Underneath, <code>ref_to</code> and <code>ref_by</code>
are <a href="data.table.html#topic+data.table">data.table</a>s which contain source
field data and reference field data with custom printing method. For
instance, if <code>iddobj$field_relation(c(1, 2), "ref_to")</code> gives results
below:
</p>
<div class="sourceCode"><pre>-- Refer to Others ---------------------
  +- Field: &lt;1: Field 1&gt;
  |  v~~~~~~~~~~~~~~~~~~
  |  \- Class: &lt;Class 2&gt;
  |     \- Field: &lt;2: Field 2&gt;
  |
  \- Field: &lt;2: Field 2&gt;
</pre></div>
<p>This means that <code style="white-space: pre;">&#8288;Field 2&#8288;</code> in current class does not refer to any other fields.
But <code style="white-space: pre;">&#8288;Field 1&#8288;</code> in current class refers to <code style="white-space: pre;">&#8288;Field 2&#8288;</code> in class named <code style="white-space: pre;">&#8288;Class 2&#8288;</code>.
</p>



<h5>Returns</h5>

<p>An <code>IddRelation</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get field relation for specific fields
surf$field_relation(c("name", "zone name", "vertex 10 z-coordinate"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-field_possible"></a>



<h4>Method <code>field_possible()</code></h4>

<p>Get field possible values
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$field_possible(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$field_possible()&#8288;</code> returns all possible values for specified fields,
including auto-value (<code>Autosize</code>, <code>Autocalculate</code>, and <code>NA</code> if not
applicable), and results from <code style="white-space: pre;">&#8288;$field_default()&#8288;</code>, <code style="white-space: pre;">&#8288;$field_range()&#8288;</code>,
<code style="white-space: pre;">&#8288;$field_choice()&#8288;</code>. Underneath, it returns a data.table with custom
printing method. For instance, if <code>iddobj$field_possible(c(4, 2))</code>
gives results below:
</p>
<div class="sourceCode"><pre>-- 4: Field 4 ----------
* Auto value: &lt;NA&gt;
* Default: &lt;NA&gt;
* Choice:
  - "Key1"
  - "Key2"

-- 2: Field 2 ----------
* Auto value: "Autosize"
* Default: 2
* Choice: &lt;NA&gt;
</pre></div>
<p>This means that <code style="white-space: pre;">&#8288;Field 4&#8288;</code> in current class cannot be &quot;autosized&quot; or
&quot;autocalculated&quot;, and it does not have any default value. Its value should be
a choice from <code>"Key1"</code> or <code>"Key2"</code>. For <code style="white-space: pre;">&#8288;Field 2&#8288;</code> in current class, it has a
default value of <code>2</code> but can also be filled with value <code>"Autosize"</code>.
</p>



<h5>Returns</h5>

<p>A <code>IddFieldPossible</code> object which is a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 9 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get field possible values for specific fields
surf$field_possible(6:10)
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_valid_field_num"></a>



<h4>Method <code>is_valid_field_num()</code></h4>

<p>Check if input is a valid field number
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_valid_field_num(num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num</code></dt><dd><p>An integer vector to test.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_field_num()&#8288;</code> returns <code>TRUE</code> if input <code>num</code> is acceptable
as a total number of fields in this class. Extensible property is
considered.
</p>
<p>For instance, the total number of fields defined in IDD for class
<code>BuildingSurfaces:Detailed</code> is 390. However, 396 is still a valid
field number for this class as the number of field in the extensible
group is 3.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_valid_field_num(c(10, 14, 100))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_extensible_index"></a>



<h4>Method <code>is_extensible_index()</code></h4>

<p>Check if input field index indicates an extensible field
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_extensible_index(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>An integer vector of field indices.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_extensible_index()&#8288;</code> returns <code>TRUE</code> if input <code>index</code> indicates an
index of extensible field in current class.
</p>
<p>Extensible fields mean that these fields can be dynamically added or
deleted, such like the X, Y and Z vertices of a building surface.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_extensible_index(c(10, 14, 100))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_valid_field_name"></a>



<h4>Method <code>is_valid_field_name()</code></h4>

<p>Check if input character is a valid field name
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_valid_field_name(name, strict = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A character vector to test.</p>
</dd>
<dt><code>strict</code></dt><dd><p>If <code>TRUE</code>, only exact match is accepted. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_field_name()&#8288;</code> returns <code>TRUE</code> if <code>name</code> is a valid field
name <strong>WITHOUT</strong> unit. Note <code>name</code> can be given in underscore style,
e.g.  <code>"outside_layer"</code> is equivalent to <code>"Outside Layer"</code>.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_valid_field_name(c("name", "sun_exposure"))

# exact match
surf$is_valid_field_name(c("Name", "Sun_Exposure"), strict = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_valid_field_index"></a>



<h4>Method <code>is_valid_field_index()</code></h4>

<p>Check if input integer is a valid field index
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_valid_field_index(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>An integer vector to test.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_field_index()&#8288;</code> returns <code>TRUE</code> if <code>index</code> is a valid field
index. For extensible class, <code>TRUE</code> is always returned.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_valid_field_index(1:10)
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_autosizable_field"></a>



<h4>Method <code>is_autosizable_field()</code></h4>

<p>Check if input field can be autosized
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_autosizable_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_autosizable_field()&#8288;</code> returns <code>TRUE</code> if input field can be
assigned to <code>autosize</code>.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_autosizable_field()

surf$is_autosizable_field(c("name", "sun_exposure"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_autocalculatable_field"></a>



<h4>Method <code>is_autocalculatable_field()</code></h4>

<p>Check if input field can be autocalculated
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_autocalculatable_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_autocalculatable_field()&#8288;</code> returns <code>TRUE</code> if input field can be
assigned to <code>autocalculate</code>.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_autocalculatable_field()

surf$is_autocalculatable_field(c("name", "sun_exposure"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_numeric_field"></a>



<h4>Method <code>is_numeric_field()</code></h4>

<p>Check if input field value should be numeric
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_numeric_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_numeric_field()&#8288;</code> returns <code>TRUE</code> if the value of input field
should be numeric ( an integer or a real number).
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_numeric_field()

surf$is_numeric_field(c("name", "sun_exposure"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_real_field"></a>



<h4>Method <code>is_real_field()</code></h4>

<p>Check if input field value should be a real number
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_real_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_real_field()&#8288;</code> returns <code>TRUE</code> if the field value should be a real
number but not an integer.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_real_field()

surf$is_real_field(c("name", "number of vertices"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_integer_field"></a>



<h4>Method <code>is_integer_field()</code></h4>

<p>Check if input field value should be an integer
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_integer_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_real_field()&#8288;</code> returns <code>TRUE</code> if the field value should be an
integer.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_integer_field()

surf$is_integer_field(c("name", "number of vertices"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-is_required_field"></a>



<h4>Method <code>is_required_field()</code></h4>

<p>Check if input field is required
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$is_required_field(which = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_required_field()&#8288;</code> returns <code>TRUE</code> if the field is required.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$is_required_field()

surf$is_required_field(c("name", "number of vertices"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-has_ref"></a>



<h4>Method <code>has_ref()</code></h4>

<p>Check if input field can refer to or can be referred by other fields
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$has_ref(which = NULL, class = NULL, group = NULL, depth = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$has_ref()&#8288;</code> returns <code>TRUE</code> if input field refers to or can be referred
by other fields.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$has_ref()

surf$has_ref(c("name", "zone name"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-has_ref_to"></a>



<h4>Method <code>has_ref_to()</code></h4>

<p>Check if input field can refer to other fields
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$has_ref_to(which = NULL, class = NULL, group = NULL, depth = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$has_ref_to()&#8288;</code> returns <code>TRUE</code> if input field can refer to other
fields.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$has_ref_to()

surf$has_ref_to(c("name", "zone name"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-has_ref_by"></a>



<h4>Method <code>has_ref_by()</code></h4>

<p>Check if input field can be referred by other fields
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$has_ref_by(which = NULL, class = NULL, group = NULL, depth = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indices or a character vector
of field names in current class. If <code>NULL</code>, all fields in this
class are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$has_ref_by()&#8288;</code> returns <code>TRUE</code> if input field can be referred by
other fields.
</p>



<h5>Returns</h5>

<p>A logical vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$has_ref_by()

surf$has_ref_by(c("name", "zone name"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-outputs"></a>



<h4>Method <code>outputs()</code></h4>

<p>Get possible output variables for current class
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$outputs()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$outputs()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> that
gives all possible outputs for current class.
The returned <a href="data.table.html#topic+data.table">data.table</a> has 6 columns:
</p>
<p>*<code>index</code>: Integer. Index of each variable.
*<code>class</code>: Character. Name of current class.
</p>

<ul>
<li> <p><code>reported_time_step</code>: Character. Reported time step for the variables.
Possible value: <code>Zone</code> and <code>HVAC</code>.
</p>
</li>
<li> <p><code>report_type</code>: Character. Report types. Possible value: <code>Average</code>,
<code>Sum</code>.
</p>
</li>
<li> <p><code>variable</code>: Character. Report variable names.
</p>
</li>
<li> <p><code>units</code>: Character. Units of reported values. <code>NA</code> if report values do not
have units.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 6 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$outputs()
}

</pre>
</div>


<hr>
<a id="method-IddObject-to_table"></a>



<h4>Method <code>to_table()</code></h4>

<p>Format an <code>IddObject</code> as a data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$to_table(all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for
specified class will be returned. If <code>FALSE</code>, only the minimum
field number is returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_table()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> that
contains basic data of current class.
The returned <a href="data.table.html#topic+data.table">data.table</a> has 3 columns:
</p>

<ul>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 3 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf$to_table()

surf$to_table(TRUE)
}

</pre>
</div>


<hr>
<a id="method-IddObject-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Format an <code>IdfObject</code> as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$to_string(comment = NULL, leading = 4L, sep_at = 29L, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>A character vector to be used as comments of returned
string format object.</p>
</dd>
<dt><code>leading</code></dt><dd><p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</dd>
<dt><code>sep_at</code></dt><dd><p>The character width to separate value string and field
string. Default: <code>29L</code> which is the same as IDF Editor.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for
specified class will be returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_string()&#8288;</code> returns the text format of current class. The returned
character vector can be pasted into an IDF file as an empty object of
specified class.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get text format of class BuildingSurface:Detailed
surf$to_string()

# tweak output formatting
surf$to_string(leading = 0, sep_at = 0)

# add comments
surf$to_string(c("This", "will", "be", "comments"))
}

</pre>
</div>


<hr>
<a id="method-IddObject-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>IddObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IddObject$print(brief = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>brief</code></dt><dd><p>If <code>TRUE</code>, only class name part is printed. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the <code>IddObject</code> object giving the information of
class name, class properties, field indices and field names.
</p>
<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the IddObject. Basically, the print output can be
divided into 4 parts:
</p>

<ul>
<li><p> CLASS: IDD class name of current object in format <code style="white-space: pre;">&#8288;&lt;IddObject: CLASS&gt;&#8288;</code>.
</p>
</li>
<li><p> MEMO: brief description of the IDD class.
</p>
</li>
<li><p> PROPERTY: properties of the IDD class, including name of group it
belongs to, whether it is an unique or required class and current
total fields. The fields may increase if the IDD class is
extensible, such as <code>Branch</code>, <code>ZoneList</code> and etc.
</p>
</li>
<li><p> FIELDS: fields of current IDD class. Required fields are marked
with stars (<code>*</code>). If the class is extensible, only the first
extensible group will be printed and two ellipses will be shown at
the bottom. Fields in the extensible group will be marked with an
arrow down surrounded by angle brackets (<code style="white-space: pre;">&#8288;&lt;v&gt;&#8288;</code>).
</p>
</li></ul>




<h5>Returns</h5>

<p>The <code>IddObject</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
surf

surf$print(brief = TRUE)
}

</pre>
</div>




<h3>Note</h3>

<p>Some classes have special format when saved in the IDFEditor with the
special format option enabled. Those special format includes
&quot;singleLine&quot;, &quot;vertices&quot;, &quot;compactSchedule&quot;, &quot;fluidProperties&quot;,
&quot;viewFactors&quot; and &quot;spectral&quot;. eplusr can handle all those format when
parsing IDF files. However, when saved, all classes are formatted in
standard way.
</p>
<p>This number may change if the class is extensible and after
<code style="white-space: pre;">&#8288;$add_extensible_group()&#8288;</code> or <code style="white-space: pre;">&#8288;$del_extensible_group()&#8288;</code>.
</p>
<p>The type of each default value will be consistent with field
definition. However, for numeric fields with default values being
<code>"autosize"</code> or <code>"autocalculate"</code>, the type of returned values will
be character.
</p>
<p>All outputs are extracted from the LaTeX source file of &quot;Input Output
Reference&quot; for EnergyPlus v9.5.0 and later. So empty result will
always be returned for <a href="#topic+Idd">Idd</a> version lower than v9.5.
</p>
<p>It is possible that there are some mistakes introduced when
extracting the output variables.
Also, some outputs are only available if certain fields
are set. Even they are listed in the results, it does not mean that
the <a href="#topic+Idf">Idf</a> can report all of them.
It is strongly suggested to check the RDD and MDD file for
correctness.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idd">Idd</a> Class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IddObject$new`
## ------------------------------------------------

## Not run: 
surf &lt;- IddObject$new("BuildingSurface:Detailed", use_idd(8.8, download = "auto"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$version`
## ------------------------------------------------

## Not run: 
# get version
surf$version()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$parent`
## ------------------------------------------------

## Not run: 
surf$parent()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$group_name`
## ------------------------------------------------

## Not run: 
surf$group_name()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$group_index`
## ------------------------------------------------

## Not run: 
surf$group_index()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$class_name`
## ------------------------------------------------

## Not run: 
surf$class_name()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$class_index`
## ------------------------------------------------

## Not run: 
surf$class_index()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$class_format`
## ------------------------------------------------

## Not run: 
surf$class_format()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$min_fields`
## ------------------------------------------------

## Not run: 
surf$min_fields()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$num_fields`
## ------------------------------------------------

## Not run: 
surf$num_fields()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$memo`
## ------------------------------------------------

## Not run: 
surf$memo()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$num_extensible`
## ------------------------------------------------

## Not run: 
surf$num_extensible()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$first_extensible_index`
## ------------------------------------------------

## Not run: 
surf$first_extensible_index()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$extensible_group_num`
## ------------------------------------------------

## Not run: 
surf$extensible_group_num()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$add_extensible_group`
## ------------------------------------------------

## Not run: 
# field number before adding
surf$num_fields()
# extensible group number before adding
surf$extensible_group_num()

# add 2 more extensible groups
surf$add_extensible_group(2)

# field number after adding
surf$num_fields()
# extensible group number after adding
surf$extensible_group_num()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$del_extensible_group`
## ------------------------------------------------

## Not run: 
# field number before deleting
surf$num_fields()
# extensible group number before deleting
surf$extensible_group_num()

# delete 2 more extensible groups
surf$del_extensible_group(2)

# field number after deleting
surf$num_fields()
# extensible group number after deleting
surf$extensible_group_num()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$has_name`
## ------------------------------------------------

## Not run: 
surf$has_name()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_required`
## ------------------------------------------------

## Not run: 
surf$is_required()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_unique`
## ------------------------------------------------

## Not run: 
surf$is_unique()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_extensible`
## ------------------------------------------------

## Not run: 
surf$is_extensible()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_name`
## ------------------------------------------------

## Not run: 
# get all field names
surf$field_name()

# get field units also
surf$field_name(unit = TRUE)

# get field units in IP
surf$field_name(unit = TRUE)

# change field name to lower-style
surf$field_name(unit = TRUE, in_ip = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_index`
## ------------------------------------------------

## Not run: 
# get all field indices
surf$field_index()

# get field indices for specific fields
surf$field_index(c("number of vertices", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_type`
## ------------------------------------------------

## Not run: 
# get all field types
surf$field_type()

# get field types for specific fields
surf$field_type(c("name", "zone name", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_note`
## ------------------------------------------------

## Not run: 
# get all field notes
surf$field_note()

# get field types for specific fields
surf$field_note(c("name", "zone name", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_unit`
## ------------------------------------------------

## Not run: 
# get all field units
surf$field_unit()

# get field units for specific fields
surf$field_unit(c("name", "zone name", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_default`
## ------------------------------------------------

## Not run: 
# get all field default values
surf$field_default()

# get default values for specific fields
surf$field_default(c("name", "zone name", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_choice`
## ------------------------------------------------

## Not run: 
# get all field value choices
surf$field_choice()

# get field value choices for specific fields
surf$field_choice(c("name", "sun exposure", "wind exposure"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_range`
## ------------------------------------------------

## Not run: 
# get all field value ranges
surf$field_range()

# get value ranges for specific fields
surf$field_range(c("name", "number of vertices", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_relation`
## ------------------------------------------------

## Not run: 
# get field relation for specific fields
surf$field_relation(c("name", "zone name", "vertex 10 z-coordinate"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$field_possible`
## ------------------------------------------------

## Not run: 
# get field possible values for specific fields
surf$field_possible(6:10)

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_valid_field_num`
## ------------------------------------------------

## Not run: 
surf$is_valid_field_num(c(10, 14, 100))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_extensible_index`
## ------------------------------------------------

## Not run: 
surf$is_extensible_index(c(10, 14, 100))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_valid_field_name`
## ------------------------------------------------

## Not run: 
surf$is_valid_field_name(c("name", "sun_exposure"))

# exact match
surf$is_valid_field_name(c("Name", "Sun_Exposure"), strict = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_valid_field_index`
## ------------------------------------------------

## Not run: 
surf$is_valid_field_index(1:10)

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_autosizable_field`
## ------------------------------------------------

## Not run: 
surf$is_autosizable_field()

surf$is_autosizable_field(c("name", "sun_exposure"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_autocalculatable_field`
## ------------------------------------------------

## Not run: 
surf$is_autocalculatable_field()

surf$is_autocalculatable_field(c("name", "sun_exposure"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_numeric_field`
## ------------------------------------------------

## Not run: 
surf$is_numeric_field()

surf$is_numeric_field(c("name", "sun_exposure"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_real_field`
## ------------------------------------------------

## Not run: 
surf$is_real_field()

surf$is_real_field(c("name", "number of vertices"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_integer_field`
## ------------------------------------------------

## Not run: 
surf$is_integer_field()

surf$is_integer_field(c("name", "number of vertices"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$is_required_field`
## ------------------------------------------------

## Not run: 
surf$is_required_field()

surf$is_required_field(c("name", "number of vertices"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$has_ref`
## ------------------------------------------------

## Not run: 
surf$has_ref()

surf$has_ref(c("name", "zone name"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$has_ref_to`
## ------------------------------------------------

## Not run: 
surf$has_ref_to()

surf$has_ref_to(c("name", "zone name"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$has_ref_by`
## ------------------------------------------------

## Not run: 
surf$has_ref_by()

surf$has_ref_by(c("name", "zone name"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$outputs`
## ------------------------------------------------

## Not run: 
surf$outputs()

## End(Not run)


## ------------------------------------------------
## Method `IddObject$to_table`
## ------------------------------------------------

## Not run: 
surf$to_table()

surf$to_table(TRUE)

## End(Not run)


## ------------------------------------------------
## Method `IddObject$to_string`
## ------------------------------------------------

## Not run: 
# get text format of class BuildingSurface:Detailed
surf$to_string()

# tweak output formatting
surf$to_string(leading = 0, sep_at = 0)

# add comments
surf$to_string(c("This", "will", "be", "comments"))

## End(Not run)


## ------------------------------------------------
## Method `IddObject$print`
## ------------------------------------------------

## Not run: 
surf

surf$print(brief = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Idf'>Read, Modify, and Run an EnergyPlus Model</h2><span id='topic+Idf'></span>

<h3>Description</h3>

<p>eplusr provides parsing EnergyPlus Input Data File (IDF) files and strings
in a hierarchical structure, which was extremely inspired by
<a href="https://openstudio-sdk-documentation.s3.amazonaws.com/cpp/OpenStudio-2.5.1-doc/utilities/html/idf_page.html">OpenStudio utilities library</a>,
but with total different data structure under the hook.
</p>


<h3>Details</h3>

<p>eplusr uses <code>Idf</code> class to present the whole IDF file and use <a href="#topic+IdfObject">IdfObject</a>
to present a single object in IDF. Both <code>Idf</code> and <a href="#topic+IdfObject">IdfObject</a> contain member
functions for helping modify the data in IDF so it complies with the
underlying IDD (EnergyPlus Input Data Dictionary).
</p>
<p>Under the hook, eplusr uses a SQL-like structure to store both IDF and IDD
data in different <a href="data.table.html#topic+data.table">data.table::data.table</a>s. So to modify an EnergyPlus model
in eplusr is equal to change the data in those IDF tables accordingly, in the
context of specific IDD data. This means that a corresponding <a href="#topic+Idd">Idd</a> object is
needed whenever creating an <code>Idf</code> object. eplusr provides several
<a href="#topic+use_idd">helpers</a> to easily download IDD files and create <a href="#topic+Idd">Idd</a> objects.
</p>
<p>All IDF reading process starts with function <code><a href="#topic+read_idf">read_idf()</a></code> which returns an
<code>Idf</code> object. <code>Idf</code> class provides lots of methods to programmatically query
and modify EnergyPlus models.
</p>
<p>Internally, the powerful <a href="https://cran.r-project.org/package=data.table">data.table</a>
package is used to speed up the whole IDF parsing process and store the
results. Under the hook, eplusr uses a SQL-like structure to store both IDF
and IDD data in <a href="data.table.html#topic+data.table">data.table::data.table</a> format. Every IDF will be parsed and
stored in three tables:
</p>

<ul>
<li> <p><code>object</code>: contains object IDs, names and comments.
</p>
</li>
<li> <p><code>value</code>: contains field values
</p>
</li>
<li> <p><code>reference</code>: contains cross-reference data of field values.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Idf-new"><code>Idf$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-version"><code>Idf$version()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-path"><code>Idf$path()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-group_name"><code>Idf$group_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-class_name"><code>Idf$class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_valid_group"><code>Idf$is_valid_group()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_valid_class"><code>Idf$is_valid_class()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-definition"><code>Idf$definition()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object_id"><code>Idf$object_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object_name"><code>Idf$object_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object_num"><code>Idf$object_num()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_valid_id"><code>Idf$is_valid_id()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_valid_name"><code>Idf$is_valid_name()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object"><code>Idf$object()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-objects"><code>Idf$objects()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object_unique"><code>Idf$object_unique()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-objects_in_class"><code>Idf$objects_in_class()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-objects_in_group"><code>Idf$objects_in_group()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-object_relation"><code>Idf$object_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-objects_in_relation"><code>Idf$objects_in_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-search_object"><code>Idf$search_object()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-dup"><code>Idf$dup()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-add"><code>Idf$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-set"><code>Idf$set()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-del"><code>Idf$del()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-purge"><code>Idf$purge()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-duplicated"><code>Idf$duplicated()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-unique"><code>Idf$unique()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-rename"><code>Idf$rename()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-insert"><code>Idf$insert()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-load"><code>Idf$load()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-update"><code>Idf$update()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-paste"><code>Idf$paste()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-search_value"><code>Idf$search_value()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-replace_value"><code>Idf$replace_value()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-validate"><code>Idf$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_valid"><code>Idf$is_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-to_string"><code>Idf$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-to_table"><code>Idf$to_table()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-external_deps"><code>Idf$external_deps()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-is_unsaved"><code>Idf$is_unsaved()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-save"><code>Idf$save()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-run"><code>Idf$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-last_job"><code>Idf$last_job()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-geometry"><code>Idf$geometry()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-view"><code>Idf$view()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-print"><code>Idf$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Idf-clone"><code>Idf$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Idf-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>Idf</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$new(path, idd = NULL, encoding = "unknown")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Either a path, a connection, or literal data (either a single
string or a raw vector) to an EnergyPlus Input Data File
(IDF). If a file path, that file usually has a extension
<code>.idf</code>.</p>
</dd>
<dt><code>idd</code></dt><dd><p>Any acceptable input of <code><a href="#topic+use_idd">use_idd()</a></code>. If <code>NULL</code>, which is the
default, the version of IDF will be passed to <code><a href="#topic+use_idd">use_idd()</a></code>. If
the input is an <code>.ddy</code> file which does not have a version
field, the latest version of <a href="#topic+Idf">Idf</a> cached will be used.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The file encoding of input IDF. Should be one of
<code>"unknown"</code>, <code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that the file is encoded in the native
encoding.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It takes an EnergyPlus Input Data File (IDF) as input and returns an
<code>Idf</code> object.
</p>
<p>Currently, Imf file is not fully supported. All EpMacro lines will be treated
as normal comments of the nearest downwards object. If input is an Imf file,
a warning will be given during parsing. It is recommended to convert the Imf
file to an Idf file and use <a href="#topic+ParametricJob">ParametricJob</a> class to conduct
parametric analysis.
</p>



<h5>Returns</h5>

<p>An <code>Idf</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# If neither EnergyPlus v8.8 nor Idd v8.8 was found, error will
# occur. If Idd v8.8 is found, it will be used automatically.
idf &lt;- Idf$new(path_idf)

# argument `idd` can be specified explicitly using `use_idd()`
idf &lt;- Idf$new(path_idf, idd = use_idd(8.8))

# you can set `download` arugment to "auto" in `use_idd()` if you
# want to automatically download corresponding IDD file when
# necessary
idf &lt;- Idf$new(path_idf, use_idd(8.8, download = "auto"))

# Besides use a path to an IDF file, you can also provide IDF in literal
# string format
string_idf &lt;-
    "
    Version, 8.8;
    Building,
        Building;                !- Name
    "

Idf$new(string_idf, use_idd(8.8, download = "auto"))
}

</pre>
</div>


<hr>
<a id="method-Idf-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of current <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of current <code>Idf</code> in a
<code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> format. This makes it easy to direction
compare versions of different <code>Idf</code>s, e.g. <code>idf$version() &gt; 8.6</code> or
<code>idf1$version() &gt; idf2$version()</code>.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get version
idf$version()
}

</pre>
</div>


<hr>
<a id="method-Idf-path"></a>



<h4>Method <code>path()</code></h4>

<p>Get the file path of current <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$path()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$path()&#8288;</code> returns the full path of current <code>Idf</code> or <code>NULL</code> if the
<code>Idf</code> object is created using a character vector and not saved
locally.
</p>



<h5>Returns</h5>

<p><code>NULL</code> or a single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get path
idf$path()

# return `NULL` if Idf is not created from a file
Idf$new("Version, 8.8;\n")$path()
}

</pre>
</div>


<hr>
<a id="method-Idf-group_name"></a>



<h4>Method <code>group_name()</code></h4>

<p>Get names of groups
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$group_name(all = FALSE, sorted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>If <code>FALSE</code>, only names of groups in current <code>Idf</code> object
will be returned. If <code>TRUE</code>, all group names in the underlying
<a href="#topic+Idd">Idd</a> will be returned. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>sorted</code></dt><dd><p>Only applicable when <code>all</code> is <code>FALSE</code>. If <code>TRUE</code>,
duplications in returned group or class names are removed, and
unique names are further sorted according to their occurrences
in the underlying <a href="#topic+Idd">Idd</a>. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_name()&#8288;</code> returns names of groups current <code>Idf</code> contains or
the underlying <a href="#topic+Idd">Idd</a> object contains.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get names of all groups Idf contains
idf$group_name()

# get group name of each object in Idf
idf$group_name(sorted = FALSE)

# get names of all available groups in underlying Idd
idf$group_name(all = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-class_name"></a>



<h4>Method <code>class_name()</code></h4>

<p>Get names of classes
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$class_name(all = FALSE, sorted = TRUE, by_group = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>If <code>FALSE</code>, only names of classes in current <code>Idf</code> object
will be returned. If <code>TRUE</code>, all class names in the underlying
<a href="#topic+Idd">Idd</a> will be returned. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>sorted</code></dt><dd><p>Only applicable when <code>all</code> is <code>FALSE</code>. If <code>TRUE</code>,
duplications in returned group or class names are removed, and
unique names are further sorted according to their occurrences
in the underlying <a href="#topic+Idd">Idd</a>. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>Only applicable when <code>all</code> or <code>sorted</code> is <code>TRUE</code>. If
<code>TRUE</code>, a list is returned which separates class names by the
group they belong to.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_name()&#8288;</code> returns names of classes current <code>Idf</code> contains or
the underlying <a href="#topic+Idd">Idd</a> object contains.
</p>



<h5>Returns</h5>

<p>A character vector if <code>by_group</code> is <code>FALSE</code> and a list of
character vectors when <code>by_group</code> is <code>TRUE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get names of all classes in Idf
idf$class_name()

# get names of all classes grouped by group names in Idf
idf$class_name(by_group = TRUE)

# get class name of each object in Idf
idf$class_name(sorted = FALSE)

# get names of all available classes in underlying Idd
idf$class_name(all = TRUE)

# get names of all available classes grouped by group names in
# underlying Idd
idf$class_name(all = TRUE, by_group = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-is_valid_group"></a>



<h4>Method <code>is_valid_group()</code></h4>

<p>Check if elements in input character vector are valid group names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_valid_group(group, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A character vector to check.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>FALSE</code>, check if input characters are valid group names
for current <code>Idf</code>. If <code>TRUE</code>, check if input characters are
valid group names for underlying <a href="#topic+Idd">Idd</a>. Default: FALSE</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_group()&#8288;</code> returns <code>TRUE</code>s if given character vector
contains valid group names in the context of current <code>Idf</code> (when
<code>all</code> is <code>FALSE</code>) or current underlying <a href="#topic+Idd">Idd</a> (when <code>all</code> is <code>TRUE</code>).
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Location and Climate"</code> is a valid group name but <code>"location and climate"</code> is not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input character
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check if input is a valid group name in current Idf
idf$is_valid_group(c("Schedules", "Compliance Objects"))

# check if input is a valid group name in underlying Idd
idf$is_valid_group(c("Schedules", "Compliance Objects"), all = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-is_valid_class"></a>



<h4>Method <code>is_valid_class()</code></h4>

<p>Check if elements in input character vector are valid class names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_valid_class(class, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector to check.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>FALSE</code>, check if input characters are valid class names
for current <code>Idf</code>. If <code>TRUE</code>, check if input characters are
valid class names for underlying <a href="#topic+Idd">Idd</a>. Default: FALSE</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_class()&#8288;</code> returns <code>TRUE</code>s if given character vector
contains valid class names in the context of current <code>Idf</code> (when
<code>all</code> is <code>FALSE</code>) or current underlying <a href="#topic+Idd">Idd</a> (when <code>all</code> is <code>TRUE</code>),
and <code>FALSE</code>s otherwise.
</p>
<p>Note that case-sensitive matching is performed, which means that
<code>"Version"</code> is a valid class name but <code>"version"</code> is not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input character
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check if input is a valid class name in current Idf
idf$is_valid_class(c("Building", "ShadowCalculation"))

# check if input is a valid class name in underlying Idd
idf$is_valid_class(c("Building", "ShadowCalculation"), all = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-definition"></a>



<h4>Method <code>definition()</code></h4>

<p>Get the <a href="#topic+IddObject">IddObject</a> object for specified class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$definition(class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A <strong>single</strong> string of valid class name in current
<a href="#topic+Idd">Idd</a>. If <code>NULL</code>, the underlying <a href="#topic+Idd">Idd</a> object is returned.
Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$definition()&#8288;</code> returns an <a href="#topic+IddObject">IddObject</a> of given class. <a href="#topic+IddObject">IddObject</a>
contains all data used for parsing and creating an <a href="#topic+IdfObject">IdfObject</a>. For
details, please see <a href="#topic+IddObject">IddObject</a> class.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IddObject">IddObject</a> object if class is not <code>NULL</code> or an <a href="#topic+Idd">Idd</a>
object if class is <code>NULL</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get the IddObject object for specified class
idf$definition("Version")
}

</pre>
</div>


<hr>
<a id="method-Idf-object_id"></a>



<h4>Method <code>object_id()</code></h4>

<p>Get the unique ID for each object in specified classes in the <code>Idf</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object_id(class = NULL, simplify = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector that contains valid class names for
current <code>Idf</code> object. If <code>NULL</code>, all classes in current <code>Idf</code>
object are used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>If <code>TRUE</code>, an integer vector contains object IDs of
all specified classes is returned. If <code>FALSE</code>, a named list
that contains object IDs for each specified class is returned.
Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In <code>Idf</code>, each object is assigned with an integer as an universally
unique identifier (UUID) in the context of current <code>Idf</code>. UUID is
not reused even if the object associated is deleted.
</p>
<p><code style="white-space: pre;">&#8288;$object_id()&#8288;</code> returns an integer vector (when <code>simplify</code> is <code>TRUE</code>)
or a named list (when <code>simplify</code> is <code>FALSE</code>) of integer vectors that
contain object IDs in each specified class. The returned list is
named using specified class names.
</p>



<h5>Returns</h5>

<p>An integer vector (when <code>simplify</code> is <code>TRUE</code>) or a named list
of integer vectors (when <code>simplify</code> is <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get IDs of all objects in current Idf object
idf$object_id()

# get IDs of all objects in current Idf object, and merge them into a
# single integer vector
idf$object_id(simplify = TRUE)

# get IDs of objects in class Version and Zone
idf$object_id(c("Version", "Zone"))

# get IDs of objects in class Version and Zone, and merge them into a
# single integer vector
idf$object_id(c("Version", "Zone"), simplify = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-object_name"></a>



<h4>Method <code>object_name()</code></h4>

<p>Get names for objects in specified classes in the <code>Idf</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object_name(class = NULL, simplify = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector that contains valid class names for
current <code>Idf</code>. If <code>NULL</code>, all classes in current <code>Idf</code> are
used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>If <code>TRUE</code>, a character vector contains object names
of all specified classes is returned. If <code>FALSE</code>, a named list
that contains a character vector for each specified class is
returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In <code>Idf</code>, each object is assigned with a single string as the name
for it, if the class it belongs to has name attribute, e.g. class
<code>RunPeriod</code>, <code>Material</code> and etc. That name should be unique among all
objects in that class. EnergyPlus will fail with an error if
duplications are found among object names in a class.
</p>
<p><code style="white-space: pre;">&#8288;$object_name()&#8288;</code> returns a character vector (when <code>simplify</code> is
<code>TRUE</code>) or a named list (when <code>simplify</code> is <code>FALSE</code>) of character
vectors that contain object IDs in each specified class. The returned
list is named using specified class names. If specified class does
not have name attribute, <code>NA</code>s are returned.
</p>



<h5>Returns</h5>

<p>A character vector (when <code>simplify</code> is <code>TRUE</code>) or a named
list of character vectors (when <code>simplify</code> is <code>FALSE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get names of all objects in current Idf object
idf$object_name()

# get names of all objects in current Idf object, and merge them into
# a single character vector
idf$object_name(simplify = TRUE)

# get names of objects in class Version and Zone
idf$object_name(c("Version", "Zone"))

# get names of objects in class Version and Zone, and merge them into
# a single character vector
idf$object_name(c("Version", "Zone"), simplify = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-object_num"></a>



<h4>Method <code>object_num()</code></h4>

<p>Get number of objects in specified classes in the <a href="#topic+Idf">Idf</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object_num(class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector that contains valid class names for
underlying <a href="#topic+Idd">Idd</a>. If <code>NULL</code>, all classes in current <code>Idf</code> are
used, and the total object number is returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$object_num()&#8288;</code> returns an integer vector of object number in
specified classes. <code>0</code> is returned if there is no object in that
class.
</p>



<h5>Returns</h5>

<p>An integer vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get total number of objects
idf$object_num()

# get number of objects in class Zone and Schedule:Compact
idf$object_num(c("Zone", "Schedule:Compact"))
}

</pre>
</div>


<hr>
<a id="method-Idf-is_valid_id"></a>



<h4>Method <code>is_valid_id()</code></h4>

<p>Check if elements in input integer vector are valid object IDs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_valid_id(id, class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>An integer vector to check.</p>
</dd>
<dt><code>class</code></dt><dd><p>A single string indicates the class where the objects to
check against. If <code>NULL</code>, all classes in current <code>Idf</code> are
used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_id()&#8288;</code> returns <code>TRUE</code>s if given integer vector
contains valid object IDs in current <code>Idf</code> object.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input integer
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$is_valid_id(c(51, 1000))
}

</pre>
</div>


<hr>
<a id="method-Idf-is_valid_name"></a>



<h4>Method <code>is_valid_name()</code></h4>

<p>Check if elements in input character vector are valid object names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_valid_name(name, class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A character vector to check.</p>
</dd>
<dt><code>class</code></dt><dd><p>A single string indicates the class where the objects to
check against. If <code>NULL</code>, all classes in current <code>Idf</code> are
used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid_name()&#8288;</code> returns <code>TRUE</code>s if given character vector
contains valid object names in current <code>Idf</code> object.
</p>
<p>Note that <strong>case-insensitive</strong> matching is performed, which means
that <code>"rOoF"</code> is equivalent to <code>"roof"</code>. This behavior is consistent
in all methods that take object name(s) as input.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as input character
vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$is_valid_name(c("Simple One Zone (Wireframe DXF)", "ZONE ONE", "a"))

# name matching is case-insensitive
idf$is_valid_name(c("simple one zone (wireframe dxf)", "zone one", "a"))
}

</pre>
</div>


<hr>
<a id="method-Idf-object"></a>



<h4>Method <code>object()</code></h4>

<p>Extract an <a href="#topic+IdfObject">IdfObject</a> object using object ID or name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object(which, class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>A single integer specifying the object ID or a single
string specifying the object name.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector that contains valid class names for
current <code>Idf</code> object used to locate objects. If <code>NULL</code>, all
classes in current <code>Idf</code> object are used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$object()&#8288;</code> returns an <a href="#topic+IdfObject">IdfObject</a> object specified by an object ID
or name.
</p>
<p>Note that unlike object ID, which is always unique across the whole
<code>Idf</code> object, different objects can have the same name. If the name
given matches multiple objects, an error is issued showing what
objects are matched by the same name. This behavior is consistent in
all methods that take object name(s) as input. In this case, it is
suggested to directly use object ID instead of name.
</p>
<p>Note that <strong>case-insensitive</strong> matching is performed for object
names, which means that <code>"rOoF"</code> is equivalent to <code>"roof"</code>. This
behavior is consistent in all methods that take object name(s) as
input.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IdfObject">IdfObject</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get an object whose ID is 3
idf$object(3)

# get an object whose name is "simple one zone (wireframe dxf)"
# NOTE: object name matching is case-insensitive
idf$object("simple one zone (wireframe dxf)")
}

</pre>
</div>


<hr>
<a id="method-Idf-objects"></a>



<h4>Method <code>objects()</code></h4>

<p>Extract multiple <a href="#topic+IdfObject">IdfObject</a> objects using object IDs or names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$objects(which)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector specifying object IDs or a character
vector specifying object names.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects()&#8288;</code> returns a named list of <a href="#topic+IdfObject">IdfObject</a> objects using object
IDS or names. The returned list is named using object names.
</p>
<p>Note that unlike object ID, which is always unique across the whole
<code>Idf</code> object, different objects can have the same name. If the name
given matches multiple objects, an error is issued showing what
objects are matched by the same name. This behavior is consistent in
all methods that take object name(s) as input. In this case, it is
suggested to directly use object ID instead of name.
</p>
<p>Note that <strong>case-insensitive</strong> matching is performed for object
names, which means that <code>"rOoF"</code> is equivalent to <code>"roof"</code>. This
behavior is consistent in all methods that take object name(s) as
input.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get objects whose IDs are 3 and 10
idf$objects(c(3,10))

# get objects whose names are "Simple One Zone (Wireframe DXF)" and "ZONE ONE"
# NOTE: object name matching is case-insensitive
idf$objects(c("Simple One Zone (Wireframe DXF)", "zone one"))
}

</pre>
</div>


<hr>
<a id="method-Idf-object_unique"></a>



<h4>Method <code>object_unique()</code></h4>

<p>Extract the <a href="#topic+IdfObject">IdfObject</a> in class with <code>unique-object</code> attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object_unique(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A single string of valid class name for current <code>Idf</code>
object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For each version of an <code>Idf</code> object, the corresponding underlying
<a href="#topic+Idd">Idd</a> describe how many objects can be defined in each class. Classes
that have <code>unique-object</code> attribute can only hold a single object,
e.g. <code>Version</code>, <code>SimulationControl</code> and etc. <code style="white-space: pre;">&#8288;$object_unique()&#8288;</code> can
be used to directly return the <a href="#topic+IdfObject">IdfObject</a> in one <code>unique-object</code>
class. An error will be issued if there are multiple objects in that
class or input class is not an <code>unique-object</code> class. This makes sure
that <code style="white-space: pre;">&#8288;$object_unique()&#8288;</code> always returns a single <a href="#topic+IdfObject">IdfObject</a>.
</p>
<p><code>Idf</code> class also provides custom S3 method of <code>$</code> and <code>[[</code> to
make it more convenient to get the <a href="#topic+IdfObject">IdfObject</a> in <code>unique-object</code>
class. Basically, <code>idf$ClassName</code> and <code>idf[["ClassName"]]</code>,
where <code>ClassName</code> is a single valid class name, is equivalent to
<code>idf$object_unique(ClassName)</code> if <code>ClassName</code> is an <code>unique-object</code>
class. For convenience, underscore-style names are allowed when using
<code>$</code>, e.g.  <code>Site_Location</code> is equivalent to <code>Site:Location</code>. For
instance, <code>idf$Site_Location</code> and also <code>idf[["Site_Location"]]</code> will
both return the <a href="#topic+IdfObject">IdfObject</a>s in <code>Site:Location</code> class. Note that
unlike <code style="white-space: pre;">&#8288;$object_unique()&#8288;</code>, <code>idf$ClassName</code> and <code>idf[["ClassName"]]</code>
will directly return <code>NULL</code> instead of giving an error when
<code>ClassName</code> is not a valid class name in current <code>Idf</code> object. This
makes it possible to use <code>is.null(idf$ClassName)</code> to check if
<code>ClassName</code> is a valid class or not.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IdfObject">IdfObject</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get the SimulationColtrol object
idf$object_unique("SimulationControl")

# S3 "[[" and "$" can also be used
idf$SimulationControl
idf[["SimulationControl"]]
}

</pre>
</div>


<hr>
<a id="method-Idf-objects_in_class"></a>



<h4>Method <code>objects_in_class()</code></h4>

<p>Extract all <a href="#topic+IdfObject">IdfObject</a> objects in one class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$objects_in_class(class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A single string of valid class name for current <code>Idf</code>
object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects_in_class()&#8288;</code> returns a named list of all <a href="#topic+IdfObject">IdfObject</a> objects
in specified class. The returned list is named using object names.
</p>
<p><code>Idf</code> class also provides custom S3 method of <code>$</code> and <code>[[</code> to
make it more convenient to get all <a href="#topic+IdfObject">IdfObject</a> objects in one class.
Basically, <code>idf$ClassName</code> and <code>idf[["ClassName"]]</code>, where
<code>ClassName</code> is a single valid class name, is equivalent to
<code>idf$objects_in_class(ClassName)</code> if <code>ClassName</code> is not an
<code>unique-object</code> class. For convenience, <em>underscore-style</em> names are
allowed, e.g.  <code>BuildingSurface_Detailed</code> is equivalent to
<code>BuildingSurface:Detailed</code> when using <code>$</code>. For instance,
<code>idf$BuildingSurface_Detailed</code> and also
<code>idf[["BuildingSurface:Detailed"]]</code> will both return all <a href="#topic+IdfObject">IdfObject</a>
objects in <code>BuildingSurface:Detailed</code> class. Note that
unlike <code style="white-space: pre;">&#8288;$objects_in_class()&#8288;</code>, <code>idf$ClassName</code> and
<code>idf[["ClassName"]]</code> will directly return <code>NULL</code> instead of giving
an error when <code>ClassName</code> is not a valid class name in current <code>Idf</code>
object. This makes it possible to use <code>is.null(idf$ClassName)</code> to
check if <code>ClassName</code> is a valid class or not.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all objects in Zone class
idf$objects_in_class("Zone")

# S3 "[[" and "$" can also be used
idf$Zone
idf[["Zone"]]
}

</pre>
</div>


<hr>
<a id="method-Idf-objects_in_group"></a>



<h4>Method <code>objects_in_group()</code></h4>

<p>Extract all <a href="#topic+IdfObject">IdfObject</a> objects in one group.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$objects_in_group(group)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A single string of valid group name for current <code>Idf</code>
object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects_in_group()&#8288;</code> returns a named list of all <a href="#topic+IdfObject">IdfObject</a> objects
in specified group. The returned list is named using object names.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all objects in Schedules group
idf$objects_in_group("Schedules")
}

</pre>
</div>


<hr>
<a id="method-Idf-object_relation"></a>



<h4>Method <code>object_relation()</code></h4>

<p>Extract the relationship between object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$object_relation(
  which,
  direction = c("all", "ref_to", "ref_by", "node"),
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  keep = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>A single integer specifying object ID or a single string
specifying object name.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be either
<code>"all"</code>, <code>"ref_to"</code>, <code>"ref_by"</code> and <code>"node"</code>.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>keep</code></dt><dd><p>If <code>TRUE</code>, all fields of specified object are returned
regardless they have any relations with other objects or not.
If <code>FALSE</code>, only fields in specified object that have
relations with other objects are returned. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Many fields in <a href="#topic+Idd">Idd</a> can be referred by others. For example, the
<code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> and other fields in <code>Construction</code> class refer to the
<code>Name</code> field in <code>Material</code> class and other material related classes.
Here it means that the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> field <strong>refers to</strong> the <code>Name</code>
field and the <code>Name</code> field is <strong>referred by</strong> the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code>. In
EnergyPlus, there is also a special type of field called <code>Node</code>,
which together with <code>Branch</code>, <code>BranchList</code> and other classes define
the topography of the HVAC connections. A outlet node of a component
can be referred by another component as its inlet node, but can also
exists independently, such as zone air node.
</p>
<p><code style="white-space: pre;">&#8288;$object_relation()&#8288;</code> provides a simple interface to get this kind of
relation. It takes a single object ID or name and also a relation
direction, and returns an <code>IdfRelation</code> object which contains data
presenting such relation above. For instance, if
<code>model$object_relation("WALL-1", "ref_to")</code> gives results below:
</p>
<div class="sourceCode"><pre>-- Refer to Others ------------------------
  Class: &lt;Construction&gt;
  \- Object [ID:2] &lt;WALL-1&gt;
     \- 2: "WD01";        !- Outside Layer
        v~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        \- Class: &lt;Material&gt;
           \- Object [ID:1] &lt;WD01&gt;
              \- 1: "WD01";        !- Name
</pre></div>
<p>This means that the value <code>"WD01"</code> of <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> in a
construction named <code>WALL-1</code> refers to a material named <code>WD01</code>. All
those objects can be further easily extracted using
<code style="white-space: pre;">&#8288;$objects_in_relation()&#8288;</code> method described below.
</p>



<h5>Returns</h5>

<p>An <code>IdfRelation</code> object, which is a list of 3
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s named <code>ref_to</code>, <code>ref_by</code> and <code>node</code>.
Each <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> contains 24 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check each layer's reference of a construction named FLOOR
idf$object_relation("floor", "ref_to")

# check where is this construction being used
idf$object_relation("floor", "ref_by")
}

</pre>
</div>


<hr>
<a id="method-Idf-objects_in_relation"></a>



<h4>Method <code>objects_in_relation()</code></h4>

<p>Extract multiple <a href="#topic+IdfObject">IdfObject</a> objects referencing each others.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$objects_in_relation(
  which,
  direction = c("ref_to", "ref_by", "node"),
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>A single integer specifying object ID or a single string
specifying object name.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be one of
<code>"ref_to"</code>, <code>"ref_by"</code> or <code>"node"</code>.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in the
underlying <a href="#topic+Idd">Idd</a>. It is used to restrict the classes to be
returned. If <code>NULL</code>, all possible classes are considered and
corresponding <a href="#topic+IdfObject">IdfObject</a> objects are returned if
relationships are found. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of valid group names in the
underlying <a href="#topic+Idd">Idd</a>. It is used to restrict the groups to be
returned. If <code>NULL</code>, all possible groups are considered and
corresponding <a href="#topic+IdfObject">IdfObject</a> objects are returned if
relationships are found. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of refering to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$objects_in_relation()&#8288;</code> returns a named list of <a href="#topic+IdfObject">IdfObject</a> objects
that have specified relationship with given object. The first element of
returned list is always the specified object itself. If that
object does not have specified relationship with other objects in
specified <code>class</code>, a list that only contains specified object itself
is returned.
</p>
<p>For instance, assuming that <code>const</code> is a valid object name in
<code>Construction</code> class, <code>idf$objects_in_relation("const", "ref_by", "BuildingSurface:Detailed")</code>
will return a named list of an <a href="#topic+IdfObject">IdfObject</a> object named <code>const</code> and
also all other <a href="#topic+IdfObject">IdfObject</a> objects in <code>BuildingSurface:Detailed</code>
class that refer to field values in <code>const</code>. Similarly,
<code>idf$objects_in_relation("const", "ref_to", "Material")</code>
will return a named list of an <a href="#topic+IdfObject">IdfObject</a> object named <code>const</code> and
also all other <a href="#topic+IdfObject">IdfObject</a> objects in <code>Material</code> class that <code>const</code>
refers to. This makes it easy to directly extract groups of related
objects and then use <code style="white-space: pre;">&#8288;$insert()&#8288;</code> method or other methods
described below to insert them or extract data.
</p>
<p>There are lots of recursive references in a model. For instance, a
material can be referred by a construction, that construction can be
referred by a building surface, and that building surface can be
referred by a window on that surface. These objects related
recursively can be extracted by setting <code>recursive</code> to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>An named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get a construction named FLOOR and all materials it uses
idf$objects_in_relation("floor", "ref_to")

# get a construction named FLOOR and all surfaces that uses it
idf$objects_in_relation("floor", "ref_by", class = "BuildingSurface:Detailed")
}

</pre>
</div>


<hr>
<a id="method-Idf-search_object"></a>



<h4>Method <code>search_object()</code></h4>

<p>Extract multiple <a href="#topic+IdfObject">IdfObject</a> objects using regular expression on
names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$search_object(
  pattern,
  class = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern, ignore.case, perl, fixed, useBytes</code></dt><dd><p>All are directly
passed to <a href="base.html#topic+grep">base::grepl</a>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in the
underlying <a href="#topic+Idd">Idd</a>. It is used to restrict the classes to be
returned. If <code>NULL</code>, all possible classes are considered and
corresponding <a href="#topic+IdfObject">IdfObject</a> objects are returned if
<code>pattern</code> is met Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$search_object()&#8288;</code> returns a named list of <a href="#topic+IdfObject">IdfObject</a> objects whose
names meet the given regular expression in specified classes.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all objects whose names contains "floor"
idf$search_object("floor", ignore.case = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-dup"></a>



<h4>Method <code>dup()</code></h4>

<p>Duplicate existing objects.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$dup(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Integer vectors of object IDs and character vectors of
object names. If input is named, its name will be used as the
name of newly created objects.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$dup()&#8288;</code> takes integer vectors of object IDs and character vectors of
object names, duplicates objects specified, and returns a list of
newly created <a href="#topic+IdfObject">IdfObject</a> objects. The names of input are used as new
names for created <a href="#topic+IdfObject">IdfObject</a>s. If input is not named, new names are
the names of duplicated objects with a suffix <code>"_1"</code>, <code>"_2"</code> and etc,
depending on how many times that object has been duplicated. Note an
error will be issued if trying to assign a new name to an object
which belongs to a class that does not have name attribute.
</p>
<p>Assigning newly added objects with an existing name in current <code>Idf</code>
object is prohibited if current validation level includes object name
conflicting checking. For details, please see <code>level_checks()</code>.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# duplicate an object named "FLOOR"
idf$dup("floor") # New object name 'FLOOR_1' is auto-generated

# duplicate that object again by specifing object ID
idf$dup(16) # New object name 'FLOOR_2' is auto-generated

# duplicate that object two times and giving new names
idf$dup(new_floor = "floor", new_floor2 = 16)

# duplicate that object multiple times using variable inputs
floors_1 &lt;- c(new_floor3 = "floor", new_floor4 = "floor")
floors_2 &lt;- setNames(rep(16, 5), paste0("flr", 1:5))
idf$dup(floors_1, floors_2)
}

</pre>
</div>


<hr>
<a id="method-Idf-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add new objects.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$add(..., .default = TRUE, .all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Lists of object definitions. Each list should be named
with a valid class name. There is a special element <code>.comment</code>
in each list, which will be used as the comments of newly
added object.</p>
</dd>
<dt><code>.default</code></dt><dd><p>If <code>TRUE</code>, default values are used for those blank
fields if possible. If <code>FALSE</code>, empty fields are kept blank.
Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.all</code></dt><dd><p>If <code>TRUE</code>, all fields are added. If <code>FALSE</code>, only minimum
required fields are added. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$add()&#8288;</code> takes new object definitions in list format, adds
corresponding objects in specified classes, returns a list of newly
added <a href="#topic+IdfObject">IdfObject</a> objects. The returned list will be named using
newly added object names. Every list should be named using a valid
class name.  Underscore-style class name is allowed for class name.
Names in each list element are treated as field names. Values without
names will be inserted according to their position. There is a
special element named <code>.comment</code> in each list, which will be used as
the comments of newly added object.
</p>
<p>Empty objects can be added using an empty list, e.g.
<code>idf$add(Building = list())</code>. All empty fields will be filled with
corresponding default value if <code>.default</code> is <code>TRUE</code>, leaving other
fields as blanks. However, adding blank objects may not be allowed if
there are required fields in that class and current validate level
includes missing-required-field checking. For what kind of validation
components will be performed during adding new objects, please see
<code><a href="#topic+level_checks">level_checks()</a></code>.
</p>
<p>Note that <code>.()</code> can be used as an alias as <code>list()</code>, e.g.
<code>idf$add(Building = .())</code> is equivalent to
<code>idf$add(Building = list())</code>.
</p>
<p>Field name matching is <strong>case-insensitive</strong>. For convenience,
underscore-style field names are also allowed, e.g. <code>eNd_MoNtH</code> is
equivalent to <code style="white-space: pre;">&#8288;End Month&#8288;</code>. This behavior is consistent among all
methods that take field names as input.
</p>
<p>There is no need to give all field values if only specific fields are
interested, as long as other fields are not required. For example, to
define a new object in <code>RunPeriod</code> class, the following is enough (at
least for EnergyPlus v8.8):
</p>
<div class="sourceCode"><pre>idf$add(
    RunPeriod = list(
        "my run period",
        begin_month = 1, begin_day_of_month = 1,
        end_month = 1, end_day_of_month = 31
    ),
    .default = TRUE
)
</pre></div>
<p>If not all field names are given, positions of those values without
field names are determined after those values with names. E.g. in
<code>idf$add(Construction = list("out_layer", name = "name"))</code>,
<code>"out_layer"</code> will be treated as the value for field <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code>
in <code>Construction</code> class, since the value for field <code>Name</code> has been
specified using explicit field name.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# add a new Building object with all default values
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = .())

# add a new Building object with all default values and comments
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = .(.comment = c("this is", "a new building")))

# add a new RunPeriod object with all possible fields
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = list(), RunPeriod = list("rp", 1, 1, 1, 31), .all = TRUE)

# add objects using variable inputs
empty &lt;- empty_idf(8.8) # create an empty Idf
objs1 &lt;- list(Schedule_Constant = list("const"), Building = list())
rp &lt;- list(RunPeriod = list("rp", 2, 1, 2, 28))
empty$add(objs1, rp)
}

</pre>
</div>


<hr>
<a id="method-Idf-set"></a>



<h4>Method <code>set()</code></h4>

<p>Set values of existing objects.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$set(..., .default = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Lists of object definitions. Each list should be named
with a valid object name or ID denoted in style <code>..ID</code>. There
is a special element <code>.comment</code> in each list, which will be
used as new comments of modified object, overwriting existing
comments if any.</p>
</dd>
<dt><code>.default</code></dt><dd><p>If <code>TRUE</code>, default values are used for those blank
fields if possible. If <code>FALSE</code>, empty fields are kept blank.
Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$set()&#8288;</code> takes new field value definitions in list format, sets new
values for fields in objects specified, and returns a list of
modified <a href="#topic+IdfObject">IdfObject</a>s. The returned list will be named using names of
modified objects. Every list in <code style="white-space: pre;">&#8288;$set()&#8288;</code> should be named with a
valid object name. Object ID can also be used but have to be combined
with prevailing two periods <code>..</code>, e.g. <code>..10</code> indicates the object
with ID <code>10</code>. Similar to
<a href="../../eplusr/html/Idf.html#method-add"><code>$add()</code></a>, a
special element <code>.comment</code> in each list will be used as the <strong>new</strong>
comments for modified object, overwriting the old ones. Names in list
element are treated as field names.
</p>
<p>Note that <code>.()</code> can be used as an alias as <code>list()</code>, e.g.
<code>idf$set(Building = .(...))</code> is equivalent to
<code>idf$set(Building = list(...))</code>.
</p>
<p>There is two special syntax in <code style="white-space: pre;">&#8288;$set()&#8288;</code>, which is inspired by the
<a href="https://cran.r-project.org/package=eplusr">data.table</a> package:
</p>

<ul>
<li> <p><code>class := list(field = value)</code>: Note the use of <code style="white-space: pre;">&#8288;:=&#8288;</code> instead of
<code>=</code>. The main difference is that, unlike <code>=</code>, the left hand side of
<code style="white-space: pre;">&#8288;:=&#8288;</code> should be a valid class name in current <code>Idf</code> object. It will
set the field of all objects in specified class to specified value.
</p>
</li>
<li> <p><code>.(object, object) := list(field = value)</code>: Similar like above, but
note the use of <code>.()</code> in the left hand side. You can put multiple
object ID or names in <code>.()</code>. It will set the field of all specified
objects to specified value.
</p>
</li></ul>

<p>You can delete a field by assigning <code>NULL</code> to it, e.g. <code>list(fld = NULL)</code> means to delete the value of field <code>fld</code>, in the condition
that <code>.default</code> is <code>FALSE</code>, <code>fld</code> is not a required field and the
index of <code>fld</code> is larger than the number minimum fields required for
that class. If those conditions are not required, <code>fld</code> will be left
as blank if <code>.default</code> is <code>FALSE</code> or filled with default value if
<code>.default</code> is <code>TRUE</code>.
</p>
<p>By default, trailing empty fields that are not required will be
removed and only minimum required fields are kept. For example, if
<code>rp</code> is an object in <code>RunPeriod</code> class in an <code>Idf</code> of version 8.8,
by default empty field with index larger than 11 will be removed
since they are all non-required fields. You can keep the trailing
empty fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>
<p>New fields that currently do not exist in that object can also be
set. They will be automatically added on the fly.
</p>
<p>Field name matching is <strong>case-insensitive</strong>. For convenience,
underscore-style field names are also allowed, e.g. <code>eNd_MoNtH</code> is
equivalent to <code style="white-space: pre;">&#8288;End Month&#8288;</code>.
</p>
<p>If not all field names are given, positions of those values without
field names are determined after those values with names. E.g. in
<code>idf$set(floor = list("out_layer", name = "name"))</code>, <code>"out_layer"</code>
will be treated as the value for field <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> in an object
named <code>floor</code>, since the value for field <code>Name</code> has been specified
using explicit field name.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# modify an object by name (case-insensitive)
idf$set(r13layer = list(roughness = "smooth"))

# modify an object by ID
idf$set(..12 = list(roughness = "rough"))

# overwrite existing object comments
idf$set(r13layer = list(.comment = c("New comment")))

# assign default values to fields
idf$set(r13layer = list(solar_absorptance = NULL), .default = TRUE)

# set field values to blanks
idf$set(r13layer = list(solar_absorptance = NULL), .default = FALSE)

# set field values to blank and delete trailing fields
idf$set(r13layer = list(visible_absorptance = NULL), .default = FALSE)

# set field values to blank and keep blank fields
idf$set(r13layer = list(visible_absorptance = NULL), .default = FALSE, .empty = TRUE)

# set all fields in one class
idf$set(Material_NoMass := list(visible_absorptance = 0.9))

# set multiple objects in one class
idf$set(.("r13layer", "r31layer") := list(solar_absorptance = 0.8))
# above is equivalent to
idf$set(r13layer = list(solar_absorptance = 0.8),
        r31layer = list(solar_absorptance = 0.8)
)

# use variable input
sets &lt;- list(r13layer = list(roughness = "smooth"))
idf$set(sets)
}

</pre>
</div>


<hr>
<a id="method-Idf-del"></a>



<h4>Method <code>del()</code></h4>

<p>Delete existing objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$del(
  ...,
  .ref_by = FALSE,
  .ref_to = FALSE,
  .recursive = FALSE,
  .force = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>integer vectors of object IDs and character vectors of
object names in current <code>Idf</code> object.</p>
</dd>
<dt><code>.ref_by</code></dt><dd><p>If <code>TRUE</code>, objects whose fields refer to input objects
will also be deleted. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>.ref_to</code></dt><dd><p>If <code>TRUE</code>, objects whose fields are referred by input
objects will also be deleted. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>.recursive</code></dt><dd><p>If <code>TRUE</code>, relation searching is performed
recursively, in case that objects whose fields refer to target
object are also referred by another object, and also objects
whose fields are referred by target object are also referred
by another object. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>.force</code></dt><dd><p>If <code>TRUE</code>, objects are deleted even if they are
referred by other objects.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$del()&#8288;</code> takes integer vectors of object IDs and character vectors of
object names, and deletes objects specified.
</p>
<p>If current <a href="#topic+level_checks">validate level</a> includes reference
checking, objects will not be allowed to be deleted if they are
referred by other objects. For example, an error will be issued if
you want to delete one material that is referred by other
constructions, because doing so will result in invalid field value
references. You may bypass this if you really want to by setting
<code>.force</code> to <code>TRUE</code>.
</p>
<p>When <code>.ref_by</code> or <code>.ref_to</code> is <code>TRUE</code>, objects will be deleted
only when they have and only have relation with input objects but not
any other objects. For example, a construction <code>const</code> consist of 4
different materials. If <code>.ref_to</code> is <code>TRUE</code>, that 4 materials will
only be deleted when they are only used in <code>const</code>, but not used in
any other objects.
</p>
<p>There are recursively reference relations in <code>Idf</code> object. For
example, one material's name is referenced by one construction, and
that construction's name can be referred by another surface. You can
delete all of them by setting <code>.recursive</code> to <code>TRUE</code>.
</p>
<p>If <code>.ref_by</code> is <code>TRUE</code>, objects whose fields refer to input objects
will also be deleted.
</p>
<p>IF <code>.ref_to</code> is <code>TRUE</code>, objects whose fields
are referred by input objects will also be deleted.
</p>



<h5>Returns</h5>

<p>The modified <code>Idf</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# delete objects using names
idf$object("Fraction") # ScheduleTypeLimits
idf$del("Fraction")

# delete objects using IDs
idf$objects(c(39, 40)) # Output:Variable
idf$del(39, 40)

# cannot delete objects that are referred by others
level_checks()$reference # reference-checking is enable by default
idf$del("r13layer") # error

# force to delete objects even thay are referred by others
idf$del("r13layer", .force = TRUE)

# delete objects and also objects that refer to them
idf$del("r31layer", .ref_by = TRUE) # Construction 'ROOF31' will be kept

# delete objects and also objects that they refer to
idf$del("extlights", .ref_to = TRUE) # Schedule 'AlwaysOn' will be kept

# delete objects and also other objects that refer to them recursively
idf$del("roof31", .ref_by = TRUE, .recursive = TRUE)

# delete objects using variable inputs
ids &lt;- idf$object_id("Output:Variable", simplify = TRUE)
idf$del(ids)
}

</pre>
</div>


<hr>
<a id="method-Idf-purge"></a>



<h4>Method <code>purge()</code></h4>

<p>Purge resource objects that are not used
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$purge(object = NULL, class = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>an integer vector of object IDs or a character vector
of object names in current <code>Idf</code> object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in current <code>Idf</code>
object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of valid group names in current <code>Idf</code>
object. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$purge()&#8288;</code> takes an integer vector of object IDs or a character
vectors of object names, and deletes resource objects specified that
are not used by any objects.
</p>
<p>Here resource objects indicate all objects that can be referenced by
other objects, e.g. all schedules. <code style="white-space: pre;">&#8288;$purge()&#8288;</code> will ignore any inputs
that are not resources. If inputs contain objects from multiple
classes, references among them are also taken into account, which
means purging is performed hierarchically. If both materials and
constructions are specified, the latter will be purged first, because
it is possible that input constructions reference input materials.
</p>



<h5>Returns</h5>

<p>The modified <code>Idf</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# purge unused "Fraction" schedule type
idf$purge("on/off") # ScheduleTypeLimits

# purge all unused schedule types
idf$purge(class = "ScheduleTypeLimits")

# purge all unused schedule related objects
idf$purge(group = "Schedules")
}

</pre>
</div>


<hr>
<a id="method-Idf-duplicated"></a>



<h4>Method <code>duplicated()</code></h4>

<p>Determine duplicated objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$duplicated(object = NULL, class = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>an integer vector of object IDs or a character vector
of object names in current <code>Idf</code> object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in current <code>Idf</code>
object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of valid group names in current <code>Idf</code>
object. Default: <code>NULL</code>.
</p>
<p>If all <code>object</code>, <code>class</code> and <code>group</code> are <code>NULL</code>, duplication checking
is performed on the whole <code>Idf</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$duplicated()&#8288;</code> takes an integer vector of object IDs or a character
vectors of object names, and returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
to show whether input objects contain duplications or not.
</p>
<p>Here duplicated objects refer to objects whose field values are the
same except the names. Object comments are just ignored during
comparison.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 4 columns:
</p>

<ul>
<li> <p><code>class</code>: Character. Names of classes that input objects belong to
</p>
</li>
<li> <p><code>id</code>: Integer. Input object IDs
</p>
</li>
<li> <p><code>name</code>: Character. Input object names
</p>
</li>
<li> <p><code>duplicate</code>: Integer. The IDs of objects that input objects
duplicate. If input object is not a duplication, <code>NA</code> is returned
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check if there are any duplications in the Idf
idf$duplicated(class = "ScheduleTypeLimits")

# check if there are any duplications in the schedule types
idf$duplicated(class = "ScheduleTypeLimits")

# check if there are any duplications in the schedule groups and
# material class
idf$duplicated(class = "Material", group = "Schedules")
}

</pre>
</div>


<hr>
<a id="method-Idf-unique"></a>



<h4>Method <code>unique()</code></h4>

<p>Remove duplicated objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$unique(object = NULL, class = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>an integer vector of object IDs or a character vector
of object names in current <code>Idf</code> object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of valid class names in current <code>Idf</code>
object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of valid group names in current <code>Idf</code>
object. Default: <code>NULL</code>.
</p>
<p>If all <code>object</code>, <code>class</code> and <code>group</code> are <code>NULL</code>, duplication checking
is performed on the whole <code>Idf</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$unique()&#8288;</code> takes an integer vector of object IDs or a character
vectors of object names, and remove duplicated objects.
</p>
<p>Here duplicated objects refer to objects whose field values are the
same except the names. Object comments are just ignored during
comparison.
</p>
<p><code style="white-space: pre;">&#8288;$unique()&#8288;</code> will only keep the first unique object and remove all
redundant objects. Value referencing the redundant objects will be
redirected into the unique object.
</p>



<h5>Returns</h5>

<p>The modified <code>Idf</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# remove duplications in the Idf
idf$unique(class = "ScheduleTypeLimits")

# remove duplications in the schedule types
idf$unique(class = "ScheduleTypeLimits")

# remove duplications in the schedule groups and material class
idf$unique(class = "Material", group = "Schedules")
}

</pre>
</div>


<hr>
<a id="method-Idf-rename"></a>



<h4>Method <code>rename()</code></h4>

<p>Rename existing objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$rename(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Integer vectors of valid object IDs and character vectors
of valid object names in current <code>Idf</code> object. Each element
should be named. Names of input vectors are used as the new
object names</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$rename()&#8288;</code> takes named character vectors of object names and named
integer vectors of object IDs, renames specified objects to names of
input vectors and returns a list of renamed <a href="#topic+IdfObject">IdfObject</a>s. The
returned list will be named using names of modified objects. An error
will be issued if trying to &quot;rename&quot; an object which does not have
name attribute. When renaming an object that is referred by other
objects, corresponding fields that refer to that object's name will
also be changed accordingly.
</p>



<h5>Returns</h5>

<p>A named list of renamed <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$objects(c("on/off", "test 352a"))
idf$rename(on_off = "on/off", test_352a = 51)
}

</pre>
</div>


<hr>
<a id="method-Idf-insert"></a>



<h4>Method <code>insert()</code></h4>

<p>Insert new objects from <a href="#topic+IdfObject">IdfObject</a>s
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$insert(..., .unique = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><a href="#topic+IdfObject">IdfObject</a>s or lists of <a href="#topic+IdfObject">IdfObject</a>s from same version as
current <code>Idf</code> object.</p>
</dd>
<dt><code>.unique</code></dt><dd><p>If there are duplications in input <a href="#topic+IdfObject">IdfObject</a>s or
there is same object in current <code>Idf</code> object, duplications in
input are removed. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$insert()&#8288;</code> takes <a href="#topic+IdfObject">IdfObject</a>s or lists of <a href="#topic+IdfObject">IdfObject</a>s as input,
inserts them into current <code>Idf</code> objects, and returns a list of
inserted <a href="#topic+IdfObject">IdfObject</a>s. The returned list will be named using names of
inserted objects.
</p>
<p><code style="white-space: pre;">&#8288;$insert()&#8288;</code> is quite useful to insert objects from other <code>Idf</code>
objects. However, you cannot insert an <a href="#topic+IdfObject">IdfObject</a> which comes from a
different version than current <code>Idf</code> object.
</p>
<p><code style="white-space: pre;">&#8288;$insert()&#8288;</code> will skip <a href="#topic+IdfObject">IdfObject</a>s that have exactly same fields in
current <code>Idf</code> object. If input <a href="#topic+IdfObject">IdfObject</a> has the same name as one
<a href="#topic+IdfObject">IdfObject</a> in current <code>Idf</code> object but field values are not equal,
an error will be issued if current <a href="#topic+level_checks">validate level</a>
includes conflicted-name checking.
</p>
<p>By default, trailing empty fields that are not required will be
removed and only minimum required fields are kept. You can keep the
trailing empty fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>A named list of inserted <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# insert all material from another IDF
path_idf2 &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5ZoneTDV.idf")
idf2 &lt;- Idf$new(path_idf2)
idf$insert(idf2$Material)

# insert objects from same Idf is equivalent to using Idf$dup()
idf$insert(idf$SizingPeriod_DesignDay)
}

</pre>
</div>


<hr>
<a id="method-Idf-load"></a>



<h4>Method <code>load()</code></h4>

<p>Load new objects from characters or data.frames
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$load(..., .unique = TRUE, .default = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Character vectors or data.frames of object definitions.</p>
</dd>
<dt><code>.unique</code></dt><dd><p>If <code>TRUE</code>, and there are duplications in input
<a href="#topic+IdfObject">IdfObject</a>s or there is same object in current <code>Idf</code> object,
duplications in input are removed. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.default</code></dt><dd><p>If <code>TRUE</code>, default values are filled for those blank
fields if possible. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$load()&#8288;</code> is similar to
<a href="../../eplusr/html/Idf.html#method-insert"><code>$insert()</code></a>,
except it takes directly character vectors or data.frames as
<a href="#topic+IdfObject">IdfObject</a> definitions, insert corresponding objects into current
<code>Idf</code> object and returns a named list of newly added <a href="#topic+IdfObject">IdfObject</a>s.
The returned list will be named using names of added objects. This
makes it easy to create objects using the output from<code style="white-space: pre;">&#8288;$to_string()&#8288;</code>
and <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> method from
<a href="../../eplusr/html/Idd.html#method-to_string"><code>Idd</code></a>,
<a href="../../eplusr/html/IddObject.html#method-to_string"><code>IddObject</code></a>,
also from
<a href="../../eplusr/html/Idf.html#method-to_string"><code>Idf</code></a>,
and
<a href="../../eplusr/html/IdfObject.html#method-to_string"><code>IdfObject</code></a>,
class.
</p>
<p>For object definitions in character vector format, they follow the
same rules as a normal IDF file:
</p>

<ul>
<li><p> Each object starts with a class name and a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Separates each values with a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Ends an object with a semicolon (<code style="white-space: pre;">&#8288;;&#8288;</code>) for the last value.
</p>
</li></ul>

<p>Each character vector can contain:
</p>

<ul>
<li><p> One single object, e.g. <code>c("Building,", "MyBuilding;")</code>, or
&quot;Building, MyBuilding;&quot;.
</p>
</li>
<li><p> Multiple objects, e.g. <code>c("Building, MyBuilding;", "SimulationControl, Yes")</code>.
</p>
</li></ul>

<p>You can also provide an option header to indicate if input objects
are presented in IP units, using <code style="white-space: pre;">&#8288;!-Option ViewInIPunits&#8288;</code>. If this
header does not exist, then all values are treated as in SI units.
</p>
<p>For object definitions in data.frame format, it is highly recommended
to use <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> method in
<a href="../../eplusr/html/Idd.html#method-to_table"><code>Idd</code></a>,
<a href="#topic+Idd">Idd</a>,
<a href="../../eplusr/html/IddObject.html#method-to_table"><code>IddObject</code></a>,
<a href="#topic+IddObject">IddObject</a>,
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>,
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>,
class to create an acceptable data.frame template. A
valid definition requires at least three columns described below.
Note that column order does not matter.
</p>

<ul>
<li> <p><code>class</code>:Character type. Valid class names in the underlying
<a href="#topic+Idd">Idd</a> object.
</p>
</li>
<li> <p><code>index</code>:Integer type. Valid field indices for each class.
</p>
</li>
<li> <p><code>value</code>:Character type or list type. Value for each field
to be added.
</p>

<ul>
<li><p> If character type, usually when <code>string_value</code> is <code>TRUE</code>
in method <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> in
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>
class. Note that
each value should be given as a string even if the corresponding
field is a numeric type.
</p>
</li>
<li><p> If list type, usually when <code>string_value</code> is set to
<code>FALSE</code> in method<code style="white-space: pre;">&#8288;$to_table()&#8288;</code> in
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>
class.
Each value should have the right type as the corresponding field
definition.  Otherwise, errors will be issued if current
<a href="#topic+level_checks">validation level</a> includes invalid-type checking.
</p>
</li></ul>

</li>
<li> <p><code>id</code>: <strong>Optional</strong>. Integer type. If input data.frame includes
multiple object definitions in a same class, values in <code>id</code> column
will be used to distinguish each definition. If <code>id</code> column does
not exists, it assumes that each definition is separated by <code>class</code>
column and will issue an error if there is any duplication in the
<code>index</code> column.
</p>
</li></ul>

<p>Note that <code style="white-space: pre;">&#8288;$load()&#8288;</code> assumes all definitions are from the same version
as current <code>Idf</code> object. If input definition is from different
version, parsing error may occur.
</p>
<p>By default, trailing empty fields that are not required will be
removed and only minimum required fields are kept. You can keep the
trailing empty fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>A named list of loaded <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# load objects from character vectors
idf$load(
    c("Material,",
      "    mat,                     !- Name",
      "    MediumSmooth,            !- Roughness",
      "    0.667,                   !- Thickness {m}",
      "    0.115,                   !- Conductivity {W/m-K}",
      "    513,                     !- Density {kg/m3}",
      "    1381;                    !- Specific Heat {J/kg-K}"),

    "Construction, const, mat;"
)

# load objects from data.frame definitions
dt &lt;- idf$to_table(class = "Material")
dt[field == "Name", value := paste(value, 1)]
dt[field == "Thickness", value := "0.5"]
idf$load(dt)

# by default, duplications are removed
idf$load(idf$to_table(class = "Material"))

# keep empty fields as they are
idf$load("Material, mat1, smooth, 0.5, 0.2, 500, 1000,,, 0.5;", .default = FALSE)

# keep trailing empty fields
idf$load("Material, mat2, smooth, 0.5, 0.2, 500, 1000,,,;",
    .default = FALSE, .empty = TRUE
)
}

</pre>
</div>


<hr>
<a id="method-Idf-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update existing object values from characters or data.frames
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$update(..., .default = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Character vectors or data.frames of object definitions.</p>
</dd>
<dt><code>.default</code></dt><dd><p>If <code>TRUE</code>, default values are filled for those blank
fields if possible. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$update()&#8288;</code> is similar to
<a href="../../eplusr/html/Idf.html#method-set"><code>$set()</code></a>, except
it takes directly character vectors or data.frames as <a href="#topic+IdfObject">IdfObject</a>
definitions, updates new values for fields in objects specified, and
returns a named list of modified <a href="#topic+IdfObject">IdfObject</a>s. The returned list will
be named using names of modified objects. This makes it easy to
update object values using the output from <code style="white-space: pre;">&#8288;$to_string()&#8288;</code> and
<code style="white-space: pre;">&#8288;$to_table&#8288;</code> method from
<a href="../../eplusr/html/Idf.html#method-to_string"><code>Idf</code></a>,
and
<a href="../../eplusr/html/IdfObject.html#method-to_string"><code>IdfObject</code></a>,
class.
</p>
<p>The format of object definitions is similar to <code style="white-space: pre;">&#8288;$load()&#8288;</code>.
</p>
<p>For object definitions in character vector format, object names are
used to locate which objects to update. Objects that have name
attribute should have valid names. This means that there is no way to
update object names using character vector format, but this can be
achieved using data.frame format as it uses object IDs instead of
object names to locate objects. The format of acceptable characters
follows the same rules as a normal IDF file:
</p>

<ul>
<li><p> Each object starts with a class name and a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Separates each values with a comma (<code style="white-space: pre;">&#8288;,&#8288;</code>);
</p>
</li>
<li><p> Ends an object with a semicolon (<code style="white-space: pre;">&#8288;;&#8288;</code>) for the last value.
</p>
</li></ul>

<p>Each character vector can contain:
</p>

<ul>
<li><p> One single object, e.g. <code>c("Building,", "MyBuilding;")</code>, or
&quot;Building, MyBuilding;&quot;.
</p>
</li>
<li><p> Multiple objects, e.g. <code>c("Building, MyBuilding;", "SimulationControl, Yes")</code>.
</p>
</li></ul>

<p>You can also provide an option header to indicate if input objects
are presented in IP units, using <code style="white-space: pre;">&#8288;!-Option ViewInIPunits&#8288;</code>. If this
header does not exist, then all values are treated as in SI units.
</p>
<p>For object definitions in data.frame format, it is highly recommended
to use <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> method in
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>,
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>,
class to create an acceptable data.frame template. A valid definition
requires three columns described below. Note that column order does
not matter.
</p>

<ul>
<li> <p><code>id</code>: Integer type. Valid IDs of objects to update.
</p>
</li>
<li> <p><code>index</code>:Integer type. Valid field indices for each object.
</p>
</li>
<li> <p><code>value</code>:Character type or list type. Value for each field
to be added.
</p>

<ul>
<li><p> If character type, usually when <code>string_value</code> is <code>TRUE</code>
in method <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> in
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>
class. Note that
each value should be given as a string even if the corresponding
field is a numeric type.
</p>
</li>
<li><p> If list type, usually when <code>string_value</code> is set to
<code>FALSE</code> in method <code style="white-space: pre;">&#8288;$to_table()&#8288;</code> in
<a href="../../eplusr/html/Idf.html#method-to_table"><code>Idf</code></a>
and
<a href="../../eplusr/html/IdfObject.html#method-to_table"><code>IdfObject</code></a>
class.
Each value should have the right type as the corresponding field
definition.  Otherwise, errors will be issued if current
<a href="#topic+level_checks">validation level</a> includes invalid-type checking.
</p>
</li></ul>

</li></ul>

<p>Note that <code style="white-space: pre;">&#8288;$update()&#8288;</code> assumes all definitions are from the same version
as current <code>Idf</code> object. If input definition is from different
version, parsing error may occur.
</p>
<p>By default, trailing empty fields that are not required will be
removed and only minimum required fields are kept. You can keep the
trailing empty fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>A named list of updated <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# update objects from string definitions:
str &lt;- idf$to_string("zone one", header = FALSE, format = "new_top")
str[8] &lt;- "2," # Multiplier
idf$update(str)

# update objects from data.frame definitions:
dt &lt;- idf$to_table("zone one")
dt[field == "Multiplier", value := "1"]
idf$update(dt)
}

</pre>
</div>


<hr>
<a id="method-Idf-paste"></a>



<h4>Method <code>paste()</code></h4>

<p>Paste new objects from IDF Editor
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$paste(in_ip = FALSE, ver = NULL, unique = TRUE, empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>in_ip</code></dt><dd><p>Set to <code>TRUE</code> if the IDF file is open with <code>Inch-Pound</code>
view option toggled. Numeric values will automatically
converted to SI units if necessary. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>ver</code></dt><dd><p>The version of IDF file open by IDF Editor, e.g. <code>8.6</code>,
<code>"8.8.0"</code>. If <code>NULL</code>, assume that the file has the same
version as current Idf object. Default: <code>NULL</code>.</p>
</dd>
<dt><code>unique</code></dt><dd><p>If <code>TRUE</code>, and there are duplications in copied objects
from IDF Editor or there is same object in current Idf,
duplications in input are removed. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$paste()&#8288;</code> reads the contents (from clipboard) of copied objects from IDF
Editor (after hitting <code style="white-space: pre;">&#8288;Copy Obj&#8288;</code> button), inserts corresponding
objects into current <code>Idf</code> object and returns a named list of newly
added <a href="#topic+IdfObject">IdfObject</a>s. The returned list will be named using names of
added objects. As IDF Editor is only available on Windows platform,
<code style="white-space: pre;">&#8288;$paste()&#8288;</code> only works on Windows too.
</p>
<p>There is no version data copied to the clipboard when copying objects in
IDF Editor. <code style="white-space: pre;">&#8288;$paste()&#8288;</code> assumes the file open in IDF Editor has the
same version as current <code>Idf</code> object. This may not be always true.
Please check the version before running <code style="white-space: pre;">&#8288;$paste()&#8288;</code>, or explicitly
specify the version of file opened by IDF Editor using <code>ver</code>
parameter. Parsing error may occur if there is a version mismatch.
</p>
<p>By default, trailing empty fields that are not required will be
removed and only minimum required fields are kept. You can keep the
trailing empty fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>



<h5>Returns</h5>

<p>A named list of loaded <a href="#topic+IdfObject">IdfObject</a> objects.
</p>


<hr>
<a id="method-Idf-search_value"></a>



<h4>Method <code>search_value()</code></h4>

<p>Search objects by field values using regular expression
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$search_value(
  pattern,
  class = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern, ignore.case, perl, fixed, useBytes</code></dt><dd><p>All of them are
directly passed to <a href="base.html#topic+grep">base::grepl</a> and
<a href="base.html#topic+grep">base::gsub</a>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of invalid class names in current
<code>Idf</code> object to search for values. If <code>NULL</code>, all classes are
used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$search_value()&#8288;</code> returns a list of <a href="#topic+IdfObject">IdfObject</a>s that contain values
which match the given pattern. If no matched found, <code>NULL</code> is
returned invisibly. The returned list will be named using names of
matched objects.
</p>
<p>Note that during matching, all values are treated as characters,
including numeric values.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search values that contains "floor"
idf$search_value("floor", ignore.case = TRUE)

# search values that contains "floor" in class Construction
idf$search_value("floor", "Construction", ignore.case = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-replace_value"></a>



<h4>Method <code>replace_value()</code></h4>

<p>Replace object field values using regular expression
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$replace_value(
  pattern,
  replacement,
  class = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern, replacement, ignore.case, perl, fixed, useBytes</code></dt><dd><p>All of
them are directly passed to <a href="base.html#topic+grep">base::grepl</a> and
<a href="base.html#topic+grep">base::gsub</a>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of invalid class names in current
<code>Idf</code> object to search for values. If <code>NULL</code>, all classes are
used. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$replace_value()&#8288;</code> returns a list of <a href="#topic+IdfObject">IdfObject</a>s whose values have
been replaced using given pattern. If no matched found, <code>NULL</code> is
returned invisibly. The returned list will be named using names of
matched objects.
</p>
<p>Note that during matching, all values are treated as characters,
including numeric values.
</p>
<p>Modifying object values using regular expression is not recommended.
Consider to use
<a href="../../eplusr/html/Idf.html#method-set"><code>$set()</code></a>
and
<a href="../../eplusr/html/Idf.html#method-update"><code>$update()</code></a>
if possible.
<a href="#topic+level_checks">Validation</a> rules also apply during replacing.
</p>



<h5>Returns</h5>

<p>A named list of <a href="#topic+IdfObject">IdfObject</a> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search values that contains "win" and replace them with "windows"
idf$replace_value("win", "windows")
}

</pre>
</div>


<hr>
<a id="method-Idf-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Check possible object field value errors
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$validate(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$validate()&#8288;</code> checks if there are errors in current <code>Idf</code> object
under specified validation level and returns an <code>IdfValidity</code> object.
<code style="white-space: pre;">&#8288;$validate()&#8288;</code> is useful to help avoid some common errors before
running the model. By default, validation is performed when calling
all methods that modify objects, e.g.
<a href="../../eplusr/html/Idf.html#method-dup"><code>$dup()</code></a>
<a href="../../eplusr/html/Idf.html#method-add"><code>$add()</code></a>,
<a href="../../eplusr/html/Idf.html#method-set"><code>$set()</code></a>,
<a href="../../eplusr/html/Idf.html#method-del"><code>$del()</code></a>,
and etc.
</p>
<p>In total, there are 10 different validate checking components:
</p>

<ul>
<li> <p><code>required_object</code>: Check if required objects are missing in current
<code>Idf</code>.
</p>
</li>
<li> <p><code>unique_object</code>: Check if there are multiple objects in one
unique-object class. An unique-object class means that there should
be at most only one object existing in that class.
</p>
</li>
<li> <p><code>unique_name</code>: Check if all objects in each class have unique names.
</p>
</li>
<li> <p><code>extensible</code>: Check if all fields in an extensible group have
values. An extensible group is a set of fields that should be
treated as a whole, such like the X, Y and Z vertices of a building
surfaces. An extensible group should be added or deleted together.
<code>extensible</code> component checks if there are some, but not all,
fields in an extensible group are empty.
</p>
</li>
<li> <p><code>required_field</code>: Check if all required fields have values.
</p>
</li>
<li> <p><code>auto_field</code>: Check if all fields filled with value <code>"Autosize"</code> and
<code>"Autocalculate"</code> are actual autosizable and autocalculatable
fields or not.
</p>
</li>
<li> <p><code>type</code>: Check if all fields have value types complied with their
definitions, i.e. character, numeric and integer fields should be
filled with corresponding type of values.
</p>
</li>
<li> <p><code>choice</code>: Check if all choice fields are filled with valid choice
values.
</p>
</li>
<li> <p><code>range</code>: Check if all numeric fields have values within prescibed
ranges.
</p>
</li>
<li> <p><code>reference</code>: Check if all fields whose values refer to other fields
are valid.
</p>
</li></ul>

<p>The <code>level</code> argument controls what checkings should be performed.
<code>level</code> here is just a list of 10 element which specify the toggle
status of each component. You can use helper <code><a href="#topic+custom_validate">custom_validate()</a></code> to
get that list and pass it directly to <code>level</code>.
</p>
<p>There are 3 predefined validate level that indicates different
combinations of checking components, i.e. <code>none</code>, <code>draft</code> and
<code>final</code>. Basically, <code>none</code> level just does not perform any
checkings; <code>draft</code> includes 5 components, i.e. <code>auto_field</code>, <code>type</code>,
<code>unique_name</code>, <code>choice</code> and <code>range</code>; and <code>final</code> level includes all
10 components. You can always get what components each level contains
using <code><a href="#topic+level_checks">level_checks()</a></code>. By default, the result from
<code>eplusr_option("validate_level")</code> is passed to <code>level</code>. If not set,
<code>final</code> level is used.
</p>
<p>Underneath, an <code>IdfValidity</code> object which <code style="white-space: pre;">&#8288;$validate()&#8288;</code> returns is a
list of 13 element as shown below. Each element or several elements
represents the results from a single validation checking component.
</p>

<ul>
<li> <p><code>missing_object</code>: Result of <code>required_object</code> checking.
</p>
</li>
<li> <p><code>duplicate_object</code>: Result of <code>unique_object</code> checking.
</p>
</li>
<li> <p><code>conflict_name</code>: Result of <code>unique_name</code> checking.
</p>
</li>
<li> <p><code>incomplete_extensible</code>: Result of <code>extensible</code> checking.
</p>
</li>
<li> <p><code>missing_value</code>: Result of <code>required_field</code> checking.
</p>
</li>
<li> <p><code>invalid_autosize</code>: Result of <code>auto_field</code> checking for invalid
<code>Autosize</code> field values.
</p>
</li>
<li> <p><code>invalid_autocalculate</code>: Result of <code>auto_field</code> checking for
invalid <code>Autocalculate</code> field values.
</p>
</li>
<li> <p><code>invalid_character</code>: Result of <code>type</code> checking for invalid
character field values.
</p>
</li>
<li> <p><code>invalid_numeric</code>: Result of <code>type</code> checking for invalid
numeric field values.
</p>
</li>
<li> <p><code>invalid_integer</code>: Result of <code>type</code> checking for invalid
integer field values.
</p>
</li>
<li> <p><code>invalid_choice</code>: Result of <code>choice</code> checking.
</p>
</li>
<li> <p><code>invalid_range</code>: Result of <code>range</code> checking.
</p>
</li>
<li> <p><code>invalid_reference</code>: Result of <code>reference</code> checking.
</p>
</li></ul>

<p>Except <code>missing_object</code>, which is a character vector of class names
that are missing, all other elements are
<a href="data.table.html#topic+data.table">data.table</a> with 9 columns containing data
of invalid field values:
</p>

<ul>
<li> <p><code>object_id</code>: IDs of objects that contain invalid values
</p>
</li>
<li> <p><code>object_name</code>: names of objects that contain invalid values
</p>
</li>
<li> <p><code>class_id</code>: indexes of classes that invalid objects belong to
</p>
</li>
<li> <p><code>class_name</code>: names of classes that invalid objects belong to
</p>
</li>
<li> <p><code>field_id</code>: indexes (at Idd level) of object fields that are invalid
</p>
</li>
<li> <p><code>field_index</code>: indexes of object fields in corresponding that are invalid
</p>
</li>
<li> <p><code>field_name</code>: names (without units) of object fields that are invalid
</p>
</li>
<li> <p><code>units</code>: SI units of object fields that are invalid
</p>
</li>
<li> <p><code>ip_units</code>: IP units of object fields that are invalid
</p>
</li>
<li> <p><code>type_enum</code>: An integer vector indicates types of invalid fields
</p>
</li>
<li> <p><code>value_id</code>: indexes (at Idf level) of object field values that are invalid
</p>
</li>
<li> <p><code>value_chr</code>: values (converted to characters) of object fields that are
invalid
</p>
</li>
<li> <p><code>value_num</code>: values (converted to numbers in SI units) of object fields
that are invalid
</p>
</li></ul>

<p>Knowing the internal structure of <code>IdfValidity</code>, it is easy to extract
invalid <a href="#topic+IdfObject">IdfObject</a>s you interested in. For example, you can get all IDs of
objects that contain invalid value references using
<code>model$validate()$invalid_reference$object_id</code>. Then using
<a href="../../eplusr/html/Idf.html#method-set"><code>$set()</code></a>
method to correct them.
</p>
<p>Different validate result examples are shown below:
</p>

<ul>
<li><p> No error is found:
</p>
<div class="sourceCode"><pre>v No error found.
</pre></div>
<p>Above result shows that there is no error found after conducting all
validate checks in specified validate level.
</p>
</li>
<li><p> Errors are found:
</p>
<div class="sourceCode"><pre> x [2] Errors found during validation.
=========================================================================

-- [2] Invalid Autocalculate Field --------------------------------------
   Fields below cannot be `autocalculate`:

    Class: &lt;AirTerminal:SingleDuct:VAV:Reheat&gt;
    \- Object [ID:176] &lt;SPACE5-1 VAV Reheat&gt;
       +- 17: AUTOCALCULATE, !- Maximum Flow per Zone Floor Area During Reheat {m3/s-m2}
       \- 18: AUTOCALCULATE; !- Maximum Flow Fraction During Reheat
</pre></div>
<p>Above result shows that after all validate components
performed under current validate level, 2 invalid field values
are found. All of them are in a object named <code style="white-space: pre;">&#8288;SPACE5-1 VAV Reheat&#8288;</code>
with ID <code>176</code>. They are invalid because those two fields do not
have an autocalculatable attribute but are given <code>AUTOCALCULATE</code>
value. Knowing this info, one simple way to fix the
error is to correct those two fields by doing:
</p>
<div class="sourceCode"><pre>idf$set(..176 =
    list(`Maximum Flow per Zone Floor Area During Reheat` = "autosize",
         `Maximum Flow Fraction During Reheat` = "autosize"
    )
)
</pre></div>
</li></ul>




<h5>Returns</h5>

<p>An <code>IdfValidity</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$validate()

# check at predefined validate level
idf$validate("none")
idf$validate("draft")
idf$validate("final")

# custom validate checking components
idf$validate(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-Idf-is_valid"></a>



<h4>Method <code>is_valid()</code></h4>

<p>Check if there is any error in current <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_valid(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid()&#8288;</code> checks if there are errors in current <code>Idf</code> object
under specified validation level and returns <code>TRUE</code> or <code>FALSE</code>
accordingly. For detailed description on validate checking, see
<a href="../../eplusr/html/Idf.html#method-validate"><code>$validate()</code></a>
documentation above.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$is_valid()

# check at predefined validate level
idf$is_valid("none")
idf$is_valid("draft")
idf$is_valid("final")

# custom validate checking components
idf$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-Idf-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Format <code>Idf</code> as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$to_string(
  which = NULL,
  class = NULL,
  comment = TRUE,
  header = TRUE,
  format = eplusr_option("save_format"),
  leading = 4L,
  sep_at = 29L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>Either an integer vector of valid object IDs or a
character vector of valid object names. If <code>NULL</code>, the whole
<code>Idf</code> object is converted. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names. If <code>NULL</code>, all
classed in current <code>Idf</code> object is converted. Default: <code>NULL</code>.</p>
</dd>
<dt><code>comment</code></dt><dd><p>If <code>FALSE</code>, all comments will not be included.
Default: <code>TRUE</code>.</p>
</dd>
<dt><code>header</code></dt><dd><p>If <code>FALSE</code>, the header will not be included. Default:
<code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>Specific format used when formatting. Should be one of
<code>"asis"</code>, <code>"sorted"</code>, <code>"new_top"</code>, and <code>"new_bot"</code>.
</p>

<ul>
<li><p> If <code>"asis"</code>, <code>Idf</code> object will be formatted in the same way as it
was when first read. If <code>Idf</code> object does not contain any format
saving option, which is typically the case when the model was not
saved using eplusr or IDFEditor, <code>"sorted"</code> will be used.
</p>
</li>
<li> <p><code>"sorted"</code>, <code>"new_top"</code> and <code>"new_bot"</code> are the same as the save
options <code>"Sorted"</code>, <code>"Original with New at Top"</code>, and <code>"Original with New at Bottom"</code> in IDFEditor. Default:
<code>eplusr_option("save_format")</code>.
</p>
</li></ul>
</dd>
<dt><code>leading</code></dt><dd><p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</dd>
<dt><code>sep_at</code></dt><dd><p>The character width to separate value string and field
string. Default: <code>29L</code> which is the same as IDF Editor.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_string()&#8288;</code> returns the text format of parts or whole <code>Idf</code>
object.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get text format of the whole Idf
head(idf$to_string())

# get text format of the whole Idf, excluding the header and all comments
head(idf$to_string(comment = FALSE, header = FALSE))

# get text format of all objects in class Material
head(idf$to_string(class = "Material", comment = FALSE, header = FALSE))

# get text format of some objects
head(idf$to_string(c("floor", "zone one")))

# tweak output formatting
head(idf$to_string("floor", leading = 0, sep_at = 0))
}

</pre>
</div>


<hr>
<a id="method-Idf-to_table"></a>



<h4>Method <code>to_table()</code></h4>

<p>Format <code>Idf</code> as a data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$to_table(
  which = NULL,
  class = NULL,
  string_value = TRUE,
  unit = FALSE,
  wide = FALSE,
  align = FALSE,
  all = FALSE,
  group_ext = c("none", "group", "index"),
  force = FALSE,
  init = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>Either an integer vector of valid object IDs or a
character vector of valid object names. If <code>NULL</code>, the whole
<code>Idf</code> object is converted. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names. If <code>NULL</code>, all
classed in current <code>Idf</code> object is converted. Default: <code>NULL</code>.</p>
</dd>
<dt><code>string_value</code></dt><dd><p>If <code>TRUE</code>, all field values are returned as
character. If <code>FALSE</code>, <code>value</code> column in returned
<a href="data.table.html#topic+data.table">data.table</a> is a list column with
each value stored as corresponding type. Note that if the
value of numeric field is set to <code>"Autosize"</code> or
<code>"Autocalculate"</code>, it is left as it is, leaving the returned
type being a string instead of a number. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>Only applicable when <code>string_value</code> is <code>FALSE</code>. If
<code>TRUE</code>, values of numeric fields are assigned with units using
<code><a href="units.html#topic+units">units::set_units()</a></code> if applicable. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>Only applicable if target objects belong to a same class.
If <code>TRUE</code>, a wide table will be returned, i.e. first three
columns are always <code>id</code>, <code>name</code> and <code>class</code>, and then every
field in a separate column. Note that this requires all
objects specified must from the same class.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>align</code></dt><dd><p>If <code>TRUE</code>, all objects in the same class will have the
same field number. The number of fields is the same as the
object that have the most fields among objects specified.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>group_ext</code></dt><dd><p>Should be one of <code>"none"</code>, <code>"group"</code> or <code>"index"</code>.
If not <code>"none"</code>, <code>value</code> column in returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> will be converted into a list.
If <code>"group"</code>, values from extensible fields will be grouped by the
extensible group they belong to. For example, coordinate
values of each vertex in class <code>BuildingSurface:Detailed</code> will
be put into a list. If <code>"index"</code>, values from extensible fields
will be grouped by the extensible field indice they belong to.
For example, coordinate values of all x coordinates will be
put into a list. If <code>"none"</code>, nothing special will be done.
Default: <code>"none"</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>If <code>TRUE</code>, <code>wide</code> can be <code>TRUE</code> even though there are
multiple classes in input. This can result in a data.table
with lots of columns. But may be useful when you know that
target classes have the exact same fields, e.g.
<code>Ceiling:Adiabatic</code> and <code>Floor:Adiabatic</code>. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>init</code></dt><dd><p>If <code>TRUE</code>, a table for new object input will be returned
with all values filled with defaults. In this case, <code>object</code>
input will be ignored. The <code>id</code> column will be filled with
possible new object IDs. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_table()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> that
contains core data of specified objects.
The returned <a href="data.table.html#topic+data.table">data.table</a> has 5 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type if <code>string_value</code> is <code>TRUE</code> or list type if
<code>string_value</code> is <code>FALSE</code> or <code>group_ext</code> is not <code>"none"</code>. Field values.
</p>
</li></ul>

<p>Note that when <code>group_ext</code> is not <code>"none"</code>, <code>index</code> and <code>field</code>
values will not match the original field indices and names. In this
case, <code>index</code> will only indicate the indices of sequences. For
<code>field</code> column, specifically:
</p>

<ul>
<li><p> When <code>group_ext</code> is <code>"group"</code>, each field name in a extensible group
will be abbreviated using <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> with <code>minlength</code> being
<code>10L</code> and all abbreviated names will be separated by <code>|</code> and
combined together. For example, field names in the extensible group
(<code style="white-space: pre;">&#8288;Vertex 1 X-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex 1 Y-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex 1 Z-coordinate&#8288;</code>) in class <code>BuildiBuildingSurface:Detailed</code> will be
merged into one name <code>Vrtx1X-crd|Vrtx1Y-crd|Vrtx1Z-crd</code>.
</p>
</li>
<li><p> When <code>group_ext</code> is <code>"index"</code>, the extensible group indicator in field
names will be removed. Take the same example as above, the
resulting field names will be <code style="white-space: pre;">&#8288;Vertex X-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex Y-coordinate&#8288;</code>, and <code style="white-space: pre;">&#8288;Vertex Z-coordinate&#8288;</code>.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 6 columns (if
<code>wide</code> is <code>FALSE</code>) or at least 6 columns (if <code>wide</code> is <code>TRUE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# extract whole Idf data
idf$to_table()

# extract all data from class Material
idf$to_table(class = "Material")

# extract multiple object data
idf$to_table(c("FLOOR", "ZONE ONE"))

# keep value types and put actual values into a list column
idf$to_table(c("FLOOR", "ZONE ONE"), string_value = FALSE)$value

# add the unit to each value
idf$to_table(c("FLOOR", "ZONE ONE"), string_value = FALSE, unit = TRUE)

# get all possible fields
idf$to_table("ZONE ONE", all = TRUE)

# make sure all objects in same class have the same number of fields
idf$to_table(class = "Construction", align = TRUE)

# get a wide table with string values
idf$to_table(class = "Construction", wide = TRUE)

# get a wide table with actual values
idf$to_table(class = "OtherEquipment", wide = TRUE, string_value = FALSE)

# group extensible by extensible group number
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "group")

# group extensible by extensible group number and convert into a wide table
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "group", wide = TRUE)

# group extensible by extensible field index
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index")

# group extensible by extensible field index and convert into a wide table
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index",
    wide = TRUE, string_value = FALSE, unit = TRUE
)

# create table for new object input
idf$to_table(class = "BuildingSurface:Detailed", init = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-external_deps"></a>



<h4>Method <code>external_deps()</code></h4>

<p>Get external file dependencies that the Idf needs for simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$external_deps(full = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt><dd><p>If <code>TRUE</code>, a <a href="data.table.html#topic+data.table">data.table</a> is
returned giving details about the objects and fields that use those
external file dependencies. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$external_deps()&#8288;</code> returns information of files that are used as
external resources for the simulation.
</p>
<p>Currently, classes below are checked:
</p>

<ul>
<li> <p><code>Schedule:File:Shading</code>
</p>
</li>
<li> <p><code>Schedule:File</code>
</p>
</li>
<li> <p><code>Construction:WindowDataFile</code>
</p>
</li>
<li> <p><code>ExternalInterface:FunctionalMockupUnitImport</code>
</p>
</li>
<li> <p><code>ExternalInterface:FunctionalMockupUnitImport:From:Variable</code>
</p>
</li>
<li> <p><code>ExternalInterface:FunctionalMockupUnitImport:To:Schedule</code>
</p>
</li>
<li> <p><code>ExternalInterface:FunctionalMockupUnitImport:To:Actuator</code>
</p>
</li>
<li> <p><code>ExternalInterface:FunctionalMockupUnitImport:To:Variable</code>
</p>
</li>
<li> <p><code>Table:IndependentVariable</code>
</p>
</li>
<li> <p><code>Table:Lookup</code>
</p>
</li></ul>

<p>Note that, for <code>ExternalInterface:FunctionalMockupUnitImport</code> and
<code style="white-space: pre;">&#8288;ExternalInterface:FunctionalMockupUnitImport:*&#8288;</code>, resources of FMU
will also be extracted.
</p>



<h5>Returns</h5>

<p>When <code>full</code> is <code>FALSE</code>, which is the default, a character vector.
</p>
<p>When <code>full</code> is <code>TRUE</code>, a <a href="data.table.html#topic+data.table">data.table</a> of 8
columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type. Field values.
</p>
</li>
<li> <p><code>path</code>: Character type. Full file paths.
</p>
</li>
<li> <p><code>exist</code>: Logical type. <code>TRUE</code> if file exists, <code>FALSE</code> otherwise.
</p>
</li></ul>

<p>If there are any FMUs using external file resources, the returned
data.table will have an attribute named <code>extra</code> which is a list
giving the FMU name and external file resources it use.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$external_deps()
}

</pre>
</div>


<hr>
<a id="method-Idf-is_unsaved"></a>



<h4>Method <code>is_unsaved()</code></h4>

<p>Check if there are unsaved changes in current <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$is_unsaved()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_unsaved()&#8288;</code> returns <code>TRUE</code> if there are modifications on the
model since it was read or since last time it was saved, and returns
<code>FALSE</code> otherwise.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$is_unsaved()
}

</pre>
</div>


<hr>
<a id="method-Idf-save"></a>



<h4>Method <code>save()</code></h4>

<p>Save <code>Idf</code> object as an IDF file
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$save(
  path = NULL,
  format = eplusr_option("save_format"),
  overwrite = FALSE,
  copy_external = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>A path where to save the IDF file. If <code>NULL</code>, the path of
the <code>Idf</code> itself, i.e.
<a href="../../eplusr/html/Idf.html#method-path"><code>$path()</code></a>,
will be used.</p>
</dd>
<dt><code>format</code></dt><dd><p>Specific format used when formatting. Should be one of
<code>"asis"</code>, <code>"sorted"</code>, <code>"new_top"</code>, and <code>"new_bot"</code>.
</p>

<ul>
<li><p> If <code>"asis"</code>, <code>Idf</code> object will be formatted in the same way as it
was when first read. If <code>Idf</code> object does not contain any format
saving option, which is typically the case when the model was not
saved using eplusr or IDFEditor, <code>"sorted"</code> will be used.
</p>
</li>
<li> <p><code>"sorted"</code>, <code>"new_top"</code> and <code>"new_bot"</code> are the same as the save
options <code>"Sorted"</code>, <code>"Original with New at Top"</code>, and <code>"Original with New at Bottom"</code> in IDFEditor. Default:
<code>eplusr_option("save_format")</code>.
</p>
</li></ul>
</dd>
<dt><code>overwrite</code></dt><dd><p>Whether to overwrite the file if it already exists.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>If <code>TRUE</code>, the external files extracted from
<code style="white-space: pre;">&#8288;$external_deps()&#8288;</code> will also be copied into the same directory.
The values of file paths in the <code>Idf</code> will be changed into
relative path automatically. This makes it possible to create
fully reproducible simulation conditions. If <code>FALSE</code>, the
values of those fields that reference external file paths will
be updated to absolute paths. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$save()&#8288;</code> formats current <code>Idf</code> object, saves it as an IDF file and
returns the path of saved file invisibly. After saving,
<a href="../../eplusr/html/Idf.html#method-path"><code>$path()</code></a>
will also be updated to return the path of saved file.
</p>



<h5>Returns</h5>

<p>A length-one character vector, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# save Idf as a new file
idf$save(tempfile(fileext = ".idf"))

# save and overwrite current file
idf$save(overwrite = TRUE)

# save the model with newly created and modified objects at the top
idf$save(overwrite = TRUE, format = "new_top")

# save the model to a new file and copy all external csv files used in
# "Schedule:File" class into the same folder
idf$save(path = file.path(tempdir(), "test1.idf"), copy_external = TRUE)
}

</pre>
</div>


<hr>
<a id="method-Idf-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run simulation using EnergyPlus
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$run(
  weather,
  dir = NULL,
  wait = TRUE,
  force = FALSE,
  copy_external = FALSE,
  echo = wait
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weather</code></dt><dd><p>A path to an <code>.epw</code> file or an <a href="#topic+Epw">Epw</a> object. <code>weather</code>
can also be <code>NULL</code> which will force design-day-only
simulation. Note that this needs at least one
<code>Sizing:DesignDay</code> object exists in the <code>Idf</code>.</p>
</dd>
<dt><code>dir</code></dt><dd><p>The directory to save the simulation results. If <code>NULL</code>,
the folder of <code>Idf</code> path will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>wait</code></dt><dd><p>Whether to wait until the simulation completes and print
the standard output and error of EnergyPlus. If <code>FALSE</code>, the
simulation will run in the background. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>Only applicable when the last simulation runs with
<code>wait</code> equals to <code>FALSE</code> and is still running. If <code>TRUE</code>,
current running job is forced to stop and a new one will
start. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>If <code>TRUE</code>, the external files that current <code>Idf</code>
object depends on will also be copied into the simulation
output directory. The values of file paths in the Idf will be
changed automatically. This ensures that the output directory
will have all files needed for the model to run. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>echo</code></dt><dd><p>Only applicable when <code>wait</code> is <code>TRUE</code>. Whether to show
standard output and error from EnergyPlus. Default: same as
<code>wait</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$run()&#8288;</code> calls corresponding version of EnergyPlus to run the current
<code>Idf</code> object together with specified weather. The model and the
weather used will be copied into the output directory. An <a href="#topic+EplusJob">EplusJob</a>
object is returned which provides detailed info of the simulation and
methods to collect simulation results. Please see <a href="#topic+EplusJob">EplusJob</a> for
details.
</p>
<p>eplusr uses the EnergyPlus command line interface which was
introduced since EnergyPlus 8.3.0. So <code style="white-space: pre;">&#8288;$run()&#8288;</code> only supports models
with version no lower than 8.3.0.
</p>
<p>When calling <code style="white-space: pre;">&#8288;$run()&#8288;</code>, eplusr will do steps below to make sure the
output collecting methods work as expected. Please note that this may
result in an IDF file that may not be exactly same as your current
<code>Idf</code> object.
</p>

<ul>
<li><p> eplusr uses EnergyPlus SQL output for extracting simulation
results. In order to do so, an object in <code>Output:SQLite</code> class with
<code style="white-space: pre;">&#8288;Option Type&#8288;</code> value being <code>SimpleAndTabular</code> will be automatically
created if it does not exists.
</p>
</li>
<li><p> In order to make sure <code>.rdd</code> (Report Data Dictionary) and <code>.mdd</code>
(Meter Data Dictionary) files are created during simulation, an
object in <code>Output:VariableDictionary</code> class with <code style="white-space: pre;">&#8288;Key Field&#8288;</code> value
being <code>IDF</code> will be automatically created if it does not exists.
</p>
</li></ul>




<h5>Returns</h5>

<p>An <a href="#topic+EplusJob">EplusJob</a> object of current simulation.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf &lt;- Idf$new(path_idf)
# save the model to tempdir()
idf$save(file.path(tempdir(), "test_run.idf"))

# use the first epw file in "WeatherData" folder in EnergyPlus v8.8
# installation path
epw &lt;- list.files(file.path(eplus_config(8.8)$dir, "WeatherData"),
    pattern = "\\.epw$", full.names = TRUE)[1]

# if `dir` is NULL, the directory of IDF file will be used as simulation
# output directory
job &lt;- idf$run(epw, dir = NULL)

# run simulation in the background
idf$run(epw, dir = tempdir(), wait = FALSE)

# copy all external files into the directory run simulation
idf$run(epw, dir = tempdir(), copy_external = TRUE)

# check for simulation errors
job$errors()

# get simulation status
job$status()

# get output directory
job$output_dir()

# re-run the simulation
job$run()

# get simulation results
job$report_data()
}

</pre>
</div>


<hr>
<a id="method-Idf-last_job"></a>



<h4>Method <code>last_job()</code></h4>

<p>Get the last simulation job
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$last_job()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$last_job()&#8288;</code> returns the last <a href="#topic+EplusJob">EplusJob</a> object that was created
using
<a href="../../eplusr/html/Idf.html#method-run"><code>$run()</code></a>. If the
<code>Idf</code> hasn't been run yet, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p><code>NULL</code> or an <a href="#topic+EplusJob">EplusJob</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$last_job()
}

</pre>
</div>


<hr>
<a id="method-Idf-geometry"></a>



<h4>Method <code>geometry()</code></h4>

<p>Extract <code>Idf</code> geometries
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$geometry()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$geometry()&#8288;</code> extracts all geometry objects into an <a href="#topic+IdfGeometry">IdfGeometry</a>
object. <code>IdfGeometry</code> is an abstraction of a collection of geometry
in an <a href="#topic+Idf">Idf</a>. It provides more detail methods to query geometry
properties, update geometry vertices and visualize geometry in 3D
using the <a href="https://cran.r-project.org/package=rgl">rgl</a> package.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IdfGeometry">IdfGeometry</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$geometry()
}

</pre>
</div>


<hr>
<a id="method-Idf-view"></a>



<h4>Method <code>view()</code></h4>

<p>View 3D <code>Idf</code> geometry
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$view(
  new = FALSE,
  render_by = "surface_type",
  wireframe = TRUE,
  x_ray = FALSE,
  axis = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new</code></dt><dd><p>If <code>TRUE</code>, a new rgl window will be open using
<code><a href="rgl.html#topic+open3d">rgl::open3d()</a></code>. If <code>FALSE</code>, existing rgl window will be
reused if possible. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>render_by</code></dt><dd><p>A single string specifying the way of rendering the
geometry. Possible values are:
</p>

<ul>
<li> <p><code>"surface_type"</code>: Default. Render the model by surface type
model. Walls, roofs, windows, doors, floors, and shading
surfaces will have unique colors.
</p>
</li>
<li> <p><code>"boundary"</code>: Render the model by outside boundary condition.
Only surfaces that have boundary conditions will be rendered
with a color. All other surfaces will be white.
</p>
</li>
<li> <p><code>"construction"</code>: Render the model by surface constructions.
</p>
</li>
<li> <p><code>"zone"</code>: Render the model by zones assigned.
</p>
</li>
<li> <p><code>"normal"</code>: Render the model by surface normal. The outside
face of a heat transfer face will be rendered as white and the
inside face will be rendered as red.
</p>
</li></ul>
</dd>
<dt><code>wireframe</code></dt><dd><p>If <code>TRUE</code>, the wireframe of each surface will be
shown. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>x_ray</code></dt><dd><p>If <code>TRUE</code>, all surfaces will be rendered translucently.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>axis</code></dt><dd><p>If <code>TRUE</code>, the X, Y and Z axes will be drawn at the
global origin. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$view()&#8288;</code> uses the <a href="https://cran.r-project.org/package=rgl">rgl</a>
package to visualize the IDF geometry in 3D in a similar way as
<a href="https://openstudio.net/">OpenStudio</a>.
</p>
<p><code style="white-space: pre;">&#8288;$view()&#8288;</code> returns an <a href="#topic+IdfViewer">IdfViewer</a> object which can be used to further
tweak the viewer scene.
</p>
<p>In the rgl window, you can control the view using your mouse:
</p>

<ul>
<li><p> Left button: Trackball
</p>
</li>
<li><p> Right button: Pan
</p>
</li>
<li><p> Middle button: Field-of-view (FOV). '0' means orthographic
projection.
</p>
</li>
<li><p> Wheel: Zoom
</p>
</li></ul>




<h5>Returns</h5>

<p>An <a href="#topic+IdfViewer">IdfViewer</a> object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$view()
idf$view(render_by = "zone")
idf$view(render_by = "construction")
}

</pre>
</div>


<hr>
<a id="method-Idf-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>Idf</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$print(zoom = "class", order = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>zoom</code></dt><dd><p>Control how detailed of the Idf object should be printed.
Should be one of <code>"group"</code>, <code>"class"</code>, <code>"object"</code> and
<code>"field"</code>. Default: <code>"group"</code>.
</p>

<ul>
<li> <p><code>"group"</code>: all group names current existing are shown with prevailing
square bracket showing how many <strong>C</strong>lasses existing in that group.
</p>
</li>
<li> <p><code>"class"</code>: all class names are shown with prevailing square bracket
showing how many <strong>O</strong>bjects existing in that class, together with
parent group name of each class.
</p>
</li>
<li> <p><code>"object"</code>: all object IDs and names are shown, together with parent
class name of each object.
</p>
</li>
<li> <p><code>"field"</code>: all object IDs and names, field names and values are shown,
together with parent class name of each object.
</p>
</li></ul>
</dd>
<dt><code>order</code></dt><dd><p>Only applicable when <code>zoom</code> is <code>"object"</code> or <code>"field"</code>.
If <code>TRUE</code>, objects are shown as the same order in the IDF. If
<code>FALSE</code>, objects are grouped and ordered by classes. Default:
<code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the <code>Idf</code> object according to different detail
level specified using the <code>zoom</code> argument.
</p>
<p>With the default <code>zoom</code> level <code>object</code>, contents of the <code>Idf</code> object
is printed in a similar style as you see in IDF Editor, with
additional heading lines showing <code>Path</code>, <code>Version</code> of the <code>Idf</code>
object. Class names of objects are ordered by group and the number of
objects in classes are shown in square bracket.
</p>



<h5>Returns</h5>

<p>The <code>Idf</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$print("group")
idf$print("class")
idf$print("object")
idf$print("field")

# order objects by there classes
idf$print("object", order = FALSE)
idf$print("field", order = FALSE)
}

</pre>
</div>


<hr>
<a id="method-Idf-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Idf$clone(deep = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+IdfObject">IdfObject</a> class for a single object in an IDF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Idf$new`
## ------------------------------------------------

## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# If neither EnergyPlus v8.8 nor Idd v8.8 was found, error will
# occur. If Idd v8.8 is found, it will be used automatically.
idf &lt;- Idf$new(path_idf)

# argument `idd` can be specified explicitly using `use_idd()`
idf &lt;- Idf$new(path_idf, idd = use_idd(8.8))

# you can set `download` arugment to "auto" in `use_idd()` if you
# want to automatically download corresponding IDD file when
# necessary
idf &lt;- Idf$new(path_idf, use_idd(8.8, download = "auto"))

# Besides use a path to an IDF file, you can also provide IDF in literal
# string format
string_idf &lt;-
    "
    Version, 8.8;
    Building,
        Building;                !- Name
    "

Idf$new(string_idf, use_idd(8.8, download = "auto"))

## End(Not run)


## ------------------------------------------------
## Method `Idf$version`
## ------------------------------------------------

## Not run: 
# get version
idf$version()

## End(Not run)


## ------------------------------------------------
## Method `Idf$path`
## ------------------------------------------------

## Not run: 
# get path
idf$path()

# return `NULL` if Idf is not created from a file
Idf$new("Version, 8.8;\n")$path()

## End(Not run)


## ------------------------------------------------
## Method `Idf$group_name`
## ------------------------------------------------

## Not run: 
# get names of all groups Idf contains
idf$group_name()

# get group name of each object in Idf
idf$group_name(sorted = FALSE)

# get names of all available groups in underlying Idd
idf$group_name(all = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$class_name`
## ------------------------------------------------

## Not run: 
# get names of all classes in Idf
idf$class_name()

# get names of all classes grouped by group names in Idf
idf$class_name(by_group = TRUE)

# get class name of each object in Idf
idf$class_name(sorted = FALSE)

# get names of all available classes in underlying Idd
idf$class_name(all = TRUE)

# get names of all available classes grouped by group names in
# underlying Idd
idf$class_name(all = TRUE, by_group = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_valid_group`
## ------------------------------------------------

## Not run: 
# check if input is a valid group name in current Idf
idf$is_valid_group(c("Schedules", "Compliance Objects"))

# check if input is a valid group name in underlying Idd
idf$is_valid_group(c("Schedules", "Compliance Objects"), all = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_valid_class`
## ------------------------------------------------

## Not run: 
# check if input is a valid class name in current Idf
idf$is_valid_class(c("Building", "ShadowCalculation"))

# check if input is a valid class name in underlying Idd
idf$is_valid_class(c("Building", "ShadowCalculation"), all = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$definition`
## ------------------------------------------------

## Not run: 
# get the IddObject object for specified class
idf$definition("Version")

## End(Not run)


## ------------------------------------------------
## Method `Idf$object_id`
## ------------------------------------------------

## Not run: 
# get IDs of all objects in current Idf object
idf$object_id()

# get IDs of all objects in current Idf object, and merge them into a
# single integer vector
idf$object_id(simplify = TRUE)

# get IDs of objects in class Version and Zone
idf$object_id(c("Version", "Zone"))

# get IDs of objects in class Version and Zone, and merge them into a
# single integer vector
idf$object_id(c("Version", "Zone"), simplify = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$object_name`
## ------------------------------------------------

## Not run: 
# get names of all objects in current Idf object
idf$object_name()

# get names of all objects in current Idf object, and merge them into
# a single character vector
idf$object_name(simplify = TRUE)

# get names of objects in class Version and Zone
idf$object_name(c("Version", "Zone"))

# get names of objects in class Version and Zone, and merge them into
# a single character vector
idf$object_name(c("Version", "Zone"), simplify = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$object_num`
## ------------------------------------------------

## Not run: 
# get total number of objects
idf$object_num()

# get number of objects in class Zone and Schedule:Compact
idf$object_num(c("Zone", "Schedule:Compact"))

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_valid_id`
## ------------------------------------------------

## Not run: 
idf$is_valid_id(c(51, 1000))

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_valid_name`
## ------------------------------------------------

## Not run: 
idf$is_valid_name(c("Simple One Zone (Wireframe DXF)", "ZONE ONE", "a"))

# name matching is case-insensitive
idf$is_valid_name(c("simple one zone (wireframe dxf)", "zone one", "a"))

## End(Not run)


## ------------------------------------------------
## Method `Idf$object`
## ------------------------------------------------

## Not run: 
# get an object whose ID is 3
idf$object(3)

# get an object whose name is "simple one zone (wireframe dxf)"
# NOTE: object name matching is case-insensitive
idf$object("simple one zone (wireframe dxf)")

## End(Not run)


## ------------------------------------------------
## Method `Idf$objects`
## ------------------------------------------------

## Not run: 
# get objects whose IDs are 3 and 10
idf$objects(c(3,10))

# get objects whose names are "Simple One Zone (Wireframe DXF)" and "ZONE ONE"
# NOTE: object name matching is case-insensitive
idf$objects(c("Simple One Zone (Wireframe DXF)", "zone one"))

## End(Not run)


## ------------------------------------------------
## Method `Idf$object_unique`
## ------------------------------------------------

## Not run: 
# get the SimulationColtrol object
idf$object_unique("SimulationControl")

# S3 "[[" and "$" can also be used
idf$SimulationControl
idf[["SimulationControl"]]

## End(Not run)


## ------------------------------------------------
## Method `Idf$objects_in_class`
## ------------------------------------------------

## Not run: 
# get all objects in Zone class
idf$objects_in_class("Zone")

# S3 "[[" and "$" can also be used
idf$Zone
idf[["Zone"]]

## End(Not run)


## ------------------------------------------------
## Method `Idf$objects_in_group`
## ------------------------------------------------

## Not run: 
# get all objects in Schedules group
idf$objects_in_group("Schedules")

## End(Not run)


## ------------------------------------------------
## Method `Idf$object_relation`
## ------------------------------------------------

## Not run: 
# check each layer's reference of a construction named FLOOR
idf$object_relation("floor", "ref_to")

# check where is this construction being used
idf$object_relation("floor", "ref_by")

## End(Not run)


## ------------------------------------------------
## Method `Idf$objects_in_relation`
## ------------------------------------------------

## Not run: 
# get a construction named FLOOR and all materials it uses
idf$objects_in_relation("floor", "ref_to")

# get a construction named FLOOR and all surfaces that uses it
idf$objects_in_relation("floor", "ref_by", class = "BuildingSurface:Detailed")

## End(Not run)


## ------------------------------------------------
## Method `Idf$search_object`
## ------------------------------------------------

## Not run: 
# get all objects whose names contains "floor"
idf$search_object("floor", ignore.case = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$dup`
## ------------------------------------------------

## Not run: 
# duplicate an object named "FLOOR"
idf$dup("floor") # New object name 'FLOOR_1' is auto-generated

# duplicate that object again by specifing object ID
idf$dup(16) # New object name 'FLOOR_2' is auto-generated

# duplicate that object two times and giving new names
idf$dup(new_floor = "floor", new_floor2 = 16)

# duplicate that object multiple times using variable inputs
floors_1 &lt;- c(new_floor3 = "floor", new_floor4 = "floor")
floors_2 &lt;- setNames(rep(16, 5), paste0("flr", 1:5))
idf$dup(floors_1, floors_2)

## End(Not run)


## ------------------------------------------------
## Method `Idf$add`
## ------------------------------------------------

## Not run: 
# add a new Building object with all default values
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = .())

# add a new Building object with all default values and comments
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = .(.comment = c("this is", "a new building")))

# add a new RunPeriod object with all possible fields
empty &lt;- empty_idf(8.8) # create an empty Idf
empty$add(Building = list(), RunPeriod = list("rp", 1, 1, 1, 31), .all = TRUE)

# add objects using variable inputs
empty &lt;- empty_idf(8.8) # create an empty Idf
objs1 &lt;- list(Schedule_Constant = list("const"), Building = list())
rp &lt;- list(RunPeriod = list("rp", 2, 1, 2, 28))
empty$add(objs1, rp)

## End(Not run)


## ------------------------------------------------
## Method `Idf$set`
## ------------------------------------------------

## Not run: 
# modify an object by name (case-insensitive)
idf$set(r13layer = list(roughness = "smooth"))

# modify an object by ID
idf$set(..12 = list(roughness = "rough"))

# overwrite existing object comments
idf$set(r13layer = list(.comment = c("New comment")))

# assign default values to fields
idf$set(r13layer = list(solar_absorptance = NULL), .default = TRUE)

# set field values to blanks
idf$set(r13layer = list(solar_absorptance = NULL), .default = FALSE)

# set field values to blank and delete trailing fields
idf$set(r13layer = list(visible_absorptance = NULL), .default = FALSE)

# set field values to blank and keep blank fields
idf$set(r13layer = list(visible_absorptance = NULL), .default = FALSE, .empty = TRUE)

# set all fields in one class
idf$set(Material_NoMass := list(visible_absorptance = 0.9))

# set multiple objects in one class
idf$set(.("r13layer", "r31layer") := list(solar_absorptance = 0.8))
# above is equivalent to
idf$set(r13layer = list(solar_absorptance = 0.8),
        r31layer = list(solar_absorptance = 0.8)
)

# use variable input
sets &lt;- list(r13layer = list(roughness = "smooth"))
idf$set(sets)

## End(Not run)


## ------------------------------------------------
## Method `Idf$del`
## ------------------------------------------------

## Not run: 
# delete objects using names
idf$object("Fraction") # ScheduleTypeLimits
idf$del("Fraction")

# delete objects using IDs
idf$objects(c(39, 40)) # Output:Variable
idf$del(39, 40)

# cannot delete objects that are referred by others
level_checks()$reference # reference-checking is enable by default
idf$del("r13layer") # error

# force to delete objects even thay are referred by others
idf$del("r13layer", .force = TRUE)

# delete objects and also objects that refer to them
idf$del("r31layer", .ref_by = TRUE) # Construction 'ROOF31' will be kept

# delete objects and also objects that they refer to
idf$del("extlights", .ref_to = TRUE) # Schedule 'AlwaysOn' will be kept

# delete objects and also other objects that refer to them recursively
idf$del("roof31", .ref_by = TRUE, .recursive = TRUE)

# delete objects using variable inputs
ids &lt;- idf$object_id("Output:Variable", simplify = TRUE)
idf$del(ids)

## End(Not run)


## ------------------------------------------------
## Method `Idf$purge`
## ------------------------------------------------

## Not run: 
# purge unused "Fraction" schedule type
idf$purge("on/off") # ScheduleTypeLimits

# purge all unused schedule types
idf$purge(class = "ScheduleTypeLimits")

# purge all unused schedule related objects
idf$purge(group = "Schedules")

## End(Not run)


## ------------------------------------------------
## Method `Idf$duplicated`
## ------------------------------------------------

## Not run: 
# check if there are any duplications in the Idf
idf$duplicated(class = "ScheduleTypeLimits")

# check if there are any duplications in the schedule types
idf$duplicated(class = "ScheduleTypeLimits")

# check if there are any duplications in the schedule groups and
# material class
idf$duplicated(class = "Material", group = "Schedules")

## End(Not run)


## ------------------------------------------------
## Method `Idf$unique`
## ------------------------------------------------

## Not run: 
# remove duplications in the Idf
idf$unique(class = "ScheduleTypeLimits")

# remove duplications in the schedule types
idf$unique(class = "ScheduleTypeLimits")

# remove duplications in the schedule groups and material class
idf$unique(class = "Material", group = "Schedules")

## End(Not run)


## ------------------------------------------------
## Method `Idf$rename`
## ------------------------------------------------

## Not run: 
idf$objects(c("on/off", "test 352a"))
idf$rename(on_off = "on/off", test_352a = 51)

## End(Not run)


## ------------------------------------------------
## Method `Idf$insert`
## ------------------------------------------------

## Not run: 
# insert all material from another IDF
path_idf2 &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5ZoneTDV.idf")
idf2 &lt;- Idf$new(path_idf2)
idf$insert(idf2$Material)

# insert objects from same Idf is equivalent to using Idf$dup()
idf$insert(idf$SizingPeriod_DesignDay)

## End(Not run)


## ------------------------------------------------
## Method `Idf$load`
## ------------------------------------------------

## Not run: 
# load objects from character vectors
idf$load(
    c("Material,",
      "    mat,                     !- Name",
      "    MediumSmooth,            !- Roughness",
      "    0.667,                   !- Thickness {m}",
      "    0.115,                   !- Conductivity {W/m-K}",
      "    513,                     !- Density {kg/m3}",
      "    1381;                    !- Specific Heat {J/kg-K}"),

    "Construction, const, mat;"
)

# load objects from data.frame definitions
dt &lt;- idf$to_table(class = "Material")
dt[field == "Name", value := paste(value, 1)]
dt[field == "Thickness", value := "0.5"]
idf$load(dt)

# by default, duplications are removed
idf$load(idf$to_table(class = "Material"))

# keep empty fields as they are
idf$load("Material, mat1, smooth, 0.5, 0.2, 500, 1000,,, 0.5;", .default = FALSE)

# keep trailing empty fields
idf$load("Material, mat2, smooth, 0.5, 0.2, 500, 1000,,,;",
    .default = FALSE, .empty = TRUE
)

## End(Not run)


## ------------------------------------------------
## Method `Idf$update`
## ------------------------------------------------

## Not run: 
# update objects from string definitions:
str &lt;- idf$to_string("zone one", header = FALSE, format = "new_top")
str[8] &lt;- "2," # Multiplier
idf$update(str)

# update objects from data.frame definitions:
dt &lt;- idf$to_table("zone one")
dt[field == "Multiplier", value := "1"]
idf$update(dt)

## End(Not run)


## ------------------------------------------------
## Method `Idf$search_value`
## ------------------------------------------------

## Not run: 
# search values that contains "floor"
idf$search_value("floor", ignore.case = TRUE)

# search values that contains "floor" in class Construction
idf$search_value("floor", "Construction", ignore.case = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$replace_value`
## ------------------------------------------------

## Not run: 
# search values that contains "win" and replace them with "windows"
idf$replace_value("win", "windows")

## End(Not run)


## ------------------------------------------------
## Method `Idf$validate`
## ------------------------------------------------

## Not run: 
idf$validate()

# check at predefined validate level
idf$validate("none")
idf$validate("draft")
idf$validate("final")

# custom validate checking components
idf$validate(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_valid`
## ------------------------------------------------

## Not run: 
idf$is_valid()

# check at predefined validate level
idf$is_valid("none")
idf$is_valid("draft")
idf$is_valid("final")

# custom validate checking components
idf$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `Idf$to_string`
## ------------------------------------------------

## Not run: 
# get text format of the whole Idf
head(idf$to_string())

# get text format of the whole Idf, excluding the header and all comments
head(idf$to_string(comment = FALSE, header = FALSE))

# get text format of all objects in class Material
head(idf$to_string(class = "Material", comment = FALSE, header = FALSE))

# get text format of some objects
head(idf$to_string(c("floor", "zone one")))

# tweak output formatting
head(idf$to_string("floor", leading = 0, sep_at = 0))

## End(Not run)


## ------------------------------------------------
## Method `Idf$to_table`
## ------------------------------------------------

## Not run: 
# extract whole Idf data
idf$to_table()

# extract all data from class Material
idf$to_table(class = "Material")

# extract multiple object data
idf$to_table(c("FLOOR", "ZONE ONE"))

# keep value types and put actual values into a list column
idf$to_table(c("FLOOR", "ZONE ONE"), string_value = FALSE)$value

# add the unit to each value
idf$to_table(c("FLOOR", "ZONE ONE"), string_value = FALSE, unit = TRUE)

# get all possible fields
idf$to_table("ZONE ONE", all = TRUE)

# make sure all objects in same class have the same number of fields
idf$to_table(class = "Construction", align = TRUE)

# get a wide table with string values
idf$to_table(class = "Construction", wide = TRUE)

# get a wide table with actual values
idf$to_table(class = "OtherEquipment", wide = TRUE, string_value = FALSE)

# group extensible by extensible group number
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "group")

# group extensible by extensible group number and convert into a wide table
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "group", wide = TRUE)

# group extensible by extensible field index
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index")

# group extensible by extensible field index and convert into a wide table
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
idf$to_table(class = "BuildingSurface:Detailed", group_ext = "index",
    wide = TRUE, string_value = FALSE, unit = TRUE
)

# create table for new object input
idf$to_table(class = "BuildingSurface:Detailed", init = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$external_deps`
## ------------------------------------------------

## Not run: 
idf$external_deps()

## End(Not run)


## ------------------------------------------------
## Method `Idf$is_unsaved`
## ------------------------------------------------

## Not run: 
idf$is_unsaved()

## End(Not run)


## ------------------------------------------------
## Method `Idf$save`
## ------------------------------------------------

## Not run: 
# save Idf as a new file
idf$save(tempfile(fileext = ".idf"))

# save and overwrite current file
idf$save(overwrite = TRUE)

# save the model with newly created and modified objects at the top
idf$save(overwrite = TRUE, format = "new_top")

# save the model to a new file and copy all external csv files used in
# "Schedule:File" class into the same folder
idf$save(path = file.path(tempdir(), "test1.idf"), copy_external = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `Idf$run`
## ------------------------------------------------

## Not run: 
idf &lt;- Idf$new(path_idf)
# save the model to tempdir()
idf$save(file.path(tempdir(), "test_run.idf"))

# use the first epw file in "WeatherData" folder in EnergyPlus v8.8
# installation path
epw &lt;- list.files(file.path(eplus_config(8.8)$dir, "WeatherData"),
    pattern = "\\.epw$", full.names = TRUE)[1]

# if `dir` is NULL, the directory of IDF file will be used as simulation
# output directory
job &lt;- idf$run(epw, dir = NULL)

# run simulation in the background
idf$run(epw, dir = tempdir(), wait = FALSE)

# copy all external files into the directory run simulation
idf$run(epw, dir = tempdir(), copy_external = TRUE)

# check for simulation errors
job$errors()

# get simulation status
job$status()

# get output directory
job$output_dir()

# re-run the simulation
job$run()

# get simulation results
job$report_data()

## End(Not run)


## ------------------------------------------------
## Method `Idf$last_job`
## ------------------------------------------------

## Not run: 
idf$last_job()

## End(Not run)


## ------------------------------------------------
## Method `Idf$geometry`
## ------------------------------------------------

## Not run: 
idf$geometry()

## End(Not run)


## ------------------------------------------------
## Method `Idf$view`
## ------------------------------------------------

## Not run: 
idf$view()
idf$view(render_by = "zone")
idf$view(render_by = "construction")

## End(Not run)


## ------------------------------------------------
## Method `Idf$print`
## ------------------------------------------------

## Not run: 
idf$print("group")
idf$print("class")
idf$print("object")
idf$print("field")

# order objects by there classes
idf$print("object", order = FALSE)
idf$print("field", order = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='idf_object'>Create an <code>IdfObject</code> object.</h2><span id='topic+idf_object'></span>

<h3>Description</h3>

<p><code>idf_object()</code> takes a parent <code>Idf</code> object, an object name or class name, and
returns a corresponding <a href="#topic+IdfObject">IdfObject</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idf_object(parent, object = NULL, class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idf_object_+3A_parent">parent</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object.</p>
</td></tr>
<tr><td><code id="idf_object_+3A_object">object</code></td>
<td>
<p>A valid object ID (an integer) or name (a string). If <code>NULL</code>
and <code>class</code> is not <code>NULL</code>, an empty <a href="#topic+IdfObject">IdfObject</a> is created with all fields
fill with default values if possible. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="idf_object_+3A_class">class</code></td>
<td>
<p>A valid class name (a string). If <code>object</code> is not <code>NULL</code>,
<code>class</code> is used to further specify what class is the target object belongs
to. If <code>object</code> is <code>NULL</code>, an empty <a href="#topic+IdfObject">IdfObject</a> of <code>class</code> is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is not given, an empty <a href="#topic+IdfObject">IdfObject</a> of specified class is created,
with all field values filled with defaults, if possible.  Note that
validation is performed when creating, which means that an error may occur if
current <a href="#topic+level_checks">validate level</a> does not allow empty required fields.
</p>
<p>The empty <a href="#topic+IdfObject">IdfObject</a> is directly added into the parent <a href="#topic+Idf">Idf</a> object. It is
recommended to use <code style="white-space: pre;">&#8288;$validate()&#8288;</code> method in <a href="#topic+IdfObject">IdfObject</a> to see what kinds of
further modifications are needed for those empty fields and use <code style="white-space: pre;">&#8288;$set()&#8288;</code>
method to set field values.
</p>


<h3>Value</h3>

<p>An <a href="#topic+IdfObject">IdfObject</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"))

# get an IdfObject using object ID
idf_object(model, 14)

# get an IdfObject using object name (case-insensitive)
idf_object(model, "zone one")

# `class` argument is useful when there are objects with same name in
# different class
idf_object(model, "zone one", "Zone")

# create a new zone
eplusr_option(validate_level = "draft")
zone &lt;- idf_object(model, class = "Zone")
zone
eplusr_option(validate_level = "final")
zone$validate()

## End(Not run)
</code></pre>

<hr>
<h2 id='IdfGeometry'>Modify and Visualize an EnergyPlus Model Geometry</h2><span id='topic+IdfGeometry'></span><span id='topic+idf_geometry'></span>

<h3>Description</h3>

<p><code>IdfGeometry</code> is an abstraction of a collection of geometry in an <a href="#topic+Idf">Idf</a>. It
provides more detail methods to query geometry properties, update geometry
vertices and visualize geometry in 3D using the
<a href="https://cran.r-project.org/package=rgl">rgl</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idf_geometry(parent, object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdfGeometry_+3A_parent">parent</code></td>
<td>
<p>A path to an IDF file or an <a href="#topic+Idf">Idf</a> object.</p>
</td></tr>
<tr><td><code id="IdfGeometry_+3A_object">object</code></td>
<td>
<p>A character vector of valid names or an integer
vector of valid IDs of objects to extract. If <code>NULL</code>, all
objects in geometry classes will be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>IdfGeometry</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdfGeometry-new"><code>IdfGeometry$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-parent"><code>IdfGeometry$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-rules"><code>IdfGeometry$rules()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-convert"><code>IdfGeometry$convert()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-coord_system"><code>IdfGeometry$coord_system()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-round_digits"><code>IdfGeometry$round_digits()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-area"><code>IdfGeometry$area()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-azimuth"><code>IdfGeometry$azimuth()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-tilt"><code>IdfGeometry$tilt()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-view"><code>IdfGeometry$view()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfGeometry-print"><code>IdfGeometry$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdfGeometry-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>IdfGeometry</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$new(parent, object = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parent</code></dt><dd><p>A path to an IDF file or an <a href="#topic+Idf">Idf</a> object.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of valid names or an integer
vector of valid IDs of objects to extract. If <code>NULL</code>, all
objects in geometry classes will be extracted.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>IdfGeometry</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# create from an Idf object
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))
geom &lt;- idf$geometry()
geom &lt;- IdfGeometry$new(idf)

# create from an IDF file
geom &lt;- idf_geometry(path_idf)
geom &lt;- IdfGeometry$new(path_idf)
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>Get parent <a href="#topic+Idf">Idf</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$parent()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$parent()&#8288;</code> returns the parent <a href="#topic+Idf">Idf</a> object of current <code>IdfGeometry</code>
object.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$parent()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-rules"></a>



<h4>Method <code>rules()</code></h4>

<p>Get global geometry rules
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$rules()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$rules()&#8288;</code> returns global geometry rules.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$rules()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-convert"></a>



<h4>Method <code>convert()</code></h4>

<p>Convert simple geometry objects
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$convert(type = c("surface", "subsurface", "shading"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A character vector giving what types of simplified
geometries should be converted. Should be a subset of
<code>"surface"</code>, <code>"subsurface"</code> and <code>"shading"</code>. Default is set to
all of them.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>EnergyPlus provides several classes that allow for simplified entry
of geometries, such as <code>Wall:Exterior</code>, <code>Window</code> and etc.
<code style="white-space: pre;">&#8288;$convert()&#8288;</code> will generate detailed vertices from simplified geometry
specifications and replace the original object with its corresponding
detailed class, including:
</p>

<ul>
<li> <p><code>BuildingSurface:Detailed</code>
</p>
</li>
<li> <p><code>FenestrationSurface:Detailed</code>
</p>
</li>
<li> <p><code>Shading:Site:Detailed</code>
</p>
</li>
<li> <p><code>Shading:Building:Detailed</code>
</p>
</li>
<li> <p><code>Shading:Zone:Detailed</code>
</p>
</li></ul>




<h5>Returns</h5>

<p>The modified <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$convert()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-coord_system"></a>



<h4>Method <code>coord_system()</code></h4>

<p>Convert vertices to specified coordinate systems
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$coord_system(detailed = NULL, simple = NULL, daylighting = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>detailed, simple, daylighting</code></dt><dd><p>A string specifying the coordinate
system for detailed geometries, simple (rectangular surface)
geometries, and daylighting reference points. Should be one of
<code>"relative"</code>, <code>"world"</code> and <code>"absolute"</code>. <code>"absolute"</code> is the
same as <code>"world"</code> and converted to it.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$coord_system()&#8288;</code> converts all vertices of geometries into specified
coordinate systems, e.g. from world to relative, and vice versa.
Besides, it also updates the <code>GlobalGeometryRules</code> in parent <a href="#topic+Idf">Idf</a>
accordingly.
</p>



<h5>Returns</h5>

<p>The modified <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$coord_system("world", "world", "world")
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-round_digits"></a>



<h4>Method <code>round_digits()</code></h4>

<p>Round digits on geometry vertices
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$round_digits(digits = 4L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>digits</code></dt><dd><p>An integer giving the number of decimal places to be
used. Default: <code>4</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$round_digits()&#8288;</code> performs number rounding on vertices of detailed
geometry object vertices, e.g. <code>BuildingSurface:Detailed</code>,
<code>FenestrationSurface:Detailed</code> and etc.
</p>
<p><code style="white-space: pre;">&#8288;$round_digits()&#8288;</code> may be useful for clean up IDF files generated
using OpenStudio which often gives vertices with long trailing
digits.
</p>



<h5>Returns</h5>

<p>The modified <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$round_digits()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-area"></a>



<h4>Method <code>area()</code></h4>

<p>Get area
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$area(class = NULL, object = NULL, net = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of valid geometry class names.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of valid names or an integer
vector of valid IDs of targeting objects.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>net</code></dt><dd><p>If <code>TRUE</code>, the gross area is returned. If <code>FALSE</code>, the net
area is returned. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$area()&#8288;</code> returns the area of surfaces in square meters.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Class names.
</p>
</li>
<li> <p><code>zone</code>: Character type. Zone names that specified objects belong to.
</p>
</li>
<li> <p><code>space</code>: Character type. Space names that specified objects belong to.
</p>
</li>
<li> <p><code>type</code>: Character type. Surface types.
</p>
</li>
<li> <p><code>area</code>: Numeric type. Surface Area in m2.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$area()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-azimuth"></a>



<h4>Method <code>azimuth()</code></h4>

<p>Get azimuth
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$azimuth(class = NULL, object = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of valid geometry class names.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of valid names or an integer
vector of valid IDs of targeting objects.
Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$azimuth()&#8288;</code> returns the azimuth of surfaces in degree.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Class names.
</p>
</li>
<li> <p><code>zone</code>: Character type. Zone names that specified objects belong to.
</p>
</li>
<li> <p><code>space</code>: Character type. Space names that specified objects belong to.
</p>
</li>
<li> <p><code>type</code>: Character type. Surface types.
</p>
</li>
<li> <p><code>azimuth</code>: Numeric type. Azimuth in degree.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$azimuth()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-tilt"></a>



<h4>Method <code>tilt()</code></h4>

<p>Get tilt
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$tilt(class = NULL, object = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>A character vector of valid geometry class names.
Default: <code>NULL</code>.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of valid names or an integer
vector of valid IDs of targeting objects.
Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$tilt()&#8288;</code> returns the tilt of surfaces in degree.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Class names.
</p>
</li>
<li> <p><code>zone</code>: Character type. Zone names that specified objects belong to.
</p>
</li>
<li> <p><code>space</code>: Character type. Space names that specified objects belong to.
</p>
</li>
<li> <p><code>type</code>: Character type. Surface types.
</p>
</li>
<li> <p><code>tilt</code>: Numeric type. Azimuth in degree.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$tilt()
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-view"></a>



<h4>Method <code>view()</code></h4>

<p>View 3D geometry
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$view(
  new = FALSE,
  render_by = "surface_type",
  wireframe = TRUE,
  x_ray = FALSE,
  axis = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new</code></dt><dd><p>If <code>TRUE</code>, a new rgl window will be open using
<code><a href="rgl.html#topic+open3d">rgl::open3d()</a></code>. If <code>FALSE</code>, existing rgl window will be
reused if possible. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>render_by</code></dt><dd><p>A single string specifying the way of rendering the
geometry. Possible values are:
</p>

<ul>
<li> <p><code>"surface_type"</code>: Default. Render the model by surface type model.
Walls, roofs, windows, doors, floors, and shading surfaces will
have unique colors.
</p>
</li>
<li> <p><code>"boundary"</code>: Render the model by outside boundary condition. Only
surfaces that have boundary conditions will be rendered with a
color. All other surfaces will be white.
</p>
</li>
<li> <p><code>"construction"</code>: Render the model by surface constructions.
</p>
</li>
<li> <p><code>"zone"</code>: Render the model by zones assigned.
</p>
</li>
<li> <p><code>"space"</code>: Render the model by spaces assigned.
</p>
</li>
<li> <p><code>"normal"</code>: Render the model by surface normal. The outside face of
a heat transfer face will be rendered as white and the inside face
will be rendered as red.
</p>
</li></ul>
</dd>
<dt><code>wireframe</code></dt><dd><p>If <code>TRUE</code>, the wireframe of each surface will be
shown. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>x_ray</code></dt><dd><p>If <code>TRUE</code>, all surfaces wll be rendered translucently.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>axis</code></dt><dd><p>If <code>TRUE</code>, the X, Y and Z axes will be drawn at the
global origin. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$view()&#8288;</code> uses the <a href="https://cran.r-project.org/package=rgl">rgl</a>
package to visualize the IDF geometry in 3D in a similar way as
<a href="https://openstudio.net/">OpenStudio</a>.
</p>
<p><code style="white-space: pre;">&#8288;$view()&#8288;</code> returns an <a href="#topic+IdfViewer">IdfViewer</a> object which can be used to further
tweak the viewer scene.
</p>
<p>In the rgl window, you can control the view using your mouse:
</p>

<ul>
<li><p> Left button: Trackball
</p>
</li>
<li><p> Right button: Pan
projection.
</p>
</li>
<li><p> Wheel: Zoom
</p>
</li></ul>

<p>For more detailed control on the scene, see <a href="#topic+IdfViewer">IdfViewer</a>.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IdfViewer">IdfViewer</a> object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
idf$view()
idf$view(render_by = "zone")
idf$view(new = TRUE, render_by = "construction")
}
</pre>
</div>


<hr>
<a id="method-IdfGeometry-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an <code>IdfGeometry</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfGeometry$print()</pre></div>



<h5>Returns</h5>

<p>The <code>IdfGeometry</code> itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
geom$print()
}
</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idf">Idf</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IdfGeometry$new`
## ------------------------------------------------

## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# create from an Idf object
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))
geom &lt;- idf$geometry()
geom &lt;- IdfGeometry$new(idf)

# create from an IDF file
geom &lt;- idf_geometry(path_idf)
geom &lt;- IdfGeometry$new(path_idf)

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$parent`
## ------------------------------------------------

## Not run: 
geom$parent()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$rules`
## ------------------------------------------------

## Not run: 
geom$rules()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$convert`
## ------------------------------------------------

## Not run: 
geom$convert()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$coord_system`
## ------------------------------------------------

## Not run: 
geom$coord_system("world", "world", "world")

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$round_digits`
## ------------------------------------------------

## Not run: 
geom$round_digits()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$area`
## ------------------------------------------------

## Not run: 
geom$area()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$azimuth`
## ------------------------------------------------

## Not run: 
geom$azimuth()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$tilt`
## ------------------------------------------------

## Not run: 
geom$tilt()

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$view`
## ------------------------------------------------

## Not run: 
idf$view()
idf$view(render_by = "zone")
idf$view(new = TRUE, render_by = "construction")

## End(Not run)

## ------------------------------------------------
## Method `IdfGeometry$print`
## ------------------------------------------------

## Not run: 
geom$print()

## End(Not run)
</code></pre>

<hr>
<h2 id='IdfObject'>Create and Modify an EnergyPlus Object</h2><span id='topic+IdfObject'></span>

<h3>Description</h3>

<p><code>IdfObject</code> is an abstraction of a single object in an <a href="#topic+Idf">Idf</a>. It provides
more detail methods to modify object values and comments. An <code>IdfObject</code>
object can also be created using function <code><a href="#topic+idf_object">idf_object()</a></code> or from methods of a
parent <a href="#topic+Idf">Idf</a> object, using <code style="white-space: pre;">&#8288;$object()&#8288;</code>, <code style="white-space: pre;">&#8288;$objects_in_class()&#8288;</code> and equivalent.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdfObject-new"><code>IdfObject$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-version"><code>IdfObject$version()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-parent"><code>IdfObject$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-id"><code>IdfObject$id()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-name"><code>IdfObject$name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-group_name"><code>IdfObject$group_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-class_name"><code>IdfObject$class_name()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-definition"><code>IdfObject$definition()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-comment"><code>IdfObject$comment()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value"><code>IdfObject$value()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-set"><code>IdfObject$set()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value_possible"><code>IdfObject$value_possible()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-validate"><code>IdfObject$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-is_valid"><code>IdfObject$is_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-value_relation"><code>IdfObject$value_relation()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_to_object"><code>IdfObject$ref_to_object()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_by_object"><code>IdfObject$ref_by_object()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-ref_to_node"><code>IdfObject$ref_to_node()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_to"><code>IdfObject$has_ref_to()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_by"><code>IdfObject$has_ref_by()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref_node"><code>IdfObject$has_ref_node()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-has_ref"><code>IdfObject$has_ref()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-to_table"><code>IdfObject$to_table()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-to_string"><code>IdfObject$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-print"><code>IdfObject$print()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfObject-clone"><code>IdfObject$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdfObject-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>IdfObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$new(object, class = NULL, parent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>An integer specifying an object ID.</p>
</dd>
<dt><code>class</code></dt><dd><p>An integer specifying a class index.</p>
</dd>
<dt><code>parent</code></dt><dd><p>An <a href="#topic+Idf">Idf</a> object specifying the parent object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It is not recommended to directly use <code style="white-space: pre;">&#8288;$new()&#8288;</code> method to create an
<code>IdfObject</code> object, instead considering to use <a href="#topic+idf_object">idf_object</a>,
<a href="../../eplusr/html/Idf.html#method-object"><code>Idf$object()</code></a>
and other equivalent to create <code>IdfObject</code> objects. They provide
more user-friendly interfaces. <code style="white-space: pre;">&#8288;$new()&#8288;</code> is a lower level API which is
mainly used inside methods in other classes.
</p>



<h5>Returns</h5>

<p>An <code>IdfObject</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))

roof &lt;- IdfObject$new(26, parent = idf)

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]
}

</pre>
</div>


<hr>
<a id="method-IdfObject-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of parent <code>Idf</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of parent <code>Idf</code> in a
<code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> format. This makes it easy to direction
compare versions of different <code>IdfObject</code>s, e.g. <code>idfobj$version() &gt; 8.6</code> or
<code>idfobj1$version() &gt; idfobj2$version()</code>.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get version
roof$version()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>Get parent <a href="#topic+Idf">Idf</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$parent()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$parent()&#8288;</code> returns parent <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$parent()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-id"></a>



<h4>Method <code>id()</code></h4>

<p>Get the unique ID for current object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$id()</pre></div>



<h5>Details</h5>

<p>In <a href="#topic+Idf">Idf</a>, each object is assigned with an integer as an universally
unique identifier (UUID) in the context of current <a href="#topic+Idf">Idf</a>. UUID is
not reused even if the object associated is deleted.
</p>
<p><code style="white-space: pre;">&#8288;$id()&#8288;</code> returns an integer of current object unique ID.
</p>



<h5>Returns</h5>

<p>A single integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$id()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-name"></a>



<h4>Method <code>name()</code></h4>

<p>Get the name for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$name()</pre></div>



<h5>Details</h5>

<p>In <code>Idf</code>, each object is assigned with a single string as the name
for it, if the class it belongs to has name attribute, e.g. class
<code>RunPeriod</code>, <code>Material</code> and etc. That name should be unique among all
objects in that class. EnergyPlus will fail with an error if
duplications are found among object names in a class.
</p>
<p><code style="white-space: pre;">&#8288;$name()&#8288;</code> returns a single string of current object name. If
specified class does not have name attribute, <code>NA</code> is returned.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$name()

# NA will be returned if the class does not have name attribute. For example,
# "Version" class
idf$Version$name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-group_name"></a>



<h4>Method <code>group_name()</code></h4>

<p>Get name of group for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$group_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$group_name()&#8288;</code> returns a single string of group name current
<code>IdfObject</code> belongs to.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$group_name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-class_name"></a>



<h4>Method <code>class_name()</code></h4>

<p>Get name of class for current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$class_name()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$class_name()&#8288;</code> returns a single string of class name current
<code>IdfObject</code> belongs to.
</p>



<h5>Returns</h5>

<p>A single string.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$class_name()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-definition"></a>



<h4>Method <code>definition()</code></h4>

<p>Get the <a href="#topic+IddObject">IddObject</a> object for current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$definition()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$definition()&#8288;</code> returns an <a href="#topic+IddObject">IddObject</a> of current class. <a href="#topic+IddObject">IddObject</a>
contains all data used for parsing and creating current <code>IdfObject</code>.
For details, please see <a href="#topic+IddObject">IddObject</a> class.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IddObject">IddObject</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
roof$definition()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-comment"></a>



<h4>Method <code>comment()</code></h4>

<p>Get and modify object comments
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$comment(comment, append = TRUE, width = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>A character vector.
</p>

<ul>
<li><p> If missing, current comments are returned. If there is no
comment in current <code>IdfObject</code>, <code>NULL</code> is returned.
</p>
</li>
<li><p> If <code>NULL</code>, all comments in current <code>IdfObject</code> is deleted.
</p>
</li>
<li><p> If a character vector, it is inserted as comments depending on
the <code>append</code> value.
</p>
</li></ul>
</dd>
<dt><code>append</code></dt><dd><p>Only applicable when <code>commment</code> is a character vector.
Default: <code>FALSE</code>.
</p>

<ul>
<li><p> If <code>NULL</code>, existing comments is deleted before adding <code>comment</code>.
</p>
</li>
<li><p> If <code>TRUE</code>, comment will be appended to existing comments.
</p>
</li>
<li><p> If <code>FALSE</code>, <code>comment</code> is prepended to existing currents.
</p>
</li></ul>
</dd>
<dt><code>width</code></dt><dd><p>A positive integer giving the target width for wrapping
inserted <code>comment</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$comment()&#8288;</code> returns current <code>IdfObject</code> comments if <code>comment</code> is not
given, or modifies current <code>IdfObject</code> comments if <code>comment</code> is given.
If no comments found, <code>NULL</code> is returned.
</p>



<h5>Returns</h5>

<p>If calling without any argument, a character vector or <code>NULL</code>
(if no comments) is return. Otherwise, the modified object itself.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get object comments
roof$comment()

# add new object comments
roof$comment(c("This is a material named `WD01`", "This object has an ID of 47"))
roof$comment()

# append new comments
roof$comment("This is an appended comment")
roof$comment()

# prepend new comments
roof$comment("This is a prepended comment", append = FALSE)
roof$comment()

# wrap long comments
roof$comment("This is a very long comment that is needed to be wrapped.", width = 30)
roof$comment()

# delete old comments and add new one
roof$comment("This is the only comment", append = NULL)
roof$comment()

# delete all comments
roof$comment(NULL)
roof$comment()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value"></a>



<h4>Method <code>value()</code></h4>

<p>Get object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value(which = NULL, all = FALSE, simplify = FALSE, unit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, values of all possible fields in current class
the <code>IdfObject</code> belongs to are returned. Default: <code>FALSE</code></p>
</dd>
<dt><code>simplify</code></dt><dd><p>If <code>TRUE</code>, values of fields are converted into
characters and the converted character vector is returned.</p>
</dd>
<dt><code>unit</code></dt><dd><p>If <code>TRUE</code>, values of numeric fields are assigned with
units using <code><a href="units.html#topic+units">units::set_units()</a></code> if applicable. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$value()&#8288;</code> takes an integer vector of valid field indexes or a
character vector of valid field names, and returns a named list
containing values of specified fields when <code>simplify</code> is <code>FALSE</code> and
a character vector when <code>simplify</code> is <code>TRUE</code>.
</p>
<p>eplusr also provides custom S3 method of <code>$</code> and <code>[[</code> which make
it more convenient to get a single value of current <code>IdfObject</code>.
Basically, <code>idfobj$FieldName</code> and <code>idfobj[[Field]]</code> is
equivalent to <code>idfobj$value(FieldName)[[1]]</code> and
<code>idfobj$value(Field)[[1]]</code>.
</p>



<h5>Returns</h5>

<p>A named list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all existing field values
str(mat$value())

# get values of field 1, 3, 5
str(mat$value(c(1, 3, 5)))

# get character format values instead of a named list
mat$value(c(1, 3, 5), simplify = TRUE)

# get values of all field even those that are not set
str(roof$value())
str(roof$value(all = TRUE))

# get field values using shortcuts
mat$Roughness
mat[["Specific_Heat"]]
mat[c(1,2)]
mat[c("Name", "Density")]
}

</pre>
</div>


<hr>
<a id="method-IdfObject-set"></a>



<h4>Method <code>set()</code></h4>

<p>Modify object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$set(..., .default = TRUE, .empty = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>New field value definitions in <code>field = value</code> format or a
single list in format:
</p>
<div class="sourceCode"><pre>list(field1 = value1, field2 = value2)
</pre></div></dd>
<dt><code>.default</code></dt><dd><p>If <code>TRUE</code>, default values are used for those blank
fields if possible. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>.empty</code></dt><dd><p>If <code>TRUE</code>, trailing empty fields are kept. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$set()&#8288;</code> takes new field value definitions in <code>field = value</code> format
or in a single list format, sets new values for fields specified, and
returns the modified <code>IdfObject</code>. Unlike <code style="white-space: pre;">&#8288;$set()&#8288;</code> method in <a href="#topic+Idf">Idf</a>
class, the special element <code>.comment</code> is <strong>not allowed</strong>. To modify
object comments, please use <code style="white-space: pre;">&#8288;$comment()&#8288;</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# set field values
mat$set(name = "new_name", Thickness = 0.02)
mat[c("Name", "Thickness")]

# When `default` argument is set to TRUE and input field values are empty, i.e.
# NULL, the field values will be reset to defaults.
mat[c("Thermal Absorptance", "Solar Absorptance")]

mat$set(visible_absorptance = NULL, Solar_Absorptance = NULL, .default = TRUE)
mat[c("Visible Absorptance", "Solar Absorptance")]

# set field values using shortcuts
mat$Name &lt;- "another_name"
mat$Name
mat[["Thickness"]] &lt;- 0.019
mat$Thickness
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value_possible"></a>



<h4>Method <code>value_possible()</code></h4>

<p>Get possible object field values.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value_possible(
  which = NULL,
  type = c("auto", "default", "choice", "range", "source")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>type</code></dt><dd><p>A character vector. What types of possible values should
be returned. Should be one of or a combination of <code>"auto"</code>,
<code>"default"</code>, <code>"choice"</code>, <code>"range"</code> and <code>"source"</code>. Default:
All of those.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$value_possible()&#8288;</code> takes an integer vector of valid field indexes or a character
vector of valid field names, and returns all possible values for specified
fields. For a specific field, there are 5 types of possible values:
</p>

<ul>
<li> <p><code>auto</code>: Whether the field can be filled with <code>Autosize</code> and
<code>Autocalculate</code>. This field attribute can also be retrieved using:
</p>
<div class="sourceCode"><pre>idfobj$definition()$is_autosizable_field()
idfobj$definition()$is_autocalculatable_field()
</pre></div>
</li>
<li> <p><code>default</code>: The default value. This value can also be retrieved using
<code>idfobj$defintion()$field_default()</code>.
</p>
</li>
<li> <p><code>choice</code>: The choices which the field can be set. This value can also be
retrieved using <code>idfobj$definition()$field_choice()</code>.
</p>
</li>
<li> <p><code>range</code>: The range which the field value should fall in. This range can
also be retrieved using <code>idfobj$definition()$field_range()</code>.
</p>
</li>
<li> <p><code>source</code>: All values from other objects that current field can refer to.
</p>
</li></ul>




<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;$value_possible()&#8288;</code> returns an <code>IdfValuePossible</code> object
which is a <a href="data.table.html#topic+data.table">data.table</a> with at most 15
columns:
</p>

<ul>
<li> <p><code>class_id</code>: index of class that current <code>IdfObject</code> belongs to
</p>
</li>
<li> <p><code>class_name</code>: name of class that current <code>IdfObject</code> belongs to
</p>
</li>
<li> <p><code>object_id</code>: ID of current <code>IdfObject</code>
</p>
</li>
<li> <p><code>object_name</code>: name of current <code>IdfObject</code>
</p>
</li>
<li> <p><code>field_id</code>: indexes (at Idd level) of object fields specified
</p>
</li>
<li> <p><code>field_index</code>: indexes of object fields specified
</p>
</li>
<li> <p><code>field_name</code>: names (without units) of object fields specified
</p>
</li>
<li> <p><code>value_id</code>: value indexes (at Idf level) of object fields specified
</p>
</li>
<li> <p><code>value_chr</code>: values (converted to characters) of object fields specified
</p>
</li>
<li> <p><code>value_num</code>: values (converted to numbers in SI units) of object fields
specified.
</p>
</li>
<li> <p><code>auto</code>: Exists only when <code>"auto"</code> is one of <code>type</code>. Character type.
Possible values are: <code>"Autosize"</code>, <code>"Autocalculate"</code> and <code>NA</code> (if current
field is neither <code>autosizable</code> nor <code>autocalculatable</code>).
</p>
</li>
<li> <p><code>default</code>: Exists only when <code>"default"</code> is one of <code>type</code>. List type. The
default value of current field. The value is converted into number if
corresponding field type yells so. Note that if current field is a numeric
field but the default value is <code>"Autosize"</code> or <code>"Autocalculate"</code>, it is
left as it is, leaving the returned type being a string instead of a
number.
</p>
</li>
<li> <p><code>range</code>: Exists only when <code>"range"</code> is one of <code>type</code>. List type. The range
that field value should fall in. Every range has four components: <code>minimum</code>
(lower limit), <code>lower_incbounds</code> (<code>TRUE</code> if the lower limit should be
included), <code>maximum</code> (upper limit), and <code>upper_incbounds</code> (<code>TRUE</code> if the
upper limit should be included). For fields of character type, empty lists
are returned. For fields of numeric types with no specified ranges,
<code>minimum</code> is set to <code>-Inf</code>, <code>lower_incbounds</code> is set to FALSE, <code>upper</code> is
set to <code>Inf</code>, and <code>upper_incbounds</code> is set to FALSE. The field range is
printed in number interval denotation.
</p>
</li>
<li> <p><code>source</code>: Exists only when <code>"source"</code> is one of <code>type</code>. List type. Each
element is a character vector which includes all values from other objects
that current field can use as sources and refers to.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$value_possible()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Check possible object field value errors
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$validate(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$validate()&#8288;</code> checks if there are errors in current <code>IdfObject</code> object
under specified validation level and returns an <code>IdfValidity</code> object.
</p>
<p><code style="white-space: pre;">&#8288;$validate()&#8288;</code> is useful to help avoid some common errors before
running the model. By default, validation is performed when calling
all methods that modify objects, e.g.
<a href="../../eplusr/html/IdfObject.html#method-set"><code>$set()</code></a>
and etc.
</p>
<p>In total, there are 10 different validate checking components:
</p>

<ul>
<li> <p><code>required_object</code>: Check if required objects are missing in current
<code>Idf</code>.
</p>
</li>
<li> <p><code>unique_object</code>: Check if there are multiple objects in one
unique-object class. An unique-object class means that there should
be at most only one object existing in that class.
</p>
</li>
<li> <p><code>unique_name</code>: Check if all objects in each class have unique names.
</p>
</li>
<li> <p><code>extensible</code>: Check if all fields in an extensible group have
values. An extensible group is a set of fields that should be
treated as a whole, such like the X, Y and Z vertices of a building
surfaces. An extensible group should be added or deleted together.
<code>extensible</code> component checks if there are some, but not all,
fields in an extensible group are empty.
</p>
</li>
<li> <p><code>required_field</code>: Check if all required fields have values.
</p>
</li>
<li> <p><code>auto_field</code>: Check if all fields filled with value <code>"Autosize"</code> and
<code>"Autocalculate"</code> are actual autosizable and autocalculatable
fields or not.
</p>
</li>
<li> <p><code>type</code>: Check if all fields have value types complied with their
definitions, i.e. character, numeric and integer fields should be
filled with corresponding type of values.
</p>
</li>
<li> <p><code>choice</code>: Check if all choice fields are filled with valid choice
values.
</p>
</li>
<li> <p><code>range</code>: Check if all numeric fields have values within prescibed
ranges.
</p>
</li>
<li> <p><code>reference</code>: Check if all fields whose values refer to other fields
are valid.
</p>
</li></ul>

<p>The <code>level</code> argument controls what checkings should be performed.
<code>level</code> here is just a list of 10 element which specify the toggle
status of each component. You can use helper <code><a href="#topic+custom_validate">custom_validate()</a></code> to
get that list and pass it directly to <code>level</code>.
</p>
<p>There are 3 predefined validate level that indicates different
combinations of checking components, i.e. <code>none</code>, <code>draft</code> and
<code>final</code>. Basically, <code>none</code> level just does not perform any
checkings; <code>draft</code> includes 5 components, i.e. <code>auto_field</code>, <code>type</code>,
<code>unique_name</code>, <code>choice</code> and <code>range</code>; and <code>final</code> level includes all
10 components. You can always get what components each level contains
using <code><a href="#topic+level_checks">level_checks()</a></code>. By default, the result from
<code>eplusr_option("validate_level")</code> is passed to <code>level</code>. If not set,
<code>final</code> level is used.
</p>
<p>Underneath, an <code>IdfValidity</code> object which <code style="white-space: pre;">&#8288;$validate()&#8288;</code> returns is a
list of 13 element as shown below. Each element or several elements
represents the results from a single validation checking component.
</p>

<ul>
<li> <p><code>missing_object</code>: Result of <code>required_object</code> checking.
</p>
</li>
<li> <p><code>duplicate_object</code>: Result of <code>unique_object</code> checking.
</p>
</li>
<li> <p><code>conflict_name</code>: Result of <code>unique_name</code> checking.
</p>
</li>
<li> <p><code>incomplete_extensible</code>: Result of <code>extensible</code> checking.
</p>
</li>
<li> <p><code>missing_value</code>: Result of <code>required_field</code> checking.
</p>
</li>
<li> <p><code>invalid_autosize</code>: Result of <code>auto_field</code> checking for invalid
<code>Autosize</code> field values.
</p>
</li>
<li> <p><code>invalid_autocalculate</code>: Result of <code>auto_field</code> checking for
invalid <code>Autocalculate</code> field values.
</p>
</li>
<li> <p><code>invalid_character</code>: Result of <code>type</code> checking for invalid
character field values.
</p>
</li>
<li> <p><code>invalid_numeric</code>: Result of <code>type</code> checking for invalid
numeric field values.
</p>
</li>
<li> <p><code>invalid_integer</code>: Result of <code>type</code> checking for invalid
integer field values.
</p>
</li>
<li> <p><code>invalid_choice</code>: Result of <code>choice</code> checking.
</p>
</li>
<li> <p><code>invalid_range</code>: Result of <code>range</code> checking.
</p>
</li>
<li> <p><code>invalid_reference</code>: Result of <code>reference</code> checking.
</p>
</li></ul>

<p>Except <code>missing_object</code>, which is a character vector of class names
that are missing, all other elements are
<a href="data.table.html#topic+data.table">data.table</a> with 9 columns containing data
of invalid field values:
</p>

<ul>
<li> <p><code>object_id</code>: IDs of objects that contain invalid values
</p>
</li>
<li> <p><code>object_name</code>: names of objects that contain invalid values
</p>
</li>
<li> <p><code>class_id</code>: indexes of classes that invalid objects belong to
</p>
</li>
<li> <p><code>class_name</code>: names of classes that invalid objects belong to
</p>
</li>
<li> <p><code>field_id</code>: indexes (at Idd level) of object fields that are invalid
</p>
</li>
<li> <p><code>field_index</code>: indexes of object fields in corresponding that are invalid
</p>
</li>
<li> <p><code>field_name</code>: names (without units) of object fields that are invalid
</p>
</li>
<li> <p><code>units</code>: SI units of object fields that are invalid
</p>
</li>
<li> <p><code>ip_units</code>: IP units of object fields that are invalid
</p>
</li>
<li> <p><code>type_enum</code>: An integer vector indicates types of invalid fields
</p>
</li>
<li> <p><code>value_id</code>: indexes (at Idf level) of object field values that are invalid
</p>
</li>
<li> <p><code>value_chr</code>: values (converted to characters) of object fields that are
invalid
</p>
</li>
<li> <p><code>value_num</code>: values (converted to numbers in SI units) of object fields
that are invalid
</p>
</li></ul>

<p>Knowing the internal structure of <code>IdfValidity</code>, it is easy to extract
invalid <a href="#topic+IdfObject">IdfObject</a>s you interested in. For example, you can get all IDs of
objects that contain invalid value references using
<code>model$validate()$invalid_reference$object_id</code>. Then using
<a href="../../eplusr/html/IdfObject.html#method-set"><code>$set()</code></a>
method to correct them.
</p>
<p>Different validate result examples are shown below:
</p>

<ul>
<li><p> No error is found:
</p>
<div class="sourceCode"><pre>v No error found.
</pre></div>
<p>Above result shows that there is no error found after conducting all
validate checks in specified validate level.
</p>
</li>
<li><p> Errors are found:
</p>
<div class="sourceCode"><pre> x [2] Errors found during validation.
=========================================================================

-- [2] Invalid Autocalculate Field --------------------------------------
   Fields below cannot be `autocalculate`:

    Class: &lt;AirTerminal:SingleDuct:VAV:Reheat&gt;
    \- Object [ID:176] &lt;SPACE5-1 VAV Reheat&gt;
       +- 17: AUTOCALCULATE, !- Maximum Flow per Zone Floor Area During Reheat {m3/s-m2}
       \- 18: AUTOCALCULATE; !- Maximum Flow Fraction During Reheat
</pre></div>
<p>Above result shows that after all validate components
performed under current validate level, 2 invalid field values
are found. All of them are in a object named <code style="white-space: pre;">&#8288;SPACE5-1 VAV Reheat&#8288;</code>
with ID <code>176</code>. They are invalid because those two fields do not
have an autocalculatable attribute but are given <code>AUTOCALCULATE</code>
value. Knowing this info, one simple way to fix the
error is to correct those two fields by doing:
</p>
<div class="sourceCode"><pre>idf$set(..176 =
    list(`Maximum Flow per Zone Floor Area During Reheat` = "autosize",
         `Maximum Flow Fraction During Reheat` = "autosize"
    )
)
</pre></div>
</li></ul>




<h5>Returns</h5>

<p>An <code>IdfValidity</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$validate()

# check at predefined validate level
mat$validate("none")
mat$validate("draft")
mat$validate("final")

# custom validate checking components
mat$validate(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-IdfObject-is_valid"></a>



<h4>Method <code>is_valid()</code></h4>

<p>Check if there is any error in current object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$is_valid(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid()&#8288;</code> returns <code>TRUE</code> if there is no error in current <code>IdfObject</code>
object under specified validation level and <code>FALSE</code> otherwise.
</p>
<p><code style="white-space: pre;">&#8288;$is_valid()&#8288;</code> checks if there are errors in current <code>IdfObject</code> object
under specified validation level and returns <code>TRUE</code> or <code>FALSE</code>
accordingly. For detailed description on validate checking, see
<a href="../../eplusr/html/IdfObject.html#method-validate"><code>$validate()</code></a>
documentation above.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$is_valid()

mat$definition()$field_range("Density")
eplusr_option(validate_level = "none") # have to set validate to "none" to do so
mat$Density &lt;- -1
eplusr_option(validate_level = "final") # change back to "final" validate level
mat$is_valid()

# check at predefined validate level
mat$is_valid("none")
mat$is_valid("draft")
mat$is_valid("final")

# custom validate checking components
mat$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))
}

</pre>
</div>


<hr>
<a id="method-IdfObject-value_relation"></a>



<h4>Method <code>value_relation()</code></h4>

<p>Get value relations
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$value_relation(
  which = NULL,
  direction = c("all", "ref_to", "ref_by", "node"),
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  keep = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>direction</code></dt><dd><p>The relation direction to extract. Should be either
<code>"all"</code>, <code>"ref_to"</code> or &quot;ref_by&quot;.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>keep</code></dt><dd><p>If <code>TRUE</code>, all input fields are returned regardless they
have any relations with other objects or not. If <code>FALSE</code>, only
fields in input that have relations with other objects are
returned. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Many fields in <a href="#topic+Idd">Idd</a> can be referred by others. For example, the
<code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> and other fields in <code>Construction</code> class refer to the
<code>Name</code> field in <code>Material</code> class and other material related classes.
Here it means that the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> field <strong>refers to</strong> the <code>Name</code>
field and the <code>Name</code> field is <strong>referred by</strong> the <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code>. In
EnergyPlus, there is also a special type of field called <code>Node</code>,
which together with <code>Branch</code> and <code>BranchList</code> define the topography
of the HVAC connections. A outlet node of a component can be referred
by another component as its inlet node, but can also exists
independently, such as zone air node.
</p>
<p><code style="white-space: pre;">&#8288;$value_relation()&#8288;</code> provides a simple interface to get this kind of
relation. It takes field indexes or field names, together a relation
direction, and returns an <code>IdfRelation</code> object which contains data
presenting such relation described above. For instance, if
<code>idfobj$value_relation("Name", "ref_by")</code> gives results below:
</p>
<div class="sourceCode"><pre>-- Referred by Others ------------------------
  \- 1: "WALL-1";      !- Name
     ^~~~~~~~~~~~~~~~~~~~~~~~~
     \- Class: &lt;BuildingSurface:Detailed&gt;
        \- Object [ID:3] &lt;WALL-1PF&gt;
           \- 3: "WALL-1";      !- Construction Name
</pre></div>
<p>This means that the value <code>"WALL-1"</code> of field <code>Name</code> is referred by
field <code style="white-space: pre;">&#8288;Construction Name&#8288;</code> in a surface named <code style="white-space: pre;">&#8288;WALL-1PF&#8288;</code>. All those
objects can be further easily extracted using <code style="white-space: pre;">&#8288;$ref_by_object()&#8288;</code>
method.
</p>
<p>Note that <code style="white-space: pre;">&#8288;$value_relation()&#8288;</code> shows all fields specified, even some of them
may do not have relation.
</p>



<h5>Returns</h5>

<p>An <code>IdfRelation</code> object, which is a list of 3
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s named <code>ref_to</code>, <code>ref_by</code> and <code>node</code>.
Each <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> contains 24 columns.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check each layer's reference of a construction named FLOOR
roof$value_relation("zone name", "ref_to")

# check where is this construction being used
roof$value_relation("name", direction = "ref_by")
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_to_object"></a>



<h4>Method <code>ref_to_object()</code></h4>

<p>Extract multiple <code>IdfObject</code> objects referred by specified field values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_to_object(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$ref_to_object()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
that specified fields refer to.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get other objects that this object refereces
mat$ref_to_object() # not referencing other objects
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_by_object"></a>



<h4>Method <code>ref_by_object()</code></h4>

<p>Extract multiple <code>IdfObject</code> objects referring to specified field values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_by_object(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$ref_by_object()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
that refer to specified fields.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get other objects that reference this object
mat$ref_by_object() # referenced by construction "FLOOR"
}

</pre>
</div>


<hr>
<a id="method-IdfObject-ref_to_node"></a>



<h4>Method <code>ref_to_node()</code></h4>

<p>Extract multiple <code>IdfObject</code> objects referring to same nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$ref_to_node(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  depth = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>depth</code></dt><dd><p>If &gt; 0, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. If <code>NULL</code>,
all possible recursive relations are returned. Default: <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$ref_to_node()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a list of <code>IdfObject</code>s
whose nodes are referred by specified fields.
</p>



<h5>Returns</h5>

<p>A named list of <code>IdfObject</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus(8.8)) {
    path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5Zone_Transformer.idf")
    idf_5z &lt;- read_idf(path)
    idf_5z$NodeList$OutsideAirInletNodes$ref_to_node()
}
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_to"></a>



<h4>Method <code>has_ref_to()</code></h4>

<p>Check if object field values refer to others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_to(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt><dd><p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$has_ref_to()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether specified fields refer to other object values or not.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_to()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_by"></a>



<h4>Method <code>has_ref_by()</code></h4>

<p>Check if object field values are referred by others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_by(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE,
  class_ref = c("both", "none", "all")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt><dd><p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>class_ref</code></dt><dd><p>Specify how to handle class-name-references. Class
name references refer to references in like field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> in <code>Branch</code> objects. Their value refers to other
many class names of objects, instaed of referring to specific
field values. There are 3 options in total, i.e. <code>"none"</code>,
<code>"both"</code> and <code>"all"</code>, with <code>"both"</code> being the default.
* <code>"none"</code>: just ignore class-name-references. It is a reasonable
option, as for most cases, class-name-references always come
along with field value references. Ignoring
class-name-references will not impact the most part of the
relation structure.
* <code>"both"</code>: only include class-name-references if this object
also reference field values of the same one. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, only the object that is referenced in the
next field <code style="white-space: pre;">&#8288;Component 1 Name&#8288;</code> is treated as referenced by
<code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code>. This is the default option.
* <code>"all"</code>: include all class-name-references. For example, if the
value of field <code style="white-space: pre;">&#8288;Component 1 Object Type&#8288;</code> is
<code>Coil:Heating:Water</code>, all objects in <code>Coil:Heating:Water</code> will
be treated as referenced by that field. This is the most
aggressive option.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$has_ref_by()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether there are other object values ref to specified fields.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_by()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref_node"></a>



<h4>Method <code>has_ref_node()</code></h4>

<p>Check if object field values refer to other nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref_node(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt><dd><p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$has_ref_node()&#8288;</code> takes an integer vector of field indexes or a
character vector of field names, and returns a logical vector showing
whether specified fields refer to other objects' nodes.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
mat$has_ref_node()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-has_ref"></a>



<h4>Method <code>has_ref()</code></h4>

<p>Check if object field values refer to or are referred by others
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$has_ref(
  which = NULL,
  object = NULL,
  class = NULL,
  group = NULL,
  recursive = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>An integer vector of field indexes or a character vector
of field names.</p>
</dd>
<dt><code>object</code></dt><dd><p>A character vector of object names or an integer vector
of object IDs used for searching relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>class</code></dt><dd><p>A character vector of class names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>A character vector of group names used for searching
relations. Default: <code>NULL</code>.</p>
</dd>
<dt><code>recursive</code></dt><dd><p>If <code>TRUE</code>, the relation is searched recursively. A
simple example of recursive reference: one material named
<code>mat</code> is referred by a construction named <code>const</code>, and <code>const</code>
is also referred by a surface named <code>surf</code>. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For details on field value relations, see
<a href="../../eplusr/html/IdfObject.html#method-value_relation"><code>$value_relation()</code></a>.
</p>
<p><code style="white-space: pre;">&#8288;$has_ref()&#8288;</code> takes an integer vector of field indexes or a character
vector of field names, and returns a logical vector showing whether
there are other object values ref to specified field values or
specified field values refer to other object values or specified
field values refer to other objects' nodes.
</p>



<h5>Returns</h5>

<p>A logical vector with the same length as specified field.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# check if having any referenced objects or is referenced by other objects
mat$has_ref()
}

</pre>
</div>


<hr>
<a id="method-IdfObject-to_table"></a>



<h4>Method <code>to_table()</code></h4>

<p>Format <code>IdfObject</code> as a data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$to_table(
  string_value = TRUE,
  unit = TRUE,
  wide = FALSE,
  all = FALSE,
  group_ext = c("none", "group", "index")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string_value</code></dt><dd><p>If <code>TRUE</code>, all field values are returned as
character. If <code>FALSE</code>, <code>value</code> column in returned
<a href="data.table.html#topic+data.table">data.table</a> is a list column with
each value stored as corresponding type. Note that if the
value of numeric field is set to <code>"Autosize"</code> or
<code>"Autocalculate"</code>, it is left as it is, leaving the returned
type being a string instead of a number. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>Only applicable when <code>string_value</code> is <code>FALSE</code>. If
<code>TRUE</code>, values of numeric fields are assigned with units using
<code><a href="units.html#topic+units">units::set_units()</a></code> if applicable. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>wide</code></dt><dd><p>Only applicable if target objects belong to a same class.
If <code>TRUE</code>, a wide table will be returned, i.e. first three
columns are always <code>id</code>, <code>name</code> and <code>class</code>, and then every
field in a separate column. Note that this requires all
objects specified must from the same class.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>group_ext</code></dt><dd><p>Should be one of <code>"none"</code>, <code>"group"</code> or <code>"index"</code>.
If not <code>"none"</code>, <code>value</code> column in returned
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> will be converted into a list.
If <code>"group"</code>, values from extensible fields will be grouped by the
extensible group they belong to. For example, coordinate
values of each vertex in class <code>BuildingSurface:Detailed</code> will
be put into a list. If <code>"index"</code>, values from extensible fields
will be grouped by the extensible field indice they belong to.
For example, coordinate values of all x coordinates will be
put into a list. If <code>"none"</code>, nothing special will be done.
Default: <code>"none"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_table()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> that
contains core data of current <code>IdfObject</code>. It has 6 columns:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Object IDs.
</p>
</li>
<li> <p><code>name</code>: Character type. Object names.
</p>
</li>
<li> <p><code>class</code>: Character type. Current class name.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indexes.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type if <code>string_value</code> is <code>TRUE</code> or list type if
<code>string_value</code> is <code>FALSE</code> or <code>group_ext</code> is not <code>"none"</code>. Field values.
</p>
</li></ul>

<p>Note that when <code>group_ext</code> is not <code>"none"</code>, <code>index</code> and <code>field</code>
values will not match the original field indices and names. In this
case, <code>index</code> will only indicate the indices of sequences. For
<code>field</code> column, specifically:
</p>

<ul>
<li><p> When <code>group_ext</code> is <code>"group"</code>, each field name in a extensible group
will be abbreviated using <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> with <code>minlength</code> being
<code>10L</code> and all abbreviated names will be separated by <code>|</code> and
combined together. For example, field names in the extensible group
(<code style="white-space: pre;">&#8288;Vertex 1 X-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex 1 Y-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex 1 Z-coordinate&#8288;</code>) in class <code>BuildiBuildingSurface:Detailed</code> will be
merged into one name <code>Vrtx1X-crd|Vrtx1Y-crd|Vrtx1Z-crd</code>.
</p>
</li>
<li><p> When <code>group_ext</code> is <code>"index"</code>, the extensible group indicator in field
names will be removed. Take the same example as above, the
resulting field names will be <code style="white-space: pre;">&#8288;Vertex X-coordinate&#8288;</code>, <code style="white-space: pre;">&#8288;Vertex Y-coordinate&#8288;</code>, and <code style="white-space: pre;">&#8288;Vertex Z-coordinate&#8288;</code>.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 6 columns (if
<code>wide</code> is <code>FALSE</code>) or at least 6 columns (if <code>wide</code> is <code>TRUE</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get all object data in a data.table format without field units
str(mat$to_table(unit = FALSE))

# get all object data in a data.table format where all field values are put in a
# list column and field names without unit
str(mat$to_table(string_value = FALSE, unit = FALSE))

# get all object data in a data.table format, including tailing empty fields
str(idf$Zone$`ZONE ONE`$to_table(all = TRUE))

# get all object data in a data.table format where each field becomes a column
str(mat$to_table(wide = TRUE))

# group extensible by extensible group number
surf &lt;- idf$BuildingSurface_Detailed[["Zn001:Roof001"]]
surf$to_table(group_ext = "group")

# group extensible by extensible group number and convert into a wide table
surf$to_table(group_ext = "group", wide = TRUE)

# group extensible by extensible field index
surf$to_table(group_ext = "index")

# group extensible by extensible field index and convert into a wide table
surf$to_table(group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
surf$to_table(group_ext = "index", wide = TRUE, string_value = FALSE, unit = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Format current object as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$to_string(comment = TRUE, leading = 4L, sep_at = 29L, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>If <code>FALSE</code>, all comments will not be included.
Default: <code>TRUE</code>.</p>
</dd>
<dt><code>leading</code></dt><dd><p>Leading spaces added to each field. Default: <code>4L</code>.</p>
</dd>
<dt><code>sep_at</code></dt><dd><p>The character width to separate value string and field
string. Default: <code>29L</code> which is the same as IDF Editor.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all available fields defined in IDD for the
class that objects belong to will be returned. Default:
<code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$to_string()&#8288;</code> returns the text format of current object.
</p>



<h5>Returns</h5>

<p>A character vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# get string format object
mat$to_string()

# get string format of object, and decrease the space between field values and
# field names
mat$to_string(sep_at = 15)

# get string format of object, and decrease the leading space of field values
mat$to_string(leading = 0)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>IdfObject</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$print(comment = TRUE, auto_sep = TRUE, brief = FALSE, all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>comment</code></dt><dd><p>If <code>FALSE</code>, all comments are not included.</p>
</dd>
<dt><code>auto_sep</code></dt><dd><p>If <code>TRUE</code>, values and field names are separated at
the largest character length of values. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>brief</code></dt><dd><p>If <code>TRUE</code>, only OBJECT part is printed. Default:
<code>FALSE</code>.</p>
</dd>
<dt><code>all</code></dt><dd><p>If <code>TRUE</code>, all fields defined in <a href="#topic+Idd">Idd</a> are printed even
they do not exist in current object. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> prints the <code>IdfObject</code>. Basically, the print output can be
divided into 3 parts:
</p>

<ul>
<li><p> OBJECT: Class name, object id and name (if applicable).
</p>
</li>
<li><p> COMMENTS: Object comments if exist.
</p>
</li>
<li><p> VALUES: fields and values of current <code>IdfObject</code>. Required fields are marked
with start <code>*</code>. String values are quoted. Numeric values are printed as
they are. Blank string values are printed as <code style="white-space: pre;">&#8288;&lt;"Blank"&gt;&#8288;</code> and blank number
values are printed as <code style="white-space: pre;">&#8288;&lt;Blank&gt;&#8288;</code>.
</p>
</li></ul>




<h5>Returns</h5>

<p>The <code>IdfObject</code> itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# print the object without comment
mat$print(comment = FALSE)

# print the object, and auto separate field values and field names at the
# largetst character length of field values
mat$print(auto_sep = TRUE)
}

</pre>
</div>


<hr>
<a id="method-IdfObject-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfObject$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>


<ul>
<li><p> Only one single list is allowed, e.g. <code>idfobj$set(lst1)</code> where <code>lst1 &lt;- list(field1 = value1)</code> is allowed, but <code>idfobj$set(lst1, lst2)</code> is not.
</p>
</li>
<li><p> You can delete a field by assigning <code>NULL</code> to it, e.g. <code>iddobj$set(fld = NULL)</code> means to delete the value of field <code>fld</code>. If <code>.default</code> is FALSE,
also <code>fld</code> is not a required field and the index of <code>fld</code> is larger than
the number minimum fields required for that class, it will be deleted.
Otherwise it will be left as blank. If <code>.default</code> is <code>TRUE</code>, that field
will be filled with default value if applicable and left as blank if not.
</p>
</li>
<li><p> By default, trailing empty fields that are not required will be removed and
only minimum required fields are kept. You can keep the trailing empty
fields by setting <code>.empty</code> to <code>TRUE</code>.
</p>
</li>
<li><p> New fields that currently do not exist in that object can also be set. They
will be automatically added on the fly.
</p>
</li>
<li><p> Field name matching is <strong>case-insensitive</strong>. For convenience,
underscore-style field names are also allowed, e.g. <code>eNd_MoNtH</code> is
equivalent to <code style="white-space: pre;">&#8288;End Month&#8288;</code>.
</p>
</li>
<li><p> If not all field names are given, positions of those values without field
names are determined after those values with names. E.g. in
<code>model$set(Construction = list("out_layer", name = "name"))</code>, <code>"out_layer"</code>
will be treated as the value of field <code style="white-space: pre;">&#8288;Outside Layer&#8288;</code> in <code>Construction</code>, as
value of field <code>Name</code> has been given as <code>"name"</code>.
</p>
</li></ul>

<p>eplusr also provides custom S3 method of <code style="white-space: pre;">&#8288;$&lt;-&#8288;</code> and
<code>[[&lt;-</code> which makes it more convenient to set a single field value of an
<code>IdfObject</code>. Basically, <code>idfobj$FieldName &lt;- value</code> and <code>idfobj[[Field]]
&lt;- value</code> is equivalent to <code>idfobj$set(FieldName = value)</code> and
<code>idfobjset(Field = value)</code>.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idf">Idf</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IdfObject$new`
## ------------------------------------------------

## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))

roof &lt;- IdfObject$new(26, parent = idf)

# get the IdfObject of material named "C5 - 4 IN HW CONCRETE"
mat &lt;- idf$Material[["C5 - 4 IN HW CONCRETE"]]

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$version`
## ------------------------------------------------

## Not run: 
# get version
roof$version()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$parent`
## ------------------------------------------------

## Not run: 
roof$parent()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$id`
## ------------------------------------------------

## Not run: 
roof$id()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$name`
## ------------------------------------------------

## Not run: 
roof$name()

# NA will be returned if the class does not have name attribute. For example,
# "Version" class
idf$Version$name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$group_name`
## ------------------------------------------------

## Not run: 
roof$group_name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$class_name`
## ------------------------------------------------

## Not run: 
roof$class_name()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$definition`
## ------------------------------------------------

## Not run: 
roof$definition()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$comment`
## ------------------------------------------------

## Not run: 
# get object comments
roof$comment()

# add new object comments
roof$comment(c("This is a material named `WD01`", "This object has an ID of 47"))
roof$comment()

# append new comments
roof$comment("This is an appended comment")
roof$comment()

# prepend new comments
roof$comment("This is a prepended comment", append = FALSE)
roof$comment()

# wrap long comments
roof$comment("This is a very long comment that is needed to be wrapped.", width = 30)
roof$comment()

# delete old comments and add new one
roof$comment("This is the only comment", append = NULL)
roof$comment()

# delete all comments
roof$comment(NULL)
roof$comment()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value`
## ------------------------------------------------

## Not run: 
# get all existing field values
str(mat$value())

# get values of field 1, 3, 5
str(mat$value(c(1, 3, 5)))

# get character format values instead of a named list
mat$value(c(1, 3, 5), simplify = TRUE)

# get values of all field even those that are not set
str(roof$value())
str(roof$value(all = TRUE))

# get field values using shortcuts
mat$Roughness
mat[["Specific_Heat"]]
mat[c(1,2)]
mat[c("Name", "Density")]

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$set`
## ------------------------------------------------

## Not run: 
# set field values
mat$set(name = "new_name", Thickness = 0.02)
mat[c("Name", "Thickness")]

# When `default` argument is set to TRUE and input field values are empty, i.e.
# NULL, the field values will be reset to defaults.
mat[c("Thermal Absorptance", "Solar Absorptance")]

mat$set(visible_absorptance = NULL, Solar_Absorptance = NULL, .default = TRUE)
mat[c("Visible Absorptance", "Solar Absorptance")]

# set field values using shortcuts
mat$Name &lt;- "another_name"
mat$Name
mat[["Thickness"]] &lt;- 0.019
mat$Thickness

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value_possible`
## ------------------------------------------------

## Not run: 
mat$value_possible()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$validate`
## ------------------------------------------------

## Not run: 
mat$validate()

# check at predefined validate level
mat$validate("none")
mat$validate("draft")
mat$validate("final")

# custom validate checking components
mat$validate(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$is_valid`
## ------------------------------------------------

## Not run: 
mat$is_valid()

mat$definition()$field_range("Density")
eplusr_option(validate_level = "none") # have to set validate to "none" to do so
mat$Density &lt;- -1
eplusr_option(validate_level = "final") # change back to "final" validate level
mat$is_valid()

# check at predefined validate level
mat$is_valid("none")
mat$is_valid("draft")
mat$is_valid("final")

# custom validate checking components
mat$is_valid(custom_validate(auto_field = TRUE, choice = TRUE))

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$value_relation`
## ------------------------------------------------

## Not run: 
# check each layer's reference of a construction named FLOOR
roof$value_relation("zone name", "ref_to")

# check where is this construction being used
roof$value_relation("name", direction = "ref_by")

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_to_object`
## ------------------------------------------------

## Not run: 
# get other objects that this object refereces
mat$ref_to_object() # not referencing other objects

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_by_object`
## ------------------------------------------------

## Not run: 
# get other objects that reference this object
mat$ref_by_object() # referenced by construction "FLOOR"

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$ref_to_node`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus(8.8)) {
    path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles/5Zone_Transformer.idf")
    idf_5z &lt;- read_idf(path)
    idf_5z$NodeList$OutsideAirInletNodes$ref_to_node()
}

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_to`
## ------------------------------------------------

## Not run: 
mat$has_ref_to()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_by`
## ------------------------------------------------

## Not run: 
mat$has_ref_by()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref_node`
## ------------------------------------------------

## Not run: 
mat$has_ref_node()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$has_ref`
## ------------------------------------------------

## Not run: 
# check if having any referenced objects or is referenced by other objects
mat$has_ref()

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$to_table`
## ------------------------------------------------

## Not run: 
# get all object data in a data.table format without field units
str(mat$to_table(unit = FALSE))

# get all object data in a data.table format where all field values are put in a
# list column and field names without unit
str(mat$to_table(string_value = FALSE, unit = FALSE))

# get all object data in a data.table format, including tailing empty fields
str(idf$Zone$`ZONE ONE`$to_table(all = TRUE))

# get all object data in a data.table format where each field becomes a column
str(mat$to_table(wide = TRUE))

# group extensible by extensible group number
surf &lt;- idf$BuildingSurface_Detailed[["Zn001:Roof001"]]
surf$to_table(group_ext = "group")

# group extensible by extensible group number and convert into a wide table
surf$to_table(group_ext = "group", wide = TRUE)

# group extensible by extensible field index
surf$to_table(group_ext = "index")

# group extensible by extensible field index and convert into a wide table
surf$to_table(group_ext = "index", wide = TRUE)

# when grouping extensible, 'string_value' and 'unit' still take effect
surf$to_table(group_ext = "index", wide = TRUE, string_value = FALSE, unit = TRUE)

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$to_string`
## ------------------------------------------------

## Not run: 
# get string format object
mat$to_string()

# get string format of object, and decrease the space between field values and
# field names
mat$to_string(sep_at = 15)

# get string format of object, and decrease the leading space of field values
mat$to_string(leading = 0)

## End(Not run)


## ------------------------------------------------
## Method `IdfObject$print`
## ------------------------------------------------

## Not run: 
# print the object without comment
mat$print(comment = FALSE)

# print the object, and auto separate field values and field names at the
# largetst character length of field values
mat$print(auto_sep = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='IdfSchedule'>Create an <code>IdfScheduleCompact</code> object.</h2><span id='topic+IdfSchedule'></span><span id='topic+schedule_compact'></span><span id='topic+IdfScheduleCompact'></span>

<h3>Description</h3>

<p><code>schedule_compact()</code> takes a parent <code>Idf</code> object, a name for
<code>Schedule:Compact</code> object, and returns a corresponding <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a>
object.
</p>
<p><code>IdfScheduleCompact</code> is an abstraction of a single <code>Schedule:Compact</code> object
in an <a href="#topic+Idf">Idf</a>. It provides more detailed methods to add, modify and extract
schedule values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schedule_compact(parent, name, new = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdfSchedule_+3A_parent">parent</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object.</p>
</td></tr>
<tr><td><code id="IdfSchedule_+3A_name">name</code></td>
<td>
<p>A valid name (a string) for a <code>Schedule:Compact</code> object.</p>
</td></tr>
<tr><td><code id="IdfSchedule_+3A_new">new</code></td>
<td>
<p>If <code>TRUE</code>, a new empty <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a> is created. Default:
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>new</code> is <code>TRUE</code>, an empty <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a> is created,
with all field values being empty. The empty <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a> is directly
added into the parent <a href="#topic+Idf">Idf</a> object. It is recommended to use <code style="white-space: pre;">&#8288;$validate()&#8288;</code>
method in <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a> to see what kinds of further modifications are
needed for those empty fields and use <code style="white-space: pre;">&#8288;$set()&#8288;</code> and <code style="white-space: pre;">&#8288;$update()&#8288;</code> method to set
field values.
</p>


<h3>Value</h3>

<p>An <a href="#topic+IdfScheduleCompact">IdfScheduleCompact</a> object.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+IdfObject">eplusr::IdfObject</a></code> -&gt; <code><a href="#topic+IdfSchedule">eplusr::IdfSchedule</a></code> -&gt; <code>IdfScheduleCompact</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdfScheduleCompact-new"><code>IdfScheduleCompact$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-type_limits"><code>IdfScheduleCompact$type_limits()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-set"><code>IdfScheduleCompact$set()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-update"><code>IdfScheduleCompact$update()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-validate"><code>IdfScheduleCompact$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-is_valid"><code>IdfScheduleCompact$is_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-extract"><code>IdfScheduleCompact$extract()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfScheduleCompact-clone"><code>IdfScheduleCompact$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="class_name"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-class_name'><code>eplusr::IdfObject$class_name()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="comment"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-comment'><code>eplusr::IdfObject$comment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="definition"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-definition'><code>eplusr::IdfObject$definition()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="group_name"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-group_name'><code>eplusr::IdfObject$group_name()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="has_ref"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-has_ref'><code>eplusr::IdfObject$has_ref()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="has_ref_by"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-has_ref_by'><code>eplusr::IdfObject$has_ref_by()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="has_ref_node"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-has_ref_node'><code>eplusr::IdfObject$has_ref_node()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="has_ref_to"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-has_ref_to'><code>eplusr::IdfObject$has_ref_to()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="id"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-id'><code>eplusr::IdfObject$id()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="name"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-name'><code>eplusr::IdfObject$name()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="parent"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-parent'><code>eplusr::IdfObject$parent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="print"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-print'><code>eplusr::IdfObject$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="ref_by_object"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-ref_by_object'><code>eplusr::IdfObject$ref_by_object()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="ref_to_node"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-ref_to_node'><code>eplusr::IdfObject$ref_to_node()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="ref_to_object"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-ref_to_object'><code>eplusr::IdfObject$ref_to_object()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="to_string"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-to_string'><code>eplusr::IdfObject$to_string()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="to_table"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-to_table'><code>eplusr::IdfObject$to_table()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="value"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-value'><code>eplusr::IdfObject$value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="value_possible"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-value_possible'><code>eplusr::IdfObject$value_possible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="value_relation"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-value_relation'><code>eplusr::IdfObject$value_relation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="IdfObject" data-id="version"><a href='../../eplusr/html/IdfObject.html#method-IdfObject-version'><code>eplusr::IdfObject$version()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-IdfScheduleCompact-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>IdfScheduleCompact</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$new(object, parent, new = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>An integer specifying an object ID.</p>
</dd>
<dt><code>parent</code></dt><dd><p>An <a href="#topic+Idf">Idf</a> object specifying the parent object.</p>
</dd>
<dt><code>new</code></dt><dd><p>If <code>TRUE</code>, an empty <code>IdfScheduleCompact</code> will be created.
Default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>IdfScheduleCompact</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
model &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"))

# create an empty 'Schedule:Compact'
schedule_compact(model, "sch", TRUE)

# get an existing 'Schedule:Compact'
sch &lt;- schedule_compact(model, "sch")
}
</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-type_limits"></a>



<h4>Method <code>type_limits()</code></h4>

<p>Get or set the schedule type limits
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$type_limits(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A string specifying the name of an <code>ScheduleTypeLimits</code>
object in current <a href="#topic+Idf">Idf</a>. If missing, value of last time will
be used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of 2 elements:
</p>

<ul>
<li> <p><code>name</code>: The name of the <code>ScheduleTypeLimits</code> object
</p>
</li>
<li> <p><code>range</code>: The range of current schedule values
</p>
</li></ul>



<hr>
<a id="method-IdfScheduleCompact-set"></a>



<h4>Method <code>set()</code></h4>

<p>Set schedule values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$set(..., .check_range = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Schedule day types and value specifications in lists.
</p>

<ul>
<li><p> Group day types inside <code>c(...)</code> at the LHS of <code style="white-space: pre;">&#8288;:=&#8288;</code>
</p>
</li>
<li><p> Put actual schedule values inside <code>list(...)</code> at the RHS of <code style="white-space: pre;">&#8288;:=&#8288;</code>
</p>
</li>
<li><p> Each schedule value should be named a time. Time can be given in
either <code>..H</code> or <code>"HH:MM"</code>.
</p>
</li></ul>
</dd>
<dt><code>.check_range</code></dt><dd><p>If <code>TRUE</code>, schedule values will be checked based
on <code style="white-space: pre;">&#8288;$type_limits()&#8288;</code>. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Please note that all schedules will be applied for all days in a
year. For detailed modifications, please check <code style="white-space: pre;">&#8288;$update()&#8288;</code> method
which accepts data.frame input.
</p>



<h5>Returns</h5>

<p>The modified <code>IdfScheduleCompact</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sch$set(c("weekday", "summerdesignday") := list(
    ..6 = 0.2, "8:00" = 0.5,
    ..12 = 0.95, "13:30" = 0.6, ..14 = 0.8,
    ..18 = 0.95, ..19 = 0.2, ..24 = 0),
    allotherday = list(..24 = 0)
)
}
</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update schedule values using data.frame
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$update(data, check_range = TRUE, compact = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A data.frame of at least 4 columns:
</p>

<ul>
<li> <p><code>year_day</code>: Used for the <code style="white-space: pre;">&#8288;Through:&#8288;</code> fields. Can be in one of the
following formats:
</p>

<ul>
<li> <p><code>character</code>: Day specifications in either <code>mm/dd</code> or <code>mm-dd</code>
where <code>mm</code> is the month in <code>1:12</code> or in character and <code>dd</code> is the
day in month in <code>1:31</code>
</p>
</li>
<li> <p><code>Date</code>: The year component will be ignored and only the month and
day component will be used
</p>
</li>
<li> <p><code>integer</code>: Julian day, e.g. <code>360</code>, <code>365</code> and etc
</p>
</li></ul>

</li>
<li> <p><code>id</code> (Optional): Integer type. Used to group together different day
types with same schedule values.  Grouped day types will be
compacted in a single <code style="white-space: pre;">&#8288;For:&#8288;</code> field, e.g. <code style="white-space: pre;">&#8288;For: Weekdays SummaryDesignDay&#8288;</code>. Grouped day types should have the same schedule
values. Otherwise an error will be issued.
</p>
</li>
<li> <p><code>daytype</code>: Character type. Used for the <code style="white-space: pre;">&#8288;For:&#8288;</code> fields. All possible
values are listed below. Case-insensitive matching is used.
Different day types can be grouped using the <code>id</code> column mentioned
above or put together directly in a single string separate by comma
(<code style="white-space: pre;">&#8288;,&#8288;</code>), e.g. <code>"weekend, holiday"</code>
</p>

<ul>
<li> <p><code>"AllDay(s)"</code>
</p>
</li>
<li> <p><code>"Weekday(s)"</code>, and also <code>"Monday"</code>, <code>"Tuesday"</code>, <code>"Wednesday"</code>,
<code>"Thursday"</code> and <code>"Friday"</code>
</p>
</li>
<li> <p><code>"Weekend(s)"</code>, and also <code>"Saturday"</code> and <code>"Sunday"</code>
</p>
</li>
<li> <p><code>"SummaryDesignDay"</code> and <code>"WinterDesignDay"</code>
</p>
</li>
<li> <p><code>"Holiday"</code>
</p>
</li>
<li> <p><code>"CustomDay1"</code> and <code>"CustomDay2"</code>
</p>
</li>
<li> <p><code>"AllOtherDay(s)"</code>
</p>
</li></ul>

</li>
<li> <p><code>time</code>: Used for the <code style="white-space: pre;">&#8288;Until:&#8288;</code> fields. Can be in one of the
following formats:
</p>

<ul>
<li> <p><code>character</code>: Time specifications in <code>HH:MM</code>
where <code>HH</code> is the hour in <code>0:24</code> and <code>MM</code> is the
minute in <code>0:60</code>
</p>
</li>
<li> <p><code>integer</code>: Time differences from <code>00:00:00</code> in <strong>minutes</strong>, e.g.
<code>seq(60, 60 * 24, by = 60)</code>
</p>
</li>
<li> <p><code>hms</code>: <code>hms</code> objects constructed using <code>hms::hms()</code> or
equivalents, e.g.  <code>hms::hms(minutes = 30, hours = 1)</code>, and
<code>hms::as_hms("1:30:00")</code>
</p>
</li>
<li> <p><code>difftime</code>: <code>difftime</code> objects constructed using <code>as.difftime()</code>
or equivalents, e.g. <code>as.difftime(1:24, units = "hours")</code>
</p>
</li>
<li> <p><code>ITime</code>: <code>ITime</code> objects constructed using
<code>data.table::as.ITime()</code>, e.g. <code>as.ITime("01:30:00")</code>
</p>
</li></ul>

</li>
<li> <p><code>value</code>: Numeric type. Used for the actual schedule values
</p>
</li></ul>
</dd>
<dt><code>check_range</code></dt><dd><p>If <code>TRUE</code>, schedule values will be checked based
on <code style="white-space: pre;">&#8288;$type_limits()&#8288;</code>. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>compact</code></dt><dd><p>If <code>TRUE</code>, same schedule values from different day
types will be compacted together.  Also, time periods that
have the same schedule values will also be compacted.
Note that only <code>"Holiday"</code>, <code>"CustomDay1"</code> and <code>"CustomDay2"</code>
will be compacted into <code>"AllOtherDays"</code>. For example, if the
<code>daytype</code> column contains only <code>"Weekdays"</code>,
<code>"SummerDesignDay"</code> and <code>"AllOtherDays"</code>, <code>"AllOtherDays"</code>
will be expanded to <code>"Weekends"</code>, <code>"WinterDesignDay"</code> and
<code>"AllOtherDays"</code>.  Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified <code>IdfScheduleCompact</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sch$update(sch$extract())

val1 &lt;- data.table::data.table(
    year_day = "12/31",
    daytype = "weekday,summerdesignday",
    time = c("6:00", "8:00", "12:00", "13:30", "14:00", "18:00", "19:00", "24:00"),
    value = c(0.2,    0.5,    0.95,    0.6,     0.8,     0.95,    0.2,     0.0)
)
val2 &lt;- data.table::data.table(
    year_day = "12/31", daytype = "allotherday",
    time = "24:00", value = 0.0
)
val &lt;- data.table::rbindlist(list(val1, val2))
sch$update(val)
}
</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Check possible object field value errors
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$validate(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$validate()&#8288;</code> checks if there are errors in current
<code>IdfScheduleCompact</code> object under specified validation level and
returns an <code>IdfValidity</code> object.
Schedule value ranges will be checked if current validate level
contains range checking (if corresponding <code>ScheduleTypeLimits</code>
<code style="white-space: pre;">&#8288;Numeric Type&#8288;</code> is <code>Continuous</code>) or choice checking (if corresponding
<code>ScheduleTypeLimits</code> <code style="white-space: pre;">&#8288;Numeric Type&#8288;</code> is <code>Discrete</code>).
</p>
<p>For detailed description on validate checking, see
<a href="../../eplusr/html/IdfObject.html#method-validate"><code>IdfObject$validate()</code></a>
documentation above.
</p>



<h5>Returns</h5>

<p>An <code>IdfValidity</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sch$validate()

# check at predefined validate level
sch$validate("none")
sch$validate("draft")
sch$validate("final")
}
</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-is_valid"></a>



<h4>Method <code>is_valid()</code></h4>

<p>Check if there is any error in current object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$is_valid(level = eplusr_option("validate_level"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>One of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or a list of 10
elements with same format as <code><a href="#topic+custom_validate">custom_validate()</a></code> output.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$is_valid()&#8288;</code> returns <code>TRUE</code> if there is no error in current
<code>IdfScheduleCompact</code> object under specified validation level.
Schedule value ranges will be checked if current validate level
contains range checking (if corresponding <code>ScheduleTypeLimits</code>
<code style="white-space: pre;">&#8288;Numeric Type&#8288;</code> is <code>Continuous</code>) or choice checking (if corresponding
<code>ScheduleTypeLimits</code> <code style="white-space: pre;">&#8288;Numeric Type&#8288;</code> is <code>Discrete</code>).
</p>
<p><code style="white-space: pre;">&#8288;$is_valid()&#8288;</code> checks if there are errors in current <code>IdfObject</code> object
under specified validation level and returns <code>TRUE</code> or <code>FALSE</code>
accordingly. For detailed description on validate checking, see
<a href="../../eplusr/html/IdfObject.html#method-validate"><code>IdfObject$validate()</code></a>
documentation above.
</p>



<h5>Returns</h5>

<p>A single logical value of <code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sch$is_valid()
}

</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-extract"></a>



<h4>Method <code>extract()</code></h4>

<p>Extract schedule values
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$extract(daytype = NULL, timestep = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>daytype</code></dt><dd><p>Should be one of:
</p>

<ul>
<li> <p><code>NULL</code>: Do nothing Grouped day types will be concatenated with a
comma, e.g. <code style="white-space: pre;">&#8288;Weekdays,SummerDesignDay&#8288;</code>. This is the default
behavior.
</p>
</li>
<li> <p><code>TRUE</code> or <code>"expand"</code>: All compacted day types will be expanded.
</p>
</li>
<li> <p><code>FALSE</code> or <code>"compact"</code>: Same schedule values from different day
types will be compacted together.
</p>
</li>
<li><p> A character vector specifying the grouped day types, e.g.
<code>c("weekday", "summerdesignday")</code>. All other days except specified
ones will be classified into day type <code>AllOtherDays</code>, if possible.
If not possible, those day types will still be extracted
separately.
</p>
</li></ul>
</dd>
<dt><code>timestep</code></dt><dd><p>The time step of schedule values, e.g. &quot;10 mins&quot; and
&quot;1 hour&quot;. Valid units include <code>sec(s)</code>, <code>min(s)</code>, and
<code>hour(s)</code>. If <code>NULL</code>, the original time specifications will be
kept. If <code>"auto"</code>, the time periods with the same schedule
values will be compacted. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code> if current schedule is empty. Otherwise, a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> of 5 columns:
</p>

<ul>
<li> <p><code>year_day</code>: Character type. Used for the <code style="white-space: pre;">&#8288;Through:&#8288;</code> fields.
Day specifications in <code>mm/dd</code> format
</p>
</li>
<li> <p><code>id</code>: Integer type. The group index of day types
</p>
</li>
<li> <p><code>daytype</code>: Character type. Used for the <code style="white-space: pre;">&#8288;For:&#8288;</code> fields. All possible
values are:
</p>

<ul>
<li> <p><code>"AllDay"</code>
</p>
</li>
<li> <p><code>"Weekday"</code>, and also <code>"Monday"</code>, <code>"Tuesday"</code>, <code>"Wednesday"</code>,
<code>"Thursday"</code> and <code>"Friday"</code>
</p>
</li>
<li> <p><code>"Weekend"</code>, and also <code>"Saturday"</code> and <code>"Sunday"</code>
</p>
</li>
<li> <p><code>"SummaryDesignDay"</code> and <code>"WinterDesignDay"</code>
</p>
</li>
<li> <p><code>"Holiday"</code>
</p>
</li>
<li> <p><code>"CustomDay1"</code> and <code>"CustomDay2"</code>
</p>
</li>
<li> <p><code>"AllOtherDay"</code>
</p>
</li></ul>

</li>
<li> <p><code>time</code>: <code>hms</code> vector. Used for the <code style="white-space: pre;">&#8288;Until:&#8288;</code> fields. It is handy for
plotting since <code>hms</code> object is directly supported by the scale
system of <a href="https://cran.r-project.org/package=ggplot2">ggplot2</a>
package
</p>
</li>
<li> <p><code>value</code>: Numeric type. Actual schedule values
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
sch$extract()
sch$extract("expand")
sch$extract(timestep = "30 mins")
}
</pre>
</div>


<hr>
<a id="method-IdfScheduleCompact-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfScheduleCompact$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idf">Idf</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IdfScheduleCompact$new`
## ------------------------------------------------

## Not run: 
model &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"))

# create an empty 'Schedule:Compact'
schedule_compact(model, "sch", TRUE)

# get an existing 'Schedule:Compact'
sch &lt;- schedule_compact(model, "sch")

## End(Not run)

## ------------------------------------------------
## Method `IdfScheduleCompact$set`
## ------------------------------------------------

## Not run: 
sch$set(c("weekday", "summerdesignday") := list(
    ..6 = 0.2, "8:00" = 0.5,
    ..12 = 0.95, "13:30" = 0.6, ..14 = 0.8,
    ..18 = 0.95, ..19 = 0.2, ..24 = 0),
    allotherday = list(..24 = 0)
)

## End(Not run)

## ------------------------------------------------
## Method `IdfScheduleCompact$update`
## ------------------------------------------------

## Not run: 
sch$update(sch$extract())

val1 &lt;- data.table::data.table(
    year_day = "12/31",
    daytype = "weekday,summerdesignday",
    time = c("6:00", "8:00", "12:00", "13:30", "14:00", "18:00", "19:00", "24:00"),
    value = c(0.2,    0.5,    0.95,    0.6,     0.8,     0.95,    0.2,     0.0)
)
val2 &lt;- data.table::data.table(
    year_day = "12/31", daytype = "allotherday",
    time = "24:00", value = 0.0
)
val &lt;- data.table::rbindlist(list(val1, val2))
sch$update(val)

## End(Not run)

## ------------------------------------------------
## Method `IdfScheduleCompact$validate`
## ------------------------------------------------

## Not run: 
sch$validate()

# check at predefined validate level
sch$validate("none")
sch$validate("draft")
sch$validate("final")

## End(Not run)

## ------------------------------------------------
## Method `IdfScheduleCompact$is_valid`
## ------------------------------------------------

## Not run: 
sch$is_valid()

## End(Not run)


## ------------------------------------------------
## Method `IdfScheduleCompact$extract`
## ------------------------------------------------

## Not run: 
sch$extract()
sch$extract("expand")
sch$extract(timestep = "30 mins")

## End(Not run)
</code></pre>

<hr>
<h2 id='IdfViewer'>Visualize an EnergyPlus Model Geometry and Simulation Results</h2><span id='topic+IdfViewer'></span><span id='topic+idf_viewer'></span>

<h3>Description</h3>

<p><code>IdfViewer</code> is a class designed to view geometry of an <a href="#topic+Idf">Idf</a> and map
simulation results to the geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idf_viewer(geometry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdfViewer_+3A_geometry">geometry</code></td>
<td>
<p>An <a href="#topic+IdfGeometry">IdfGeometry</a> object. <code>geometry</code> can also be a
path to an IDF file or an <a href="#topic+Idf">Idf</a> object. In this case, an
<code>IdfGeometry</code> is created based on input <a href="#topic+Idf">Idf</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>IdfViewer</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdfViewer-new"><code>IdfViewer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-parent"><code>IdfViewer$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-geometry"><code>IdfViewer$geometry()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-device"><code>IdfViewer$device()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-background"><code>IdfViewer$background()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-viewpoint"><code>IdfViewer$viewpoint()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-win_size"><code>IdfViewer$win_size()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-mouse_mode"><code>IdfViewer$mouse_mode()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-axis"><code>IdfViewer$axis()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-ground"><code>IdfViewer$ground()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-wireframe"><code>IdfViewer$wireframe()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-x_ray"><code>IdfViewer$x_ray()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-render_by"><code>IdfViewer$render_by()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-show"><code>IdfViewer$show()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-focus"><code>IdfViewer$focus()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-close"><code>IdfViewer$close()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-snapshot"><code>IdfViewer$snapshot()</code></a>
</p>
</li>
<li> <p><a href="#method-IdfViewer-print"><code>IdfViewer$print()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdfViewer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an <code>IdfViewer</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$new(geometry)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>geometry</code></dt><dd><p>An <a href="#topic+IdfGeometry">IdfGeometry</a> object. <code>geometry</code> can also be a
path to an IDF file or an <a href="#topic+Idf">Idf</a> object. In this case, an
<code>IdfGeometry</code> is created based on input <a href="#topic+Idf">Idf</a>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>IdfViewer</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# create from an Idf object
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))
viewer &lt;- idf_viewer(idf)
viewer &lt;- IdfViewer$new(idf)

# create from an IDF file
viewer &lt;- idf_viewer(path_idf)
viewer &lt;- IdfViewer$new(path_idf)
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>Get parent <a href="#topic+Idf">Idf</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$parent()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$parent()&#8288;</code> returns the parent <a href="#topic+Idf">Idf</a> object of current <code>IdfGeometry</code>
object.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$parent()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-geometry"></a>



<h4>Method <code>geometry()</code></h4>

<p>Get parent <a href="#topic+IdfGeometry">IdfGeometry</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$geometry()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$geometry()&#8288;</code> returns the parent <a href="#topic+IdfGeometry">IdfGeometry</a> object.
</p>



<h5>Returns</h5>

<p>An <a href="#topic+IdfGeometry">IdfGeometry</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$geometry()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-device"></a>



<h4>Method <code>device()</code></h4>

<p>Get Rgl device ID
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$device()</pre></div>



<h5>Details</h5>

<p>If Rgl is used, the Rgl device ID is returned. If WebGL is
used, the <code>elementID</code> is returned. If no viewer has been open, <code>NULL</code>
is returned.
</p>



<h5>Returns</h5>

<p>A number or <code>NULL</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$device()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-background"></a>



<h4>Method <code>background()</code></h4>

<p>Set the background color of the scene
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$background(color = "white")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color</code></dt><dd><p>A single string giving the background color. Default:
<code>white</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$background("blue")
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-viewpoint"></a>



<h4>Method <code>viewpoint()</code></h4>

<p>Set the viewpoint orientation of the scene
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$viewpoint(
  look_at = "iso",
  theta = NULL,
  phi = NULL,
  fov = NULL,
  zoom = NULL,
  scale = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>look_at</code></dt><dd><p>A single string indicating a standard view. If
specified, <code>theta</code> and <code>phi</code> will be ignored. Should be
one of <code>c("top", "bottom", "left", "right", "front", "back", "iso")</code>. <code>look_at</code> will be ignored if any of <code>theta</code> and <code>phi</code>
is specified. Default: <code>iso</code> (i.e. isometric).</p>
</dd>
<dt><code>theta</code></dt><dd><p>Theta in polar coordinates. If <code>NULL</code>, no changes will
be made to current scene. Default: <code>NULL</code>.</p>
</dd>
<dt><code>phi</code></dt><dd><p>Phi in polar coordinates. If <code>NULL</code>, no changes will be
made to current scene. Default: <code>NULL</code>.</p>
</dd>
<dt><code>fov</code></dt><dd><p>Field-of-view angle in degrees. If <code>0</code>, a parallel or
orthogonal projection is used. If <code>NULL</code>, no changes will
be made to current scene. Default: <code>NULL</code>.</p>
</dd>
<dt><code>zoom</code></dt><dd><p>Zoom factor. If <code>NULL</code>, no changes will be made to
current scene. Default: <code>NULL</code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>A numeric vector of length 3 giving the rescaling to
apply to each axis. If <code>NULL</code>, no changes will be made to
current scene. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$viewpoint()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-win_size"></a>



<h4>Method <code>win_size()</code></h4>

<p>Set the window size
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$win_size(left = 0, top = 0, right = 600, bottom = 600)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left, top, right, bottom</code></dt><dd><p>A single number indicating the pixels of
the displayed window. Defaults: <code>0</code> (<code>left</code>), <code>0</code> (<code>top</code>),
<code>600</code> (<code>right</code>) and <code>600</code> (<code>bottom</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$win_size(0, 0, 400, 500)
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-mouse_mode"></a>



<h4>Method <code>mouse_mode()</code></h4>

<p>Set the handlers of mouse control
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$mouse_mode(
  left = "trackball",
  right = "pan",
  middle = "fov",
  wheel = "pull"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left, right, middle</code></dt><dd><p>Refer to the buttons on a three button
mouse, or simulations of them on other mice. Defaults:
<code>"trackball"</code> (<code>left</code>), <code>"pan"</code> (<code>right</code>) and <code>"fov"</code>
(<code>middle</code>).</p>
</dd>
<dt><code>wheel</code></dt><dd><p>Refer to the mouse wheel. Default: <code>"pull"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Possible values are:</p>

<table>
<tr>
 <td style="text-align: left;">
   Mode </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   "none" </td><td style="text-align: left;"> No action </td>
</tr>
<tr>
 <td style="text-align: left;">
   "trackball" </td><td style="text-align: left;"> The mouse acts as a virtual trackball. Clicking and dragging rotates the scene </td>
</tr>
<tr>
 <td style="text-align: left;">
   "xAxis", "yAxis", "zAxis" </td><td style="text-align: left;"> Like "trackball", but restricted to rotation about one axis </td>
</tr>
<tr>
 <td style="text-align: left;">
   "polar" </td><td style="text-align: left;"> The mouse affects rotations by controlling polar coordinates directly </td>
</tr>
<tr>
 <td style="text-align: left;">
   "zoom" </td><td style="text-align: left;"> The mouse zooms the display </td>
</tr>
<tr>
 <td style="text-align: left;">
   "fov" </td><td style="text-align: left;"> The mouse affects perspective by changing the field of view </td>
</tr>
<tr>
 <td style="text-align: left;">
   "pull" </td><td style="text-align: left;"> Rotating the mouse wheel towards the user “ pulls the scene closer” </td>
</tr>
<tr>
 <td style="text-align: left;">
   "push" </td><td style="text-align: left;"> The same rotation “pushes the scene away” </td>
</tr>
<tr>
 <td style="text-align: left;">
   "pan" </td><td style="text-align: left;"> Pan the camera view vertically or horizontally </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$mouse_mode()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-axis"></a>



<h4>Method <code>axis()</code></h4>

<p>Toggle axis in the scene
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$axis(
  add = TRUE,
  expand = 2,
  width = 1.5,
  color = c("red", "green", "blue", "orange"),
  alpha = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add</code></dt><dd><p>If <code>TRUE</code>, axis is added to the scene. If <code>FALSE</code>, axis is
removed in the scene.</p>
</dd>
<dt><code>expand</code></dt><dd><p>A single number giving the factor to expand based on
the largest X, Y and Z coordinate values. Default: <code>2.0</code>.</p>
</dd>
<dt><code>width</code></dt><dd><p>A number giving the line width of axis. <code>width * 2</code> is
used for the true north axis. Default: <code>1.5</code>.</p>
</dd>
<dt><code>color</code></dt><dd><p>A character of length 4 giving the color of X, Y, Z and
true north axis. Default: <code>c("red", "green", "blue", "orange")</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A number giving the alpha value of axis. Default: <code>1.0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$axis()&#8288;</code> adds or removes X, Y and Z axis in the scene.
</p>



<h5>Returns</h5>

<p>A single logical value as <code>add</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$axis()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-ground"></a>



<h4>Method <code>ground()</code></h4>

<p>Toggle ground in the scene
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$ground(add = TRUE, expand = 1.02, color = "#EDEDEB", alpha = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add</code></dt><dd><p>If <code>TRUE</code>, ground is added to the scene. If <code>FALSE</code>,
ground is removed in the scene.</p>
</dd>
<dt><code>expand</code></dt><dd><p>A single number giving the factor to expand based on
the largest X, Y and Z coordinate values. Default: <code>1.02</code>.</p>
</dd>
<dt><code>color</code></dt><dd><p>A string giving the color of ground. Default: <code style="white-space: pre;">&#8288;#EDEDEB&#8288;</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A number giving the alpha value of ground. Default: <code>1.0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$ground()&#8288;</code> adds or removes ground in the scene.
</p>



<h5>Returns</h5>

<p>A single logical value as <code>add</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$ground()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-wireframe"></a>



<h4>Method <code>wireframe()</code></h4>

<p>Toggle wireframe
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$wireframe(add = TRUE, width = 1.5, color = "black", alpha = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add</code></dt><dd><p>If <code>TRUE</code>, wireframe is turned on. If <code>FALSE</code>, wireframe
is turned off. Default: <code>TRUE</code>.</p>
</dd>
<dt><code>width</code></dt><dd><p>A number giving the line width of axis. Default: <code>1.5</code>.</p>
</dd>
<dt><code>color</code></dt><dd><p>A character of length 3 giving the color of X, Y and Z
axis. Default: <code>c("red", "green", "blue")</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A number giving the alpha value of axis. Default: <code>1.0</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$wireframe()&#8288;</code> turns on/off wireframes.
</p>



<h5>Returns</h5>

<p>A single logical value as <code>add</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$wireframe()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-x_ray"></a>



<h4>Method <code>x_ray()</code></h4>

<p>Toggle X-ray face style
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$x_ray(on = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>on</code></dt><dd><p>If <code>TRUE</code>, X-ray is turned on. If <code>FALSE</code>, X-ray is turned
off. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$x_ray()&#8288;</code> turns on/off X-ray face style.
</p>



<h5>Returns</h5>

<p>A single logical value as <code>on</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$x_ray()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-render_by"></a>



<h4>Method <code>render_by()</code></h4>

<p>Set render style
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$render_by(type = "surface_type")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A single string giving the render style. Should be one
of:
</p>

<ul>
<li> <p><code>"surface_type"</code>: Default. Render the model by surface type
model. Walls, roofs, windows, doors, floors, and shading
surfaces will have unique colors.
</p>
</li>
<li> <p><code>"boundary"</code>: Render the model by outside boundary condition.
Only surfaces that have boundary conditions will be rendered
with a color. All other surfaces will be white.
</p>
</li>
<li> <p><code>"construction"</code>: Render the model by surface constructions.
</p>
</li>
<li> <p><code>"zone"</code>: Render the model by zones assigned.
</p>
</li>
<li> <p><code>"space"</code>: Render the model by spaces assigned.
</p>
</li>
<li> <p><code>"normal"</code>: Render the model by surface normal. The outside
face of a heat transfer face will be rendered as white and the
inside face will be rendered as red.
</p>
</li></ul>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$render_by()&#8288;</code> sets the render style of geometries.
</p>



<h5>Returns</h5>

<p>A same value as <code>style</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$render_by()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-show"></a>



<h4>Method <code>show()</code></h4>

<p>Show <a href="#topic+Idf">Idf</a> geometry
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$show(
  type = "all",
  zone = NULL,
  space = NULL,
  surface = NULL,
  width = 1.5,
  dayl_color = "red",
  dayl_size = 5
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A character vector of geometry components to show. If
<code>"all"</code> (default), all geometry components will be shown. If
<code>NULL</code>, no geometry faces will be shown. Otherwise, should be
a subset of following:
</p>

<ul>
<li> <p><code>"floor"</code>
</p>
</li>
<li> <p><code>"wall"</code>
</p>
</li>
<li> <p><code>"roof"</code>
</p>
</li>
<li> <p><code>"window"</code>
</p>
</li>
<li> <p><code>"door"</code>
</p>
</li>
<li> <p><code>"shading"</code>
</p>
</li>
<li> <p><code>"daylighting"</code>
</p>
</li></ul>
</dd>
<dt><code>zone</code></dt><dd><p>A character vector of names or an integer vector of IDs
of zones in current <a href="#topic+Idf">Idf</a> to show. If <code>NULL</code>, no subsetting is
performed.</p>
</dd>
<dt><code>space</code></dt><dd><p>A character vector of names or an integer vector of IDs
of spaces in current <a href="#topic+Idf">Idf</a> to show. If <code>NULL</code>, no subsetting is
performed.</p>
</dd>
<dt><code>surface</code></dt><dd><p>A character vector of names or an integer vector of IDs
of surfaces in current <a href="#topic+Idf">Idf</a> to show. If <code>NULL</code>, no subsetting
is performed.</p>
</dd>
<dt><code>width</code></dt><dd><p>The line width for the geometry components. Default:
<code>1.5</code>.</p>
</dd>
<dt><code>dayl_color, dayl_size</code></dt><dd><p>The color and size of daylighting
reference points. Defaults: <code>"red"</code> (<code>dayl_color</code>) and <code>5</code>
(<code>dayl_size</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <code>IdfViewer</code> itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$show()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-focus"></a>



<h4>Method <code>focus()</code></h4>

<p>Bring the scene window to the top
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$focus()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$top()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-close"></a>



<h4>Method <code>close()</code></h4>

<p>Close the scene window
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$close()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$close()
}
</pre>
</div>


<hr>
<a id="method-IdfViewer-snapshot"></a>



<h4>Method <code>snapshot()</code></h4>

<p>Capture and save current rgl view as an image
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$snapshot(filename, webshot = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>A single string specifying the file name. Current
supported formats are <code>png</code>, <code>pdf</code>, <code>svg</code>, <code>ps</code>, <code>eps</code>, <code>tex</code>
and <code>pgf</code>.</p>
</dd>
<dt><code>webshot</code></dt><dd><p>Whether to use the 'webshot2' package to take the
snapshot. For more details, please see <code><a href="rgl.html#topic+snapshot">rgl::snapshot3d()</a></code>.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments to pass to <code>webshot2::webshot()</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$snapshot()&#8288;</code> captures the current rgl view and saves it as an image
file to disk using <code><a href="rgl.html#topic+snapshot">rgl::snapshot3d()</a></code> and <code><a href="rgl.html#topic+postscript">rgl::rgl.postscript()</a></code>.
</p>



<h5>Returns</h5>

<p>A single string of the file path.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$show()
viewer$snapshot(tempfile(fileext = ".png"))
}

</pre>
</div>


<hr>
<a id="method-IdfViewer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an <code>IdfViewer</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>IdfViewer$print()</pre></div>



<h5>Returns</h5>

<p>The <code>IdfViewer</code> itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
viewer$print()
}
</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+IdfGeometry">IdfGeometry</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `IdfViewer$new`
## ------------------------------------------------

## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# create from an Idf object
idf &lt;- read_idf(path_idf, use_idd(8.8, "auto"))
viewer &lt;- idf_viewer(idf)
viewer &lt;- IdfViewer$new(idf)

# create from an IDF file
viewer &lt;- idf_viewer(path_idf)
viewer &lt;- IdfViewer$new(path_idf)

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$parent`
## ------------------------------------------------

## Not run: 
viewer$parent()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$geometry`
## ------------------------------------------------

## Not run: 
viewer$geometry()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$device`
## ------------------------------------------------

## Not run: 
viewer$device()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$background`
## ------------------------------------------------

## Not run: 
viewer$background("blue")

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$viewpoint`
## ------------------------------------------------

## Not run: 
viewer$viewpoint()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$win_size`
## ------------------------------------------------

## Not run: 
viewer$win_size(0, 0, 400, 500)

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$mouse_mode`
## ------------------------------------------------

## Not run: 
viewer$mouse_mode()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$axis`
## ------------------------------------------------

## Not run: 
viewer$axis()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$ground`
## ------------------------------------------------

## Not run: 
viewer$ground()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$wireframe`
## ------------------------------------------------

## Not run: 
viewer$wireframe()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$x_ray`
## ------------------------------------------------

## Not run: 
viewer$x_ray()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$render_by`
## ------------------------------------------------

## Not run: 
viewer$render_by()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$show`
## ------------------------------------------------

## Not run: 
viewer$show()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$focus`
## ------------------------------------------------

## Not run: 
viewer$top()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$close`
## ------------------------------------------------

## Not run: 
viewer$close()

## End(Not run)

## ------------------------------------------------
## Method `IdfViewer$snapshot`
## ------------------------------------------------

## Not run: 
viewer$show()
viewer$snapshot(tempfile(fileext = ".png"))

## End(Not run)


## ------------------------------------------------
## Method `IdfViewer$print`
## ------------------------------------------------

## Not run: 
viewer$print()

## End(Not run)
</code></pre>

<hr>
<h2 id='init_idf_object'>Initialize object data</h2><span id='topic+init_idf_object'></span>

<h3>Description</h3>

<p>Initialize object data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_idf_object(
  idd_env,
  idf_env,
  class,
  property = NULL,
  underscore = FALSE,
  id = TRUE,
  name = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_property">property</code></td>
<td>
<p>A character vector of column names in class table to return.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name will be converted into
underscore style name first and column <code>class_name_us</code> will be used
for matching. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_id">id</code></td>
<td>
<p>If <code>TRUE</code>, new object IDs will be added in column <code>object_id</code> based
on current existing objects found in <code>idf_env</code>. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_object_+3A_name">name</code></td>
<td>
<p>If <code>TRUE</code>, column <code>object_name</code> and <code>object_name_lower</code> will be
filled using <code><a href="#topic+make_idf_object_name">make_idf_object_name()</a></code>. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>

<hr>
<h2 id='init_idf_value'>Initialize value data</h2><span id='topic+init_idf_value'></span>

<h3>Description</h3>

<p>Initialize value data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_idf_value(
  idd_env,
  idf_env,
  class,
  field = NULL,
  property = NULL,
  underscore = FALSE,
  complete = FALSE,
  all = FALSE,
  default = TRUE,
  id = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_idf_value_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_class">class</code></td>
<td>
<p>An integer vector of valid class indexes or a character vector
of valid class names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_field">field</code></td>
<td>
<p>An integer vector of valid field indexes or a character
vector of valid field names (can be in in underscore style). <code>class</code>
and <code>field</code> should have the same length.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_property">property</code></td>
<td>
<p>A character vector of column names in field table to return.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_underscore">underscore</code></td>
<td>
<p>If <code>TRUE</code>, input class name will be converted into
underscore style name first and column <code>class_name_us</code> will be used
for matching. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code>, at least fields till the current whole extensible
group will be returned. A new column named &quot;matched_rleid&quot; will be
created (when <code>property</code> is NULL) indicating if given field has been
matched or not. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_all">all</code></td>
<td>
<p>If <code>TRUE</code>, all available fields defined in IDD for the class that
objects belong to will be returned. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_default">default</code></td>
<td>
<p>If <code>TRUE</code>, column <code>value_chr</code> and <code>value_num</code> will be filled
with default values. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="init_idf_value_+3A_id">id</code></td>
<td>
<p>If <code>TRUE</code>, new value id will be added in column <code>value_id</code> based
on current existing value ids found in <code>idf_env</code>. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing specified columns.
</p>


<h3>Note</h3>

<p>'object_id' and 'object_name' are added as all <code>NA</code>s.
</p>

<hr>
<h2 id='install_eplus'>Download and Install EnergyPlus</h2><span id='topic+install_eplus'></span><span id='topic+uninstall_eplus'></span><span id='topic+download_eplus'></span>

<h3>Description</h3>

<p>Download specified version of EnergyPlus for your platform from GitHub and
install it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_eplus(ver = "latest", local = FALSE, dir = NULL, force = FALSE, ...)

uninstall_eplus(ver)

download_eplus(ver = "latest", dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_eplus_+3A_ver">ver</code></td>
<td>
<p>The EnergyPlus version number, e.g., <code>"8.7"</code>. For <code>download_eplus()</code>
and <code>install_eplus()</code>, the special value <code>"latest"</code>, which is the
default, means the latest version supported by eplusr.</p>
</td></tr>
<tr><td><code id="install_eplus_+3A_local">local</code></td>
<td>
<p>Whether to install EnergyPlus only for current user. For Windows
and Linux, if <code>FALSE</code>, administrative privileges are required to
install EnergyPlus to the default system-level location. See details.
<code>local</code> should be also set to <code>FALSE</code> if you do not have the write
access to the directory specified via <code>dir</code>. Default: <code>FALSE</code>. For
macOS, administrative privileges are always required no matter you
want EnergyPlus to be install at <code style="white-space: pre;">&#8288;/Applications&#8288;</code> or <code style="white-space: pre;">&#8288;~/Applications&#8288;</code>.</p>
</td></tr>
<tr><td><code id="install_eplus_+3A_dir">dir</code></td>
<td>
<p>A single string of directory.
</p>

<ul>
<li><p> For <code>download_eplus()</code>, where to save EnergyPlus installer file.
Default: <code>"."</code>.
</p>
</li>
<li><p> For <code>install_eplus()</code>, the installer will always be saved into
<code><a href="base.html#topic+tempdir">tempdir()</a></code>. But you can use <code>dir</code> to specify the <strong>parent</strong> directory
of EnergyPlus installation, i.e. the <strong>parent</strong> directory of
<code>EnergyPlusVX-Y-0</code> on Windows and <code>EnergyPlus-X-Y-0</code> on Linux. macOS is
not supported. If <code>NULL</code>, the default installation path will be used.
See details for more information. Please note that <code>dir</code> does not work
on macOS and EnergyPlus will always be installed into the default
location. Default: <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="install_eplus_+3A_force">force</code></td>
<td>
<p>Whether to install EnergyPlus even if it has already been
installed. Setting to <code>TRUE</code> if you want to install the downloaded
EnergyPlus anyway. Please note that this may results in multiple
EnergyPlus installations of the same version at different locations.
eplusr will only use the first EnergyPlus installation. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="install_eplus_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the installer. Current only one
additional argument exists and is only for Linux:
</p>

<ul>
<li> <p><code>dir_bin</code>: A path where symbolic links will be created to the software
executables. The default is <code style="white-space: pre;">&#8288;/usr/local/bin&#8288;</code> if <code>local</code> is <code>FALSE</code>
and <code style="white-space: pre;">&#8288;~/.local/bin&#8288;</code> if <code>local</code> is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>download_eplus()</code> downloads specified version of EnergyPlus from
<a href="https://github.com/NREL/EnergyPlus">EnergyPlus GitHub Repository</a>.
</p>
<p><code>install_eplus()</code> tries to install EnergyPlus into the default location,
e.g. <code style="white-space: pre;">&#8288;C:\EnergyPlusVX-Y-0&#8288;</code> on Windows, <code style="white-space: pre;">&#8288;/usr/local/EnergyPlus-X-Y-0&#8288;</code> on
Linux, and <code style="white-space: pre;">&#8288;/Applications/EnergyPlus-X-Y-0&#8288;</code> on macOS.
</p>
<p>Note that installing to the default location requires administrative
privileges and you have to run R with administrator (or with sudo if you are
on Linux) to make it work if you are not in interactive mode.
</p>
<p>If you can't run R with administrator, it is possible to install EnergyPlus
to your home corresponding directory by setting <code>local</code> to <code>TRUE</code>.
</p>
<p>The user level EnergyPlus installation path is:
</p>

<ul>
<li><p> Windows:
</p>

<ul>
<li> <p><code>dir(Sys.getenv("LOCALAPPDATA"), "EnergyPlusVX-Y-0")</code> OR
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;C:\Users\&lt;User&gt;\AppData\Local\EnergyPlusVX-Y-0&#8288;</code> if environment
variable <code>"LOCALAPPDATA"</code> is not set
</p>
</li></ul>

</li>
<li><p> macOS: <code style="white-space: pre;">&#8288;/Users/&lt;User&gt;/Applications/EnergyPlus-X-Y-0&#8288;</code>
</p>
</li>
<li><p> Linux: <code>"~/.local/EnergyPlus-X-Y-0"</code>
</p>
</li></ul>

<p>On Windows and Linux, you can also specify your custom directory using the
<code>dir</code> argument. Remember to change <code>local</code> to <code>FALSE</code> in order to ask for
administrator privileges if you do not have the write access to that
directory.
</p>
<p>Please note that when <code>local</code> is set to <code>FALSE</code>, no symbolic links
will be created, since this process requires administrative privileges.
</p>
<p><code>uninstall_eplus()</code> tries to uninstall specified version of EnergyPlus
located by eplusr. Similar as <code>install_eplus()</code>, administrative privileges
may be required.
</p>


<h3>Value</h3>

<p>An invisible integer <code>0</code> if succeed. Moreover, some attributes will
also be returned:
</p>

<ul>
<li><p> For <code>install_eplus()</code>:
</p>

<ul>
<li> <p><code>path</code>: the EnergyPlus installation path
</p>
</li>
<li> <p><code>installer</code>: the path of downloaded EnergyPlus installer file
</p>
</li></ul>

</li>
<li><p> For <code>download_eplus()</code>:
</p>

<ul>
<li> <p><code>file</code>: the path of downloaded EnergyPlus installer file
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download the latest version of EnergyPlus
download_eplus("latest", dir = tempdir())
# install the latest version of EnergyPlus system-wide which is the default
# and requires administrative privileges
install_eplus("latest")

# for a specific version of EnergyPlus
download_eplus("8.8", dir = tempdir())
install_eplus("8.8")

# force to reinstall
install_eplus("8.8", force = TRUE)

# install EnergyPlus in your home directory
install_eplus("8.8", local = TRUE, force = TRUE)

# custom EnergyPlus install home directory
install_eplus("8.8", dir = "~/MyPrograms", local = TRUE, force = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='is_eplus_ver'>Check for Idd, Idf and Epw objects</h2><span id='topic+is_eplus_ver'></span><span id='topic+is_idd_ver'></span><span id='topic+is_eplus_path'></span><span id='topic+is_idd'></span><span id='topic+is_idf'></span><span id='topic+is_iddobject'></span><span id='topic+is_idfobject'></span><span id='topic+is_epw'></span>

<h3>Description</h3>

<p>These functions test if input is a valid object of Idd, Idf, Epw and other
main classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_eplus_ver(ver, strict = FALSE)

is_idd_ver(ver, strict = FALSE)

is_eplus_path(path)

is_idd(x)

is_idf(x)

is_iddobject(x)

is_idfobject(x)

is_epw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_eplus_ver_+3A_ver">ver</code></td>
<td>
<p>A character or numeric vector with suitable numeric version
strings.</p>
</td></tr>
<tr><td><code id="is_eplus_ver_+3A_strict">strict</code></td>
<td>
<p>If <code>FALSE</code>, <code>ver</code> can be a special string &quot;latest&quot; which
represents the latest version.</p>
</td></tr>
<tr><td><code id="is_eplus_ver_+3A_path">path</code></td>
<td>
<p>A path to test.</p>
</td></tr>
<tr><td><code id="is_eplus_ver_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_eplus_ver()</code> returns <code>TRUE</code> if input is a valid EnergyPlus version.
</p>
<p><code>is_idd_ver()</code> returns <code>TRUE</code> if input is a valid EnergyPlus IDD version.
</p>
<p><code>is_eplus_path()</code> returns <code>TRUE</code> if input path is a valid EnergyPlus path,
i.e. a path where there is an <code>energyplus</code> executable and an <code>Energy+.idd</code>
file.
</p>
<p><code>is_idd()</code> returns <code>TRUE</code> if input is an Idd object.
</p>
<p><code>is_idf()</code> returns <code>TRUE</code> if input is an Idf object.
</p>
<p><code>is_iddobject()</code> returns <code>TRUE</code> if input is an IddObject object.
</p>
<p><code>is_idfobject()</code> returns <code>TRUE</code> if input is an IdfObject object.
</p>
<p><code>is_epw()</code> returns <code>TRUE</code> if input is an Epw object.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_eplus_ver("8.8")
is_eplus_ver("8.0")
is_eplus_ver("latest", strict = FALSE)

is_idd_ver("9.0.1")
is_idd_ver("8.0.1")

is_eplus_path("C:/EnergyPlusV9-0-0")
is_eplus_path("/usr/local/EnergyPlus-9-0-1")

## Not run: 
is_idd(use_idd("8.8", download = "auto"))

idf &lt;- read_idf(system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr"),
    idd = use_idd("8.8", download = "auto"))
is_idf(idf)

is_iddobject(idd_object("8.8", "Version"))

is_idfobject(idf_object(idf, 1))

is_epw(read_epw(download_weather("los angeles.*tmy3", type = "epw", ask = FALSE, max_match = 1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='level_checks'>Show components of validation strictness level</h2><span id='topic+level_checks'></span>

<h3>Description</h3>

<p><code>level_checks()</code> takes input of a built in validation level or a custom
validation level and returns a list with all validation components that level
contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>level_checks(level = eplusr_option("validate_level"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="level_checks_+3A_level">level</code></td>
<td>
<p>Should be one of <code>"none"</code>, <code>"draft"</code>, <code>"final"</code> or an output of
<code><a href="#topic+custom_validate">custom_validate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with 10 elements, e.g. <code>required_object</code>,
<code>unique_object</code>, <code>unique_name</code>, <code>extensible</code>, <code>required_field</code>, <code>auto_field</code>,
<code>type</code>, <code>choice</code>, <code>range</code> and <code>reference</code>. For the meaning of each validation
component, see<code><a href="#topic+custom_validate">custom_validate()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>level_checks("draft")
level_checks("final")
level_checks(custom_validate(auto_field = TRUE))
level_checks(eplusr_option("validate_level"))
</code></pre>

<hr>
<h2 id='make_idf_object_name'>Initialize object data</h2><span id='topic+make_idf_object_name'></span>

<h3>Description</h3>

<p>Initialize object data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_idf_object_name(
  idd_env,
  idf_env,
  dt_object,
  use_old = TRUE,
  prefix_col = NULL,
  prefix_sep = " ",
  keep_na = TRUE,
  include_ori = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_idf_object_name_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> containing object data.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_use_old">use_old</code></td>
<td>
<p>If <code>TRUE</code>, new object names are based on the original object
names in column <code>object_name</code>. If <code>FALSE</code>, new object names are
created based on the class name it belongs to. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_prefix_col">prefix_col</code></td>
<td>
<p>An character vector of column names in input <code>dt_object</code>
whose values will be combined together as the prefix of the new object
names. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_prefix_sep">prefix_sep</code></td>
<td>
<p>A single string specifying the separation character among
prefix columns. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_keep_na">keep_na</code></td>
<td>
<p>If <code>TRUE</code>, new object names will be <code>NA</code> if the original
object names in column <code>object_name</code> are <code>NA</code>s. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_idf_object_name_+3A_include_ori">include_ori</code></td>
<td>
<p>If <code>TRUE</code>, make sure new object names are not the same as
the original object names in the <code>object_name</code> column. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>

<hr>
<h2 id='ParametricJob'>Create and Run Parametric Analysis, and Collect Results</h2><span id='topic+ParametricJob'></span><span id='topic+param_job'></span>

<h3>Description</h3>

<p><code>ParametricJob</code> class provides a prototype of conducting parametric analysis
of EnergyPlus simulations.
</p>
<p><code>param_job()</code> takes an IDF and EPW as input and returns a <code>ParametricJob</code>.
For details on <code>ParametricJob</code>, please see <a href="#topic+ParametricJob">ParametricJob</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_job(idf, epw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParametricJob_+3A_idf">idf</code></td>
<td>
<p>A path to EnergyPlus IDF or IMF file or an <code>Idf</code> object.</p>
</td></tr>
<tr><td><code id="ParametricJob_+3A_epw">epw</code></td>
<td>
<p>A path to EnergyPlus EPW file or an <code>Epw</code> object. <code>epw</code> can also
be <code>NULL</code> which will force design-day-only simulation when
<code><a href="#topic+ParametricJob">$run()</a></code> method is called. Note this needs at least
one <code>Sizing:DesignDay</code> object exists in the <a href="#topic+Idf">Idf</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, it is a collection of multiple <code>EplusJob</code> objects. However, the
model is first parsed and the <a href="#topic+Idf">Idf</a> object is stored internally, instead of
storing only the path of Idf like in <a href="#topic+EplusJob">EplusJob</a> class. Also, an object in
<code>Output:SQLite</code> with <code style="white-space: pre;">&#8288;Option Type&#8288;</code> value of <code>SimpleAndTabular</code> will be
automatically created if it does not exists, like <a href="#topic+Idf">Idf</a> class does.
</p>


<h3>Value</h3>

<p>A <code>ParametricJob</code> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+EplusGroupJob">eplusr::EplusGroupJob</a></code> -&gt; <code>ParametricJob</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ParametricJob-new"><code>ParametricJob$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-version"><code>ParametricJob$version()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-seed"><code>ParametricJob$seed()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-weather"><code>ParametricJob$weather()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-param"><code>ParametricJob$param()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-apply_measure"><code>ParametricJob$apply_measure()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-models"><code>ParametricJob$models()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-cases"><code>ParametricJob$cases()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-save"><code>ParametricJob$save()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-run"><code>ParametricJob$run()</code></a>
</p>
</li>
<li> <p><a href="#method-ParametricJob-print"><code>ParametricJob$print()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="errors"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-errors'><code>eplusr::EplusGroupJob$errors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="kill"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-kill'><code>eplusr::EplusGroupJob$kill()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="list_files"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-list_files'><code>eplusr::EplusGroupJob$list_files()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="list_table"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-list_table'><code>eplusr::EplusGroupJob$list_table()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="locate_output"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-locate_output'><code>eplusr::EplusGroupJob$locate_output()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="output_dir"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-output_dir'><code>eplusr::EplusGroupJob$output_dir()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="read_mdd"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-read_mdd'><code>eplusr::EplusGroupJob$read_mdd()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="read_rdd"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-read_rdd'><code>eplusr::EplusGroupJob$read_rdd()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="read_table"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-read_table'><code>eplusr::EplusGroupJob$read_table()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="report_data"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-report_data'><code>eplusr::EplusGroupJob$report_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="report_data_dict"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-report_data_dict'><code>eplusr::EplusGroupJob$report_data_dict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="status"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-status'><code>eplusr::EplusGroupJob$status()</code></a></span></li>
<li><span class="pkg-link" data-pkg="eplusr" data-topic="EplusGroupJob" data-id="tabular_data"><a href='../../eplusr/html/EplusGroupJob.html#method-EplusGroupJob-tabular_data'><code>eplusr::EplusGroupJob$tabular_data()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ParametricJob-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>ParametricJob</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$new(idf, epw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>idf</code></dt><dd><p>Path to EnergyPlus IDF file or an <code>Idf</code> object.</p>
</dd>
<dt><code>epw</code></dt><dd><p>Path to EnergyPlus EPW file or an <code>Epw</code> object. <code>epw</code> can
also be <code>NULL</code> which will force design-day-only simulation
when <code style="white-space: pre;">&#8288;$run()&#8288;</code> method is called. Note this needs at least one
<code>Sizing:DesignDay</code> object exists in the <a href="#topic+Idf">Idf</a>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>ParametricJob</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
if (is_avail_eplus("8.8")) {
     path_idf &lt;- path_eplus_example("8.8", "5Zone_Transformer.idf")
     path_epw &lt;- path_eplus_weather("8.8", "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw")

    # create from an IDF and an EPW
    param &lt;- param_job(path_idf, path_epw)
    param &lt;- ParametricJob$new(path_idf, path_epw)

    # create from an Idf and an Epw object
    param_job(read_idf(path_idf), read_epw(path_epw))
}
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-version"></a>



<h4>Method <code>version()</code></h4>

<p>Get the version of seed IDF
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$version()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$version()&#8288;</code> returns the version of input seed <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Returns</h5>

<p>A <code><a href="base.html#topic+numeric_version">base::numeric_version()</a></code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$version()
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-seed"></a>



<h4>Method <code>seed()</code></h4>

<p>Get the seed <a href="#topic+Idf">Idf</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$seed()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$seed()&#8288;</code> returns the parsed input seed <a href="#topic+Idf">Idf</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$seed()
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-weather"></a>



<h4>Method <code>weather()</code></h4>

<p>Get the <a href="#topic+Epw">Epw</a> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$weather()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$weather()&#8288;</code> returns the input <a href="#topic+Epw">Epw</a> object. If no <a href="#topic+Epw">Epw</a> is provided
when creating the <code>ParametricJob</code> object, <code>NULL</code> is returned.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$weather()
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-param"></a>



<h4>Method <code>param()</code></h4>

<p>Set parameters for parametric simulations
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$param(..., .names = NULL, .cross = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Lists of paramter definitions. Please see above on the
syntax.</p>
</dd>
<dt><code>.names</code></dt><dd><p>A character vector of the parameter names. If <code>NULL</code>,
the parameter will be named in format <code>param_X</code>, where
<code>X</code> is the index of parameter. Default: <code>NULL</code>.</p>
</dd>
<dt><code>.cross</code></dt><dd><p>If <code>TRUE</code>, all combinations of parameter values will be
used to create models. If <code>FALSE</code>, each parameter should have
the same length of values. Default: <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$param()&#8288;</code> takes parameter definitions in list format, which is
similar to <a href="#topic+Idf">Idf$set()</a> except that each field is not assigned
with a single value, but a vector of any length, indicating the
levels of each parameter.
</p>
<p>Similar like the way of modifying object field values in
<a href="#topic+Idf">Idf$set()</a>, there are 3 different ways of defining a parameter
in epluspar:
</p>

<ul>
<li> <p><code>object = list(field = c(value1, value2, ...))</code>: Where <code>object</code> is
a valid object ID or name. Note object ID should be denoted with
two periods <code>..</code>, e.g. <code>..10</code> indicates the object with ID <code>10</code>, It
will set that specific field in that object as one parameter.
</p>
</li>
<li> <p><code>.(object, object) := list(field = c(value1, value2, ...))</code>:
Simimar like above, but note the use of <code>.()</code> in the left hand
side.  You can put multiple object ID or names in <code>.()</code>. It will
set the field of all specified objects as one parameter.
</p>
</li>
<li> <p><code>class := list(field = c(value1, value2, ...))</code>: Note the use of
<code style="white-space: pre;">&#8288;:=&#8288;</code> instead of <code>=</code>. The main difference is that, unlike <code>=</code>, the
left hand side of <code style="white-space: pre;">&#8288;:=&#8288;</code> should be a valid class name in current
<a href="#topic+Idf">Idf</a>. It will set that field of all objects in specified
class as one parameter.
</p>
</li></ul>

<p>For example, the code block below defines 3 parameters:
</p>

<ul>
<li><p> Field <code style="white-space: pre;">&#8288;Fan Total Efficiency&#8288;</code> in object named <code style="white-space: pre;">&#8288;Supply Fan 1&#8288;</code> in class
<code>Fan:VariableVolume</code> class, with 10 levels being 0.1 to 1.0 with a
0.1 step.
</p>
</li>
<li><p> Field <code>Thickness</code> in all objects in class <code>Material</code>, with 10
levels being 0.01 to 0.1 m with a 0.1 m step.
</p>
</li>
<li><p> Field <code>Conductivity</code> in all objects in class <code>Material</code>, with 10
levels being 0.1 to 1.0 W/m-K with a 0.1 W/m-K step.
</p>
</li></ul>

<div class="sourceCode"><pre>param$param(
    `Supply Fan 1` = list(Fan_Total_Efficiency = seq(0.1, 1.0, 0.1)),
    Material := list(
        Thickness = seq(0.01, 0.1, 0.1),
        Conductivity = seq(0.1, 1.0, 0.1)
    )
)
</pre></div>



<h5>Returns</h5>

<p>The modified <code>ParametricJob</code> object invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{

param$param(
    Material := .(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
    ),
   "Supply Fan 1" = .(fan_total_efficiency = c(0.1, 0.5, 0.8))
)

# specify parameter values
param$param(
    Material := .(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
     ),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8)),
    .names = c("thickness", "conduct", "fan_eff")
)

# each parameter should have the same length of values
try(
param$param(
    Material := list(Thickness = c(0.1, 0.2)),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8))
)
)

# use all combinations of parameters
param$param(
    Material := list(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
    ),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8)),
    .cross = TRUE
)
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-apply_measure"></a>



<h4>Method <code>apply_measure()</code></h4>

<p>Create parametric models
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$apply_measure(measure, ..., .names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measure</code></dt><dd><p>A function that takes an <code>Idf</code> and other arguments as
input and returns an <a href="#topic+Idf">Idf</a> object as output.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments <strong>except first <code>Idf</code> argument</strong> that are passed
to that <code>measure</code>.</p>
</dd>
<dt><code>.names</code></dt><dd><p>A character vector of the names of parametric <code>Idf</code>s.
If <code>NULL</code>, the new <code>Idf</code>s will be named in format
<code>measure_name + number</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$apply_measure()&#8288;</code> allows to apply a measure to an <a href="#topic+Idf">Idf</a> and creates
parametric models for analysis. Basically, a measure is just a
function that takes an <a href="#topic+Idf">Idf</a> object and other arguements as input, and
returns a modified <a href="#topic+Idf">Idf</a> object as output. Use <code>...</code> to supply
different arguments, <strong>except for the first <code>Idf</code> argument</strong>, to that
measure. Under the hook, <code><a href="base.html#topic+mapply">base::mapply()</a></code> is used to create multiple
<a href="#topic+Idf">Idf</a>s according to the input values.
</p>



<h5>Returns</h5>

<p>The modified <code>ParametricJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# create a measure to change the orientation of the building
rotate_building &lt;- function(idf, degree = 0L) {
    if (!idf$is_valid_class("Building")) {
       stop("Input model does not have a Building object")
    }

    if (degree &gt; 360 || degree &lt; -360 ) {
        stop("Input degree should in range [-360, 360]")
    }

    cur &lt;- idf$Building$North_Axis

    new &lt;- cur + degree

    if (new &gt; 360) {
        new &lt;- new %% 360
        warning("Calculated new north axis is greater than 360. ",
            "Final north axis will be ", new
        )
    } else if (new &lt; -360) {
        new &lt;- new %% -360
        warning("Calculated new north axis is smaller than -360. ",
            "Final north axis will be ", new
        )
    }

    idf$Building$North_Axis &lt;- new

    idf
}

# apply measure
# this will create 12 models
param$apply_measure(rotate_building, degree = seq(30, 360, 30))

# apply measure with new names specified
param$apply_measure(rotate_building, degree = seq(30, 360, 30),
    .names = paste0("rotate_", seq(30, 360, 30))
)
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-models"></a>



<h4>Method <code>models()</code></h4>

<p>Get created parametric <a href="#topic+Idf">Idf</a> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$models(names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>names</code></dt><dd><p>A character vector of new names for parametric models.
If a single string, it will be used as a prefix and all models
will be named in pattern <code>names_X</code>, where <code>X</code> is the model
index. If <code>NULL</code>, existing parametric models are directly
returned. Default: <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$models()&#8288;</code> returns a list of parametric models generated using input
<a href="#topic+Idf">Idf</a> object and
<a href="../../eplusr/html/ParametricJob.html#method-apply_measure"><code>$apply_measure()</code></a>
method. Model names are assigned in the same way as the <code>.names</code>
arugment in
<a href="../../eplusr/html/ParametricJob.html#method-apply_measure"><code>$apply_measure()</code></a>.
If no measure has been applied, <code>NULL</code> is returned. Note that it is
not recommended to conduct any extra modification on those models
directly, after they were created using
<a href="../../eplusr/html/ParametricJob.html#method-apply_measure"><code>$apply_measure()</code></a>,
as this may lead to an un-reproducible process. A warning message
will be issued if any of those models has been modified when running
simulations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$models()
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-cases"></a>



<h4>Method <code>cases()</code></h4>

<p>Get a summary of parametric models and parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$cases()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$cases()&#8288;</code> returns a <a href="data.table.html#topic+data.table">data.table</a> giving a
summary of parametric models and parameter values.
</p>
<p>The returned <code>data.table</code> has the following columns:
</p>

<ul>
<li> <p><code>index</code>: Integer type. The indices of parameter models
</p>
</li>
<li> <p><code>case</code>: Character type. The names of parameter models
</p>
</li>
<li><p> Parameters: Type depends on the parameter values. Each parameter
stands in a separate column. For parametric models created using
<code>ParametricJob$param()</code>, the column names will be the same as what
you specified in <code>.names</code>. For the case of
<code>ParametricJob$apply_measure()</code>, this will be the argument names of
the measure functions.
</p>
</li></ul>




<h5>Returns</h5>

<p>If no parametric models have been created, <code>NULL</code> is
returned. Otherwise, a <a href="data.table.html#topic+data.table">data.table</a>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$cases()
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-save"></a>



<h4>Method <code>save()</code></h4>

<p>Save parametric models
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$save(dir = NULL, separate = TRUE, copy_external = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir</code></dt><dd><p>The parent output directory for models to be saved. If
<code>NULL</code>, the directory of the seed model will be used. Default:
<code>NULL</code>.</p>
</dd>
<dt><code>separate</code></dt><dd><p>If <code>TRUE</code>, all models are saved in a separate folder
with each model's name under specified directory. If <code>FALSE</code>,
all models are saved in the specified directory. Default:
<code>TRUE</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>Only applicable when <code>separate</code> is <code>TRUE</code>. If
<code>TRUE</code>, the external files that every <code>Idf</code> object depends on
will also be copied into the saving directory. The values of
file paths in the Idf will be changed automatically.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$save()&#8288;</code> saves all parametric models in specified folder. An error
will be issued if no measure has been applied.
</p>



<h5>Returns</h5>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with two columns:
</p>

<ul>
<li><p> model: The path of saved parametric model files.
</p>
</li>
<li><p> weather: The path of saved weather files.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# save all parametric models with each model in a separate folder
param$save(tempdir())

# save all parametric models with all models in the same folder
param$save(tempdir(), separate = FALSE)
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run parametric simulations
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$run(
  dir = NULL,
  wait = TRUE,
  force = FALSE,
  copy_external = FALSE,
  echo = wait,
  separate = TRUE,
  readvars = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir</code></dt><dd><p>The parent output directory for specified simulations.
Outputs of each simulation are placed in a separate folder
under the parent directory. If <code>NULL</code>, the directory of the
seed model will be used. Default: <code>NULL</code>.</p>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, R will hang on and wait all EnergyPlus
simulations finish. If <code>FALSE</code>, all EnergyPlus simulations are
run in the background.  Default: <code>TRUE</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p>Only applicable when the last simulation runs with
<code>wait</code> equals to <code>FALSE</code> and is still running. If <code>TRUE</code>,
current running job is forced to stop and a new one will
start. Default: <code>FALSE</code>.</p>
</dd>
<dt><code>copy_external</code></dt><dd><p>If <code>TRUE</code>, the external files that current <code>Idf</code>
object depends on will also be copied into the simulation
output directory. The values of file paths in the Idf will be
changed automatically. Currently, only <code>Schedule:File</code> class
is supported.  This ensures that the output directory will
have all files needed for the model to run. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>echo</code></dt><dd><p>Only applicable when <code>wait</code> is <code>TRUE</code>. Whether to
simulation status. Default: same as <code>wait</code>.</p>
</dd>
<dt><code>separate</code></dt><dd><p>If <code>TRUE</code>, all models are saved in a separate folder
with each model's name under <code>dir</code> when simulation. If <code>FALSE</code>,
all models are saved in <code>dir</code> when simulation. Default:
<code>TRUE</code>.</p>
</dd>
<dt><code>readvars</code></dt><dd><p>If <code>TRUE</code>, the <code>ReadVarESO</code> post-processor will run
to generate CSV files from the ESO output. Since those CSV
files are never used when extracting simulation data in eplusr,
setting it to <code>FALSE</code> can speed up the simulation if there are
hundreds of output variables or meters. Default: <code>TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$run()&#8288;</code> runs all parametric simulations in parallel. The number of
parallel EnergyPlus process can be controlled by
<code>eplusr_option("num_parallel")</code>. If <code>wait</code> is FALSE, then the job
will be run in the background. You can get updated job status by just
printing the <code>ParametricJob</code> object.
</p>



<h5>Returns</h5>

<p>The <code>ParametricJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# run parametric simulations
param$run(wait = TRUE, echo = FALSE)

# run in background
param$run(wait = FALSE)
# get detailed job status by printing
print(param)
}

</pre>
</div>


<hr>
<a id="method-ParametricJob-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>ParametricJob</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ParametricJob$print()</pre></div>



<h5>Details</h5>

<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> shows the core information of this <code>ParametricJob</code>,
including the path of IDFs and EPWs and also the simulation job
status.
</p>
<p><code style="white-space: pre;">&#8288;$print()&#8288;</code> is quite useful to get the simulation status, especially
when <code>wait</code> is <code>FALSE</code> in <code style="white-space: pre;">&#8288;$run()&#8288;</code>. The job status will be updated
and printed whenever <code style="white-space: pre;">&#8288;$print()&#8288;</code> is called.
</p>



<h5>Returns</h5>

<p>The <code>ParametricJob</code> object itself, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
param$print()

Sys.sleep(10)
param$print()
}

</pre>
</div>




<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eplus_job">eplus_job()</a></code> for creating an EnergyPlus single simulation job.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `ParametricJob$new`
## ------------------------------------------------

## Not run: 
if (is_avail_eplus("8.8")) {
     path_idf &lt;- path_eplus_example("8.8", "5Zone_Transformer.idf")
     path_epw &lt;- path_eplus_weather("8.8", "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw")

    # create from an IDF and an EPW
    param &lt;- param_job(path_idf, path_epw)
    param &lt;- ParametricJob$new(path_idf, path_epw)

    # create from an Idf and an Epw object
    param_job(read_idf(path_idf), read_epw(path_epw))
}

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$version`
## ------------------------------------------------

## Not run: 
param$version()

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$seed`
## ------------------------------------------------

## Not run: 
param$seed()

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$weather`
## ------------------------------------------------

## Not run: 
param$weather()

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$param`
## ------------------------------------------------

## Not run: 

param$param(
    Material := .(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
    ),
   "Supply Fan 1" = .(fan_total_efficiency = c(0.1, 0.5, 0.8))
)

# specify parameter values
param$param(
    Material := .(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
     ),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8)),
    .names = c("thickness", "conduct", "fan_eff")
)

# each parameter should have the same length of values
try(
param$param(
    Material := list(Thickness = c(0.1, 0.2)),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8))
)
)

# use all combinations of parameters
param$param(
    Material := list(
        Thickness = seq(0.1, 1, length.out = 3),
        Conductivity = seq(0.1, 0.6, length.out = 3)
    ),
    "Supply Fan 1" = list(fan_total_efficiency = c(0.1, 0.5, 0.8)),
    .cross = TRUE
)

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$apply_measure`
## ------------------------------------------------

## Not run: 
# create a measure to change the orientation of the building
rotate_building &lt;- function(idf, degree = 0L) {
    if (!idf$is_valid_class("Building")) {
       stop("Input model does not have a Building object")
    }

    if (degree &gt; 360 || degree &lt; -360 ) {
        stop("Input degree should in range [-360, 360]")
    }

    cur &lt;- idf$Building$North_Axis

    new &lt;- cur + degree

    if (new &gt; 360) {
        new &lt;- new %% 360
        warning("Calculated new north axis is greater than 360. ",
            "Final north axis will be ", new
        )
    } else if (new &lt; -360) {
        new &lt;- new %% -360
        warning("Calculated new north axis is smaller than -360. ",
            "Final north axis will be ", new
        )
    }

    idf$Building$North_Axis &lt;- new

    idf
}

# apply measure
# this will create 12 models
param$apply_measure(rotate_building, degree = seq(30, 360, 30))

# apply measure with new names specified
param$apply_measure(rotate_building, degree = seq(30, 360, 30),
    .names = paste0("rotate_", seq(30, 360, 30))
)

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$models`
## ------------------------------------------------

## Not run: 
param$models()

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$cases`
## ------------------------------------------------

## Not run: 
param$cases()

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$save`
## ------------------------------------------------

## Not run: 
# save all parametric models with each model in a separate folder
param$save(tempdir())

# save all parametric models with all models in the same folder
param$save(tempdir(), separate = FALSE)

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$run`
## ------------------------------------------------

## Not run: 
# run parametric simulations
param$run(wait = TRUE, echo = FALSE)

# run in background
param$run(wait = FALSE)
# get detailed job status by printing
print(param)

## End(Not run)


## ------------------------------------------------
## Method `ParametricJob$print`
## ------------------------------------------------

## Not run: 
param$print()

Sys.sleep(10)
param$print()

## End(Not run)

</code></pre>

<hr>
<h2 id='parse_dots_value'>Parse object field values given in list format</h2><span id='topic+parse_dots_value'></span>

<h3>Description</h3>

<p>Parse object field values given in list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dots_value(
  ...,
  .scalar = TRUE,
  .pair = FALSE,
  .ref_assign = TRUE,
  .unique = FALSE,
  .empty = FALSE,
  .env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_dots_value_+3A_...">...</code></td>
<td>
<p>Lists of object definitions. Each list should be named
with a valid class/object id/name. ID should be denoted in style
<code>..ID</code>. There is a special element <code>.comment</code> in each list, which will
be used as new comments of the object. If <code>.ref_assign</code> is <code>TRUE</code>,
<code style="white-space: pre;">&#8288;:=&#8288;</code> can be used to group ids/names:
</p>

<ul>
<li><p> When <code>.type</code> equals <code>"class"</code>, LHS multiple class indices/names should be
wrapped by <code>.()</code>, <code>c()</code>.
</p>
</li>
<li><p> When <code>.type</code> equals <code>"object"</code>, LHS multiple object ids/names should be
wrapped by <code>.()</code> or <code>c()</code>. LHS <strong>SINGLE</strong> class name should be
wrapped by <code>..()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.scalar">.scalar</code></td>
<td>
<p>If <code>TRUE</code>, make sure the value of each field in the object is a
scalar value. If <code>FALSE</code>, <code>value_chr</code> and <code>value_num</code> column will be
list type. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.pair">.pair</code></td>
<td>
<p>Only works when <code>.scalar</code> is <code>FALSE</code>. If <code>.pair</code> is <code>TRUE</code>,
vector field values will be paired to each id/name on the LHS. In this
case, <code>value_chr</code> and <code>value_num</code> will be character type and double
type, respectively. When there is only one id/name on the LHS, it will
be replicated to match the length of the value vector. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.ref_assign">.ref_assign</code></td>
<td>
<p>If <code>TRUE</code>, allow using <code style="white-space: pre;">&#8288;:=&#8288;</code> to gather multiple
classes/objects on the LHS when defining the objects. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.unique">.unique</code></td>
<td>
<p>If <code>TRUE</code>, make sure there are no duplicated classes/objects in
the input. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.empty">.empty</code></td>
<td>
<p>If <code>TRUE</code>, allow using an empty list, i.e. <code>list()</code> to define an
object with all default values. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="parse_dots_value_+3A_.env">.env</code></td>
<td>
<p>An environment specifying the environment to evaluate the <code>...</code>.
Default: <code><a href="base.html#topic+parent.frame">parent.frame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 2 element <code>object</code> and <code>value</code> which is a
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with object data and value data respectively.
</p>

<hr>
<h2 id='path_eplus'>Get file path from EnergyPlus installation directory</h2><span id='topic+path_eplus'></span><span id='topic+path_eplus_processor'></span><span id='topic+path_eplus_example'></span><span id='topic+path_eplus_weather'></span><span id='topic+path_eplus_dataset'></span>

<h3>Description</h3>

<p>Get file path from EnergyPlus installation directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_eplus(ver, ..., strict = FALSE)

path_eplus_processor(ver, ..., strict = FALSE)

path_eplus_example(ver, file, strict = FALSE)

path_eplus_weather(ver, file, strict = FALSE)

path_eplus_dataset(ver, file, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_eplus_+3A_ver">ver</code></td>
<td>
<p>An acceptable EnergyPlus version or an EnergyPlus installation
directory</p>
</td></tr>
<tr><td><code id="path_eplus_+3A_...">...</code></td>
<td>
<p>File paths passed to <code><a href="base.html#topic+file.path">base::file.path()</a></code>.</p>
</td></tr>
<tr><td><code id="path_eplus_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, an error will be issued if the specified file does
not exist</p>
</td></tr>
<tr><td><code id="path_eplus_+3A_file">file</code></td>
<td>
<p>A single string of file name.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>path_eplus()</code> returns the file path specified in EnergyPlus installation
directory.
</p>
</li>
<li> <p><code>path_eplus_processor()</code> is the same as <code>path_eplus()</code> expect it
automatically prepend the executable extension, i.e. <code>.exe</code> on Windows and
empty on macOS and Linux.
</p>
</li>
<li> <p><code>path_eplus_example()</code> returns the file path specified under the <code>ExampleFiles</code>
folder in EnergyPlus installation directory.
</p>
</li>
<li> <p><code>path_eplus_weather()</code> returns the file path specified under the
<code>WeatherData</code> folder in EnergyPlus installation directory.
</p>
</li>
<li> <p><code>path_eplus_dataset()</code> returns the file path specified under the
<code>DataSets</code> folder in EnergyPlus installation directory.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path_eplus("8.8", "Energy+.idd")

path_eplus_processor("8.8", "EPMacro", strict = TRUE)
path_eplus_processor("8.8", "PreProcess", "GrndTempCalc", "Slab", strict = TRUE)

path_eplus_example("8.8", "1ZoneUncontrolled.idf")
path_eplus_example("8.8", "BasicFiles/Exercise1A.idf")

path_eplus_weather("8.8", "USA_CA_San.Francisco.Intl.AP.724940_TMY3.ddy")

path_eplus_dataset("8.8", "Boilers.idf")
path_eplus_dataset("8.8", "FMUs/MoistAir.fmu")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.ErrFile'>Print EnergyPlus Error File</h2><span id='topic+print.ErrFile'></span>

<h3>Description</h3>

<p><code>ErrFile</code> is mainly used to extract and print data in an EnergyPlus Error
File (<code>.err</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ErrFile'
print(x, brief = FALSE, info = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ErrFile_+3A_x">x</code></td>
<td>
<p>An <code>ErrFile</code> created using <code><a href="#topic+read_err">read_err()</a></code>.</p>
</td></tr>
<tr><td><code id="print.ErrFile_+3A_brief">brief</code></td>
<td>
<p>If <code>TRUE</code>, only summary data is printed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.ErrFile_+3A_info">info</code></td>
<td>
<p>If <code>FALSE</code>, informative messages are excluded. Only warnings and
errors are printed. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.ErrFile_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ErrFile</code> object, invisibly.
</p>

<hr>
<h2 id='purge_idf_object'>Purge not-used resource objects</h2><span id='topic+purge_idf_object'></span>

<h3>Description</h3>

<p>Purge not-used resource objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purge_idf_object(idd_env, idf_env, dt_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="purge_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="purge_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="purge_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='rdd_to_load'>Format RddFile Object to Standard Input for <code>Idf$load()</code> Method</h2><span id='topic+rdd_to_load'></span><span id='topic+mdd_to_load'></span>

<h3>Description</h3>

<p><code>rdd_to_load()</code> and <code>mdd_to_load()</code> takes a <code>RddFile</code> and <code>MddFile</code> object
respectively and format it into a <a href="data.table.html#topic+data.table">data.table</a> in
acceptable format for <code style="white-space: pre;">&#8288;$load()&#8288;</code> method in <a href="#topic+Idf">Idf</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_to_load(rdd, key_value, reporting_frequency)

mdd_to_load(
  mdd,
  reporting_frequency,
  class = c("Output:Meter", "Output:Meter:MeterFileOnly", "Output:Meter:Cumulative",
    "Output:Meter:Cumulative:MeterFileOnly")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_to_load_+3A_rdd">rdd</code>, <code id="rdd_to_load_+3A_mdd">mdd</code></td>
<td>
<p>A <code>RddFile</code> object created using <code><a href="#topic+read_rdd">read_rdd()</a></code> and a <code>MddFile</code>
object created using <code><a href="#topic+read_mdd">read_mdd()</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="rdd_to_load_+3A_key_value">key_value</code></td>
<td>
<p>Key value name for <strong>all</strong> variables. If not specified and
the <code>key_value</code> column in the input <code>RddFile</code> object will be used. If
<code>key_value</code> column does not exist, <code>"*"</code> are used for all variables.</p>
</td></tr>
<tr><td><code id="rdd_to_load_+3A_reporting_frequency">reporting_frequency</code></td>
<td>
<p>Variable value reporting frequency for <strong>all</strong>
variables. If not specified and the <code>reporting_freqency</code> column in the input
<code>RddFile</code> object will be used. If <code>reporting_freqency</code> column does not exist,
<code>"Timestep"</code> are used for all variables. All possible values: <code>"Detailed"</code>,
<code>"Timestep"</code>, <code>"Hourly"</code>, <code>"Daily"</code>, <code>"Monthly"</code>, <code>"RunPeriod"</code>,
<code>"Environment"</code>, and <code>"Annual"</code>.</p>
</td></tr>
<tr><td><code id="rdd_to_load_+3A_class">class</code></td>
<td>
<p>Class name for meter output. All possible values:
<code>"Output:Meter"</code>, <code>"Output:Meter:MeterFileOnly"</code>,
<code>"Output:Meter:Cumulative"</code>, and <code>"Output:Meter:Cumulative:MeterFileOnly"</code>.
Default: <code>"Output:Meter"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="data.table.html#topic+data.table">data.table</a> with 5 columns with an additional
attribute named <code>eplus_version</code> extracted from the original <code>RddFile</code> and
<code>MddFile</code>:
</p>

<ul>
<li> <p><code>id</code>: Integer type. Used to distinguish each object definition.
</p>
</li>
<li> <p><code>class</code>: Character type. Class names, e.g. <code>Output:Variable</code> and
<code>Output:Meter</code>.
</p>
</li>
<li> <p><code>index</code>: Integer type. Field indices.
</p>
</li>
<li> <p><code>field</code>: Character type. Field names.
</p>
</li>
<li> <p><code>value</code>: Character type. The value of each field to be added.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read an example distributed with eplusr
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")
idf &lt;- read_idf(path_idf)

# run Design-Day-Only simulation silently
job &lt;- idf$run(NULL, tempdir(), echo = FALSE)

# read RDD and MDD
rdd &lt;- job$read_rdd()
mdd &lt;- job$read_mdd()

# perform subsetting on the variables
# e.g.:
rdd_sub &lt;- rdd[grepl("Site", variable)]
mdd_sub &lt;- mdd[grepl("Electricity", variable)]

# use newly added helper `rdd_to_load()` and `mdd_to_load()` and `$load()` to
# add `Output:Variable` and `Output:Meter*`
idf$load(rdd_to_load(rdd_sub))
idf$load(mdd_to_load(mdd_sub))

# default `Key Value` is `"*"` and `Reporting Frequency` is `Timestep`
# can overwrite using `key_value` and `reporting_freqency` arg
rdd_to_load(rdd_sub, key_value = "Environment", reporting_frequency = "hourly")

# if input has column `key_value`, default is to use it, unless `key_value` is
# explicitly specified
rdd_to_load(rdd_sub[, key_value := "Environment"])
rdd_to_load(rdd_sub[, key_value := "Environment"], key_value = "*")

# `reporting_frequency` arg works in the same way as `key_value` arg, i.e.:
# if input has column `reporting_frequency`, use it, unless
# `reporting_frequency` is explicitly specified
rdd_to_load(rdd_sub[,  reporting_frequency := "monthly"])
rdd_to_load(rdd_sub[,  reporting_frequency := "monthly"], reporting_frequency = "detailed")

# if input has column `key_value`, default is to use it, unless `key_value` is
# explicitly specified
rdd_to_load(rdd_sub[, key_value := "Environment"])
rdd_to_load(rdd_sub[, key_value := "Environment"], key_value = "*")

# meter class can be further specified using `class` arg
mdd_to_load(mdd_sub, class = "Output:Meter:MeterFileOnly")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_epw'>Read and Parse EnergyPlus Weather File (EPW)</h2><span id='topic+read_epw'></span>

<h3>Description</h3>

<p><code>read_epw()</code> parses an EPW file and returns an <code>Epw</code> object. The parsing
process is extremely inspired by [EnergyPlus/WeatherManager.cc] with some
simplifications. For more details on <code>Epw</code>, please see <a href="#topic+Epw">Epw</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_epw(path, encoding = "unknown")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_epw_+3A_path">path</code></td>
<td>
<p>A path of an EnergyPlus <code>EPW</code> file.</p>
</td></tr>
<tr><td><code id="read_epw_+3A_encoding">encoding</code></td>
<td>
<p>The file encoding of input IDD. Should be one of <code>"unknown"</code>,
<code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that
the file is encoded in the native encoding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Epw</code> object.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Epw">Epw</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read an EPW file from EnergyPlus v8.8 installation folder
if (is_avail_eplus(8.8)) {
    path_epw &lt;- file.path(
        eplus_config(8.8)$dir,
        "WeatherData",
        "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
   )
   read_epw(path_epw)
}

# read an EPW file from EnergyPlus website
path_base &lt;- "https://energyplus.net/weather-download"
path_region &lt;- "north_and_central_america_wmo_region_4/USA/CA"
path_file &lt;- "USA_CA_San.Francisco.Intl.AP.724940_TMY3/USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
path_epw &lt;- file.path(path_base, path_region, path_file)
read_epw(path_epw)

## End(Not run)

</code></pre>

<hr>
<h2 id='read_err'>Read an EnergyPlus Simulation Error File</h2><span id='topic+read_err'></span>

<h3>Description</h3>

<p><code>read_err()</code> takes a file path of EnergyPlus simulation error file, usually
with an extension <code>.err</code>, parses it and returns an <code>ErrFile</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_err(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_err_+3A_path">path</code></td>
<td>
<p>a file path of EnergyPlus simulation error file, usually
with an extension <code>.err</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, an <code>ErrFile</code> object is a <a href="data.table.html#topic+data.table">data.table</a>
with 6 columns and 6 additional attributes:
</p>
<p>6 Columns:
</p>

<ul>
<li> <p><code>index</code>: Integer. Index of messages.
</p>
</li>
<li> <p><code>envir_index</code>: Integer. Index of simulation environments.
</p>
</li>
<li> <p><code>envir</code>: Character. Names of simulation environments.
</p>
</li>
<li> <p><code>level_index</code>: Integer. Index for each severe level.
</p>
</li>
<li> <p><code>level</code>: Character. Name of severe levels. Possible values: <code>Info</code>,
<code>Warning</code>, <code>Severe</code>, and etc.
</p>
</li>
<li> <p><code>message</code>: Character. Error messages.
</p>
</li></ul>

<p>6 Attributes:
</p>

<ul>
<li> <p><code>path</code>: A single string. The path of input file.
</p>
</li>
<li> <p><code>eplus_version</code>: A <a href="base.html#topic+numeric_version">numeric_version</a> object. The
version of EnergyPlus used during the simulation.
</p>
</li>
<li> <p><code>eplus_build</code>: A single string. The build tag of EnergyPlus used during the
simulation.
</p>
</li>
<li> <p><code>datetime</code>: A DateTime (POSIXct). The time when the simulation started.
</p>
</li>
<li> <p><code>idd_version</code>: A <a href="base.html#topic+numeric_version">numeric_version</a>. The version of
IDD used during the simulation.
</p>
</li>
<li> <p><code>successful</code>: <code>TRUE</code> when the simulation ended successfully, and <code>FALSE</code>
otherwise.
</p>
</li>
<li> <p><code>terminated</code>: <code>TRUE</code> when the simulation was terminated, and <code>FALSE</code>
otherwise.
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>ErrFile</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# run simulation and get the err file
idf_name &lt;- "1ZoneUncontrolled.idf"
epw_name &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
idf_path &lt;- file.path(eplus_config(8.8)$dir, "ExampleFiles", idf_name)
epw_path &lt;- file.path(eplus_config(8.8)$dir, "WeatherData", epw_name)
job &lt;- eplus_job(idf_path, epw_path)
job$run(dir = tempdir())

# read the err file
read_err(job$locate_output(".err"))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_idf'>Read an EnergyPlus Input Data File (IDF)</h2><span id='topic+read_idf'></span>

<h3>Description</h3>

<p><code>read_idf</code> takes an EnergyPlus Input Data File (IDF) as input and returns an
<code>Idf</code> object. For more details on <code>Idf</code> object, please see <a href="#topic+Idf">Idf</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_idf(path, idd = NULL, encoding = "unknown")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_idf_+3A_path">path</code></td>
<td>
<p>Either a path, a connection, or literal data (either a single
string or a raw vector) to an EnergyPlus Input Data File (IDF). If a
file path, that file usually has a extension <code>.idf</code>.</p>
</td></tr>
<tr><td><code id="read_idf_+3A_idd">idd</code></td>
<td>
<p>Any acceptable input of <code><a href="#topic+use_idd">use_idd()</a></code>. If <code>NULL</code>, which is the
default, the version of IDF will be passed to <code><a href="#topic+use_idd">use_idd()</a></code>. If the
input is an <code>.ddy</code> file which does not have a version field, the
latest version of <a href="#topic+Idf">Idf</a> cached will be used.</p>
</td></tr>
<tr><td><code id="read_idf_+3A_encoding">encoding</code></td>
<td>
<p>The file encoding of input IDD. Should be one of <code>"unknown"</code>,
<code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that
the file is encoded in the native encoding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, Imf file is not fully supported. All EpMacro lines will be treated
as normal comments of the nearest downwards object. If input is an Imf file,
a warning will be given during parsing. It is recommended to convert the Imf
file to an Idf file and use <a href="#topic+ParametricJob">ParametricJob</a> class to conduct
parametric analysis.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Idf">Idf</a> object.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idf">Idf</a> class for modifying EnergyPlus model. <code><a href="#topic+use_idd">use_idd()</a></code> and
<code><a href="#topic+download_idd">download_idd()</a></code> for downloading and parsing EnergyPlus IDD file.
<code><a href="#topic+use_eplus">use_eplus()</a></code> for configuring which version of EnergyPlus to use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example model shipped with eplusr from EnergyPlus v8.8
idf_path &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr") # v8.8

# if neither EnergyPlus v8.8 nor Idd v8.8 was found, error will occur
# if EnergyPlus v8.8 is found but Idd v8.8 was not, `Energy+.idd` in EnergyPlus
# installation folder will be used for pasing
# if Idd v8.8 is found, it will be used automatically
is_avail_eplus("8.8")
is_avail_idd("8.8")

read_idf(idf_path)

# argument `idd` can be specified explicitly using `use_idd()`
read_idf(idf_path, idd = use_idd("8.8"))

# you can set `download` arugment to "auto" in `use_idd()` if you want to
# automatically download corresponding IDD file when necessary
read_idf(idf_path, use_idd("8.8", download = "auto"))

# Besides use a path to an IDF file, you can also provide IDF in literal
# string format
idf_string &lt;-
    "
    Version, 8.8;
    Building,
        Building;                !- Name
    "

read_idf(idf_string, use_idd("8.8", download = "auto"))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_idfeditor_copy'>Parse objects from IDF Editor</h2><span id='topic+read_idfeditor_copy'></span>

<h3>Description</h3>

<p>Parse objects from IDF Editor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_idfeditor_copy(idd_env, idf_env, version = NULL, in_ip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_idfeditor_copy_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="read_idfeditor_copy_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="read_idfeditor_copy_+3A_version">version</code></td>
<td>
<p>The version of IDF file open by IDF Editor, e.g. <code>"8.6"</code>,
<code>"8.8.0"</code>. If <code>NULL</code>, assume that the file has the same
version as current <code>Idf</code> object. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="read_idfeditor_copy_+3A_in_ip">in_ip</code></td>
<td>
<p>Set to <code>TRUE</code> if the IDF file is open with <code>Inch-Pound</code>
view option toggled. Numeric values will automatically
converted to SI units if necessary. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The copyied object data from IDF Editor in a named list of 3
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s, i.e. <code>object</code>, <code>value</code> and <code>reference</code>.
</p>


<h3>Note</h3>

<p>References in the input is not parsed and <code>reference</code> in the returned list is
always a zero-row table.
</p>

<hr>
<h2 id='read_rdd'>Read an EnergyPlus Report Data Dictionary File</h2><span id='topic+read_rdd'></span><span id='topic+read_mdd'></span>

<h3>Description</h3>

<p><code>read_rdd()</code> takes a file path of EnergyPlus Report Data Dictionary (RDD)
file, parses it and returns a <code>RddFile</code> object. <code>read_mdd()</code> takes a file
path of EnergyPlus Meter Data Dictionary (MDD) file, parses it and returns a
<code>MddFile</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rdd(path)

read_mdd(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_rdd_+3A_path">path</code></td>
<td>
<p>For <code>read_rdd()</code>, a file path of EnergyPlus EnergyPlus Report Data
Dictionary file with an extension <code>.rdd</code>. For <code>read_mdd()</code>, a file path of
EnergyPlus EnergyPlus Meter Data Dictionary file with an extension <code>.mdd</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, a <code>RddFile</code> and <code>MddFile</code> object is a
<a href="data.table.html#topic+data.table">data.table</a> with 5 columns and 3 additional
attributes:
</p>
<p>5 Columns:
</p>
<p>*<code>index</code>: Integer. Index of each variable.
</p>

<ul>
<li> <p><code>reported_time_step</code>: Character. Reported time step for the variables.
Possible value: <code>Zone</code> and <code>HVAC</code>.
</p>
</li>
<li> <p><code>report_type</code>: Character. Report types. Possible value: <code>Average</code>, <code>Sum</code>
and <code>Meter</code>. Note that <code>Meter</code> is only for MDD file. All variables will
have <code>report_type</code> being <code>Meter</code>.
</p>
</li>
<li> <p><code>variable</code>: Character. Report variable names.
</p>
</li>
<li> <p><code>units</code>: Character. Units of reported values. <code>NA</code> if report values do not
have units.
</p>
</li></ul>

<p>3 Attributes:
</p>

<ul>
<li> <p><code>eplus_version</code>: A <a href="base.html#topic+numeric_version">numeric_version</a> object. The
version of EnergyPlus used during the simulation.
</p>
</li>
<li> <p><code>eplus_build</code>: A single string. The build tag of EnergyPlus used during the
simulation.
</p>
</li>
<li> <p><code>datetime</code>: A DateTime (POSIXct). The time when the simulation started.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>read_rdd()</code>, an <code>RddFile</code> object. For <code>read_mdd()</code>, a <code>MddFile</code>
object.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# run simulation and get the err file
idf_name &lt;- "1ZoneUncontrolled.idf"
epw_name &lt;-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
idf_path &lt;- path_eplus_example("8.8", idf_name)
epw_path &lt;- path_eplus_weather("8.8", epw_name)
job &lt;- eplus_job(idf_path, epw_path)
job$run(dir = tempdir())

# read the err file
read_rdd(job$locate_output(".rdd"))
read_mdd(job$locate_output(".mdd"))

## End(Not run)
</code></pre>

<hr>
<h2 id='reload'>Reload Idf data</h2><span id='topic+reload'></span>

<h3>Description</h3>

<p>Reload Idf data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reload(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reload_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+Idd">Idd</a>, <a href="#topic+IddObject">IddObject</a>, <a href="#topic+Idf">Idf</a>, <a href="#topic+IdfObject">IdfObject</a>, <a href="#topic+Epw">Epw</a>,
<a href="#topic+EplusJob">EplusJob</a>, <a href="#topic+EplusGroupJob">EplusGroupJob</a> or <a href="#topic+ParametricJob">ParametricJob</a> object. Any object of
other class will be directly returned without any modifications.</p>
</td></tr>
<tr><td><code id="reload_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Currently not
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>eplusr relies heavily on the <a href="data.table.html#topic+data.table">data.table</a> package.
The core data of all main classes in eplusr are saved as
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s. This introduces a problem when loading saved
<a href="#topic+Idf">Idf</a> objects or other class objects via an <code style="white-space: pre;">&#8288;*.RDS&#8288;</code> and <code style="white-space: pre;">&#8288;*.RData&#8288;</code> file on
disk: the stored <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s lose their column
over-allocation. <code>reload()</code> is a helper function that calls
<code><a href="data.table.html#topic+setDT">data.table::setDT()</a></code> on all internal <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s to make
sure they are initialized properly.
</p>
<p>It is recommended to call <code>reload()</code> on each <a href="#topic+Idd">Idd</a>, <a href="#topic+Idf">Idf</a> and other
class object in eplusr loaded with <code><a href="base.html#topic+readRDS">readRDS()</a></code> or <code><a href="base.html#topic+load">load()</a></code>, to make sure all
eplusr's functionaries works properly.
</p>


<h3>Value</h3>

<p>The input object with its internal <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s
properly initialized.
</p>

<hr>
<h2 id='remove_duplicated_objects'>Remove duplicated objects in inputs</h2><span id='topic+remove_duplicated_objects'></span>

<h3>Description</h3>

<p>Remove duplicated objects in inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicated_objects(idd_env, idf_env, dt_object, dt_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_duplicated_objects_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="remove_duplicated_objects_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="remove_duplicated_objects_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="remove_duplicated_objects_+3A_dt_value">dt_value</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains value data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified input data in a named list of 2
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s, i.e. <code>object</code> and <code>value</code>.
</p>

<hr>
<h2 id='remove_empty_fields'>Remove trailing empty object fields</h2><span id='topic+remove_empty_fields'></span>

<h3>Description</h3>

<p>Remove trailing empty object fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty_fields(idd_env, idf_env, dt_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_empty_fields_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="remove_empty_fields_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="remove_empty_fields_+3A_dt_value">dt_value</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains value data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>

<hr>
<h2 id='rename_idf_object'>Rename existing objects</h2><span id='topic+rename_idf_object'></span>

<h3>Description</h3>

<p>Rename existing objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_idf_object(
  idd_env,
  idf_env,
  dt_object,
  level = eplusr_option("validate_level")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="rename_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="rename_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="rename_idf_object_+3A_level">level</code></td>
<td>
<p>Validate level. Default: <code>eplusr_option("validate_level")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='run_idf'>Run simulations of EnergyPlus models.</h2><span id='topic+run_idf'></span><span id='topic+run_multi'></span>

<h3>Description</h3>

<p>Run simulations of EnergyPlus models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_idf(
  model,
  weather,
  output_dir,
  design_day = FALSE,
  annual = FALSE,
  expand_obj = TRUE,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)

run_multi(
  model,
  weather,
  output_dir,
  design_day = FALSE,
  annual = FALSE,
  expand_obj = TRUE,
  wait = TRUE,
  echo = TRUE,
  eplus = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_idf_+3A_model">model</code></td>
<td>
<p>A path (for <code>run_idf()</code>) or a vector of paths (for
<code>run_multi()</code>) of EnergyPlus IDF or IMF files.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_weather">weather</code></td>
<td>
<p>A path (for <code>run_idf()</code>) or a vector of paths (for
<code>run_multi()</code>) of EnergyPlus EPW weather files.
If set to <code>NULL</code>, design-day-only simulation will be triggered,
regardless of the <code>design-day</code> value.
For <code>run_multi()</code>, <code>weather</code> can also be a single EPW file path. In
this case, that weather will be used for all simulations; otherwise,
<code>model</code> and <code>weather</code> should have the same length. You can set to
design-day-only simulation to some specific simulations by setting the
corresponding weather to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_output_dir">output_dir</code></td>
<td>
<p>Output directory path (for <code>rum_idf()</code>) or paths (for
<code>run_mult()</code>). If NULL, the directory of input model is used. For
<code>run_multi()</code>, <code>output_dir</code>, if not <code>NULL</code>, should have the same
length as <code>model</code>. Any duplicated combination of <code>model</code> and
<code>output_dir</code> is prohibited.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_design_day">design_day</code></td>
<td>
<p>Force design-day-only simulation. For <code>rum_multi()</code>,
<code>design_day</code> can also be a logical vector which has the same length as
<code>model</code>. Note that <code>design_day</code> and <code>annual</code> cannot be all <code>TRUE</code> at
the same time. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_annual">annual</code></td>
<td>
<p>Force annual simulation. For <code>rum_multi()</code>,
<code>annual</code> can also be a logical vector which has the same length as
<code>model</code>. Note that <code>design_day</code> and <code>annual</code> cannot be all <code>TRUE</code> at
the same time. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_expand_obj">expand_obj</code></td>
<td>
<p>Whether to run ExpandObject preprocessor before simulation.
Default: TRUE.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_wait">wait</code></td>
<td>
<p>If <code>TRUE</code>, R will hang on and wait all EnergyPlus simulations
finish. If <code>FALSE</code>, all EnergyPlus simulations are run in the
background, and a <a href="processx.html#topic+process">process</a> object is returned.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_echo">echo</code></td>
<td>
<p>Only applicable when <code>wait</code> is <code>TRUE</code>. Whether to show standard
output and error from EnergyPlus for <code>run_idf()</code> and simulation status
for <code>run_multi()</code>. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="run_idf_+3A_eplus">eplus</code></td>
<td>
<p>An acceptable input (for <code>run_idf()</code>) or inputs (for
<code>run_multi()</code>) of <code><a href="#topic+use_eplus">use_eplus()</a></code> and <code><a href="#topic+eplus_config">eplus_config()</a></code>. If <code>NULL</code>, which
is the default, the version of EnergyPlus to use is determined by the
version of input model. For <code>run_multi()</code>, <code>eplus</code>, if not <code>NULL</code>,
should have the same length as <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>run_idf()</code> is a wrapper of EnergyPlus itself, plus various pre-processors
and post-processors which enables to run EnergyPlus model with different
options.
</p>
<p><code>run_multi()</code> provides the functionality of running multiple models in
parallel.
</p>
<p>It is suggested to run simulations using <a href="#topic+EplusJob">EplusJob</a> class and <a href="#topic+EplusGroupJob">EplusGroupJob</a>
class, which provide much more detailed controls on the simulation and also
methods to extract simulation outputs.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>run_idf()</code>, if <code>wait</code> is <code>TRUE</code>, a named list of 11 elements:
</p>
</li></ul>

<table>
<tr>
 <td style="text-align: right;">
   No. </td><td style="text-align: left;"> Column </td><td style="text-align: left;"> Type </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: left;"> <code>idf</code> </td><td style="text-align: left;"> <code>character(1)</code> </td><td style="text-align: left;"> Full path of input IDF file </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: left;"> <code>epw</code> </td><td style="text-align: left;"> <code>character(1)</code> or <code>NULL</code> </td><td style="text-align: left;"> Full path of input EPW file </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: left;"> <code>version</code> </td><td style="text-align: left;"> <code>character(1)</code> </td><td style="text-align: left;"> Version of called EnergyPlus </td>
</tr>
<tr>
 <td style="text-align: right;">
   4 </td><td style="text-align: left;"> <code>exit_status</code> </td><td style="text-align: left;"> <code>integer(1)</code> or <code>NULL</code> </td><td style="text-align: left;"> Exit status of EnergyPlus. <code>NULL</code> if terminated or <code>wait</code> is <code>FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   5 </td><td style="text-align: left;"> <code>start_time</code> </td><td style="text-align: left;"> <code>POSIXct(1)</code> </td><td style="text-align: left;"> Start of time of simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   6 </td><td style="text-align: left;"> <code>end_time</code> </td><td style="text-align: left;"> <code>POSIXct(1)</code> or <code>NULL</code> </td><td style="text-align: left;"> End of time of simulation. <code>NULL</code> if <code>wait</code> is <code>FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   7 </td><td style="text-align: left;"> <code>output_dir</code> </td><td style="text-align: left;"> <code>character(1)</code> </td><td style="text-align: left;"> Full path of simulation output directory </td>
</tr>
<tr>
 <td style="text-align: right;">
   8 </td><td style="text-align: left;"> <code>energyplus</code> </td><td style="text-align: left;"> <code>character(1)</code> </td><td style="text-align: left;"> Full path of called EnergyPlus executable </td>
</tr>
<tr>
 <td style="text-align: right;">
   9 </td><td style="text-align: left;"> <code>stdout</code> </td><td style="text-align: left;"> <code>character(1)</code> or <code>NULL</code> </td><td style="text-align: left;"> Standard output of EnergyPlus during simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   10 </td><td style="text-align: left;"> <code>stderr</code> </td><td style="text-align: left;"> <code>character(1)</code> or <code>NULL</code> </td><td style="text-align: left;"> Standard error of EnergyPlus during simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   11 </td><td style="text-align: left;"> <code>process</code> </td><td style="text-align: left;"> <a href="callr.html#topic+r_bg">r_process</a> </td><td style="text-align: left;"> A process object which called EnergyPlus and ran the simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>If <code>wait</code> is <code>FALSE</code>, the <a href="callr.html#topic+r_bg">R process</a> is directly returned.
You can get the results by calling <code>result &lt;- proc$get_result()</code> (<code>proc</code> is
the returned process). Please note that in this case, <code>result$process</code> will
alwasy be <code>NULL</code>. But you can easily assign it by running <code>result$process &lt;- proc</code>
</p>

<ul>
<li><p> For <code>rum_multi()</code>, if <code>wait</code> is TRUE, a
<a href="data.table.html#topic+data.table">data.table</a> of 12 columns:</p>

<table>
<tr>
 <td style="text-align: right;">
   No. </td><td style="text-align: left;"> Column </td><td style="text-align: left;"> Type </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: left;"> <code>index</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Index of simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: left;"> <code>status</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Simulation status </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: left;"> <code>idf</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Full path of input IDF file </td>
</tr>
<tr>
 <td style="text-align: right;">
   4 </td><td style="text-align: left;"> <code>epw</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Full path of input EPW file. <code>NA</code> for design-day-only simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   5 </td><td style="text-align: left;"> <code>version</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Version of EnergyPlus </td>
</tr>
<tr>
 <td style="text-align: right;">
   6 </td><td style="text-align: left;"> <code>exit_status</code> </td><td style="text-align: left;"> <code>integer</code> </td><td style="text-align: left;"> Exit status of EnergyPlus. <code>NA</code> if terminated </td>
</tr>
<tr>
 <td style="text-align: right;">
   7 </td><td style="text-align: left;"> <code>start_time</code> </td><td style="text-align: left;"> <code>POSIXct</code> </td><td style="text-align: left;"> Start of time of simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   8 </td><td style="text-align: left;"> <code>end_time</code> </td><td style="text-align: left;"> <code>POSIXct</code> </td><td style="text-align: left;"> End of time of simulation. </td>
</tr>
<tr>
 <td style="text-align: right;">
   9 </td><td style="text-align: left;"> <code>output_dir</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Full path of simulation output directory </td>
</tr>
<tr>
 <td style="text-align: right;">
   10 </td><td style="text-align: left;"> <code>energyplus</code> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> Full path of called EnergyPlus executable </td>
</tr>
<tr>
 <td style="text-align: right;">
   11 </td><td style="text-align: left;"> <code>stdout</code> </td><td style="text-align: left;"> <code>list</code> </td><td style="text-align: left;"> Standard output of EnergyPlus during simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
   12 </td><td style="text-align: left;"> <code>stderr</code> </td><td style="text-align: left;"> <code>list</code> </td><td style="text-align: left;"> Standard error of EnergyPlus during simulation </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>For column <code>status</code>, there are 4 possible values:
</p>

<ul>
<li> <p><code>"completed"</code>: the simulation job is completed successfully
</p>
</li>
<li> <p><code>"failed"</code>: the simulation job ended with error
</p>
</li>
<li> <p><code>"terminated"</code>: the simulation job started but was terminated
</p>
</li>
<li> <p><code>"cancelled"</code>: the simulation job was cancelled, i.e. did not start at all
</p>
</li></ul>

</li>
<li><p> For <code>run_multi()</code>, if <code>wait</code> is <code>FALSE</code>, a <a href="callr.html#topic+r_bg">r_process</a>
object of background R process which handles all simulation jobs is
returned. You can check if the jobs are completed using <code style="white-space: pre;">&#8288;$is_alive()&#8288;</code> and
get the final data.table using <code style="white-space: pre;">&#8288;$get_result()&#8288;</code> method.
</p>
</li></ul>



<h3>Note</h3>

<p>If your input model has external file dependencies, e.g. FMU, schedule files,
etc. <code>run_idf()</code> and <code>run_multi()</code> will not work if the output directory is
different that where the input mode lives. If this is the case, parse the
model using <code><a href="#topic+read_idf">read_idf()</a></code> and use <a href="#topic+Idf">Idf$run()</a> or <code><a href="#topic+eplus_job">eplus_job()</a></code> instead.
They are able to automatically change the paths of external files to absolute
paths or copy them into the output directory, based on your choice.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>References</h3>

<p><a href="https://github.com/NREL/EnergyPlus/blob/develop/doc/running-energyplus-from-command-line.md">Running EnergyPlus from Command Line (EnergyPlus GitHub Repository)</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+EplusJob">EplusJob</a> class and <a href="#topic+ParametricJob">ParametricJob</a> class which provide a more friendly
interface to run EnergyPlus simulations and collect outputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf_path &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")

if (is_avail_eplus("8.8")) {
    # run a single model
    epw_path &lt;- file.path(
        eplus_config("8.8")$dir,
        "WeatherData",
        "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"
    )

    run_idf(idf_path, epw_path, output_dir = tempdir())

    # run multiple model in parallel
    idf_paths &lt;- file.path(eplus_config("8.8")$dir, "ExampleFiles",
        c("1ZoneUncontrolled.idf", "1ZoneUncontrolledFourAlgorithms.idf")
    )
    epw_paths &lt;- rep(epw_path, times = 2L)
    output_dirs &lt;- file.path(tempdir(), tools::file_path_sans_ext(basename(idf_paths)))
    run_multi(idf_paths, epw_paths, output_dir = output_dirs)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='set_idf_object'>Modifying existing objects</h2><span id='topic+set_idf_object'></span>

<h3>Description</h3>

<p>Modifying existing objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_idf_object(
  idd_env,
  idf_env,
  dt_object,
  dt_value,
  empty = FALSE,
  level = eplusr_option("validate_level"),
  replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="set_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="set_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
<tr><td><code id="set_idf_object_+3A_dt_value">dt_value</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains value data.</p>
</td></tr>
<tr><td><code id="set_idf_object_+3A_empty">empty</code></td>
<td>
<p>If <code>TRUE</code>, trailing empty fields are kept. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="set_idf_object_+3A_level">level</code></td>
<td>
<p>Validate level. Default: <code>eplusr_option("validate_level")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='standardize_idf_value'>Standardize Value Data</h2><span id='topic+standardize_idf_value'></span>

<h3>Description</h3>

<p>Standardize Value Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_idf_value(
  idd_env,
  idf_env,
  dt_value,
  type = c("choice", "reference"),
  keep = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_idf_value_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="standardize_idf_value_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="standardize_idf_value_+3A_dt_value">dt_value</code></td>
<td>
<p>An data.table of object field values.</p>
</td></tr>
<tr><td><code id="standardize_idf_value_+3A_type">type</code></td>
<td>
<p>A character vector to specify what type of values to be
standardized. Should be a subset of <code>c("choice", "reference")</code>.
Default: <code>c("choice", "reference")</code>.</p>
</td></tr>
<tr><td><code id="standardize_idf_value_+3A_keep">keep</code></td>
<td>
<p>If <code>TRUE</code>, the original value will be kept even if it is invalid.
If <code>FALSE</code>, invalid values will be converted into NAs. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>

<hr>
<h2 id='transition'>Perform version transition of EnergyPlus model</h2><span id='topic+transition'></span>

<h3>Description</h3>

<p><code>transition()</code> takes an <a href="#topic+Idf">Idf</a> object or a path of IDF file and a target
version, performs version transitions and returns an <a href="#topic+Idf">Idf</a> object of
specified version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition(idf, ver, keep_all = FALSE, save = FALSE, dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition_+3A_idf">idf</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object or a path of IDF file.</p>
</td></tr>
<tr><td><code id="transition_+3A_ver">ver</code></td>
<td>
<p>A valid EnergyPlus IDD version, e.g. <code>"9"</code>, <code>"8.8"</code>, or <code>"8.8.0"</code>.</p>
</td></tr>
<tr><td><code id="transition_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>TRUE</code>, a list will be return which contains all
<a href="#topic+Idf">Idf</a> objects of intermediate versions. The list will be named using first
two number of that version, e.g. <code>8.1</code>, <code>8.2</code>. If <code>FALSE</code>, only the <a href="#topic+Idf">Idf</a>
object of the version specified by <code>ver</code> will be returned. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="transition_+3A_save">save</code></td>
<td>
<p>If <code>TRUE</code>, the models will be saved into specified directory.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="transition_+3A_dir">dir</code></td>
<td>
<p>Only applicable when <code>save</code> is <code>TRUE</code>. The directory to save the
new IDF files. If the directory does not exist, it will be created before
save. If <code>NULL</code>, the directory of input <a href="#topic+Idf">Idf</a> object or IDF file will be
used. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+Idf">Idf</a> object if <code>keep_all</code> is <code>FALSE</code> or a list of <a href="#topic+Idf">Idf</a> objects
if <code>keep_all</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+version_updater">version_updater()</a></code> which directly call EnergyPlus preprocessor
<code>IDFVersionUpdater</code> to perform the version transitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (any(avail_eplus()) &gt; "7.2") {
    # create an empty IDF
    idf &lt;- empty_idf("7.2")

    # convert it from v7.2 to the latest EnergyPlus installed
    transition(idf, max(avail_eplus()))

    # convert it from v7.2 to the latest EnergyPlus installed and keep all
    # intermediate versions
    transition(idf, max(avail_eplus()), keep_all = TRUE)

    # convert it from v7.2 to the latest EnergyPlus installed and keep all
    # intermediate versions and save all them
    idf$save(tempfile(fileext = ".idf"))
    transition(idf, max(avail_eplus()), keep_all = TRUE,
        save = TRUE, dir = tempdir()
    )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='unique_idf_object'>Remove duplicate objects</h2><span id='topic+unique_idf_object'></span>

<h3>Description</h3>

<p>Remove duplicate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_idf_object(idd_env, idf_env, dt_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_idf_object_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment or list contains IDD tables including class,
field, and reference.</p>
</td></tr>
<tr><td><code id="unique_idf_object_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment or list contains IDF tables including object,
value, and reference.</p>
</td></tr>
<tr><td><code id="unique_idf_object_+3A_dt_object">dt_object</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> that contains object data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <a href="#topic+Idf">Idf</a> data in a named list of 5 elements, i.e. <code>object</code>,
<code>value</code>, <code>reference</code>, <code>changed</code> and <code>updated</code>. First 3 elements are
<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s containing the actual updated <a href="#topic+Idf">Idf</a> data while
<code>changed</code> and <code>updated</code> are integer vectors containing IDs of objects that
have been directly changed and indirectly updated due to references,
respectively.
</p>

<hr>
<h2 id='use_eplus'>Configure which version of EnergyPlus to use</h2><span id='topic+use_eplus'></span><span id='topic+eplus_config'></span><span id='topic+avail_eplus'></span><span id='topic+is_avail_eplus'></span><span id='topic+locate_eplus'></span>

<h3>Description</h3>

<p>Configure which version of EnergyPlus to use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_eplus(eplus)

eplus_config(ver)

avail_eplus()

is_avail_eplus(ver)

locate_eplus()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_eplus_+3A_eplus">eplus</code></td>
<td>
<p>An acceptable EnergyPlus version or an EnergyPlus installation
path.</p>
</td></tr>
<tr><td><code id="use_eplus_+3A_ver">ver</code></td>
<td>
<p>An acceptable EnergyPlus version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_eplus()</code> adds an EnergyPlus version into the EnergyPlus version cache in
eplusr. That cache will be used to get corresponding <a href="#topic+Idd">Idd</a> object when
parsing IDF files and call corresponding EnergyPlus to run models.
</p>
<p><code>eplus_config()</code> returns the a list of configure data of specified version of
EnergyPlus. If no data found, an empty list will be returned.
</p>
<p><code>avail_eplus()</code> returns all versions of available EnergyPlus.
</p>
<p><code>locate_eplus()</code> re-searches all EnergyPlus installations at the <strong>default</strong>
locations and returns versions of EnergyPlus it finds. Please note that all
configure data of EnergyPlus installed at custom locations will be
<strong>removed</strong>.
</p>
<p><code>is_avail_eplus()</code> checks if the specified version of EnergyPlus is
available or not.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>use_eplus()</code> and <code>eplus_config()</code>, an (invisible for
<code>use_eplus()</code>) list of three contains EnergyPlus version, directory and
EnergyPlus executable.  version of EnergyPlus;
</p>
</li>
<li><p> For <code>avail_eplus()</code>, a <a href="base.html#topic+numeric_version">numeric_version</a> vector or <code>NULL</code> if no
available EnergyPlus is found;
</p>
</li>
<li><p> For <code>is_avis_avail_eplus()</code>, a scalar logical vector.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+download_eplus">download_eplus()</a></code> and <code><a href="#topic+install_eplus">install_eplus()</a></code> for downloading and
installing EnergyPlus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add specific version of EnergyPlus
use_eplus("8.9")
use_eplus("8.8.0")

# get configure data of specific EnergyPlus version if avaiable
eplus_config("8.6")

## End(Not run)

# get all versions of avaiable EnergyPlus
avail_eplus()

# check if specific version of EnergyPlus is available
is_avail_eplus("8.5")
is_avail_eplus("8.8")

</code></pre>

<hr>
<h2 id='use_idd'>Use a specific EnergyPlus Input Data Dictionary (IDD) file</h2><span id='topic+use_idd'></span><span id='topic+download_idd'></span><span id='topic+avail_idd'></span><span id='topic+is_avail_idd'></span>

<h3>Description</h3>

<p>Use a specific EnergyPlus Input Data Dictionary (IDD) file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_idd(idd, download = FALSE, encoding = "unknown")

download_idd(ver = "latest", dir = ".")

avail_idd()

is_avail_idd(ver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_idd_+3A_idd">idd</code></td>
<td>
<p>Either a path, a connection, or literal data (either a single
string or a raw vector) to an EnergyPlus Input Data Dictionary (IDD)
file, usually named as <code>Energy+.idd</code>, or a valid version of IDD, e.g.
<code>"8.9"</code>, <code>"8.9.0"</code>.</p>
</td></tr>
<tr><td><code id="use_idd_+3A_download">download</code></td>
<td>
<p>If <code>TRUE</code> and argument <code>idd</code>, the IDD file will be
downloaded from <a href="https://github.com/NREL/EnergyPlus">EnergyPlus GitHub Repository</a>,
and saved to <code><a href="base.html#topic+tempdir">tempdir()</a></code>. It will be parsed after it is downloaded
successfully. A special value of <code>"auto"</code> can be given, which will
automatically download corresponding IDD file if the Idd object is
currently not available. It is useful in case when you only want to edit
an EnergyPlus Input Data File (IDF) directly but do not want to install
whole EnergyPlus software. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="use_idd_+3A_encoding">encoding</code></td>
<td>
<p>The file encoding of input IDD. Should be one of <code>"unknown"</code>,
<code style="white-space: pre;">&#8288;"Latin-1" and &#8288;</code>&quot;UTF-8&quot;<code style="white-space: pre;">&#8288;. The default is &#8288;</code>&quot;unknown&quot;' which means that the
file is encoded in the native encoding.</p>
</td></tr>
<tr><td><code id="use_idd_+3A_ver">ver</code></td>
<td>
<p>A valid EnergyPlus version, e.g. <code>"8"</code>, <code>"8.7"</code> or <code>"8.7.0"</code>.
For <code>download_idd()</code>, the special value <code>"latest"</code>, which is default,
means the latest version.</p>
</td></tr>
<tr><td><code id="use_idd_+3A_dir">dir</code></td>
<td>
<p>A directory to indicate where to save the IDD file. Default:
current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_idd()</code> takes a valid version or a path of an EnergyPlus Input Data
Dictionary (IDD) file, usually named &quot;Energy+.idd&quot; and return an <code>Idd</code>
object. For details on <code>Idd</code> class, please see <a href="#topic+Idd">Idd</a>.
</p>
<p><code>download_idd()</code> downloads specified version of EnergyPlus IDD file from
<a href="https://github.com/NREL/EnergyPlus">EnergyPlus GitHub Repository</a>. It is
useful in case where you only want to edit an EnergyPlus Input Data File
(IDF) directly but do not want to install whole EnergyPlus software.
</p>
<p><code>avail_idd()</code> returns versions of all cached <code>Idd</code> object.
</p>
<p><code>is_avail_idd()</code> returns <code>TRUE</code> if input version of IDD file has been parsed
and cached.
</p>
<p>eplusr tries to detect all installed EnergyPlus in default installation
locations when loading. If argument <code>idd</code> is a version, eplusr will try the
follow ways sequentially to find corresponding IDD:
</p>

<ul>
<li><p> The cached <code>Idd</code> object of that version
</p>
</li>
<li> <p><code>"Energy+.idd"</code> file distributed with EnergyPlus of that version (see
<code><a href="#topic+avail_eplus">avail_eplus()</a></code>).
</p>
</li>
<li><p> The <code>"VX-Y-Z-Energy+.idd"</code> file distributed along with IDFVersionUpdater
from the latest EnergyPlus detected.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>use_idd()</code> returns an <code>Idd</code> object
</p>
</li>
<li> <p><code>download_idd()</code> returns an invisible integer <code>0</code> if succeed. Also an
attribute named <code>file</code> which is the full path of the downloaded IDD file;
</p>
</li>
<li> <p><code>avail_idd()</code> returns a <a href="base.html#topic+numeric_version">numeric_version</a> vector
or <code>NULL</code> if no available Idd object found.
</p>
</li>
<li> <p><code>is_avail_idd()</code> returns a single logical vector.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>See Also</h3>

<p><a href="#topic+Idd">Idd</a> Class for parsing, querying and making modifications to
EnergyPlus IDD file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get all available Idd version
avail_idd()

# check if specific version of Idd is available
is_avail_idd("8.5")

# download latest IDD file from EnergyPlus GitHub repo
str(download_idd("latest", tempdir()))

# use specific version of Idd
# only works if EnergyPlus v8.8 has been found or Idd v8.8 exists
use_idd("8.8")

# If Idd object is currently not avail_idd, automatically download IDD file
# from EnergyPlus GitHub repo and parse it
use_idd("8.8", download = "auto")

# now Idd v8.8 should be available
is_avail_idd("8.8")

# get specific version of parsed Idd object
use_idd("8.8")

avail_idd() # should contain "8.8.0"

## End(Not run)
</code></pre>

<hr>
<h2 id='validate_objects'>Validate input IDF data in terms of various aspects</h2><span id='topic+validate_objects'></span>

<h3>Description</h3>

<p>Validate input IDF data in terms of various aspects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_objects(
  idd_env,
  idf_env,
  dt_object = NULL,
  dt_value = NULL,
  required_object = FALSE,
  unique_object = FALSE,
  unique_name = FALSE,
  extensible = FALSE,
  required_field = FALSE,
  auto_field = FALSE,
  type = FALSE,
  choice = FALSE,
  range = FALSE,
  reference = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_objects_+3A_idd_env">idd_env</code></td>
<td>
<p>An environment that contains IDD data</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_idf_env">idf_env</code></td>
<td>
<p>An environment that contains IDF data</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_dt_object">dt_object</code></td>
<td>
<p>A data.table that contains object data to validate. If
<code>NULL</code>, the object data from <code>idf_env</code> will be used, which means to
validate the whole IDF.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_dt_value">dt_value</code></td>
<td>
<p>A data.table that contains value data to validate. If
<code>NULL</code>, the value data from <code>idf_env</code> will be used, which means to
validate the whole IDF.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_required_object">required_object</code></td>
<td>
<p>Whether to check if required objects are missing. This
will only be applied when checking the whole IDF.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_unique_object">unique_object</code></td>
<td>
<p>Whether to check if there are multiple instances of
unique object.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_unique_name">unique_name</code></td>
<td>
<p>Whether to check if there are objects having the same name
in same class.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_extensible">extensible</code></td>
<td>
<p>Whether to check if there are incomplete extensible.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_required_field">required_field</code></td>
<td>
<p>Whether to check if there are missing value for
required fields.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_auto_field">auto_field</code></td>
<td>
<p>Whether to check if there are non-autosizable or
non-autocalculatable fields that are assigned &quot;autosize&quot; or
&quot;autocalculate&quot;.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_type">type</code></td>
<td>
<p>Whether to check if there are input values whose type are not
consistent with definitions in IDD.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_choice">choice</code></td>
<td>
<p>Whether to check if there are invalid choice values.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_range">range</code></td>
<td>
<p>Whether to check if there are numeric values that are out of
ranges specified in IDD.</p>
</td></tr>
<tr><td><code id="validate_objects_+3A_reference">reference</code></td>
<td>
<p>Whether to check if there are values that have invalid
references.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An IdfValidity object.
</p>

<hr>
<h2 id='version_updater'>Run IDFVersionUpdater to Update Model Versions</h2><span id='topic+version_updater'></span>

<h3>Description</h3>

<p><code>version_updater()</code> is a wrapper of IDFVersionUpdater preprocessor
distributed with EnergyPlus. It takes a path of IDF file or an <a href="#topic+Idf">Idf</a> object,
a target version to update to and a directory to save the new models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version_updater(idf, ver, dir = NULL, keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="version_updater_+3A_idf">idf</code></td>
<td>
<p>An <a href="#topic+Idf">Idf</a> object or a path of IDF file.</p>
</td></tr>
<tr><td><code id="version_updater_+3A_ver">ver</code></td>
<td>
<p>A valid EnergyPlus IDD version, e.g. <code>"9"</code>, <code>"8.8"</code>, or <code>"8.8.0"</code>.</p>
</td></tr>
<tr><td><code id="version_updater_+3A_dir">dir</code></td>
<td>
<p>The directory to save the new IDF files. If the directory does not
exist, it will be created before save. If <code>NULL</code>, the directory of input
<a href="#topic+Idf">Idf</a> object or IDF file will be used. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="version_updater_+3A_keep_all">keep_all</code></td>
<td>
<p>If <code>TRUE</code>, a list will be return which contains all
<a href="#topic+Idf">Idf</a> objects of intermediate versions. The list will be named using first
two number of that version, e.g. <code>8.1</code>, <code>8.2</code>. If <code>FALSE</code>, only the <a href="#topic+Idf">Idf</a>
object of the version specified by <code>ver</code> will be returned. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attribute named <code>errors</code> is attached which is a list of
<a href="#topic+read_err">ErrFiles</a> that contain all error messages from transition error
(.VCpErr) files.
</p>


<h3>Value</h3>

<p>An <a href="#topic+Idf">Idf</a> object if <code>keep_all</code> is <code>FALSE</code> or a list of <a href="#topic+Idf">Idf</a> objects
if <code>keep_all</code> is <code>TRUE</code>. An attribute named <code>errors</code> is attached which
contains all error messages from transition error (.VCpErr) files.
</p>


<h3>Author(s)</h3>

<p>Hongyuan Jia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (any(avail_eplus()) &gt; "7.2") {
    # create an empty IDF
    idf &lt;- empty_idf("7.2")
    idf$save(tempfile(fileext = ".idf"))

    # convert it from v7.2 to the latest EnergyPlus installed
    updated &lt;- version_updater(idf, max(avail_eplus()))

    # convert it from v7.2 to the latest EnergyPlus installed and keep all
    # intermediate versions
    updated &lt;- version_updater(idf, max(avail_eplus()), keep_all = TRUE)

    # see transition error messages
    attr(updated, "errors")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='with_option'>Evaluate an expression with temporary eplusr options</h2><span id='topic+with_option'></span><span id='topic+with_silent'></span><span id='topic+with_verbose'></span><span id='topic+without_checking'></span>

<h3>Description</h3>

<p>These functions evaluate an expression with temporary eplusr options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_option(opts, expr)

with_silent(expr)

with_verbose(expr)

without_checking(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_option_+3A_opts">opts</code></td>
<td>
<p>A list of valid input for <code>eplusr::eplusr_option()</code>.</p>
</td></tr>
<tr><td><code id="with_option_+3A_expr">expr</code></td>
<td>
<p>An expression to be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>with_option</code> evaluates an expression with specified eplusr options.
</p>
<p><code>with_silent</code> evaluates an expression with no verbose messages.
</p>
<p><code>with_verbose</code> evaluates an expression with verbose messages.
</p>
<p><code>without_checking</code> evaluates an expression with no checkings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path_idf &lt;- system.file("extdata/1ZoneUncontrolled.idf", package = "eplusr")

# temporarily disable verbose messages
idf &lt;- with_silent(read_idf(path_idf, use_idd("8.8", download = "auto")))

# temporarily disable checkings
without_checking(idf$'BuildingSurface:Detailed' &lt;- NULL)
# OR
with_option(list(validate_level = "none"), idf$'BuildingSurface:Detailed' &lt;- NULL)

## End(Not run)

</code></pre>

<hr>
<h2 id='with_speed'>Evaluates an expression without checking</h2><span id='topic+with_speed'></span>

<h3>Description</h3>

<p>Evaluates an expression without checking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_speed(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_speed_+3A_expr">expr</code></td>
<td>
<p>An expression to be evaluated.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
