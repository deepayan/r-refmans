<!DOCTYPE html><html lang="en"><head><title>Help for package comparator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comparator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comparator-package'><p>comparator: Comparison Functions for Clustering and Record Linkage</p></a></li>
<li><a href='#BinaryComp'><p>Binary String/Sequence Comparator</p></a></li>
<li><a href='#Chebyshev'><p>Chebyshev Numeric Comparator</p></a></li>
<li><a href='#Comparator-class'><p>Virtual Comparator Class</p></a></li>
<li><a href='#Constant'><p>Constant String/Sequence Comparator</p></a></li>
<li><a href='#CppSeqComparator-class'><p>Virtual Class for a Sequence Comparator with a C++ Implementation</p></a></li>
<li><a href='#DamerauLevenshtein'><p>Damerau-Levenshtein String/Sequence Comparator</p></a></li>
<li><a href='#elementwise'><p>Elementwise Similarity/Distance Vector</p></a></li>
<li><a href='#Euclidean'><p>Euclidean Numeric Comparator</p></a></li>
<li><a href='#FuzzyTokenSet'><p>Fuzzy Token Set Comparator</p></a></li>
<li><a href='#gmean'><p>Geometric Mean</p></a></li>
<li><a href='#Hamming'><p>Hamming String/Sequence Comparator</p></a></li>
<li><a href='#hmean'><p>Harmonic Mean</p></a></li>
<li><a href='#InVocabulary'><p>In-Vocabulary Comparator</p></a></li>
<li><a href='#Jaro'><p>Jaro String/Sequence Comparator</p></a></li>
<li><a href='#JaroWinkler'><p>Jaro-Winkler String/Sequence Comparator</p></a></li>
<li><a href='#LCS'><p>Longest Common Subsequence (LCS) Comparator</p></a></li>
<li><a href='#Levenshtein'><p>Levenshtein String/Sequence Comparator</p></a></li>
<li><a href='#Lookup'><p>Lookup String Comparator</p></a></li>
<li><a href='#Manhattan'><p>Manhattan Numeric Comparator</p></a></li>
<li><a href='#Minkowski'><p>Minkowski Numeric Comparator</p></a></li>
<li><a href='#MongeElkan'><p>Monge-Elkan Token Comparator</p></a></li>
<li><a href='#NumericComparator-class'><p>Virtual Numeric Comparator Class</p></a></li>
<li><a href='#OSA'><p>Optimal String Alignment (OSA) String/Sequence Comparator</p></a></li>
<li><a href='#pairwise'><p>Pairwise Similarity/Distance Matrix</p></a></li>
<li><a href='#PairwiseMatrix-class'><p>Pairwise Similarity/Distance Matrix</p></a></li>
<li><a href='#SequenceComparator-class'><p>Virtual Sequence Comparator Class</p></a></li>
<li><a href='#StringComparator-class'><p>Virtual String Comparator Class</p></a></li>
<li><a href='#TokenComparator-class'><p>Virtual Token Comparator Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparison Functions for Clustering and Record Linkage</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neil Marchant &lt;ngmarchant@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements functions for comparing strings, sequences and 
    numeric vectors for clustering and record linkage applications. 
    Supported comparison functions include: generalized edit distances 
    for comparing sequences/strings, Monge-Elkan similarity for fuzzy 
    comparison of token sets, and L-p distances for comparing numeric 
    vectors. Where possible, comparison functions are implemented in 
    C/C++ to ensure good performance.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), proxy (&ge; 0.4), methods, clue (&ge; 0.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ngmarchant/comparator">https://github.com/ngmarchant/comparator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ngmarchant/comparator/issues">https://github.com/ngmarchant/comparator/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'Comparator.R' 'CppSeqComparator.R' 'PairwiseMatrix.R'
'SequenceComparator.R' 'StringComparator.R' 'BinaryComp.R'
'NumericComparator.R' 'Chebyshev.R' 'Constant.R'
'Levenshtein.R' 'DamerauLevenshtein.R' 'Minkowski.R'
'Euclidean.R' 'FuzzyTokenSet.R' 'Hamming.R' 'InVocabulary.R'
'Jaro.R' 'JaroWinkler.R' 'LCS.R' 'Lookup.R' 'Manhattan.R'
'TokenComparator.R' 'MongeElkan.R' 'OSA.R' 'RcppExports.R'
'generalized_mean.R' 'strcompr-package.R' 'util.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-08 01:26:26 UTC; nmarchant</td>
</tr>
<tr>
<td>Author:</td>
<td>Neil Marchant [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-08 21:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='comparator-package'>comparator: Comparison Functions for Clustering and Record Linkage</h2><span id='topic+comparator'></span><span id='topic+comparator-package'></span>

<h3>Description</h3>

<p>Implements functions for comparing strings, sequences and numeric vectors for clustering and record linkage applications. Supported comparison functions include: generalized edit distances for comparing sequences/strings, Monge-Elkan similarity for fuzzy comparison of token sets, and L-p distances for comparing numeric vectors. Where possible, comparison functions are implemented in C/C++ to ensure good performance.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Neil Marchant <a href="mailto:ngmarchant@gmail.com">ngmarchant@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ngmarchant/comparator">https://github.com/ngmarchant/comparator</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ngmarchant/comparator/issues">https://github.com/ngmarchant/comparator/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BinaryComp'>Binary String/Sequence Comparator</h2><span id='topic+BinaryComp'></span>

<h3>Description</h3>

<p>Compares a pair of strings or sequences based on whether they are
identical or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryComp(score = 1, similarity = FALSE, ignore_case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinaryComp_+3A_score">score</code></td>
<td>
<p>a numeric of length 1. Positive distance to return if the
pair of strings/sequences are not identical. Defaults to 1.0.</p>
</td></tr>
<tr><td><code id="BinaryComp_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarities are returned instead of
distances. Specifically <code>score</code> is returned if the strings agree,
and 0.0 is returned otherwise.</p>
</td></tr>
<tr><td><code id="BinaryComp_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>similarity = FALSE</code> (default) the scores can be interpreted
as distances. When <code class="reqn">x = y</code> the comparator returns a distance of 0.0,
and when <code class="reqn">x \neq y</code> the comparator returns <code>score</code>.
</p>
<p>If <code>similarity = TRUE</code> the scores can be interpreted as similarities.
When <code class="reqn">x = y</code> the comparator returns <code>score</code>, and when <code class="reqn">x \neq y</code>
the comparator returns 0.0.
</p>


<h3>Value</h3>

<p>A <code>BinaryComp</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>

<hr>
<h2 id='Chebyshev'>Chebyshev Numeric Comparator</h2><span id='topic+Chebyshev'></span>

<h3>Description</h3>

<p>The Chebyshev distance (a.k.a. L-Inf distance or ) between two vectors
<code class="reqn">x</code> and <code class="reqn">y</code> is the greatest of the absolute differences between each
coordinate:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Chebyshev}(x,y) = \max_i |x_i - y_i|.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Chebyshev()
</code></pre>


<h3>Value</h3>

<p>A <code>Chebyshev</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+NumericComparator-class">NumericComparator</a></code>.
</p>


<h3>Note</h3>

<p>The Chebyshev distance is a limiting case of the <code><a href="#topic+Minkowski">Minkowski</a></code>
distance where <code class="reqn">p \to \infty</code>.
</p>


<h3>See Also</h3>

<p>Other numeric comparators include <code><a href="#topic+Manhattan">Manhattan</a></code>, <code><a href="#topic+Euclidean">Euclidean</a></code> and
<code><a href="#topic+Minkowski">Minkowski</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Distance between two vectors
x &lt;- c(0, 1, 0, 1, 0)
y &lt;- seq_len(5)
Chebyshev()(x, y)

## Distance between rows (elementwise) of two matrices
comparator &lt;- Chebyshev()
x &lt;- matrix(rnorm(25), nrow = 5)
y &lt;- matrix(rnorm(5), nrow = 1)
elementwise(comparator, x, y)

## Distance between rows (pairwise) of two matrices
pairwise(comparator, x, y)

</code></pre>

<hr>
<h2 id='Comparator-class'>Virtual Comparator Class</h2><span id='topic+Comparator-class'></span>

<h3>Description</h3>

<p>This class represents a function for comparing pairs of
objects. It is the base class from which other types of comparators (e.g.
<code><a href="#topic+NumericComparator-class">NumericComparator</a></code> and <code><a href="#topic+StringComparator-class">StringComparator</a></code>) are derived.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a function which takes a pair of arguments <code>x</code> and <code>y</code>, and
returns the elementwise scores.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>a logical of length 1. If TRUE, the comparator is symmetric
in its arguments&mdash;i.e. <code>comparator(x, y)</code> is identical to
<code>comparator(y, x)</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
distances and satisfies <code>comparator(x, x) = 0</code>. The comparator may not
satisfy all of the properties of a distance metric.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
similarity scores.</p>
</dd>
<dt><code>tri_inequal</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator satisfies
the triangle inequality. This is only possible (but not guaranteed) if
<code>distance = TRUE</code> and <code>symmetric = TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='Constant'>Constant String/Sequence Comparator</h2><span id='topic+Constant'></span>

<h3>Description</h3>

<p>A trivial comparator that returns a constant for any pair of strings or
sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Constant(constant = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Constant_+3A_constant">constant</code></td>
<td>
<p>a non-negative numeric vector of length 1. Defaults to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Constant</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>

<hr>
<h2 id='CppSeqComparator-class'>Virtual Class for a Sequence Comparator with a C++ Implementation</h2><span id='topic+CppSeqComparator-class'></span>

<h3>Description</h3>

<p>This class is a trait possessed by SequenceComparators that have a
C++ implementation. SequenceComparators without this trait are implemented
in R, and may be slower to execute.
</p>

<hr>
<h2 id='DamerauLevenshtein'>Damerau-Levenshtein String/Sequence Comparator</h2><span id='topic+DamerauLevenshtein'></span>

<h3>Description</h3>

<p>The Damerau-Levenshtein distance between two strings/sequences <code class="reqn">x</code>
and <code class="reqn">y</code> is the minimum cost of operations (insertions, deletions,
substitutions or transpositions) required to transform <code class="reqn">x</code>
into <code class="reqn">y</code>. It differs from the Levenshtein distance by including
<em>transpositions</em> (swaps) among the allowable operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DamerauLevenshtein(
  deletion = 1,
  insertion = 1,
  substitution = 1,
  transposition = 1,
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DamerauLevenshtein_+3A_deletion">deletion</code></td>
<td>
<p>positive cost associated with deletion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_insertion">insertion</code></td>
<td>
<p>positive cost associated insertion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_substitution">substitution</code></td>
<td>
<p>positive cost associated with substitution of a
character or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_transposition">transposition</code></td>
<td>
<p>positive cost associated with transposing (swapping)
a pair of characters or sequence elements. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_normalize">normalize</code></td>
<td>
<p>a logical. If TRUE, distances are normalized to the
unit interval. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="DamerauLevenshtein_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>A Damerau-Levenshtein similarity is returned if <code>similarity = TRUE</code>, which
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{w_d |x| + w_i |y| - \mathrm{dist}(x, y)}{2},</code>
</p>

<p>where <code class="reqn">|x|</code>, <code class="reqn">|y|</code> are the number of characters in <code class="reqn">x</code> and
<code class="reqn">y</code> respectively, <code class="reqn">\mathrm{dist}</code> is the Damerau-Levenshtein
distance, <code class="reqn">w_d</code> is the cost of a deletion and <code class="reqn">w_i</code> is the cost of
an insertion.
</p>
<p>Normalization of the Damerau-Levenshtein distance/similarity to the unit
interval is also supported by setting <code>normalize = TRUE</code>. The normalization
approach follows Yujian and Bo (2007), and ensures that the distance
remains a metric when the costs of insertion <code class="reqn">w_i</code> and deletion
<code class="reqn">w_d</code> are equal. The normalized distance <code class="reqn">\mathrm{dist}_n</code>
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_n(x, y) = \frac{2 \mathrm{dist}(x, y)}{w_d |x| + w_i |y| + \mathrm{dist}(x, y)},</code>
</p>

<p>and the normalized similarity <code class="reqn">\mathrm{sim}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_n(x, y) = 1 - \mathrm{dist}_n(x, y) = \frac{\mathrm{sim}(x, y)}{w_d |x| + w_i |y| - \mathrm{sim}(x, y)}.</code>
</p>



<h3>Value</h3>

<p>A <code>DamerauLevenshtein</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+Levenshtein">Levenshtein</a></code>.
</p>


<h3>Note</h3>

<p>If the costs of deletion and insertion are equal, this comparator is
symmetric in <code class="reqn">x</code> and <code class="reqn">y</code>. In addition, the normalized and
unnormalized distances satisfy the properties of a metric.
</p>


<h3>References</h3>

<p>Boytsov, L. (2011), &quot;Indexing methods for approximate dictionary searching:
Comparative analysis&quot;, <em>ACM J. Exp. Algorithmics</em> <strong>16</strong>,
Article 1.1.
</p>
<p>Navarro, G. (2001), &quot;A guided tour to approximate string matching&quot;,
<em>ACM Computing Surveys (CSUR)</em>, <strong>33</strong>(1), 31-88.
</p>
<p>Yujian, L. &amp; Bo, L. (2007), &quot;A Normalized Levenshtein Distance Metric&quot;,
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>
<strong>29</strong>, 1091-1095.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code><a href="#topic+Hamming">Hamming</a></code>, <code><a href="#topic+LCS">LCS</a></code>,
<code><a href="#topic+Levenshtein">Levenshtein</a></code> and <code><a href="#topic+OSA">OSA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The Damerau-Levenshtein distance reduces to ordinary Levenshtein distance 
## when the cost of transpositions is high
x &lt;- "plauge"; y &lt;- "plague"
DamerauLevenshtein(transposition = 100)(x, y) == Levenshtein()(x, y)

## Compare car names using normalized Damerau-Levenshtein similarity
data(mtcars)
cars &lt;- rownames(mtcars)
pairwise(DamerauLevenshtein(similarity = TRUE, normalize=TRUE), cars)

## Compare sequences using Damerau-Levenshtein distance
x &lt;- c("G", "T", "G", "C", "T", "G", "G", "C", "C", "C", "A", "T")
y &lt;- c("G", "T", "G", "C", "G", "T", "G", "C", "C", "C", "A", "T")
DamerauLevenshtein()(list(x), list(y))

</code></pre>

<hr>
<h2 id='elementwise'>Elementwise Similarity/Distance Vector</h2><span id='topic+elementwise'></span><span id='topic+elementwise+2CCppSeqComparator+2Clist+2Clist-method'></span><span id='topic+elementwise+2CStringComparator+2Cvector+2Cvector-method'></span><span id='topic+elementwise+2CNumericComparator+2Cmatrix+2Cvector-method'></span><span id='topic+elementwise+2CNumericComparator+2Cvector+2Cmatrix-method'></span><span id='topic+elementwise+2CNumericComparator+2Cvector+2Cvector-method'></span><span id='topic+elementwise+2CChebyshev+2Cmatrix+2Cmatrix-method'></span><span id='topic+elementwise+2CFuzzyTokenSet+2Clist+2Clist-method'></span><span id='topic+elementwise+2CInVocabulary+2Cvector+2Cvector-method'></span><span id='topic+elementwise+2CLookup+2Cvector+2Cvector-method'></span><span id='topic+elementwise+2CMongeElkan+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>Computes elementwise similarities/distances between two collections of
objects (strings, vectors, etc.) using the provided comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elementwise(comparator, x, y, ...)

## S4 method for signature 'CppSeqComparator,list,list'
elementwise(comparator, x, y, ...)

## S4 method for signature 'StringComparator,vector,vector'
elementwise(comparator, x, y, ...)

## S4 method for signature 'NumericComparator,matrix,vector'
elementwise(comparator, x, y, ...)

## S4 method for signature 'NumericComparator,vector,matrix'
elementwise(comparator, x, y, ...)

## S4 method for signature 'NumericComparator,vector,vector'
elementwise(comparator, x, y, ...)

## S4 method for signature 'Chebyshev,matrix,matrix'
elementwise(comparator, x, y, ...)

## S4 method for signature 'FuzzyTokenSet,list,list'
elementwise(comparator, x, y, ...)

## S4 method for signature 'InVocabulary,vector,vector'
elementwise(comparator, x, y, ...)

## S4 method for signature 'Lookup,vector,vector'
elementwise(comparator, x, y, ...)

## S4 method for signature 'MongeElkan,list,list'
elementwise(comparator, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elementwise_+3A_comparator">comparator</code></td>
<td>
<p>a comparator used to compare the objects, which is a
sub-class of <code><a href="#topic+Comparator-class">Comparator</a></code>.</p>
</td></tr>
<tr><td><code id="elementwise_+3A_x">x</code>, <code id="elementwise_+3A_y">y</code></td>
<td>
<p>a collection of objects to compare, typically stored as entries
in an atomic vector, rows in a matrix, or entries in a list. The required
format depends on the type of <code>comparator</code>. If <code>x</code> and <code>y</code> do not contain
the same number of objects, the smaller collection is recycled according
to standard <code>R</code> behavior.</p>
</td></tr>
<tr><td><code id="elementwise_+3A_...">...</code></td>
<td>
<p>other parameters passed on to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Every object in <code>x</code> is compared to every object in <code>y</code> elementwise
(with recycling) using the given comparator, to produce a numeric vector of
scores of length <code class="reqn">max{size(x), size(y)}</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>comparator = CppSeqComparator,x = list,y = list</code>: Specialization for <code><a href="#topic+CppSeqComparator-class">CppSeqComparator</a></code> where
<code>x</code> and <code>y</code> are lists of sequences (vectors) to compare.
</p>
</li>
<li> <p><code>comparator = StringComparator,x = vector,y = vector</code>: Specialization for <code><a href="#topic+StringComparator-class">StringComparator</a></code> where
<code>x</code> and <code>y</code> are vectors of strings to compare.
</p>
</li>
<li> <p><code>comparator = NumericComparator,x = matrix,y = vector</code>: Specialization for <code><a href="#topic+NumericComparator-class">NumericComparator</a></code> where
<code>x</code> is a matrix of rows (interpreted as vectors) to compare with a vector
<code>y</code>.
</p>
</li>
<li> <p><code>comparator = NumericComparator,x = vector,y = matrix</code>: Specialization for <code><a href="#topic+NumericComparator-class">NumericComparator</a></code> where
<code>x</code> is a vector to compare with a matrix <code>y</code> of rows (interpreted as
vectors).
</p>
</li>
<li> <p><code>comparator = NumericComparator,x = vector,y = vector</code>: Specialization for <code><a href="#topic+NumericComparator-class">NumericComparator</a></code> where
<code>x</code> and <code>y</code> are vectors to compare.
</p>
</li>
<li> <p><code>comparator = Chebyshev,x = matrix,y = matrix</code>: Specialization for <code><a href="#topic+Chebyshev">Chebyshev</a></code> where <code>x</code> and <code>y</code>
matrices of rows (interpreted as vectors) to compare. If <code>x</code> any <code>y</code> do
not have the same number of rows, rows are recycled in the smaller matrix.
</p>
</li>
<li> <p><code>comparator = FuzzyTokenSet,x = list,y = list</code>: Specialization for <code><a href="#topic+FuzzyTokenSet">FuzzyTokenSet</a></code> where <code>x</code> and <code>y</code>
are lists of token vectors to compare.
</p>
</li>
<li> <p><code>comparator = InVocabulary,x = vector,y = vector</code>: Specialization for <code><a href="#topic+InVocabulary">InVocabulary</a></code> where <code>x</code> and
<code>y</code> are vectors of strings to compare.
</p>
</li>
<li> <p><code>comparator = Lookup,x = vector,y = vector</code>: Specialization for a <code><a href="#topic+Lookup">Lookup</a></code> where <code>x</code> and <code>y</code>
are vectors of strings to compare
</p>
</li>
<li> <p><code>comparator = MongeElkan,x = list,y = list</code>: Specialization for <code><a href="#topic+MongeElkan">MongeElkan</a></code> where <code>x</code> and <code>y</code>
lists of token vectors to compare.
</p>
</li></ul>


<h3>Note</h3>

<p>This function is not strictly necessary, as the <code>comparator</code> itself is a
function that returns elementwise vectors of scores. In other words,
<code>comparator(x, y, ...)</code> is equivalent to
<code>elementwise(comparator, x, y, ...)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the absolute difference between two sets of scalar observations
data("iris")
x &lt;- as.matrix(iris$Sepal.Width)
y &lt;- as.matrix(iris$Sepal.Length)
elementwise(Euclidean(), x, y)

## Compute the edit distance between columns of two linked data.frames
col.1 &lt;- c("Hasna Yuhanna", "Korina Zenovia", "Phyllis Haywood", "Nicky Ellen")
col.2 &lt;- c("Hasna Yuhanna", "Corinna Zenovia", "Phyllis Dorothy Haywood", "Nicole Ellen")
elementwise(Levenshtein(), col.1, col.2)
Levenshtein()(col.1, col.2)               # equivalent to above

## Recycling is used if the two collections don't contain the same number of objects
elementwise(Levenshtein(), "Cora Zenovia", col.1)

</code></pre>

<hr>
<h2 id='Euclidean'>Euclidean Numeric Comparator</h2><span id='topic+Euclidean'></span>

<h3>Description</h3>

<p>The Euclidean distance (a.k.a. L-2 distance) between two vectors <code class="reqn">x</code> and
<code class="reqn">y</code> is the square root of the sum of the squared differences of the
Cartesian coordinates:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Euclidean}(x, y) = \sqrt{\sum_{i = 1}^{n} (x_i - y_i)^2}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Euclidean()
</code></pre>


<h3>Value</h3>

<p>A <code>Euclidean</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+Minkowski">Minkowski</a></code>.
</p>


<h3>Note</h3>

<p>The Euclidean distance is a special case of the <code><a href="#topic+Minkowski">Minkowski</a></code>
distance with <code class="reqn">p = 2</code>.
</p>


<h3>See Also</h3>

<p>Other numeric comparators include <code><a href="#topic+Manhattan">Manhattan</a></code>, <code><a href="#topic+Minkowski">Minkowski</a></code> and
<code><a href="#topic+Chebyshev">Chebyshev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Distance between two vectors
x &lt;- c(0, 1, 0, 1, 0)
y &lt;- seq_len(5)
Euclidean()(x, y)

## Distance between rows (elementwise) of two matrices
comparator &lt;- Euclidean()
x &lt;- matrix(rnorm(25), nrow = 5)
y &lt;- matrix(rnorm(5), nrow = 1)
elementwise(comparator, x, y)

## Distance between rows (pairwise) of two matrices
pairwise(comparator, x, y)

</code></pre>

<hr>
<h2 id='FuzzyTokenSet'>Fuzzy Token Set Comparator</h2><span id='topic+FuzzyTokenSet'></span>

<h3>Description</h3>

<p>Compares a pair of token sets <code class="reqn">x</code> and <code class="reqn">y</code> by computing the
optimal cost of transforming <code class="reqn">x</code> into <code class="reqn">y</code> using single-token
operations (insertions, deletions and substitutions). The cost of
single-token operations is determined at the character-level using an
internal string comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzyTokenSet(
  inner_comparator = Levenshtein(normalize = TRUE),
  agg_function = base::mean,
  deletion = 1,
  insertion = 1,
  substitution = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuzzyTokenSet_+3A_inner_comparator">inner_comparator</code></td>
<td>
<p>inner string distance comparator of class
<code><a href="#topic+StringComparator-class">StringComparator</a></code>. Defaults to normalized <code><a href="#topic+Levenshtein">Levenshtein</a></code>
distance.</p>
</td></tr>
<tr><td><code id="FuzzyTokenSet_+3A_agg_function">agg_function</code></td>
<td>
<p>function used to aggregate the costs of the optimal
operations. Defaults to <code><a href="base.html#topic+mean">base::mean</a></code>.</p>
</td></tr>
<tr><td><code id="FuzzyTokenSet_+3A_deletion">deletion</code></td>
<td>
<p>non-negative weight associated with deletion of a token.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="FuzzyTokenSet_+3A_insertion">insertion</code></td>
<td>
<p>non-negative weight associated insertion of a token.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="FuzzyTokenSet_+3A_substitution">substitution</code></td>
<td>
<p>non-negative weight associated with substitution of a
token. Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A token set is an unordered enumeration of tokens, which may include
duplicates. Given two token sets <code class="reqn">x</code> and <code class="reqn">y</code>, this comparator
computes the optimal cost of transforming <code class="reqn">x</code> into <code class="reqn">y</code> using the
following single-token operations:
</p>

<ul>
<li><p> deleting a token <code class="reqn">a</code> from <code class="reqn">x</code> at cost <code class="reqn">w_d \times \mathrm{inner}(a, "")</code>
</p>
</li>
<li><p> inserting a token <code class="reqn">b</code> in <code class="reqn">y</code> at cost <code class="reqn">w_i \times \mathrm{inner}("", b)</code>
</p>
</li>
<li><p> substituting a token <code class="reqn">a</code> in <code class="reqn">x</code> for a token <code class="reqn">b</code>
in <code class="reqn">y</code> at cost <code class="reqn">w_s \times \mathrm{inner}(a, b)</code>
</p>
</li></ul>

<p>where <code class="reqn">\mathrm{inner}</code> is an internal string comparator and
<code class="reqn">w_d, w_i, w_s</code> are non-negative weights, referred to as <code>deletion</code>,
<code>insertion</code> and <code>substitution</code> in the parameter list. By default, the
<em>mean</em> cost of the optimal set of operations is returned. Other methods of
aggregating the costs are supported by specifying a non-default
<code>agg_function</code>.
</p>
<p>If the internal string comparator is a <em>distance</em> function, then the optimal
set of operations <em>minimize</em> the cost. Otherwise, the optimal set of
operations <em>maximize</em> the cost. The optimization problem is solved exactly
using a linear sum assignment solver.
</p>


<h3>Note</h3>

<p>This comparator is qualitatively similar to the <code><a href="#topic+MongeElkan">MongeElkan</a></code>
comparator, however it is arguably more principled, since it is formulated
as a cost optimization problem. It also offers more control over the costs
of missing tokens (by varying the <code>deletion</code> and <code>insertion</code> weights).
This is useful for comparing full names, when dropping a name (e.g.
middle name) shouldn't be severely penalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names with heterogenous representations
x &lt;- "The University of California - San Diego"
y &lt;- "Univ. Calif. San Diego"
# Tokenize strings on white space
x &lt;- strsplit(x, '\\s+')
y &lt;- strsplit(y, '\\s+')
FuzzyTokenSet()(x, y)
# Reduce the cost associated with missing words
FuzzyTokenSet(deletion = 0.5, insertion = 0.5)(x, y)

## Compare full name with abbreviated name, reducing the penalty 
## for dropping parts of the name
fullname &lt;- "JOSE ELIAS TEJADA BASQUES"
name &lt;- "JOSE BASQUES"
# Tokenize strings on white space
fullname &lt;- strsplit(fullname, '\\s+')
name &lt;- strsplit(name, '\\s+')
comparator &lt;- FuzzyTokenSet(deletion = 0.5)
comparator(fullname, name) &lt; comparator(name, fullname) # TRUE

</code></pre>

<hr>
<h2 id='gmean'>Geometric Mean</h2><span id='topic+gmean'></span><span id='topic+gmean.default'></span>

<h3>Description</h3>

<p>Geometric Mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmean(x, ...)

## Default S3 method:
gmean(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmean_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object. Currently there are methods for numeric/logical
vectors and date, date-time and time interval objects. Complex vectors
are allowed for <code>trim = 0</code>, only.</p>
</td></tr>
<tr><td><code id="gmean_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="gmean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be
stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The geometric mean of the values in <code>x</code> is computed, as a numeric
or complex vector of length one. If <code>x</code> is not logical (coerced to
numeric), numeric (including integer) or complex, <code>NA_real_</code> is returned,
with a warning.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code> for the arithmetic mean and <code><a href="#topic+hmean">hmean</a></code> for the harmonic
mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, 50)
xm &lt;- gmean(x)

</code></pre>

<hr>
<h2 id='Hamming'>Hamming String/Sequence Comparator</h2><span id='topic+Hamming'></span>

<h3>Description</h3>

<p>The Hamming distance between two strings/sequences of equal length is the
number of positions where the corresponding characters/sequence elements
differ. It can be viewed as a type of edit distance where the only
permitted operation is substitution of characters/sequence elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hamming(
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hamming_+3A_normalize">normalize</code></td>
<td>
<p>a logical. If TRUE, distances/similarities are normalized
to the unit interval. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="Hamming_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="Hamming_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="Hamming_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the input strings/sequences <code class="reqn">x</code> and <code class="reqn">y</code> are of
different lengths (<code class="reqn">|x| \neq |y|</code>), the Hamming distance
is defined to be <code class="reqn">\infty</code>.
</p>
<p>A Hamming similarity is returned if <code>similarity = TRUE</code>. When
<code class="reqn">|x| = |y|</code> the similarity is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = |x| - \mathrm{dist}(x, y),</code>
</p>

<p>where <code class="reqn">sim</code> is the Hamming similarity and <code class="reqn">dist</code> is the Hamming
distance. When <code class="reqn">|x| \neq |y|</code> the similarity is defined to
be 0.
</p>
<p>Normalization of the Hamming distance/similarity to the unit interval is
also supported by setting <code>normalize = TRUE</code>. The raw distance/similarity
is divided by the length of the string/sequence <code class="reqn">|x| = |y|</code>. If
<code class="reqn">|x| \neq |y|</code> the normalized distance is defined to be 1,
while the normalized similarity is defined to be 0.
</p>


<h3>Value</h3>

<p>A <code>Hamming</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>While the unnormalized Hamming distance is a metric, the normalized
variant is not as it does not satisfy the triangle inequality.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code><a href="#topic+LCS">LCS</a></code>, <code><a href="#topic+Levenshtein">Levenshtein</a></code>,
<code><a href="#topic+OSA">OSA</a></code> and <code><a href="#topic+DamerauLevenshtein">DamerauLevenshtein</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare US ZIP codes
x &lt;- "90001"
y &lt;- "90209"
m1 &lt;- Hamming()                                     # unnormalized distance
m2 &lt;- Hamming(similarity = TRUE, normalize = TRUE)  # normalized similarity
m1(x, y)
m2(x, y)

</code></pre>

<hr>
<h2 id='hmean'>Harmonic Mean</h2><span id='topic+hmean'></span><span id='topic+hmean.default'></span>

<h3>Description</h3>

<p>Harmonic Mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmean(x, ...)

## Default S3 method:
hmean(x, trim = 0, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmean_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object. Currently there are methods for numeric/logical
vectors and date, date-time and time interval objects. Complex vectors
are allowed for <code>trim = 0</code>, only.</p>
</td></tr>
<tr><td><code id="hmean_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="hmean_+3A_trim">trim</code></td>
<td>
<p>the fraction (0 to 0.5) of observations to be trimmed from each
end of <code>x</code> before the mean is computed. Values of trim outside that range
are taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="hmean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be
stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>trim</code> is zero (the default), the harmonic mean of the values
in <code>x</code> is computed, as a numeric or complex vector of length one. If <code>x</code>
is not logical (coerced to numeric), numeric (including integer) or
complex, <code>NA_real_</code> is returned, with a warning.
</p>
<p>If <code>trim</code> is non-zero, a symmetrically trimmed mean is computed with a
fraction of trim observations deleted from each end before the mean
is computed.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code> for the arithmetic mean and <code><a href="#topic+gmean">gmean</a></code> for the geometric
mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, 50)
xm &lt;- hmean(x)

</code></pre>

<hr>
<h2 id='InVocabulary'>In-Vocabulary Comparator</h2><span id='topic+InVocabulary'></span>

<h3>Description</h3>

<p>Compares a pair of strings <code class="reqn">x</code> and <code class="reqn">y</code> using a reference vocabulary.
Different scores are returned depending on whether both/one/neither of
<code class="reqn">x</code> and <code class="reqn">y</code> are in the reference vocabulary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InVocabulary(
  vocab,
  both_in_distinct = 0.7,
  both_in_same = 1,
  one_in = 1,
  none_in = 1,
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InVocabulary_+3A_vocab">vocab</code></td>
<td>
<p>a vector containing in-vocabulary (known) strings. Any strings
not in this vector are out-of-vocabulary (unknown).</p>
</td></tr>
<tr><td><code id="InVocabulary_+3A_both_in_distinct">both_in_distinct</code></td>
<td>
<p>score to return if the pair of values being
compared are both in <code>vocab</code> and distinct. Defaults to 0.7, which would
is appropriate for multiplying by similarity scores. If multiplying
by distance scores, a value greater than 1 is likely to be more
appropriate.</p>
</td></tr>
<tr><td><code id="InVocabulary_+3A_both_in_same">both_in_same</code></td>
<td>
<p>score to return if the pair of values being
compared are both in <code>vocab</code> and identical. Defaults to 1.0, which
would leave another score unchanged when multiplied by this one.</p>
</td></tr>
<tr><td><code id="InVocabulary_+3A_one_in">one_in</code></td>
<td>
<p>score to return if only one of the pair of values being
compared is in <code>vocab</code>. Defaults to 1.0, which would leave another
score unchanged when multiplied by this one.</p>
</td></tr>
<tr><td><code id="InVocabulary_+3A_none_in">none_in</code></td>
<td>
<p>score to return if none of the pair of values being
compared is in <code>vocab</code>. Defaults to 1.0, which would leave another
score unchanged when multiplied by this one.</p>
</td></tr>
<tr><td><code id="InVocabulary_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing the
strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This comparator is not intended to produce useful scores on its own.
Rather, it is intended to produce multiplicative factors which can be
applied to other similarity/distance scores. It is particularly useful
for comparing names when a reference list (vocabulary) of known names is
available. For example, it can be configured to down-weight the similarity
scores of distinct (known) names like &quot;Roberto&quot; and &quot;Umberto&quot; which are
semantically very different, but deceptively similar in terms of edit
distance. The normalized Levenshtein similarity for these two names is 75%,
but their similarity can be reduced to 53% if multiplied by the score
from this comparator using the default settings.
</p>


<h3>Value</h3>

<p>An <code>InVocabulary</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names with possible typos using a reference of known names
known_names &lt;- c("Roberto", "Umberto", "Alberto", "Emberto", "Norberto", "Humberto")
m1 &lt;- InVocabulary(known_names)
m2 &lt;- Levenshtein(similarity = TRUE, normalize = TRUE)
x &lt;- "Emberto"
y &lt;- c("Enberto", "Umberto")
# "Emberto" and "Umberto" are likely to refer to distinct people (since 
# they are known distinct names) so their Levenshtein similarity is 
# downweighted to 0.61. "Emberto" and "Enberto" may refer to the same 
# person (likely typo), so their Levenshtein similarity of 0.87 is not 
# downweighted.
similarities &lt;- m1(x, y) * m2(x, y)

</code></pre>

<hr>
<h2 id='Jaro'>Jaro String/Sequence Comparator</h2><span id='topic+Jaro'></span>

<h3>Description</h3>

<p>Compares a pair of strings/sequences <code>x</code> and <code>y</code> based on the number of
greedily-aligned characters/sequence elements and the number of
transpositions. It was developed for comparing names at the U.S. Census
Bureau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jaro(similarity = TRUE, ignore_case = FALSE, use_bytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jaro_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
(default), otherwise distances are returned (see definition under Details).</p>
</td></tr>
<tr><td><code id="Jaro_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="Jaro_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>When <code>similarity = TRUE</code> (default), the Jaro similarity is computed as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{1}{3}\left(\frac{m}{|x|} + \frac{m}{|y|} + \frac{m - \lfloor \frac{t}{2} \rfloor}{m}\right)</code>
</p>

<p>where <code class="reqn">m</code> is the number of &quot;matching&quot; characters (defined below),
<code class="reqn">t</code> is the number of &quot;transpositions&quot;, and <code class="reqn">|x|,|y|</code> are the
lengths of the strings <code class="reqn">x</code> and <code class="reqn">y</code>. The similarity takes on values
in the range <code class="reqn">[0, 1]</code>, where 1 corresponds to a perfect match.
</p>
<p>The number of &quot;matching&quot; characters <code class="reqn">m</code> is computed using a greedy
alignment algorithm. The algorithm iterates over the characters in <code class="reqn">x</code>,
attempting to align the <code class="reqn">i</code>-th character <code class="reqn">x_i</code> with the first
matching character in <code class="reqn">y</code>. When looking for matching characters in
<code class="reqn">y</code>, the algorithm only considers previously un-matched characters
within a window
<code class="reqn">[\max(0, i - w), \min(|y|, i + w)]</code>
where <code class="reqn">w = \left\lfloor \frac{\max(|x|, |y|)}{2} \right\rfloor - 1</code>.
The alignment process yields a subsequence of matching characters from
<code class="reqn">x</code> and <code class="reqn">y</code>. The number of &quot;transpositions&quot; <code class="reqn">t</code> is defined to
be the number of positions in the subsequence of <code class="reqn">x</code> which are
misaligned with the corresponding position in <code class="reqn">y</code>.
</p>
<p>When <code>similarity = FALSE</code>, the Jaro distance is computed as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}(x,y) = 1 - \mathrm{sim}(x,y).</code>
</p>



<h3>Value</h3>

<p>A <code>Jaro</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>The Jaro distance is not a metric, as it does not satisfy the
identity axiom <code class="reqn">\mathrm{dist}(x,y) = 0 \Leftrightarrow x = y.</code>
</p>


<h3>References</h3>

<p>Jaro, M. A. (1989), &quot;Advances in Record-Linkage Methodology as Applied to
Matching the 1985 Census of Tampa, Florida&quot;, <em>Journal of the American
Statistical Association</em> <strong>84</strong>(406), 414-420.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+JaroWinkler">JaroWinkler</a></code> comparator modifies the <code><a href="#topic+Jaro">Jaro</a></code> comparator by
boosting the similarity score for strings/sequences that have matching
prefixes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names
Jaro()("Martha", "Mathra")
Jaro()("Eileen", "Phyllis")

</code></pre>

<hr>
<h2 id='JaroWinkler'>Jaro-Winkler String/Sequence Comparator</h2><span id='topic+JaroWinkler'></span>

<h3>Description</h3>

<p>The Jaro-Winkler comparator is a variant of the <code><a href="#topic+Jaro">Jaro</a></code> comparator which
boosts the similarity score for strings/sequences with matching prefixes.
It was developed for comparing names at the U.S. Census Bureau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JaroWinkler(
  p = 0.1,
  threshold = 0.7,
  max_prefix = 4L,
  similarity = TRUE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JaroWinkler_+3A_p">p</code></td>
<td>
<p>a non-negative numeric scalar no larger than 1/max_prefix.
Similarity scores eligible for boosting are scaled by this factor.</p>
</td></tr>
<tr><td><code id="JaroWinkler_+3A_threshold">threshold</code></td>
<td>
<p>a numeric scalar on the unit interval. Jaro similarities
greater than this value are boosted based on matching characters in the
prefixes of both strings. Jaro similarities below this value are
returned unadjusted. Defaults to 0.7.</p>
</td></tr>
<tr><td><code id="JaroWinkler_+3A_max_prefix">max_prefix</code></td>
<td>
<p>a non-negative integer scalar, specifying the size of
the prefix to consider for boosting. Defaults to 4 (characters).</p>
</td></tr>
<tr><td><code id="JaroWinkler_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
(default), otherwise distances are returned (see definition under Details).</p>
</td></tr>
<tr><td><code id="JaroWinkler_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="JaroWinkler_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>The Jaro-Winkler similarity (computed when <code>similarity = TRUE</code>) is
defined in terms of the <code><a href="#topic+Jaro">Jaro</a></code> similarity. If the Jaro similarity
<code class="reqn">sim_J(x,y)</code> between strings <code class="reqn">x</code> and <code class="reqn">y</code> exceeds a
user-specified threshold <code class="reqn">0 \leq \tau \leq 1</code>,
the similarity score is boosted in proportion to the number of matching
characters in the prefixes of <code class="reqn">x</code> and <code class="reqn">y</code>. More precisely, the
Jaro-Winkler similarity is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_{JW}(x, y) = \mathrm{sim}_J(x, y) + \min(c(x, y), l) p (1 - \mathrm{sim}_J(x, y)),</code>
</p>

<p>where <code class="reqn">c(x,y)</code> is the length of the common prefix, <code class="reqn">l \geq 0</code>
is a user-specified upper bound on the prefix size, and
<code class="reqn">0 \leq p \leq 1/l</code> is a scaling factor.
</p>
<p>The Jaro-Winkler distance is computed when <code>similarity = FALSE</code> and is
defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_{JW}(x, y) = 1 - \mathrm{sim}_{JW}(x, y).</code>
</p>



<h3>Value</h3>

<p>A <code>JaroWinkler</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>Like the Jaro distance, the Jaro-Winkler distance is not a metric as
it does not satisfy the identity axiom.
</p>


<h3>References</h3>

<p>Jaro, M. A. (1989), &quot;Advances in Record-Linkage Methodology as Applied to
Matching the 1985 Census of Tampa, Florida&quot;, <em>Journal of the American
Statistical Association</em> <strong>84</strong>(406), 414-420.
</p>
<p>Winkler, W. E. (2006), &quot;Overview of Record Linkage and Current Research
Directions&quot;, Tech. report. Statistics #2006-2. Statistical Research
Division, U.S. Census Bureau.
</p>
<p>Winkler, W., McLaughlin G., Jaro M. and Lynch M. (1994), <a href="https://web.archive.org/web/20100227020019/http://www.census.gov/geo/msb/stand/strcmp.c">strcmp95.c</a>,
Version 2. United States Census Bureau.
</p>


<h3>See Also</h3>

<p>This comparator reduces to the <code><a href="#topic+Jaro">Jaro</a></code> comparator when <code>max_prefix = 0L</code>
or <code>threshold = 0.0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names
JaroWinkler()("Martha", "Mathra")
JaroWinkler()("Eileen", "Phyllis")

## Reduce the threshold for boosting
x &lt;- "Matthew"
y &lt;- "Martin"
JaroWinkler()(x, y) &lt; JaroWinkler(threshold = 0.5)(x, y)

</code></pre>

<hr>
<h2 id='LCS'>Longest Common Subsequence (LCS) Comparator</h2><span id='topic+LCS'></span>

<h3>Description</h3>

<p>The Longest Common Subsequence (LCS) distance between two
strings/sequences <code class="reqn">x</code> and <code class="reqn">y</code> is the minimum cost of operations
(insertions and deletions) required to transform  <code class="reqn">x</code> into <code class="reqn">y</code>.
The LCS similarity is more commonly used, which can be interpreted as the
length of the longest subsequence common to <code class="reqn">x</code> and <code class="reqn">y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCS(
  deletion = 1,
  insertion = 1,
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCS_+3A_deletion">deletion</code></td>
<td>
<p>positive cost associated with deletion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="LCS_+3A_insertion">insertion</code></td>
<td>
<p>positive cost associated insertion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="LCS_+3A_normalize">normalize</code></td>
<td>
<p>a logical. If TRUE, distances are normalized to the
unit interval. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="LCS_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="LCS_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="LCS_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>An LCS similarity is returned if <code>similarity = TRUE</code>, which
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{w_d |x| + w_i |y| - \mathrm{dist}(x, y)}{2},</code>
</p>

<p>where <code class="reqn">|x|</code>, <code class="reqn">|y|</code> are the number of characters in <code class="reqn">x</code> and
<code class="reqn">y</code> respectively, <code class="reqn">dist</code> is the LCS distance, <code class="reqn">w_d</code>
is the cost of a deletion and <code class="reqn">w_i</code> is the cost of an insertion.
</p>
<p>Normalization of the LCS distance/similarity to the unit interval
is also supported by setting <code>normalize = TRUE</code>. The normalization approach
follows Yujian and Bo (2007), and ensures that the distance remains a metric
when the costs of insertion <code class="reqn">w_i</code> and deletion <code class="reqn">w_d</code> are equal.
The normalized distance <code class="reqn">\mathrm{dist}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_n(x, y) = \frac{2 \mathrm{dist}(x, y)}{w_d |x| + w_i |y| + \mathrm{dist}(x, y)},</code>
</p>

<p>and the normalized similarity <code class="reqn">\mathrm{sim}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_n(x, y) = 1 - \mathrm{dist}_n(x, y) = \frac{\mathrm{sim}(x, y)}{w_d |x| + w_i |y| - \mathrm{sim}(x, y)}.</code>
</p>



<h3>Value</h3>

<p>A <code>LCS</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>If the costs of deletion and insertion are equal, this comparator is
symmetric in <code class="reqn">x</code> and <code class="reqn">y</code>. In addition, the normalized and
unnormalized distances satisfy the properties of a metric.
</p>


<h3>References</h3>

<p>Bergroth, L., Hakonen, H., &amp; Raita, T. (2000), &quot;A survey of longest common
subsequence algorithms&quot;, <em>Proceedings Seventh International Symposium
on String Processing and Information Retrieval (SPIRE'00)</em>, 39-48.
</p>
<p>Yujian, L. &amp; Bo, L. (2007), &quot;A Normalized Levenshtein Distance Metric&quot;,
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>
<strong>29</strong>, 10911095.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code><a href="#topic+Hamming">Hamming</a></code>, <code><a href="#topic+Levenshtein">Levenshtein</a></code>,
<code><a href="#topic+OSA">OSA</a></code> and <code><a href="#topic+DamerauLevenshtein">DamerauLevenshtein</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## There are no common substrings of size 3 for the following example, 
## however there are two common substrings of size 2: "AC" and "BC". 
## Hence the LCS similarity is 2.
x &lt;- "ABCDA"; y &lt;- "BAC"
LCS(similarity = TRUE)(x, y)

## Levenshtein distance reduces to LCS distance when the cost of 
## substitution is high
x &lt;- "ABC"; y &lt;- "AAA"
LCS()(x, y) == Levenshtein(substitution = 100)(x, y)

</code></pre>

<hr>
<h2 id='Levenshtein'>Levenshtein String/Sequence Comparator</h2><span id='topic+Levenshtein'></span>

<h3>Description</h3>

<p>The Levenshtein (edit) distance between two strings/sequences <code class="reqn">x</code> and
<code class="reqn">y</code> is the minimum cost of operations (insertions, deletions or
substitutions) required to transform <code class="reqn">x</code> into <code class="reqn">y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Levenshtein(
  deletion = 1,
  insertion = 1,
  substitution = 1,
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Levenshtein_+3A_deletion">deletion</code></td>
<td>
<p>positive cost associated with deletion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_insertion">insertion</code></td>
<td>
<p>positive cost associated insertion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_substitution">substitution</code></td>
<td>
<p>positive cost associated with substitution of a
character or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_normalize">normalize</code></td>
<td>
<p>a logical. If TRUE, distances are normalized to the
unit interval. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="Levenshtein_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>A Levenshtein similarity is returned if <code>similarity = TRUE</code>, which
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{w_d |x| + w_i |y| - \mathrm{dist}(x, y)}{2},</code>
</p>

<p>where <code class="reqn">|x|</code>, <code class="reqn">|y|</code> are the number of characters in <code class="reqn">x</code> and
<code class="reqn">y</code> respectively, <code class="reqn">\mathrm{dist}</code> is the Levenshtein distance,
<code class="reqn">w_d</code> is the cost of a deletion and <code class="reqn">w_i</code> is the cost of an
insertion.
</p>
<p>Normalization of the Levenshtein distance/similarity to the unit interval
is also supported by setting <code>normalize = TRUE</code>. The normalization approach
follows Yujian and Bo (2007), and ensures that the distance remains a metric
when the costs of insertion <code class="reqn">w_i</code> and deletion <code class="reqn">w_d</code> are equal.
The normalized distance <code class="reqn">\mathrm{dist}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_n(x, y) = \frac{2 \mathrm{dist}(x, y)}{w_d |x| + w_i |y| + \mathrm{dist}(x, y)},</code>
</p>

<p>and the normalized similarity <code class="reqn">\mathrm{sim}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_n(x, y) = 1 - \mathrm{dist}_n(x, y) = \frac{\mathrm{sim}(x, y)}{w_d |x| + w_i |y| - \mathrm{sim}(x, y)}.</code>
</p>



<h3>Value</h3>

<p>A <code>Levenshtein</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>If the costs of deletion and insertion are equal, this comparator is
symmetric in <code class="reqn">x</code> and <code class="reqn">y</code>. In addition, the normalized and
unnormalized distances satisfy the properties of a metric.
</p>


<h3>References</h3>

<p>Navarro, G. (2001), &quot;A guided tour to approximate string matching&quot;,
<em>ACM Computing Surveys (CSUR)</em>, <strong>33</strong>(1), 31-88.
</p>
<p>Yujian, L. &amp; Bo, L. (2007), &quot;A Normalized Levenshtein Distance Metric&quot;,
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>
<strong>29</strong>, 10911095.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code><a href="#topic+Hamming">Hamming</a></code>, <code><a href="#topic+LCS">LCS</a></code>,
<code><a href="#topic+OSA">OSA</a></code> and <code><a href="#topic+DamerauLevenshtein">DamerauLevenshtein</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names with potential typos
x &lt;- c("Brian Cheng", "Bryan Cheng", "Kondo Onyejekwe", "Condo Onyejekve")
pairwise(Levenshtein(), x, return_matrix = TRUE)

## When the substitution cost is high, Levenshtein distance reduces to LCS distance
Levenshtein(substitution = 100)("Iran", "Iraq") == LCS()("Iran", "Iraq")

</code></pre>

<hr>
<h2 id='Lookup'>Lookup String Comparator</h2><span id='topic+Lookup'></span>

<h3>Description</h3>

<p>Compares a pair of strings <code class="reqn">x</code> and <code class="reqn">y</code> by retrieving
their distance/similarity score from a provided lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lookup(
  lookup_table,
  values_colnames,
  score_colname,
  default_match = 0,
  default_nonmatch = NA_real_,
  symmetric = TRUE,
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lookup_+3A_lookup_table">lookup_table</code></td>
<td>
<p>data frame containing distances/similarities for
pairs of values</p>
</td></tr>
<tr><td><code id="Lookup_+3A_values_colnames">values_colnames</code></td>
<td>
<p>character vector containing the colnames
corresponding to pairs of values (e.g. strings) in <code>lookup_table</code></p>
</td></tr>
<tr><td><code id="Lookup_+3A_score_colname">score_colname</code></td>
<td>
<p>name of column that contains distances/similarities
in <code>lookup_table</code></p>
</td></tr>
<tr><td><code id="Lookup_+3A_default_match">default_match</code></td>
<td>
<p>distance/similarity to use if the pair of values
match exactly and do not appear in <code>lookup_table</code>. Defaults to 0.0.</p>
</td></tr>
<tr><td><code id="Lookup_+3A_default_nonmatch">default_nonmatch</code></td>
<td>
<p>distance/similarity to use if the pair of values are
not an exact match and do not appear in <code style="white-space: pre;">&#8288;lookup table&#8288;</code>. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Lookup_+3A_symmetric">symmetric</code></td>
<td>
<p>whether the underlying distance/similarity scores are
symmetric. If TRUE <code>lookup_table</code> need only contain entries for
one of the two pairs&mdash;i.e. an entry for value pair <code class="reqn">(y, x)</code> is not
required if an entry for <code class="reqn">(x, y)</code> is already present.</p>
</td></tr>
<tr><td><code id="Lookup_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing the
strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lookup table should contain three columns corresponding to <code class="reqn">x</code>,
and <code class="reqn">y</code> (<code>values_colnames</code> below) and the distance/similarity
(<code>score_colname</code> below). If a pair of values <code class="reqn">x</code> and <code class="reqn">y</code> is
not in the lookup table, a default distance/similarity is returned
depending on whether <code class="reqn">x = y</code> (<code>default_match</code> below) or
<code class="reqn">x \neq y</code> (<code>default_nonmatch</code> below).
</p>


<h3>Value</h3>

<p>A <code>Lookup</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Measure the distance between cities
lookup_table &lt;- data.frame(x = c("Melbourne", "Melbourne", "Sydney"), 
                           y = c("Sydney", "Brisbane", "Brisbane"), 
                           dist = c(713.4, 1374.8, 732.5))

comparator &lt;- Lookup(lookup_table, c("x", "y"), "dist")
comparator("Sydney", "Melbourne")
comparator("Melbourne", "Perth")

</code></pre>

<hr>
<h2 id='Manhattan'>Manhattan Numeric Comparator</h2><span id='topic+Manhattan'></span>

<h3>Description</h3>

<p>The Manhattan distance (a.k.a. L-1 distance) between two vectors <code class="reqn">x</code> and
<code class="reqn">y</code> is the sum of the absolute differences of their Cartesian
coordinates:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Manhattan}(x,y) = \sum_{i = 1}^{n} |x_i - y_i|.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Manhattan()
</code></pre>


<h3>Value</h3>

<p>A <code>Manhattan</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+Minkowski">Minkowski</a></code>.
</p>


<h3>Note</h3>

<p>The Manhattan distance is a special case of the <code><a href="#topic+Minkowski">Minkowski</a></code>
distance with <code class="reqn">p = 1</code>.
</p>


<h3>See Also</h3>

<p>Other numeric comparators include <code><a href="#topic+Euclidean">Euclidean</a></code>, <code><a href="#topic+Minkowski">Minkowski</a></code> and
<code><a href="#topic+Chebyshev">Chebyshev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Distance between two vectors
x &lt;- c(0, 1, 0, 1, 0)
y &lt;- seq_len(5)
Manhattan()(x, y)

## Distance between rows (elementwise) of two matrices
comparator &lt;- Manhattan()
x &lt;- matrix(rnorm(25), nrow = 5)
y &lt;- matrix(rnorm(5), nrow = 1)
elementwise(comparator, x, y)

## Distance between rows (pairwise) of two matrices
pairwise(comparator, x, y)

</code></pre>

<hr>
<h2 id='Minkowski'>Minkowski Numeric Comparator</h2><span id='topic+Minkowski'></span>

<h3>Description</h3>

<p>The Minkowski distance (a.k.a. L-p distance) between two vectors <code class="reqn">x</code> and
<code class="reqn">y</code> is the p-th root of the sum of the absolute differences of their
Cartesian coordinates raised to the p-th power:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Minkowski}(x,y) = \left(\sum_{i = 1}^{n} |x_i - y_i|^p\right)^{1/p}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Minkowski(p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Minkowski_+3A_p">p</code></td>
<td>
<p>a positive numeric specifying the order of the distance. Defaults
to 2 (Euclidean distance). If <code>p &lt; 1</code> the Minkowski distance does not
satisfy the triangle inequality and is therefore not a proper distance
metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Minkowski</code> instance is returned, which is an S4 class inheriting
from <code><a href="#topic+NumericComparator-class">NumericComparator</a></code>.
</p>


<h3>See Also</h3>

<p>Other numeric comparators include <code><a href="#topic+Manhattan">Manhattan</a></code>, <code><a href="#topic+Euclidean">Euclidean</a></code> and
<code><a href="#topic+Chebyshev">Chebyshev</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Distance between two vectors
x &lt;- c(0, 1, 0, 1, 0)
y &lt;- seq_len(5)
Minkowski()(x, y)

## Distance between rows (elementwise) of two matrices
comparator &lt;- Minkowski()
x &lt;- matrix(rnorm(25), nrow = 5)
y &lt;- matrix(rnorm(5), nrow = 1)
elementwise(comparator, x, y)

## Distance between rows (pairwise) of two matrices
pairwise(comparator, x, y)

</code></pre>

<hr>
<h2 id='MongeElkan'>Monge-Elkan Token Comparator</h2><span id='topic+MongeElkan'></span>

<h3>Description</h3>

<p>Compares a pair of token sets <code class="reqn">x</code> and <code class="reqn">y</code> by computing similarity
scores between all pairs of tokens using an internal string comparator,
then taking the mean of the maximum scores for each token in <code class="reqn">x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MongeElkan(
  inner_comparator = Levenshtein(similarity = TRUE, normalize = TRUE),
  agg_function = base::mean,
  symmetrize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MongeElkan_+3A_inner_comparator">inner_comparator</code></td>
<td>
<p>internal string comparator of class
<code><a href="#topic+StringComparator-class">StringComparator</a></code>. Defaults to <code><a href="#topic+Levenshtein">Levenshtein</a></code> similarity.</p>
</td></tr>
<tr><td><code id="MongeElkan_+3A_agg_function">agg_function</code></td>
<td>
<p>aggregation function to use when aggregating internal
similarities/distances between tokens. Defaults to <code><a href="base.html#topic+mean">mean</a></code>,
however <code><a href="#topic+hmean">hmean</a></code> may be a better choice when the comparator returns
normalized similarity scores.</p>
</td></tr>
<tr><td><code id="MongeElkan_+3A_symmetrize">symmetrize</code></td>
<td>
<p>logical indicating whether to use a symmetrized version
of the Monge-Elkan comparator. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A token set is an unordered enumeration of tokens, which may include
duplicates.
Given two token sets <code class="reqn">x</code> and <code class="reqn">y</code>, the Monge-Elkan comparator is
defined as:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{ME}(x, y) = \frac{1}{|x|} \sum_{i = 1}^{|x|} \max_j \mathrm{sim}(x_i, y_j)</code>
</p>

<p>where <code class="reqn">x_i</code> is the i-th token in <code class="reqn">x</code>, <code class="reqn">|x|</code> is the
number of tokens in <code class="reqn">x</code> and <code class="reqn">\mathrm{sim}</code> is an internal
string similarity comparator.
</p>
<p>A generalization of the original Monge-Elkan comparator is implemented here,
which allows for distance comparators in place of similarity comparators,
and/or more general aggregation functions in place of the arithmetic mean.
The generalized Monge-Elkan comparator is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{ME}(x, y) = \mathrm{agg}(\mathrm{opt}_j \ \mathrm{inner}(x_i, y_j))</code>
</p>

<p>where <code class="reqn">\mathrm{inner}</code> is an internal distance or similarity
comparator, <code class="reqn">\mathrm{opt}</code> is <code class="reqn">\max</code> if
<code class="reqn">\mathrm{inner}</code> is a similarity comparator or <code class="reqn">\min</code> if
it is a distance comparator, and <code class="reqn">\mathrm{agg}</code> is an aggregation
function which takes a vector of scores for each token in <code class="reqn">x</code> and
returns a scalar.
</p>
<p>By default, the Monge-Elkan comparator is asymmetric in its arguments <code class="reqn">x</code>
and <code class="reqn">y</code>. If <code>symmetrize = TRUE</code>, a symmetric version of the comparator
is obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{ME}_{sym}(x, y) = \mathrm{opt} \ \{\mathrm{ME}(x, y), \mathrm{ME}(y, x)\}</code>
</p>

<p>where <code class="reqn">\mathrm{opt}</code> is defined above.
</p>


<h3>Value</h3>

<p>A <code>MongeElkan</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>References</h3>

<p>Monge, A. E., &amp; Elkan, C. (1996), &quot;The Field Matching
Problem: Algorithms and Applications&quot;, In <em>Proceedings of the Second
International Conference on Knowledge Discovery and Data Mining (KDD'96)</em>,
pp. 267-270.
</p>
<p>Jimenez, S., Becerra, C., Gelbukh, A., &amp; Gonzalez, F. (2009), &quot;Generalized
Monge-Elkan Method for Approximate Text String Comparison&quot;, In
<em>Computational Linguistics and Intelligent Text Processing</em>,
pp. 559-570.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare names with heterogenous representations
x &lt;- "The University of California - San Diego"
y &lt;- "Univ. Calif. San Diego"
# Tokenize strings on white space
x &lt;- strsplit(x, '\\s+')
y &lt;- strsplit(y, '\\s+')
MongeElkan()(x, y)

## The symmetrized variant is arguably more appropriate for this example
MongeElkan(symmetrize = TRUE)(x, y) 

## Using a different internal comparator changes the result
MongeElkan(inner_comparator = BinaryComp(), symmetrize=TRUE)(x, y)

</code></pre>

<hr>
<h2 id='NumericComparator-class'>Virtual Numeric Comparator Class</h2><span id='topic+NumericComparator-class'></span>

<h3>Description</h3>

<p>Represents a comparator for comparing pairs of numeric vectors.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a function that calls the elementwise method for this class,
with arguments <code>x</code>, <code>y</code> and <code>...</code>.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>a logical of length 1. If TRUE, the comparator is symmetric
in its arguments&mdash;i.e. <code>comparator(x, y)</code> is identical to
<code>comparator(y, x)</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
distances and satisfies <code>comparator(x, x) = 0</code>. The comparator may not
satisfy all of the properties of a distance metric.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
similarity scores.</p>
</dd>
<dt><code>tri_inequal</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator satisfies
the triangle inequality. This is only possible (but not guaranteed) if
<code>distance = TRUE</code> and <code>symmetric = TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='OSA'>Optimal String Alignment (OSA) String/Sequence Comparator</h2><span id='topic+OSA'></span>

<h3>Description</h3>

<p>The Optimal String Alignment (OSA) distance between two strings/sequences
<code class="reqn">x</code> and <code class="reqn">y</code> is the minimum cost of operations (insertions,
deletions, substitutions or transpositions) required to transform  <code class="reqn">x</code>
into <code class="reqn">y</code>, subject to the constraint that <em>no substring/subsequence is
edited more than once</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSA(
  deletion = 1,
  insertion = 1,
  substitution = 1,
  transposition = 1,
  normalize = FALSE,
  similarity = FALSE,
  ignore_case = FALSE,
  use_bytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OSA_+3A_deletion">deletion</code></td>
<td>
<p>positive cost associated with deletion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="OSA_+3A_insertion">insertion</code></td>
<td>
<p>positive cost associated insertion of a character
or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="OSA_+3A_substitution">substitution</code></td>
<td>
<p>positive cost associated with substitution of a
character or sequence element. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="OSA_+3A_transposition">transposition</code></td>
<td>
<p>positive cost associated with transposing (swapping)
a pair of characters or sequence elements. Defaults to unit cost.</p>
</td></tr>
<tr><td><code id="OSA_+3A_normalize">normalize</code></td>
<td>
<p>a logical. If TRUE, distances are normalized to the
unit interval. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="OSA_+3A_similarity">similarity</code></td>
<td>
<p>a logical. If TRUE, similarity scores are returned
instead of distances. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="OSA_+3A_ignore_case">ignore_case</code></td>
<td>
<p>a logical. If TRUE, case is ignored when comparing
strings.</p>
</td></tr>
<tr><td><code id="OSA_+3A_use_bytes">use_bytes</code></td>
<td>
<p>a logical. If TRUE, strings are compared byte-by-byte
rather than character-by-character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simplicity we assume <code>x</code> and <code>y</code> are strings in this section,
however the comparator is also implemented for more general sequences.
</p>
<p>An OSA similarity is returned if <code>similarity = TRUE</code>, which
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}(x, y) = \frac{w_d |x| + w_i |y| - \mathrm{dist}(x, y)}{2},</code>
</p>

<p>where <code class="reqn">|x|</code>, <code class="reqn">|y|</code> are the number of characters in <code class="reqn">x</code> and
<code class="reqn">y</code> respectively, <code class="reqn">dist</code> is the OSA distance, <code class="reqn">w_d</code>
is the cost of a deletion and <code class="reqn">w_i</code> is the cost of an insertion.
</p>
<p>Normalization of the OSA distance/similarity to the unit interval
is also supported by setting <code>normalize = TRUE</code>. The normalization approach
follows Yujian and Bo (2007), and ensures that the distance remains a metric
when the costs of insertion <code class="reqn">w_i</code> and deletion <code class="reqn">w_d</code> are equal.
The normalized distance <code class="reqn">\mathrm{dist}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{dist}_n(x, y) = \frac{2 \mathrm{dist}(x, y)}{w_d |x| + w_i |y| + \mathrm{dist}(x, y)},</code>
</p>

<p>and the normalized similarity <code class="reqn">\mathrm{sim}_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{sim}_n(x, y) = 1 - \mathrm{dist}_n(x, y) = \frac{\mathrm{sim}(x, y)}{w_d |x| + w_i |y| - \mathrm{sim}(x, y)}.</code>
</p>



<h3>Value</h3>

<p>An <code>OSA</code> instance is returned, which is an S4 class inheriting from
<code><a href="#topic+StringComparator-class">StringComparator</a></code>.
</p>


<h3>Note</h3>

<p>If the costs of deletion and insertion are equal, this comparator is
symmetric in <code class="reqn">x</code> and <code class="reqn">y</code>. The OSA distance is not a proper metric
as it does not satisfy the triangle inequality. The Damerau-Levenshtein
distance is closely related&mdash;it allows the same edit operations as OSA,
but removes the requirement that no substring can be edited more than once.
</p>


<h3>References</h3>

<p>Boytsov, L. (2011), &quot;Indexing methods for approximate dictionary searching:
Comparative analysis&quot;, <em>ACM J. Exp. Algorithmics</em> <strong>16</strong>,
Article 1.1.
</p>
<p>Navarro, G. (2001), &quot;A guided tour to approximate string matching&quot;,
<em>ACM Computing Surveys (CSUR)</em>, <strong>33</strong>(1), 31-88.
</p>
<p>Yujian, L. &amp; Bo, L. (2007), &quot;A Normalized Levenshtein Distance Metric&quot;,
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>
<strong>29</strong>: 10911095.
</p>


<h3>See Also</h3>

<p>Other edit-based comparators include <code><a href="#topic+Hamming">Hamming</a></code>, <code><a href="#topic+LCS">LCS</a></code>,
<code><a href="#topic+Levenshtein">Levenshtein</a></code> and <code><a href="#topic+DamerauLevenshtein">DamerauLevenshtein</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare strings with a transposition error
x &lt;- "plauge"; y &lt;- "plague"
OSA()(x, y) != Levenshtein()(x, y)

## Unlike Damerau-Levenshtein, OSA does not allow a substring to be 
## edited more than once
x &lt;- "ABC"; y &lt;- "CA"
OSA()(x, y) != DamerauLevenshtein()(x, y)

## Compare car names using normalized OSA similarity
data(mtcars)
cars &lt;- rownames(mtcars)
pairwise(OSA(similarity = TRUE, normalize=TRUE), cars)

</code></pre>

<hr>
<h2 id='pairwise'>Pairwise Similarity/Distance Matrix</h2><span id='topic+pairwise'></span><span id='topic+pairwise+2CComparator+2CANY+2Cmissing-method'></span><span id='topic+pairwise+2CCppSeqComparator+2Clist+2Clist-method'></span><span id='topic+pairwise+2CCppSeqComparator+2Clist+2CNULL-method'></span><span id='topic+pairwise+2CStringComparator+2Cvector+2Cvector-method'></span><span id='topic+pairwise+2CStringComparator+2Cvector+2CNULL-method'></span><span id='topic+pairwise+2CNumericComparator+2Cmatrix+2Cvector-method'></span><span id='topic+pairwise+2CNumericComparator+2Cvector+2Cmatrix-method'></span><span id='topic+pairwise+2CChebyshev+2Cmatrix+2Cmatrix-method'></span><span id='topic+pairwise+2CChebyshev+2Cmatrix+2CNULL-method'></span><span id='topic+elementwise+2CMinkowski+2Cmatrix+2Cmatrix-method'></span><span id='topic+pairwise+2CMinkowski+2Cmatrix+2Cmatrix-method'></span><span id='topic+pairwise+2CMinkowski+2Cmatrix+2CNULL-method'></span><span id='topic+pairwise+2CFuzzyTokenSet+2Clist+2Clist-method'></span><span id='topic+pairwise+2CFuzzyTokenSet+2Cvector+2CNULL-method'></span><span id='topic+pairwise+2CInVocabulary+2Cvector+2Cvector-method'></span><span id='topic+pairwise+2CInVocabulary+2Cvector+2CNULL-method'></span><span id='topic+pairwise+2CLookup+2Cvector+2Cvector-method'></span><span id='topic+pairwise+2CLookup+2Cvector+2CNULL-method'></span><span id='topic+pairwise+2CMongeElkan+2Clist+2Clist-method'></span><span id='topic+pairwise+2CMongeElkan+2Clist+2CNULL-method'></span>

<h3>Description</h3>

<p>Computes pairwise similarities/distances between two collections of objects
(strings, vectors, etc.) using the provided comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Comparator,ANY,missing'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'CppSeqComparator,list,list'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'CppSeqComparator,list,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'StringComparator,vector,vector'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'StringComparator,vector,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'NumericComparator,matrix,vector'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'NumericComparator,vector,matrix'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Chebyshev,matrix,matrix'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Chebyshev,matrix,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Minkowski,matrix,matrix'
elementwise(comparator, x, y, ...)

## S4 method for signature 'Minkowski,matrix,matrix'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Minkowski,matrix,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'FuzzyTokenSet,list,list'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'FuzzyTokenSet,vector,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'InVocabulary,vector,vector'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'InVocabulary,vector,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Lookup,vector,vector'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'Lookup,vector,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'MongeElkan,list,list'
pairwise(comparator, x, y, return_matrix = FALSE, ...)

## S4 method for signature 'MongeElkan,list,'NULL''
pairwise(comparator, x, y, return_matrix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_+3A_comparator">comparator</code></td>
<td>
<p>a comparator used to compare the objects, which is a
sub-class of <code><a href="#topic+Comparator-class">Comparator</a></code>.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_x">x</code>, <code id="pairwise_+3A_y">y</code></td>
<td>
<p>a collection of objects to compare, typically stored as entries
in an atomic vector, rows in a matrix, or entries in a list. The required
format depends on the type of <code>comparator</code>. <code>y</code> may be omitted or set to
<code>NULL</code> to compare objects in <code>x</code>.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_return_matrix">return_matrix</code></td>
<td>
<p>a logical of length 1. If FALSE (default), the pairwise
similarities/distances will be returned as a <code><a href="#topic+PairwiseMatrix-class">PairwiseMatrix</a></code>
which is more space-efficient for symmetric comparators. If TRUE, a
standard <code><a href="base.html#topic+matrix">matrix</a></code> is returned instead.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_...">...</code></td>
<td>
<p>other parameters passed on to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If both <code>x</code> and <code>y</code> are specified, every object in <code>x</code> is compared with
every object in <code>y</code> using the comparator, and the resulting scores are
returned in a <code>size(x)</code> by <code>size(y)</code> matrix.
</p>
<p>If only <code>x</code> is specified, then the objects in <code>x</code> are compared with
themselves using the comparator, and the resulting scores are returned in a
<code>size(x)</code> by <code>size(y)</code> matrix.
</p>
<p>By default, the matrix is represented as an instance of the
<code><a href="#topic+PairwiseMatrix-class">PairwiseMatrix</a></code> class, which is more space-efficient for symmetric
comparators when <code>y</code> is not specified. However, if <code>return_matrix = TRUE</code>,
the matrix is returned as an ordinary <code><a href="base.html#topic+matrix">matrix</a></code> instead.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>comparator = Comparator,x = ANY,y = missing</code>: Compute a pairwise comparator when <code>y</code>
</p>
</li>
<li> <p><code>comparator = CppSeqComparator,x = list,y = list</code>: Specialization for <code><a href="#topic+CppSeqComparator-class">CppSeqComparator</a></code> where <code>x</code>
and <code>y</code> are lists of sequences (vectors) to compare.
</p>
</li>
<li> <p><code>comparator = CppSeqComparator,x = list,y = NULL</code>: Specialization for <code><a href="#topic+CppSeqComparator-class">CppSeqComparator</a></code> where <code>x</code> is
a list of sequences (vectors) to compare.
</p>
</li>
<li> <p><code>comparator = StringComparator,x = vector,y = vector</code>: Specialization for <code><a href="#topic+StringComparator-class">StringComparator</a></code> where <code>x</code>
and <code>y</code> are vectors of strings to compare.
</p>
</li>
<li> <p><code>comparator = StringComparator,x = vector,y = NULL</code>: Specialization for <code><a href="#topic+StringComparator-class">StringComparator</a></code> where <code>x</code>
is a vector of strings to compare.
</p>
</li>
<li> <p><code>comparator = NumericComparator,x = matrix,y = vector</code>: Specialization for <code><a href="#topic+NumericComparator-class">NumericComparator</a></code> where <code>x</code>
is a matrix of rows (interpreted as vectors) to compare with a vector <code>y</code>.
</p>
</li>
<li> <p><code>comparator = NumericComparator,x = vector,y = matrix</code>: Specialization for <code><a href="#topic+NumericComparator-class">NumericComparator</a></code> where <code>x</code>
is a vector to compare with a matrix <code>y</code> of rows (interpreted as vectors).
</p>
</li>
<li> <p><code>comparator = Chebyshev,x = matrix,y = matrix</code>: Specialization for <code><a href="#topic+Chebyshev">Chebyshev</a></code> where <code>x</code> and <code>y</code>
matrices of rows (interpreted as vectors) to compare.
</p>
</li>
<li> <p><code>comparator = Chebyshev,x = matrix,y = NULL</code>: Specialization for <code><a href="#topic+Minkowski">Minkowski</a></code> where <code>x</code> is a matrix
of rows (interpreted as vectors) to compare among themselves.
</p>
</li>
<li> <p><code>comparator = Minkowski,x = matrix,y = matrix</code>: Specialization for a <code><a href="#topic+Minkowski">Minkowski</a></code> where <code>x</code> and <code>y</code>
matrices of rows (interpreted as vectors) to compare.
</p>
</li>
<li> <p><code>comparator = Minkowski,x = matrix,y = matrix</code>: Specialization for a <code><a href="#topic+Minkowski">Minkowski</a></code> where <code>x</code> and <code>y</code>
matrices of rows (interpreted as vectors) to compare.
</p>
</li>
<li> <p><code>comparator = Minkowski,x = matrix,y = NULL</code>: Specialization for <code><a href="#topic+Minkowski">Minkowski</a></code> where <code>x</code> is a matrix
of rows (interpreted as vectors) to compare among themselves.
</p>
</li>
<li> <p><code>comparator = FuzzyTokenSet,x = list,y = list</code>: Specialization for <code><a href="#topic+FuzzyTokenSet">FuzzyTokenSet</a></code> where <code>x</code> and <code>y</code> are
lists of token vectors to compare.
</p>
</li>
<li> <p><code>comparator = FuzzyTokenSet,x = vector,y = NULL</code>: Specialization for <code><a href="#topic+FuzzyTokenSet">FuzzyTokenSet</a></code> where <code>x</code> is a list of token
vectors to compare among themselves.
</p>
</li>
<li> <p><code>comparator = InVocabulary,x = vector,y = vector</code>: Specialization for <code><a href="#topic+InVocabulary">InVocabulary</a></code> where <code>x</code> and <code>y</code>
are vectors of strings to compare.
</p>
</li>
<li> <p><code>comparator = InVocabulary,x = vector,y = NULL</code>: Specialization for <code><a href="#topic+InVocabulary">InVocabulary</a></code> where <code>x</code> is a
vector of strings to compare among themselves.
</p>
</li>
<li> <p><code>comparator = Lookup,x = vector,y = vector</code>: Specialization for a <code><a href="#topic+Lookup">Lookup</a></code> where <code>x</code> and <code>y</code> are
vectors of strings to compare
</p>
</li>
<li> <p><code>comparator = Lookup,x = vector,y = NULL</code>: Specialization for <code><a href="#topic+Lookup">Lookup</a></code> where <code>x</code> is a vector of
strings to compare among themselves
</p>
</li>
<li> <p><code>comparator = MongeElkan,x = list,y = list</code>: Specialization for <code><a href="#topic+MongeElkan">MongeElkan</a></code> where <code>x</code> and <code>y</code> are
lists of token vectors to compare.
</p>
</li>
<li> <p><code>comparator = MongeElkan,x = list,y = NULL</code>: Specialization for <code><a href="#topic+MongeElkan">MongeElkan</a></code> where <code>x</code> is a list
of token vectors to compare among themselves.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Computing the distances between a query point y (a 3D numeric vector) 
## and a set of reference points x
x &lt;- rbind(c(1,0,1), c(0,0,0), c(-1,2,-1))
y &lt;- c(10, 5, 10)
pairwise(Manhattan(), x, y)

## Computing the pairwise similarities among a set of strings
x &lt;- c("Benjamin", "Ben", "Benny", "Bne", "Benedict", "Benson")
comparator &lt;- DamerauLevenshtein(similarity = TRUE, normalize = TRUE)
pairwise(comparator, x, return_matrix = TRUE)  # return an ordinary matrix

</code></pre>

<hr>
<h2 id='PairwiseMatrix-class'>Pairwise Similarity/Distance Matrix</h2><span id='topic+PairwiseMatrix-class'></span><span id='topic+PairwiseMatrix'></span><span id='topic+as.PairwiseMatrix'></span><span id='topic+as.PairwiseMatrix+2Cmatrix-method'></span><span id='topic+as.matrix+2CPairwiseMatrix-method'></span>

<h3>Description</h3>

<p>Represents a pairwise similarity or distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PairwiseMatrix(x, ...)

## S4 method for signature 'matrix'
as.PairwiseMatrix(x, ...)

## S4 method for signature 'PairwiseMatrix'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PairwiseMatrix-class_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="PairwiseMatrix-class_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the elements being compared are from the same set, the matrix
may be symmetric if the comparator is symmetric. In this case, entries
in the upper triangle and/or along the diagonal may not be stored in
memory, since they are redundant.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as.PairwiseMatrix</code>: Convert an R object <code>x</code> to a <code>PairwiseMatrix</code>.
</p>
</li>
<li> <p><code>as.PairwiseMatrix,matrix-method</code>: Convert an ordinary <code><a href="base.html#topic+matrix">matrix</a></code> <code>x</code> to a <code>PairwiseMatrix</code>.
</p>
</li>
<li> <p><code>as.matrix,PairwiseMatrix-method</code>: Convert a <code>PairwiseMatrix</code> <code>x</code> to an ordinary <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>entries of the matrix in column-major order. Entries in the
upper triangle and/or on the diagonal may be omitted.</p>
</dd>
<dt><code>Dim</code></dt><dd><p>integer vector of length 2. The dimensions of the matrix.</p>
</dd>
<dt><code>Diag</code></dt><dd><p>logical indicating whether the diagonal entries are stored in
<code>.Data</code>.</p>
</dd>
</dl>

<hr>
<h2 id='SequenceComparator-class'>Virtual Sequence Comparator Class</h2><span id='topic+SequenceComparator-class'></span>

<h3>Description</h3>

<p>Represents a comparator for pairs of sequences.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a function that calls the elementwise method for this class,
with arguments <code>x</code>, <code>y</code> and <code>...</code>.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>a logical of length 1. If TRUE, the comparator is symmetric
in its arguments&mdash;i.e. <code>comparator(x, y)</code> is identical to
<code>comparator(y, x)</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
distances and satisfies <code>comparator(x, x) = 0</code>. The comparator may not
satisfy all of the properties of a distance metric.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
similarity scores.</p>
</dd>
<dt><code>tri_inequal</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator satisfies
the triangle inequality. This is only possible (but not guaranteed) if
<code>distance = TRUE</code> and <code>symmetric = TRUE</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StringComparator-class'>Virtual String Comparator Class</h2><span id='topic+StringComparator-class'></span>

<h3>Description</h3>

<p>Represents a comparator for pairs of strings.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a function that calls the elementwise method for this class,
with arguments <code>x</code>, <code>y</code> and <code>...</code>.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>a logical of length 1. If TRUE, the comparator is symmetric
in its arguments&mdash;i.e. <code>comparator(x, y)</code> is identical to
<code>comparator(y, x)</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
distances and satisfies <code>comparator(x, x) = 0</code>. The comparator may not
satisfy all of the properties of a distance metric.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
similarity scores.</p>
</dd>
<dt><code>tri_inequal</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator satisfies
the triangle inequality. This is only possible (but not guaranteed) if
<code>distance = TRUE</code> and <code>symmetric = TRUE</code>.</p>
</dd>
<dt><code>ignore_case</code></dt><dd><p>a logical of length 1. If TRUE, case is ignored when
comparing strings. Defaults to FALSE.</p>
</dd>
<dt><code>use_bytes</code></dt><dd><p>a logical of length 1. If TRUE, strings are compared
byte-by-byte rather than character-by-character.</p>
</dd>
</dl>

<hr>
<h2 id='TokenComparator-class'>Virtual Token Comparator Class</h2><span id='topic+TokenComparator-class'></span>

<h3>Description</h3>

<p>Represents a comparator for pairs of token sequences.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>a function that calls the elementwise method for this class,
with arguments <code>x</code>, <code>y</code> and <code>...</code>.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>a logical of length 1. If TRUE, the comparator is symmetric
in its arguments&mdash;i.e. <code>comparator(x, y)</code> is identical to
<code>comparator(y, x)</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
distances and satisfies <code>comparator(x, x) = 0</code>. The comparator may not
satisfy all of the properties of a distance metric.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator produces
similarity scores.</p>
</dd>
<dt><code>tri_inequal</code></dt><dd><p>a logical of length 1. If <code>TRUE</code>, the comparator satisfies
the triangle inequality. This is only possible (but not guaranteed) if
<code>distance = TRUE</code> and <code>symmetric = TRUE</code>.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>a logical of length 1. If TRUE, the comparator treats token
sequences as ordered, otherwise they are treated as unordered.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
