<!DOCTYPE html><html><head><title>Help for package depmixS4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {depmixS4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#depmixS4-package'>
<p>depmixS4 provides classes for specifying and fitting hidden Markov models</p>
</p></a></li>
<li><a href='#balance'><p>Balance Scale Data</p></a></li>
<li><a href='#depmix'><p>Dependent Mixture Model Specifiction</p></a></li>
<li><a href='#depmix-class'><p>Class &quot;depmix&quot;</p></a></li>
<li><a href='#depmix-internal'><p>DepmixS4 internal functions</p></a></li>
<li><a href='#depmix-methods'><p> 'depmix' and 'mix' methods.</p></a></li>
<li><a href='#depmix.fitted-class'><p>Class &quot;depmix.fitted&quot; (and  &quot;depmix.fitted.classLik&quot;)</p></a></li>
<li><a href='#depmix.sim-class'><p>Class &quot;depmix.sim&quot;</p></a></li>
<li><a href='#em.control'><p>Control parameters for the EM algorithm</p></a></li>
<li><a href='#fit'><p>Fit 'depmix' or 'mix' models</p></a></li>
<li><a href='#formatperc'><p>Format percentage for level in printing confidence interval</p></a></li>
<li><a href='#forwardbackward'><p> Forward and backward variables</p></a></li>
<li><a href='#GLMresponse'><p>Methods for creating depmix response models</p></a></li>
<li><a href='#llratio'><p>Log likelihood ratio test on two fitted models</p></a></li>
<li><a href='#makeDepmix'><p>Dependent Mixture Model Specifiction: full control and adding response models</p></a></li>
<li><a href='#mix'><p> Mixture Model Specifiction</p></a></li>
<li><a href='#mix-class'><p>Class &quot;mix&quot;</p></a></li>
<li><a href='#mix.fitted-class'><p>Class &quot;mix.fitted&quot; (and &quot;mix.fitted.classLik&quot;)</p></a></li>
<li><a href='#mix.sim-class'><p>Class &quot;mix.sim&quot;</p></a></li>
<li><a href='#multistart'><p>Methods to fit a (dep-)mix model using multiple sets of starting values</p></a></li>
<li><a href='#posterior'><p>Posterior state/class probabilities and classification</p></a></li>
<li><a href='#response-class'><p>Class &quot;response&quot;</p></a></li>
<li><a href='#response-classes'><p>Class &quot;GLMresponse&quot; and class &quot;transInit&quot;</p></a></li>
<li><a href='#responses'><p>Response models currently implemented in depmix.</p></a></li>
<li><a href='#simulate'><p>Methods to simulate from (dep-)mix models</p></a></li>
<li><a href='#sp500'><p>Standard &amp; Poor's 500 index</p></a></li>
<li><a href='#speed'><p>Speed Accuracy Switching Data</p></a></li>
<li><a href='#stationary'><p>Compute the stationary distribution of a transition probability matrix.</p></a></li>
<li><a href='#transInit'><p>Methods for creating depmix transition and initial probability models</p></a></li>
<li><a href='#vcov'><p> Parameter standard errors</p></a></li>
<li><a href='#viterbi'><p>Viterbi algorithm for decoding the most likely state sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Dependent Mixture Models - Hidden Markov Models of GLMs and
Other Distributions in S4</td>
</tr>
<tr>
<td>Author:</td>
<td>Ingmar Visser &lt;i.visser@uva.nl&gt;, Maarten Speekenbrink &lt;m.speekenbrink@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ingmar Visser &lt;i.visser@uva.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), nnet, MASS, Rsolnp, nlme</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, stats4, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gamlss, gamlss.dist, Rdonlp2</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="http://R-Forge.R-project.org">http://R-Forge.R-project.org</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fits latent (hidden) Markov models on mixed categorical and continuous (time series) data, otherwise known as dependent mixture models, see Visser &amp; Speekenbrink (2010, &lt;<a href="https://doi.org/10.18637%2Fjss.v036.i07">doi:10.18637/jss.v036.i07</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://depmix.github.io/">https://depmix.github.io/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-12 07:59:42 UTC; ingmar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-12 12:12:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='depmixS4-package'>
depmixS4 provides classes for specifying and fitting hidden Markov models
</h2><span id='topic+depmixS4'></span><span id='topic+depmixS4-package'></span>

<h3>Description</h3>

<p><code>depmixS4</code> is a framework for specifying and fitting dependent
mixture models, otherwise known as hidden or latent Markov models.
Optimization is done with the EM algorithm or optionally with Rdonlp2
when (general linear (in-)equality) constraints on the parameters need
to be incorporated.  Models can be fitted on (multiple) sets of
observations.  The response densities for each state may be chosen from
the GLM family, or a multinomial.  User defined response densities are
easy to add; for the latter an example is given for the ex-gauss distribution
as well as the multivariate normal distribution. 
</p>
<p>Mixture or latent class (regression) models can also be fitted; these
are the limit case in which the length of observed time series is 1 for
all cases. 
</p>


<h3>Details</h3>

<p>Model fitting is done in two steps; first, models are specified through
the <code><a href="#topic+depmix">depmix</a></code> function (or the <code><a href="#topic+mix">mix</a></code> function for
mixture and latent class models), which both use standard
<code><a href="stats.html#topic+glm">glm</a></code> style arguments to specify the observed
distributions; second, the model needs to be fitted by using the
<code><a href="#topic+fit">fit</a></code> function; imposing constraints is done through the
fit function.  Standard output includes the optimized parameters and
the posterior densities for the states and the optimal state sequence.
</p>
<p>For full control and the possibility to add new response distributions,
check the <code><a href="#topic+makeDepmix">makeDepmix</a></code> help page. 
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink
</p>
<p>Maintainer: i.visser@uva.nl
</p>


<h3>References</h3>

<p>Ingmar Visser and Maarten Speekenbrink (2010).  depmixS4: An R Package for
Hidden Markov Models. <em>Journal of Statistical Software, 36(7)</em>, p. 1-21.
</p>
<p>On hidden Markov models: Lawrence R. Rabiner (1989).  A tutorial on
hidden Markov models and selected applications in speech recognition.
<em>Proceedings of IEEE</em>, 77-2, p.  267-295.
</p>
<p>On latent class models: A. L. McCutcheon (1987).  <em>Latent class
analysis</em>.  Sage Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depmix">depmix</a></code>, <code><a href="#topic+fit">fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# create a 2 state model with one continuous and one binary response
	data(speed)
	mod &lt;- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))
	# print the model, formulae and parameter values (ie the starting values)
	mod
</code></pre>

<hr>
<h2 id='balance'>Balance Scale Data</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>Balance scale data of four distance items from 779 participants;
participants ages are included.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(balance)</code></pre>


<h3>Format</h3>

<p>A data frame with 779 observations on the following variables. The full 
dataset is described and analyzed extensively in 
Jansen &amp; Van der Maas (2002). The trichotomous data are left, balance, right. 
The dichotomous version of the data is scored correct, incorrect. 
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Participants sex.</p>
</dd>
<dt><code>agedays</code></dt><dd><p>Age in days.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years.</p>
</dd>
<dt><code>t1</code></dt><dd><p>Trichotomously scored distance item.</p>
</dd>
<dt><code>t2</code></dt><dd><p>Trichotomously scored distance item.</p>
</dd>
<dt><code>t3</code></dt><dd><p>Trichotomously scored distance item.</p>
</dd>
<dt><code>t4</code></dt><dd><p>Trichotomously scored distance item.</p>
</dd>
<dt><code>d1</code></dt><dd><p>Dichotomously scored distance item.</p>
</dd>
<dt><code>d2</code></dt><dd><p>Dichotomously scored distance item.</p>
</dd>
<dt><code>d3</code></dt><dd><p>Dichotomously scored distance item.</p>
</dd>
<dt><code>d4</code></dt><dd><p>Dichotomously scored distance item.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Brenda Jansen &amp; Han van der Maas (2002). The development of
children's rule use on the balance scale task. <em>Journal 
of experimental Child Psychology, 81</em>, p. 383-416.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(balance)
</code></pre>

<hr>
<h2 id='depmix'>Dependent Mixture Model Specifiction</h2><span id='topic+depmix'></span><span id='topic+depmix+2CANY-method'></span><span id='topic+show'></span><span id='topic+summary'></span><span id='topic+show+2Cdepmix-method'></span><span id='topic+summary+2Cdepmix-method'></span>

<h3>Description</h3>

<p><code>depmix</code> creates an object of class <code>depmix</code>, a dependent
mixture model, otherwise known as hidden Markov model.  For a short
description of the package see <code><a href="#topic+depmixS4">depmixS4</a></code>. See the vignette 
for an introduction to hidden Markov models and the package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	depmix(response, data=NULL, nstates, transition=~1, family=gaussian(), 
		prior=~1, initdata=NULL, respstart=NULL, trstart=NULL, instart=NULL,
		ntimes=NULL,...)
	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depmix_+3A_response">response</code></td>
<td>
<p>The response to be modeled; either a formula or a list 
of formulae (in the multivariate case); this interfaces to the glm
and other distributions. See 'Details'.</p>
</td></tr>
<tr><td><code id="depmix_+3A_data">data</code></td>
<td>
<p>An optional <code>data.frame</code> to interpret the variables in
the response and transition arguments.</p>
</td></tr>
<tr><td><code id="depmix_+3A_nstates">nstates</code></td>
<td>
<p>The number of states of the model.</p>
</td></tr>
<tr><td><code id="depmix_+3A_transition">transition</code></td>
<td>
<p>A one-sided formula specifying the model for the 
transitions. See 'Details'.</p>
</td></tr>
<tr><td><code id="depmix_+3A_family">family</code></td>
<td>
<p>A family argument for the response. This must be a list
of <code>family</code>'s if the response is multivariate.</p>
</td></tr>
<tr><td><code id="depmix_+3A_prior">prior</code></td>
<td>
<p>A one-sided formula specifying the density for the prior
or initial state probabilities.</p>
</td></tr>
<tr><td><code id="depmix_+3A_initdata">initdata</code></td>
<td>
<p>An optional data.frame to interpret the variables
occuring in <code>prior</code>.  The number of rows of this data.frame
must be equal to the number of cases being modeled,
<code>length(ntimes)</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="depmix_+3A_respstart">respstart</code></td>
<td>
<p>Starting values for the parameters of the response
models.</p>
</td></tr>
<tr><td><code id="depmix_+3A_trstart">trstart</code></td>
<td>
<p>Starting values for the parameters of the transition
models.</p>
</td></tr>
<tr><td><code id="depmix_+3A_instart">instart</code></td>
<td>
<p>Starting values for the parameters of the prior or
initial state probability model.</p>
</td></tr>
<tr><td><code id="depmix_+3A_ntimes">ntimes</code></td>
<td>
<p>A vector specifying the lengths of individual, i.e.
independent, time series. If not specified, the responses are
assumed to form a single time series, i.e. <code>ntimes=nrow(data)</code>.
If the <code>data</code> argument has an attribute <code>ntimes</code>, then this 
is used. The first example in <code><a href="#topic+fit">fit</a></code> uses this argument.</p>
</td></tr>
<tr><td><code id="depmix_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The function <code>depmix</code> creates an S4 object of class <code>depmix</code>,
which needs to be fitted using <code><a href="#topic+fit">fit</a></code> to optimize the
parameters.
</p>
<p>The response model(s) are by default created by call(s) to
<code>GLMresponse</code> using the <code>formula</code> and the <code>family</code>
arguments, the latter specifying the error distribution.  See
<code><a href="#topic+GLMresponse">GLMresponse</a></code> for possible values of the <code>family</code>
argument for <code>glm</code>-type responses (ie a subset of the <code>glm</code>
family options, and the multinomial).  Alternative response
distributions are specified by using the <code><a href="#topic+makeDepmix">makeDepmix</a></code>
function.  Its help page has examples of specifying a model with a
multivariate normal response, as well as an example of adding a
user-defined response model, in this case for the ex-gauss
distribution. 
</p>
<p>If <code>response</code> is a list of formulae, the <code>response</code>'s are
assumed to be independent conditional on the latent state.
</p>
<p>The transitions are modeled as a multinomial logistic model for each
state.  Hence, the transition matrix can be modeled using time-varying
covariates.  The prior density is also modeled as a multinomial
logistic.  Both of these models are created by calls to
<code><a href="#topic+transInit">transInit</a></code>.
</p>
<p>Starting values for the initial, transition, and response models may be
provided by their respective arguments.  NB: note that the starting
values for the initial and transition models as well as of the
multinomial logit response models are interpreted as probabilities, and
internally converted to multinomial logit parameters.  The order in
which parameters must be provided can be easily studied by using the
<code><a href="#topic+setpars">setpars</a></code> and <code><a href="#topic+getpars">getpars</a></code> functions.
</p>
<p>Linear constraints on parameters can be provided as argument to the
<code><a href="#topic+fit">fit</a></code> function.
</p>
<p>The print function prints the formulae for the response, transition and
prior models along with their parameter values.
</p>
<p>Missing values are allowed in the data, but missing values in the 
covariates lead to errors. 
</p>


<h3>Value</h3>

<p><code>depmix</code> returns an object of class <code>depmix</code> which has the
following slots:
</p>
<table>
<tr><td><code>response</code></td>
<td>
<p>A list of a list of response models; the first
index runs over states; the second index runs over the independent 
responses in case a multivariate response is provided.</p>
</td></tr>
<tr><td><code>transition</code></td>
<td>
<p>A list of <code>transInit</code> models, ie multinomial
logistic models with length the number of states.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A multinomial logistic model for the initial state
probabilities.</p>
</td></tr>
<tr><td><code>dens</code>, <code>trDens</code>, <code>init</code></td>
<td>
<p>See <code><a href="#topic+depmix-class">depmix-class</a></code> help for
details.  For internal use.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Logical indicating whether the transitions are
time-dependent or not; for internal use.</p>
</td></tr>
<tr><td><code>ntimes</code></td>
<td>
<p>A vector containing the lengths of independent time
series.</p>
</td></tr>
<tr><td><code>nstates</code></td>
<td>
<p>The number of states of the model.</p>
</td></tr>
<tr><td><code>nresp</code></td>
<td>
<p>The number of independent responses.</p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>The total number of parameters of the model.  Note: this
is <em>not</em> the degrees of freedom because there are redundancies in the
parameters, in particular in the multinomial models for the transitions
and prior probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Models are not fitted; the return value of <code>depmix</code> is a model
specification without optimized parameter values. Use the <code><a href="#topic+fit">fit</a></code>
function to optimize parameters, and to specify additional constraints.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>References</h3>

<p>Ingmar Visser and Maarten Speekenbrink (2010).  depmixS4: An R Package for
Hidden Markov Models. <em>Journal of Statistical Software, 36(7)</em>, p. 1-21.
</p>
<p>Lawrence R. Rabiner (1989).  A tutorial on hidden Markov models and
selected applications in speech recognition.  <em>Proceedings of
IEEE</em>, 77-2, p. 267-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code>, <code><a href="#topic+transInit">transInit</a></code>, <code><a href="#topic+GLMresponse">GLMresponse</a></code>,
<code><a href="#topic+depmix-methods">depmix-methods</a></code> for accessor functions to <code>depmix</code>
objects. 	
</p>
<p>For full control see the <code><a href="#topic+makeDepmix">makeDepmix</a></code> help page and its
example section for the possibility to add user-defined response
distributions. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2 state model with one continuous and one binary response
# ntimes is used to specify the lengths of 3 separate series
data(speed)	
mod &lt;- depmix(list(rt~1,corr~1),data=speed,nstates=2,
    family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
# print the model, formulae and parameter values
mod
set.seed(1)
# fit the model by calling fit
fm &lt;- fit(mod)

# Volatility of S &amp; P 500 returns
# (thanks to Chen Haibo for providing this example)

data(sp500)

# fit some models
msp &lt;- depmix(logret~1,nstates=2,data=sp500)
set.seed(1)
fmsp &lt;- fit(msp)	

# plot posterior state sequence for the 2-state model
plot(ts(posterior(fmsp, type="smoothing")[,1], start=c(1950,2),deltat=1/12),ylab="probability",
main="Posterior probability of state 1 (volatile, negative markets).",
frame=FALSE)

## Not run: 

# this creates data with a single change point with Poisson data
set.seed(3)
y1 &lt;- rpois(50,1)
y2 &lt;- rpois(50,2)
ydf &lt;- data.frame(y=c(y1,y2))

# fit models with 1 to 3 states
m1 &lt;- depmix(y~1,ns=1,family=poisson(),data=ydf)
set.seed(1)
fm1 &lt;- fit(m1)
m2 &lt;- depmix(y~1,ns=2,family=poisson(),data=ydf)
set.seed(1)
fm2 &lt;- fit(m2)
m3 &lt;- depmix(y~1,ns=3,family=poisson(),data=ydf)
set.seed(1)
fm3 &lt;- fit(m3,em=em.control(maxit=500))

# plot the BICs to select the proper model
plot(1:3,c(BIC(fm1),BIC(fm2),BIC(fm3)),ty="b")


## End(Not run)

## Not run: 
# similar to the binomial model, data may also be entered in 
# multi-column format where the n for each row can be different
dt &lt;- data.frame(y1=c(0,1,1,2,4,5),y2=c(1,0,1,0,1,0),y3=c(4,4,3,2,1,1))
# specify a mixture model ...
m2 &lt;- mix(cbind(y1,y2,y3)~1,data=dt,ns=2,family=multinomial("identity"))
set.seed(1)
fm2 &lt;- fit(m2)
# ... or dependent mixture model
dm2 &lt;- depmix(cbind(y1,y2,y3)~1,data=dt,ns=2,family=multinomial("identity"))
set.seed(1)
fdm2 &lt;- fit(dm2)

## End(Not run)



</code></pre>

<hr>
<h2 id='depmix-class'>Class &quot;depmix&quot;</h2><span id='topic+depmix-class'></span><span id='topic+nresp'></span><span id='topic+nresp+2Cdepmix-method'></span><span id='topic+ntimes'></span><span id='topic+ntimes+2Cdepmix-method'></span><span id='topic+nstates'></span><span id='topic+nstates+2Cdepmix-method'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+depmix">depmix</a></code> model.</p>


<h3>Slots</h3>


<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>transition</code></dt><dd><p>List of <code><a href="#topic+transInit">transInit</a></code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code><a href="#topic+transInit">transInit</a></code> object.</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>trDens</code>:</dt><dd><p>Array of dimension <code>sum(ntimes)</code>*nstates
providing the probability of a state transition depending on the
predictors.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension <code>length(ntimes)</code>*nstates with 
the current predictions for the initial state probabilities.</p>
</dd>
<dt><code>homogeneous</code>:</dt><dd><p>Logical indicating whether the transitions are
time-dependent or not; for internal use.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector containing the lengths of independent time
series; if data is provided, sum(ntimes) must be equal to
nrow(data).</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model. This is not
the degrees of freedom, ie there are redundancies in the
parameters, in particular in the multinomial models for the
transitions and prior.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of responses.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>The vector of independent time series lengths.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>

<hr>
<h2 id='depmix-internal'>DepmixS4 internal functions</h2><span id='topic+dens'></span><span id='topic+em'></span><span id='topic+fb'></span><span id='topic+logDens'></span><span id='topic+lystig'></span><span id='topic+makePriorModel'></span><span id='topic+makeResponseModels'></span><span id='topic+makeTransModels'></span><span id='topic+hess2cov'></span><span id='topic+mlogit'></span><span id='topic+multinomial'></span><span id='topic+pa2conr'></span><span id='topic+cov2par'></span><span id='topic+par2cov'></span><span id='topic+getConstraints'></span><span id='topic+getConstraints+2Cmix-method'></span><span id='topic+nlin'></span><span id='topic+nlin+2Cdepmix.fitted-method'></span><span id='topic+nlin+2Cmix.fitted-method'></span><span id='topic+dens+2CGLMresponse-method'></span><span id='topic+dens+2CBINOMresponse-method'></span><span id='topic+dens+2CNORMresponse-method'></span><span id='topic+dens+2CGAMMAresponse-method'></span><span id='topic+dens+2CPOISSONresponse-method'></span><span id='topic+dens+2CMVNresponse-method'></span><span id='topic+dens+2CMULTINOMresponse-method'></span><span id='topic+dens+2CtransInit-method'></span><span id='topic+fit+2CGLMresponse-method'></span><span id='topic+fit+2CBINOMresponse-method'></span><span id='topic+fit+2CNORMresponse-method'></span><span id='topic+fit+2CMULTINOMresponse-method'></span><span id='topic+fit+2CMVNresponse-method'></span><span id='topic+fit+2CtransInit-method'></span><span id='topic+logLik+2CGLMresponse-method'></span><span id='topic+predict+2CGLMresponse-method'></span><span id='topic+predict+2CBINOMresponse-method'></span><span id='topic+predict+2CNORMresponse-method'></span><span id='topic+predict+2CMULTINOMresponse-method'></span><span id='topic+predict+2CtransInit-method'></span><span id='topic+predict+2CMVNresponse-method'></span><span id='topic+getpars+2CGLMresponse-method'></span><span id='topic+setpars+2CGLMresponse-method'></span><span id='topic+getpars+2CMVNresponse-method'></span><span id='topic+setpars+2CMVNresponse-method'></span><span id='topic+npar+2Cresponse-method'></span><span id='topic+MVNresponse+2Cformula-method'></span>

<h3>Description</h3>

<p>Internal depmix functions, methods and classes.
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>

<hr>
<h2 id='depmix-methods'> 'depmix' and 'mix' methods. </h2><span id='topic+depmix-methods'></span><span id='topic+logLik'></span><span id='topic+logLik+2Cdepmix-method'></span><span id='topic+logLik+2Cmix-method'></span><span id='topic+logLik+2Cdepmix.fitted.classLik-method'></span><span id='topic+logLik+2Cmix.fitted.classLik-method'></span><span id='topic+nobs'></span><span id='topic+nobs+2Cdepmix-method'></span><span id='topic+nobs+2Cmix-method'></span><span id='topic+npar'></span><span id='topic+npar+2Cdepmix-method'></span><span id='topic+npar+2Cmix-method'></span><span id='topic+freepars'></span><span id='topic+freepars+2Cdepmix-method'></span><span id='topic+freepars+2Cmix-method'></span><span id='topic+freepars+2Cdepmix.fitted-method'></span><span id='topic+freepars+2Cmix.fitted-method'></span><span id='topic+setpars'></span><span id='topic+setpars+2Cdepmix-method'></span><span id='topic+setpars+2Cmix-method'></span><span id='topic+getpars'></span><span id='topic+getpars+2Cdepmix-method'></span><span id='topic+getpars+2Cmix-method'></span><span id='topic+getmodel'></span><span id='topic+getmodel+2Cdepmix-method'></span><span id='topic+getmodel+2Cmix-method'></span>

<h3>Description</h3>

<p>Various methods for <code>depmix</code> and <code>mix</code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	## S4 method for signature 'depmix'
logLik(object,method=c("fb","lystig","classification"),na.allow=TRUE)
	## S4 method for signature 'mix'
logLik(object,method=c("fb","lystig","classification"),na.allow=TRUE)
	
	## S4 method for signature 'depmix.fitted.classLik'
logLik(object,method=c("classification","fb","lystig"),na.allow=TRUE)
	## S4 method for signature 'mix.fitted.classLik'
logLik(object,method=c("classification","fb","lystig"),na.allow=TRUE)
	
	## S4 method for signature 'depmix'
nobs(object, ...)
	## S4 method for signature 'mix'
nobs(object, ...)
	
	## S4 method for signature 'depmix'
npar(object)
	## S4 method for signature 'mix'
npar(object)
	
	## S4 method for signature 'depmix'
freepars(object)
	## S4 method for signature 'mix'
freepars(object)
	
	## S4 method for signature 'depmix'
setpars(object,values, which="pars",...)
	## S4 method for signature 'mix'
setpars(object,values, which="pars",...)
	
	## S4 method for signature 'depmix'
getpars(object,which="pars",...)	
	## S4 method for signature 'mix'
getpars(object,which="pars",...)	
	
	## S4 method for signature 'depmix'
getmodel(object,which="response",state=1,number=1)	
	## S4 method for signature 'mix'
getmodel(object,which="response",state=1,number=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depmix-methods_+3A_object">object</code></td>
<td>
<p>A <code>depmix</code> or <code>mix</code> object.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_values">values</code></td>
<td>
<p>To be used in <code>setpars</code> to set new parameter values; see
the example.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_method">method</code></td>
<td>
<p>The log likelihood can be computed by either the forward
backward algorithm (Rabiner, 1989), or by the method of Lystig and
Hughes, 2002. The former is the default and implemented in a fast
C routine. The forward-backward routine also computes the state and transition 
smoothed probabilities, which are not directly neccessary for the log likelihood.  
Those smoothed variables, and the forward and backward variables are accessible
through the <code><a href="#topic+forwardbackward">forwardbackward</a></code> function. When method=&quot;classification&quot;,
the classification likelihood is computed, which is the likelihood of the data 
assuming the state sequence is known and equal to the maximum a posteriori state 
sequence. The MAP state sequence is available through the <code><a href="#topic+viterbi">viterbi</a></code>
function. The classification likelihood is comuted by default when calling the 
logLik method on an a model fitted by maximising the classification likelihood.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_na.allow">na.allow</code></td>
<td>
<p>Allow missing observations? When set to FALSE,
the logLik method will return NA in the presence of missing observations. 
When set to TRUE, missing values will be ignored when computing the likelihood.
When observations are partly missing (when a multivariate observation has missing
values on only some of its dimensionis), this may give unexpected results.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_which">which</code></td>
<td>
<p><code>getpars</code> function: The default &quot;pars&quot; returns a vector
of all parameters of a <code>depmix</code> object; the alternative value
&quot;fixed&quot; returns a logical vector of the same length indicating which
parameters are fixed.  The setpars functions sets parameters to new
values; <code>setpars</code> also recomputes the dens, trans and init slots of
<code>depmix</code> objects.  Note that the <code>getpars</code> and <code>setpars</code>
functions for <code>depmix</code> objects simply call the functions of the same
name for the response and transition models.
</p>
<p><code>getmodel</code> function: possible values are &quot;response&quot; (the default),
&quot;prior&quot; and &quot;transition&quot; to return the corresponding submodels.  </p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_state">state</code></td>
<td>
<p>In <code>getmodel</code> this determines the submodel to be
returned (together with number in the case of response models); when
which=&quot;transition&quot;, <code>getmodel</code> returns the transition submodel for
state=<code>state</code>.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_number">number</code></td>
<td>
<p>In <code>getmodel</code> this determines the &quot;response&quot; model to
be returned from state <code>state</code>.</p>
</td></tr>
<tr><td><code id="depmix-methods_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>logLik</code></td>
<td>
<p>returns a <code>logLik</code> object with attributes <code>df</code> and <code>nobs</code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>returns the number of observations (used in computing the BIC).</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>returns the number of paramaters of a model.</p>
</td></tr>
<tr><td><code>freepars</code></td>
<td>
<p>returns the number of non-redundant parameters.</p>
</td></tr>
<tr><td><code>setpars</code></td>
<td>
<p>returns a <code>(dep-)mix</code> object with new parameter values.</p>
</td></tr>
<tr><td><code>getpars</code></td>
<td>
<p>returns a vector with the current parameter values.</p>
</td></tr>
<tr><td><code>getmodel</code></td>
<td>
<p>returns a submodel of a <code>(dep-)mix</code> model; the prior
model, one of the transition models (determined by argument state) or one
of the response models (determined by arguments state and number).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a 2 state model with one continuous and one binary response
data(speed)
mod &lt;- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))

getmodel(mod,"response",2,1)

getmodel(mod,"prior")

# get the loglikelihood of the model
logLik(mod)

# to see the ordering of parameters to use in setpars
mod &lt;- setpars(mod, value=1:npar(mod))
mod

# to see which parameters are fixed (by default only baseline parameters in
# the multinomial logistic models for the transition models and the initial
# state probabilities model)
mod &lt;- setpars(mod, getpars(mod,which="fixed"))
mod

</code></pre>

<hr>
<h2 id='depmix.fitted-class'>Class &quot;depmix.fitted&quot; (and  &quot;depmix.fitted.classLik&quot;)</h2><span id='topic+depmix.fitted'></span><span id='topic+depmix.fitted-class'></span><span id='topic+depmix.fitted.classLik'></span><span id='topic+depmix.fitted.classLik-class'></span>

<h3>Description</h3>

<p>A fitted <code><a href="#topic+depmix">depmix</a></code> model.</p>


<h3>Slots</h3>

<p>A <code>depmix.fitted</code> object is a <code>depmix</code> object with three 
additional slots, here is the complete list:
</p>

<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>transition</code></dt><dd><p>List of <code>transInit</code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code>transInit</code> object.</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>trDens</code>:</dt><dd><p>Array of dimension <code>sum(ntimes)</code>*nstates
providing the probability of a state transition depending on the
predictors.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension <code>length(ntimes)</code>*nstates with 
the current predictions for the initial state probabilities.</p>
</dd>
<dt><code>stationary</code>:</dt><dd><p>Logical indicating whether the transitions are
time-dependent or not; for internal use.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector containing the lengths of independent time
series; if data is provided, sum(ntimes) must be equal to
nrow(data).</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model. This is not
the degrees of freedom, ie there are redundancies in the
parameters, in particular in the multinomial models for the
transitions and prior.</p>
</dd>
<dt><code>message</code>:</dt><dd><p>This provides some information on convergence,
either from the EM algorithm or from Rdonlp2.</p>
</dd>
<dt><code>conMat</code>:</dt><dd><p>The linear constraint matrix, which has zero rows
if there were no constraints.</p>
</dd>
<dt><code>lin.lower</code></dt><dd><p>The lower bounds on the linear constraints.</p>
</dd>
<dt><code>lin.upper</code></dt><dd><p>The upper bounds on the linear constraints.</p>
</dd>		
<dt><code>posterior</code>:</dt><dd><p>Posterior (Viterbi) state sequence.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The print function shows some convergence information, and the summary
method shows the parameter estimates.
</p>


<h3>Extends</h3>

<p><code>depmix.fitted</code> extends the <code>"<a href="#topic+depmix-class">depmix</a>"</code> class directly. <code>depmix.fitted.classLik</code> is
similar to <code>depmix.fitted</code>, the only difference being that the model is fitted
by maximising the classification likelihood.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>

<hr>
<h2 id='depmix.sim-class'>Class &quot;depmix.sim&quot;</h2><span id='topic+depmix.sim'></span><span id='topic+depmix.sim-class'></span><span id='topic+nresp+2Cdepmix.sim-method'></span><span id='topic+ntimes+2Cdepmix.sim-method'></span><span id='topic+nstates+2Cdepmix.sim-method'></span>

<h3>Description</h3>

<p>A <code>depmix.sim</code> model. The <code>depmix.sim</code> class directly
extends the <code><a href="#topic+depmix">depmix</a></code> class, and has an additional slot for the
true states. A <code>depmix.sim</code> model can be generated by
<code>simulate(mod,...)</code>, where <code>mod</code> is a <code><a href="#topic+depmix">depmix</a></code> model.</p>


<h3>Slots</h3>


<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>transition</code></dt><dd><p>List of <code><a href="#topic+transInit">transInit</a></code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code><a href="#topic+transInit">transInit</a></code> object.</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>trDens</code>:</dt><dd><p>Array of dimension <code>sum(ntimes)</code>*nstates
providing the probability of a state transition depending on the
predictors.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension <code>length(ntimes)</code>*nstates with 
the current predictions for the initial state probabilities.</p>
</dd>
<dt><code>homogeneous</code>:</dt><dd><p>Logical indicating whether the transitions are
time-dependent or not; for internal use.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector containing the lengths of independent time
series; if data is provided, sum(ntimes) must be equal to
nrow(data).</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model. This is not
the degrees of freedom, ie there are redundancies in the
parameters, in particular in the multinomial models for the
transitions and prior.</p>
</dd>
<dt><code>states</code>:</dt><dd><p>A matrix with the true states.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of responses.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>The vector of independent time series lengths.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>

<hr>
<h2 id='em.control'>Control parameters for the EM algorithm</h2><span id='topic+em.control'></span>

<h3>Description</h3>

<p>Set control parameters for the EM algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	em.control(maxit = 500, tol = 1e-08, crit = c("relative","absolute"), 
	random.start = TRUE, classification = c("soft","hard"))
	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em.control_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="em.control_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for convergence. See Details.</p>
</td></tr>
<tr><td><code id="em.control_+3A_crit">crit</code></td>
<td>
<p>Sets the convergence criterion to &quot;relative&quot; or &quot;absolute&quot; 
change of the log-likelihood. See Details.</p>
</td></tr>
<tr><td><code id="em.control_+3A_random.start">random.start</code></td>
<td>
<p>This is used for a (limited) random
initialization of the parameters. See Details.</p>
</td></tr>
<tr><td><code id="em.control_+3A_classification">classification</code></td>
<td>
<p>Type of classification to states
used. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>crit</code> sets the convergence criterion to either the
relative change in the log-likelihood or the absolute change in the
log-likelihood.  The relative likelihood criterion (the default) assumes
convergence on iteration <code class="reqn">i</code> when 
<code class="reqn">\frac{\log L(i) - \log L(i-1)}{\log L(i-1)} &lt; tol</code>.  
The absolute likelihood criterion assumes convergence on iteration
<code class="reqn">i</code> when <code class="reqn">\log L(i) - \log L(i-1) &lt; tol</code>.  
Use <code>crit="absolute"</code> to invoke the latter
convergence criterion.  Note that in that case, optimal values of the 
tolerance parameter <code>tol</code> scale with the value of the log-likelihood
(and these are not changed automagically). 
</p>
<p>Argument <code>random.start</code> This is used for a (limited) random
initialization of the parameters.  In particular, if
<code>random.start=TRUE</code>, the (posterior) state probabilities are
randomized at iteration 0 (using a uniform distribution), i.e. the 
<code class="reqn">\gamma</code> variables (Rabiner, 1989) are sampled from the Dirichlet
distribution with a (currently fixed) value of
<code class="reqn">\alpha=0.1</code>; this results in values for each row of <code class="reqn">\gamma</code>
that are quite close to zero and one; note that when these values are
chosen at zero and one, the initialization is similar to that used in
<code>kmeans</code>.  Random initialization is useful when no initial parameters can be
given to distinguish between the states.  It is also useful for repeated
estimation from different starting values.
</p>
<p>Argument <code>classification</code> is used to choose either soft (default) or
hard classification of observations to states. When using soft classification, observations
are assigned to states with a weight equal to the posterior probability of
the state. When using hard classification, observations are assigned to states
according to the maximum a posteriori (MAP) states (i.e., each observation
is assigned to one state, which is determined by the Viterbi algorithm in the
case of <code>depmix</code> models). As a result, the EM algorithm will find a local
maximum of the classification likelihood (Celeux &amp; Govaert, 1992). 
Warning: hard classification is an experimental feature, 
especially for hidden Markov models, and its use is currently not advised.
</p>


<h3>Value</h3>

<p><code>em.control</code> returns a list of the control parameters. 
</p>


<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>


<h3>References</h3>

<p>Lawrence R. Rabiner (1989).  A tutorial on hidden Markov models and
selected applications in speech recognition.  <em>Proceedings of
IEEE</em>, 77-2, p.  267-295.
</p>
<p>Gilles Celeux and Gerard Govaert (1992). A classification EM algorithm 
for clustering and two stochastic versions. <em>Computational
Statistics and Data Analysis, 14</em>, p. 315-332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using "hard" assignment of observations to the states, we can maximise the
# classification likelihood instead of the usual marginal likelihood
data(speed)  
mod &lt;- depmix(list(rt~1,corr~1),data=speed,nstates=2,
    family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
set.seed(1)
# fit the model by calling fit
fmod &lt;- fit(mod,emcontrol=em.control(classification="hard"))
# can get rather different solutions with different starting values...
set.seed(3)
fmod2 &lt;- fit(mod,emcontrol=em.control(classification="hard"))
</code></pre>

<hr>
<h2 id='fit'>Fit 'depmix' or 'mix' models</h2><span id='topic+fit'></span><span id='topic+depmix.fit'></span><span id='topic+fit+2Cdepmix-method'></span><span id='topic+show+2Cdepmix.fitted-method'></span><span id='topic+summary+2Cdepmix.fitted-method'></span><span id='topic+mix.fit'></span><span id='topic+fit+2Cmix-method'></span><span id='topic+show+2Cmix.fitted-method'></span><span id='topic+summary+2Cmix.fitted-method'></span>

<h3>Description</h3>

<p><code>fit</code> optimizes parameters of <code><a href="#topic+depmix">depmix</a></code> or
<code><a href="#topic+mix">mix</a></code> models, optionally subject to general linear
(in)equality constraints. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	## S4 method for signature 'mix'
fit(object, fixed=NULL, equal=NULL, 
		conrows=NULL, conrows.upper=NULL, conrows.lower=NULL, 
		method=NULL, verbose=FALSE,
		emcontrol=em.control(),
		solnpcntrl=list(rho = 1, outer.iter = 400, inner.iter = 800, 
		delta = 1e-7, tol = 1e-8),
		donlpcntrl=donlp2Control(),
		...)
	
	## S4 method for signature 'mix.fitted'
summary(object,which="all")
	
	## S4 method for signature 'depmix.fitted'
summary(object,which="all")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>(dep-)mix</code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_fixed">fixed</code></td>
<td>
<p>Vector of mode logical indicating which parameters should 
be fixed.</p>
</td></tr>
<tr><td><code id="fit_+3A_equal">equal</code></td>
<td>
<p>Vector indicating equality constraints; see Details.</p>
</td></tr>
<tr><td><code id="fit_+3A_conrows">conrows</code></td>
<td>
<p>Rows of a general linear constraint matrix; see Details.</p>
</td></tr>
<tr><td><code id="fit_+3A_conrows.upper">conrows.upper</code>, <code id="fit_+3A_conrows.lower">conrows.lower</code></td>
<td>
<p>Upper and lower bounds for the
linear constraints; see Details.</p>
</td></tr>
<tr><td><code id="fit_+3A_method">method</code></td>
<td>
<p>The optimization method; mostly determined by
constraints.</p>
</td></tr>
<tr><td><code id="fit_+3A_verbose">verbose</code></td>
<td>
<p>Should optimization information be displayed on screen?</p>
</td></tr>
<tr><td><code id="fit_+3A_emcontrol">emcontrol</code></td>
<td>
<p>Named list with control parameters for the EM
algorithm (see <code><a href="#topic+em.control">em.control</a></code>).</p>
</td></tr>
<tr><td><code id="fit_+3A_solnpcntrl">solnpcntrl</code></td>
<td>
<p>Control parameters passed to the 'rsolnp' optimizer;
see <code><a href="Rsolnp.html#topic+solnp">solnp</a></code> for explanation and defaults used there.</p>
</td></tr>
<tr><td><code id="fit_+3A_donlpcntrl">donlpcntrl</code></td>
<td>
<p>Control parameters passed to 'donlp' optimizer; see
<code>?donlp2Control</code> for explanation and defaults used there; this can 
be used to tweak optimization but note that extra output is not 
returned.</p>
</td></tr>
<tr><td><code id="fit_+3A_which">which</code></td>
<td>
<p>Should summaries be provided for &quot;all&quot; submodels? Options 
are &quot;prior&quot;, &quot;response&quot;, and for fitted depmix models also &quot;transition&quot;.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the optimization methods.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Models are fitted by the EM algorithm if there are no constraints on the
parameters.  Aspects of the EM algorithm can be controlled through the
<code>emcontrol</code> argument; see details in <code><a href="#topic+em.control">em.control</a></code>.
Otherwise the general optimizers <code>solnp</code>, the default (from package
<code>Rsolnp</code>) or <code>donlp2</code> (from package <code>Rdonlp2</code>) are used
which handle general linear (in-)equality constraints.  These optimizers
are selected by setting method='rsolnp' or method='donlp' respectively.
</p>
<p>Three types of constraints can be specified on the parameters: fixed,
equality, and general linear (in-)equality constraints.  Constraint
vectors should be of length <code>npar(object)</code>; note that this hence
includes redundant parameters such as the base category parameter in
multinomial logistic models which is always fixed at zero.  See help on
<code><a href="#topic+getpars">getpars</a></code> and <code><a href="#topic+setpars">setpars</a></code> about the ordering of
parameters.
</p>
<p>The <code>equal</code> argument is used to specify equality constraints:
parameters that get the same integer number in this vector are
estimated to be equal. Any integers can be used in this way except 0
and 1, which indicate fixed and free parameters, respectively. 
</p>
<p>Using <code>solnp</code> (or <code>donlp2</code>), a Newton-Raphson scheme is employed
to estimate parameters subject to linear constraints by imposing:
</p>
<p>bl &lt;= A*x &lt;= bu,
</p>
<p>where x is the parameter vector, bl is a vector of lower bounds, bu is
a vector of upper bounds, and A is the constraint matrix.
</p>
<p>The <code>conrows</code> argument is used to specify rows of A directly, and
the conrows.lower and conrows.upper arguments to specify the bounds on
the constraints.  <code>conrows</code> must be a matrix of npar(object) columns
and one row for each constraint (a vector in the case of a single
constraint).  Examples of these three ways of constraining parameters
are provided below.
</p>
<p>Note that when specifying constraints that these should respect the
fixed constraints inherent in e.g. the multinomial logit models for the
initial and transition probabilities.  For example, the baseline
category coefficient in a multinomial logit model is fixed on zero.
</p>
<p><code><a href="#topic+llratio">llratio</a></code> performs a log-likelihood ratio test on two
<code>fit</code>'ted models; the first object should have the largest degrees
of freedom (find out by using <code><a href="#topic+freepars">freepars</a></code>).
</p>


<h3>Value</h3>

<p><code>fit</code> returns an object of class
<code><a href="#topic+depmix.fitted">depmix.fitted</a></code> which contains the
original <code>depmix</code> object, and further has slots:
</p>

<dl>
<dt><code>message</code>:</dt><dd><p>Convergence information.</p>
</dd>
<dt><code>conMat</code>:</dt><dd><p>The constraint matrix A, see Details.</p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>The posterior state sequence (computed
with the viterbi algorithm), and the posterior probabilities (delta
probabilities in Rabiner, 1989, notation).</p>
</dd>
</dl>

<p>The print method shows the <code>message</code> along with the likelihood and
AIC and BIC; the summary method prints the parameter estimates.
</p>
<p>Posterior densities and the viterbi state sequence can be accessed
through <code><a href="#topic+posterior">posterior</a></code>.
</p>
<p>As fitted models are depmixS4 models, they can be used as starting
values for new fits, for example with constraints added. Note that 
when refitting already fitted models, the constraints, if any, are not
added automatically, they have to be added again. 
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>References</h3>

<p>Some of the below models for the <code>speed</code> data are reported in:
</p>
<p>Ingmar Visser, Maartje E. J. Raijmakers and Han L. J. van der Maas
(2009).  Hidden Markov Models for Invdividual Time Series.  In: Jaan
Valsiner, Peter C. M. Molenaar, M. C. D. P. Lyra, and N. Chaudhary
(editors).  <em>Dynamic Process Methodology in the Social and
Developmental Sciences</em>, chapter 13, pages 269&ndash;289.  New York:
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed)

# 2-state model on rt and corr from speed data set 
# with Pacc as covariate on the transition matrix
# ntimes is used to specify the lengths of 3 separate time-series
mod1 &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
# fit the model
set.seed(3)
fmod1 &lt;- fit(mod1)
fmod1 # to see the logLik and optimization information
# to see the parameters
summary(fmod1)

# to obtain the posterior most likely state sequence, as computed by the 
# Viterbi algorithm
pst_global &lt;- posterior(fmod1, type = "global")
# local decoding provides a different method for state classification:
pst_local &lt;- posterior(fmod1,type="local")
identical(pst_global, pst_local)
# smoothing probabilities are used for local decoding, and may be used as 
# easily interpretable posterior state probabilities
pst_prob &lt;- posterior(fmod1, type = "smoothing")

# testing viterbi states for new data
df &lt;- data.frame(corr=c(1,0,1),rt=c(6.4,5.5,5.3),Pacc=c(0.6,0.1,0.1))
# define model with new data like above
modNew &lt;- depmix(list(rt~1,corr~1),data=df,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")))
# get parameters from estimated model
modNew &lt;- setpars(modNew,getpars(fmod1))
# check the state sequence and probabilities
pst_new &lt;- posterior(modNew, type="global")

# same model, now with missing data
## Not run: 
speed[2,1] &lt;- NA
speed[3,2] &lt;- NA

# 2-state model on rt and corr from speed data set 
# with Pacc as covariate on the transition matrix
# ntimes is used to specify the lengths of 3 separate series
mod1ms &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
# fit the model
set.seed(3)
fmod1ms &lt;- fit(mod1ms)

## End(Not run)

# instead of the normal likelihood, we can also maximise the "classification" likelihood
# this uses the maximum a posteriori state sequence to assign observations to states
# and to compute initial and transition probabilities. 

fmod1b &lt;- fit(mod1,emcontrol=em.control(classification="hard"))
fmod1b # to see the logLik and optimization information

# FIX SOME PARAMETERS

# get the starting values of this model to the optimized 
# values of the previously fitted model to speed optimization

pars &lt;- c(unlist(getpars(fmod1)))

# constrain the initial state probs to be 0 and 1 
# also constrain the guessing probs to be 0.5 and 0.5 
# (ie the probabilities of corr in state 1)
# change the ones that we want to constrain
pars[1]=0
pars[2]=1 # this means the process will always start in state 2
pars[13]=0.5
pars[14]=0.5 # the corr parameters are now both 0.5
mod2 &lt;- setpars(mod1,pars)

# fix the parameters by setting: 
free &lt;- c(0,0,rep(c(0,1),4),1,1,0,0,1,1,1,1)
# fit the model
fmod2 &lt;- fit(mod2,fixed=!free)

# likelihood ratio insignificant, hence fmod2 better than fmod1
llratio(fmod1,fmod2)


# ADDING SOME GENERAL LINEAR CONSTRAINTS

# set the starting values of this model to the optimized 
# values of the previously fitted model to speed optimization

## Not run: 

pars &lt;- c(unlist(getpars(fmod2)))
pars[4] &lt;- pars[8] &lt;- -4
pars[6] &lt;- pars[10] &lt;- 10
mod3 &lt;- setpars(mod2,pars)

# start with fixed and free parameters
conpat &lt;- c(0,0,rep(c(0,1),4),1,1,0,0,1,1,1,1)
# constrain the beta's on the transition parameters to be equal
conpat[4] &lt;- conpat[8] &lt;- 2
conpat[6] &lt;- conpat[10] &lt;- 3

fmod3 &lt;- fit(mod3,equal=conpat)

llratio(fmod2,fmod3)

# above constraints can also be specified using the conrows argument as follows
conr &lt;- matrix(0,2,18)
# parameters 4 and 8 have to be equal, otherwise stated, their diffence should be zero,
# and similarly for parameters 6 &amp; 10
conr[1,4] &lt;- 1
conr[1,8] &lt;- -1
conr[2,6] &lt;- 1
conr[2,10] &lt;- -1

# note here that we use the fitted model fmod2 as that has appropriate 
# starting values
fmod3b &lt;- fit(mod3,conrows=conr,fixed=!free) # using free defined above


## End(Not run)

data(balance)
# four binary items on the balance scale task
mod4 &lt;- mix(list(d1~1,d2~1,d3~1,d4~1), data=balance, nstates=2,
	family=list(multinomial("identity"),multinomial("identity"),
	multinomial("identity"),multinomial("identity")))

set.seed(1)
fmod4 &lt;- fit(mod4)

## Not run: 

# add age as covariate on class membership by using the prior argument
mod5 &lt;- mix(list(d1~1,d2~1,d3~1,d4~1), data=balance, nstates=2,
	family=list(multinomial("identity"),multinomial("identity"),
	multinomial("identity"),multinomial("identity")),
	prior=~age, initdata=balance)

set.seed(1)
fmod5 &lt;- fit(mod5)

# check the likelihood ratio; adding age significantly improves the goodness-of-fit
llratio(fmod5,fmod4)


## End(Not run)

</code></pre>

<hr>
<h2 id='formatperc'>Format percentage for level in printing confidence interval</h2><span id='topic+formatperc'></span>

<h3>Description</h3>

<p>See title.</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatperc(x,digits)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatperc_+3A_x">x</code></td>
<td>
<p>a vector of probabilities to be formatted as percentages.</p>
</td></tr>
<tr><td><code id="formatperc_+3A_digits">digits</code></td>
<td>
<p>the number of required digits in the percentages.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ingmar Visser</p>

<hr>
<h2 id='forwardbackward'> Forward and backward variables </h2><span id='topic+forwardbackward'></span><span id='topic+forwardbackward+2Cmix-method'></span><span id='topic+forwardbackward+2Cdepmix-method'></span>

<h3>Description</h3>

<p>Compute the forward and backward variables of a <code>depmix</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	## S4 method for signature 'mix'
forwardbackward(object, return.all=TRUE, useC=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forwardbackward_+3A_object">object</code></td>
<td>
<p>A depmix object.</p>
</td></tr>
<tr><td><code id="forwardbackward_+3A_return.all">return.all</code></td>
<td>
<p>If FALSE, only gamma and xi and the log likelihood
are returned (which are the only variables needed in using EM).</p>
</td></tr>
<tr><td><code id="forwardbackward_+3A_usec">useC</code></td>
<td>
<p>Flag used to set whether the C-code is used to compute the
forward, backward, gamma and xi variables or not; the R-code is basically
obsolete (but retained for now for debugging purposes).</p>
</td></tr>
<tr><td><code id="forwardbackward_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>forwardbackward</code> returns a list of the following (the variables 
are named after the notation from Rabiner, 1989):
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>The forward variables.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The backward variables.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The smoothed state probabilities.</p>
</td></tr>
<tr><td><code>xi</code></td>
<td>
<p>The smoothed transition probabilities.</p>
</td></tr>
<tr><td><code>sca</code></td>
<td>
<p>The scale factors (called lambda in Rabiner, 1989).</p>
</td></tr>
<tr><td><code>logLike</code></td>
<td>
<p>The log likelihood (computed as <code>-sum(log(sca))</code>.</p>
</td></tr>
</table>
<p>If return.all=FALSE, only gamma, xi and the log likelihood are returned.
</p>


<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>


<h3>References</h3>

 	
<p>Lawrence R. Rabiner (1989).  A tutorial on hidden Markov models and
selected applications in speech recognition.  <em>Proceedings of
IEEE</em>, 77-2, p.  267-295. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed)

# 2-state model on rt and corr from speed data set 
# with Pacc as covariate on the transition matrix
# ntimes is used to specify the lengths of 3 separate series
mod1 &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))

fb &lt;- forwardbackward(mod1)
all.equal(-sum(log(fb$sca)),fb$logLike)

</code></pre>

<hr>
<h2 id='GLMresponse'>Methods for creating depmix response models</h2><span id='topic+GLMresponse'></span><span id='topic+GLMresponse+2Cformula-method'></span><span id='topic+getdf'></span><span id='topic+getdf+2Cresponse-method'></span><span id='topic+getdf+2CMULTINOMresponse-method'></span><span id='topic+show+2CGLMresponse-method'></span>

<h3>Description</h3>

<p>Create <code>GLMresponse</code> objects for <code><a href="#topic+depmix">depmix</a></code> models using
formulae and family objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	GLMresponse(formula, data=NULL, family=gaussian(), pstart=NULL, 
		fixed=NULL, prob=TRUE, ...)
	
		## S4 method for signature 'response'
getdf(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMresponse_+3A_formula">formula</code></td>
<td>
<p>A model <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_data">data</code></td>
<td>
<p>An optional data.frame to interpret the variables from the 
formula argument in.</p>
</td></tr>	
<tr><td><code id="GLMresponse_+3A_family">family</code></td>
<td>
<p>A family object; </p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_pstart">pstart</code></td>
<td>
<p>Starting values for the coefficients and other
parameters, e.g. the standard deviation for the gaussian() family.</p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_fixed">fixed</code></td>
<td>
<p>Logical vector indicating which paramters are to be fixed.</p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_prob">prob</code></td>
<td>
<p>Logical indicating whether the starting values for
multinomial() family models are probabilities or logistic
parameters (see details).</p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_object">object</code></td>
<td>
<p>Object of class response.</p>
</td></tr>
<tr><td><code id="GLMresponse_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GLMresponse</code> is the default driver for specifying response
distributions of <code>depmix</code> models.  It uses the familiar formula
interface from <code><a href="stats.html#topic+glm">glm</a></code> to specify how responses depend on
covariates/predictors.
</p>
<p>Currently available options for the family argument are
<code>binomial</code>, <code>gaussian</code>, <code>poisson</code>, <code>Gamma</code>, and
<code>multinomial</code>.  Except for the latter option, the
<code>GLMresponse</code> model is an interface to the <code>glm</code> functions of
which the functionality is used: predict, fit and density functions.
</p>
<p>The <code>multinomial</code> model takes as link functions <code>mlogit</code>, the
default, and then uses functionality from the <code>nnet</code> package to
fit multinomial logistic models; using <code>mlogit</code> as link allows
only n=1 models to be specified, i.e. a single observation for each
occasion; it also takes <code>identity</code> as a link function.  The latter
is typically faster and is hence preferred when no covariates are
present.
</p>
<p>See the <code><a href="#topic+responses">responses</a></code> help page for examples. 
</p>


<h3>Value</h3>

<p><code>GLMresponse</code> returns an object of class <code>GLMresponse</code> which
extends the <code><a href="#topic+response-class">response-class</a></code>.
</p>
<p><code>getdf</code> returns the number of free parameters of a
<code>response</code> model.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeDepmix">makeDepmix</a></code> has an example of specifying a model with a 
multivariate normal response and an example of how to add a user-defined
response model, in particular an ex-gauss distribution used for the
<code>speed</code> data. 
</p>

<hr>
<h2 id='llratio'>Log likelihood ratio test on two fitted models</h2><span id='topic+llratio'></span><span id='topic+loglikelihoodratio'></span><span id='topic+show+2Cllratio-method'></span>

<h3>Description</h3>

<p>Performs a log likelihood ratio test on two fitted
<code>depmix</code> models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	llratio(basemodel, constrainedmodel, ...)
	
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="llratio_+3A_basemodel">basemodel</code></td>
<td>
<p>Fitted model with a <code>logLik</code> method.</p>
</td></tr>
<tr><td><code id="llratio_+3A_constrainedmodel">constrainedmodel</code></td>
<td>
<p>Fitted model with a <code>logLik</code> method.</p>
</td></tr>
<tr><td><code id="llratio_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+fit">fit</a></code> help page for an example. 
</p>


<h3>Value</h3>

<p><code>llratio</code> returns an object of class <code>llratio</code> which has slots: 
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>: Minus twice the loglikelihood difference.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>: The degrees of freedom, ie the difference in number of freely
estimated paraemters between the models.</p>
</td></tr>
</table>
<p>The print method shows the value, the degrees of freedom and the
corresponding p-value under the chisquared distribution. 
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser</p>

<hr>
<h2 id='makeDepmix'>Dependent Mixture Model Specifiction: full control and adding response models</h2><span id='topic+makeDepmix'></span><span id='topic+makeMix'></span>

<h3>Description</h3>

<p><code>makeDepmix</code> creates an object of class <code>depmix</code>.  This
function is meant for full control, e.g. specifying each response model
and the transition and prior models 'by hand'.  For the default easier
specification of models, please see <code><a href="#topic+depmix">depmix</a></code>.  This
function is meant for specifying one's own response models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	makeDepmix(response, transition, prior, ntimes = NULL, homogeneous = TRUE, 
		stationary = NULL, ...) 	
	
	makeMix(response, prior, ...) 	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDepmix_+3A_response">response</code></td>
<td>
<p>A two-dimensional list of response models.  See
'Details'.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_transition">transition</code></td>
<td>
<p>A list of transition models, each created by a
call to <code><a href="#topic+transInit">transInit</a></code>.  The lenght of this list should be
the number of states of the model.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_prior">prior</code></td>
<td>
<p>The initial state probabilities model; created through a
call to <code><a href="#topic+transInit">transInit</a></code>.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_ntimes">ntimes</code></td>
<td>
<p>A vector specifying the lengths of individual, ie
independent, time series. If not specified, the responses are
assumed to form a single time series.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Logical indicating whether the transition models
include time-varying covariates; used internally to determine the
dimensions of certain arrays, notably <code>trDens</code>.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_stationary">stationary</code></td>
<td>
<p>This argument should no longer be used; if not NULL,
the value of stationary is copied to the homogeneous argument, with a
warning.  In future versions this argument may be dropped or used for
different purposes, i.e., for specifying models in which the initial state
probabilities are constrained to be the stationary distribution of the
transition matrix.</p>
</td></tr>
<tr><td><code id="makeDepmix_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The function <code>makeDepmix</code> creates an S4 object of class
<code>depmix</code>, which needs to be fitted using <code><a href="#topic+fit">fit</a></code> to
optimize the parameters.  This function is provided to have full
control, eg by specifying one's own response models with distributions
that are not provided.
</p>
<p>The response model(s) should be created by call(s) to
<code><a href="#topic+GLMresponse">GLMresponse</a></code>, <code>MVNresponse</code> (see example below) or
user-defined response models (see example below) that should extend the
<code><a href="#topic+response-class">response-class</a></code> and have the following methods: dens,
predict and optionally fit.  The fit function should have an argument
w, providing the weights.  If the fit function is not provided,
optimization should be done by using Rdonlp (use method=&quot;donlp&quot; in
calling fit on the depmix model, note that this is <em>not</em> the default).
The first index of response models runs over the states of the model,
and the second index over the responses to be modeled.
</p>


<h3>Value</h3>

<p>See the <code><a href="#topic+depmix">depmix</a></code> help page for the return value, a
<code>depmix</code> object.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code>, <code><a href="#topic+transInit">transInit</a></code>, <code><a href="#topic+GLMresponse">GLMresponse</a></code>,
<code><a href="#topic+depmix-methods">depmix-methods</a></code> for accessor functions to <code>depmix</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# below example recreates the same model as on the fit help page in a roundabout way
# there we had:
# mod1 &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
#	 family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))

data(speed)   

rModels &lt;- list(
	list(
		GLMresponse(formula=rt~1,data=speed,family=gaussian()),
		GLMresponse(formula=corr~1,data=speed,family=multinomial("identity"))
	),
	list(
		GLMresponse(formula=rt~1,data=speed,family=gaussian()),
		GLMresponse(formula=corr~1,data=speed,family=multinomial("identity"))
	)
)

transition &lt;- list()
transition[[1]] &lt;- transInit(~Pacc,nstates=2,data=speed)
transition[[2]] &lt;- transInit(~Pacc,nstates=2,data=speed)

inMod &lt;- transInit(~1,ns=2,data=data.frame(rep(1,3)),family=multinomial("identity"))
mod &lt;- makeDepmix(response=rModels,transition=transition,prior=inMod,
ntimes=c(168,134,137),homogeneous=FALSE)

set.seed(3)
fm1 &lt;- fit(mod)
fm1
summary(fm1)


# generate data from two different multivariate normal distributions
m1 &lt;- c(0,1)
sd1 &lt;- matrix(c(1,0.7,.7,1),2,2)
m2 &lt;- c(1,0)
sd2 &lt;- matrix(c(2,.1,.1,1),2,2)
set.seed(2)
y1 &lt;- mvrnorm(50,m1,sd1)
y2 &lt;- mvrnorm(50,m2,sd2)
# this creates data with a single change point
y &lt;- rbind(y1,y2)

# now use makeDepmix to create a depmix model for this bivariate normal timeseries
rModels &lt;-  list()
rModels[[1]] &lt;- list(MVNresponse(y~1))
rModels[[2]] &lt;- list(MVNresponse(y~1))

trstart=c(0.9,0.1,0.1,0.9)

transition &lt;- list()
transition[[1]] &lt;- transInit(~1,nstates=2,data=data.frame(1),pstart=c(trstart[1:2]))
transition[[2]] &lt;- transInit(~1,nstates=2,data=data.frame(1),pstart=c(trstart[3:4]))

instart=runif(2)
inMod &lt;- transInit(~1,ns=2,ps=instart,data=data.frame(1))

mod &lt;- makeDepmix(response=rModels,transition=transition,prior=inMod)

fm2 &lt;- fit(mod,emc=em.control(random=FALSE))

# where is the switch point?
plot(as.ts(posterior(fm2, type="smoothing")[,1]))


# in below example we add the exgaus distribution as a response model and fit
# this instead of the gaussian distribution to the rt slot of the speed data
# most of the actual computations for the exgaus distribution is done by calling
# functions from the gamlss family of packages; see their help pages for 
# interpretation of the mu, nu and sigma parameters that are fitted below

## Not run: 
require(gamlss)
require(gamlss.dist)

data(speed)
rt &lt;- speed$rt

# define a response class which only contains the standard slots, no additional slots
setClass("exgaus", contains="response")

# define a generic for the method defining the response class

setGeneric("exgaus", function(y, pstart = NULL, fixed = NULL, ...) standardGeneric("exgaus"))

# define the method that creates the response class

setMethod("exgaus", 
    signature(y="ANY"), 
    function(y,pstart=NULL,fixed=NULL, ...) {
        y &lt;- matrix(y,length(y))
		x &lt;- matrix(1)
		parameters &lt;- list()
		npar &lt;- 3
		if(is.null(fixed)) fixed &lt;- as.logical(rep(0,npar))
		if(!is.null(pstart)) {
		if(length(pstart)!=npar) stop("length of 'pstart' must be ",npar)
		  parameters$mu &lt;- pstart[1]
		  parameters$sigma &lt;- log(pstart[2])
		  parameters$nu &lt;- log(pstart[3])
        }
        mod &lt;- new("exgaus",parameters=parameters,fixed=fixed,x=x,y=y,npar=npar)
        mod
	}
)

setMethod("show","exgaus",
    function(object) {
        cat("Model of type exgaus (see ?gamlss for details) \n")
        cat("Parameters: \n")
        cat("mu: ", object@parameters$mu, "\n")
        cat("sigma: ", object@parameters$sigma, "\n")
        cat("nu: ", object@parameters$nu, "\n")
    }
)

setMethod("dens","exgaus",
 function(object,log=FALSE) {
   dexGAUS(object@y, mu = predict(object), 
		sigma = exp(object@parameters$sigma), nu = exp(object@parameters$nu), log = log)
  }
)

setMethod("getpars","response",
    function(object,which="pars",...) {
        switch(which,
            "pars" = {
                parameters &lt;- numeric()
                parameters &lt;- unlist(object@parameters)
                pars &lt;- parameters
            },
            "fixed" = {
                pars &lt;- object@fixed
            }
        )
        return(pars)
    }
)

setMethod("setpars","exgaus",
    function(object, values, which="pars", ...) {
        npar &lt;- npar(object)
        if(length(values)!=npar) stop("length of 'values' must be",npar)
        # determine whether parameters or fixed constraints are being set
		nms &lt;- names(object@parameters)
		switch(which,
		  "pars"= {
		      object@parameters$mu &lt;- values[1]
		      object@parameters$sigma &lt;- values[2]
		      object@parameters$nu &lt;- values[3]
		      },
		  "fixed" = {
		      object@fixed &lt;- as.logical(values)
		  }
		  )
        names(object@parameters) &lt;- nms
        return(object)
    }
)

setMethod("fit","exgaus",
    function(object,w) {
        if(missing(w)) w &lt;- NULL
        y &lt;- object@y
        fit &lt;- gamlss(y~1,weights=w,family=exGAUS(),
			control=gamlss.control(n.cyc=100,trace=FALSE),
			mu.start=object@parameters$mu,
			sigma.start=exp(object@parameters$sigma),
			nu.start=exp(object@parameters$nu))
		pars &lt;- c(fit$mu.coefficients,fit$sigma.coefficients,fit$nu.coefficients)
		object &lt;- setpars(object,pars)
		object
	}
)

setMethod("predict","exgaus", 
    function(object) {
        ret &lt;- object@parameters$mu
        return(ret)
    }
)

rModels &lt;- list(
  list(
	  exgaus(rt,pstart=c(5,.1,.1)),
		GLMresponse(formula=corr~1, data=speed, 
		family=multinomial("identity"), pstart=c(0.5,0.5))
	),
	list(
		exgaus(rt,pstart=c(6,.1,.1)),
		GLMresponse(formula=corr~1, data=speed, 
		family=multinomial("identity"), pstart=c(.1,.9))
	)
)

trstart=c(0.9,0.1,0.1,0.9)
transition &lt;- list()
transition[[1]] &lt;- transInit(~Pacc,nstates=2,data=speed,pstart=c(trstart[1:2],0,0))
transition[[2]] &lt;- transInit(~Pacc,nstates=2,data=speed,pstart=c(trstart[3:4],0,0))

instart=c(0.5,0.5)
inMod &lt;- transInit(~1,ns=2,ps=instart,family=multinomial("identity"), data=data.frame(rep(1,3)))

mod &lt;- makeDepmix(response=rModels,transition=transition,prior=inMod,ntimes=c(168,134,137), 
homogeneous=FALSE)

fm3 &lt;- fit(mod,emc=em.control(rand=FALSE))
summary(fm3)

## End(Not run)

</code></pre>

<hr>
<h2 id='mix'> Mixture Model Specifiction </h2><span id='topic+mix'></span><span id='topic+mix+2CANY-method'></span><span id='topic+show+2Cmix-method'></span><span id='topic+summary+2Cmix-method'></span>

<h3>Description</h3>

<p><code>mix</code> creates an object of class <code>mix</code>, an (independent)
mixture model (as a limit case of dependent mixture models in which all
observed time series are of length 1), otherwise known latent class or
mixture model.  For a short description of the package see
<code><a href="#topic+depmixS4">depmixS4</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	mix(response, data=NULL, nstates, family=gaussian(), 
		prior=~1, initdata=NULL, respstart=NULL, instart=NULL,...)	
	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_+3A_response">response</code></td>
<td>
<p>The response to be modeled; either a formula or a list 
of formulae in the multivariate case; this interfaces to the glm
distributions. See 'Details'.</p>
</td></tr>
<tr><td><code id="mix_+3A_data">data</code></td>
<td>
<p>An optional data.frame to interpret the variables in
the response and transition arguments.</p>
</td></tr>
<tr><td><code id="mix_+3A_nstates">nstates</code></td>
<td>
<p>The number of states of the model.</p>
</td></tr>
<tr><td><code id="mix_+3A_family">family</code></td>
<td>
<p>A family argument for the response. This must be a list
of family's if the response is multivariate.</p>
</td></tr>
<tr><td><code id="mix_+3A_prior">prior</code></td>
<td>
<p>A one-sided formula specifying the density for the prior
or initial state probabilities.</p>
</td></tr>
<tr><td><code id="mix_+3A_initdata">initdata</code></td>
<td>
<p>An optional data.frame to interpret the variables
occuring in prior. The number of rows of this data.frame must be
equal to the number of cases being modeled. See 'Details'.</p>
</td></tr>
<tr><td><code id="mix_+3A_respstart">respstart</code></td>
<td>
<p>Starting values for the parameters of the response
models.</p>
</td></tr>
<tr><td><code id="mix_+3A_instart">instart</code></td>
<td>
<p>Starting values for the parameters of the prior or
initial state probability model.</p>
</td></tr>
<tr><td><code id="mix_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The function <code>mix</code> creates an S4 object of class <code>mix</code>,
which needs to be fitted using <code><a href="#topic+fit">fit</a></code> to optimize the
parameters.
</p>
<p>The response model(s) are by default created by call(s) to
<code>GLMresponse</code> using the <code>formula</code> and the <code>family</code>
arguments, the latter specifying the error distribution.  See
<code><a href="#topic+GLMresponse">GLMresponse</a></code> for possible values of the <code>family</code>
argument for <code>glm</code>-type responses (ie a subset of the <code>glm</code>
family options, and the multinomial).  Alternative response
distributions are specified by using the <code><a href="#topic+makeDepmix">makeDepmix</a></code>
function.  Its help page has examples of specifying a model with a
multivariate normal response, as well as an example of adding a
user-defined response model, in this case for the ex-gauss
distribution.
</p>
<p>If <code>response</code> is a list of formulae, the <code>response</code>'s are
assumed to be independent conditional on the latent state.
</p>
<p>The prior density is modeled as a multinomial logistic.  This model is
created by a call to <code><a href="#topic+transInit">transInit</a></code>.
</p>
<p>Starting values may be provided by the respective arguments.  The order
in which parameters must be provided can be easily studied by using the
<code><a href="#topic+setpars">setpars</a></code> and <code><a href="#topic+getpars">getpars</a></code> functions.
</p>
<p>Linear constraints on parameters can be provided as argument to the
<code><a href="#topic+fit">fit</a></code> function.
</p>
<p>The print function prints the formulae for the response and prior
models along with their parameter values.
</p>


<h3>Value</h3>

<p><code>mix</code> returns an object of class <code>mix</code> which has the
following slots:
</p>
<table>
<tr><td><code>response</code></td>
<td>
<p>A list of a list of response models; the first
index runs over states; the second index runs over the independent 
responses in case a multivariate response is provided.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A multinomial logistic model for the initial state
probabilities.</p>
</td></tr>
<tr><td><code>dens</code>, <code>init</code></td>
<td>
<p>See <code><a href="#topic+mix-class">mix-class</a></code> help for details.  For
internal use.</p>
</td></tr>
<tr><td><code>ntimes</code></td>
<td>
<p>A vector made by <code>rep(1,nrow(data))</code>; for internal
use only.</p>
</td></tr>
<tr><td><code>nstates</code></td>
<td>
<p>The number of states of the model.</p>
</td></tr>
<tr><td><code>nresp</code></td>
<td>
<p>The number of independent responses.</p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>The total number of parameters of the model.  Note: this
is <em>not</em> the degrees of freedom because there are redundancies in the
parameters, in particular in the multinomial models for the transitions
and prior probabilities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>References</h3>

<p>A. L. McCutcheon (1987).  <em>Latent class analysis</em>.  Sage
Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code>, <code><a href="#topic+transInit">transInit</a></code>, <code><a href="#topic+GLMresponse">GLMresponse</a></code>,
<code><a href="#topic+depmix-methods">depmix-methods</a></code> for accessor functions to <code>depmix</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# four binary items on the balance scale task
data(balance)

# define a latent class model
instart=c(0.5,0.5)
set.seed(1)
respstart=runif(16)
# note that ntimes argument is used to make this a mixture model
mod &lt;- mix(list(d1~1,d2~1,d3~1,d4~1), data=balance, nstates=2,
	family=list(multinomial(),multinomial(),multinomial(),multinomial()),
	respstart=respstart,instart=instart)
# to see the model
mod

</code></pre>

<hr>
<h2 id='mix-class'>Class &quot;mix&quot;</h2><span id='topic+mix-class'></span><span id='topic+nresp+2Cmix-method'></span><span id='topic+nstates+2Cmix-method'></span><span id='topic+ntimes+2Cmix-method'></span>

<h3>Description</h3>

<p> A <code><a href="#topic+mix">mix</a></code> model. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code><a href="#topic+mix">mix</a></code>.
</p>


<h3>Slots</h3>

 
<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code><a href="#topic+transInit">transInit</a></code> object; model for the
prior probabilities, also unconditional probabilities</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension
<code>length(ntimes)</code>*nstates with the current predictions for the
initial state probabilities.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states (classes) of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector of 1's for each case; for internal
use.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model.
This is not the degrees of freedom, ie there are redundancies in
the parameters, in particular in the multinomial models for the
transitions and prior.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of responses.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>The vector of independent time series lengths.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>Examples</h3>

<pre><code class='language-R'>	showClass("mix")
</code></pre>

<hr>
<h2 id='mix.fitted-class'>Class &quot;mix.fitted&quot; (and &quot;mix.fitted.classLik&quot;)</h2><span id='topic+mix.fitted-class'></span><span id='topic+mix.fitted.classLik-class'></span>

<h3>Description</h3>

<p>A fitted <code><a href="#topic+mix">mix</a></code> model.</p>


<h3>Slots</h3>

<p>A <code>mix.fitted</code> object is a <code>mix</code> object with three 
additional slots, here is the complete list:
</p>

<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code>transInit</code> object.</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension <code>length(ntimes)</code>*nstates with 
the current predictions for the initial state probabilities.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector containing the lengths of independent time
series; if data is provided, sum(ntimes) must be equal to
nrow(data).</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model. This is not
the degrees of freedom, ie there are redundancies in the
parameters, in particular in the multinomial models for the
transitions and prior.</p>
</dd>
<dt><code>message</code>:</dt><dd><p>This provides some information on convergence,
either from the EM algorithm or from Rdonlp2.</p>
</dd>
<dt><code>conMat</code>:</dt><dd><p>The linear constraint matrix, which has zero rows
if there were no constraints.</p>
</dd>
<dt><code>lin.lower</code></dt><dd><p>The lower bounds on the linear constraints.</p>
</dd>
<dt><code>lin.upper</code></dt><dd><p>The upper bounds on the linear constraints.</p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>Posterior (Viterbi) state sequence.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The print function shows some convergence information, and the summary
method shows the parameter estimates.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mix-class">mix</a>"</code> directly. <code>mix.fitted.classLik</code> is
similar to <code>mix.fitted</code>, the only difference being that the model is fitted
by maximising the classification likelihood.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>Examples</h3>

<pre><code class='language-R'>	showClass("mix.fitted")
</code></pre>

<hr>
<h2 id='mix.sim-class'>Class &quot;mix.sim&quot;</h2><span id='topic+mix.sim'></span><span id='topic+mix.sim-class'></span><span id='topic+nresp+2Cmix.sim-method'></span><span id='topic+ntimes+2Cmix.sim-method'></span><span id='topic+nstates+2Cmix.sim-method'></span>

<h3>Description</h3>

<p>A <code>mix.sim</code> model. The <code>mix.sim</code> class directly
extends the <code><a href="#topic+mix">mix</a></code> class, and has an additional slot for the
true states. A <code>mix.sim</code> model can be generated by
<code>simulate(mod,...)</code>, where <code>mod</code> is a <code><a href="#topic+mix">mix</a></code> model.</p>


<h3>Slots</h3>


<dl>
<dt><code>response</code>:</dt><dd><p>List of list of <code>response</code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p><code><a href="#topic+transInit">transInit</a></code> object.</p>
</dd>
<dt><code>dens</code>:</dt><dd><p>Array of dimension sum(ntimes)*nresp*nstates
providing the densities of the observed responses for each state.</p>
</dd>
<dt><code>init</code>:</dt><dd><p>Array of dimension <code>length(ntimes)</code>*nstates with 
the current predictions for the initial state probabilities.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>A vector containing the lengths of independent time
series; not applicable for mix objects, i.e. this is a vector of 1's.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states/classes of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of independent responses.</p>
</dd>
<dt><code>npars</code>:</dt><dd><p>The total number of parameters of the model.  
This is not the degrees of freedom, ie there are redundancies in the
parameters, in particular in the multinomial models for the transitions
and prior.</p>
</dd>
<dt><code>states</code>:</dt><dd><p>A matrix with the true states/classes.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>nresp</code>:</dt><dd><p>The number of responses.</p>
</dd>
<dt><code>nstates</code>:</dt><dd><p>The number of states.</p>
</dd>
<dt><code>ntimes</code>:</dt><dd><p>The vector of independent time series lengths.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>

<hr>
<h2 id='multistart'>Methods to fit a (dep-)mix model using multiple sets of starting values</h2><span id='topic+multistart'></span><span id='topic+multistart+2Cmix-method'></span><span id='topic+multistart+2Cdepmix-method'></span>

<h3>Description</h3>

<p>Fit a model using multiple sets of starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'mix'
multistart(object, nstart=10, initIters=10, ...)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multistart_+3A_object">object</code></td>
<td>
<p>An object of class <code>mix</code> or <code>depmix</code>.</p>
</td></tr>
<tr><td><code id="multistart_+3A_nstart">nstart</code></td>
<td>
<p>The number of sets of starting values that are used.</p>
</td></tr>
<tr><td><code id="multistart_+3A_inititers">initIters</code></td>
<td>
<p>The number of EM iterations that each set of starting values is run.</p>
</td></tr>
<tr><td><code id="multistart_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting values in the EM algorithm are generated by randomly assigning posterior state
probabilities for each observation using a Dirichlet distribution. This is done <code>nstart</code>
times. The EM algorithm is run <code>initIters</code> times for each set of starting values. The then
best fitting model is then optimized until convergence. A warning is provided about the number
of sets of starting values that are infeasible, e.g. due to non-finite log likelihood, if that 
number is larger than zero. Note that the number of iterations reported in the final fitted 
model does not include the initial number of iterations that EM was run for. 
</p>


<h3>Value</h3>

<p>A fitted <code>(dep)mix</code> object. 
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed)

# this example is from ?fit with fit now replaced by multistart and the 
# set.seed statement is left out
mod1 &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
set.seed(3)
fmod1 &lt;- fit(mod1)
fmod2 &lt;- multistart(mod1)
fmod1
fmod2

</code></pre>

<hr>
<h2 id='posterior'>Posterior state/class probabilities and classification</h2><span id='topic+posterior'></span><span id='topic+posterior+2Cdepmix-method'></span><span id='topic+posterior+2Cmix-method'></span><span id='topic+posterior+2Cdepmix.fitted-method'></span><span id='topic+posterior+2Cmix.fitted-method'></span>

<h3>Description</h3>

<p>Return posterior state classifications and/or
probabilities for a fitted <code>(dep-)mix</code> object. In
the case of a latent class or mixture model, states refer to the 
classes/mixture components.
</p>
<p>There are different ways to define posterior state probabilities and the 
resulting classifications. The 'type' argument can be used to specify the
desired definition. The default is currently set to 'viterbi'.
Other options are 'global' and 'local' for state classification, and 
'filtering' and 'smoothing' for state probabilities. See Details for more 
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S4 method for signature 'depmix'
posterior(object, type = c("viterbi", "global", "local", "filtering", "smoothing"))
	## S4 method for signature 'depmix.fitted'
posterior(object, type = c("viterbi", "global", "local", "filtering", "smoothing"))
	## S4 method for signature 'mix'
posterior(object, type = c("viterbi", "global", "local", "filtering", "smoothing"))
	## S4 method for signature 'mix.fitted'
posterior(object, type = c("viterbi", "global", "local", "filtering", "smoothing"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_+3A_object">object</code></td>
<td>
<p>A (fitted)(dep-)mix object.</p>
</td></tr>
<tr><td><code id="posterior_+3A_type">type</code></td>
<td>
<p>character, partial matching allowed. The type of classification or posterior probability desired. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>After fitting a <code>mix</code> or <code>depmix</code> model, one is often interested 
in determining the most probable mixture components or hidden states at each 
time-point <var>t</var>. This is also called decoding the hidden states from the observed 
data. There are at least two general ways to consider state classification:
'global' decoding means determining the most likely state sequence, whilst 
'local' decoding means determining the most likely state at each time point 
whilst not explicitly considering the identity of the hidden states at other
time points. For mixture models, both forms of decoding are identical.
</p>
<p>Global decoding is based on the conditional probability
<code class="reqn">p(S_1, \ldots, S_T \mid Y_1, \ldots, Y_T)</code>, and consists of determining, 
at each time point <code class="reqn">t = 1, \ldots, T</code>:
</p>
<p style="text-align: center;"><code class="reqn">s*_t = \arg \max_{i=1}^N p(S_1 = s*_1, \ldots, S_{t-1} = s*_{t-1}, S_t = i, S_{t+1} = s*_{t+1}, \ldots, S_T = s*_{T} \mid Y_1, \ldots, Y_T)</code>
</p>

<p>where <var>N</var> is the total number of states. These probabilities and the 
resulting classifications, are computed through the <code><a href="#topic+viterbi">viterbi</a></code> algorithm.
Setting <code>type = 'viterbi'</code> returns a <code>data.frame</code> with the Viterbi-decoded 
global state sequence in the first column, and the normalized &quot;delta&quot; probabilities
in the remainining columns. These &quot;delta&quot; probabilities are defined as the joint 
probability of the most likely state sequence ending in state <var>i</var> at time <var>t</var>,
and all the observations up to time <var>t</var>. The normalization of these joint
probabilities is done on a time-point basis (i.e., dividing the delta probability
by the sum of the delta probabilities for that time point for all possible states 
<var>j</var> (including state <var>i</var>)). These probabilities are not straightforward 
to interpret. Setting <code>type = "global"</code> returns just a vector with the 
Viterbi-decoded global state sequence.
</p>
<p>Local decoding is based on the smoothing probabilities 
<code class="reqn">p(S_t \mid Y_1, \ldots, Y_T)</code>, which are the &quot;gamma&quot; probabilities 
computed with the <code><a href="#topic+forwardbackward">forwardbackward</a></code> algorithm. Local decoding then
consists of determining, at each time point <code class="reqn">t = 1, \ldots, T</code> 
</p>
<p style="text-align: center;"><code class="reqn">s*_t = \arg \max_{i=1}^N p(S_t = i \mid Y_1, \ldots, Y_T)</code>
</p>
 
<p>where <var>N</var> is the total number of states. Setting <code>type = "local"</code> returns
a vector with the local decoded states. Setting <code>type = "smoothing"</code> returns
the smoothing probabilities which underlie this classification. When considering
the posterior probability of each state, the values returned by <code>type = "smoothing"</code>
are most likely what is wanted by the user.
</p>
<p>The option <code>type = "filtering"</code> returns a matrix with the so-called filtering probabilities, 
defined as <code class="reqn">p(S_t \mid Y_1, \ldots, Y_t)</code>, i.e. the probability of a hidden 
state at time <var>t</var> considering the observations up to and including time <var>t</var>.
</p>
<p>See the <code><a href="#topic+fit">fit</a></code> help page for an example. 
</p>


<h3>Value</h3>

<p>The return value of <code>posterior</code> depends on the value of the <code>type</code>
argument:
</p>
<table>
<tr><td><code>type = 'viterbi'</code></td>
<td>
<p>Returns a data.frame with <code>nstates(object) + 1</code>
columns; the first column contains the states decoded through the Viterbi 
algorithm, the remaining columns contain the (normalized) delta probabilities.</p>
</td></tr>
<tr><td><code>type = 'global'</code></td>
<td>
<p>Returns a vector which contains the states decoded 
through the Viterbi algorithm.</p>
</td></tr>
<tr><td><code>type = 'local'</code></td>
<td>
<p>Returns a vector which contains the states decoded 
as the maximum of the smoothing probabilities.</p>
</td></tr>
<tr><td><code>type = 'filtering'</code></td>
<td>
<p>Returns a matrix which contains the posterior 
probabilities of each state, conditional upon the responses observed thus 
far.</p>
</td></tr>
<tr><td><code>type = 'smoothing'</code></td>
<td>
<p>Returns a matrix which contains the posterior 
probabilities of each state, conditional upon all the responses observed.</p>
</td></tr>
</table>
<p>See Details for more information.
</p>


<h3>Note</h3>

<p>The initial version of this function was a simple wrapper to return the value of the <code>posterior</code> slot in a <code>mix-fitted</code> or <code>depmix-fitted</code> object. The value of this slot is set by a call of the <code>viterbi</code> method. For backwards compatibility, the default value of the <code>type</code> argument is set to <code>"viterbi"</code>, which returns the same. As the &quot;delta&quot; probabilities returned as part of this may be misinterpreted, and may not be the desired posterior probabilities, the updated version of this method now allows for other return values, and the <code>type = "viterbi"</code> option should be considered depreciated.</p>


<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>


<h3>References</h3>

 	
<p>Lawrence R. Rabiner (1989). A tutorial on hidden Markov models and
selected applications in speech recognition. <em>Proceedings of
IEEE</em>, 77-2, p.  267-295. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed)

# 2-state model on rt and corr from speed data set 
# with Pacc as covariate on the transition matrix
# ntimes is used to specify the lengths of 3 separate series
mod &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
fmod &lt;- fit(mod)

# Global decoding:
pst_global &lt;- posterior(fmod, type = "global")

# Local decoding:
pst_local &lt;- posterior(fmod,type="local")

# Global and local decoding provide different results:
identical(pst_global, pst_local)

# smoothing probabilities are used for local decoding, and may be used as 
# easily interpretable posterior state probabilities
pst_prob &lt;- posterior(fmod, type = "smoothing")

# "delta" probabilities from the Viterbi algorithm
pst_delta &lt;- posterior(fmod, type="viterbi")[,-1]

# The smoothing and "delta" probabilities are different:
identical(pst_prob, pst_delta)

# Filtering probabilities are an alternative to smoothing probabilities:
pst_filt &lt;- posterior(fmod, type = "filtering")

# The smoothing and filtering probabilities are different:
identical(pst_prob, pst_filt)
</code></pre>

<hr>
<h2 id='response-class'>Class &quot;response&quot;</h2><span id='topic+response-class'></span>

<h3>Description</h3>

<p>A generic <code>response</code> model for <code><a href="#topic+depmix">depmix</a></code> models.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="response-class_+3A_object">object</code></td>
<td>
<p>An object of class &quot;response&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class offers a framework from which to build specific response
models such as glm based responses or multinomial responses.  For
extensibility, objects with class <code>response</code> should have at least
methods: <code>dens</code> to return the <code>dens</code>'ity of responses, and
<code>getpars</code> and <code>setpars</code> methods to get and set parameters.
</p>
<p>The <code>constr</code> slot is used for information on constraints that are
inherently part of a model; the only such constraints which are currently 
used are 1) the sum constraint in multinomial models with identity link, 
and 2) a lower bound of zero of sd parameters in gaussian distributions. 
Such constraints are only used in fitting models with general optimization
routines such as <code>Rsolnp</code>; the EM algorithm automagically respects the
sum constraint. 
</p>

<dl>
<dt><code>lin</code>:</dt><dd><p>Derivative of linear constraint.</p>
</dd>
<dt><code>linup</code>:</dt><dd><p>Upper bounds for linear constraints.</p>
</dd>
<dt><code>linlow</code>:</dt><dd><p>Lower bounds for linear constraints.</p>
</dd>
<dt><code>parup</code>:</dt><dd><p>Upper bounds on parameters.</p>
</dd>
<dt><code>parlow</code>:</dt><dd><p>Lower bounds on parameters.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>parameters</code>:</dt><dd><p>A (named) list of parameters.</p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>A logical vector indicating which parameters
are fixed.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>A matrix with the actual response; possibly
multivariate.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>A design matrix; possibly only an intercept term.</p>
</dd>
<dt><code>npar</code>:</dt><dd><p>The number of parameters.</p>
</dd>
<dt><code>constr</code>:</dt><dd><p>Information on constraints.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>getdf</code>:</dt><dd><p>The number of non-fixed parameters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>

<hr>
<h2 id='response-classes'>Class &quot;GLMresponse&quot; and class &quot;transInit&quot;</h2><span id='topic+response-classes'></span><span id='topic+GLMresponse-class'></span><span id='topic+transInit-class'></span><span id='topic+MVNresponse-class'></span>

<h3>Description</h3>

<p>Specific instances of response models for <code><a href="#topic+depmix">depmix</a></code>
models.</p>


<h3>Details</h3>

<p>The <code>GLMresponse</code>-class offers an interface to the
<code><a href="stats.html#topic+glm">glm</a></code> functions that are subsequently used in fitting
the <code>depmix</code> model of which the response is a part.
</p>
<p>The <code>transInit</code> is an extension of <code>response</code> that is used to
model the transition matrix and the initial state probabilities by the
use of a multinomial logistic model, the difference being that in fact
the response is missing as the transitions between states are not
observed.  This class has its own fit function which is an interface to
the multinom function in <code><a href="nnet.html#topic+nnet">nnet</a></code>.
</p>


<h3>Slots</h3>

<p>Both <code>GLMresponse</code> and <code>transInit</code> contain the
<code>response</code>-class. In addition to the slots of that class, these
classes have the following slots: 
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>A formula that specifies the model.</p>
</dd>
<dt><code>family</code>:</dt><dd><p>A family object specifying the link 
function. See the <code><a href="#topic+GLMresponse">GLMresponse</a></code> help page for 
possible options.</p>
</dd>
</dl>



<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>npar</code>:</dt><dd><p>The number of parameters of the model.</p>
</dd>
<dt><code>getdf</code>:</dt><dd><p>The number of non-fixed parameters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>

<hr>
<h2 id='responses'>Response models currently implemented in depmix.</h2><span id='topic+responses'></span><span id='topic+BINOMresponse'></span><span id='topic+GAMMAresponse'></span><span id='topic+MULTINOMresponse'></span><span id='topic+MVNresponse'></span><span id='topic+NORMresponse'></span><span id='topic+POISSONresponse'></span><span id='topic+show+2CMVNresponse-method'></span>

<h3>Description</h3>

<p>Depmix contains a number of default response models. We provide a
brief description of these here.</p>


<h3>BINOMresponse</h3>

<p><code>BINOMresponse</code> is a binomial response model. It derives from the basic
<code><a href="#topic+GLMresponse">GLMresponse</a></code> class.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable can be either a
binary vector, a factor, or a 2-column matrix, with successes and misses.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with a single element &ldquo;coefficients&rdquo;,
which contains the GLM coefficients.</p>
</dd>
</dl>



<h3>GAMMAresponse</h3>

<p><code>GAMMAresponse</code> is a model for a Gamma distributed response.
It extends the basic <code><a href="#topic+GLMresponse">GLMresponse</a></code> class directly.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with a single element &ldquo;coefficients&rdquo;,
which contains the GLM coefficients.</p>
</dd>
</dl>



<h3>MULTINOMresponse</h3>

<p><code>MULTINOMresponse</code> is a model for a multinomial distributed response.
It extends the basic <code><a href="#topic+GLMresponse">GLMresponse</a></code> class, although the
functionality is somewhat different from other models that do so.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable. This is a binary matrix with N rows and
Y columns, where Y is the total number of categories.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with a single element &ldquo;coefficients&rdquo;,
which is an <code>ncol(x)</code> by <code>ncol(y)</code> matrix which contains the GLM
coefficients.</p>
</dd>
</dl>



<h3>MVNresponse</h3>

<p><code>MVNresponse</code> is a model for a multivariate normal distributed
response.  See code<a href="#topic+makeDepmix">makeDepmix</a> for an example of how to use
this and other non-glm like distributions.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable. This is a matrix.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with a elements &ldquo;coefficients&rdquo;,
which contains the GLM coefficients, and &ldquo;Sigma&rdquo;, which contains the
covariance matrix.</p>
</dd>
</dl>



<h3>NORMresponse</h3>

<p><code>NORMresponse</code> is a model for a normal (Gaussian) distributed response.
It extends the basic <code><a href="#topic+GLMresponse">GLMresponse</a></code> class directly.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with elements &ldquo;coefficients&rdquo;,
which contains the GLM coefficients, and &ldquo;sd&rdquo;, which contains the
standard deviation.</p>
</dd>
</dl>



<h3>POISSONresponse</h3>

<p><code>POISSONresponse</code> is a model for a Poisson distributed response.
It extends the basic <code><a href="#topic+GLMresponse">GLMresponse</a></code> class directly.
</p>

<dl>
<dt>y:</dt><dd><p>The dependent variable.</p>
</dd>
<dt>x:</dt><dd><p>The design matrix.</p>
</dd>
<dt>Parameters:</dt><dd><p>A named list with a single element &ldquo;coefficients&rdquo;,
which contains the GLM coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# binomial response model
x &lt;- rnorm(1000)
p &lt;- plogis(x)
ss &lt;- rbinom(1000,1,p)
mod &lt;- GLMresponse(cbind(ss,1-ss)~x,family=binomial())
fit(mod)
glm(cbind(ss,1-ss)~x, family=binomial)

# gamma response model
x=runif(1000,1,5)
res &lt;- rgamma(1000,x)
## note that gamma needs proper starting values which are not
## provided by depmixS4 (even with them, this may produce warnings)
mod &lt;- GLMresponse(res~x,family=Gamma(),pst=c(0.8,1/0.8))
fit(mod)
glm(res~x,family=Gamma)

# multinomial response model
x &lt;- sample(0:1,1000,rep=TRUE)
mod &lt;- GLMresponse(sample(1:3,1000,rep=TRUE)~x,family=multinomial(),pstart=c(0.33,0.33,0.33,0,0,1))
mod@y &lt;- simulate(mod)
fit(mod)
colSums(mod@y[which(x==0),])/length(which(x==0))
colSums(mod@y[which(x==1),])/length(which(x==1))
# note that the response is treated as factor here, internal representation is in 
# dummy coded format:
head(mod@y)
# similar to the binomial model, data may also be entered in multi-column format 
# where the n for each row can be different
dt &lt;- data.frame(y1=c(0,1,1,2,4,5),y2=c(1,0,1,0,1,0),y3=c(4,4,3,2,1,1))
m2 &lt;- mix(cbind(y1,y2,y3)~1,data=dt,ns=2,family=multinomial("identity"))
fm2 &lt;- fit(m2)
summary(fm2)

# multivariate normal response model
mn &lt;- c(1,2,3)
sig &lt;- matrix(c(1,.5,0,.5,1,0,0,0,2),3,3)
y &lt;- mvrnorm(1000,mn,sig)
mod &lt;- MVNresponse(y~1)
fit(mod)
colMeans(y)
var(y)

# normal (gaussian) response model
y &lt;- rnorm(1000)
mod &lt;- GLMresponse(y~1)
fm &lt;- fit(mod)
cat("Test gaussian fit: ", all.equal(getpars(fm),c(mean(y),sd(y)),check.attributes=FALSE))

# poisson response model
x &lt;- abs(rnorm(1000,2))
res &lt;- rpois(1000,x)
mod &lt;- GLMresponse(res~x,family=poisson())
fit(mod)
glm(res~x, family=poisson)

# this creates data with a single change point with Poisson distributed data
set.seed(3)
y1 &lt;- rpois(50,1)
y2 &lt;- rpois(50,2)
ydf &lt;- data.frame(y=c(y1,y2))

# fit models with 1 to 3 states
m1 &lt;- depmix(y~1,ns=1,family=poisson(),data=ydf)
fm1 &lt;- fit(m1)
m2 &lt;- depmix(y~1,ns=2,family=poisson(),data=ydf)
fm2 &lt;- fit(m2)
m3 &lt;- depmix(y~1,ns=3,family=poisson(),data=ydf)
fm3 &lt;- fit(m3,em=em.control(maxit=500))

# plot the BICs to select the proper model
plot(1:3,c(BIC(fm1),BIC(fm2),BIC(fm3)),ty="b")

</code></pre>

<hr>
<h2 id='simulate'>Methods to simulate from (dep-)mix models</h2><span id='topic+simulate'></span><span id='topic+simulate+2Cresponse-method'></span><span id='topic+simulate+2Cmix-method'></span><span id='topic+simulate+2Cdepmix-method'></span><span id='topic+simulate+2CGLMresponse-method'></span><span id='topic+simulate+2CtransInit-method'></span><span id='topic+simulate+2CBINOMresponse-method'></span><span id='topic+simulate+2CGAMMAresponse-method'></span><span id='topic+simulate+2CMULTINOMresponse-method'></span><span id='topic+simulate+2CMVNresponse-method'></span><span id='topic+simulate+2CNORMresponse-method'></span><span id='topic+simulate+2CPOISSONresponse-method'></span>

<h3>Description</h3>

<p>Random draws from <code>(dep-)mix</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'depmix'
simulate(object, nsim=1, seed=NULL, ...)
  
  ## S4 method for signature 'mix'
simulate(object, nsim=1, seed=NULL, ...)

  ## S4 method for signature 'response'
simulate(object, nsim=1, seed=NULL, times, ...)
  
  ## S4 method for signature 'GLMresponse'
simulate(object, nsim=1, seed=NULL, times, ...)
  
  ## S4 method for signature 'transInit'
simulate(object, nsim=1, seed=NULL, times, is.prior=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>Object to generate random draws.  An object of class
<code>mix</code>, <code>depmix</code>, <code>response</code> or <code>transInit</code></p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>The number of draws (one draw simulates a data set of the
size that is defined by ntimes); defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>Set the seed.</p>
</td></tr>
<tr><td><code id="simulate_+3A_times">times</code></td>
<td>
<p>(optional) An indicator vector indicating for which times in the
complete series to generate the data.  For internal use.</p>
</td></tr>
<tr><td><code id="simulate_+3A_is.prior">is.prior</code></td>
<td>
<p>For <code>transInit</code> objects, indicates whether it is a prior 
(init) model, or not (i.e., it is a transition model)</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>depmix</code> model, simulate generates <code>nsim</code> random state
sequences, each of the same length as the observation sequence in the
<code>depmix</code> model (i.e., <code>sum(ntimes(object))</code>.  The state
sequences are then used to generate <code>nsim</code> observation sequences
of thee same length.
</p>
<p>For a <code>mix</code> model, simulate generates <code>nsim</code> random class 
assignments for each case. Those assigments are then used to generate
observation/response values from the appropriate distributions. 
</p>
<p>Setting the <code>times</code> option selects the time points in the total
state/observation sequence (i.e., counting is continued over ntimes).
Direct calls of simulate with the <code>times</code> option are not recommended.
</p>


<h3>Value</h3>

<p>For a <code>depmix</code> object, a new object of class <code>depmix.sim</code>. 
</p>
<p>For a <code>transInit</code> object, a state sequence.
</p>
<p>For a <code>response</code> object, an observation sequence.
</p>


<h3>Author(s)</h3>

<p>Maarten Speekenbrink &amp; Ingmar Visser</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(1000)
respst &lt;- c(0,1,2,1)
trst &lt;- c(0.9,0.1,0.1,0.9)

df &lt;- data.frame(y=y)

mod &lt;- depmix(y~1,data=df,respst=respst,trst=trst,inst=c(0.5,0.5),nti=1000,nst=2)

mod &lt;- simulate(mod)

</code></pre>

<hr>
<h2 id='sp500'>Standard &amp; Poor's 500 index</h2><span id='topic+sp500'></span>

<h3>Description</h3>

<p>This data set consists of (monthly) values of the S&amp;P 500 stock exchange
index. The variable of interest is the logarithm of the return values, i.e.,
the logarithm of the ratio of indices, in this case the closing index is
used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(speed)</code></pre>


<h3>Format</h3>

<p>A data frame with 744 observations and 6 variables.
</p>

<dl>
<dt><code>Open</code></dt><dd><p>Index at the start of trading.</p>
</dd>
<dt><code>High</code></dt><dd><p>Highest index.</p>
</dd>
<dt><code>Low</code></dt><dd><p>Lowest index.</p>
</dd>
<dt><code>Close</code></dt><dd><p>Index at the close of trading.</p>
</dd>
<dt><code>Volume</code></dt><dd><p>The volume of trading.</p>
</dd>
<dt><code>logret</code></dt><dd><p>The log return of the closing index.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yahoo Data. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp500)

# the data can be made with the following code (eg to include a longer or
# shorter time span)

## Not run: 

require(TTR)

# load SP500 returns
Sys.setenv(tz='UTC')

sp500 &lt;- getYahooData('^GSPC',start=19500101,end=20120228,freq='daily')
ep &lt;- endpoints(sp500, on="months", k=1)
sp500 &lt;- sp500[ep[2:(length(ep)-1)]]
sp500$sp500_ret &lt;- log(sp500$Close) - lag(log(sp500$Close))
sp500 &lt;- na.exclude(sp500)


## End(Not run)

</code></pre>

<hr>
<h2 id='speed'>Speed Accuracy Switching Data</h2><span id='topic+speed'></span>

<h3>Description</h3>

<p>This data set is a bivariate series of response times and accuracy
scores of a single participant switching between slow/accurate
responding and fast guessing on a lexical decision task.  The slow and
accurate responding, and the fast guessing can be modelled using two
states, with a switching regime between them.  The dataset further
contains a third variable called Pacc, representing the relative
pay-off for accurate responding, which is on a scale of zero to one.
The value of Pacc was varied during the experiment to induce the
switching.  This data set is a from participant A in experiment 
1a from Dutilh et al (2011). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(speed)</code></pre>


<h3>Format</h3>

<p>A data frame with 439 observations on the following 4 variables.
</p>

<dl>
<dt><code>rt</code></dt><dd><p>a numeric vector of response times (log ms)</p>
</dd>
<dt><code>corr</code></dt><dd><p>a numeric vector of accuracy scores (0/1)</p>
</dd>
<dt><code>Pacc</code></dt><dd><p>a numeric vector of the pay-off for accuracy</p>
</dd>
<dt><code>prev</code></dt><dd><p>a numeric vector of accuracy scores (0/1) 
on the previous trial</p>
</dd>
</dl>



<h3>Source</h3>

<p>Gilles Dutilh, Eric-Jan Wagenmakers, Ingmar Visser, &amp; Han L. J. van der Maas (2011).
A phase transition model for the speed-accuracy trade-off in response time experiments.
<em>Cognitive Science</em>, 35:211-250.
</p>
<p>Corresponding author: g.dutilh@uva.nl 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(speed)
## maybe str(speed) ; plot(speed) ...
</code></pre>

<hr>
<h2 id='stationary'>Compute the stationary distribution of a transition probability matrix.</h2><span id='topic+stationary'></span>

<h3>Description</h3>

<p>See title.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary(tpm)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stationary_+3A_tpm">tpm</code></td>
<td>
<p>a transition probability matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the stationary distribution such that p=tpm*p.</p>


<h3>Author(s)</h3>

<p>Ingmar Visser</p>

<hr>
<h2 id='transInit'>Methods for creating depmix transition and initial probability models</h2><span id='topic+transInit'></span><span id='topic+transInit+2Cformula-method'></span><span id='topic+getdf+2CtransInit-method'></span>

<h3>Description</h3>

<p>Create <code>transInit</code> objects for <code><a href="#topic+depmix">depmix</a></code> models using
formulae and family objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
	transInit(formula, nstates, data=NULL, family=multinomial(),
		pstart=NULL, fixed=NULL, prob=TRUE, ...)
		
		## S4 method for signature 'transInit'
getdf(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transInit_+3A_formula">formula</code></td>
<td>
<p>A model <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="transInit_+3A_data">data</code></td>
<td>
<p>An optional data.frame to interpret the variables from the 
formula argument in.</p>
</td></tr>
<tr><td><code id="transInit_+3A_family">family</code></td>
<td>
<p>A family object; see details.</p>
</td></tr>
<tr><td><code id="transInit_+3A_pstart">pstart</code></td>
<td>
<p>Starting values for the coefficients.</p>
</td></tr>
<tr><td><code id="transInit_+3A_fixed">fixed</code></td>
<td>
<p>Logical vector indicating which paramters are to be fixed.</p>
</td></tr>
<tr><td><code id="transInit_+3A_prob">prob</code></td>
<td>
<p>Logical indicating whether the starting values for
multinomial() family models are probabilities or logistic
parameters (see details).</p>
</td></tr>
<tr><td><code id="transInit_+3A_nstates">nstates</code></td>
<td>
<p>The number of states of the model.</p>
</td></tr>
<tr><td><code id="transInit_+3A_object">object</code></td>
<td>
<p>An object of class <code>transInit</code>.</p>
</td></tr>
<tr><td><code id="transInit_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>transInit</code> model provides functionality for the multinomial
probabilities of the transitions between states, as well as for the
prior or initial probabilities.  These probabilities may depend on
(time-varying) covariates.  The model can be used with link functions
<code>mlogit</code> and <code>identity</code>; the latter is the default when no
covariates are.  With the <code>mlogit</code> link function, the transition
probabilities are modeled as baseline logistic multinomials (see
Agresti, 2002, p.  272 ff.).
</p>
<p>Start values for the parameters may be provided using the <code>pstart</code>
argument; these can be provided as probabilities, the default option,
or as baseline logistic parameters, use the <code>prob</code> argument to
specify the chosen option.  The default baseline category is set to 1,
which can be modified through calling, say, family=multinomial(base=2).
</p>
<p>Note that the transInit model extends the <code><a href="#topic+response-class">response-class</a></code>,
but that it actually lacks a reponse, i.e. the y-slot is empty, at the
time of construction, as the transitions are not observed.
</p>
<p><code>getdf</code> returns the number of free parameters of a transInit model.
</p>


<h3>Value</h3>

<p><code>transInit</code> return objects of class <code>transInit</code>; this class
extends the <code><a href="#topic+response-class">response-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ingmar Visser &amp; Maarten Speekenbrink</p>


<h3>References</h3>

<p>Agresti, A. (2002).  <em>Categorical Data Analysis</em>.  Wiley series in
probability and mathematical statistics.  Wiley-Interscience, Hoboken,
NJ, 2 edition.
</p>

<hr>
<h2 id='vcov'> Parameter standard errors </h2><span id='topic+vcov'></span><span id='topic+confint'></span><span id='topic+standardError'></span><span id='topic+hessian'></span><span id='topic+vcov+2Cmix-method'></span><span id='topic+confint+2Cmix-method'></span><span id='topic+standardError+2Cmix-method'></span><span id='topic+hessian+2Cmix-method'></span>

<h3>Description</h3>

<p>These functions provide standard errors for parameters of (dep-)mix models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S4 method for signature 'mix'
vcov(object, fixed=NULL, equal=NULL, 
		conrows=NULL, conrows.upper=NULL, conrows.lower=NULL, tolerance=1e-6, 
		method="finiteDifferences", ...)	
	
	## S4 method for signature 'mix'
standardError(object, fixed=NULL, equal=NULL, 
		conrows=NULL, conrows.upper=NULL, conrows.lower=NULL, tolerance=1e-6, 
		method="finiteDifferences", ...)	
	
	## S4 method for signature 'mix'
confint(object, level=0.95, fixed=NULL, equal=NULL, 
		conrows=NULL, conrows.upper=NULL, conrows.lower=NULL, tolerance=1e-6, 
		method="finiteDifferences", ...)	

	## S4 method for signature 'mix'
hessian(object, tolerance=1e-6, 	
			method="finiteDifferences", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>A (dep-)mix object; see <a href="#topic+depmix">depmix</a> for details.</p>
</td></tr>
<tr><td><code id="vcov_+3A_fixed">fixed</code>, <code id="vcov_+3A_equal">equal</code></td>
<td>
<p>These arguments are used to specify constraints on a model; see usage details here: <code><a href="#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_conrows">conrows</code></td>
<td>
<p>These arguments are used to specify constraints on a model; see usage details here: <code><a href="#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_conrows.upper">conrows.upper</code></td>
<td>
<p>These arguments are used to specify constraints on a model; see usage details here: <code><a href="#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_conrows.lower">conrows.lower</code></td>
<td>
<p>These arguments are used to specify constraints on a model; see usage details here: <code><a href="#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_tolerance">tolerance</code></td>
<td>
<p>Threshold used for testing whether parameters are estimated on the boundary of the parameter space; if so, 
they are ignored in these functions.</p>
</td></tr>
<tr><td><code id="vcov_+3A_method">method</code></td>
<td>
<p>The method used for computing the Hessian matrix of the parameters; currently only a finite 
differences method (using <code>fdHess</code> from package <code><a href="nlme.html#topic+nlme">nlme</a></code>) is implemented and hence used by default.</p>
</td></tr>
<tr><td><code id="vcov_+3A_level">level</code></td>
<td>
<p>The desired significance level for the confidence intervals.</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods; currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p><code>vcov</code> computes the variance-covariance matrix of a (dep-)mix object, either fitted or not. 
It does so by first constructing a Hessian matrix through the use of <code>hessian</code> and then 
transforming this as described in Visser et al (2000), taking into account the linear constraints 
that are part of the model. Currently, <code>hessian</code> has a single <code>method</code> using finite 
differences to arrive at an approximation of the second order derivative matrix of the parameters. 
</p>
<p><code>confint</code> and <code>standardError</code> use <code>vcov</code> to compute confidence intervals (the confidence
level can be set through an argument) and standard errors respectively. The latter are computed first by 
using <code>sqrt(diag(vcov))</code> and the confidence intervals are computed through the normal approximation. 
</p>
<p>If and when these methods are applied to <code>fit</code>'ted models, the linear constraint matrix is 
obtained from the <code>mix.fitted</code> or <code>depmix.fitted</code> slot <code>lincon</code> (supplemented with 
additional constraints if those are provided through the <code>equal</code> and other arguments to these
functions). 
</p>
<p>All four functions exclude parameters that are estimated on or near (this can be controlled using 
the <code>tolerance</code> argument) their boundary values. Setting this argument to zero can result in
error as the <code>fdHess</code> function requires an environment around the parameter estimate that 
provides proper log-likelihood values, which parameter on or over their boundary values are not
guaranteed to provided. Fixed parameters are similarly ignored in these four functions. 
</p>


<h3>Value</h3>

<p><code>vcov</code> returns a named list with elements <code>vcov</code>, <code>elements</code>, and <code>lincon</code>. 
<code>standardError</code> returns a <code>data.frame</code> with columns <code>par</code>, <code>elements</code>, 
and <code>se</code>. <code>confint</code> returns a <code>data.frame</code> with columns <code>par</code>, 
<code>elements</code>, and two columns for the lower and upper bounds of the confidence intervals 
(with the column names indicating the <code>level</code> of the interval.)
</p>
<table>
<tr><td><code>vcov</code></td>
<td>
<p>: The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>elements</code></td>
<td>
<p>: Vector of length <code>npar(object)</code> indicating which elements of 
the parameter vector are included in computing the hessian, the variance-covariance matrix, 
the standard errors and/or the confidence intervals.</p>
</td></tr>
<tr><td><code>inc</code></td>
<td>
<p>: 'inc'luded parameter.</p>
</td></tr>
<tr><td><code>fix</code></td>
<td>
<p>: 'fix'ed parameter.</p>
</td></tr>
<tr><td><code>bnd</code></td>
<td>
<p>: parameter estimated on the boundary.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>: The values of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>: The values of the standard errors of the parameters.</p>
</td></tr>
<tr><td><code>lower/upper</code></td>
<td>
<p>: The lower and upper bounds of the confidence intervals; column names
indicate the as in 0.5+/-level/2, using the <code>level</code> argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the quality of the resulting standard errors is similar to those reported in 
Visser et al (2000) for both bootstrap and the profile likelihood methods. In Visser et
al (2000), the finite differences standard errors were somewhat less precise as they 
relied on a very parsimonious but indeed less precise method for computing the finite
differences approximation (computation time was a much scarcer resource at the time then
it is now). 
</p>


<h3>Author(s)</h3>

<p> Ingmar Visser </p>


<h3>References</h3>

 	
<p>Ingmar Visser, Maartje E. J. Raijmakers, and Peter C. M. Molenaar (2000).
Confidence intervals for hidden Markov model parameters. <em>British journal
of mathematical and statistical psychology</em>, 53, p. 317-327. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data(speed)

	# 2-state model on rt and corr from speed data set 
	# with Pacc as covariate on the transition matrix
	# ntimes is used to specify the lengths of 3 separate series
	mod1 &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
		family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
	
	# fit the model
	set.seed(3)
	fmod1 &lt;- fit(mod1)
	
	vcov(fmod1)$vcov # $
	standardError(fmod1)
	confint(fmod1)
	
</code></pre>

<hr>
<h2 id='viterbi'>Viterbi algorithm for decoding the most likely state sequence</h2><span id='topic+viterbi'></span><span id='topic+viterbi2'></span><span id='topic+viterbi.fb'></span>

<h3>Description</h3>

<p>Apply the Viterbi algorithm to compute the maximum a posteriori state sequence
for a <code>mix</code> or <code>depmix</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	viterbi(object, na.allow=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi_+3A_object">object</code></td>
<td>
<p>A <code>mix</code> or <code>depmix</code> object.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_na.allow">na.allow</code></td>
<td>
<p>logical. If TRUE, the density of missing responses is set to 
1, similar as in the <code><a href="#topic+forwardbackward">forwardbackward</a></code> algorithm. If FALSE, missing 
values have NA as density values, and will result in an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Viterbi algorithm is used for global decoding of the hidden state 
sequence. Global decoding is based on the conditional probability
<code class="reqn">p(S_1, \ldots, S_T \mid Y_1, \ldots, Y_T)</code>, and consists of determining, 
at each time point <code class="reqn">t = 1, \ldots, T</code>:
</p>
<p style="text-align: center;"><code class="reqn">s*_t = \arg \max_{i=1}^N p(S_1 = s*_1, \ldots, S_{t-1} = s*_{t-1}, S_t = i, S_{t+1} = s*_{t+1}, \ldots, S_T = s*_{T} \mid Y_1, \ldots, Y_T)</code>
</p>

<p>where <var>N</var> is the total number of states.
</p>
<p>The Viterbi algorithm is a dynamic programming algorithm that relies on 
&quot;delta&quot; probabilities (see Rabiner, 1989), which are defined as the joint 
probability of the most likely state sequence ending in state <var>i</var> at time <var>t</var>,
and all the observations up to time <var>t</var>. The implementation here normalizes 
these probabilities on a time-point basis, dividing the delta probability
by the sum of the delta probabilities for that time point for all possible states 
<var>j</var> (including state <var>i</var>)). The normalized delta probabilities for
each state are returned in columns <code>2:(nstates(object) + 1)</code>, whilst
column 1 contains the indices of the maximum a posteriori states.
</p>


<h3>Value</h3>

<p><code>viterbi</code> returns a <code>data.frame</code> with in the first column 
the maximum a posteriori state sequence. This is a vector with integers 
corresponding to the index of the most likely hidden states. The remaining
columns contain the normalized &quot;delta&quot; probabilities (see Details). 
</p>


<h3>Author(s)</h3>

<p>Maarten Speekenbrink</p>


<h3>References</h3>

 	
<p>Lawrence R. Rabiner (1989).  A tutorial on hidden Markov models and
selected applications in speech recognition.  <em>Proceedings of
IEEE</em>, 77-2, p.  267-295. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed)

# 2-state model on rt and corr from speed data set 
# with Pacc as covariate on the transition matrix
# ntimes is used to specify the lengths of 3 separate series
mod &lt;- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,
	family=list(gaussian(),multinomial("identity")),ntimes=c(168,134,137))
fmod &lt;- fit(mod)
# result of viterbi is stored in a depmix-fitted object in slot "posterior"
identical(viterbi(fmod),fmod@posterior)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
