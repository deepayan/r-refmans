<!DOCTYPE html><html lang="en"><head><title>Help for package MetricGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MetricGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MetricGraph-package'><p>Gaussian processes on metric graphs</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#augment.graph_lme'><p>Augment data with information from a <code>graph_lme</code> object</p></a></li>
<li><a href='#bru_mapper.inla_metric_graph_spde'><p>Metric graph 'inlabru' mapper</p></a></li>
<li><a href='#drop_na.metric_graph_data'><p>A version of <code>tidyr::drop_na()</code> function for datasets on metric graphs</p></a></li>
<li><a href='#exp_covariance'><p>Exponential covariance function</p></a></li>
<li><a href='#filter.metric_graph_data'><p>A version of <code>dplyr::filter()</code> function for datasets on metric graphs</p></a></li>
<li><a href='#gg_df.metric_graph_spde_result'><p>Data frame for metric_graph_spde_result objects to be used in 'ggplot2'</p></a></li>
<li><a href='#glance.graph_lme'><p>Glance at a <code>graph_lme</code> object</p></a></li>
<li><a href='#graph_bru_process_data'><p>Prepare data frames or data lists to be used with 'inlabru' in metric</p>
graphs</a></li>
<li><a href='#graph_components'><p>Connected components of metric graph</p></a></li>
<li><a href='#graph_data_spde'><p>Data extraction for 'spde' models</p></a></li>
<li><a href='#graph_lgcp'><p>Simulation of log-Gaussian Cox processes driven by Whittle-Matérn</p>
fields on metric graphs</a></li>
<li><a href='#graph_lme'><p>Metric graph linear mixed effects models</p></a></li>
<li><a href='#graph_spde'><p>'INLA' implementation of Whittle-Matérn fields for metric graphs</p></a></li>
<li><a href='#graph_spde_basis'><p>Deprecated - Observation/prediction matrices for 'SPDE' models</p></a></li>
<li><a href='#graph_spde_make_A'><p>Deprecated - Observation/prediction matrices for 'SPDE' models</p></a></li>
<li><a href='#graph_starting_values'><p>Starting values for random field models on metric graphs</p></a></li>
<li><a href='#linnet.to.graph'><p>Convert a <code>linnet</code> object to a metric graph object</p></a></li>
<li><a href='#logo_lines'><p>Create lines for package name</p></a></li>
<li><a href='#make_Q_euler'><p>Space-time precision operator Euler discretization</p></a></li>
<li><a href='#make_Q_spacetime'><p>Space-time precision operator discretization</p></a></li>
<li><a href='#metric_graph'><p>Metric graph</p></a></li>
<li><a href='#mutate.metric_graph_data'><p>A version of <code>dplyr::mutate()</code> function for datasets on metric graphs</p></a></li>
<li><a href='#pems'><p>Traffic speed data from San Jose, California</p></a></li>
<li><a href='#pems_repl'><p>Traffic speed data with replicates from San Jose, California</p></a></li>
<li><a href='#plot.graph_bru_pred'><p>Plot of predicted values with 'inlabru'</p></a></li>
<li><a href='#plot.graph_bru_proc_pred'><p>Plot of processed predicted values with 'inlabru'</p></a></li>
<li><a href='#posterior_crossvalidation'><p>Leave-one-out crossvalidation for <code>graph_lme</code> models assuming observations at</p>
the vertices of metric graphs</a></li>
<li><a href='#predict.graph_lme'><p>Prediction for a mixed effects regression model on a metric graph</p></a></li>
<li><a href='#predict.inla_metric_graph_spde'><p>Predict method for 'inlabru' fits on Metric Graphs</p></a></li>
<li><a href='#predict.rspde_metric_graph'><p>Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models</p></a></li>
<li><a href='#process_rspde_predictions'><p>Process predictions of <code>rspde_metric_graph</code> objects obtained by using <code>inlabru</code></p></a></li>
<li><a href='#psp.to.graph'><p>Convert a <code>psp</code> object to a metric graph object</p></a></li>
<li><a href='#sample_spde'><p>Samples a Whittle-Matérn field on a metric graph</p></a></li>
<li><a href='#select.metric_graph_data'><p>A version of <code>dplyr::select()</code> function for datasets on metric graphs</p></a></li>
<li><a href='#selected_inv'><p>Selected Inverse Calculation</p></a></li>
<li><a href='#simulate_spacetime'><p>space-time simulation based on implicit Euler discretization in time</p></a></li>
<li><a href='#simulate.graph_lme'><p>Simulation of models on metric graphs</p></a></li>
<li><a href='#spde_covariance'><p>Covariance function for Whittle-Matérn fields</p></a></li>
<li><a href='#spde_metric_graph_result'><p>Metric graph SPDE result extraction from 'INLA' estimation results</p></a></li>
<li><a href='#spde_precision'><p>Precision matrix for Whittle-Matérn fields</p></a></li>
<li><a href='#spde_variance'><p>Variancefor Whittle-Matérn fields</p></a></li>
<li><a href='#stlpp.to.graph'><p>Convert an <code>stlpp</code> object to a metric graph object</p></a></li>
<li><a href='#summarise.metric_graph_data'><p>A version of <code>dplyr::summarise()</code> function for datasets on metric graphs</p></a></li>
<li><a href='#summary.graph_lme'><p>Summary Method for <code>graph_lme</code> Objects</p></a></li>
<li><a href='#summary.metric_graph'><p>Summary Method for <code>metric_graph</code> Objects</p></a></li>
<li><a href='#summary.metric_graph_spde_result'><p>Summary for posteriors of field parameters for an <code>inla_rspde</code></p>
model from a <code>rspde.result</code> object</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Random Fields on Metric Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Bolin &lt;davidbolin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates creation and manipulation of metric graphs, such as street or river networks. Further facilitates operations and visualizations of data on metric graphs, and the creation of a large class of random fields and stochastic partial differential equations on such spaces. These random fields can be used for simulation, prediction and inference. In particular, linear mixed effects models including random field components can be fitted to data based on computationally efficient sparse matrix representations. Interfaces to the R packages 'INLA' and 'inlabru' are also provided, which facilitate working with Bayesian statistical models on metric graphs. The main references for the methods are Bolin, Simas and Wallin (2024) &lt;<a href="https://doi.org/10.3150%2F23-BEJ1647">doi:10.3150/23-BEJ1647</a>&gt;, Bolin, Kovacs, Kumar and Simas (2023) &lt;<a href="https://doi.org/10.1090%2Fmcom%2F3929">doi:10.1090/mcom/3929</a>&gt; and Bolin, Simas and Wallin (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2304.03190">doi:10.48550/arXiv.2304.03190</a>&gt; and &lt;<a href="https://doi.org/10.48550%2FarXiv.2304.10372">doi:10.48550/arXiv.2304.10372</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, RANN, ggplot2, igraph, sf, rSPDE (&ge; 2.3.3), Matrix,
methods, Rcpp (&ge; 1.0.5), R6, lifecycle, sp, dplyr, tidyr,
magrittr, broom, zoo, ggnewscale</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, INLA (&ge; 22.12.14), inlabru, osmdata, sn,
plotly, parallel, optimParallel, numDeriv, SSN2, cowplot,
leaflet, mapview, viridis, fmesher</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidbolin/MetricGraph/issues">https://github.com/davidbolin/MetricGraph/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidbolin.github.io/MetricGraph/">https://davidbolin.github.io/MetricGraph/</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>The R package and code, and the main programs, were written
by and are Copyright by David Bolin, Alexandre B. Simas and
Jonas Wallin, and are redistributable under the GNU Public
License, version 2 or later. The package also includes partial
codes from another package, which was deprecated in Oct-2023,
and whose codes are under the GPL-2 license. For details see
the COPYRIGHTS file.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-02 19:46:21 UTC; debusta</td>
</tr>
<tr>
<td>Author:</td>
<td>David Bolin [cre, aut],
  Alexandre Simas [aut],
  Jonas Wallin [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-02 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MetricGraph-package'>Gaussian processes on metric graphs</h2><span id='topic+MetricGraph'></span><span id='topic+MetricGraph-package'></span>

<h3>Description</h3>

<p>'MetricGraph' is used for creation and manipulation of metric graphs, such as street or river networks.
It also has several functions thatfacilitates operations and visualizations of data on metric graphs,
and the creation of a large class of random fields and stochastic partial differential equations on
such spaces.
The main models are the Whittle-Matérn fields, which are specified through the
fractional elliptic SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa^2 - \Delta)^{\alpha/2} (\tau u(s)) = W,</code>
</p>

<p><code class="reqn">\kappa,\tau&gt;0</code> and <code class="reqn">\alpha&gt;1/2</code> are parameters and <code class="reqn">W</code> is Gaussian white noise.
It contains exact implementations of the above model for <code class="reqn">\alpha=1</code> and <code class="reqn">\alpha=2</code>,
and contains approximate implementations, via the finite element method, for any <code class="reqn">\alpha &gt; 0.5</code>.
It also implements models based on graph Laplacians and isotropic covariance functions.
Several utility functions for specifying graphs, computing likelihoods, performing
prediction, simulating processes, and visualizing results on metric graphs are provided.
In particular, linear mixed effects models including random field components can be fitted to
data based on computationally efficient sparse matrix representations. Interfaces to the R
packages 'INLA' and 'inlabru' are also provided, which facilitate working with Bayesian statistical
models on metric graphs.
</p>


<h3>Details</h3>

<p>At the heart of the package is the <code>R6</code> class <code style="white-space: pre;">&#8288;[metric_graph()]&#8288;</code>. This is used for specifying
metric graphs, and contains various utility functions which are needed for specifying Gaussian
processes on such spaces.
</p>
<p>Linear mixed effects models are provided (see
<code style="white-space: pre;">&#8288;[graph_lme]&#8288;</code>) and perform
predictions (see <code style="white-space: pre;">&#8288;[predict.graph_lme]&#8288;</code>). The package also has interfaces for
'INLA' (see <code style="white-space: pre;">&#8288;[graph_spde]&#8288;</code>), and it this interface also works with 'inlabru'.
</p>
<p>For a more detailed introduction to the package, see the 'MetricGraph' Vignettes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Alexandre Simas <a href="mailto:alexandre.impa@gmail.com">alexandre.impa@gmail.com</a>
</p>
</li>
<li><p> Jonas Wallin <a href="mailto:jonas.wallin81@gmail.com">jonas.wallin81@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://davidbolin.github.io/MetricGraph/">https://davidbolin.github.io/MetricGraph/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/davidbolin/MetricGraph/issues">https://github.com/davidbolin/MetricGraph/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='augment.graph_lme'>Augment data with information from a <code>graph_lme</code> object</h2><span id='topic+augment.graph_lme'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds information about each observation in the dataset. It includes
predicted values in the <code>.fitted</code> column, residuals in the <code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code> column.
It also contains the New columns always begin with a . prefix to avoid overwriting columns in the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_lme'
augment(
  x,
  newdata = NULL,
  which_repl = NULL,
  sd_post_re = FALSE,
  se_fit = FALSE,
  conf_int = FALSE,
  pred_int = FALSE,
  level = 0.95,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "spatial"),
  normalized = FALSE,
  no_nugget = FALSE,
  check_euclidean = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.graph_lme_+3A_x">x</code></td>
<td>
<p>A <code>graph_lme</code> object.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction. If <code>NULL</code>, the fitted values will be given for the original locations where the model was fitted.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to obtain the prediction. If <code>NULL</code> predictions
will be obtained for all replicates. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_sd_post_re">sd_post_re</code></td>
<td>
<p>Logical indicating whether or not a .sd_post_re column should be added to the augmented output containing the posterior standard deviations of the random effects.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a .se_fit column should be added to the augmented output containing the standard errors of the fitted values. If <code>TRUE</code>, the posterior standard deviations of the random effects will also be returned.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_conf_int">conf_int</code></td>
<td>
<p>Logical indicating whether or not confidence intervals for the posterior mean of the random effects should be built.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_pred_int">pred_int</code></td>
<td>
<p>Logical indicating whether or not prediction intervals for the fitted values should be built. If <code>TRUE</code>, the confidence intervals for the posterior random effects will also be built.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_level">level</code></td>
<td>
<p>Level of confidence and prediction intervals if they are constructed.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_edge_number">edge_number</code></td>
<td>
<p>Name of the variable that contains the edge number, the
default is <code>edge_number</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_distance_on_edge">distance_on_edge</code></td>
<td>
<p>Name of the variable that contains the distance on
edge, the default is <code>distance_on_edge</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_coord_x">coord_x</code></td>
<td>
<p>Column (or entry on the list) of the <code>data</code> that contains
the x coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_coord_y">coord_y</code></td>
<td>
<p>Column (or entry on the list) of the <code>data</code> that contains
the y coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_data_coords">data_coords</code></td>
<td>
<p>To be used only if <code>Spoints</code> is <code>NULL</code>. It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_normalized">normalized</code></td>
<td>
<p>Are the distances on edges normalized?</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_no_nugget">no_nugget</code></td>
<td>
<p>Should the prediction be done without nugget?</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_check_euclidean">check_euclidean</code></td>
<td>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</td></tr>
<tr><td><code id="augment.graph_lme_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with columns:
</p>

<ul>
<li> <p><code>.fitted</code> Fitted or predicted value.
</p>
</li>
<li> <p><code>.relwrconf</code> Lower bound of the confidence interval of the random effects, if conf_int = TRUE
</p>
</li>
<li> <p><code>.reuprconf</code> Upper bound of the confidence interval of the random effects, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fittedlwrpred</code> Lower bound of the prediction interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fitteduprpred</code> Upper bound of the prediction interval, if conf_int = TRUE
</p>
</li>
<li> <p><code>.fixed</code> Prediction of the fixed effects.
</p>
</li>
<li> <p><code>.random</code> Prediction of the random effects.
</p>
</li>
<li> <p><code>.resid</code> The ordinary residuals, that is, the difference between observed and fitted values.
</p>
</li>
<li> <p><code>.std_resid</code> The standardized residuals, that is, the ordinary residuals divided by the standard error of the fitted values (by the prediction standard error), if se_fit = TRUE or pred_int = TRUE.
</p>
</li>
<li> <p><code>.se_fit</code> Standard errors of fitted values, if se_fit = TRUE.
</p>
</li>
<li> <p><code>.sd_post_re</code> Standard deviation of the posterior mean of the random effects, if se_fit = TRUE.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+glance.graph_lme">glance.graph_lme</a>
</p>

<hr>
<h2 id='bru_mapper.inla_metric_graph_spde'>Metric graph 'inlabru' mapper</h2><span id='topic+bru_mapper.inla_metric_graph_spde'></span><span id='topic+bru_get_mapper.inla_metric_graph_spde'></span><span id='topic+ibm_n.bru_mapper_inla_metric_graph_spde'></span><span id='topic+ibm_values.bru_mapper_inla_metric_graph_spde'></span><span id='topic+ibm_jacobian.bru_mapper_inla_metric_graph_spde'></span>

<h3>Description</h3>

<p>Metric graph 'inlabru' mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.inla_metric_graph_spde(model, ...)

ibm_n.bru_mapper_inla_metric_graph_spde(mapper, ...)

ibm_values.bru_mapper_inla_metric_graph_spde(mapper, ...)

ibm_jacobian.bru_mapper_inla_metric_graph_spde(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bru_mapper.inla_metric_graph_spde_+3A_model">model</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> for which to construct or extract a mapper</p>
</td></tr>
<tr><td><code id="bru_mapper.inla_metric_graph_spde_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper.inla_metric_graph_spde_+3A_mapper">mapper</code></td>
<td>
<p>A <code>bru_mapper.inla_metric_graph_spde</code> object</p>
</td></tr>
<tr><td><code id="bru_mapper.inla_metric_graph_spde_+3A_input">input</code></td>
<td>
<p>The values for which to produce a mapping matrix</p>
</td></tr>
</table>

<hr>
<h2 id='drop_na.metric_graph_data'>A version of <code>tidyr::drop_na()</code> function for datasets on metric graphs</h2><span id='topic+drop_na.metric_graph_data'></span><span id='topic+drop_na'></span>

<h3>Description</h3>

<p>Applies <code>tidyr::drop_na()</code> function for datasets obtained from a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_data'
drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_na.metric_graph_data_+3A_data">data</code></td>
<td>
<p>The data list or <code>tidyr::tibble</code> obtained from a metric graph object.</p>
</td></tr>
<tr><td><code id="drop_na.metric_graph_data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>tidyr::drop_na()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyr::tibble</code> with the resulting selected columns.
</p>

<hr>
<h2 id='exp_covariance'>Exponential covariance function</h2><span id='topic+exp_covariance'></span>

<h3>Description</h3>

<p>Evaluates the exponential covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2 \exp\{-kappa h\}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>exp_covariance(h, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_covariance_+3A_h">h</code></td>
<td>
<p>Distances to evaluate the covariance function at.</p>
</td></tr>
<tr><td><code id="exp_covariance_+3A_theta">theta</code></td>
<td>
<p>A vector <code>c(sigma, kappa)</code>, where <code>sigma</code> is the standard
deviation and <code>kappa</code> is a range-like parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values of the covariance function.
</p>

<hr>
<h2 id='filter.metric_graph_data'>A version of <code>dplyr::filter()</code> function for datasets on metric graphs</h2><span id='topic+filter.metric_graph_data'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>Applies <code>dplyr::filter()</code> function for datasets obtained from a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_data'
filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.metric_graph_data_+3A_.data">.data</code></td>
<td>
<p>The data list or <code>tidyr::tibble</code> obtained from a metric graph object.</p>
</td></tr>
<tr><td><code id="filter.metric_graph_data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>dplyr::filter()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyr::tibble</code> with the resulting selected columns.
</p>

<hr>
<h2 id='gg_df.metric_graph_spde_result'>Data frame for metric_graph_spde_result objects to be used in 'ggplot2'</h2><span id='topic+gg_df.metric_graph_spde_result'></span><span id='topic+gg_df'></span>

<h3>Description</h3>

<p>Returns a 'ggplot2'-friendly data-frame with the marginal posterior densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_spde_result'
gg_df(
  result,
  parameter = result$params,
  transform = TRUE,
  restrict_x_axis = parameter,
  restrict_quantiles = list(sigma = c(0, 1), range = c(0, 1), kappa = c(0, 1), sigma =
    c(0, 1)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_result">result</code></td>
<td>
<p>A metric_graph_spde_result object.</p>
</td></tr>
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_parameter">parameter</code></td>
<td>
<p>Vector. Which parameters to get the posterior density in the
data.frame? The options are <code>sigma</code>, <code>range</code> or <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_transform">transform</code></td>
<td>
<p>Should the posterior density be given in the original scale?</p>
</td></tr>
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_restrict_x_axis">restrict_x_axis</code></td>
<td>
<p>Variables to restrict the range of x axis based on quantiles.</p>
</td></tr>
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_restrict_quantiles">restrict_quantiles</code></td>
<td>
<p>List of quantiles to restrict x axis.</p>
</td></tr>
<tr><td><code id="gg_df.metric_graph_spde_result_+3A_...">...</code></td>
<td>
<p>Not being used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the posterior densities.
</p>

<hr>
<h2 id='glance.graph_lme'>Glance at a <code>graph_lme</code> object</h2><span id='topic+glance.graph_lme'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>Glance accepts a <code>graph_lme</code> object and returns a
<code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row of model summaries.
The summaries are the square root of the estimated variance of the measurement error, residual
degrees of freedom, AIC, BIC, log-likelihood,
the type of latent model used in the fit and the total number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_lme'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glance.graph_lme_+3A_x">x</code></td>
<td>
<p>A <code>graph_lme</code> object.</p>
</td></tr>
<tr><td><code id="glance.graph_lme_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tidyr.html#topic+reexports">tidyr::tibble()</a></code> with exactly one row and columns:
</p>

<ul>
<li> <p><code>nobs</code> Number of observations used.
</p>
</li>
<li> <p><code>sigma</code> the square root of the estimated residual variance
</p>
</li>
<li> <p><code>logLik</code> The log-likelihood of the model.
</p>
</li>
<li> <p><code>AIC</code> Akaike's Information Criterion for the model.
</p>
</li>
<li> <p><code>BIC</code> Bayesian Information Criterion for the model.
</p>
</li>
<li> <p><code>deviance</code> Deviance of the model.
</p>
</li>
<li> <p><code>df.residual</code> Residual degrees of freedom.
</p>
</li>
<li> <p><code>model.type</code> Type of latent model fitted.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+augment.graph_lme">augment.graph_lme</a>
</p>

<hr>
<h2 id='graph_bru_process_data'>Prepare data frames or data lists to be used with 'inlabru' in metric
graphs</h2><span id='topic+graph_bru_process_data'></span>

<h3>Description</h3>

<p>Prepare data frames or data lists to be used with 'inlabru' in metric
graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_bru_process_data(
  data,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  loc = "loc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_bru_process_data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction.</p>
</td></tr>
<tr><td><code id="graph_bru_process_data_+3A_edge_number">edge_number</code></td>
<td>
<p>Name of the variable that contains the edge number, the
default is <code>edge_number</code>.</p>
</td></tr>
<tr><td><code id="graph_bru_process_data_+3A_distance_on_edge">distance_on_edge</code></td>
<td>
<p>Name of the variable that contains the distance on
edge, the default is <code>distance_on_edge</code>.</p>
</td></tr>
<tr><td><code id="graph_bru_process_data_+3A_loc">loc</code></td>
<td>
<p>character. Name of the locations to be used in 'inlabru' component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the processed data to be used in a user-friendly
manner by 'inlabru'.
</p>

<hr>
<h2 id='graph_components'>Connected components of metric graph</h2><span id='topic+graph_components'></span>

<h3>Description</h3>

<p>Class representing connected components of a metric graph.
</p>


<h3>Details</h3>

<p>A list of <code>metric_graph</code> objects (representing the different
connected components in the full graph) created from vertex and edge matrices,
or from an sp::SpatialLines object where each line is representing and edge.
For more details, see the vignette:
<code>vignette("metric_graph", package = "MetricGraph")</code>
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> for creating metric graph components.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>graphs</code></dt><dd><p>List of the graphs representing the connected components.</p>
</dd>
<dt><code>n</code></dt><dd><p>The number of graphs.</p>
</dd>
<dt><code>sizes</code></dt><dd><p>Number of vertices for each of the graphs.</p>
</dd>
<dt><code>lengths</code></dt><dd><p>Total edge lengths for each of the graphs.
Create metric graphs for connected components</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-graph_components-new"><code>graph_components$new()</code></a>
</p>
</li>
<li> <p><a href="#method-graph_components-get_largest"><code>graph_components$get_largest()</code></a>
</p>
</li>
<li> <p><a href="#method-graph_components-plot"><code>graph_components$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-graph_components-clone"><code>graph_components$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-graph_components-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>graph_components$new(
  edges = NULL,
  V = NULL,
  E = NULL,
  by_length = TRUE,
  edge_weights = NULL,
  ...,
  lines = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edges</code></dt><dd><p>A list containing coordinates as <code style="white-space: pre;">&#8288;m x 2&#8288;</code> matrices (that is, of <code>matrix</code> type) or m x 2 data frames (<code>data.frame</code> type) of sequence of points connected by straightlines. Alternatively, you can also prove an object of type <code>SpatialLinesDataFrame</code> or <code>SpatialLines</code> (from <code>sp</code> package) or <code>MULTILINESTRING</code> (from <code>sf</code> package).</p>
</dd>
<dt><code>V</code></dt><dd><p>n x 2 matrix with Euclidean coordinates of the n vertices.</p>
</dd>
<dt><code>E</code></dt><dd><p>m x 2 matrix where each row represents an edge.</p>
</dd>
<dt><code>by_length</code></dt><dd><p>Sort the components by total edge length? If <code>FALSE</code>,
the components are sorted by the number of vertices.</p>
</dd>
<dt><code>edge_weights</code></dt><dd><p>Either a number, a numerical vector with length given by the number of edges, providing the edge weights, or a <code>data.frame</code> with the number of rows being equal to the number of edges, where</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments used when specifying the graphs</p>
</dd>
<dt><code>lines</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>edges</code> instead.</p>
</dd>
<dt><code>vertex_unit</code></dt><dd><p>The unit in which the vertices are specified. The options are 'degree' (the great circle distance in km), 'km', 'm' and 'miles'. The default is <code>NULL</code>, which means no unit. However, if you set <code>length_unit</code>, you need to set <code>vertex_unit</code>.</p>
</dd>
<dt><code>length_unit</code></dt><dd><p>The unit in which the lengths will be computed. The options are 'km', 'm' and 'miles'. The default is <code>vertex_unit</code>. Observe that if <code>vertex_unit</code> is <code>NULL</code>, <code>length_unit</code> can only be <code>NULL</code>.
If <code>vertex_unit</code> is 'degree', then the default value for <code>length_unit</code> is 'km'.</p>
</dd>
<dt><code>longlat</code></dt><dd><p>If TRUE, then it is assumed that the coordinates are given.
in Longitude/Latitude and that distances should be computed in meters. It takes precedence over
<code>vertex_unit</code> and <code>length_unit</code>, and is equivalent to <code>vertex_unit = 'degree'</code> and <code>length_unit = 'm'</code>.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>Vertices that are closer than this number are merged when
constructing the graph (default = 1e-10). If <code>longlat = TRUE</code>, the
tolerance is given in km.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>graph_components</code> object.
</p>


<hr>
<a id="method-graph_components-get_largest"></a>



<h4>Method <code>get_largest()</code></h4>

<p>Returns the largest component in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>graph_components$get_largest()</pre></div>



<h5>Returns</h5>

<p>A <code>metric_graph</code> object.
</p>


<hr>
<a id="method-graph_components-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plots all components.
</p>


<h5>Usage</h5>

<div class="r"><pre>graph_components$plot(edge_colors = NULL, vertex_colors = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edge_colors</code></dt><dd><p>A 3 x nc matrix with RGB values for the edge colors to
be used when plotting each graph.</p>
</dd>
<dt><code>vertex_colors</code></dt><dd><p>A 3 x nc matrix with RGB values for the edge colors to
be used when plotting each graph.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for plotting the individual graphs.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>ggplot</code> object.
</p>


<hr>
<a id="method-graph_components-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>graph_components$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
edge1 &lt;- rbind(c(0, 0), c(1, 0))
edge2 &lt;- rbind(c(1, 0), c(2, 0))
edge3 &lt;- rbind(c(1, 1), c(2, 1))
edges &lt;- list(edge1, edge2, edge3)

graphs &lt;- graph_components$new(edges)
graphs$plot()
</code></pre>

<hr>
<h2 id='graph_data_spde'>Data extraction for 'spde' models</h2><span id='topic+graph_data_spde'></span>

<h3>Description</h3>

<p>Extracts data from metric graphs to be used by 'INLA' and 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_data_spde(
  graph_spde,
  name = "field",
  repl = NULL,
  repl_col = NULL,
  group = NULL,
  group_col = NULL,
  likelihood_col = NULL,
  resp_col = NULL,
  covariates = NULL,
  only_pred = FALSE,
  loc_name = NULL,
  tibble = FALSE,
  drop_na = FALSE,
  drop_all_na = TRUE,
  loc = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_data_spde_+3A_graph_spde">graph_spde</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> object built with the
<code>graph_spde()</code> function.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_name">name</code></td>
<td>
<p>A character string with the base name of the effect.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, one
can set <code>repl</code> to <code>NULL</code>. If one wants all replicates,
then one sets to <code>repl</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_repl_col">repl_col</code></td>
<td>
<p>Column containing the replicates. If the replicate is the internal group variable, set the replicates
to &quot;.group&quot;. If not replicates, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_group">group</code></td>
<td>
<p>Which groups? If there is no groups, one
can set <code>group</code> to <code>NULL</code>. If one wants all groups,
then one sets to <code>group</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_group_col">group_col</code></td>
<td>
<p>Which &quot;column&quot; of the data contains the group variable?</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_likelihood_col">likelihood_col</code></td>
<td>
<p>If only a single likelihood, this variable should be <code>NULL</code>. In case of multiple likelihoods, which column contains the variable indicating the number of the likelihood to be considered?</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_resp_col">resp_col</code></td>
<td>
<p>If only a single likelihood, this variable should be <code>NULL</code>. In case of multiple likelihoods, column containing the response variable.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_covariates">covariates</code></td>
<td>
<p>Vector containing the column names of the covariates. If no covariates, then it should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_only_pred">only_pred</code></td>
<td>
<p>Should only return the <code>data.frame</code> to the prediction data?</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_loc_name">loc_name</code></td>
<td>
<p>Character with the name of the location variable to be used in
'inlabru' prediction.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_tibble">tibble</code></td>
<td>
<p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_drop_na">drop_na</code></td>
<td>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_drop_all_na">drop_all_na</code></td>
<td>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>. This option is turned to <code>FALSE</code> if <code>only_pred</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="graph_data_spde_+3A_loc">loc</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>loc_name</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'INLA' and 'inlabru' friendly list with the data.
</p>

<hr>
<h2 id='graph_lgcp'>Simulation of log-Gaussian Cox processes driven by Whittle-Matérn
fields on metric graphs</h2><span id='topic+graph_lgcp'></span>

<h3>Description</h3>

<p>Simulation of log-Gaussian Cox processes driven by Whittle-Matérn
fields on metric graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_lgcp(n = 1, intercept = 0, sigma, range, alpha, graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_lgcp_+3A_n">n</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="graph_lgcp_+3A_intercept">intercept</code></td>
<td>
<p>Mean value of the Gaussian process.</p>
</td></tr>
<tr><td><code id="graph_lgcp_+3A_sigma">sigma</code></td>
<td>
<p>Parameter for marginal standard deviations.</p>
</td></tr>
<tr><td><code id="graph_lgcp_+3A_range">range</code></td>
<td>
<p>Parameter for practical correlation range.</p>
</td></tr>
<tr><td><code id="graph_lgcp_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (1 or 2).</p>
</td></tr>
<tr><td><code id="graph_lgcp_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with Gaussian process sample and simulated points.
</p>

<hr>
<h2 id='graph_lme'>Metric graph linear mixed effects models</h2><span id='topic+graph_lme'></span>

<h3>Description</h3>

<p>Fitting linear mixed effects model in metric graphs. The random effects can be
Gaussian Whittle-Matern fields, discrete Gaussian Markov random fields based
on the graph Laplacian, as well as Gaussian random fields with isotropic
covariance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_lme(
  formula,
  graph,
  model = list(type = "linearModel"),
  which_repl = NULL,
  optim_method = "L-BFGS-B",
  possible_methods = "L-BFGS-B",
  model_options = list(),
  BC = 1,
  previous_fit = NULL,
  fix_coeff = FALSE,
  parallel = FALSE,
  n_cores = parallel::detectCores() - 1,
  optim_controls = list(),
  improve_hessian = FALSE,
  hessian_args = list(),
  check_euclidean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_lme_+3A_formula">formula</code></td>
<td>
<p>Formula object describing the relation between the response
variables and the fixed effects.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_model">model</code></td>
<td>
<p>The random effects model that will be used (it also includes the
option of not having any random effects). It can be either a character,
whose options are 'lm', for linear models without random effects; 'WM1' and
'WM2' for Whittle-Matern models with <code class="reqn">\alpha</code>=1 and 2, with exact
precision matrices, respectively; 'WM' for Whittle-Matern models where one
also estimates the smoothness parameter via finite-element method; 'isoExp'
for a model with isotropic exponential covariance; 'GL1' and 'GL2' for a
SPDE model based on graph Laplacian with <code class="reqn">\alpha</code> = 1 and 2, respectively.
'WMD1' is the directed Whittle-Matern with  <code class="reqn">\alpha</code>=1.
There is also the option to provide it as a list containing the elements
<code>type</code>, which can be <code>linearModel</code>, <code>WhittleMatern</code>, <code>graphLaplacian</code> or <code>isoCov</code>.
<code>linearModel</code> corresponds to a linear model without random effects.
For <code>WhittleMatern</code> models, that is, if the list contains <code>type = 'WhittleMatern'</code>,
one can choose between a finite element approximation of the precision matrix
by adding <code>fem = TRUE</code> to the list, or to use the exact precision matrix
(by setting <code>fem = FALSE</code>). If <code>fem</code> is <code>FALSE</code>, there is also the parameter
<code>alpha</code>, to determine the order of the SPDE, which is either 1 or 2. If <code>fem</code>
is <code>FALSE</code> and <code>alpha</code> is not specified, then the default value of <code>alpha=1</code>
will be used. If <code>fem</code> is <code>TRUE</code> and one does not specify <code>alpha</code>, it will be
estimated from the data. However, if one wants to have <code>alpha</code> fixed to some
value, the user can specify either <code>alpha</code> or <code>nu</code> in the list. See the
vignettes for examples. Finally, for type 'WhittleMatern', there is an optional
argument, <code>rspde_order</code>, that chooses the order of the rational approximation.
By default <code>rspde_order</code> is 2.
Finally, if one wants to fit a nonstationary model, then <code>fem</code> necessarily
needs to be <code>TRUE</code>, and one needs to also supply the matrices <code>B.tau</code>
and <code>B.kappa</code> or <code>B.range</code> and <code>B.sigma</code>.
For <code>graph-Laplacian</code> models, the list must also contain a parameter <code>alpha</code>
(which is 1 by default). For <code>isoCov</code> models, the list must
contain a parameter <code>cov_function</code>, containing the covariance function.
The function accepts a string input for the following covariance functions:
'exp_covariance', 'WM1', 'WM2', 'GL1', 'GL2'. For another covariance function,
the function itself must be provided as the <code>cov_function</code> argument. The
default is 'exp_covariance', the exponential covariance. We also have
covariance-based versions of the Whittle-Matern and graph Laplacian models,
however they are much slower, they are the following (string) values for
'cov_function': 'alpha1' and 'alpha2' for Whittle-Matern fields, and 'GL1'
and 'GL2' for graph Laplacian models. Finally, for <code>Whittle-Matern</code> models,
there is an additional parameter <code>version</code>, which can be either 1 or 2, to
tell which version of the likelihood should be used. Version is 1 by default.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Vector or list containing which replicates to consider in
the model. If <code>NULL</code> all replicates will be considered.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_optim_method">optim_method</code></td>
<td>
<p>The method to be used with <code>optim</code> function.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_possible_methods">possible_methods</code></td>
<td>
<p>Which methods to try in case the optimization fails or the hessian is not positive definite. The options are 'Nelder-Mead', 'L-BFGS-B', 'BFGS', 'CG' and 'SANN'. By default only 'L-BFGS-B' is considered.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_model_options">model_options</code></td>
<td>
<p>A list containing additional options to be used in the model. Currently, it is possible to fix parameters during the estimation or change the starting values of the parameters. The general structure of the elements of the list is <code>fix_parname</code> and <code>start_parname</code>, where <code>parname</code> stands for the name of the parameter. If <code>fix_parname</code> is not <code>NULL</code>, then the model with be fitted with the <code>parname</code> being fixed at the value that was passed. If <code>start_parname</code> is not <code>NULL</code>, the model will be fitted using the value passed as starting value for <code>parname</code>. the For 'WM' models, the possible elements of the list are: <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_nu</code>, <code>start_nu</code>, <code>fix_sigma</code>, <code>start_sigma</code>, <code>fix_range</code>, <code>start_range</code>. Alternatively, one can use <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_nu</code>, <code>start_nu</code>, <code>fix_tau</code>, <code>start_tau</code>, <code>fix_kappa</code>, <code>start_kappa</code>. For 'WM1', 'WM2', 'isoExp', 'GL1' and 'GL2' models, the possible elements of the list are <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_sigma</code>, <code>start_sigma</code>, <code>fix_range</code>, <code>start_range</code>. Alternatively, one can use <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_tau</code>, <code>start_tau</code>, <code>fix_kappa</code>, <code>start_kappa</code>. For 'isoCov' models, the possible values are <code>fix_sigma_e</code>, <code>start_sigma_e</code>, <code>fix_par_vec</code>, <code>start_par_vec</code>. Observe that contrary to the other models, for 'isoCov' models, both <code>fix_par_vec</code> and <code>start_par_vec</code> should be given as vectors of the size of the dimension of the vector for the input of the covariance function passed to the 'isoCov' model. Furthermore, for 'isoCov' models, <code>fix_par_vec</code> is a logical vector, indicating which parameters to be fixed, and the values will be kept fixed to the values given to <code>start_par_vec</code>, one can also use <code>fix_sigma_e</code> and <code>start_sigma_e</code> for controlling the std. deviation of the measurement error.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_bc">BC</code></td>
<td>
<p>For <code>WhittleMatern</code> models, decides which boundary condition to use
(0,1). Here, 0 is Neumann boundary conditions and 1 specifies stationary boundary
conditions.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_previous_fit">previous_fit</code></td>
<td>
<p>An object of class <code>graph_lme</code>. Use the fitted coefficients as starting values.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_fix_coeff">fix_coeff</code></td>
<td>
<p>If using a previous fit, should all coefficients be fixed at the starting values?</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_parallel">parallel</code></td>
<td>
<p>logical. Indicating whether to use <code>optimParallel()</code> or not.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to be used if parallel is true.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_optim_controls">optim_controls</code></td>
<td>
<p>Additional controls to be passed to <code>optim()</code> or <code>optimParallel()</code>.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_improve_hessian">improve_hessian</code></td>
<td>
<p>Should a more precise estimate of the hessian be obtained?
Turning on might increase the overall time.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_hessian_args">hessian_args</code></td>
<td>
<p>List of controls to be used if <code>improve_hessian</code> is <code>TRUE</code>.
The list can contain the arguments to be passed to the <code>method.args</code> argument
in the <code>hessian</code> function. See the help of the <code>hessian</code> function in 'numDeriv'
package for details. Observet that it only accepts the &quot;Richardson&quot; method for
now, the method &quot;complex&quot; is not supported.</p>
</td></tr>
<tr><td><code id="graph_lme_+3A_check_euclidean">check_euclidean</code></td>
<td>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the fitted model.
</p>

<hr>
<h2 id='graph_spde'>'INLA' implementation of Whittle-Matérn fields for metric graphs</h2><span id='topic+graph_spde'></span>

<h3>Description</h3>

<p>This function creates an 'INLA' object that can be used
in 'INLA' or 'inlabru' to fit Whittle-Matérn fields on metric graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_spde(
  graph_object,
  alpha = 1,
  directional = FALSE,
  stationary_endpoints = "all",
  parameterization = c("matern", "spde"),
  start_range = NULL,
  prior_range = NULL,
  start_kappa = NULL,
  prior_kappa = NULL,
  start_sigma = NULL,
  prior_sigma = NULL,
  start_tau = NULL,
  prior_tau = NULL,
  factor_start_range = 0.3,
  type_start_range_bbox = "diag",
  shared_lib = "detect",
  debug = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_spde_+3A_graph_object">graph_object</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_alpha">alpha</code></td>
<td>
<p>The order of the SPDE.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_directional">directional</code></td>
<td>
<p>Should a directional model be used? Currently only implemented for <code>alpha=1</code>.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_stationary_endpoints">stationary_endpoints</code></td>
<td>
<p>Which vertices of degree 1 should contain
stationary boundary conditions? Set to &quot;all&quot; for all vertices of degree 1, &quot;none&quot; for none of the vertices of degree 1, or pass the indices of the vertices of degree 1 for which stationary conditions are desired.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_parameterization">parameterization</code></td>
<td>
<p>Which parameterization to be used? The options are
'matern' (sigma and range) and 'spde' (sigma and kappa).</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_start_range">start_range</code></td>
<td>
<p>Starting value for range parameter.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_prior_range">prior_range</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of the range parameter on
the log scale. Will not be used if prior.kappa is non-null.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_start_kappa">start_kappa</code></td>
<td>
<p>Starting value for kappa.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_prior_kappa">prior_kappa</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of kappa on the log scale.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_start_sigma">start_sigma</code></td>
<td>
<p>Starting value for sigma.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of sigma on the log scale.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_start_tau">start_tau</code></td>
<td>
<p>Starting value for tau.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_prior_tau">prior_tau</code></td>
<td>
<p>a <code>list</code> containing the elements <code>meanlog</code> and
<code>sdlog</code>, that is, the mean and standard deviation of tau on the log scale.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_factor_start_range">factor_start_range</code></td>
<td>
<p>Factor to multiply the max/min dimension of the bounding box to obtain a starting value for range. Default is 0.3.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_type_start_range_bbox">type_start_range_bbox</code></td>
<td>
<p>Which dimension from the bounding box should be used? The options are 'diag', the default, 'max' and 'min'.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_shared_lib">shared_lib</code></td>
<td>
<p>Which shared lib to use for the cgeneric implementation?
If &quot;detect&quot;, it will check if the shared lib exists locally, in which case it will
use it. Otherwise it will use 'INLA's shared library.
If 'INLA', it will use the shared lib from 'INLA's installation. If 'rSPDE', then
it will use the local installation of the rSPDE package (does not work if your installation is from CRAN).
Otherwise, you can directly supply the path of the .so (or .dll) file.</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_debug">debug</code></td>
<td>
<p>Should debug be displayed?</p>
</td></tr>
<tr><td><code id="graph_spde_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity. 0 is silent, 1 prints basic information, 2 prints more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to construct a Matern SPDE model on a metric graph.
The latent field <code class="reqn">u</code> is the solution of the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa^2 - \Delta)^\alpha u = \sigma W,</code>
</p>
<p> where <code class="reqn">W</code> is Gaussian
white noise on the metric graph. This model implements exactly
the cases in which <code class="reqn">\alpha = 1</code> or <code class="reqn">\alpha = 2</code>. For a finite
element approximation for general <code class="reqn">\alpha</code> we refer the reader to the
'rSPDE' package and to the Whittle&ndash;Matérn fields with general smoothness vignette.
</p>
<p>We also have the alternative parameterization <code class="reqn">\rho = \frac{\sqrt{8(\alpha-0.5)}}{\kappa}</code>,
which can be interpreted as a range parameter.
</p>
<p>Let <code class="reqn">\kappa_0</code> and <code class="reqn">\sigma_0</code> be the starting values for <code class="reqn">\kappa</code> and
<code class="reqn">\sigma</code>, we write <code class="reqn">\sigma = \exp\{\theta_1\}</code> and <code class="reqn">\kappa = \exp\{\theta_2\}</code>.
We assume priors on <code class="reqn">\theta_1</code> and <code class="reqn">\theta_2</code> to be normally distributed
with mean, respectively, <code class="reqn">\log(\sigma_0)</code> and <code class="reqn">\log(\kappa_0)</code>, and variance 10.
Similarly, if we let <code class="reqn">\rho_0</code> be the starting value for <code class="reqn">\rho</code>, then
we write <code class="reqn">\rho = \exp\{\theta_2\}</code> and assume a normal prior for <code class="reqn">\theta_2</code>,
with mean <code class="reqn">\log(\rho_0)</code> and variance 10.
</p>


<h3>Value</h3>

<p>An 'INLA' object.
</p>

<hr>
<h2 id='graph_spde_basis'>Deprecated - Observation/prediction matrices for 'SPDE' models</h2><span id='topic+graph_spde_basis'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for metric graph models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_spde_basis(graph_spde, repl = NULL, drop_na = FALSE, drop_all_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_spde_basis_+3A_graph_spde">graph_spde</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> object built with the
<code>graph_spde()</code> function.</p>
</td></tr>
<tr><td><code id="graph_spde_basis_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, or to
use all replicates, one can set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="graph_spde_basis_+3A_drop_na">drop_na</code></td>
<td>
<p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="graph_spde_basis_+3A_drop_all_na">drop_all_na</code></td>
<td>
<p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The observation matrix.
</p>

<hr>
<h2 id='graph_spde_make_A'>Deprecated - Observation/prediction matrices for 'SPDE' models</h2><span id='topic+graph_spde_make_A'></span>

<h3>Description</h3>

<p>Constructs observation/prediction weight matrices
for metric graph models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_spde_make_A(graph_spde, repl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_spde_make_A_+3A_graph_spde">graph_spde</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> object built with the
<code>graph_spde()</code> function.</p>
</td></tr>
<tr><td><code id="graph_spde_make_A_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, or to
use all replicates, one can set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The observation matrix.
</p>

<hr>
<h2 id='graph_starting_values'>Starting values for random field models on metric graphs</h2><span id='topic+graph_starting_values'></span>

<h3>Description</h3>

<p>Computes appropriate starting values for optimization of Gaussian random
field models on metric graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_starting_values(
  graph,
  model = c("alpha1", "alpha2", "isoExp", "GL1", "GL2"),
  data = TRUE,
  data_name = NULL,
  range_par = FALSE,
  nu = FALSE,
  manual_data = NULL,
  like_format = FALSE,
  log_scale = FALSE,
  model_options = list(),
  rec_tau = TRUE,
  factor_start_range = 0.3,
  type_start_range_bbox = "diag"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_starting_values_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_model">model</code></td>
<td>
<p>Type of model, &quot;alpha1&quot;, &quot;alpha2&quot;, &quot;isoExp&quot;, &quot;GL1&quot;, and &quot;GL2&quot;
are supported.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_data">data</code></td>
<td>
<p>Should the data be used to obtain improved starting values?</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_data_name">data_name</code></td>
<td>
<p>The name of the response variable in <code>graph$data</code>.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_range_par">range_par</code></td>
<td>
<p>Should an initial value for range parameter be returned
instead of for kappa?</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_nu">nu</code></td>
<td>
<p>Should an initial value for nu be returned?</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_manual_data">manual_data</code></td>
<td>
<p>A vector (or matrix) of response variables.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_like_format">like_format</code></td>
<td>
<p>Should the starting values be returned with sigma.e as the
last element? This is the format for the likelihood constructor from the
'rSPDE' package.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_log_scale">log_scale</code></td>
<td>
<p>Should the initial values be returned in log scale?</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_model_options">model_options</code></td>
<td>
<p>List object containing the model options.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_rec_tau">rec_tau</code></td>
<td>
<p>Should a starting value for the reciprocal of tau be given?</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_factor_start_range">factor_start_range</code></td>
<td>
<p>Factor to multiply the max/min/diagonal dimension of the bounding box to obtain a starting value for range. Default is 0.5.</p>
</td></tr>
<tr><td><code id="graph_starting_values_+3A_type_start_range_bbox">type_start_range_bbox</code></td>
<td>
<p>Which dimension from the bounding box should be used? The options are 'diag', the default, 'max' and 'min'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, <code>c(start_sigma_e, start_sigma, start_kappa)</code>
</p>

<hr>
<h2 id='linnet.to.graph'>Convert a <code>linnet</code> object to a metric graph object</h2><span id='topic+linnet.to.graph'></span>

<h3>Description</h3>

<p>This function converts a <code>linnet</code> object (from the <code>spatstat</code> package) into a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linnet.to.graph(linnet.object, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linnet.to.graph_+3A_linnet.object">linnet.object</code></td>
<td>
<p>A <code>linnet</code> object to be converted.</p>
</td></tr>
<tr><td><code id="linnet.to.graph_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system of the graph.</p>
</td></tr>
<tr><td><code id="linnet.to.graph_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code>metric_graph</code> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A metric graph object with edges defined by the network.
</p>

<hr>
<h2 id='logo_lines'>Create lines for package name</h2><span id='topic+logo_lines'></span>

<h3>Description</h3>

<p>Create lines for package name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logo_lines()
</code></pre>


<h3>Value</h3>

<p><code>SpatialLines</code> object with package name.
</p>

<hr>
<h2 id='make_Q_euler'>Space-time precision operator Euler discretization</h2><span id='topic+make_Q_euler'></span>

<h3>Description</h3>

<p>The precision matrix for all vertices for space-time field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q_euler(graph, t, kappa, rho, gamma, alpha, beta, sigma, theta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_Q_euler_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_t">t</code></td>
<td>
<p>Vector of time points.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_kappa">kappa</code></td>
<td>
<p>Spatial range parameter.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_rho">rho</code></td>
<td>
<p>Drift parameter.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_gamma">gamma</code></td>
<td>
<p>Temporal range parameter.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (integer) for spatial operator.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter (integer) for Q-Wiener process.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_sigma">sigma</code></td>
<td>
<p>Variance parameter.</p>
</td></tr>
<tr><td><code id="make_Q_euler_+3A_theta">theta</code></td>
<td>
<p>Parameter theta for the Euler scheme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision matrix.
</p>

<hr>
<h2 id='make_Q_spacetime'>Space-time precision operator discretization</h2><span id='topic+make_Q_spacetime'></span>

<h3>Description</h3>

<p>The precision matrix for all vertices for space-time field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Q_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_Q_spacetime_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_t">t</code></td>
<td>
<p>Vector of time points.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_kappa">kappa</code></td>
<td>
<p>Spatial range parameter.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_rho">rho</code></td>
<td>
<p>Drift parameter.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_gamma">gamma</code></td>
<td>
<p>Temporal range parameter.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (integer) for spatial operator.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter (integer) for Q-Wiener process.</p>
</td></tr>
<tr><td><code id="make_Q_spacetime_+3A_sigma">sigma</code></td>
<td>
<p>Variance parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision matrix.
</p>

<hr>
<h2 id='metric_graph'>Metric graph</h2><span id='topic+metric_graph'></span>

<h3>Description</h3>

<p>Class representing a general metric graph.
</p>


<h3>Details</h3>

<p>A graph object created from vertex and edge matrices, or from an
<code>sp::SpatialLines</code> object where each line is representing and edge. For more details,
see the vignette:
<code>vignette("metric_graph", package = "MetricGraph")</code>
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> for creating metric graphs.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>V</code></dt><dd><p>Matrix with positions in Euclidean space of the vertices of the
graph.</p>
</dd>
<dt><code>nV</code></dt><dd><p>The number of vertices.</p>
</dd>
<dt><code>E</code></dt><dd><p>Matrix with the edges of the graph, where each row represents an
edge, <code>E[i,1]</code> is the vertex at the start of the ith edge and <code>E[i,2]</code> is
the vertex at the end of the edge.</p>
</dd>
<dt><code>nE</code></dt><dd><p>The number of edges.</p>
</dd>
<dt><code>edge_lengths</code></dt><dd><p>Vector with the lengths of the edges in the graph.</p>
</dd>
<dt><code>C</code></dt><dd><p>Constraint matrix used to set Kirchhoff constraints.</p>
</dd>
<dt><code>CoB</code></dt><dd><p>Change-of-basis object used for Kirchhoff constraints.</p>
</dd>
<dt><code>PtV</code></dt><dd><p>Vector with the indices of the vertices which are observation
locations.</p>
</dd>
<dt><code>mesh</code></dt><dd><p>Mesh object used for plotting.</p>
</dd>
<dt><code>edges</code></dt><dd><p>The coordinates of the edges in the graph.</p>
</dd>
<dt><code>DirectionalWeightFunction_in</code></dt><dd><p>Function for inwards weights in directional models</p>
</dd>
<dt><code>DirectionalWeightFunction_out</code></dt><dd><p>Function for outwards weights in directional models</p>
</dd>
<dt><code>vertices</code></dt><dd><p>The coordinates of the vertices in the graph, along with several attributes.</p>
</dd>
<dt><code>geo_dist</code></dt><dd><p>Geodesic distances between the vertices in the graph.</p>
</dd>
<dt><code>res_dist</code></dt><dd><p>Resistance distances between the observation locations.</p>
</dd>
<dt><code>Laplacian</code></dt><dd><p>The weighted graph Laplacian of the vertices in the
graph. The weights are given by the edge lengths.</p>
</dd>
<dt><code>characteristics</code></dt><dd><p>List with various characteristics of the graph.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-metric_graph-new"><code>metric_graph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-remove_small_circles"><code>metric_graph$remove_small_circles()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_edges"><code>metric_graph$get_edges()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_bounding_box"><code>metric_graph$get_bounding_box()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_vertices"><code>metric_graph$get_vertices()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-export"><code>metric_graph$export()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-leaflet"><code>metric_graph$leaflet()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mapview"><code>metric_graph$mapview()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-set_edge_weights"><code>metric_graph$set_edge_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_edge_weights"><code>metric_graph$get_edge_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_vertices_incomp_dir"><code>metric_graph$get_vertices_incomp_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-summary"><code>metric_graph$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-print"><code>metric_graph$print()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_characteristics"><code>metric_graph$compute_characteristics()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-check_euclidean"><code>metric_graph$check_euclidean()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-check_distance_consistency"><code>metric_graph$check_distance_consistency()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist"><code>metric_graph$compute_geodist()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist_PtE"><code>metric_graph$compute_geodist_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_geodist_mesh"><code>metric_graph$compute_geodist_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist"><code>metric_graph$compute_resdist()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist_PtE"><code>metric_graph$compute_resdist_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_degrees"><code>metric_graph$get_degrees()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_PtE_edges"><code>metric_graph$compute_PtE_edges()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_resdist_mesh"><code>metric_graph$compute_resdist_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_laplacian"><code>metric_graph$compute_laplacian()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-prune_vertices"><code>metric_graph$prune_vertices()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-set_manual_edge_lengths"><code>metric_graph$set_manual_edge_lengths()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_groups"><code>metric_graph$get_groups()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_PtE"><code>metric_graph$get_PtE()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_edge_lengths"><code>metric_graph$get_edge_lengths()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_locations"><code>metric_graph$get_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-observation_to_vertex"><code>metric_graph$observation_to_vertex()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-edgeweight_to_data"><code>metric_graph$edgeweight_to_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_mesh_locations"><code>metric_graph$get_mesh_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-clear_observations"><code>metric_graph$clear_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-process_data"><code>metric_graph$process_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-add_observations"><code>metric_graph$add_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mutate_weights"><code>metric_graph$mutate_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-select_weights"><code>metric_graph$select_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-filter_weights"><code>metric_graph$filter_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-summarise_weights"><code>metric_graph$summarise_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-drop_na_weights"><code>metric_graph$drop_na_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mutate"><code>metric_graph$mutate()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-drop_na"><code>metric_graph$drop_na()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-select"><code>metric_graph$select()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-filter"><code>metric_graph$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-summarise"><code>metric_graph$summarise()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_data"><code>metric_graph$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-setDirectionalWeightFunction"><code>metric_graph$setDirectionalWeightFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-buildDirectionalConstraints"><code>metric_graph$buildDirectionalConstraints()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-buildC"><code>metric_graph$buildC()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-build_mesh"><code>metric_graph$build_mesh()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-compute_fem"><code>metric_graph$compute_fem()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-mesh_A"><code>metric_graph$mesh_A()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-fem_basis"><code>metric_graph$fem_basis()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-VtEfirst"><code>metric_graph$VtEfirst()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot"><code>metric_graph$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_connections"><code>metric_graph$plot_connections()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-is_tree"><code>metric_graph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_function"><code>metric_graph$plot_function()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-plot_movie"><code>metric_graph$plot_movie()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-add_mesh_observations"><code>metric_graph$add_mesh_observations()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-get_initial_graph"><code>metric_graph$get_initial_graph()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-coordinates"><code>metric_graph$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-metric_graph-clone"><code>metric_graph$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-metric_graph-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>metric_graph</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$new(
  edges = NULL,
  V = NULL,
  E = NULL,
  vertex_unit = NULL,
  length_unit = NULL,
  edge_weights = NULL,
  kirchhoff_weights = NULL,
  directional_weights = NULL,
  longlat = NULL,
  crs = NULL,
  proj4string = NULL,
  which_longlat = "sp",
  include_obs = NULL,
  include_edge_weights = NULL,
  project = FALSE,
  project_data = FALSE,
  which_projection = "Winkel tripel",
  manual_edge_lengths = NULL,
  perform_merges = NULL,
  approx_edge_PtE = TRUE,
  tolerance = list(vertex_vertex = 0.001, vertex_edge = 0.001, edge_edge = 0),
  check_connected = TRUE,
  remove_deg2 = FALSE,
  merge_close_vertices = NULL,
  factor_merge_close_vertices = 1,
  remove_circles = FALSE,
  auto_remove_point_edges = TRUE,
  verbose = 1,
  add_obs_options = list(return_removed = FALSE, verbose = verbose),
  lines = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edges</code></dt><dd><p>A list containing coordinates as <code style="white-space: pre;">&#8288;m x 2&#8288;</code> matrices (that is, of <code>matrix</code> type) or m x 2 data frames (<code>data.frame</code> type) of sequence of points connected by straightlines. Alternatively, you can also prove an object of type <code>SSN</code>, <code>osmdata_sp</code>, <code>osmdata_sf</code>, <code>SpatialLinesDataFrame</code> or <code>SpatialLines</code> (from <code>sp</code> package) or <code>MULTILINESTRING</code> (from <code>sf</code> package).</p>
</dd>
<dt><code>V</code></dt><dd><p>n x 2 matrix with Euclidean coordinates of the n vertices. If non-NULL, no merges will be performed.</p>
</dd>
<dt><code>E</code></dt><dd><p>m x 2 matrix where each row represents one of the m edges. If non-NULL, no merges will be performed.</p>
</dd>
<dt><code>vertex_unit</code></dt><dd><p>The unit in which the vertices are specified. The options are 'degree' (the great circle distance in km), 'km', 'm' and 'miles'. The default is <code>NULL</code>, which means no unit. However, if you set <code>length_unit</code>, you need to set <code>vertex_unit</code>.</p>
</dd>
<dt><code>length_unit</code></dt><dd><p>The unit in which the lengths will be computed. The options are 'km', 'm' and 'miles'. The default, when longlat is <code>TRUE</code>, or an <code>sf</code> or <code>sp</code> objects are provided, is 'km'.</p>
</dd>
<dt><code>edge_weights</code></dt><dd><p>Either a number, a numerical vector with length given by the number of edges, providing the edge weights, or a <code>data.frame</code> with the number of rows being equal to the number of edges, where
each row gives a vector of weights to its corresponding edge. Can be changed by using the <code>set_edge_weights()</code> method.</p>
</dd>
<dt><code>kirchhoff_weights</code></dt><dd><p>If non-null, the name (or number) of the column of <code>edge_weights</code> that contain the Kirchhoff weights. Must be equal to 1 (or <code>TRUE</code>) in case <code>edge_weights</code> is a single number and those are the Kirchhoff weights.</p>
</dd>
<dt><code>directional_weights</code></dt><dd><p>If non-null, the name (or number) of the column of <code>edge_weights</code> that contain the directional weights. The default is the first column of the edge weights.</p>
</dd>
<dt><code>longlat</code></dt><dd><p>There are three options: <code>NULL</code>, <code>TRUE</code> or <code>FALSE</code>. If <code>NULL</code> (the default option), the <code>edges</code> argument will be checked to see if there is a CRS or proj4string available, if so, <code>longlat</code> will be set to <code>TRUE</code>, otherwise, it will be set to <code>FALSE</code>. If <code>TRUE</code>, then it is assumed that the coordinates are given.
in Longitude/Latitude and that distances should be computed in meters. If <code>TRUE</code> it takes precedence over
<code>vertex_unit</code> and <code>length_unit</code>, and is equivalent to <code>vertex_unit = 'degree'</code> and <code>length_unit = 'm'</code>.</p>
</dd>
<dt><code>crs</code></dt><dd><p>Coordinate reference system to be used in case <code>longlat</code> is set to <code>TRUE</code> and <code>which_longlat</code> is <code>sf</code>. Object of class crs. The default choice, if the <code>edges</code> object does not have CRS nor proj4string, is <code>sf::st_crs(4326)</code>.</p>
</dd>
<dt><code>proj4string</code></dt><dd><p>Projection string of class CRS-class to be used in case <code>longlat</code> is set to <code>TRUE</code> and <code>which_longlat</code> is <code>sp</code>. The default choice, if the <code>edges</code> object does not have CRS nor proj4string, is <code>sp::CRS("+proj=longlat +datum=WGS84")</code>.</p>
</dd>
<dt><code>which_longlat</code></dt><dd><p>Compute the distance using which package? The options are <code>sp</code> and <code>sf</code>. The default is <code>sp</code>.</p>
</dd>
<dt><code>include_obs</code></dt><dd><p>If the object is of class <code>SSN</code>, should the observations be added? If <code>NULL</code> and the edges are of class <code>SSN</code>, the data will be automatically added. If <code>FALSE</code>, the data will not be added. Alternatively, one can set this argument to the numbers or names of the columns of the observations to be added as observations.</p>
</dd>
<dt><code>include_edge_weights</code></dt><dd><p>If the object is of class <code>SSN</code>, <code>osmdata_sp</code>, <code>osmdata_sf</code>, <code>SpatialLinesDataFrame</code>, <code>MULTILINESTRING</code>, <code>LINESTRING</code>, <code>sfc_LINESTRING</code>, <code>sfc_MULTILINESTRING</code>, should the edge data (if any) be added as edge weights? If <code>NULL</code>, the edge data will be added as edge weights, if <code>FALSE</code> they will not be added. Alternatively, one can set this argument to the numbers or names of the columns of the edge data to be added as edge weights.</p>
</dd>
<dt><code>project</code></dt><dd><p>If <code>longlat</code> is <code>TRUE</code> should a projection be used to compute the distances to be used for the tolerances (see <code>tolerance</code> below)? The default is <code>FALSE</code>. When <code>TRUE</code>, the construction of the graph is faster.</p>
</dd>
<dt><code>project_data</code></dt><dd><p>If <code>longlat</code> is <code>TRUE</code> should the vertices be project to planar coordinates? The default is <code>FALSE</code>. When <code>TRUE</code>, the construction of the graph is faster.</p>
</dd>
<dt><code>which_projection</code></dt><dd><p>Which projection should be used in case <code>project</code> is <code>TRUE</code>? The options are <code>Robinson</code>, <code style="white-space: pre;">&#8288;Winkel tripel&#8288;</code> or a proj4string. The default is <code style="white-space: pre;">&#8288;Winkel tripel&#8288;</code>.</p>
</dd>
<dt><code>manual_edge_lengths</code></dt><dd><p>If non-NULL, a vector containing the edges lengths, and all the quantities related to edge lengths will be computed in terms of these. If merges are performed, it is likely that the merges will override the manual edge lengths. In such a case, to provide manual edge lengths, one should either set the <code>perform_merges</code> argument to <code>FALSE</code> or use the <code>set_manual_edge_lengths()</code> method.</p>
</dd>
<dt><code>perform_merges</code></dt><dd><p>There are three options, <code>NULL</code>, <code>TRUE</code> or <code>FALSE</code>. The default option is <code>NULL</code>. If <code>NULL</code>, it will be set to <code>FALSE</code> unless 'edges', 'V' and 'E' are <code>NULL</code>, in which case it will be set to <code>TRUE</code>. If FALSE, this will take priority over the other arguments, and no merges (except the optional <code>merge_close_vertices</code> below) will be performed. Note that the merge on the additional <code>merge_close_vertices</code> might still be performed, if it is set to <code>TRUE</code>.</p>
</dd>
<dt><code>approx_edge_PtE</code></dt><dd><p>Should the relative positions on the edges be approximated? The default is <code>TRUE</code>. If <code>FALSE</code>, the speed can be considerably slower, especially for large metric graphs.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>List that provides tolerances during the construction of the graph:
</p>

<ul>
<li> <p><code>vertex_vertex</code> Vertices that are closer than this number are merged (default = 1e-7).
</p>
</li>
<li> <p><code>vertex_edge</code> If a vertex at the end of one edge is closer than this
number to another edge, this vertex is connected to that edge
(default = 1e-7). Previously <code>vertex_line</code>, which is now deprecated.
</p>
</li>
<li> <p><code>edge_edge</code> If two edges at some point are closer than this number, a new
vertex is added at that point and the two edges are connected (default = 0).
</p>
</li>
<li> <p><code>vertex_line</code>, Deprecated. Use <code>vertex_edge</code> instead.
</p>
</li>
<li> <p><code>line_line</code>, Deprecated. Use <code>edge_edge</code> instead.
</p>
</li></ul>

<p>In case <code>longlat = TRUE</code>, the tolerances are given in <code>length_unit</code>.</p>
</dd>
<dt><code>check_connected</code></dt><dd><p>If <code>TRUE</code>, it is checked whether the graph is
connected and a warning is given if this is not the case.</p>
</dd>
<dt><code>remove_deg2</code></dt><dd><p>Set to <code>TRUE</code> to remove all vertices of degree 2 in the
initialization. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>merge_close_vertices</code></dt><dd><p>Should an additional step to merge close vertices be done? The options are <code>NULL</code> (the default), <code>TRUE</code> or <code>FALSE</code>. If <code>NULL</code>, it will be determined automatically. If <code>TRUE</code> this step will be performed even if <code>perfom_merges</code> is set to <code>FALSE</code>.</p>
</dd>
<dt><code>factor_merge_close_vertices</code></dt><dd><p>Which factor to be multiplied by tolerance <code>vertex_vertex</code> when merging close vertices at the additional step?</p>
</dd>
<dt><code>remove_circles</code></dt><dd><p>All circlular edges with a length smaller than this number
are removed. If <code>TRUE</code>, the <code>vertex_vertex</code> tolerance will be used. If <code>FALSE</code>, no circles will be removed.</p>
</dd>
<dt><code>auto_remove_point_edges</code></dt><dd><p>Should edges of length zero, that is, edges that are actually points, be automatically removed?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of graph creation. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>add_obs_options</code></dt><dd><p>List containing additional options to be passed to the <code>add_observations()</code> method when adding observations from <code>SSN</code> data?</p>
</dd>
<dt><code>lines</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>edges</code> instead.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A graph object can be initialized in two ways. The first method
is to specify V and E. In this case, all edges are assumed to be straight
lines. The second option is to specify the graph via the <code>lines</code> input.
In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be
viewed as a vertex.
</p>



<h5>Returns</h5>

<p>A <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-remove_small_circles"></a>



<h4>Method <code>remove_small_circles()</code></h4>

<p>Sets the edge weights
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$remove_small_circles(tolerance, verbose = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tolerance</code></dt><dd><p>Tolerance at which circles with length less than this will be removed.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of graph creation. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-get_edges"></a>



<h4>Method <code>get_edges()</code></h4>

<p>Exports the edges of the MetricGraph object as an <code>sf</code> or <code>sp</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_edges(format = c("sf", "sp", "list"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>The format for the exported object. The options are <code>sf</code> (default), <code>sp</code> and <code>list</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>For <code>format == "sf"</code>, the function returns an <code>sf</code> object of <code>LINESTRING</code> geometries, where the associated data frame includes edge weights.
</p>
<p>For <code>format == "sp"</code>, the function returns a <code>SpatialLinesDataFrame</code> where the data frame includes edge weights.
</p>


<hr>
<a id="method-metric_graph-get_bounding_box"></a>



<h4>Method <code>get_bounding_box()</code></h4>

<p>Bounding box of the metric graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_bounding_box(format = "sf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>If the metric graph has a coordinate reference system, the format for the exported object. The options are <code>sf</code> (default), <code>sp</code> and <code>matrix</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A bounding box of the metric graph
</p>


<hr>
<a id="method-metric_graph-get_vertices"></a>



<h4>Method <code>get_vertices()</code></h4>

<p>Exports the vertices of the MetricGraph object as an <code>sf</code>, <code>sp</code> or as a matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_vertices(format = c("sf", "sp", "list"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>The format for the exported object. The options are <code>sf</code> (default), <code>sp</code> and <code>matrix</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>For <code>which_format == "sf"</code>, the function returns an <code>sf</code> object of <code>POINT</code> geometries.
</p>
<p>For <code>which_format == "sp"</code>, the function returns a <code>SpatialPointsDataFrame</code> object.
</p>


<hr>
<a id="method-metric_graph-export"></a>



<h4>Method <code>export()</code></h4>

<p>Exports the MetricGraph object as an <code>sf</code> or <code>sp</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$export(format = "sf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>The format for the exported object. The options are <code>sf</code> (default) and <code>sp</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns a list with three elements: <code>edges</code>, <code>vertices</code>, and <code>data</code>.
</p>
<p>For <code>format == "sf"</code>, <code>edges</code> is an <code>sf</code> object of <code>LINESTRING</code> geometries with edge weights, and <code>vertices</code> and <code>data</code> are <code>sf</code> objects with <code>POINT</code> geometries.
</p>
<p>For <code>format == "sp"</code>, <code>edges</code> is a <code>SpatialLinesDataFrame</code> with edge weights, and <code>vertices</code> and <code>data</code> are <code>SpatialPointsDataFrame</code>.
</p>


<hr>
<a id="method-metric_graph-leaflet"></a>



<h4>Method <code>leaflet()</code></h4>

<p>Return the metric graph as a <code>leaflet::leaflet()</code> object to be built upon.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$leaflet(
  width = NULL,
  height = NULL,
  padding = 0,
  options = leafletOptions(),
  elementId = NULL,
  sizingPolicy = leafletSizingPolicy(padding = padding)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>width</code></dt><dd><p>the width of the map</p>
</dd>
<dt><code>height</code></dt><dd><p>the height of the map</p>
</dd>
<dt><code>padding</code></dt><dd><p>the padding of the map</p>
</dd>
<dt><code>options</code></dt><dd><p>the map options</p>
</dd>
<dt><code>elementId</code></dt><dd><p>Use an explicit element ID for the widget (rather than an automatically generated one).</p>
</dd>
<dt><code>sizingPolicy</code></dt><dd><p>htmlwidgets sizing policy object. Defaults to <code>leafletSizingPolicy()</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-metric_graph-mapview"></a>



<h4>Method <code>mapview()</code></h4>

<p>Returns a <code>mapview::mapview()</code> object of the metric graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mapview(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments to be passed to <code>mapview::mapview()</code>. The <code>x</code> argument of mapview, containing the metric graph is already passed internally.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-metric_graph-set_edge_weights"></a>



<h4>Method <code>set_edge_weights()</code></h4>

<p>Sets the edge weights
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$set_edge_weights(
  weights = NULL,
  kirchhoff_weights = NULL,
  directional_weights = NULL,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weights</code></dt><dd><p>Either a number, a numerical vector with length given by the number of edges, providing the edge weights, or a <code>data.frame</code> with the number of rows being equal to the number of edges, where
each row gives a vector of weights to its corresponding edge.</p>
</dd>
<dt><code>kirchhoff_weights</code></dt><dd><p>If non-null, the name (or number) of the column of <code>weights</code> that contain the Kirchhoff weights. Must be equal to 1 (or <code>TRUE</code>) in case <code>weights</code> is a single number and those are the Kirchhoff weights.</p>
</dd>
<dt><code>directional_weights</code></dt><dd><p>If non-null, the name (or number) of the column of <code>weights</code> that contain the directional weights.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-get_edge_weights"></a>



<h4>Method <code>get_edge_weights()</code></h4>

<p>Gets the edge weights
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_edge_weights(
  data.frame = FALSE,
  format = c("tibble", "sf", "sp", "list"),
  tibble = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data.frame</code></dt><dd><p>If the edge weights are given as vectors, should the result be returned as a data.frame?</p>
</dd>
<dt><code>format</code></dt><dd><p>Which format should the data be returned? The options are <code>tibble</code> for <code>tidyr::tibble</code>, <code>sf</code> for <code>POINT</code>, <code>sp</code> for <code>SpatialPointsDataFrame</code> and <code>list</code> for the internal list format.</p>
</dd>
<dt><code>tibble</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>format</code> instead.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector or <code>data.frame</code> containing the edge weights.
</p>


<hr>
<a id="method-metric_graph-get_vertices_incomp_dir"></a>



<h4>Method <code>get_vertices_incomp_dir()</code></h4>

<p>Gets vertices with incompatible directions
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_vertices_incomp_dir()</pre></div>



<h5>Returns</h5>

<p>A vector containing the vertices with incompatible directions.
</p>


<hr>
<a id="method-metric_graph-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Prints a summary of various informations of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$summary(
  messages = FALSE,
  compute_characteristics = NULL,
  check_euclidean = NULL,
  check_distance_consistency = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>messages</code></dt><dd><p>Should message explaining how to build the results be given for missing quantities?</p>
</dd>
<dt><code>compute_characteristics</code></dt><dd><p>Should the characteristics of the graph be computed? If <code>NULL</code> it will be determined based on the size of the graph.</p>
</dd>
<dt><code>check_euclidean</code></dt><dd><p>Check if the graph has Euclidean edges? If <code>NULL</code> it will be determined based on the size of the graph.</p>
</dd>
<dt><code>check_distance_consistency</code></dt><dd><p>Check the distance consistency assumption? If <code>NULL</code> it will be determined based on the size of the graph.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints various characteristics of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$print()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-compute_characteristics"></a>



<h4>Method <code>compute_characteristics()</code></h4>

<p>Computes various characteristics of the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_characteristics(check_euclidean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_euclidean</code></dt><dd><p>Also check if the graph has Euclidean edges? This essentially means that the distance consistency check will also be perfomed. If the graph does not have Euclidean edges due to another reason rather than the distance consistency, then it will already be indicated that the graph does not have Euclidean edges.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The computed characteristics
are stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-check_euclidean"></a>



<h4>Method <code>check_euclidean()</code></h4>

<p>Check if the graph has Euclidean edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$check_euclidean()</pre></div>



<h5>Returns</h5>

<p>Returns <code>TRUE</code> if the graph has Euclidean edges, or <code>FALSE</code> otherwise.
The result is stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
The result is displayed when the graph is printed.
</p>


<hr>
<a id="method-metric_graph-check_distance_consistency"></a>



<h4>Method <code>check_distance_consistency()</code></h4>

<p>Checks distance consistency of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$check_distance_consistency()</pre></div>



<h5>Returns</h5>

<p>No return value.
The result is stored in the <code>characteristics</code> element of the <code>metric_graph</code> object.
The result is displayed when the graph is printed.
</p>


<hr>
<a id="method-metric_graph-compute_geodist"></a>



<h4>Method <code>compute_geodist()</code></h4>

<p>Computes shortest path distances between the vertices in the
graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist(
  full = FALSE,
  obs = TRUE,
  group = NULL,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt><dd><p>Should the geodesic distances be computed for all
the available locations? If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt><dd><p>Should the geodesic distances be computed at the observation
locations?</p>
</dd>
<dt><code>group</code></dt><dd><p>Vector or list containing which groups to compute the distance
for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the computation of the geodesic distances. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The computed geodesic
distances are stored in the <code>geo_dist</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_geodist_PtE"></a>



<h4>Method <code>compute_geodist_PtE()</code></h4>

<p>Computes shortest path distances between the vertices in the
graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist_PtE(
  PtE,
  normalized = TRUE,
  include_vertices = TRUE,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt><dd><p>Points to compute the metric for.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>are the locations in PtE in normalized distance?</p>
</dd>
<dt><code>include_vertices</code></dt><dd><p>Should the original vertices be included in the
distance matrix?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the computation of the geodesic distances. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix containing the geodesic distances.
</p>


<hr>
<a id="method-metric_graph-compute_geodist_mesh"></a>



<h4>Method <code>compute_geodist_mesh()</code></h4>

<p>Computes shortest path distances between the vertices in the
mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_geodist_mesh()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
on the mesh are stored in <code>mesh$geo_dist</code> in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_resdist"></a>



<h4>Method <code>compute_resdist()</code></h4>

<p>Computes the resistance distance between the observation
locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist(
  full = FALSE,
  obs = TRUE,
  group = NULL,
  check_euclidean = FALSE,
  include_vertices = FALSE,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt><dd><p>Should the resistance distances be computed for all
the available locations. If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt><dd><p>Should the resistance distances be computed at the observation
locations?</p>
</dd>
<dt><code>group</code></dt><dd><p>Vector or list containing which groups to compute the distance
for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
<dt><code>check_euclidean</code></dt><dd><p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</dd>
<dt><code>include_vertices</code></dt><dd><p>Should the vertices of the graph be also included in the resulting matrix when using <code>FULL=TRUE</code>?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the computation of the resistance distances. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
are stored in the <code>res_dist</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_resdist_PtE"></a>



<h4>Method <code>compute_resdist_PtE()</code></h4>

<p>Computes the resistance distance between the observation
locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist_PtE(
  PtE,
  normalized = TRUE,
  include_vertices = FALSE,
  check_euclidean = FALSE,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt><dd><p>Points to compute the metric for.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>Are the locations in PtE in normalized distance?</p>
</dd>
<dt><code>include_vertices</code></dt><dd><p>Should the original vertices be included in the
Laplacian matrix?</p>
</dd>
<dt><code>check_euclidean</code></dt><dd><p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the computation of the resistance distances. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix containing the resistance distances.
</p>


<hr>
<a id="method-metric_graph-get_degrees"></a>



<h4>Method <code>get_degrees()</code></h4>

<p>Returns the degrees of the vertices in the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_degrees(which = "degree")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>which</code></dt><dd><p>If &quot;degree&quot;, returns the degree of the vertex. If &quot;indegree&quot;, returns the indegree,
and if &quot;outdegree&quot;, it returns the outdegree.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector containing the degrees of the vertices.
</p>


<hr>
<a id="method-metric_graph-compute_PtE_edges"></a>



<h4>Method <code>compute_PtE_edges()</code></h4>

<p>Computes the relative positions of the coordinates of the edges and save it as an attribute to each edge. This improves the quality of plots obtained by the <code>plot_function()</code> method, however it might be costly to compute.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_PtE_edges(approx = TRUE, verbose = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>approx</code></dt><dd><p>Should the computation of the relative positions be approximate? Default is <code>TRUE</code>. If <code>FALSE</code>, the speed can be considerably slower, especially for large metric graphs.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Level of verbosity, 0, 1 or 2. The default is 0.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value, called for its side effects.
</p>


<hr>
<a id="method-metric_graph-compute_resdist_mesh"></a>



<h4>Method <code>compute_resdist_mesh()</code></h4>

<p>Computes the resistance metric between the vertices in the
mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_resdist_mesh()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The geodesic distances
on the mesh are stored in the <code>mesh$res_dist</code> element in the <code>metric_graph</code>
object.
</p>


<hr>
<a id="method-metric_graph-compute_laplacian"></a>



<h4>Method <code>compute_laplacian()</code></h4>

<p>Computes the weigthed graph Laplacian for the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_laplacian(
  full = FALSE,
  obs = TRUE,
  group = NULL,
  verbose = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>full</code></dt><dd><p>Should the resistance distances be computed for all
the available locations. If <code>FALSE</code>, it will be computed
separately for the locations of each group.</p>
</dd>
<dt><code>obs</code></dt><dd><p>Should the resistance distances be computed at the observation
locations? It will only compute for locations in which there is at least one observations that is not NA.</p>
</dd>
<dt><code>group</code></dt><dd><p>Vector or list containing which groups to compute the
Laplacian for. If <code>NULL</code>, it will be computed for all groups.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the computation of the Laplacian. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No reutrn value. Called for its side effects. The Laplacian is stored
in the <code>Laplacian</code> element in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-prune_vertices"></a>



<h4>Method <code>prune_vertices()</code></h4>

<p>Removes vertices of degree 2 from the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$prune_vertices(
  check_weights = TRUE,
  check_circles = TRUE,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_weights</code></dt><dd><p>If <code>TRUE</code> will only prune edges with different weights.</p>
</dd>
<dt><code>check_circles</code></dt><dd><p>If <code>TRUE</code> will not prune a vertex such that the resulting edge is a circle.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of pruning. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Vertices of degree 2 are removed as long as the corresponding edges that
would be merged are compatible in terms of direction.
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-set_manual_edge_lengths"></a>



<h4>Method <code>set_manual_edge_lengths()</code></h4>

<p>Gets the groups from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$set_manual_edge_lengths(edge_lengths, unit = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edge_lengths</code></dt><dd><p>edge lengths to be set to the metric graph edges.</p>
</dd>
<dt><code>unit</code></dt><dd><p>set or override the edge lengths unit.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>does not return anything. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-get_groups"></a>



<h4>Method <code>get_groups()</code></h4>

<p>Gets the groups from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_groups(get_cols = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>get_cols</code></dt><dd><p>Should the names of the columns that created the group variable be returned?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector containing the available groups in the internal data.
</p>


<hr>
<a id="method-metric_graph-get_PtE"></a>



<h4>Method <code>get_PtE()</code></h4>

<p>Gets PtE from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_PtE()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>For which group, should the PtE be returned? <code>NULL</code> means that all PtEs available will be returned.</p>
</dd>
<dt><code>include_group</code></dt><dd><p>Should the group be included as a column? If <code>TRUE</code>, the PtEs for each group will be concatenated, otherwise a single matrix containing the unique PtEs will be returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with two columns, where the first column contains the edge
number and the second column contains the distance on edge of the
observation locations.
</p>


<hr>
<a id="method-metric_graph-get_edge_lengths"></a>



<h4>Method <code>get_edge_lengths()</code></h4>

<p>Gets the edge lengths with the corresponding unit.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_edge_lengths(unit = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unit</code></dt><dd><p>If non-NULL, changes from <code>length_unit</code> from the graph construction to <code>unit</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a vector with the length unit (if the graph was constructed with a length unit).
</p>


<hr>
<a id="method-metric_graph-get_locations"></a>



<h4>Method <code>get_locations()</code></h4>

<p>Gets the spatial locations from the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_locations()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> object with observation locations. If <code>longlat = TRUE</code>, the column names are lon and lat, otherwise the column names are x and y.
</p>


<hr>
<a id="method-metric_graph-observation_to_vertex"></a>



<h4>Method <code>observation_to_vertex()</code></h4>

<p>Adds observation locations as vertices in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$observation_to_vertex(
  mesh_warning = TRUE,
  verbose = 0,
  tolerance = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mesh_warning</code></dt><dd><p>Display a warning if the graph structure change and the metric graph has a mesh object.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the steps when adding observations. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Not used anymore</p>
</dd>
<dt><code>share_weights</code></dt><dd><p>Should the same weight be shared among the split edges? If <code>FALSE</code>, the weights will be removed, and a common weight given by 1 will be given.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-edgeweight_to_data"></a>



<h4>Method <code>edgeweight_to_data()</code></h4>

<p>Turns edge weights into data on the metric graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$edgeweight_to_data(
  loc = NULL,
  mesh = FALSE,
  data_loc = FALSE,
  weight_col = NULL,
  add = TRUE,
  data_coords = c("PtE", "spatial"),
  normalized = FALSE,
  tibble = FALSE,
  format = c("tibble", "sf", "sp", "list"),
  verbose = 1,
  suppress_warnings = FALSE,
  return = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>loc</code></dt><dd><p>A <code>matrix</code> or <code>data.frame</code> with two columns containing the locations to generate the data from the edge weights. If <code>data_coords</code> is 'spatial', the first column must be the x-coordinate of the data, and the second column must be the y-coordinate. If <code>data_coords</code> is 'PtE', the first column must be the edge number and the second column must be the distance on edge.</p>
</dd>
<dt><code>mesh</code></dt><dd><p>Should the data be generated to the mesh locations? In this case, the <code>loc</code> argument will be ignored. Observe that the metric graph must have a mesh built for one to use this option. CAUTION: To add edgeweight to data to both the data locations and mesh locations, please, add at the data locations first, then to mesh locations.</p>
</dd>
<dt><code>data_loc</code></dt><dd><p>Should the data be generated to the data locations? In this case, the <code>loc</code> argument will be ignored. Observe that the metric graph must have data for one to use this option. CAUTION: To add edgeweight to data to both the data locations and mesh locations, please, add at the data locations first, then to mesh locations.</p>
</dd>
<dt><code>weight_col</code></dt><dd><p>Which columns of the edge weights should be turned into data? If <code>NULL</code>, all columns will be turned into data.</p>
</dd>
<dt><code>add</code></dt><dd><p>Should the data generated be added to the metric graph internal data?</p>
</dd>
<dt><code>data_coords</code></dt><dd><p>To be used only if <code>mesh</code> is <code>FALSE</code>. It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>tibble</code></dt><dd><p>Should the data be returned in a <code>tibble</code> format?</p>
</dd>
<dt><code>format</code></dt><dd><p>If <code>return</code> is <code>TRUE</code>, the format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the steps when adding observations. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>suppress_warnings</code></dt><dd><p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>return</code></dt><dd><p>Should the data be returned? If <code>return_removed</code> is <code>TRUE</code>, only the removed locations will be return (if there is any).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-metric_graph-get_mesh_locations"></a>



<h4>Method <code>get_mesh_locations()</code></h4>

<p>Returns a list or a matrix with the mesh locations.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_mesh_locations(
  bru = FALSE,
  loc = c(".edge_number", ".distance_on_edge"),
  loc_name = NULL,
  normalized = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bru</code></dt><dd><p>Should an 'inlabru'-friendly list be returned?</p>
</dd>
<dt><code>loc</code></dt><dd><p>If <code>bru</code> is set to <code>TRUE</code>, the column names of the location variables.
The default name is <code>c('.edge_number', '.distance_on_edge')</code>.</p>
</dd>
<dt><code>loc_name</code></dt><dd><p>The name of the location variables. Not needed for <code>rSPDE</code> models.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>If TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list or a matrix containing the mesh locations.
</p>


<hr>
<a id="method-metric_graph-clear_observations"></a>



<h4>Method <code>clear_observations()</code></h4>

<p>Clear all observations from the <code>metric_graph</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$clear_observations()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-process_data"></a>



<h4>Method <code>process_data()</code></h4>

<p>Process data to the metric graph data format.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$process_data(
  data = NULL,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "spatial"),
  group = NULL,
  group_sep = ".",
  normalized = FALSE,
  format = c("tibble", "sf", "sp", "list"),
  duplicated_strategy = "closest",
  include_distance_to_graph = TRUE,
  only_return_removed = FALSE,
  tolerance = max(self$edge_lengths)/2,
  verbose = FALSE,
  suppress_warnings = FALSE,
  Spoints = lifecycle::deprecated(),
  tibble = lifecycle::deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> or named list containing the observations. In
case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If <code>data</code> is not <code>NULL</code>,
it takes priority over any eventual data in <code>Spoints</code>.</p>
</dd>
<dt><code>edge_number</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
&quot;edge_number&quot; will be chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code>.</p>
</dd>
<dt><code>distance_on_edge</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
&quot;distance_on_edge&quot; will be chosen.  Will not be used if <code>Spoints</code> is not
<code>NULL</code>.</p>
</dd>
<dt><code>coord_x</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that contains
the x coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>coord_y</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that contains
the y coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>data_coords</code></dt><dd><p>It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>. The option <code>euclidean</code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>spatial</code> instead.</p>
</dd>
<dt><code>group</code></dt><dd><p>Vector. If the data is grouped (for example measured at different time
points), this argument specifies the columns (or entries on the list) in
which the group variables are stored. It will be stored as a single column <code>.group</code> with the combined entries.</p>
</dd>
<dt><code>group_sep</code></dt><dd><p>separator character for creating the new group variable when grouping two or more variables.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>format</code></dt><dd><p>Which format should the data be returned? The options are <code>tibble</code> for <code>tidyr::tibble</code>, <code>sf</code> for <code>POINT</code>, <code>sp</code> for <code>SpatialPointsDataFrame</code> and <code>list</code> for the internal list format.</p>
</dd>
<dt><code>duplicated_strategy</code></dt><dd><p>Which strategy to handle observations on the same location on the metric graph (that is, if there are two or more observations projected at the same location).
The options are 'closest' and 'jitter'. If 'closest', only the closest observation will be used. If 'jitter', a small perturbation will be performed on the projected observation location. The default is 'closest'.</p>
</dd>
<dt><code>include_distance_to_graph</code></dt><dd><p>When <code>data_coord</code> is 'spatial', should the distance of the observations to the graph be included as a column?</p>
</dd>
<dt><code>only_return_removed</code></dt><dd><p>Should the removed data (if it exists) when using 'closest' <code>duplicated_strategy</code> be returned instead of the processed data?</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>Parameter to control a warning when adding observations.
If the distance of some location and the closest point on the graph is
greater than the tolerance, the function will display a warning.
This helps detecting mistakes on the input locations when adding new data.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, report steps and times.</p>
</dd>
<dt><code>suppress_warnings</code></dt><dd><p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>Spoints</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>data</code> instead.</p>
</dd>
<dt><code>tibble</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>format</code> instead.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-add_observations"></a>



<h4>Method <code>add_observations()</code></h4>

<p>Add observations to the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$add_observations(
  data = NULL,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "spatial"),
  group = NULL,
  group_sep = ".",
  normalized = FALSE,
  clear_obs = FALSE,
  tibble = FALSE,
  tolerance = max(self$edge_lengths)/2,
  duplicated_strategy = "closest",
  include_distance_to_graph = TRUE,
  return_removed = TRUE,
  tolerance_merge = 0,
  merge_strategy = "merge",
  verbose = 1,
  suppress_warnings = FALSE,
  Spoints = lifecycle::deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> or named list containing the observations. In
case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. <code>data</code> can also be an <code>sf</code> object, a
<code>SpatialPointsDataFrame</code> object or an <code>SSN</code> object.
in which case <code>data_coords</code> will automatically be spatial, and there is no need to specify the <code>coord_x</code> or <code>coord_y</code> arguments.</p>
</dd>
<dt><code>edge_number</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
&quot;edge_number&quot; will be chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code>.</p>
</dd>
<dt><code>distance_on_edge</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that
contains the edge numbers. If not supplied, the column with name
&quot;distance_on_edge&quot; will be chosen.  Will not be used if <code>Spoints</code> is not
<code>NULL</code>.</p>
</dd>
<dt><code>coord_x</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that contains
the x coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>coord_y</code></dt><dd><p>Column (or entry on the list) of the <code>data</code> that contains
the y coordinate. If not supplied, the column with name &quot;coord_x&quot; will be
chosen. Will not be used if <code>Spoints</code> is not <code>NULL</code> or if <code>data_coords</code> is
<code>PtE</code>.</p>
</dd>
<dt><code>data_coords</code></dt><dd><p>It decides which
coordinate system to use. If <code>PtE</code>, the user must provide <code>edge_number</code> and
<code>distance_on_edge</code>, otherwise if <code>spatial</code>, the user must provide
<code>coord_x</code> and <code>coord_y</code>. The option <code>euclidean</code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>spatial</code> instead.</p>
</dd>
<dt><code>group</code></dt><dd><p>Vector. If the data is grouped (for example measured at different time
points), this argument specifies the columns (or entries on the list) in
which the group variables are stored. It will be stored as a single column <code>.group</code> with the combined entries.</p>
</dd>
<dt><code>group_sep</code></dt><dd><p>separator character for creating the new group variable when grouping two or more variables.</p>
</dd>
<dt><code>normalized</code></dt><dd><p>if TRUE, then the distances in <code>distance_on_edge</code> are
assumed to be normalized to (0,1). Default FALSE.</p>
</dd>
<dt><code>clear_obs</code></dt><dd><p>Should the existing observations be removed before adding the data?</p>
</dd>
<dt><code>tibble</code></dt><dd><p>Should the data be returned as a <code>tidyr::tibble</code>?</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>Parameter to control a warning when adding observations.
If the distance of some location and the closest point on the graph is
greater than the tolerance, the function will display a warning.
This helps detecting mistakes on the input locations when adding new data.</p>
</dd>
<dt><code>duplicated_strategy</code></dt><dd><p>Which strategy to handle observations on the same location on the metric graph (that is, if there are two or more observations projected at the same location).
The options are 'closest' and 'jitter'. If 'closest', only the closest observation will be used. If 'jitter', a small perturbation will be performed on the projected observation location. The default is 'closest'.</p>
</dd>
<dt><code>include_distance_to_graph</code></dt><dd><p>When <code>data_coord</code> is 'spatial', should the distance of the observations to the graph be included as a column?</p>
</dd>
<dt><code>return_removed</code></dt><dd><p>Should the removed data (if it exists) due to being projected to the same place when using 'closest' <code>duplicated_strategy</code>, or due to some merge strategy, be returned?</p>
</dd>
<dt><code>tolerance_merge</code></dt><dd><p>tolerance (in edge_length units) for merging points that are very close and are on a common edge. By default, this tolerance is zero, meaning no merges will be performed.</p>
</dd>
<dt><code>merge_strategy</code></dt><dd><p>The strategies to handle observations that are within the tolerance. The options are <code>remove</code>, <code>merge</code>, <code>average</code>. The default is <code>merge</code>, in which one of the observations will be chosen, and the remaining will be used to try to fill all columns with non-NA values. The second strategy is <code>remove</code>, meaning that if two observations are within the tolerance one of them will be removed. Finally, <code>average</code> will take the average over the close observations for numerical variables, and will choose one non-NA for non-numerical variables.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print progress of the steps when adding observations. There are 3 levels of verbose, level 0, 1 and 2. In level 0, no messages are printed. In level 1, only messages regarding important steps are printed. Finally, in level 2, messages detailing all the steps are printed. The default is 1.</p>
</dd>
<dt><code>suppress_warnings</code></dt><dd><p>Suppress warnings related to duplicated observations?</p>
</dd>
<dt><code>Spoints</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>data</code> instead.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-mutate_weights"></a>



<h4>Method <code>mutate_weights()</code></h4>

<p>Use <code>dplyr::mutate</code> function on the internal edge weights object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mutate_weights(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::mutate()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::mutate()</code> on the internal edge weights object and return the result in the requested format.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code> or <code>sp</code> object containing the resulting data list after the mutate.
</p>


<hr>
<a id="method-metric_graph-select_weights"></a>



<h4>Method <code>select_weights()</code></h4>

<p>Use <code>dplyr::select</code> function on the internal edge weights object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$select_weights(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::select()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::select()</code> on the internal edge weights object and return the result in the requested format.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code> or <code>sp</code> object containing the resulting data list after the select.
</p>


<hr>
<a id="method-metric_graph-filter_weights"></a>



<h4>Method <code>filter_weights()</code></h4>

<p>Use <code>dplyr::filter</code> function on the internal edge weights object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$filter_weights(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::filter()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::filter()</code> on the internal edge weights object and return the result in the requested format.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code> or <code>sp</code> object containing the resulting data list after the filter.
</p>


<hr>
<a id="method-metric_graph-summarise_weights"></a>



<h4>Method <code>summarise_weights()</code></h4>

<p>Use <code>dplyr::summarise</code> function on the internal edge weights object grouped by the edge numbers.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$summarise_weights(
  ...,
  .groups = NULL,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::summarise()</code>.</p>
</dd>
<dt><code>.groups</code></dt><dd><p>A vector of strings containing the names of the columns to be grouped, when computing the summaries. The default is <code>NULL</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::summarise()</code> on the internal edge weights object and return the result in the requested format.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code> or <code>sp</code> object containing the resulting data list after the summarise.
</p>


<hr>
<a id="method-metric_graph-drop_na_weights"></a>



<h4>Method <code>drop_na_weights()</code></h4>

<p>Use <code>tidyr::drop_na()</code> function on the internal edge weights object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$drop_na_weights(..., format = "tibble")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>tidyr::drop_na()</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>tidyr::drop_na()</code> within the internal edge weights object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code>, or <code>sp</code> object containing the resulting data list after the drop_na.
</p>


<hr>
<a id="method-metric_graph-mutate"></a>



<h4>Method <code>mutate()</code></h4>

<p>Use <code>dplyr::mutate</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mutate(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::mutate()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::mutate()</code> within the internal metric graph data object and return the result in the requested format.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code>, <code>sf</code>, or <code>sp</code> object containing the resulting data list after the mutate.
</p>


<hr>
<a id="method-metric_graph-drop_na"></a>



<h4>Method <code>drop_na()</code></h4>

<p>Use <code>tidyr::drop_na()</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$drop_na(..., format = "tibble")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>tidyr::drop_na()</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::drop_na()</code> within the internal metric graph data object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the drop_na.
</p>


<hr>
<a id="method-metric_graph-select"></a>



<h4>Method <code>select()</code></h4>

<p>Use <code>dplyr::select</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$select(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::select()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::select()</code> within the internal metric graph data object. Observe that it is a bit different from directly using <code>dplyr::select()</code> since it does not allow to remove the internal positions that are needed for the metric_graph methods to work.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the selection.
</p>


<hr>
<a id="method-metric_graph-filter"></a>



<h4>Method <code>filter()</code></h4>

<p>Use <code>dplyr::filter</code> function on the internal metric graph data object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$filter(
  ...,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::filter()</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::filter()</code> within the internal metric graph data object.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the filter.
</p>


<hr>
<a id="method-metric_graph-summarise"></a>



<h4>Method <code>summarise()</code></h4>

<p>Use <code>dplyr::summarise</code> function on the internal metric graph data object grouped by the spatial locations and the internal group variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$summarise(
  ...,
  .include_graph_groups = FALSE,
  .groups = NULL,
  .drop_na = FALSE,
  .drop_all_na = TRUE,
  format = "tibble"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to be passed to <code>dplyr::summarise()</code>.</p>
</dd>
<dt><code>.include_graph_groups</code></dt><dd><p>Should the internal graph groups be included in the grouping variables? The default is <code>FALSE</code>. This means that, when summarising, the data will be grouped by the internal group variable together with the spatial locations.</p>
</dd>
<dt><code>.groups</code></dt><dd><p>A vector of strings containing the names of the columns to be additionally grouped, when computing the summaries. The default is <code>NULL</code>.</p>
</dd>
<dt><code>.drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>.drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>format</code></dt><dd><p>The format of the output: &quot;tibble&quot;, &quot;sf&quot;, or &quot;sp&quot;. Default is &quot;tibble&quot;.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A wrapper to use <code>dplyr::summarise()</code> within the internal metric graph data object grouped by manually inserted groups (optional), the internal group variable (optional) and the spatial locations. Observe that if the integral group variable was not used as a grouping variable for the summarise, a new column, called <code>.group</code>, will be added, with the same value 1 for all rows.
</p>



<h5>Returns</h5>

<p>A <code>tidyr::tibble</code> object containing the resulting data list after the summarise.
</p>


<hr>
<a id="method-metric_graph-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Return the internal data with the option to filter by groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_data(
  group = NULL,
  format = c("tibble", "sf", "sp", "list"),
  drop_na = FALSE,
  drop_all_na = TRUE,
  tibble = deprecated()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>A vector contaning which groups should be returned? The default is <code>NULL</code>, which gives the result for the all groups.</p>
</dd>
<dt><code>format</code></dt><dd><p>Which format should the data be returned? The options are <code>tibble</code> for <code>tidyr::tibble</code>, <code>sf</code> for <code>POINT</code>, <code>sp</code> for <code>SpatialPointsDataFrame</code> and <code>list</code> for the internal list format.</p>
</dd>
<dt><code>drop_na</code></dt><dd><p>Should the rows with at least one NA for one of the columns be removed? DEFAULT is <code>FALSE</code>.</p>
</dd>
<dt><code>drop_all_na</code></dt><dd><p>Should the rows with all variables being NA be removed? DEFAULT is <code>TRUE</code>.</p>
</dd>
<dt><code>tibble</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>format</code> instead.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-metric_graph-setDirectionalWeightFunction"></a>



<h4>Method <code>setDirectionalWeightFunction()</code></h4>

<p>Define the columns to be used for creating the directional vertex
weights. Also possible to supply user defined functions for input and output
to create ones own weights.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$setDirectionalWeightFunction(f_in = NULL, f_out = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f_in</code></dt><dd><p>functions for the input vertex (default <code>w/sum(w)</code>) uses the columns of name_column</p>
</dd>
<dt><code>f_out</code></dt><dd><p>functions for the output vertex (deafult <code>rep(-1,length(w))</code>) uses the columns of name_column</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For more details see paper (that does not exists yet).
</p>



<h5>Returns</h5>

<p>No return value.
</p>


<hr>
<a id="method-metric_graph-buildDirectionalConstraints"></a>



<h4>Method <code>buildDirectionalConstraints()</code></h4>

<p>Build directional ODE constraint matrix from edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$buildDirectionalConstraints(alpha = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>how many derivatives the processes has</p>
</dd>
<dt><code>weight</code></dt><dd><p>weighting for each vertex used in the constraint (E x 2)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Currently not implemented for circles (edges that start and end
in the same vertex)
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-buildC"></a>



<h4>Method <code>buildC()</code></h4>

<p>Build Kirchoff constraint matrix from edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$buildC(alpha = 2, edge_constraint = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>the type of constraint (currently only supports 2)</p>
</dd>
<dt><code>edge_constraint</code></dt><dd><p>if TRUE, add constraints on vertices of degree 1</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Currently not implemented for circles (edges that start and end
in the same vertex)
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-build_mesh"></a>



<h4>Method <code>build_mesh()</code></h4>

<p>Builds mesh object for graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$build_mesh(
  h = NULL,
  n = NULL,
  continuous = TRUE,
  continuous.outs = FALSE,
  continuous.deg2 = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>h</code></dt><dd><p>Maximum distance between mesh nodes (should be provided if n is
not provided).</p>
</dd>
<dt><code>n</code></dt><dd><p>Maximum number of nodes per edge (should be provided if h is not
provided).</p>
</dd>
<dt><code>continuous</code></dt><dd><p>If <code>TRUE</code> (default), the mesh contains only one node per vertex.
If <code>FALSE</code>, each vertex v is split into deg(v) disconnected nodes to allow
for the creation of discontinuities at the vertices.</p>
</dd>
<dt><code>continuous.outs</code></dt><dd><p>If <code>continuous = FALSE</code> and <code>continuous.outs = TRUE</code>, continuity is
assumed for the outgoing edges from each vertex.</p>
</dd>
<dt><code>continuous.deg2</code></dt><dd><p>If <code>TRUE</code>, continuity is assumed at degree 2 vertices.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The mesh is a list with the objects:
</p>

<ul>
<li> <p><code>PtE</code> The mesh locations excluding the original vertices;
</p>
</li>
<li> <p><code>V</code> The verties of the mesh;
</p>
</li>
<li> <p><code>E</code> The edges of the mesh;
</p>
</li>
<li> <p><code>n_e</code> The number of vertices in the mesh per original edge in the graph;
</p>
</li>
<li> <p><code>h_e</code> The mesh width per edge in the graph;
</p>
</li>
<li> <p><code>ind</code> The indices of the vertices in the mesh;
</p>
</li>
<li> <p><code>VtE</code> All mesh locations including the original vertices.
</p>
</li></ul>




<h5>Returns</h5>

<p>No return value. Called for its side effects. The mesh is stored in
the <code>mesh</code> element of the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-compute_fem"></a>



<h4>Method <code>compute_fem()</code></h4>

<p>Build mass and stiffness matrices for given mesh object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$compute_fem(petrov = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>petrov</code></dt><dd><p>Compute Petrov-Galerkin matrices? (default <code>FALSE</code>). These
are defined as <code class="reqn">Cpet_{ij} = &lt;\phi_i, \psi_j&gt;</code> and <code class="reqn">Gpet_{ij} = &lt;d\phi_i, \psi_j&gt;</code>,
where <code class="reqn">\psi_{i}</code> are piecewise constant basis functions on the edges of
the mesh.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The function builds: The matrix <code>C</code> which is the mass matrix with
elements <code class="reqn">C_{ij} = &lt;\phi_i, \phi_j&gt;</code>, the matrix <code>G</code> which is the stiffness
matrix with elements <code class="reqn">G_{ij} = &lt;d\phi_i, d\phi_j&gt;</code>, the matrix <code>B</code> with
elements <code class="reqn">B_{ij} = &lt;d\phi_i, \phi_j&gt;</code>, the matrix <code>D</code> with elements
<code class="reqn">D_{ij} = \sum_{v\in V}\phi_i(v)\phi_j(v)</code>, and the vector with weights
<code class="reqn">&lt;\phi_i, 1&gt;</code>.
</p>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The finite element
matrices <code>C</code>, <code>G</code> and <code>B</code> are stored in the <code>mesh</code> element in the
<code>metric_graph</code> object. If <code>petrov=TRUE</code>, the corresponding Petrov-Galerkin
matrices are stored in <code>Cpet</code> and <code>Gpet</code>.
</p>


<hr>
<a id="method-metric_graph-mesh_A"></a>



<h4>Method <code>mesh_A()</code></h4>

<p>Deprecated - Computes observation matrix for mesh.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code>metric_graph$fem_basis()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$mesh_A(PtE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt><dd><p>Locations given as (edge number in graph, normalized location on
edge)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For n locations and a mesh with m nodes, <code>A</code> is an n x m matrix with
elements <code class="reqn">A_{ij} = \phi_j(s_i)</code>.
</p>



<h5>Returns</h5>

<p>The observation matrix.
</p>


<hr>
<a id="method-metric_graph-fem_basis"></a>



<h4>Method <code>fem_basis()</code></h4>

<p>Computes observation matrix for mesh.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$fem_basis(PtE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt><dd><p>Locations given as (edge number in graph, normalized location on
edge)</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For n locations and a mesh with m nodes, <code>A</code> is an n x m matrix with
elements <code class="reqn">A_{ij} = \phi_j(s_i)</code>.
</p>



<h5>Returns</h5>

<p>The observation matrix.
</p>


<hr>
<a id="method-metric_graph-VtEfirst"></a>



<h4>Method <code>VtEfirst()</code></h4>

<p>Find one edge corresponding to each vertex.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$VtEfirst()</pre></div>



<h5>Returns</h5>

<p>A nV x 2 matrix the first element of the <code>i</code>th row is the edge
number corresponding to the <code>i</code>th vertex and the second value is 0
if the vertex is at the start of the edge and 1 if the vertex
is at the end of the edge.
</p>


<hr>
<a id="method-metric_graph-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plots the metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot(
  data = NULL,
  newdata = NULL,
  group = 1,
  type = c("ggplot", "plotly", "mapview"),
  interactive = FALSE,
  vertex_size = 3,
  vertex_color = "black",
  edge_width = 0.3,
  edge_color = "black",
  data_size = 1,
  support_width = 0.5,
  support_color = "gray",
  mesh = FALSE,
  X = NULL,
  X_loc = NULL,
  p = NULL,
  degree = FALSE,
  direction = FALSE,
  arrow_size = ggplot2::unit(0.25, "inches"),
  edge_weight = NULL,
  edge_width_weight = NULL,
  scale_color_main = ggplot2::scale_color_viridis_c(option = "D"),
  scale_color_weights = ggplot2::scale_color_viridis_c(option = "C"),
  scale_color_degree = ggplot2::scale_color_viridis_d(option = "D"),
  scale_color_weights_discrete = ggplot2::scale_color_viridis_d(option = "C"),
  scale_color_main_discrete = ggplot2::scale_color_viridis_d(option = "C"),
  add_new_scale_weights = TRUE,
  scale_color_mapview = viridis::viridis(100, option = "D"),
  scale_color_weights_mapview = viridis::viridis(100, option = "C"),
  scale_color_weights_discrete_mapview = NULL,
  scale_color_degree_mapview = NULL,
  plotly = deprecated(),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Which column of the data to plot? If <code>NULL</code>, no data will be
plotted.</p>
</dd>
<dt><code>newdata</code></dt><dd><p>A dataset of class <code>metric_graph_data</code>, obtained by any <code>get_data()</code>, <code>mutate()</code>, <code>filter()</code>, <code>summarise()</code>, <code>drop_na()</code> methods of metric graphs, see the vignette on data manipulation for more details.</p>
</dd>
<dt><code>group</code></dt><dd><p>If there are groups, which group to plot? If <code>group</code> is a
number and <code>newdata</code> is <code>NULL</code>, it will be the index of the group as stored internally and if <code>newdata</code> is provided, it will be the index of the group stored in <code>newdata</code>. If <code>group</code>
is a character, then the group will be chosen by its name.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of plot to be returned. The options are <code>ggplot</code> (the default), that uses <code>ggplot2</code>; <code>plotly</code> that uses <code>plot_ly</code> for 3D plots, which requires the <code>plotly</code> package, and <code>mapview</code> that uses the <code>mapview</code> function, to build interactive plots, which requires the <code>mapview</code> package.</p>
</dd>
<dt><code>interactive</code></dt><dd><p>Only works for 2d plots. If <code>TRUE</code>, an interactive plot will be displayed. Unfortunately, <code>interactive</code> is not compatible with <code>edge_weight</code> if <code>add_new_scale_weights</code> is TRUE.</p>
</dd>
<dt><code>vertex_size</code></dt><dd><p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt><dd><p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt><dd><p>Line width for edges. If <code>edge_width_weight</code> is not <code>NULL</code>, this determines the maximum edge width.</p>
</dd>
<dt><code>edge_color</code></dt><dd><p>Color of edges.</p>
</dd>
<dt><code>data_size</code></dt><dd><p>Size of markers for data.</p>
</dd>
<dt><code>support_width</code></dt><dd><p>For 3D plot, width of support lines.</p>
</dd>
<dt><code>support_color</code></dt><dd><p>For 3D plot, color of support lines.</p>
</dd>
<dt><code>mesh</code></dt><dd><p>Plot the mesh locations?</p>
</dd>
<dt><code>X</code></dt><dd><p>Additional values to plot.</p>
</dd>
<dt><code>X_loc</code></dt><dd><p>Locations of the additional values in the format
(edge, normalized distance on edge).</p>
</dd>
<dt><code>p</code></dt><dd><p>Existing objects obtained from 'ggplot2' or 'plotly' to add the graph to</p>
</dd>
<dt><code>degree</code></dt><dd><p>Show the degrees of the vertices?</p>
</dd>
<dt><code>direction</code></dt><dd><p>Show the direction of the edges? For <code>type == "mapview"</code> the arrows are not shown, only the color of the vertices indicating whether they are problematic or not.</p>
</dd>
<dt><code>arrow_size</code></dt><dd><p>The size of the arrows if direction is TRUE.</p>
</dd>
<dt><code>edge_weight</code></dt><dd><p>Which column from edge weights to determine the colors of the edges? If <code>NULL</code> edge weights are not plotted. To plot the edge weights when the metric graph <code>edge_weights</code> is a vector instead of a <code>data.frame</code>, simply set to 1.
<code>edge_weight</code> is only available for 2d plots. For 3d plots with edge weights, please use the <code>plot_function()</code> method.</p>
</dd>
<dt><code>edge_width_weight</code></dt><dd><p>Which column from edge weights to determine the edges widths? If <code>NULL</code> edge width will be determined from <code>edge_width</code>. Currently it is not supported for <code>type = "mapview"</code>.</p>
</dd>
<dt><code>scale_color_main</code></dt><dd><p>Color scale for the data to be plotted.</p>
</dd>
<dt><code>scale_color_weights</code></dt><dd><p>Color scale for the edge weights. Will only be used if <code>add_new_scale_weights</code> is TRUE.</p>
</dd>
<dt><code>scale_color_degree</code></dt><dd><p>Color scale for the degrees.</p>
</dd>
<dt><code>scale_color_weights_discrete</code></dt><dd><p>Color scale for discrete edge weights. Will only be used if <code>add_new_scale_weights</code> is TRUE.</p>
</dd>
<dt><code>scale_color_main_discrete</code></dt><dd><p>Color scale for the data to be plotted, for discrete data.</p>
</dd>
<dt><code>add_new_scale_weights</code></dt><dd><p>Should a new color scale for the edge weights be created?</p>
</dd>
<dt><code>scale_color_mapview</code></dt><dd><p>Color scale to be applied for data when <code>type = "mapview"</code>.</p>
</dd>
<dt><code>scale_color_weights_mapview</code></dt><dd><p>Color scale to be applied for edge weights when <code>type = "mapview"</code>.</p>
</dd>
<dt><code>scale_color_weights_discrete_mapview</code></dt><dd><p>Color scale to be applied for degrees when <code>type = "mapview"</code>. If <code>NULL</code> <code>RColorBrewer::brewer.pal(n = n_weights, "Set1")</code> will be used where <code>n_weights</code> is the number of different degrees.</p>
</dd>
<dt><code>scale_color_degree_mapview</code></dt><dd><p>Color scale to be applied for degrees when <code>type = "mapview"</code>. If <code>NULL</code> <code>RColorBrewer::brewer.pal(n = n_degrees, "Set1")</code> will be used where <code>n_degrees</code> is the number of different degrees.</p>
</dd>
<dt><code>plotly</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>type</code> instead.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to <code>ggplot()</code> or <code>plot_ly()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>plot_ly</code> (if <code>type = "plotly"</code>) or <code>ggplot</code> object.
</p>


<hr>
<a id="method-metric_graph-plot_connections"></a>



<h4>Method <code>plot_connections()</code></h4>

<p>Plots the connections in the graph
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_connections()</pre></div>



<h5>Returns</h5>

<p>No return value. Called for its side effects.
</p>


<hr>
<a id="method-metric_graph-is_tree"></a>



<h4>Method <code>is_tree()</code></h4>

<p>Checks if the graph is a tree (without considering directions)
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$is_tree()</pre></div>



<h5>Returns</h5>

<p>TRUE if the graph is a tree and FALSE otherwise.
</p>


<hr>
<a id="method-metric_graph-plot_function"></a>



<h4>Method <code>plot_function()</code></h4>

<p>Plots continuous function on the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_function(
  data = NULL,
  newdata = NULL,
  group = 1,
  X = NULL,
  type = c("ggplot", "plotly", "mapview"),
  continuous = TRUE,
  interpolate_plot = TRUE,
  edge_weight = NULL,
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  scale_color = ggplot2::scale_color_viridis_c(option = "D"),
  scale_color_mapview = viridis::viridis(100, option = "D"),
  support_width = 0.5,
  support_color = "gray",
  mapview_caption = "Function",
  p = NULL,
  plotly = deprecated(),
  improve_plot = deprecated(),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Which column of the data to plot? If <code>NULL</code>, no data will be
plotted.</p>
</dd>
<dt><code>newdata</code></dt><dd><p>A dataset of class <code>metric_graph_data</code>, obtained by any <code>get_data()</code>, <code>mutate()</code>, <code>filter()</code>, <code>summarise()</code>, <code>drop_na()</code> methods of metric graphs, see the vignette on data manipulation for more details.</p>
</dd>
<dt><code>group</code></dt><dd><p>If there are groups, which group to plot? If <code>group</code> is a
number, it will be the index of the group as stored internally. If <code>group</code>
is a character, then the group will be chosen by its name.</p>
</dd>
<dt><code>X</code></dt><dd><p>A vector with values for the function
evaluated at the mesh in the graph</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of plot to be returned. The options are <code>ggplot</code> (the default), that uses <code>ggplot2</code>; <code>plotly</code> that uses <code>plot_ly</code> for 3D plots, which requires the <code>plotly</code> package, and <code>mapview</code> that uses the <code>mapview</code> function, to build interactive plots, which requires the <code>mapview</code> package.</p>
</dd>
<dt><code>continuous</code></dt><dd><p>Should continuity be assumed when the plot uses <code>newdata</code>?</p>
</dd>
<dt><code>interpolate_plot</code></dt><dd><p>Should the values to be plotted be interpolated?</p>
</dd>
<dt><code>edge_weight</code></dt><dd><p>Which column from edge weights to plot? If <code>NULL</code> edge weights are not plotted. To plot the edge weights when the metric graph <code>edge_weights</code> is a vector instead of a <code>data.frame</code>, simply set to 1.</p>
</dd>
<dt><code>vertex_size</code></dt><dd><p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt><dd><p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt><dd><p>Width for edges.</p>
</dd>
<dt><code>edge_color</code></dt><dd><p>For 3D plot, color of edges.</p>
</dd>
<dt><code>line_width</code></dt><dd><p>For 3D plot, line width of the function curve.</p>
</dd>
<dt><code>line_color</code></dt><dd><p>Color of the function curve.</p>
</dd>
<dt><code>scale_color</code></dt><dd><p>Color scale to be used for data and weights.</p>
</dd>
<dt><code>scale_color_mapview</code></dt><dd><p>Color scale to be applied for data when <code>type = "mapview"</code>.</p>
</dd>
<dt><code>support_width</code></dt><dd><p>For 3D plot, width of support lines.</p>
</dd>
<dt><code>support_color</code></dt><dd><p>For 3D plot, color of support lines.</p>
</dd>
<dt><code>mapview_caption</code></dt><dd><p>Caption for the function if <code>type = "mapview"</code>.</p>
</dd>
<dt><code>p</code></dt><dd><p>Previous plot to which the new plot should be added.</p>
</dd>
<dt><code>plotly</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>type</code> instead.</p>
</dd>
<dt><code>improve_plot</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>interpolate</code> instead. There is no need to use it to improve the edges.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for <code>ggplot()</code> or <code>plot_ly()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Either a <code>ggplot</code> (if <code>plotly = FALSE</code>) or a <code>plot_ly</code> object.
</p>


<hr>
<a id="method-metric_graph-plot_movie"></a>



<h4>Method <code>plot_movie()</code></h4>

<p>Plots a movie of a continuous function evolving on the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$plot_movie(
  X,
  type = "plotly",
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>A m x T matrix where the ith column represents the function at the
ith time, evaluated at the mesh locations.</p>
</dd>
<dt><code>type</code></dt><dd><p>Type of plot. Either <code>"plotly"</code> or <code>"ggplot"</code>.</p>
</dd>
<dt><code>vertex_size</code></dt><dd><p>Size of the vertices.</p>
</dd>
<dt><code>vertex_color</code></dt><dd><p>Color of vertices.</p>
</dd>
<dt><code>edge_width</code></dt><dd><p>Width for edges.</p>
</dd>
<dt><code>edge_color</code></dt><dd><p>For 3D plot, color of edges.</p>
</dd>
<dt><code>line_width</code></dt><dd><p>For 3D plot, line width of the function curve.</p>
</dd>
<dt><code>line_color</code></dt><dd><p>Color of the function curve.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for ggplot or plot_ly.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Either a <code>ggplot</code> (if <code>plotly=FALSE</code>) or a <code>plot_ly</code> object.
</p>


<hr>
<a id="method-metric_graph-add_mesh_observations"></a>



<h4>Method <code>add_mesh_observations()</code></h4>

<p>Add observations on mesh to the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$add_mesh_observations(data = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> or named list containing the observations.
In case of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If <code>data_frame</code> is not
<code>NULL</code>, it takes priority over any eventual data in <code>Spoints</code>.</p>
</dd>
<dt><code>group</code></dt><dd><p>If the data_frame contains groups, one must provide the column
in which the group indices are stored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>No return value. Called for its side effects. The observations are
stored in the <code>data</code> element in the <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-get_initial_graph"></a>



<h4>Method <code>get_initial_graph()</code></h4>

<p>Returns a copy of the initial metric graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$get_initial_graph()</pre></div>



<h5>Returns</h5>

<p>A <code>metric_graph</code> object.
</p>


<hr>
<a id="method-metric_graph-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>

<p>Convert between locations on the graph and Euclidean
coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>PtE</code></dt><dd><p>Matrix with locations on the graph (edge number and normalized
position on the edge).</p>
</dd>
<dt><code>XY</code></dt><dd><p>Matrix with locations in Euclidean space</p>
</dd>
<dt><code>normalized</code></dt><dd><p>If <code>TRUE</code>, it is assumed that the positions in <code>PtE</code> are
normalized to (0,1), and the object returned if <code>XY</code> is specified contains
normalized locations.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>PtE</code> is specified, then a matrix with Euclidean coordinates of
the locations is returned. If <code>XY</code> is provided, then a matrix with the
closest locations on the graph is returned.
Gets the edge weights
data.frame If the edge weights are given as vectors, should the result be returned as a data.frame?
A vector or <code>data.frame</code> containing the edge weights.
data List containing data on the metric graph.
</p>


<hr>
<a id="method-metric_graph-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>metric_graph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>edge1 &lt;- rbind(c(0, 0), c(2, 0))
edge2 &lt;- rbind(c(2, 0), c(1, 1))
edge3 &lt;- rbind(c(1, 1), c(0, 0))
edges &lt;- list(edge1, edge2, edge3)
graph &lt;- metric_graph$new(edges)
graph$plot()

</code></pre>

<hr>
<h2 id='mutate.metric_graph_data'>A version of <code>dplyr::mutate()</code> function for datasets on metric graphs</h2><span id='topic+mutate.metric_graph_data'></span><span id='topic+mutate'></span>

<h3>Description</h3>

<p>Applies <code>dplyr::mutate()</code> function for datasets obtained from a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_data'
mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.metric_graph_data_+3A_.data">.data</code></td>
<td>
<p>The data list or <code>tidyr::tibble</code> obtained from a metric graph object.</p>
</td></tr>
<tr><td><code id="mutate.metric_graph_data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>dplyr::mutate()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyr::tibble</code> with the resulting selected columns.
</p>

<hr>
<h2 id='pems'>Traffic speed data from San Jose, California</h2><span id='topic+pems'></span>

<h3>Description</h3>

<p>Data set of traffic speed observations on highways in the city of San Jose,
California.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pems
</code></pre>


<h3>Format</h3>



<h4><code>pems</code></h4>

<p>A list with two elements:
</p>

<dl>
<dt>edges</dt><dd><p>A <code>list</code> object containing the coordinates of the road segments.</p>
</dd>
<dt>data</dt><dd><p>Locations of the observations on the road segments as a
<code>data.frame</code> with 325 rows and 3 columns. The first column indicates the edge
number, the second column indicates the distance on edge of the position,
and the third column indicates the average speed observed.</p>
</dd>
</dl>




<h3>Source</h3>

<p>https://www.openstreetmap.org
</p>
<p>https://github.com/spbu-math-cs/Graph-Gaussian-Processes/blob/main/examples/data/PEMS.zip
</p>


<h3>References</h3>

<p>Chen, C., K. Petty, A. Skabardonis, P. Varaiya, and Z. Jia (2001). Freeway performance measurement system: mining loop detector data. Transportation Research Record 1748(1), 96-102.
</p>
<p>OpenStreetMap contributors (2017). Planet dump retrieved from https://planet.osm.org. https://www.openstreetmap.org.
</p>

<hr>
<h2 id='pems_repl'>Traffic speed data with replicates from San Jose, California</h2><span id='topic+pems_repl'></span>

<h3>Description</h3>

<p>Data set of traffic speed observations on highways in the city of San Jose,
California.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pems_repl
</code></pre>


<h3>Format</h3>



<h4><code>pems_repl</code></h4>

<p>A list with two elements:
</p>

<dl>
<dt>edges</dt><dd><p>A <code>list</code> object containing the coordinates of the road segments.</p>
</dd>
<dt>data</dt><dd><p>Locations of the observations on the road segments as a
<code>data.frame</code> with 325 rows and 4 columns. The first column indicates the observed speed,
the second column indicates the edge
number, the third column indicates the distance on edge of the position,
and the fourth column indicates the replicate number.</p>
</dd>
</dl>




<h3>Source</h3>

<p>https://www.openstreetmap.org
</p>
<p>https://github.com/spbu-math-cs/Graph-Gaussian-Processes/blob/main/examples/data/PEMS.zip
</p>


<h3>References</h3>

<p>Chen, C., K. Petty, A. Skabardonis, P. Varaiya, and Z. Jia (2001). Freeway performance measurement system: mining loop detector data. Transportation Research Record 1748(1), 96-102.
</p>
<p>OpenStreetMap contributors (2017). Planet dump retrieved from https://planet.osm.org. https://www.openstreetmap.org.
</p>

<hr>
<h2 id='plot.graph_bru_pred'>Plot of predicted values with 'inlabru'</h2><span id='topic+plot.graph_bru_pred'></span>

<h3>Description</h3>

<p>Auxiliary function to obtain plots of the predictions of the field
using 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_bru_pred'
plot(x, y = NULL, vertex_size = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.graph_bru_pred_+3A_x">x</code></td>
<td>
<p>A predicted object obtained with the <code>predict</code> method.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_pred_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_pred_+3A_vertex_size">vertex_size</code></td>
<td>
<p>Size of the vertices.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_pred_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to plot_function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot2' object.
</p>

<hr>
<h2 id='plot.graph_bru_proc_pred'>Plot of processed predicted values with 'inlabru'</h2><span id='topic+plot.graph_bru_proc_pred'></span>

<h3>Description</h3>

<p>Auxiliary function to obtain plots of the processed predictions of the field
using 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_bru_proc_pred'
plot(x, y = NULL, vertex_size = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.graph_bru_proc_pred_+3A_x">x</code></td>
<td>
<p>A processed predicted object obtained with the <code>process_rspde_predictions</code> function.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_proc_pred_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_proc_pred_+3A_vertex_size">vertex_size</code></td>
<td>
<p>Size of the vertices.</p>
</td></tr>
<tr><td><code id="plot.graph_bru_proc_pred_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to plot_function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot2' object.
</p>

<hr>
<h2 id='posterior_crossvalidation'>Leave-one-out crossvalidation for <code>graph_lme</code> models assuming observations at
the vertices of metric graphs</h2><span id='topic+posterior_crossvalidation'></span>

<h3>Description</h3>

<p>Leave-one-out crossvalidation for <code>graph_lme</code> models assuming observations at
the vertices of metric graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_crossvalidation(object, factor = 1, tibble = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_crossvalidation_+3A_object">object</code></td>
<td>
<p>A fitted model using the <code>graph_lme()</code> function or a named list of fitted objects using the <code>graph_lme()</code> function.</p>
</td></tr>
<tr><td><code id="posterior_crossvalidation_+3A_factor">factor</code></td>
<td>
<p>Which factor to multiply the scores. The default is 1.</p>
</td></tr>
<tr><td><code id="posterior_crossvalidation_+3A_tibble">tibble</code></td>
<td>
<p>Return the scores as a <code>tidyr::tibble()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the posterior expectations and variances as well as
mean absolute error (MAE), root mean squared errors (RMSE), and three
negatively oriented proper scoring rules: log-score, CRPS, and scaled
CRPS.
</p>

<hr>
<h2 id='predict.graph_lme'>Prediction for a mixed effects regression model on a metric graph</h2><span id='topic+predict.graph_lme'></span>

<h3>Description</h3>

<p>Prediction for a mixed effects regression model on a metric graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_lme'
predict(
  object,
  newdata = NULL,
  mesh = FALSE,
  mesh_h = 0.01,
  which_repl = NULL,
  compute_variances = FALSE,
  compute_pred_variances = FALSE,
  posterior_samples = FALSE,
  pred_samples = FALSE,
  n_samples = 100,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  normalized = FALSE,
  no_nugget = FALSE,
  return_as_list = FALSE,
  return_original_order = TRUE,
  check_euclidean = TRUE,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.graph_lme_+3A_object">object</code></td>
<td>
<p>The fitted object with the <code>graph_lme()</code> function.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or a <code>list</code> containing the covariates, the edge
number and the distance on edge for the locations to obtain the prediction. Observe that you should not provide the locations for each replicate. Only a single set of locations and covariates, and the predictions for the different replicates will be obtained for this same set of locations.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_mesh">mesh</code></td>
<td>
<p>Obtain predictions for mesh nodes? The graph must have a mesh and should not have covariates.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_mesh_h">mesh_h</code></td>
<td>
<p>If the graph does not have a mesh, one will be created with this
value of 'h'.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to obtain the prediction. If <code>NULL</code> predictions
will be obtained for all replicates. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_compute_variances">compute_variances</code></td>
<td>
<p>Set to TRUE to compute the kriging variances.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_compute_pred_variances">compute_pred_variances</code></td>
<td>
<p>Set to TRUE to compute the prediction variances. Will only be computed if newdata is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>If <code>TRUE</code>, posterior samples for the random effect will be returned.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_pred_samples">pred_samples</code></td>
<td>
<p>If <code>TRUE</code>, prediction samples for the response variable will be returned. Will only be computed if newdata is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples to be returned. Will only be used if
<code>sampling</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_edge_number">edge_number</code></td>
<td>
<p>Name of the variable that contains the edge number, the
default is <code>edge_number</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_distance_on_edge">distance_on_edge</code></td>
<td>
<p>Name of the variable that contains the distance on
edge, the default is <code>distance_on_edge</code>.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_normalized">normalized</code></td>
<td>
<p>Are the distances on edges normalized?</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_no_nugget">no_nugget</code></td>
<td>
<p>Should the prediction be carried out without the nugget?</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_return_as_list">return_as_list</code></td>
<td>
<p>Should the means of the predictions and the posterior
samples be returned as a list, with each replicate being an element?</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_return_original_order">return_original_order</code></td>
<td>
<p>Should the results be return in the original
(input) order or in the order inside the graph?</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_check_euclidean">check_euclidean</code></td>
<td>
<p>Check if the graph used to compute the resistance distance has Euclidean edges? The graph used to compute the resistance distance has the observation locations as vertices.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="predict.graph_lme_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>mean</code>, which contains the means of the
predictions, <code>fe_mean</code>, which is the prediction for the fixed effects, <code>re_mean</code>, which is the prediction for the random effects, <code>variance</code> (if <code>compute_variance</code> is <code>TRUE</code>), which contains the
posterior variances of the random effects, <code>samples</code> (if <code>posterior_samples</code> is <code>TRUE</code>),
which contains the posterior samples.
</p>

<hr>
<h2 id='predict.inla_metric_graph_spde'>Predict method for 'inlabru' fits on Metric Graphs</h2><span id='topic+predict.inla_metric_graph_spde'></span>

<h3>Description</h3>

<p>Auxiliar function to obtain predictions of the field
using 'inlabru'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inla_metric_graph_spde'
predict(
  object,
  cmp,
  bru_fit,
  newdata = NULL,
  formula = NULL,
  data_coords = c("PtE", "euclidean"),
  normalized = TRUE,
  repl = NULL,
  repl_col = NULL,
  group = NULL,
  group_col = NULL,
  n.samples = 100,
  seed = 0L,
  probs = c(0.025, 0.5, 0.975),
  return_original_order = TRUE,
  num.threads = NULL,
  include = NULL,
  exclude = NULL,
  drop = FALSE,
  tolerance_merge = 1e-05,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.inla_metric_graph_spde_+3A_object">object</code></td>
<td>
<p>An <code>inla_metric_graph_spde</code> object built with the <code>graph_spde()</code>
function.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_cmp">cmp</code></td>
<td>
<p>The 'inlabru' component used to fit the model.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_bru_fit">bru_fit</code></td>
<td>
<p>A fitted model using 'inlabru' or 'INLA'.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame of covariates needed for the prediction. The
locations must be normalized PtE.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression to
evaluate for each generated sample. If NULL, the latent and hyperparameter
states are returned as named list elements. See Details for more information.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_data_coords">data_coords</code></td>
<td>
<p>It decides which coordinate system to use. If <code>PtE</code>, the
user must provide the locations as a data frame with the first column being
the edge number and the second column as the distance on edge, otherwise if
<code>euclidean</code>, the user must provide a data frame with the first column being
the <code>x</code> Euclidean coordinates and the second column being the <code>y</code> Euclidean
coordinates.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_normalized">normalized</code></td>
<td>
<p>if <code>TRUE</code>, then the distances in distance on edge are
assumed to be normalized to (0,1). Default TRUE. Will not be
used if <code>data_coords</code> is <code>euclidean</code>.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_repl">repl</code></td>
<td>
<p>Which replicates? If there is no replicates, one
can set <code>repl</code> to <code>NULL</code>. If one wants all replicates,
then one sets to <code>repl</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_repl_col">repl_col</code></td>
<td>
<p>Column containing the replicates. If the replicate is the internal group variable, set the replicates
to &quot;.group&quot;. If not replicates, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_group">group</code></td>
<td>
<p>Which groups? If there is no groups, one
can set <code>group</code> to <code>NULL</code>. If one wants all groups,
then one sets to <code>group</code> to <code>.all</code>.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_group_col">group_col</code></td>
<td>
<p>Which &quot;column&quot; of the data contains the group variable?</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_n.samples">n.samples</code></td>
<td>
<p>Integer setting the number of samples to draw in order to
calculate the posterior statistics. The default is rather low but provides a
quick approximate result.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed passed on to <code>inla.posterior.sample()</code></p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in the standard
unit interval to be passed to stats::quantile</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_return_original_order">return_original_order</code></td>
<td>
<p>Should the predictions be returned in the
original order?</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to 'INLA'. When seed != 0, overridden to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: NULL (include all components that are not
explicitly excluded)</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list as determined
by the include parameter; Default: NULL (do not remove any components from
the inclusion list)</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_drop">drop</code></td>
<td>
<p>logical; If keep=FALSE, data is a SpatialDataFrame, and the
prediciton summary has the same number of rows as data, then the output is a
SpatialDataFrame object. Default FALSE.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_tolerance_merge">tolerance_merge</code></td>
<td>
<p>Tolerance for merging prediction points into original points to increase stability.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>inla.posterior.sample()</code>.</p>
</td></tr>
<tr><td><code id="predict.inla_metric_graph_spde_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with predictions.
</p>

<hr>
<h2 id='predict.rspde_metric_graph'>Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models</h2><span id='topic+predict.rspde_metric_graph'></span>

<h3>Description</h3>

<p>Auxiliar function to obtain predictions of the field
using 'inlabru' and 'rSPDE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rspde_metric_graph'
predict(
  object,
  cmp,
  bru_fit,
  newdata = NULL,
  formula = NULL,
  data_coords = c("PtE", "euclidean"),
  normalized = TRUE,
  n.samples = 100,
  seed = 0L,
  probs = c(0.025, 0.5, 0.975),
  num.threads = NULL,
  include = NULL,
  exclude = NULL,
  drop = FALSE,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rspde_metric_graph_+3A_object">object</code></td>
<td>
<p>An <code>rspde_metric_graph</code> object built with the
<code>rspde.metric_graph()</code> function.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_cmp">cmp</code></td>
<td>
<p>The 'inlabru' component used to fit the model.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_bru_fit">bru_fit</code></td>
<td>
<p>A fitted model using 'inlabru' or 'INLA'.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame of covariates needed for the prediction. The locations
must be normalized PtE.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression to
evaluate for each generated sample. If NULL, the latent and hyperparameter
states are returned as named list elements. See Details for more information.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_data_coords">data_coords</code></td>
<td>
<p>It decides which coordinate system to use. If <code>PtE</code>, the
user must provide the locations as a data frame with the first column being
the edge number and the second column as the distance on edge, otherwise if
<code>euclidean</code>, the user must provide a data frame with the first column being
the <code>x</code> Euclidean coordinates and the second column being the <code>y</code> Euclidean
coordinates.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_normalized">normalized</code></td>
<td>
<p>if <code>TRUE</code>, then the distances in distance on edge are
assumed to be normalized to (0,1). Default TRUE. Will not be used if
<code>data_coords</code> is <code>euclidean</code>.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_n.samples">n.samples</code></td>
<td>
<p>Integer setting the number of samples to draw in order to
calculate the posterior statistics. The default is rather low but provides a
quick approximate result.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed passed on to inla.posterior.sample</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in the standard
unit interval to be passed to stats::quantile.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to 'INLA'. When seed != 0, overridden
to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: NULL (include all components that are not
explicitly excluded)</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list as determined
by the include parameter; Default: NULL (do not remove any components from the
inclusion list)</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_drop">drop</code></td>
<td>
<p>logical; If keep=FALSE, data is a SpatialDataFrame, and the
prediciton summary has the same number of rows as data, then the output is a
SpatialDataFrame object. Default FALSE.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to inla.posterior.sample.</p>
</td></tr>
<tr><td><code id="predict.rspde_metric_graph_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with predictions.
</p>

<hr>
<h2 id='process_rspde_predictions'>Process predictions of <code>rspde_metric_graph</code> objects obtained by using <code>inlabru</code></h2><span id='topic+process_rspde_predictions'></span>

<h3>Description</h3>

<p>Auxiliar function to transform the predictions of the field into a plot friendly object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_rspde_predictions(pred, graph, PtE = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_rspde_predictions_+3A_pred">pred</code></td>
<td>
<p>The predictions of the field obtained by using <code>inlabru</code></p>
</td></tr>
<tr><td><code id="process_rspde_predictions_+3A_graph">graph</code></td>
<td>
<p>The original <code>metric_graph</code> object in which the predictions were obtained.</p>
</td></tr>
<tr><td><code id="process_rspde_predictions_+3A_pte">PtE</code></td>
<td>
<p>Normalized locations of the points on the edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with predictions.
</p>

<hr>
<h2 id='psp.to.graph'>Convert a <code>psp</code> object to a metric graph object</h2><span id='topic+psp.to.graph'></span>

<h3>Description</h3>

<p>This function converts a <code>psp</code> object (from the <code>spatstat</code> package) into a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psp.to.graph(psp.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psp.to.graph_+3A_psp.object">psp.object</code></td>
<td>
<p>A <code>psp</code> object to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A metric graph object with edges defined by the segments in the <code>psp</code> object.
</p>

<hr>
<h2 id='sample_spde'>Samples a Whittle-Matérn field on a metric graph</h2><span id='topic+sample_spde'></span>

<h3>Description</h3>

<p>Obtains samples of a Whittle-Matérn field on a metric graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_spde(
  kappa,
  tau,
  range,
  sigma,
  sigma_e = 0,
  alpha = 1,
  directional = FALSE,
  graph,
  PtE = NULL,
  type = "manual",
  posterior = FALSE,
  nsim = 1,
  method = c("conditional", "Q"),
  BC = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_spde_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_tau">tau</code></td>
<td>
<p>Precision parameter.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_range">range</code></td>
<td>
<p>Practical correlation range parameter.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_sigma">sigma</code></td>
<td>
<p>Marginal standard deviation parameter.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_sigma_e">sigma_e</code></td>
<td>
<p>Standard deviation of the measurement noise.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_directional">directional</code></td>
<td>
<p>should we use directional model currently only for alpha=1</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_pte">PtE</code></td>
<td>
<p>Matrix with locations (edge, normalized distance on edge) where
the samples should be generated.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_type">type</code></td>
<td>
<p>If &quot;manual&quot; is set, then sampling is done at the locations
specified in <code>PtE</code>. Set to &quot;mesh&quot; for simulation at mesh nodes, and to &quot;obs&quot;
for simulation at observation locations.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_posterior">posterior</code></td>
<td>
<p>Sample conditionally on the observations?</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_nsim">nsim</code></td>
<td>
<p>Number of samples to be generated.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_method">method</code></td>
<td>
<p>Which method to use for the sampling? The options are
&quot;conditional&quot; and &quot;Q&quot;. Here, &quot;Q&quot; is more stable but takes longer.</p>
</td></tr>
<tr><td><code id="sample_spde_+3A_bc">BC</code></td>
<td>
<p>Boundary conditions for degree 1 vertices. BC = 0 gives Neumann
boundary conditions and BC = 1 gives stationary boundary conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples a Gaussian Whittle-Matérn field on a metric graph, either
from the prior or conditionally on observations
</p>
<p style="text-align: center;"><code class="reqn">y_i = u(t_i) + \sigma_e e_i</code>
</p>

<p>on the graph,  where <code class="reqn">e_i</code> are independent standard Gaussian variables.
The parameters for the field can either be specified in terms of tau and kappa
or practical correlation range and marginal standard deviation.
</p>


<h3>Value</h3>

<p>Matrix or vector with the samples.
</p>

<hr>
<h2 id='select.metric_graph_data'>A version of <code>dplyr::select()</code> function for datasets on metric graphs</h2><span id='topic+select.metric_graph_data'></span><span id='topic+select'></span>

<h3>Description</h3>

<p>Selects columns on metric graphs, while keeps the spatial positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_data'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.metric_graph_data_+3A_.data">.data</code></td>
<td>
<p>The data list or <code>tidyr::tibble</code> obtained from a metric graph object.</p>
</td></tr>
<tr><td><code id="select.metric_graph_data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>dplyr::select()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyr::tibble</code> with the resulting selected columns.
</p>

<hr>
<h2 id='selected_inv'>Selected Inverse Calculation</h2><span id='topic+selected_inv'></span>

<h3>Description</h3>

<p>Selected Inverse Calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selected_inv(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selected_inv_+3A_q">Q</code></td>
<td>
<p>A sparse matrix in dgCMatrix format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the selected inverse
</p>

<hr>
<h2 id='simulate_spacetime'>space-time simulation based on implicit Euler discretization in time</h2><span id='topic+simulate_spacetime'></span>

<h3>Description</h3>

<p>Simulation with starting value u0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma, u0, BC = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_spacetime_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_t">t</code></td>
<td>
<p>Vector of time points.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_kappa">kappa</code></td>
<td>
<p>Spatial range parameter.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_rho">rho</code></td>
<td>
<p>Drift parameter.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_gamma">gamma</code></td>
<td>
<p>Temporal range parameter.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (integer) for spatial operator.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_beta">beta</code></td>
<td>
<p>Smoothness parameter (integer) for Q-Wiener process.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_sigma">sigma</code></td>
<td>
<p>Variance parameter.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_u0">u0</code></td>
<td>
<p>Starting value.</p>
</td></tr>
<tr><td><code id="simulate_spacetime_+3A_bc">BC</code></td>
<td>
<p>Which boundary condition to use (0,1). Here, 0 is no adjustment on
the boundary and 1 results in making the boundary condition stationary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision matrix.
</p>

<hr>
<h2 id='simulate.graph_lme'>Simulation of models on metric graphs</h2><span id='topic+simulate.graph_lme'></span>

<h3>Description</h3>

<p>The function samples a Gaussian random field based on a
fitted model using <code>graph_lme()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_lme'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  sample_latent = FALSE,
  posterior = FALSE,
  which_repl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.graph_lme_+3A_object">object</code></td>
<td>
<p>A <code>graph_lme</code> object</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be initialized (‘seeded’).</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_sample_latent">sample_latent</code></td>
<td>
<p>If <code>FALSE</code>, samples for the response variable will be generated. If <code>TRUE</code>, samples for the latent model will be generated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_posterior">posterior</code></td>
<td>
<p>Should posterior samples be generated? If <code>FALSE</code>, samples will be computed based on the estimated prior distribution. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_which_repl">which_repl</code></td>
<td>
<p>Which replicates to generate the samples. If <code>NULL</code> samples will
be generated for all replicates. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate.graph_lme_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing elements <code>samples</code>, <code>edge_number</code> and <code>distance_on_edge</code>. Each of them is a list, whose indexes are the replicates, and in <code>samples</code> a matrix is given with <code>nsim</code> columns, each one being a sample. <code>edge_number</code> and <code>distance_on_edges</code> contain the respective edge numbers and distances on edge for each sampled element. The locations of the samples are the location of the data in which the model was fitted.
</p>

<hr>
<h2 id='spde_covariance'>Covariance function for Whittle-Matérn fields</h2><span id='topic+spde_covariance'></span>

<h3>Description</h3>

<p>Computes the covariance function for a Whittle-Matérn field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_covariance(P, kappa, tau, range, sigma, alpha, graph, directional = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde_covariance_+3A_p">P</code></td>
<td>
<p>Location (edge number and normalized location on the edge) for the
location to evaluate the covariance function at.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_kappa">kappa</code></td>
<td>
<p>Parameter kappa from the SPDE.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_tau">tau</code></td>
<td>
<p>Parameter tau from the SPDE.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_range">range</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation parameter.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (1 or 2).</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="spde_covariance_+3A_directional">directional</code></td>
<td>
<p>bool is the model a directional or not. directional only works for alpha=1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the covariance function <code class="reqn">\rho(P,s_i)</code> where
P is the provided location and <code class="reqn">s_i</code> are all locations in the mesh
of the graph.
</p>


<h3>Value</h3>

<p>Vector with the covariance function evaluate at the mesh locations.
</p>

<hr>
<h2 id='spde_metric_graph_result'>Metric graph SPDE result extraction from 'INLA' estimation results</h2><span id='topic+spde_metric_graph_result'></span>

<h3>Description</h3>

<p>Extract field and parameter values and distributions
for a metric graph spde effect from an 'INLA' result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_metric_graph_result(
  inla,
  name,
  metric_graph_spde,
  compute.summary = TRUE,
  n_samples = 5000,
  n_density = 1024
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde_metric_graph_result_+3A_inla">inla</code></td>
<td>
<p>An 'INLA' object obtained from a call to <code>inla()</code>.</p>
</td></tr>
<tr><td><code id="spde_metric_graph_result_+3A_name">name</code></td>
<td>
<p>A character string with the name of the 'rSPDE' effect
in the model.</p>
</td></tr>
<tr><td><code id="spde_metric_graph_result_+3A_metric_graph_spde">metric_graph_spde</code></td>
<td>
<p>The <code>inla_metric_graph_spde</code> object used for the
random effect in the model.</p>
</td></tr>
<tr><td><code id="spde_metric_graph_result_+3A_compute.summary">compute.summary</code></td>
<td>
<p>Should the summary be computed?</p>
</td></tr>
<tr><td><code id="spde_metric_graph_result_+3A_n_samples">n_samples</code></td>
<td>
<p>The number of samples to be used if parameterization is <code>matern</code>.</p>
</td></tr>
<tr><td><code id="spde_metric_graph_result_+3A_n_density">n_density</code></td>
<td>
<p>The number of equally spaced points to estimate the density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the model was fitted with <code>matern</code> parameterization (the default),
it returns a list containing:
</p>
<table role = "presentation">
<tr><td><code>marginals.range</code></td>
<td>
<p>Marginal densities for the range parameter.</p>
</td></tr>
<tr><td><code>marginals.log.range</code></td>
<td>
<p>Marginal densities for log(range).</p>
</td></tr>
<tr><td><code>marginals.sigma</code></td>
<td>
<p>Marginal densities for std. deviation.</p>
</td></tr>
<tr><td><code>marginals.log.sigma</code></td>
<td>
<p>Marginal densities for log(std. deviation).</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values.</p>
</td></tr>
<tr><td><code>summary.log.range</code></td>
<td>
<p>Summary statistics for log(range).</p>
</td></tr>
<tr><td><code>summary.log.sigma</code></td>
<td>
<p>Summary statistics for log(std. deviation).</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values.</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa.</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau.</p>
</td></tr>
</table>
<p>If the model was fitted with the <code>spde</code> parameterization, it returns a list containing:
</p>
<table role = "presentation">
<tr><td><code>marginals.kappa</code></td>
<td>
<p>Marginal densities for kappa.</p>
</td></tr>
<tr><td><code>marginals.log.kappa</code></td>
<td>
<p>Marginal densities for log(kappa).</p>
</td></tr>
<tr><td><code>marginals.log.tau</code></td>
<td>
<p>Marginal densities for log(tau).</p>
</td></tr>
<tr><td><code>marginals.tau</code></td>
<td>
<p>Marginal densities for tau.</p>
</td></tr>
<tr><td><code>marginals.values</code></td>
<td>
<p>Marginal densities for the field values.</p>
</td></tr>
<tr><td><code>summary.log.kappa</code></td>
<td>
<p>Summary statistics for log(kappa).</p>
</td></tr>
<tr><td><code>summary.log.tau</code></td>
<td>
<p>Summary statistics for log(tau).</p>
</td></tr>
<tr><td><code>summary.values</code></td>
<td>
<p>Summary statistics for the field values.</p>
</td></tr>
</table>
<p>If <code>compute.summary</code> is <code>TRUE</code>, then the list will also contain
</p>
<table role = "presentation">
<tr><td><code>summary.kappa</code></td>
<td>
<p>Summary statistics for kappa.</p>
</td></tr>
<tr><td><code>summary.tau</code></td>
<td>
<p>Summary statistics for tau.</p>
</td></tr>
</table>

<hr>
<h2 id='spde_precision'>Precision matrix for Whittle-Matérn fields</h2><span id='topic+spde_precision'></span>

<h3>Description</h3>

<p>Computes the precision matrix for all vertices for a Whittle-Matérn field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_precision(kappa, tau, alpha, graph, BC = 1, build = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde_precision_+3A_kappa">kappa</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="spde_precision_+3A_tau">tau</code></td>
<td>
<p>Precision parameter.</p>
</td></tr>
<tr><td><code id="spde_precision_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (1 or 2).</p>
</td></tr>
<tr><td><code id="spde_precision_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="spde_precision_+3A_bc">BC</code></td>
<td>
<p>Set boundary conditions for degree=1 vertices. BC =0 gives Neumann
boundary conditions and BC=1 gives stationary boundary conditions.</p>
</td></tr>
<tr><td><code id="spde_precision_+3A_build">build</code></td>
<td>
<p>If <code>TRUE</code>, the precision matrix is returned. Otherwise a list
list(i,j,x, nv) is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision matrix or list.
</p>

<hr>
<h2 id='spde_variance'>Variancefor Whittle-Matérn fields</h2><span id='topic+spde_variance'></span>

<h3>Description</h3>

<p>Computes the variance function for a Whittle-Matérn field.
Warning is not feasible for large graph due to matrix inversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde_variance(
  kappa,
  tau,
  range,
  sigma,
  alpha,
  graph,
  BC = 1,
  include_vertices = FALSE,
  directional = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spde_variance_+3A_kappa">kappa</code></td>
<td>
<p>Parameter kappa from the SPDE.</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_tau">tau</code></td>
<td>
<p>Parameter tau from the SPDE.</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_range">range</code></td>
<td>
<p>Range parameter.</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation parameter.</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_alpha">alpha</code></td>
<td>
<p>Smoothness parameter (1 or 2).</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_graph">graph</code></td>
<td>
<p>A <code>metric_graph</code> object.</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_bc">BC</code></td>
<td>
<p>boundary conditions</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_include_vertices">include_vertices</code></td>
<td>
<p>Should the variance at the vertices locations be included in the returned vector?</p>
</td></tr>
<tr><td><code id="spde_variance_+3A_directional">directional</code></td>
<td>
<p>bool is the model a directional or not. directional only works for alpha=1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the variance <code class="reqn">\rho(s_i,s_i)</code> where
<code class="reqn">s_i</code> are all locations in the mesh
of the graph.
</p>


<h3>Value</h3>

<p>Vector with the variance function evaluate at the mesh locations.
</p>

<hr>
<h2 id='stlpp.to.graph'>Convert an <code>stlpp</code> object to a metric graph object</h2><span id='topic+stlpp.to.graph'></span>

<h3>Description</h3>

<p>This function converts an <code>stlpp</code> object (from the <code>stlnpp</code> package) into a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlpp.to.graph(stlpp.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stlpp.to.graph_+3A_stlpp.obj">stlpp.obj</code></td>
<td>
<p>An <code>stlpp</code> object to be converted.</p>
</td></tr>
<tr><td><code id="stlpp.to.graph_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code>metric_graph</code> constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A metric graph object
</p>

<hr>
<h2 id='summarise.metric_graph_data'>A version of <code>dplyr::summarise()</code> function for datasets on metric graphs</h2><span id='topic+summarise.metric_graph_data'></span><span id='topic+summarise'></span>

<h3>Description</h3>

<p>Creates summaries, while keeps the spatial positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_data'
summarise(.data, ..., .include_graph_groups = FALSE, .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.metric_graph_data_+3A_.data">.data</code></td>
<td>
<p>The data list or <code>tidyr::tibble</code> obtained from a metric graph object.</p>
</td></tr>
<tr><td><code id="summarise.metric_graph_data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>dplyr::summarise()</code>.</p>
</td></tr>
<tr><td><code id="summarise.metric_graph_data_+3A_.include_graph_groups">.include_graph_groups</code></td>
<td>
<p>Should the internal graph groups be included in the grouping variables? The default is <code>FALSE</code>. This means that, when summarising, the data will be grouped by the internal group variable together with the spatial locations.</p>
</td></tr>
<tr><td><code id="summarise.metric_graph_data_+3A_.groups">.groups</code></td>
<td>
<p>A vector of strings containing the names of the columns to be additionally grouped, when computing the summaries. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyr::tibble</code> with the resulting selected columns.
</p>

<hr>
<h2 id='summary.graph_lme'>Summary Method for <code>graph_lme</code> Objects</h2><span id='topic+summary.graph_lme'></span>

<h3>Description</h3>

<p>Function providing a summary of results related to metric graph
mixed effects regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graph_lme'
summary(object, all_times = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.graph_lme_+3A_object">object</code></td>
<td>
<p>an object of class <code>graph_lme</code> containing results from the
fitted model.</p>
</td></tr>
<tr><td><code id="summary.graph_lme_+3A_all_times">all_times</code></td>
<td>
<p>Show all computed times.</p>
</td></tr>
<tr><td><code id="summary.graph_lme_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary_graph_lme</code> containing information
about a <em>graph_lme</em> object.
</p>

<hr>
<h2 id='summary.metric_graph'>Summary Method for <code>metric_graph</code> Objects</h2><span id='topic+summary.metric_graph'></span>

<h3>Description</h3>

<p>Function providing a summary of several informations/characteristics of a metric graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph'
summary(
  object,
  messages = FALSE,
  compute_characteristics = NULL,
  check_euclidean = NULL,
  check_distance_consistency = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.metric_graph_+3A_object">object</code></td>
<td>
<p>an object of class <code>metric_graph</code>.</p>
</td></tr>
<tr><td><code id="summary.metric_graph_+3A_messages">messages</code></td>
<td>
<p>Should message explaining how to build the results be given for missing quantities?</p>
</td></tr>
<tr><td><code id="summary.metric_graph_+3A_compute_characteristics">compute_characteristics</code></td>
<td>
<p>Should the characteristics of the graph be computed? If <code>NULL</code> it will be determined based on the size of the graph.</p>
</td></tr>
<tr><td><code id="summary.metric_graph_+3A_check_euclidean">check_euclidean</code></td>
<td>
<p>Check if the graph has Euclidean edges? If <code>NULL</code> it will be determined based on the size of the graph.</p>
</td></tr>
<tr><td><code id="summary.metric_graph_+3A_check_distance_consistency">check_distance_consistency</code></td>
<td>
<p>Check the distance consistency assumption?#' If <code>NULL</code> it will be determined based on the size of the graph.</p>
</td></tr>
<tr><td><code id="summary.metric_graph_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary_graph_lme</code> containing information
about a <em>metric_graph</em> object.
</p>

<hr>
<h2 id='summary.metric_graph_spde_result'>Summary for posteriors of field parameters for an <code>inla_rspde</code>
model from a <code>rspde.result</code> object</h2><span id='topic+summary.metric_graph_spde_result'></span>

<h3>Description</h3>

<p>Summary for posteriors of 'rSPDE' field parameters in
their original scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metric_graph_spde_result'
summary(object, digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.metric_graph_spde_result_+3A_object">object</code></td>
<td>
<p>A <code>rspde.result</code> object.</p>
</td></tr>
<tr><td><code id="summary.metric_graph_spde_result_+3A_digits">digits</code></td>
<td>
<p>Integer, used for number formatting with signif()</p>
</td></tr>
<tr><td><code id="summary.metric_graph_spde_result_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the summary.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
