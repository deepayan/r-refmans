<!DOCTYPE html><html lang="en"><head><title>Help for package tidync</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidync}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidync-package'><p>tidync: A Tidy Approach to 'NetCDF' Data Exploration and Extraction</p></a></li>
<li><a href='#activate'><p>Activate a NetCDF grid</p></a></li>
<li><a href='#hyper_array'><p>Extract NetCDF data as an array</p></a></li>
<li><a href='#hyper_filter'><p>Subset NetCDF variable by expression</p></a></li>
<li><a href='#hyper_tbl_cube'><p>A dplyr cube tbl</p></a></li>
<li><a href='#hyper_tibble'><p>Extract NetCDF data as an expanded table.</p></a></li>
<li><a href='#hyper_transforms'><p>Axis transforms</p></a></li>
<li><a href='#hyper_vars'><p>Grid status</p></a></li>
<li><a href='#nc_get'><p>Helper to get a variable from NetCDF.</p></a></li>
<li><a href='#print.tidync'><p>Print tidync object</p></a></li>
<li><a href='#print.tidync_data'><p>Print tidync data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tidync'><p>Tidy NetCDF</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Tidy Approach to 'NetCDF' Data Exploration and Extraction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tidy tools for 'NetCDF' data sources. Explore the contents of a 
 'NetCDF' source (file or URL) presented as variables organized by grid with a 
 database-like interface. The hyper_filter() interactive function translates the 
 filter value or index expressions to array-slicing form. No data is read until 
 explicitly requested, as a data frame or list of arrays via hyper_tibble() or 
 hyper_array(). </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.0), forcats, magrittr, ncdf4, ncmeta (&ge; 0.2.0),
purrr, RNetCDF (&ge; 1.9-1), rlang, tibble, tidyr, CFtime (&ge;
1.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, testthat, covr, cubelyr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>netcdf udunits-2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/tidync/">https://docs.ropensci.org/tidync/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/tidync/issues">https://github.com/ropensci/tidync/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-17 07:41:00 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Sumner [aut, cre],
  Simon Wotherspoon [ctb],
  Tomas Remenyi [ctb],
  Ben Raymond [ctb],
  Jakub Nowosad [ctb],
  Tim Lucas [ctb],
  Hadley Wickham [ctb],
  Adrian Odenweller [ctb],
  Patrick Van Laake [ctb],
  Fabian Bernhard [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-17 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidync-package'>tidync: A Tidy Approach to 'NetCDF' Data Exploration and Extraction</h2><span id='topic+tidync-package'></span>

<h3>Description</h3>

<p>Tidy tools for 'NetCDF' data sources. Explore the contents of a 'NetCDF' source (file or URL) presented as variables organized by grid with a database-like interface. The hyper_filter() interactive function translates the filter value or index expressions to array-slicing form. No data is read until explicitly requested, as a data frame or list of arrays via hyper_tibble() or hyper_array().
</p>
<p>Provides easy to use idioms for working with NetCDF data for extraction,
manipulation and visualization. NetCDF is Network Common Data Form
<a href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a>.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+print.tidync">print.tidync()</a></code> for details on the printed version of a tidync object.
</p>
<p>There is a family of functions &quot;hyper_verb&quot; around exploring and
extracting data.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+active">active</a></code> </td><td style="text-align: left;"> report the currently active grid </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+activate">activate</a></code> </td><td style="text-align: left;"> active a grid </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+tidync">tidync</a></code> </td><td style="text-align: left;"> core NetCDF source object for tidync functions</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_filter">hyper_filter</a></code> </td><td style="text-align: left;"> apply dimension expressions to specify array slices</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_array">hyper_array</a></code> </td><td style="text-align: left;"> extracts a raw data array based on a NetCDF index </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_tbl_cube">hyper_tbl_cube</a></code> </td><td style="text-align: left;"> extracts data as a dplyr tbl_cube </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_tibble">hyper_tibble</a></code> </td><td style="text-align: left;"> extracts data as a data frame with all dimension values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_transforms">hyper_transforms</a></code> </td><td style="text-align: left;"> extract the active (or all) dimension transforms</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_vars">hyper_vars</a></code> </td><td style="text-align: left;"> information on active variables </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_dims">hyper_dims</a></code> </td><td style="text-align: left;"> information on active dimensions </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+hyper_grids">hyper_grids</a></code> </td><td style="text-align: left;"> information on grids </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The scheme generally processes dimension filters into NetCDF extraction
indexes and these are always available to each function, and are expressed
in printed output.
</p>
<p>The following options are available.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>tidync.large.data.check = TRUE/FALSE</code> </td><td style="text-align: left;"> check for large data extraction (default <code>TRUE</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tidync.silent = FALSE/TRUE</code> </td><td style="text-align: left;"> emit warnings,messages or be silent (default <code>FALSE</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Simon Wotherspoon [contributor]
</p>
</li>
<li><p> Tomas Remenyi [contributor]
</p>
</li>
<li><p> Ben Raymond [contributor]
</p>
</li>
<li><p> Jakub Nowosad [contributor]
</p>
</li>
<li><p> Tim Lucas [contributor]
</p>
</li>
<li><p> Hadley Wickham [contributor]
</p>
</li>
<li><p> Adrian Odenweller [contributor]
</p>
</li>
<li><p> Patrick Van Laake [contributor]
</p>
</li>
<li><p> Fabian Bernhard [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/tidync/">https://docs.ropensci.org/tidync/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/tidync/issues">https://github.com/ropensci/tidync/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>argofile &lt;- system.file("extdata/argo/MD5903593_001.nc", package = "tidync")
argo &lt;- tidync(argofile)
argo %&gt;% active()
argo %&gt;% activate("D3,D8") %&gt;% hyper_array()
argo %&gt;% hyper_filter(N_LEVELS = index &lt; 4)
argo %&gt;% hyper_tbl_cube()
argo %&gt;% hyper_tibble(select_var = c("TEMP_QC"))
argo %&gt;% hyper_transforms()
argo %&gt;% hyper_vars()
argo %&gt;% hyper_dims()
argo %&gt;% hyper_grids()

## some global options
getOption("tidync.large.data.check")

getOption("tidync.silent")
op &lt;- options(tidync.silent = TRUE)
getOption("tidync.silent")
options(op)
</code></pre>

<hr>
<h2 id='activate'>Activate a NetCDF grid</h2><span id='topic+activate'></span><span id='topic+active'></span><span id='topic+active+3C-'></span><span id='topic+activate.tidync'></span><span id='topic+active.tidync'></span><span id='topic+active.default'></span><span id='topic+active+3C-.default'></span>

<h3>Description</h3>

<p>A grid in NetCDF is a particular shape and size available for array
variables, and consists of sets of dimensions. To activate a grid is to set
the context for downstream operations, for querying, summarizing and reading
data. There's no sense in performing these operations on more than one grid
at a time, but multiple variables may exist in a single grid. There may be
only one significant grid in a source or many, individual dimensions are
themselves grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate(.data, what, ..., select_var = NULL)

## S3 method for class 'tidync'
activate(.data, what, ..., select_var = NULL)

## S3 method for class 'tidync'
active(x)

active(x)

## Default S3 method:
active(x)

active(x) &lt;- value

## Default S3 replacement method:
active(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activate_+3A_.data">.data</code></td>
<td>
<p>NetCDF object</p>
</td></tr>
<tr><td><code id="activate_+3A_what">what</code></td>
<td>
<p>name of a grid or variable</p>
</td></tr>
<tr><td><code id="activate_+3A_...">...</code></td>
<td>
<p>reserved, currently ignored</p>
</td></tr>
<tr><td><code id="activate_+3A_select_var">select_var</code></td>
<td>
<p>optional argument to set selected state of variable/s by
name</p>
</td></tr>
<tr><td><code id="activate_+3A_x">x</code></td>
<td>
<p>NetCDF object</p>
</td></tr>
<tr><td><code id="activate_+3A_value">value</code></td>
<td>
<p>name of grid or variable to be active</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There may be more than one grid and one is always activated by default. A
grid may be activated by name in the form of 'D1,D0' where one or more
numbered dimensions indicates the grid. The grid definition names are printed
as part of the summary of in the tidync object and may be obtained directly
with <code><a href="#topic+hyper_grids">hyper_grids()</a></code> on the tidync object.
</p>
<p>Activation of a grid sets the context for downstream operations (slicing and
reading data) from NetCDF, and as there may be several grids in a single
source activation allows a different choice of available variables.  By
default the largest grid is activated. Once activated, all downstream tasks
apply to the set of variables that exist on that grid.
</p>
<p>If <code><a href="#topic+activate">activate()</a></code> is called with a variable name, it puts the variable first.
The function <code><a href="#topic+active">active()</a></code> gets and sets the active grid. To restrict ultimate
read to particular variables use the <code>select_var</code> argument to
<code><a href="#topic+hyper_filter">hyper_filter()</a></code>, <code><a href="#topic+hyper_tibble">hyper_tibble()</a></code> and <code><a href="#topic+hyper_tbl_cube">hyper_tbl_cube()</a></code>.
</p>
<p>Scalar variables are not currently available to tidync, and it's not obvious
how activation would occur for scalars, but in future perhaps <code>activate("S")</code>
could be the right way forward.
</p>


<h3>Value</h3>

<p>NetCDF object
</p>


<h3>See Also</h3>

<p>hyper_filter hyper_tibble hyper_tbl_cube
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!tolower(Sys.info()[["sysname"]]) == "sunos") {
 l3file &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
 rnc &lt;- tidync(system.file("extdata", "oceandata", l3file,
 package = "tidync"))
 activate(rnc, "palette")

 ## extract available grid names
 hyper_grids(rnc)
}
</code></pre>

<hr>
<h2 id='hyper_array'>Extract NetCDF data as an array</h2><span id='topic+hyper_array'></span><span id='topic+tidync_data'></span><span id='topic+hyper_slice'></span><span id='topic+hyper_array.tidync'></span><span id='topic+hyper_array.character'></span>

<h3>Description</h3>

<p>Extract the raw array data as a list of  one or more arrays. This can be the
entire variable/s or after dimension-slicing using <code><a href="#topic+hyper_filter">hyper_filter()</a></code>
expressions. This is a delay-breaking function and causes data to be read
from the source into R native arrays. This list of arrays is
lightly classed as <a href="#topic+tidync_data">tidync_data</a>, with methods for <code><a href="base.html#topic+print">print()</a></code> and <code><a href="#topic+tidync">tidync()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_array(
  x,
  select_var = NULL,
  ...,
  raw_datavals = FALSE,
  force = FALSE,
  drop = TRUE
)

hyper_slice(
  x,
  select_var = NULL,
  ...,
  raw_datavals = FALSE,
  force = FALSE,
  drop = TRUE
)

## S3 method for class 'tidync'
hyper_array(
  x,
  select_var = NULL,
  ...,
  raw_datavals = FALSE,
  force = FALSE,
  drop = TRUE
)

## S3 method for class 'character'
hyper_array(
  x,
  select_var = NULL,
  ...,
  raw_datavals = FALSE,
  force = FALSE,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_array_+3A_x">x</code></td>
<td>
<p>NetCDF file, connection object, or <a href="#topic+tidync">tidync</a> object</p>
</td></tr>
<tr><td><code id="hyper_array_+3A_select_var">select_var</code></td>
<td>
<p>optional vector of variable names to select</p>
</td></tr>
<tr><td><code id="hyper_array_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+hyper_filter">hyper_filter()</a></code></p>
</td></tr>
<tr><td><code id="hyper_array_+3A_raw_datavals">raw_datavals</code></td>
<td>
<p>logical to control whether scaling in the NetCDF is
applied or not</p>
</td></tr>
<tr><td><code id="hyper_array_+3A_force">force</code></td>
<td>
<p>ignore caveats about large extraction and just do it</p>
</td></tr>
<tr><td><code id="hyper_array_+3A_drop">drop</code></td>
<td>
<p>collapse degenerate dimensions, defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+hyper_array">hyper_array()</a></code> is used by <code><a href="#topic+hyper_tibble">hyper_tibble()</a></code> and <code><a href="#topic+hyper_tbl_cube">hyper_tbl_cube()</a></code>
to actually extract data arrays from NetCDF, if a result would be particularly large
there is a check made and user-opportunity to cancel. This is controllable as an
option <code>getOption('tidync.large.data.check')</code>, and can be set to never check with
<code>options(tidync.large.data.check = FALSE)</code>.
</p>
<p>The function <code><a href="#topic+hyper_array">hyper_array()</a></code> will act on an existing tidync object or a source
string.
</p>
<p>By default all variables in the active grid are returned, use <code>select_var</code> to
specify one or more desired variables.
</p>
<p>The transforms are stored as a list of tables in an attribute 'transforms&ldquo;,
access these with <code><a href="#topic+hyper_transforms">hyper_transforms()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.tidync_data">print.tidync_data</a> for a description of the print summary,
<code><a href="#topic+hyper_tbl_cube">hyper_tbl_cube()</a></code> and <code><a href="#topic+hyper_tibble">hyper_tibble()</a></code> which are also delay-breaking
functions that cause data to be read
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
l3file &lt;- system.file("extdata/oceandata", f, package= "tidync")

## extract a raw list by filtered dimension
library(dplyr)
araw1 &lt;- tidync(l3file) %&gt;%
 hyper_filter(lat = between(lat, -78, -75.8), 
              lon = between(lon, 165, 171)) %&gt;%
 hyper_array()

araw &lt;- tidync(l3file) %&gt;% 
         hyper_filter(lat = abs(lat) &lt; 10, 
                     lon = index &lt; 100) %&gt;%
  hyper_array()

## hyper_array will pass the expressions to hyper_filter
braw &lt;- tidync(l3file) %&gt;% 
  hyper_array(lat = abs(lat) &lt; 10, lon = index &lt; 100)

## get the transforms tables (the axis coordinates)
lapply(attr(braw, "transforms"), 
   function(x) nrow(dplyr::filter(x, selected)))
## the selected axis coordinates should match in order and in size
lapply(braw, dim)
</code></pre>

<hr>
<h2 id='hyper_filter'>Subset NetCDF variable by expression</h2><span id='topic+hyper_filter'></span><span id='topic+hyper_filter.tidync'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+hyper_filter">hyper_filter()</a></code> acts on a <a href="#topic+tidync">tidync</a> object by matching one or more
filtering expressions like with <code>dplyr::filter</code>. This allows us to lazily
specify a subset from a NetCDF array without pulling  any data. The modified
object may be printed to see the effects of subsetting, or saved for further
use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_filter(.x, ...)

## S3 method for class 'tidync'
hyper_filter(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_filter_+3A_.x">.x</code></td>
<td>
<p>NetCDF file, connection object, or <code>tidync</code> object</p>
</td></tr>
<tr><td><code id="hyper_filter_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+hyper_filter">hyper_filter()</a></code> will act on an existing tidync object or a
source string.
</p>
<p>Filter arguments must be named as per the dimensions in the variable in form
<code>dimname = dimname &lt; 10</code>. This is a restrictive variant of <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>,
with a syntax more like <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>. This ensures that each element is
named, so we know which dimension to apply this to, but also that the
expression evaluated against can do some extra work for a nuanced test.
</p>
<p>There are special columns provided with each axis, one is 'index' so that
exact matching can be done by position, or to ignore the actual value of the
coordinate. That means we can use a form like <code>dimname = index &lt; 10</code> to
subset by position in the array index, without necessarily knowing the
values along that dimension.
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
l3file &lt;- system.file("extdata/oceandata", f, package= "tidync")
## filter by value
tidync(l3file) %&gt;% hyper_filter(lon = lon &lt; 100)
## filter by index
tidync(l3file) %&gt;% hyper_filter(lon = index &lt; 100)

## be careful that multiple comparisons must occur in one expression
 tidync(l3file) %&gt;% hyper_filter(lon = lon &lt; 100 &amp; lon &gt; 50)

## filter in combination/s
tidync(l3file) %&gt;% hyper_filter(lat = abs(lat) &lt; 10, lon = index &lt; 100)
</code></pre>

<hr>
<h2 id='hyper_tbl_cube'>A dplyr cube tbl</h2><span id='topic+hyper_tbl_cube'></span><span id='topic+hyper_tbl_cube.tidync'></span><span id='topic+hyper_tbl_cube.character'></span>

<h3>Description</h3>

<p>Produce a <a href="cubelyr.html#topic+tbl_cube">tbl_cube</a> from NetCDF. This is a
delay-breaking function and causes data to be read from the source
into the tbl cube format defined in the <a href="cubelyr.html#topic+tbl_cube">dplyr</a>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_tbl_cube(x, ..., force = FALSE)

## S3 method for class 'tidync'
hyper_tbl_cube(x, ..., force = FALSE)

## S3 method for class 'character'
hyper_tbl_cube(x, ..., force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_tbl_cube_+3A_x">x</code></td>
<td>
<p>tidync object</p>
</td></tr>
<tr><td><code id="hyper_tbl_cube_+3A_...">...</code></td>
<td>
<p>arguments for <code><a href="#topic+hyper_filter">hyper_filter()</a></code></p>
</td></tr>
<tr><td><code id="hyper_tbl_cube_+3A_force">force</code></td>
<td>
<p>ignore caveats about large extraction and just do it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of an extraction is checked and if <em>quite large</em> there is an a user-controlled
prompt to proceed or cancel. This can be disabled with <code>options(tidync.large.data.check = FALSE)</code>
</p>

<ul>
<li><p> please see <code><a href="#topic+hyper_array">hyper_array()</a></code> for more details.
</p>
</li></ul>

<p>The tbl cube is a very general and arbitrarily-sized array that
can be used with tidyverse functionality. Dimension coordinates are
stored with the tbl cube, derived from the grid
<a href="#topic+hyper_transforms">transforms</a>.
</p>


<h3>Value</h3>

<p>tbl_cube
</p>
<p><code>dplyr::tbl_cube</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper_array">hyper_array()</a></code> and <code><a href="#topic+hyper_tibble">hyper_tibble()</a></code> which are also delay-breaking
functions that cause data to be read
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
l3file &lt;- system.file("extdata/oceandata", f, package= "tidync")
(cube &lt;- hyper_tbl_cube(tidync(l3file) %&gt;%
activate(chlor_a), lon = lon &gt; 107, lat = abs(lat) &lt; 30))
ufile &lt;- system.file("extdata", "unidata", "test_hgroups.nc", 
 package = "tidync", mustWork = TRUE)
 
## some versions of NetCDF don't support this file
## (4.1.3 tidync/issues/82)
group_nc &lt;- try(tidync(ufile), silent = TRUE)
if (!inherits(group_nc, "try-error")) {
 res &lt;-  hyper_tbl_cube(tidync(ufile))
 print(res)
} else {
 ## the error was
 writeLines(c(group_nc))
}
</code></pre>

<hr>
<h2 id='hyper_tibble'>Extract NetCDF data as an expanded table.</h2><span id='topic+hyper_tibble'></span><span id='topic+hyper_tibble.character'></span><span id='topic+hyper_tibble.tidync'></span>

<h3>Description</h3>

<p>Extract the raw array data as an expanded data frame. This can be the entire
variable/s or after dimension-slicing using <code><a href="#topic+hyper_filter">hyper_filter()</a></code> expressions with
dimension values expanded appropriately for each element in the arrays (one
row per element).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_tibble(x, ..., na.rm = TRUE, force = FALSE)

## S3 method for class 'character'
hyper_tibble(x, ..., na.rm = TRUE, force = FALSE)

## S3 method for class 'tidync'
hyper_tibble(x, ..., na.rm = TRUE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_tibble_+3A_x">x</code></td>
<td>
<p>NetCDF file, connection object, or <code>tidync</code> object</p>
</td></tr>
<tr><td><code id="hyper_tibble_+3A_...">...</code></td>
<td>
<p>arguments to 'hyper_filter&ldquo;</p>
</td></tr>
<tr><td><code id="hyper_tibble_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> these rows are not included in the output when all
variables are <code>NA</code></p>
</td></tr>
<tr><td><code id="hyper_tibble_+3A_force">force</code></td>
<td>
<p>ignore caveats about large extraction and just do it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of an extraction is checked and if <em>quite large</em> there is an a user-controlled
prompt to proceed or cancel. This can be disabled with <code>options(tidync.large.data.check = FALSE)</code>
</p>

<ul>
<li><p> please see <code><a href="#topic+hyper_array">hyper_array()</a></code> for more details.
</p>
</li></ul>

<p>The function <code><a href="#topic+hyper_tibble">hyper_tibble()</a></code> will act on an existing tidync object or a source
string.
</p>
<p>By default all variables in the active grid are returned, use <code>select_var</code> to
limit.
</p>


<h3>Value</h3>

<p>a <code>tbl_df</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper_array">hyper_array()</a></code> and <code><a href="#topic+hyper_tbl_cube">hyper_tbl_cube()</a></code>  which are also delay-breaking
functions that cause data to be read
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l3file &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
f &lt;- system.file("extdata", "oceandata", l3file, package= "tidync")
rnc &lt;- tidync(f)
hyper_filter(rnc)
library(dplyr)
lapply(hyper_array(f, lat = lat &gt; 0, lon = index &gt; 3000), dim)

 ht &lt;- hyper_tibble(rnc) %&gt;%
 filter(!is.na(chlor_a))
ht
library(ggplot2)
ggplot(ht %&gt;% filter(!is.na(chlor_a)),
aes(x = lon, y = lat, fill = chlor_a)) + geom_tile()
</code></pre>

<hr>
<h2 id='hyper_transforms'>Axis transforms</h2><span id='topic+hyper_transforms'></span><span id='topic+hyper_transforms.default'></span>

<h3>Description</h3>

<p>Axis 'transforms' are data frames of each dimension in a NetCDF source.
<code>hyper_transforms</code> returns a list of the active transforms by default,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_transforms(x, all = FALSE, ...)

## Default S3 method:
hyper_transforms(x, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_transforms_+3A_x">x</code></td>
<td>
<p>tidync object</p>
</td></tr>
<tr><td><code id="hyper_transforms_+3A_all">all</code></td>
<td>
<p>set to <code>TRUE</code> to return all transforms, not only active ones</p>
</td></tr>
<tr><td><code id="hyper_transforms_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each transform is available by name from a list, and each data frame has the
coordinate of the dimension, its index, and a 'selected' variable set by the
filtering expressions in <code>hyper_filter</code> and used by the read-functions
<code>hyper_array</code> and <code>hyper_tibble</code>.
</p>
<p>Use <code>hyper_transforms</code> to interrogate and explore the available dimension
manually, or for development of custom functions.
</p>


<h3>Value</h3>

<p>list of axis transforms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l3file &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
f &lt;- system.file("extdata", "oceandata", l3file, package = "tidync")
ax &lt;- tidync(f) %&gt;% hyper_transforms()
names(ax)
lapply(ax, dim)

## this function returns the transforms tidync knows about for this source
str(tidync(f)$transforms)
names(hyper_transforms(tidync(f), all = TRUE))
</code></pre>

<hr>
<h2 id='hyper_vars'>Grid status</h2><span id='topic+hyper_vars'></span><span id='topic+hyper_dims'></span><span id='topic+hyper_grids'></span>

<h3>Description</h3>

<p>Functions to report on the current status of the <code>active</code> grid. Information
on the active dimensions and variables are listed in a data frame with
multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_vars(x, ...)

hyper_dims(x, ...)

hyper_grids(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper_vars_+3A_x">x</code></td>
<td>
<p>tidync object</p>
</td></tr>
<tr><td><code id="hyper_vars_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimensions and variables of the active grid are identified in the
<a href="#topic+print.tidync">print</a> method of the tidync object, these functions exist to
provide that information directly.
</p>
<p><code>hyper_vars()</code> will list the ids, data type, name, dimension number, number
of attributes and and coordinate status of the variables on the currently
active grid.
</p>
<p><code>hyper_dims()</code> will list the names, lengths, start/count index, ids, and
status of dimensions on the currently active grid. records on the currently
active dimensions.
</p>
<p><code>hyper_grids()</code> will list the names, number of dimension, and number of
variables and active status of each grid in the source.
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
l3file &lt;- system.file("extdata/oceandata", f, package= "tidync")
tnc &lt;- tidync(l3file)
hyper_vars(tnc)
hyper_dims(tnc)
hyper_dims(tnc %&gt;% hyper_filter(lat = lat &lt; 20))
</code></pre>

<hr>
<h2 id='nc_get'>Helper to get a variable from NetCDF.</h2><span id='topic+nc_get'></span>

<h3>Description</h3>

<p>This exists so we can (internally) use a file path, uri, or open
NetCDF connection (ncdf4 or RNetCDF) in a simpler way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_get(x, v, test = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nc_get_+3A_x">x</code></td>
<td>
<p>file path, uri, or NetCDF connection</p>
</td></tr>
<tr><td><code id="nc_get_+3A_v">v</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="nc_get_+3A_test">test</code></td>
<td>
<p>if true we make sure the connection can be open, not applied for connections themselves</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just reads the whole array. It is equivalent to the
angstroms package function 'rawdata(x, varname)'.
</p>

<hr>
<h2 id='print.tidync'>Print tidync object</h2><span id='topic+print.tidync'></span>

<h3>Description</h3>

<p>Provide a summary of variables and dimensions, organized by their 'grid' (or
'shape') and with a summary of any slicing operations provided as 'start' and
'count' summaries for each dimension in the active grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidync'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tidync_+3A_x">x</code></td>
<td>
<p>NetCDF object</p>
</td></tr>
<tr><td><code id="print.tidync_+3A_...">...</code></td>
<td>
<p>reserved</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+tidync">tidync</a> for detail about the object, and
<a href="#topic+hyper_vars">hyper_vars</a> for programmatic access to the active grid's
variable and dimension information.
</p>
<p>The print summary is organized in two sections, the first is available grids
(sets of dimensions) and their associated variables, the second is the
dimensions, separated into active and inactive. All dimensions may be active
in some NetCDF sources.
</p>
<p>Individual <em>active</em> dimensions include the following components: * 'dim'    -
dimension label, D0, D1, D2, ... * 'name'   - dimension name * 'length' -
size of the dimension * 'min'    - minimum value of the dimension * 'max' -
maximum value of the dimension * 'start'  - start index of subsetting *
'count'  - length of subsetting index * 'dmin'   - minimum value of the
subset dimension * 'dmax'   - maximum value of the subset dimension * 'unlim'
</p>

<ul>
<li><p> indicates whether dimension is unlimited (spread across other files,
usually the time-step) * 'coord_dim' - indicates whether dimension is a
coordinate-dimension (i.e. listed as a 1-D grid)
</p>
</li></ul>

<p>The <em>inactive</em> dimension summary does not include 'start', 'count', 'dmin',
'dmax' as these are identical to the values of 1, 'length', 'min', 'max' when
no array subsetting has been applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>argofile &lt;- system.file("extdata/argo/MD5903593_001.nc", package = "tidync")
argo &lt;- tidync(argofile)
print(argo)

## the print is modified by choosing a new grid or running filters
argo %&gt;% activate("D7,D9,D11,D8")

argo %&gt;% hyper_filter(N_LEVELS = index &gt; 300)
</code></pre>

<hr>
<h2 id='print.tidync_data'>Print tidync data</h2><span id='topic+print.tidync_data'></span>

<h3>Description</h3>

<p>Print method for the 'tidync_data' list of arrays returned by <code><a href="#topic+hyper_array">hyper_array()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidync_data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tidync_data_+3A_x">x</code></td>
<td>
<p>'tidync_data' object (from <code><a href="#topic+hyper_array">hyper_array()</a></code>)</p>
</td></tr>
<tr><td><code id="print.tidync_data_+3A_...">...</code></td>
<td>
<p>reserved args</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output lists the variables and their dimensions of an object from a
previous call to <code><a href="#topic+tidync">tidync()</a></code>, and possibly <code><a href="#topic+hyper_filter">hyper_filter()</a></code>. The available
data will differ from the source in terms of variables (via <code>select_var</code> in
<a href="#topic+hyper_array">hyper_array</a>) and the lengths of each dimension (via named expressions in
<code><a href="#topic+hyper_filter">hyper_filter()</a></code>).
</p>


<h3>Value</h3>

<p>the input object invisibly
</p>


<h3>See Also</h3>

<p>tidync_data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>argofile &lt;- system.file("extdata/argo/MD5903593_001.nc", package = "tidync")
argodata &lt;- tidync(argofile) %&gt;% hyper_filter(N_LEVELS = index &lt; 5) %&gt;% 
              hyper_array(select_var = c("TEMP_ADJUSTED", "PRES"))
print(argodata)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("extdata/argo/MD5903593_001.nc", package = "tidync") %&gt;% 
     tidync()
</code></pre>

<hr>
<h2 id='tidync'>Tidy NetCDF</h2><span id='topic+tidync'></span><span id='topic+tidync.character'></span><span id='topic+tidync.tidync_data'></span>

<h3>Description</h3>

<p>Connect to a NetCDF source and allow use of <code style="white-space: pre;">&#8288;hyper_*&#8288;</code> verbs for slicing with
<code><a href="#topic+hyper_filter">hyper_filter()</a></code>, extracting data with <code><a href="#topic+hyper_array">hyper_array()</a></code> and  [hyper_tibble()
from an activated grid. By default the largest <em>grid</em> encountered is
activated, see<code><a href="#topic+activate">activate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidync(x, what, ...)

## S3 method for class 'character'
tidync(x, what, ...)

## S3 method for class 'tidync_data'
tidync(x, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidync_+3A_x">x</code></td>
<td>
<p>path to a NetCDF file</p>
</td></tr>
<tr><td><code id="tidync_+3A_what">what</code></td>
<td>
<p>(optional) character name of grid (see <code>ncmeta::nc_grids</code>) or
(bare) name of variable (see <code>ncmeta::nc_vars</code>) or index of grid to
<code>activate</code></p>
</td></tr>
<tr><td><code id="tidync_+3A_...">...</code></td>
<td>
<p>reserved for arguments to methods, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method for tidync includes a lot of information about which
variables exist on which dimensions, and if any slicing (<code><a href="#topic+hyper_filter">hyper_filter()</a></code>)
operations have occurred these are summarized as 'start' and 'count'
modifications relative to the dimension lengths. See <a href="#topic+print.tidync">print</a>
for these details, and <a href="#topic+hyper_vars">hyper_vars</a> for programmatic access to
this information
</p>
<p>Many NetCDF forms are supported and tidync tries to reduce the interpretation
applied to a given source. The NetCDF system defines a 'grid' for storing
array data, where 'grid' is the array 'shape', or 'set of dimensions'). There
may be several grids in a single source and so we introduce the concept of
grid 'activation'. Once activated, all downstream tasks apply to the set of
variables that exist on that grid.
</p>
<p>NetCDF sources with numeric types are chosen by default, even if existing
'NC_CHAR' type variables are on the largest grid. When read any 'NC_CHAR'
type variables are exploded into single character elements so that dimensions
match the source.
</p>


<h3>Grids</h3>

<p>A grid is an instance of a particular set of dimensions,
which can be shared by more than one variable. This is not the 'rank' of a
variable (the number of dimensions) since a single data set may have many
3D variables composed of different sets of axes/dimensions. There's no
formality around the concept of 'shape', as far as we know.
</p>
<p>A dimension may have length zero, but this is a special case for a
&quot;measure&quot; dimension, we think. (It doesn't mean the product of the
dimensions is zero, for example).
</p>


<h3>Limitations</h3>

<p>Files with compound types are not yet supported and
should fail gracefully. Groups are not yet supported.
</p>
<p>We haven't yet explored 'HDF5' in detail, so any feedback is appreciated.
Major use of compound types is made by <a href="https://github.com/sosoc/croc">https://github.com/sosoc/croc</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a SeaWiFS (S) Level-3 Mapped (L3m) monthly (MO) chlorophyll-a (CHL)
## remote sensing product at 9km resolution (at the equator)
## from the NASA ocean colour group in NetCDF4 format (.nc)
## for 31 day period January 2008 (S20080012008031) 
f &lt;- "S20080012008031.L3m_MO_CHL_chlor_a_9km.nc"
l3file &lt;- system.file("extdata/oceandata", f, package= "tidync")
## skip on Solaris
if (!tolower(Sys.info()[["sysname"]]) == "sunos") {
tnc &lt;- tidync(l3file)
print(tnc)
}

## very simple Unidata example file, with one dimension
## Not run: 
uf &lt;- system.file("extdata/unidata", "test_hgroups.nc", package = "tidync")
recNum &lt;- tidync(uf) %&gt;% hyper_tibble()
print(recNum)

## End(Not run)
## a raw grid of Southern Ocean sea ice concentration from IFREMER
## it is 12.5km resolution passive microwave concentration values
## on a polar stereographic grid, on 2 October 2017, displaying the 
## "hole in the ice" made famous here:
## https://tinyurl.com/ycbchcgn
ifr &lt;- system.file("extdata/ifremer", "20171002.nc", package = "tidync")
ifrnc &lt;- tidync(ifr)
ifrnc %&gt;% hyper_tibble(select_var = "concentration")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
