<!DOCTYPE html><html lang="en"><head><title>Help for package hlaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hlaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalAlleleMismFreq'><p>Evaluate the frequency of specific allele mismatches</p></a></li>
<li><a href='#CalAlleleTopN'><p>topN most frequent HLA alleles</p></a></li>
<li><a href='#CalEpletMHCI'><p>Calculate class I HLA eplet mismatch</p></a></li>
<li><a href='#CalEpletMHCII'><p>Calculate class II HLA eplet mismatch.</p></a></li>
<li><a href='#CleanAllele'><p>Clean messy HLA typing data</p></a></li>
<li><a href='#CountAlleleMism'><p>Count HLA mismatch at the allele level</p></a></li>
<li><a href='#EvalAlleleMism'><p>Evaluate mismatched alleles</p></a></li>
<li><a href='#ImputeHaplo'><p>Imputation</p></a></li>
<li><a href='#utils'><p>Basic functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for HLA Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A streamlined tool for eplet analysis of donor and recipient HLA (human leukocyte antigen) mismatch. Messy, low-resolution HLA typing data is cleaned, and imputed to high-resolution using the NMDP (National Marrow Donor Program) haplotype reference database <a href="https://haplostats.org/haplostats">https://haplostats.org/haplostats</a>. High resolution data is analyzed for overall or single antigen eplet mismatch using a reference table (currently supporting 'HLAMatchMaker' <a href="http://www.epitopes.net">http://www.epitopes.net</a> versions 2 and 3). Data can enter or exit the workflow at different points depending on the user's aims and initial data quality.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pubmed.ncbi.nlm.nih.gov/35101308/">https://pubmed.ncbi.nlm.nih.gov/35101308/</a>,
<a href="https://emory-larsenlab.shinyapps.io/hlar_shiny/">https://emory-larsenlab.shinyapps.io/hlar_shiny/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LarsenLab/hlaR/issues">https://github.com/LarsenLab/hlaR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools, tidyverse, dplyr, reshape2, schoolmath, tibble,
tidyselect, stringr, purrr, tidyr, utils, readr, janitor</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-31 16:11:49 UTC; xzhan50</td>
</tr>
<tr>
<td>Author:</td>
<td>Joan Zhang [aut, cre],
  Aileen Johnson [aut],
  Christian P Larsen [cph, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joan Zhang &lt;joan.zhang@emory.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-31 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalAlleleMismFreq'>Evaluate the frequency of specific allele mismatches</h2><span id='topic+CalAlleleMismFreq'></span>

<h3>Description</h3>

<p>This function evaluates allele level mismatch between donor and recipient and then presents the most commonly mismatched alleles. This function is most effectively used to study the most common mismatches within a transplant population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAlleleMismFreq(dat_in, nms_don = c(), nms_rcpt = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalAlleleMismFreq_+3A_dat_in">dat_in</code></td>
<td>
<p>A data frame of clean HLA typing data.</p>
</td></tr>
<tr><td><code id="CalAlleleMismFreq_+3A_nms_don">nms_don</code></td>
<td>
<p>A vector of column names of donor's alleles, must be length of 2.</p>
</td></tr>
<tr><td><code id="CalAlleleMismFreq_+3A_nms_rcpt">nms_rcpt</code></td>
<td>
<p>A vector of column names of recipient's alleles, must be length of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of donor's mismatched alleles with frequency &gt; 1. No mismatch is calculated if input alleles are NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.csv(system.file("extdata/example", "HLA_MisMatch_test.csv", package = "hlaR"))
don &lt;- c("donor.a1", "donor.a2")
rcpt &lt;- c("recipient.a1", "recipient.a2")
re &lt;- CalAlleleMismFreq(dat_in = dat, nms_don = don, nms_rcpt = rcpt)
</code></pre>

<hr>
<h2 id='CalAlleleTopN'>topN most frequent HLA alleles</h2><span id='topic+CalAlleleTopN'></span>

<h3>Description</h3>

<p>Input cleaned HLA(Human Leukocyte Antigen) data for a population of transplant donors and recipients to determine the most common alleles represented in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAlleleTopN(dat_in, nms_don = c(), nms_rcpt = c(), top_n = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalAlleleTopN_+3A_dat_in">dat_in</code></td>
<td>
<p>A data frame with clean HLA typing data.</p>
</td></tr>
<tr><td><code id="CalAlleleTopN_+3A_nms_don">nms_don</code></td>
<td>
<p>A vector of donor's allele name(s).</p>
</td></tr>
<tr><td><code id="CalAlleleTopN_+3A_nms_rcpt">nms_rcpt</code></td>
<td>
<p>A vector of recipient's allele name(s).</p>
</td></tr>
<tr><td><code id="CalAlleleTopN_+3A_top_n">top_n</code></td>
<td>
<p>Number of alleles to return. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of top_n most frequent alleles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.csv(system.file("extdata/example", "HLA_MisMatch_test.csv", package = "hlaR"))
don &lt;- c("donor.a1", "donor.a2")
rcpt &lt;- c("recipient.a1", "recipient.a2")
re &lt;- CalAlleleTopN(dat_in = dat, nms_don = don, nms_rcpt = rcpt, top_n = 2)
</code></pre>

<hr>
<h2 id='CalEpletMHCI'>Calculate class I HLA eplet mismatch</h2><span id='topic+CalEpletMHCI'></span>

<h3>Description</h3>

<p>Use high resolution HLA(Human Leukocyte Antigen) class I data to calculate class I eplet mismatch for a population of donors and recipients. Mismatch is calculated using logic from 'HLAMatchMaker', developed by Rene Dusquesnoy. Current reference tables supported are 'HLAMatchMaker' v2 and v3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalEpletMHCI(dat_in, ver = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalEpletMHCI_+3A_dat_in">dat_in</code></td>
<td>
<p>A dataframe of recipient and donor's high resolution MHC I data. Each recipient and donor pair are linked by are the “pair_id” column and differentiated by the “subject_type” column.</p>
</td></tr>
<tr><td><code id="CalEpletMHCI_+3A_ver">ver</code></td>
<td>
<p>Version number of HLAMatchMaker based eplet reference table to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data tables.
- 'single_detail': single molecule class I MHC eplet mismatch table, including mismatched eplet names and the count of eplets mismatched at each allele.
- 'overall_count': original input data appended with total count of mismatched eplets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-read.csv(system.file("extdata/example","MHC_I_test.csv",package="hlaR"),sep=",",header=TRUE)
re &lt;- CalEpletMHCI(dat_in = dat, ver = 3)
</code></pre>

<hr>
<h2 id='CalEpletMHCII'>Calculate class II HLA eplet mismatch.</h2><span id='topic+CalEpletMHCII'></span>

<h3>Description</h3>

<p>Use high resolution HLA(Human Leukocyte Antigen) class II data to calculate class II eplet mismatch for a population of donors and recipients. Mismatch is calculated using logic from 'HLAMatchMaker', developed by Rene Dusquesnoy. Current reference tables supported are 'HLAMatchMaker' v2 and v3. Note: interlocus info only available in v3 reference tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalEpletMHCII(dat_in, ver = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalEpletMHCII_+3A_dat_in">dat_in</code></td>
<td>
<p>A dataframe of recipient and donor's high resolution MHC II data. Each recipient and donor pair are linked by are the “pair_id” column and differentiated by the “subject_type” column.</p>
</td></tr>
<tr><td><code id="CalEpletMHCII_+3A_ver">ver</code></td>
<td>
<p>Version number of HLAMatchMaker based eplet reference table to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data tables.
- 'single_detail': single molecule class II MHC eplet mismatch table, including mismatched eplet names and the count of eplets mismatched at each allele.
- 'overall_count': original input data appended with total count of mismatched eplets.
- 'dqdr_risk': DR DQ risk score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.csv(system.file("extdata/example","MHC_II_test.csv",package="hlaR"),sep=",",header=TRUE)
re &lt;- CalEpletMHCII(dat, ver = 2)
</code></pre>

<hr>
<h2 id='CleanAllele'>Clean messy HLA typing data</h2><span id='topic+CleanAllele'></span>

<h3>Description</h3>

<p>This function takes raw messy HLA(Human Leukocyte Antigen) typing data as input. It removes inconsistent formatting and unnecessary symbols. If one of two alleles at a loci is NA, the locus is assumed to be homozygous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CleanAllele(var_1, var_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CleanAllele_+3A_var_1">var_1</code></td>
<td>
<p>HLA on allele 1.</p>
</td></tr>
<tr><td><code id="CleanAllele_+3A_var_2">var_2</code></td>
<td>
<p>HLA on allele 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 columns:
- 'var_1': raw messy input hla, identical with first input
- 'var_2': raw messy input hla, identical with second input
- 'locus1_clean': cleaned hla of var_1
- 'locus2_clean': cleaned hla of var_2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;-  read.csv(system.file("extdata/example", "HLA_Clean_test.csv", package = "hlaR"))
re &lt;- CleanAllele(dat$recipient_a1, dat$recipient_a2)
</code></pre>

<hr>
<h2 id='CountAlleleMism'>Count HLA mismatch at the allele level</h2><span id='topic+CountAlleleMism'></span>

<h3>Description</h3>

<p>Donor and recipient HLA(Human Leukocyte Antigen) typing data is compared to determine allele level mismatch. The output of EvalAlleleMism is used as input for this function. Allele level mismatch can be calculated for both high and low resolution data. The generated count will return NA if the input alleles are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountAlleleMism(dat_in, names_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountAlleleMism_+3A_dat_in">dat_in</code></td>
<td>
<p>A data frame with donor and recipient mismatched alleles. It's a output from EvalAlleleMism function.</p>
</td></tr>
<tr><td><code id="CountAlleleMism_+3A_names_in">names_in</code></td>
<td>
<p>A vector of HLA loci name to count mismatch for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of input data (subject id and hla loci) followed by mismatch hla count of each subject.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hla &lt;- read.csv(system.file("extdata/example", "HLA_MisMatch_count_test.csv", package = "hlaR"))
classI &lt;- CountAlleleMism(hla, c("mism.a1", "mism.a2", "mism.b1", "mism.b2"))
classII &lt;- CountAlleleMism(hla, c("mism.dqa12", "mism.dqb11", "mism.dqb12"))
</code></pre>

<hr>
<h2 id='EvalAlleleMism'>Evaluate mismatched alleles</h2><span id='topic+EvalAlleleMism'></span>

<h3>Description</h3>

<p>Compare donor and recipient HLA(Human Leukocyte Antigen) typing data to determine mismatched alleles. Input data can be high or low resolution, mismatch is evaluated at the allele level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalAlleleMism(don_1, don_2, recip_1, recip_2, hmz_cnt = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EvalAlleleMism_+3A_don_1">don_1</code></td>
<td>
<p>Donor's alpha1 domain.</p>
</td></tr>
<tr><td><code id="EvalAlleleMism_+3A_don_2">don_2</code></td>
<td>
<p>Donor's alpha2 or beta1 domain.</p>
</td></tr>
<tr><td><code id="EvalAlleleMism_+3A_recip_1">recip_1</code></td>
<td>
<p>Recipient's alpha1 domain.</p>
</td></tr>
<tr><td><code id="EvalAlleleMism_+3A_recip_2">recip_2</code></td>
<td>
<p>Recipient's alpha2 or beta1 domain.</p>
</td></tr>
<tr><td><code id="EvalAlleleMism_+3A_hmz_cnt">hmz_cnt</code></td>
<td>
<p>Use hmz_cnt to determine how mismatch at homozygous alleles should be handled. By default, a mismatch at a homozygous allele is considered a single mismatch. Set hmz_cnt = 2 to count homozygous mismatches as double.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of original input columns followed by mism_cnt of each donor/recipient pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.csv(system.file("extdata/example", "HLA_Clean_test.csv", package = "hlaR"))
re &lt;- EvalAlleleMism(dat$donor_a1, dat$donor_a2, dat$recipient_a1, dat$recipient_a2, hmz_cnt = 2)
</code></pre>

<hr>
<h2 id='ImputeHaplo'>Imputation</h2><span id='topic+ImputeHaplo'></span>

<h3>Description</h3>

<p>Impute low or mixed resolution HLA(Human Leukocyte Antigen) typing to the most likely high resolution equivalent. Imputation is computationally intensive, so large dataset may encounter delays in processing. This function uses data from the NMDP(National Marrow Donor Program), and is currently limited to HLA A, B, C, and DRB loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImputeHaplo(dat_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImputeHaplo_+3A_dat_in">dat_in</code></td>
<td>
<p>A data frame with low resolution HLA data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with high resolution HLA data pulled from the most likely pair of haplotypes matching the input low resolution data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- read.csv(system.file("extdata/example", "Haplotype_test.csv", package = "hlaR"))
result &lt;- ImputeHaplo(dat_in = dat[c(1:2), ])

</code></pre>

<hr>
<h2 id='utils'>Basic functions</h2><span id='topic+utils'></span><span id='topic+GenerateLookup'></span><span id='topic+CalRiskScore'></span><span id='topic+FuncForCompHaplo'></span><span id='topic+na_to_empty_string'></span>

<h3>Description</h3>

<p>GenerateLookup() called in CalEpletMHCII()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateLookup(lkup_in, locus_in)

CalRiskScore(dat_in)

FuncForCompHaplo(tbl_raw, tbl_in)

na_to_empty_string(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_+3A_lkup_in">lkup_in</code></td>
<td>
<p>data table</p>
</td></tr>
<tr><td><code id="utils_+3A_locus_in">locus_in</code></td>
<td>
<p>string
CalRiskScore() calculate DR DQ risk score, it's called in CalEpletMHCII()</p>
</td></tr>
<tr><td><code id="utils_+3A_dat_in">dat_in</code></td>
<td>
<p>dataframe
FuncForCompHaplo() called in ImputeHaplo()</p>
</td></tr>
<tr><td><code id="utils_+3A_tbl_raw">tbl_raw</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="utils_+3A_tbl_in">tbl_in</code></td>
<td>
<p>data frame
na_to_empty_string()</p>
</td></tr>
<tr><td><code id="utils_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
