<!DOCTYPE html><html><head><title>Help for package TDLM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDLM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calib_param'><p>Automatic calibration of trip distribution laws' parameter</p></a></li>
<li><a href='#check_format_names'><p>Check format of TDLM's inputs</p></a></li>
<li><a href='#county'><p>Spatial distribution of US Kansas counties in 2000</p></a></li>
<li><a href='#distance'><p>Great-circle distances between US Kansas counties</p></a></li>
<li><a href='#extract_opportunities'><p>Compute the number of opportunities between pairs of locations</p></a></li>
<li><a href='#extract_spatial_information'><p>Extract distances and surface areas from a spatial object</p></a></li>
<li><a href='#gof'><p>Compute goodness-of-fit measures between observed and simulated OD matrices</p></a></li>
<li><a href='#mass'><p>Population and number of out- and in-commuters by US Kansas county in 2000</p></a></li>
<li><a href='#od'><p>Origin-Destination commuting matrix between US Kansas counties in 2000</p></a></li>
<li><a href='#run_law'><p>Estimate mobility flows based on different trip distribution laws</p></a></li>
<li><a href='#run_law_model'><p>Estimate mobility flows based on different trip distribution laws and models</p></a></li>
<li><a href='#run_model'><p>Estimate mobility flows based on different trip distribution models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Systematic Comparison of Trip Distribution Laws and Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to propose a rigorous framework to fairly compare trip distribution laws and models as described in Lenormand et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jtrangeo.2015.12.008">doi:10.1016/j.jtrangeo.2015.12.008</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Imports:</td>
<td>Ecume, mathjaxr, Rdpack(&ge; 1.0.0), readr (&ge; 2.0.0), rmarkdown
(&ge; 2.0.0), sf (&ge; 1.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EpiVec/TDLM/issues">https://github.com/EpiVec/TDLM/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://epivec.github.io/TDLM/">https://epivec.github.io/TDLM/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 08:38:41 UTC; maxime</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Lenormand <a href="https://orcid.org/0000-0001-6362-3473"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Lenormand &lt;maxime.lenormand@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calib_param'>Automatic calibration of trip distribution laws' parameter</h2><span id='topic+calib_param'></span>

<h3>Description</h3>

<p>This function returns an estimation of the optimal parameter value based on
the average surface area of the locations (in square kilometer) according to
the law. This estimation has only been tested on commuting data
(in kilometer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calib_param(av_surf, law = "NGravExp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calib_param_+3A_av_surf">av_surf</code></td>
<td>
<p>a positive numeric value indicating the average surface
area of the locations (in square kilometer).</p>
</td></tr>
<tr><td><code id="calib_param_+3A_law">law</code></td>
<td>
<p>a character indicating which law to use (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation is based on the Figure 8 in
Lenormand et al. (2016) for four types of laws. The
normalized gravity law with an exponential distance decay function
(<code>law = "NGravExp"</code>), the normalized gravity law with a power distance
decay function (<code>law = "NGravPow"</code>), the Schneider's intervening
opportunities law (<code>law = "Schneider"</code>) and the extended radiation law
(<code>law = "RadExt"</code>).
</p>


<h3>Value</h3>

<p>An estimation of the optimal parameter value based on
the average surface area of the locations.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_opportunities">extract_opportunities()</a></code> <code><a href="#topic+extract_spatial_information">extract_spatial_information()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(county)

res &lt;- extract_spatial_information(county, id = "ID")
av_surf &lt;- mean(res$surface)

calib_param(av_surf = av_surf, law = "NGravExp")
calib_param(av_surf = av_surf, law = "NGravPow")
calib_param(av_surf = av_surf, law = "Schneider")
calib_param(av_surf = av_surf, law = "RadExt")

</code></pre>

<hr>
<h2 id='check_format_names'>Check format of TDLM's inputs</h2><span id='topic+check_format_names'></span>

<h3>Description</h3>

<p>This function checks that the TDLM's inputs have the required format (an
names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_format_names(vectors, matrices = NULL, check = "format_and_names")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_format_names_+3A_vectors">vectors</code></td>
<td>
<p>a list of vectors. The list can contain one vector. It is
recommended to name each element of the list. If <code>vectors = NULL</code> only the
matrices will be considered.</p>
</td></tr>
<tr><td><code id="check_format_names_+3A_matrices">matrices</code></td>
<td>
<p>a list of matrices. The list can contain one matrix. It is
recommended to name each element of the list. If <code>matrices = NULL</code> only the
vectors will be considered (by default).</p>
</td></tr>
<tr><td><code id="check_format_names_+3A_check">check</code></td>
<td>
<p>a character indicating what types of check
(&quot;format&quot; or &quot;format_and_names&quot;) should be used (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>TDLM</code>'s inputs should be based on the same number of
locations sorted in the same order. <code>check = "format"</code> will run basic checks
to ensure that the structure of the inputs (dimensions, class, type...) is
correct.
</p>
<p>It is recommended to use the location ID as vector names, matrix rownames and
matrix colnames. Set <code>check  = "format_and_names"</code> to check the inputs'
names. The checks are run successively, so run the function as many times as
needed to get the message indicating that the inputs passed the check
successfully.
</p>


<h3>Value</h3>

<p>A message indicating if the check has passed or failed.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
names(mi) &lt;- rownames(mass)
mj &lt;- mi

check_format_names(
  vectors = list(mi = mi, mj = mj),
  matrices = list(distance = distance),
  check = "format_and_names"
)

</code></pre>

<hr>
<h2 id='county'>Spatial distribution of US Kansas counties in 2000</h2><span id='topic+county'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of 105 US Kansas counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>county
</code></pre>


<h3>Format</h3>


<dl>
<dt>ID</dt><dd><p>County ID.</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude coordinate of the centroid of the county.</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude coordinate of the centroid of the county.</p>
</dd>
<dt>Area</dt><dd><p>Surface area of the county (in square kilometer).</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the county.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='distance'>Great-circle distances between US Kansas counties</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>A dataset containing the great-circle distance (in kilometer) between 105
US Kansas counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 105 rows and 105 columns. Each element of the
matrix represents the distance between two counties. County ID as rownames
and colnames.
</p>


<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='extract_opportunities'>Compute the number of opportunities between pairs of locations</h2><span id='topic+extract_opportunities'></span>

<h3>Description</h3>

<p>This function computes the number of opportunities between pairs of locations
as defined in Lenormand et al. (2016).
For a given pair of location the number of opportunities between the location
of origin and the location of destination is based on the number of
opportunities in a circle of radius equal to the distance between origin and
destination centered in the origin. The number of opportunities at origin
and destination are not included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_opportunities(opportunity, distance, check_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_opportunities_+3A_opportunity">opportunity</code></td>
<td>
<p>a numeric vector representing the number of opportunities
per location. The value should be positive.</p>
</td></tr>
<tr><td><code id="extract_opportunities_+3A_distance">distance</code></td>
<td>
<p>a squared matrix representing the distance between locations.</p>
</td></tr>
<tr><td><code id="extract_opportunities_+3A_check_names">check_names</code></td>
<td>
<p>a boolean indicating if the ID location are used as
vector names, matrix rownames and colnames and if they should be checked
(see Note).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A squared matrix in which each element represents the number of opportunities
between a pair of locations.
</p>


<h3>Note</h3>

<p><code>opportunity</code> and <code>distance</code> should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as vector names, matrix rownames and matrix colnames and to set
<code>check_names = TRUE</code> to verify that everything is in order before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to control the validity of all the inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calib_param">calib_param()</a></code> <code><a href="#topic+extract_spatial_information">extract_spatial_information()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

opportunity &lt;- mass[, 1]

sij &lt;- extract_opportunities(
  opportunity = opportunity,
  distance = distance,
  check_names = FALSE
)

</code></pre>

<hr>
<h2 id='extract_spatial_information'>Extract distances and surface areas from a spatial object</h2><span id='topic+extract_spatial_information'></span>

<h3>Description</h3>

<p>This function returns a matrix of distances between locations (in kilometer)
along with a vector surface areas of the locations (in square kilometer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_spatial_information(geometry, id = NULL, show_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_spatial_information_+3A_geometry">geometry</code></td>
<td>
<p>a spatial object that can be handled by the <code>sf</code> package.</p>
</td></tr>
<tr><td><code id="extract_spatial_information_+3A_id">id</code></td>
<td>
<p>name or number of the column to use as rownames and colnames for
the output distance matrix (optional, NULL by default). A vector with length
equal to the number of locations can also be used.</p>
</td></tr>
<tr><td><code id="extract_spatial_information_+3A_show_progress">show_progress</code></td>
<td>
<p>a boolean indicating if a progress bar should be
displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>geometry</code> must be projected in a valid coordinate reference
system. It will be reprojected in degrees longitude/latitude to compute the
great-circle distances between centroids' locations with an internal function
and to compute the surface area with the function <a href="sf.html#topic+geos_measures">st_area</a> from
the <a href="https://cran.r-project.org/package=sf">sf</a> package.
</p>


<h3>Value</h3>

<p>A list composed of two elements. The first element is a squared matrix
representing the great-circle distance (in kilometer) between locations. The
second element is a vector containing the surface area of each location
(in square kilometer).
</p>


<h3>Note</h3>

<p>The outputs are based on the locations contained in <code>geometry</code> and
sorted in the same order. An optional <code>id</code> can also be provided to be used as
names for the outputs.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calib_param">calib_param()</a></code> <code><a href="#topic+extract_opportunities">extract_opportunities()</a></code> <code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(county)

res &lt;- extract_spatial_information(county, id = "ID")

dim(res$distance)

length(res$surface)

</code></pre>

<hr>
<h2 id='gof'>Compute goodness-of-fit measures between observed and simulated OD matrices</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>This function returns a data.frame where each row provides one or
several goodness-of-fit measures between a simulated and an observed
Origin-Destination matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(
  sim,
  obs,
  measures = "all",
  distance = NULL,
  bin_size = 2,
  use_proba = FALSE,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_sim">sim</code></td>
<td>
<p>an object of class <code>TDLM</code> (output of <code><a href="#topic+run_law_model">run_law_model()</a></code>,
<code><a href="#topic+run_law">run_law()</a></code> or <code><a href="#topic+run_model">run_model()</a></code>).
A matrix or a list of matrices can also be used (see Note).</p>
</td></tr>
<tr><td><code id="gof_+3A_obs">obs</code></td>
<td>
<p>a squared matrix representing the observed mobility flows.</p>
</td></tr>
<tr><td><code id="gof_+3A_measures">measures</code></td>
<td>
<p>a vector of string(s) indicating which goodness-of-fit
measure(s) to chose (see Details). If <code>"all"</code> is specified, then all measures
will be calculated.</p>
</td></tr>
<tr><td><code id="gof_+3A_distance">distance</code></td>
<td>
<p>a squared matrix representing the distance between locations.
Only necessary for the distance-based measures.</p>
</td></tr>
<tr><td><code id="gof_+3A_bin_size">bin_size</code></td>
<td>
<p>a numeric value indicating the size of bin used to discretize
the distance distribution to compute CPC_d (2 &quot;km&quot; by default).</p>
</td></tr>
<tr><td><code id="gof_+3A_use_proba">use_proba</code></td>
<td>
<p>a boolean indicating if the <code>proba</code> matrix should be used
instead of the simulated OD matrix to compute the measure(s). Only valid for
the output from <code><a href="#topic+run_law_model">run_law_model()</a></code> with argument <code>write_proba = TRUE</code> (see
Note).</p>
</td></tr>
<tr><td><code id="gof_+3A_check_names">check_names</code></td>
<td>
<p>a boolean indicating if the ID location are used as matrix
rownames and colnames and if they should be checked (see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>With \(n\) the number of locations, \(T_{ij}\) the
observed flow between location \(i\) and location \(j\)
(argument <code>obs</code>), \(\tilde{T}_{ij}\) a simulated flow
between location \(i\) and location \(j\) (a matrix from
argument <code>sim</code>), \(N=\sum_{i,j=1}^n T_{ij}\) the
sum of observed flows and
\(\tilde{N}=\sum_{i,j=1}^n \tilde{T}_{ij}\)
the sum of simulated flows.
</p>
<p>Several goodness-of-fit measures have been considered
<code>measures = c("CPC", "NRMSE", "KL", "CPL", "CPC_d", "KS")</code>. The Common Part
of Commuters (Gargiulo et al. 2012; Lenormand et al. 2012; Lenormand et al. 2016),
</p>
<p>\(\displaystyle CPC(T,\tilde{T}) = \frac{2\cdot\sum_{i,j=1}^n min(T_{ij},\tilde{T}_{ij})}{N + \tilde{N}}\)
</p>
<p>the Normalized Root Mean Square Error (NRMSE),
</p>
<p>\(\displaystyle NRMSE(T,\tilde{T}) = \sqrt{\frac{\sum_{i,j=1}^n (T_{ij}-\tilde{T}_{ij})^2}{N}}\)
</p>
<p>the Kullback–Leibler divergence (Kullback and Leibler 1951),
</p>
<p>\(\displaystyle KL(T,\tilde{T}) = \sum_{i,j=1}^n \frac{T_{ij}}{N}\log\left(\frac{T_{ij}}{N}\frac{\tilde{N}}{\tilde{T}_{ij}}\right)\)
</p>
<p>the Common Part of Links (CPL) (Lenormand et al. 2016),
</p>
<p>\(\displaystyle CPL(T,\tilde{T}) = \frac{2\cdot\sum_{i,j=1}^n 1_{T_{ij}>0} \cdot 1_{\tilde{T}_{ij}>0}}{\sum_{i,j=1}^n 1_{T_{ij}>0} + \sum_{i,j=1}^n 1_{\tilde{T}_{ij}>0}}\)
</p>
<p>the Common Part of Commuters based on the disance
(Lenormand et al. 2016), noted CPC_d. Let us consider
\(N_k\) (and \(\tilde{N}_k\)) the
sum of observed (and simulated) flows at a distance comprised in the bin
[<code>bin_size</code>*k-<code>bin_size</code>, <code>bin_size</code>*k[.
</p>
<p>\(\displaystyle CPC_d(T,\tilde{T}) = \frac{2\cdot\sum_{k=1}^{\infty} min(N_{k},\tilde{N}_{k})}{N+\tilde{N}}\)
</p>
<p>and the Kolmogorv-Smirnov statistic and p-value (Massey 1951)
, noted KS. It is based on the observed and simulated flow distance
distribution and computed with the <a href="Ecume.html#topic+ks_test">ks_test</a> function from
the <a href="https://cran.r-project.org/package=Ecume">Ecume</a> package.
</p>


<h3>Value</h3>

<p>A data.frame providing one or several goodness-of-fit measure(s) between
simulated OD(s) and an observed OD. Each row corresponds to a matrix sorted
according to the list (or list of list) elements (names are used if
provided).
</p>


<h3>Note</h3>

<p>By default, if <code>sim</code> is an output of <code><a href="#topic+run_law_model">run_law_model()</a></code>
the measure(s) are computed only for the simulated OD matrices and
not the <code>proba</code> matrix (included in the output when
<code>write_proba = TRUE</code>). The argument <code>use_proba</code> can be used to compute the
measure(s) based on the <code>proba</code> matrix instead of the simulated
OD matrix. In this case the argument <code>obs</code> should also be a proba matrix.
</p>
<p>All the inputs should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as matrix rownames and matrix colnames and to set
<code>check_names = TRUE</code> to verify that everything is in order before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to control the validity of all the inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>
<p>Gargiulo F, Lenormand M, Huet S, Baqueiro Espinosa O (2012).
&ldquo;Commuting network model: getting to the essentials.&rdquo;
<em>Journal of Artificial Societies and Social Simulation</em>, <b>15</b>(2), 13.
</p>
<p>Lenormand M, Huet S, Gargiulo F, Deffuant G (2012).
&ldquo;A Universal Model of Commuting Networks.&rdquo;
<em>PLoS ONE</em>, <b>7</b>, e45985.
</p>
<p>Kullback S, Leibler RA (1951).
&ldquo;On Information and Sufficiency.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>22</b>(1), 79 &ndash; 86.
</p>
<p>Massey FJ (1951).
&ldquo;The Kolmogorov-Smirnov test for goodness of fit.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>46</b>(253), 68&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_law_model">run_law_model()</a></code> <code><a href="#topic+run_law">run_law()</a></code> <code><a href="#topic+run_model">run_model()</a></code> <code><a href="#topic+run_law_model">run_law_model()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)
data(od)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi
Oi &lt;- as.numeric(mass[, 2])
Dj &lt;- as.numeric(mass[, 3])

res &lt;- run_law_model(
  law = "GravExp", mass_origin = mi, mass_destination = mj,
  distance = distance, opportunity = NULL, param = 0.01,
  model = "DCM", nb_trips = NULL, out_trips = Oi, in_trips = Dj,
  average = FALSE, nbrep = 1, maxiter = 50, mindiff = 0.01,
  write_proba = FALSE,
  check_names = FALSE
)

gof(
  sim = res, obs = od, measures = "CPC", distance = NULL, bin_size = 2,
  use_proba = FALSE,
  check_names = FALSE
)


</code></pre>

<hr>
<h2 id='mass'>Population and number of out- and in-commuters by US Kansas county in 2000</h2><span id='topic+mass'></span>

<h3>Description</h3>

<p>A dataset containing the number of inhabitants, in-commuters and
out-commuters for 105 US Kansas counties in 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 105 rows and 3 columns:
</p>

<dl>
<dt>rownames</dt><dd><p>County ID.</p>
</dd>
<dt>Population</dt><dd><p>Number of inhabitants.</p>
</dd>
<dt>Out-commuters</dt><dd><p>Number of out-commuters.</p>
</dd>
<dt>In-commuters</dt><dd><p>Number of in-commuters.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/">https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/</a>
</p>

<hr>
<h2 id='od'>Origin-Destination commuting matrix between US Kansas counties in 2000</h2><span id='topic+od'></span>

<h3>Description</h3>

<p>A dataset containing the number of commuters between 105 US Kansas counties
in 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 105 rows and 105 columns. Each element of the
matrix represents the number of commuters between two counties. County ID as
rownames and colnames.
</p>


<h3>Source</h3>

<p><a href="https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/">https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/</a>
</p>

<hr>
<h2 id='run_law'>Estimate mobility flows based on different trip distribution laws</h2><span id='topic+run_law'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution laws.
As described in Lenormand et al. (2016), we
propose a two-step approach to generate mobility flows by separating the trip
distribution law, gravity or intervening opportunities, from the modeling
approach used to generate the flows from this law. This function only uses
the first step to generate a probability distribution based on the different
laws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_law(
  law = "Unif",
  mass_origin,
  mass_destination = mass_origin,
  distance = NULL,
  opportunity = NULL,
  param = NULL,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_law_+3A_law">law</code></td>
<td>
<p>a character indicating which law to use (see Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_mass_origin">mass_origin</code></td>
<td>
<p>a numeric vector representing the mass at origin (i.e.
demand).</p>
</td></tr>
<tr><td><code id="run_law_+3A_mass_destination">mass_destination</code></td>
<td>
<p>a numeric vector representing the mass at
destination (i.e. attractiveness).</p>
</td></tr>
<tr><td><code id="run_law_+3A_distance">distance</code></td>
<td>
<p>a squared matrix representing the distance between locations
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_opportunity">opportunity</code></td>
<td>
<p>a squared matrix representing the number of opportunities
between locations (see Details). Can be easily computed with
<code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>.</p>
</td></tr>
<tr><td><code id="run_law_+3A_param">param</code></td>
<td>
<p>a vector of numeric value(s) used to adjust the importance of
<code>distance</code> or <code>opportunity</code> associated with the chosen law. A single value or
a vector of several parameter values can be used (see Return). Not necessary
for the original radiation law or the uniform law (see Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_check_names">check_names</code></td>
<td>
<p>a boolean indicating if the ID location are used as
vector names, matrix rownames and colnames and if they should be checked
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>We compute the matrix <code>proba</code> estimating the probability
\(p_{ij}\) to observe a trip from location \(i\) to
another location \(j\)
(\(\sum_{i}\sum_{j} p_{ij}=1\)). This
probability is based on the demand \(m_{i}\)
(argument <code>mass_origin</code>) and the attractiveness
\(m_{j}\) (argument <code>mass_destination</code>). Note that the population
is typically used as a surrogate for both quantities (this is why
<code>mass_destination = mass_origin</code> by default). It also depends on the
distance \(d_{ij}\) between locations (argument <code>distance</code>) OR
the number of opportunities \(s_{ij}\) between locations
(argument <code>opportunity</code>) depending on the chosen law. Both the effect of the
distance and the number of opportunities can be adjusted with a parameter
(argument <code>param</code>) except for the original radiation law or the uniform law.
</p>
<p>In this package we consider eight probabilistic laws
described in details in Lenormand et al. (2016). Four
gravity laws
(Carey 1858; Zipf 1946; Barthelemy 2011; Lenormand et al. 2016), three
intervening opportunity laws
(Schneider 1959; Simini et al. 2012; Yang et al. 2014) and a uniform law.
</p>

<ol>
<li><p> Gravity law with an exponential distance decay function
(<code>law = "GravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with an exponential distance decay function
(<code>law = "NGravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Gravity law with a power distance decay function
(<code>law = "GravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with a power distance decay function
(<code>law = "NGravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Schneider's intervening opportunities law (<code>law = "Schneider"</code>). The
arguments <code>mass_origin</code>, <code>mass_destination</code> (optional), <code>opportunity</code> and
<code>param</code> will be used.
</p>
</li>
<li><p> Radiation law (<code>law = "Rad"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional) and <code>opportunity</code> will be used.
</p>
</li>
<li><p> Extended radiation law (<code>law = "RadExt"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional), <code>opportunity</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Uniform law (<code>law = "Unif"</code>). The argument <code>mass_origin</code> will be used to
extract the number of locations.
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <code>TDLM</code>. A list of list of matrices containing for each
parameter value the matrix of probabilities (called <code>proba</code>). If
<code>length(param) = 1</code> or <code>law = "Rad"</code> or <code style="white-space: pre;">&#8288;law = "Unif&#8288;</code> only a list of
matrices will be returned.
</p>


<h3>Note</h3>

<p>All the inputs should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as vector names, matrix rownames and matrix colnames and to set
<code>check_names = TRUE</code> to verify that everything is in order before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to control the validity of all the inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>
<p>Carey HC (1858).
<em>Principles of Social Science</em>.
Lippincott.
</p>
<p>Zipf GK (1946).
&ldquo;The P1 P2/D Hypothesis: On the Intercity Movement of Persons.&rdquo;
<em>American Sociological Review</em>, <b>11</b>(6), 677&ndash;686.
</p>
<p>Barthelemy M (2011).
&ldquo;Spatial Networks.&rdquo;
<em>Physics Reports</em>, <b>499</b>, 1-101.
</p>
<p>Schneider M (1959).
&ldquo;Gravity models and trip distribution theory.&rdquo;
<em>Papers of the regional science association</em>, <b>5</b>, 51-58.
</p>
<p>Simini F, González MC, Maritan A, Barabasi A (2012).
&ldquo;A universal model for mobility and migration patterns.&rdquo;
<em>Nature</em>, <b>484</b>, 96-100.
</p>
<p>Yang Y, Herrera C, Eagle N, González MC (2014).
&ldquo;Limits of Predictability in Commuting Flows in the Absence of Data for Calibration.&rdquo;
<em>Scientific Reports</em>, <b>4</b>(5662), 5662.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof()</a></code> <code><a href="#topic+run_law_model">run_law_model()</a></code> <code><a href="#topic+run_model">run_model()</a></code> <code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi

res &lt;- run_law(
  law = "GravExp", mass_origin = mi, mass_destination = mj,
  distance = distance, opportunity = NULL, param = 0.01,
  check_names = FALSE
)

# print(res)

</code></pre>

<hr>
<h2 id='run_law_model'>Estimate mobility flows based on different trip distribution laws and models</h2><span id='topic+run_law_model'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution laws and
models. As described in Lenormand et al. (2016), the
function uses a two-step approach to generate mobility flows by separating
the trip distribution law, gravity or intervening opportunities, from the
modeling approach used to generate the flows from this law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_law_model(
  law = "Unif",
  mass_origin,
  mass_destination = mass_origin,
  distance = NULL,
  opportunity = NULL,
  param = NULL,
  model = "UM",
  nb_trips = 1000,
  out_trips = NULL,
  in_trips = out_trips,
  average = FALSE,
  nbrep = 3,
  maxiter = 50,
  mindiff = 0.01,
  write_proba = FALSE,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_law_model_+3A_law">law</code></td>
<td>
<p>a character indicating which law to use (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mass_origin">mass_origin</code></td>
<td>
<p>a numeric vector representing the mass at origin (i.e.
demand).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mass_destination">mass_destination</code></td>
<td>
<p>a numeric vector representing the mass at
destination (i.e. attractiveness).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_distance">distance</code></td>
<td>
<p>a squared matrix representing the distance between locations
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_opportunity">opportunity</code></td>
<td>
<p>a squared matrix representing the number of opportunities
between locations (see Details). Can be easily computed with
<code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_param">param</code></td>
<td>
<p>a vector of numeric value(s) used to adjust the importance of
<code>distance</code> or <code>opportunity</code> associated with the chosen law. A single value or
a vector of several parameter values can be used (see Return). Not necessary
for the original radiation law or the uniform law (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_model">model</code></td>
<td>
<p>a character indicating which model to use.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_nb_trips">nb_trips</code></td>
<td>
<p>a numeric value indicating the total number of trips. Must
be an integer if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_out_trips">out_trips</code></td>
<td>
<p>a numeric vector representing the number of outgoing
trips per location. Must be a vector of integers
if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_in_trips">in_trips</code></td>
<td>
<p>a numeric vector representing the number of incoming
trips per location. Must be a vector of integers
if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_average">average</code></td>
<td>
<p>a boolean indicating if the average mobility flow matrix
should be generated instead of the <code>nbrep</code> matrices based on
random draws (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_nbrep">nbrep</code></td>
<td>
<p>an integer indicating the number of replications
associated to the model run. Note that <code>nbrep = 1</code> if <code>average = TRUE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_maxiter">maxiter</code></td>
<td>
<p>an integer indicating the maximal number of iterations for
adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mindiff">mindiff</code></td>
<td>
<p>a numeric strictly positive value indicating the
stopping criterion for adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_write_proba">write_proba</code></td>
<td>
<p>a boolean indicating if the estimation of the
probability to move from one location to another obtained with the
distribution law should be returned along with the flows estimations.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_check_names">check_names</code></td>
<td>
<p>a boolean indicating if the ID location are used as
vector names, matrix rownames and colnames and if they should be checked
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>First, we compute the matrix <code>proba</code> estimating the probability
\(p_{ij}\) to observe a trip from location \(i\) to
another location \(j\)
(\(\sum_{i}\sum_{j} p_{ij}=1\)). This
probability is based on the demand \(m_{i}\)
(argument <code>mass_origin</code>) and the attractiveness
\(m_{j}\) (argument <code>mass_destination</code>). Note that the population
is typically used as a surrogate for both quantities (this is why
<code>mass_destination = mass_origin</code> by default). It also depends on the
distance \(d_{ij}\) between locations (argument <code>distance</code>) OR
the number of opportunities \(s_{ij}\) between locations
(argument <code>opportunity</code>) depending on the chosen law. Both the effect of the
distance and the number of opportunities can be adjusted with a parameter
(argument <code>param</code>) except for the original radiation law and the uniform law.
</p>
<p>In this package we consider eight probabilistic laws
described in details in Lenormand et al. (2016). Four
gravity laws
(Carey 1858; Zipf 1946; Barthelemy 2011; Lenormand et al. 2016), three
intervening opportunity laws
(Schneider 1959; Simini et al. 2012; Yang et al. 2014) and a uniform law.
</p>

<ol>
<li><p> Gravity law with an exponential distance decay function
(<code>law = "GravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with an exponential distance decay function
(<code>law = "NGravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Gravity law with a power distance decay function
(<code>law = "GravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with a power distance decay function
(<code>law = "NGravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Schneider's intervening opportunities law (<code>law = "Schneider"</code>). The
arguments <code>mass_origin</code>, <code>mass_destination</code> (optional), <code>opportunity</code> and
<code>param</code> will be used.
</p>
</li>
<li><p> Radiation law (<code>law = "Rad"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional) and <code>opportunity</code> will be used.
</p>
</li>
<li><p> Extended radiation law (<code>law = "RadExt"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional), <code>opportunity</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Uniform law (<code>law = "Unif"</code>). The argument <code>mass_origin</code> will be used to
extract the number of locations.
</p>
</li></ol>

<p>Second, we propose four constrained models to generate the flows from these
distribution of probability. These models respect different level of
constraints. These constraints can preserve the total number of trips
(argument <code>nb_trips</code>) OR the number of out-going trips
\(O_{i}\) (argument <code>out_trips</code>) AND/OR the number of in-coming
\(D_{j}\) (argument <code>in_trips</code>) according to the model. The sum of
out-going trips \(\sum_{i} O_{i}\) should be equal to the
sum of in-coming trips \(\sum_{j} D_{j}\).
</p>

<ol>
<li><p> Unconstrained model (<code>model = "UM"</code>). Only <code>nb_trips</code> will be preserved
(arguments <code>out_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Production constrained model (<code>model = "PCM"</code>). Only <code>out_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Attraction constrained model (<code>model = "ACM"</code>). Only <code>in_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>out_trips</code> will not be used).
</p>
</li>
<li><p> Doubly constrained model (<code>model = "DCM"</code>). Both <code>out_trips</code> and
<code>in_trips</code> will be preserved (arguments <code>nb_trips</code>will not be used). The
doubly constrained model is based on an Iterative Proportional Fitting
process (Deming and Stephan 1940). The arguments <code>maxiter</code> (50 by
default) and <code>mindiff</code> (0.01 by default) can be used to tune the model.
<code>mindiff</code> is the minimal tolerated relative error between the
simulated and observed marginals. <code>maxiter</code>
ensures that the algorithm stops even if it has not converged toward the
<code>mindiff</code> wanted value.
</p>
</li></ol>

<p>By default, when <code>average = FALSE</code>, <code>nbrep</code> matrices are generated from
<code>proba</code> with multinomial random draws that will take different forms
according to the model used. In this case, the models will deal with positive
integers as inputs and outputs. Nevertheless, it is also possible to generate
an average matrix based on a multinomial distribution (based on an infinite
number of drawings). In this case, the models' inputs can be either positive
integer or real numbers and the output (<code>nbrep = 1</code> in this case) will be a
matrix of positive real numbers.
</p>


<h3>Value</h3>

<p>An object of class <code>TDLM</code>. A list of list of matrices containing for each
parameter value the <code>nbrep</code> simulated matrices and the matrix of
probabilities (called <code>proba</code>) if <code>write_proba = TRUE</code>.
If <code>length(param) = 1</code> or <code>law = "Rad"</code> or <code style="white-space: pre;">&#8288;law = "Unif&#8288;</code> only a list of
matrices will be returned.
</p>


<h3>Note</h3>

<p>All the inputs should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as vector names, matrix rownames and matrix colnames and to set
<code>check_names = TRUE</code> to verify that everything is in order before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to control the validity of all the inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>
<p>Carey HC (1858).
<em>Principles of Social Science</em>.
Lippincott.
</p>
<p>Zipf GK (1946).
&ldquo;The P1 P2/D Hypothesis: On the Intercity Movement of Persons.&rdquo;
<em>American Sociological Review</em>, <b>11</b>(6), 677&ndash;686.
</p>
<p>Barthelemy M (2011).
&ldquo;Spatial Networks.&rdquo;
<em>Physics Reports</em>, <b>499</b>, 1-101.
</p>
<p>Schneider M (1959).
&ldquo;Gravity models and trip distribution theory.&rdquo;
<em>Papers of the regional science association</em>, <b>5</b>, 51-58.
</p>
<p>Simini F, González MC, Maritan A, Barabasi A (2012).
&ldquo;A universal model for mobility and migration patterns.&rdquo;
<em>Nature</em>, <b>484</b>, 96-100.
</p>
<p>Yang Y, Herrera C, Eagle N, González MC (2014).
&ldquo;Limits of Predictability in Commuting Flows in the Absence of Data for Calibration.&rdquo;
<em>Scientific Reports</em>, <b>4</b>(5662), 5662.
</p>
<p>Deming WE, Stephan FF (1940).
&ldquo;On a Least Squares Adjustment of a Sample Frequency Table When the Expected Marginal Totals Are Known.&rdquo;
<em>Annals of Mathematical Statistics</em>, <b>11</b>, 427-444.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof()</a></code> <code><a href="#topic+run_law">run_law()</a></code> <code><a href="#topic+run_model">run_model()</a></code> <code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi
Oi &lt;- as.numeric(mass[, 2])
Dj &lt;- as.numeric(mass[, 3])

res &lt;- run_law_model(
  law = "GravExp", mass_origin = mi, mass_destination = mj,
  distance = distance, opportunity = NULL, param = 0.01,
  model = "DCM", nb_trips = NULL, out_trips = Oi, in_trips = Dj,
  average = FALSE, nbrep = 3, maxiter = 50, mindiff = 0.01,
  write_proba = FALSE,
  check_names = FALSE
)

print(res)

</code></pre>

<hr>
<h2 id='run_model'>Estimate mobility flows based on different trip distribution models</h2><span id='topic+run_model'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution models.
As described in Lenormand et al. (2016), we
propose a two-step approach to generate mobility flows by separating the trip
distribution law, gravity or intervening opportunities, from the modeling
approach used to generate the flows from this law. This function only uses
the second step to generate mobility flow based on a matrix of probabilities
using different models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_model(
  proba,
  model = "UM",
  nb_trips = 1000,
  out_trips = NULL,
  in_trips = out_trips,
  average = FALSE,
  nbrep = 3,
  maxiter = 50,
  mindiff = 0.01,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_model_+3A_proba">proba</code></td>
<td>
<p>a squared matrix of probability. The sum of the matrix element
must be equal to 1. It will be normalized automatically if it is not the
case.</p>
</td></tr>
<tr><td><code id="run_model_+3A_model">model</code></td>
<td>
<p>a character indicating which model to use.</p>
</td></tr>
<tr><td><code id="run_model_+3A_nb_trips">nb_trips</code></td>
<td>
<p>a numeric value indicating the total number of trips. Must
be an integer if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_out_trips">out_trips</code></td>
<td>
<p>a numeric vector representing the number of outgoing
trips per location. Must be a vector of integers
if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_in_trips">in_trips</code></td>
<td>
<p>a numeric vector representing the number of incoming
trips per location. Must be a vector of integers
if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_average">average</code></td>
<td>
<p>a boolean indicating if the average mobility flow matrix
should be generated instead of the <code>nbrep</code> matrices based on
random draws (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_nbrep">nbrep</code></td>
<td>
<p>an integer indicating the number of replications
associated to the model run. Note that <code>nbrep = 1</code> if <code>average = TRUE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_maxiter">maxiter</code></td>
<td>
<p>an integer indicating the maximal number of iterations for
adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_mindiff">mindiff</code></td>
<td>
<p>a numeric strictly positive value indicating the
stopping criterion for adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_check_names">check_names</code></td>
<td>
<p>a boolean indicating if the ID location are used as
vector names, matrix rownames and colnames and if they should be checked
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>We propose four constrained models to generate the flow from the matrix
of probabilities. These models respect different level of
constraints. These constraints can preserve the total number of trips
(argument <code>nb_trips</code>) OR the number of out-going trips
\(O_{i}\) (argument <code>out_trips</code>) AND/OR the number of in-coming
\(D_{j}\) (argument <code>in_trips</code>) according to the model. The sum of
out-going trips \(\sum_{i} O_{i}\) should be equal to the
sum of in-coming trips \(\sum_{j} D_{j}\).
</p>

<ol>
<li><p> Unconstrained model (<code>model = "UM"</code>). Only <code>nb_trips</code> will be preserved
(arguments <code>out_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Production constrained model (<code>model = "PCM"</code>). Only <code>out_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Attraction constrained model (<code>model = "ACM"</code>). Only <code>in_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>out_trips</code> will not be used).
</p>
</li>
<li><p> Doubly constrained model (<code>model = "DCM"</code>). Both <code>out_trips</code> and
<code>in_trips</code> will be preserved (arguments <code>nb_trips</code>will not be used). The
doubly constrained model is based on an Iterative Proportional Fitting
process (Deming and Stephan 1940). The arguments <code>maxiter</code> (50 by
default) and <code>mindiff</code> (0.01 by default) can be used to tune the model.
<code>mindiff</code> is the minimal tolerated relative error between the
simulated and observed marginals. <code>maxiter</code>
ensures that the algorithm stops even if it has not converged toward the
<code>mindiff</code> wanted value.
</p>
</li></ol>

<p>By default, when <code>average = FALSE</code>, <code>nbrep</code> matrices are generated from
<code>proba</code> with multinomial random draws that will take different forms
according to the model used. In this case, the models will deal with positive
integers as inputs and outputs. Nevertheless, it is also possible to generate
an average matrix based on a multinomial distribution (based on an infinite
number of drawings). In this case, the models' inputs can be either positive
integer or real numbers and the output (<code>nbrep = 1</code> in this case) will be a
matrix of positive real numbers.
</p>


<h3>Value</h3>

<p>An object of class <code>TDLM</code>. A list of matrices containing the
<code>nbrep</code> simulated matrices.
</p>


<h3>Note</h3>

<p>All the inputs should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as vector names, matrix rownames and matrix colnames and to set
<code>check_names = TRUE</code> to verify that everything is in order before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to control the validity of all the inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016).
&ldquo;Systematic comparison of trip distribution laws and models.&rdquo;
<em>Journal of Transport Geography</em>, <b>51</b>, 158-169.
</p>
<p>Deming WE, Stephan FF (1940).
&ldquo;On a Least Squares Adjustment of a Sample Frequency Table When the Expected Marginal Totals Are Known.&rdquo;
<em>Annals of Mathematical Statistics</em>, <b>11</b>, 427-444.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gof">gof()</a></code> <code><a href="#topic+run_law_model">run_law_model()</a></code> <code><a href="#topic+run_law">run_law()</a></code> <code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(od)

proba &lt;- od / sum(od)

Oi &lt;- as.numeric(mass[, 2])
Dj &lt;- as.numeric(mass[, 3])

res &lt;- run_model(
  proba = proba,
  model = "DCM", nb_trips = NULL, out_trips = Oi, in_trips = Dj,
  average = FALSE, nbrep = 3, maxiter = 50, mindiff = 0.01,
  check_names = FALSE
)

# print(res)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
