<!DOCTYPE html><html lang="en"><head><title>Help for package TDLM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDLM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calib_param'><p>Automatic calibration of trip distribution laws' parameter</p></a></li>
<li><a href='#check_format_names'><p>Check format of TDLM's inputs</p></a></li>
<li><a href='#coords'><p>Geographical coordinates of US Kansas counties' centroids in 2000</p>
(Longitude/Latitude)</a></li>
<li><a href='#coords_xy'><p>Geographical coordinates of US Kansas counties' centroids in 2000</p>
(X/Y based on Web Mercator)</a></li>
<li><a href='#county'><p>Spatial distribution of US Kansas counties in 2000</p></a></li>
<li><a href='#distance'><p>Great-circle distances between US Kansas counties</p></a></li>
<li><a href='#extract_distances'><p>Compute the distance between pairs of locations</p></a></li>
<li><a href='#extract_opportunities'><p>Compute the number of opportunities between pairs of locations</p></a></li>
<li><a href='#extract_spatial_information'><p>Extract distances and surface areas from a spatial object</p></a></li>
<li><a href='#gof'><p>Compute goodness-of-fit measures between observed and simulated OD matrices</p></a></li>
<li><a href='#mass'><p>Population and number of out- and in-commuters by US Kansas county in 2000</p></a></li>
<li><a href='#od'><p>Origin-Destination commuting matrix between US Kansas counties in 2000</p></a></li>
<li><a href='#run_law'><p>Estimate mobility flows based on different trip distribution laws</p></a></li>
<li><a href='#run_law_model'><p>Estimate mobility flows based on different trip distribution laws and models</p></a></li>
<li><a href='#run_model'><p>Estimate mobility flows based on different trip distribution models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Systematic Comparison of Trip Distribution Laws and Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to propose a rigorous framework to fairly compare trip distribution laws and models as described in Lenormand et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jtrangeo.2015.12.008">doi:10.1016/j.jtrangeo.2015.12.008</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Imports:</td>
<td>Ecume, mathjaxr, Rdpack(&ge; 1.0.0), readr (&ge; 2.0.0), rmarkdown
(&ge; 2.0.0), sf (&ge; 1.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EpiVec/TDLM/issues">https://github.com/EpiVec/TDLM/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://epivec.github.io/TDLM/">https://epivec.github.io/TDLM/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-06 09:13:32 UTC; maxime</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Lenormand <a href="https://orcid.org/0000-0001-6362-3473"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Lenormand &lt;maxime.lenormand@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calib_param'>Automatic calibration of trip distribution laws' parameter</h2><span id='topic+calib_param'></span>

<h3>Description</h3>

<p>This function returns an estimate of the optimal parameter value based on
the average surface area of the locations (in square kilometers) according
to the law. This estimation has only been tested on commuting data
(in kilometers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calib_param(av_surf, law = "NGravExp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calib_param_+3A_av_surf">av_surf</code></td>
<td>
<p>A positive <code>numeric</code> value indicating the average surface
area of the locations (in square kilometers).</p>
</td></tr>
<tr><td><code id="calib_param_+3A_law">law</code></td>
<td>
<p>A <code>character</code> string indicating which law to use (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation is based on Figure 8 in Lenormand <em>et al.</em>
(2016) for four types of laws: the normalized gravity law with an exponential
distance decay function (<code>law = "NGravExp"</code>), the normalized gravity law with
a power distance decay function (<code>law = "NGravPow"</code>), Schneider's
intervening opportunities law (<code>law = "Schneider"</code>), and the extended
radiation law (<code>law = "RadExt"</code>).
</p>


<h3>Value</h3>

<p>An estimate of the optimal parameter value based on
the average surface area of the locations.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>


<h3>See Also</h3>

<p>Associated functions:
<code><a href="#topic+extract_opportunities">extract_opportunities()</a></code> <code><a href="#topic+extract_spatial_information">extract_spatial_information()</a></code>
<code><a href="#topic+check_format_names">check_format_names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(county)

res &lt;- extract_spatial_information(county, id = "ID")
av_surf &lt;- mean(res$surface)

calib_param(av_surf = av_surf, law = "NGravExp")
calib_param(av_surf = av_surf, law = "NGravPow")
calib_param(av_surf = av_surf, law = "Schneider")
calib_param(av_surf = av_surf, law = "RadExt")

</code></pre>

<hr>
<h2 id='check_format_names'>Check format of TDLM's inputs</h2><span id='topic+check_format_names'></span>

<h3>Description</h3>

<p>This function checks that the TDLM's inputs have the required format (and names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_format_names(vectors, matrices = NULL, check = "format_and_names")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_format_names_+3A_vectors">vectors</code></td>
<td>
<p>A <code>list</code> of vectors. The list can contain one vector. It is
recommended to name each element of the list. If <code>vectors = NULL</code>, only the
matrices will be considered.</p>
</td></tr>
<tr><td><code id="check_format_names_+3A_matrices">matrices</code></td>
<td>
<p>A <code>list</code> of matrices. The list can contain one matrix. It is
recommended to name each element of the list. If <code>matrices = NULL</code>, only the
vectors will be considered (by default).</p>
</td></tr>
<tr><td><code id="check_format_names_+3A_check">check</code></td>
<td>
<p>A <code>character</code> indicating which types of check
(<code>"format"</code> or <code>"format_and_names"</code>) should be used (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>TDLM</code>'s inputs should be based on the same number of
locations sorted in the same order. <code>check = "format"</code> will run basic checks
to ensure that the structure of the inputs (dimensions, class, type...) is
correct.
</p>
<p>It is recommended to use the location ID as <code>vector</code> <code>names</code>, <code>matrix</code>
<code>rownames</code>, and <code>matrix</code> <code>colnames</code>. Set <code>check  = "format_and_names"</code> to
check the inputs' names. The checks are run successively, so run the function
as many times as needed to get the message indicating that the inputs passed
the check successfully.
</p>


<h3>Value</h3>

<p>A message indicating if the check has passed or failed.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
names(mi) &lt;- rownames(mass)
mj &lt;- mi

check_format_names(
  vectors = list(mi = mi, mj = mj),
  matrices = list(distance = distance),
  check = "format_and_names"
)

</code></pre>

<hr>
<h2 id='coords'>Geographical coordinates of US Kansas counties' centroids in 2000
(Longitude/Latitude)</h2><span id='topic+coords'></span>

<h3>Description</h3>

<p>A dataset containing the geographical coordinates of US Kansas counties'
centroids in 2000 (Longitude/Latitude).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords
</code></pre>


<h3>Format</h3>


<dl>
<dt>Longitude</dt><dd><p>Longitude coordinate of the centroid of the county.</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude coordinate of the centroid of the county.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='coords_xy'>Geographical coordinates of US Kansas counties' centroids in 2000
(X/Y based on Web Mercator)</h2><span id='topic+coords_xy'></span>

<h3>Description</h3>

<p>A dataset containing the geographical coordinates of US Kansas counties'
centroids in 2000 (X/Y based on Web Mercator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords_xy
</code></pre>


<h3>Format</h3>


<dl>
<dt>X</dt><dd><p>X coordinate of the centroid of the county.</p>
</dd>
<dt>Y</dt><dd><p>Y coordinate of the centroid of the county.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='county'>Spatial distribution of US Kansas counties in 2000</h2><span id='topic+county'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of 105 US Kansas counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>county
</code></pre>


<h3>Format</h3>


<dl>
<dt>ID</dt><dd><p>County ID.</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude coordinate of the centroid of the county.</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude coordinate of the centroid of the county.</p>
</dd>
<dt>Area</dt><dd><p>Surface area of the county (in square kilometers).</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the county.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='distance'>Great-circle distances between US Kansas counties</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>A dataset containing the great-circle distance (in kilometers) between 105
US Kansas counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 105 rows and 105 columns. Each element of the
matrix represents the distance between two counties. County IDs are used as
row names and column names.
</p>


<h3>Source</h3>

<p><a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html</a>
</p>

<hr>
<h2 id='extract_distances'>Compute the distance between pairs of locations</h2><span id='topic+extract_distances'></span>

<h3>Description</h3>

<p>This function computes the distance between pairs of locations based on
geographical coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_distances(
  coords,
  method = "Haversine",
  id = NULL,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_distances_+3A_coords">coords</code></td>
<td>
<p>A two-column <code>matrix</code> or <code>data.frame</code> where each row represents
the coordinates of a location (see Details).</p>
</td></tr>
<tr><td><code id="extract_distances_+3A_method">method</code></td>
<td>
<p>A <code>character</code> string indicating which method to choose to
compute the distances (see Details). Available options are <code>"Haversine"</code> or
<code>"Euclidean"</code>.</p>
</td></tr>
<tr><td><code id="extract_distances_+3A_id">id</code></td>
<td>
<p>A vector with length equal to the number of locations, used as
row names and column names for the output distance matrix (optional, <code>NULL</code>
by default).</p>
</td></tr>
<tr><td><code id="extract_distances_+3A_show_progress">show_progress</code></td>
<td>
<p>A boolean indicating whether a progress bar should be
displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coords</code> must contain two columns: the first one for the longitude
or &quot;X&quot; coordinates, and the second one for the latitude or &quot;Y&quot; coordinates.
The <code>"Haversine"</code> method is used to compute great-circle distances from
longitude/latitude, while the <code>"Euclidean"</code> method should be used for &quot;X/Y&quot;
coordinates.
</p>


<h3>Value</h3>

<p>A square matrix representing the distance (in kilometers) between locations.
</p>


<h3>Note</h3>

<p>The outputs are based on the locations contained in <code>coords</code>, sorted
in the same order. An optional <code>id</code> can also be provided to be used as
names for the outputs.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p>Associated functions:
<a href="#topic+extract_spatial_information">extract_opportunities()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coords)

distance &lt;- extract_distances(coords = coords, 
                              method = "Haversine",
                              id = rownames(coords))

</code></pre>

<hr>
<h2 id='extract_opportunities'>Compute the number of opportunities between pairs of locations</h2><span id='topic+extract_opportunities'></span>

<h3>Description</h3>

<p>This function computes the number of opportunities between pairs of locations
as defined in Lenormand <em>et al.</em> (2016). For a given pair of locations,
the number of opportunities between the origin location and the destination
location is based on the number of opportunities within a circle of radius
equal to the distance between the origin and the destination, with the
origin location as the center. The number of opportunities at the origin
and destination locations are not included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_opportunities(opportunity, distance, check_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_opportunities_+3A_opportunity">opportunity</code></td>
<td>
<p>A <code>numeric</code> vector representing the number of opportunities
per location. The value should be positive.</p>
</td></tr>
<tr><td><code id="extract_opportunities_+3A_distance">distance</code></td>
<td>
<p>A squared <code>matrix</code> representing the distances between
locations.</p>
</td></tr>
<tr><td><code id="extract_opportunities_+3A_check_names">check_names</code></td>
<td>
<p>A <code>boolean</code> indicating whether the location IDs are used
as <code>vector</code> names, <code>matrix</code> row names, and <code>matrix</code> column names, and
whether they should be checked (see Note).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A squared <code>matrix</code> in which each element represents the number of
opportunities between a pair of locations.
</p>


<h3>Note</h3>

<p><code>opportunity</code> and <code>distance</code> should be based on the same number of
locations sorted in the same order. It is recommended to use the location ID
as <code>matrix</code> <code>rownames</code> and <code>matrix</code> <code>colnames</code> and to set
<code>check_names = TRUE</code> to verify that everything is consistent before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to validate all inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>


<h3>See Also</h3>

<p>Associated functions:
<code><a href="#topic+extract_distances">extract_distances()</a></code>, <code><a href="#topic+extract_spatial_information">extract_spatial_information()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

opportunity &lt;- mass[, 1]

sij &lt;- extract_opportunities(opportunity = opportunity,
                             distance = distance,
                             check_names = FALSE)

</code></pre>

<hr>
<h2 id='extract_spatial_information'>Extract distances and surface areas from a spatial object</h2><span id='topic+extract_spatial_information'></span>

<h3>Description</h3>

<p>This function returns a <code>matrix</code> of distances between locations (in
kilometers) along with a vector of surface areas for the locations (in square
kilometers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_spatial_information(geometry, id = NULL, show_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_spatial_information_+3A_geometry">geometry</code></td>
<td>
<p>A spatial object that can be handled by the <code>sf</code> package.</p>
</td></tr>
<tr><td><code id="extract_spatial_information_+3A_id">id</code></td>
<td>
<p>The name or number of the column to use as <code>rownames</code> and
<code>colnames</code> for the output distance <code>matrix</code> (optional, <code>NULL</code> by default). A
<code>vector</code> with a length equal to the number of locations can also be used.</p>
</td></tr>
<tr><td><code id="extract_spatial_information_+3A_show_progress">show_progress</code></td>
<td>
<p>A <code>boolean</code> indicating whether a progress bar should be
displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>geometry</code> must be projected in a valid coordinate reference
system. It will be reprojected in degrees longitude/latitude to compute the
great-circle distances between centroids of locations using an internal
function and to compute the surface area using the function
<a href="sf.html#topic+geos_measures">st_area</a> from the
<a href="https://cran.r-project.org/package=sf">sf</a> package.
</p>


<h3>Value</h3>

<p>A <code>list</code> composed of two elements. The first element is a square <code>matrix</code>
representing the great-circle distances (in kilometers) between locations.
The second element is a vector containing the surface area of each location
(in square kilometers).
</p>


<h3>Note</h3>

<p>The outputs are based on the locations contained in <code>geometry</code> and
sorted in the same order. An optional <code>id</code> can also be provided to be used as
names for the outputs.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p>'Associated functions:
<code><a href="#topic+extract_distances">extract_distances()</a></code> <code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(county)

res &lt;- extract_spatial_information(county, id = "ID")

dim(res$distance)

length(res$surface)

</code></pre>

<hr>
<h2 id='gof'>Compute goodness-of-fit measures between observed and simulated OD matrices</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>This function returns a <code>data.frame</code> where each row provides one or
several goodness-of-fit measures between a simulated and an observed
Origin-Destination (OD) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(
  sim,
  obs,
  measures = "all",
  distance = NULL,
  bin_size = 2,
  use_proba = FALSE,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_+3A_sim">sim</code></td>
<td>
<p>An object of class <code>TDLM</code> (output of <code><a href="#topic+run_law_model">run_law_model()</a></code>,
<code><a href="#topic+run_law">run_law()</a></code>, or <code><a href="#topic+run_model">run_model()</a></code>). A matrix or a list of matrices can also be
used (see Note).</p>
</td></tr>
<tr><td><code id="gof_+3A_obs">obs</code></td>
<td>
<p>A square <code>matrix</code> representing the observed mobility flows.</p>
</td></tr>
<tr><td><code id="gof_+3A_measures">measures</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string
indicating which goodness-of-fit measure(s) to compute (see Details).
Available options are <code>"CPC"</code>, <code>"NRMSE"</code>, <code>"KL"</code>, <code>"CPL"</code>, <code>"CPC_d"</code> and
<code>"KS"</code>. If <code>"all"</code> is specified, all measures will be calculated.</p>
</td></tr>
<tr><td><code id="gof_+3A_distance">distance</code></td>
<td>
<p>A square <code>matrix</code> representing the distances between
locations. This is only necessary for distance-based measures.</p>
</td></tr>
<tr><td><code id="gof_+3A_bin_size">bin_size</code></td>
<td>
<p>A <code>numeric</code> value indicating the size of bins used to
discretize the distance distribution when computing CPC_d (default is 2
kilometers).</p>
</td></tr>
<tr><td><code id="gof_+3A_use_proba">use_proba</code></td>
<td>
<p>A <code>boolean</code> indicating whether the <code>proba</code> matrix should be
used instead of the simulated OD matrix to compute the measure(s). This is
only valid for output from <code><a href="#topic+run_law_model">run_law_model()</a></code> with the argument
<code>write_proba = TRUE</code> (see Note).</p>
</td></tr>
<tr><td><code id="gof_+3A_check_names">check_names</code></td>
<td>
<p>A <code>boolean</code> indicating whether the location IDs used as
matrix rownames and colnames should be checked for consistency
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several goodness-of-fit measures are considered, such as the Common Part
of Commuters (CPC), the Common Part of Links (CPL), and the Common Part of
Commuters based on the distance (CPC_d), as described in <a href="http://arxiv.org/abs/1506.04889">Lenormand <em>et al.</em> (2016)</a>. It also includes
classical metrics such as the
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#normalized-root-mean-square-error-nrmse">Normalized Root Mean Square Error</a>
(NRMSE), the
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#kullbackleibler-divergence-ks">Kullback–Leibler divergence</a>
(KL), and the Kolmogorov-Smirnov statistic and
p-value (KS). These measures are based on the observed and simulated flow
distance distributions and are computed using the <a href="Ecume.html#topic+ks_test">ks_test</a>
function from the <a href="https://cran.r-project.org/package=Ecume">Ecume</a> package.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> providing one or several goodness-of-fit measures between
simulated OD(s) and an observed OD. Each row corresponds to a matrix sorted
according to the list (or list of lists) elements (names are used if
provided).
</p>


<h3>Note</h3>

<p>By default, if <code>sim</code> is an output of <code><a href="#topic+run_law_model">run_law_model()</a></code>,
the measure(s) are computed only for the simulated OD matrices and
not for the <code>proba</code> matrix (included in the output when
<code>write_proba = TRUE</code>). The argument <code>use_proba</code> can be used to compute the
measure(s) based on the <code>proba</code> matrix instead of the simulated
OD matrix. In this case, the argument <code>obs</code> should also be a <code>proba</code> matrix.
</p>
<p>All inputs should be based on the same number of
locations, sorted in the same order. It is recommended to use the location ID
as <code>matrix</code> <code>rownames</code> and <code>matrix</code> <code>colnames</code> and to set
<code>check_names = TRUE</code> to verify that everything is consistent before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to validate all inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#goodness-of-fit-measures">https://epivec.github.io/TDLM/articles/TDLM.html#goodness-of-fit-measures</a>.
</p>
<p>Associated functions:
<code><a href="#topic+run_law">run_law()</a></code>, <code><a href="#topic+run_model">run_model()</a></code>, <code><a href="#topic+run_law_model">run_law_model()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)
data(od)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi
Oi &lt;- as.numeric(mass[, 2])
Dj &lt;- as.numeric(mass[, 3])

res &lt;- run_law_model(law = "GravExp", 
                     mass_origin = mi, 
                     mass_destination = mj,
                     distance = distance, 
                     opportunity = NULL, 
                     param = 0.01,
                     model = "DCM", 
                     nb_trips = NULL, 
                     out_trips = Oi, 
                     in_trips = Dj,
                     average = FALSE, 
                     nbrep = 1, 
                     maxiter = 50, 
                     mindiff = 0.01,
                     write_proba = FALSE,
                     check_names = FALSE)

gof(sim = res, 
    obs = od, 
    measures = "CPC", 
    distance = NULL, 
    bin_size = 2,
    use_proba = FALSE,
    check_names = FALSE)

</code></pre>

<hr>
<h2 id='mass'>Population and number of out- and in-commuters by US Kansas county in 2000</h2><span id='topic+mass'></span>

<h3>Description</h3>

<p>A dataset containing the number of inhabitants, in-commuters, and
out-commuters for 105 US Kansas counties in 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 105 rows and 4 columns:
</p>

<dl>
<dt>rownames</dt><dd><p>County ID.</p>
</dd>
<dt>Population</dt><dd><p>Number of inhabitants.</p>
</dd>
<dt>Out-commuters</dt><dd><p>Number of out-commuters.</p>
</dd>
<dt>In-commuters</dt><dd><p>Number of in-commuters.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/">https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/</a>
</p>

<hr>
<h2 id='od'>Origin-Destination commuting matrix between US Kansas counties in 2000</h2><span id='topic+od'></span>

<h3>Description</h3>

<p>A dataset containing the number of commuters between 105 US Kansas counties
in 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 105 rows and 105 columns. Each element of the
matrix represents the number of commuters between two counties. County IDs
are used as row names and column names.
</p>


<h3>Source</h3>

<p><a href="https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/">https://www2.census.gov/programs-surveys/decennial/tables/2000/county-to-county-worker-flow-files/</a>
</p>

<hr>
<h2 id='run_law'>Estimate mobility flows based on different trip distribution laws</h2><span id='topic+run_law'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution laws
and models. As described in Lenormand <em>et al.</em> (2016), the
function uses a two-step approach to generate mobility flows by separating
the trip distribution law (gravity or intervening opportunities) from the
modeling approach used to generate the flows based on this law. This function
only uses the first step to generate a probability distribution based on the
different laws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_law(
  law = "Unif",
  mass_origin,
  mass_destination = mass_origin,
  distance = NULL,
  opportunity = NULL,
  param = NULL,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_law_+3A_law">law</code></td>
<td>
<p>A <code>character</code> indicating which law to use (see Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_mass_origin">mass_origin</code></td>
<td>
<p>A <code>numeric</code> vector representing the mass at the origin (i.e.
demand).</p>
</td></tr>
<tr><td><code id="run_law_+3A_mass_destination">mass_destination</code></td>
<td>
<p>A <code>numeric</code> vector representing the mass at
the destination (i.e. attractiveness).</p>
</td></tr>
<tr><td><code id="run_law_+3A_distance">distance</code></td>
<td>
<p>A squared <code>matrix</code> representing the distance between locations
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_opportunity">opportunity</code></td>
<td>
<p>A squared <code>matrix</code> representing the number of opportunities
between locations (see Details). Can be easily computed with
<code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>.</p>
</td></tr>
<tr><td><code id="run_law_+3A_param">param</code></td>
<td>
<p>A <code>numeric</code> vector or a single <code>numeric</code> value used to adjust
the importance of <code>distance</code> or <code>opportunity</code> associated with the chosen law.
Not necessary for the original radiation law or the uniform law (see
Details).</p>
</td></tr>
<tr><td><code id="run_law_+3A_check_names">check_names</code></td>
<td>
<p>A <code>boolean</code> indicating whether the location IDs used as
matrix rownames and colnames should be checked for consistency
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We compute the matrix <code>proba</code> estimating the probability to observe a
trip from one location to another. This probability is based on the demand
(argument <code>mass_origin</code>) and the attractiveness (argument
<code>mass_destination</code>). Note that the population is typically used as a
surrogate for both quantities (this is why <code>mass_destination = mass_origin</code>
by default). It also depends on the distance between locations
(argument <code>distance</code>) OR the number of opportunities between locations
(argument <code>opportunity</code>) depending on the chosen law. Both the effect of the
distance and the number of opportunities can be adjusted with a parameter
(argument <code>param</code>) except for the original radiation law and the uniform law.
</p>
<p>In this package we consider eight probabilistic laws described in details in
Lenormand <em>et al.</em> (2016). Four
gravity laws (Barthelemy, 2011), three
intervening opportunity laws (Schneider, 1959; Simini <em>et al.</em>, 2012;
Yang <em>et al.</em>, 2014) and a uniform law.
</p>

<ol>
<li><p> Gravity law with an exponential distance decay function
(<code>law = "GravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with an exponential distance decay function
(<code>law = "NGravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Gravity law with a power distance decay function
(<code>law = "GravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with a power distance decay function
(<code>law = "NGravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Schneider's intervening opportunities law (<code>law = "Schneider"</code>). The
arguments <code>mass_origin</code>, <code>mass_destination</code> (optional), <code>opportunity</code> and
<code>param</code> will be used.
</p>
</li>
<li><p> Radiation law (<code>law = "Rad"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional) and <code>opportunity</code> will be used.
</p>
</li>
<li><p> Extended radiation law (<code>law = "RadExt"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional), <code>opportunity</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Uniform law (<code>law = "Unif"</code>). The argument <code>mass_origin</code> will be used to
extract the number of locations.
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <code>TDLM</code>. An object of class <code>TDLM</code>. A <code>list</code> of <code>list</code> of
matrice containing for each parameter value the matrix of probabilities
(called <code>proba</code>). If <code>length(param) = 1</code> or <code>law = "Rad"</code> or <code>law = "Unif"</code>
only a list of matrices will be returned.
</p>


<h3>Note</h3>

<p>All inputs should be based on the same number of
locations, sorted in the same order. It is recommended to use the location ID
as <code>matrix</code> <code>rownames</code> and <code>matrix</code> <code>colnames</code> and to set
<code>check_names = TRUE</code> to verify that everything is consistent before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to validate all inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Barthelemy M (2011). Spatial Networks. <em>Physics Reports</em> 499, 1-101.
</p>
<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>
<p>Schneider M (1959) Gravity models and trip distribution theory. <em>Papers
of the regional science association</em> 5, 51-58.
</p>
<p>Simini F, González MC, Maritan A &amp; Barabási A (2012) A universal model for
mobility and migration patterns. <em>Nature</em> 484, 96-100.
</p>
<p>Yang Y, Herrera C, Eagle N &amp; González MC (2014) Limits of Predictability in
Commuting Flows in the Absence of Data for Calibration. <em>Scientific
Reports</em> 4, 5662.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#run-functions">https://epivec.github.io/TDLM/articles/TDLM.html#run-functions</a>.
</p>
<p>Associated functions:
<code><a href="#topic+run_law_model">run_law_model()</a></code>, <code><a href="#topic+run_model">run_model()</a></code>, <code><a href="#topic+gof">gof()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi

res &lt;- run_law(
  law = "GravExp", mass_origin = mi, mass_destination = mj,
  distance = distance, opportunity = NULL, param = 0.01,
  check_names = FALSE
)

# print(res)

</code></pre>

<hr>
<h2 id='run_law_model'>Estimate mobility flows based on different trip distribution laws and models</h2><span id='topic+run_law_model'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution laws and
models. As described in Lenormand <em>et al.</em> (2016), the
function uses a two-step approach to generate mobility flows by separating
the trip distribution law (gravity or intervening opportunities) from the
modeling approach used to generate the flows based on this law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_law_model(
  law = "Unif",
  mass_origin,
  mass_destination = mass_origin,
  distance = NULL,
  opportunity = NULL,
  param = NULL,
  model = "UM",
  nb_trips = 1000,
  out_trips = NULL,
  in_trips = out_trips,
  average = FALSE,
  nbrep = 3,
  maxiter = 50,
  mindiff = 0.01,
  write_proba = FALSE,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_law_model_+3A_law">law</code></td>
<td>
<p>A <code>character</code> indicating which law to use (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mass_origin">mass_origin</code></td>
<td>
<p>A <code>numeric</code> vector representing the mass at the origin (i.e.
demand).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mass_destination">mass_destination</code></td>
<td>
<p>A <code>numeric</code> vector representing the mass at
the destination (i.e. attractiveness).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_distance">distance</code></td>
<td>
<p>A squared <code>matrix</code> representing the distance between locations
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_opportunity">opportunity</code></td>
<td>
<p>A squared <code>matrix</code> representing the number of opportunities
between locations (see Details). Can be easily computed with
<code><a href="#topic+extract_opportunities">extract_opportunities()</a></code>.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_param">param</code></td>
<td>
<p>A <code>numeric</code> vector or a single <code>numeric</code> value used to adjust
the importance of <code>distance</code> or <code>opportunity</code> associated with the chosen law.
Not necessary for the original radiation law or the uniform law (see
Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_model">model</code></td>
<td>
<p>A <code>character</code> indicating which model to use.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_nb_trips">nb_trips</code></td>
<td>
<p>A <code>numeric</code> value indicating the total number of trips. Must
be an <code>integer</code> if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_out_trips">out_trips</code></td>
<td>
<p>A <code>numeric</code> vector representing the number of outgoing
trips per location. Must be a vector of integers if <code>average = FALSE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_in_trips">in_trips</code></td>
<td>
<p>A <code>numeric</code> vector representing the number of incoming
trips per location. Must be a vector of integers if <code>average = FALSE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_average">average</code></td>
<td>
<p>A <code>boolean</code> indicating if the average mobility flow matrix
should be generated instead of the <code>nbrep</code> matrices based on random draws
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_nbrep">nbrep</code></td>
<td>
<p>An <code>integer</code> indicating the number of replications
associated with the model run. Note that <code>nbrep = 1</code> if <code>average = TRUE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_maxiter">maxiter</code></td>
<td>
<p>An <code>integer</code> indicating the maximal number of iterations for
adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_mindiff">mindiff</code></td>
<td>
<p>A <code>numeric</code> strictly positive value indicating the
stopping criterion for adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_write_proba">write_proba</code></td>
<td>
<p>A <code>boolean</code> indicating if the estimation of the
probability to move from one location to another obtained with the
distribution law should be returned along with the flow estimations.</p>
</td></tr>
<tr><td><code id="run_law_model_+3A_check_names">check_names</code></td>
<td>
<p>A <code>boolean</code> indicating whether the location IDs used as
matrix rownames and colnames should be checked for consistency
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, we compute the matrix <code>proba</code> estimating the probability to observe a
trip from one location to another. This probability is based on the demand
(argument <code>mass_origin</code>) and the attractiveness (argument
<code>mass_destination</code>). Note that the population is typically used as a
surrogate for both quantities (this is why <code>mass_destination = mass_origin</code>
by default). It also depends on the distance between locations
(argument <code>distance</code>) OR the number of opportunities between locations
(argument <code>opportunity</code>) depending on the chosen law. Both the effect of the
distance and the number of opportunities can be adjusted with a parameter
(argument <code>param</code>) except for the original radiation law and the uniform law.
</p>
<p>In this package we consider eight probabilistic laws described in details in
Lenormand <em>et al.</em> (2016). Four
gravity laws (Barthelemy, 2011), three
intervening opportunity laws (Schneider, 1959; Simini <em>et al.</em>, 2012;
Yang <em>et al.</em>, 2014) and a uniform law.
</p>

<ol>
<li><p> Gravity law with an exponential distance decay function
(<code>law = "GravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with an exponential distance decay function
(<code>law = "NGravExp"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Gravity law with a power distance decay function
(<code>law = "GravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Normalized gravity law with a power distance decay function
(<code>law = "NGravPow"</code>). The arguments <code>mass_origin</code>, <code>mass_destination</code>
(optional), <code>distance</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Schneider's intervening opportunities law (<code>law = "Schneider"</code>). The
arguments <code>mass_origin</code>, <code>mass_destination</code> (optional), <code>opportunity</code> and
<code>param</code> will be used.
</p>
</li>
<li><p> Radiation law (<code>law = "Rad"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional) and <code>opportunity</code> will be used.
</p>
</li>
<li><p> Extended radiation law (<code>law = "RadExt"</code>). The arguments <code>mass_origin</code>,
<code>mass_destination</code> (optional), <code>opportunity</code> and <code>param</code> will be used.
</p>
</li>
<li><p> Uniform law (<code>law = "Unif"</code>). The argument <code>mass_origin</code> will be used to
extract the number of locations.
</p>
</li></ol>

<p>Second, we propose four constrained models to generate the flows from these
distribution of probability as described in Lenromand <em>et al.</em> (2016).
These models respect different level of constraints. These constraints can
preserve the total number of trips (argument <code>nb_trips</code>) OR the number of
out-going trips (argument <code>out_trips</code>) AND/OR the number of in-coming
(argument <code>in_trips</code>) according to the model. The sum of out-going trips
should be equal to the sum of in-coming trips.
</p>

<ol>
<li><p> Unconstrained model (<code>model = "UM"</code>). Only <code>nb_trips</code> will be preserved
(arguments <code>out_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Production constrained model (<code>model = "PCM"</code>). Only <code>out_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Attraction constrained model (<code>model = "ACM"</code>). Only <code>in_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>out_trips</code> will not be used).
</p>
</li>
<li><p> Doubly constrained model (<code>model = "DCM"</code>). Both <code>out_trips</code> and
<code>in_trips</code> will be preserved (arguments <code>nb_trips</code>will not be used). The
doubly constrained model is based on an Iterative Proportional Fitting
process (Deming &amp; Stephan, 1940). The arguments <code>maxiter</code> (50 by
default) and <code>mindiff</code> (0.01 by default) can be used to tune the model.
<code>mindiff</code> is the minimal tolerated relative error between the
simulated and observed marginals. <code>maxiter</code> ensures that the algorithm stops
even if it has not converged toward the <code>mindiff</code> wanted value.
</p>
</li></ol>

<p>By default, when <code>average = FALSE</code>, <code>nbrep</code> matrices are generated from
<code>proba</code> with multinomial random draws that will take different forms
according to the model used. In this case, the models will deal with positive
integers as inputs and outputs. Nevertheless, it is also possible to generate
an average matrix based on a multinomial distribution (based on an infinite
number of drawings). In this case, the models' inputs can be either positive
integer or real numbers and the output (<code>nbrep = 1</code> in this case) will be a
matrix of positive real numbers.
</p>


<h3>Value</h3>

<p>An object of class <code>TDLM</code>. A <code>list</code> of <code>list</code> of matrices containing for each
parameter value the <code>nbrep</code> simulated matrices and the matrix of
probabilities (called <code>proba</code>) if <code>write_proba = TRUE</code>. If
<code>length(param) = 1</code> or <code>law = "Rad"</code> or <code>law = "Unif"</code> only a list of
matrices will be returned.
</p>


<h3>Note</h3>

<p>All inputs should be based on the same number of
locations, sorted in the same order. It is recommended to use the location ID
as <code>matrix</code> <code>rownames</code> and <code>matrix</code> <code>colnames</code> and to set
<code>check_names = TRUE</code> to verify that everything is consistent before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to validate all inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Barthelemy M (2011). Spatial Networks. <em>Physics Reports</em> 499, 1-101.
</p>
<p>Deming WE &amp; Stephan FF (1940) On a Least Squares Adjustment of a Sample
Frequency Table When the Expected Marginal Totals Are Known. <em>Annals of
Mathematical Statistics</em> 11, 427-444.
</p>
<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>
<p>Schneider M (1959) Gravity models and trip distribution theory. <em>Papers
of the regional science association</em> 5, 51-58.
</p>
<p>Simini F, González MC, Maritan A &amp; Barabási A (2012) A universal model for
mobility and migration patterns. <em>Nature</em> 484, 96-100.
</p>
<p>Yang Y, Herrera C, Eagle N &amp; González MC (2014) Limits of Predictability in
Commuting Flows in the Absence of Data for Calibration. <em>Scientific
Reports</em> 4, 5662.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#run-functions">https://epivec.github.io/TDLM/articles/TDLM.html#run-functions</a>.
</p>
<p>Associated functions:
<code><a href="#topic+run_law">run_law()</a></code>, <code><a href="#topic+run_model">run_model()</a></code>, <code><a href="#topic+gof">gof()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(distance)

mi &lt;- as.numeric(mass[, 1])
mj &lt;- mi
N &lt;- 1000

res &lt;- run_law_model(law = "GravExp",
                     mass_origin = mi, 
                     mass_destination = mj,
                     distance = distance, 
                     opportunity = NULL, 
                     param = 0.01,
                     model = "UM", 
                     nb_trips = N,
                     out_trips = NULL, 
                     in_trips = NULL,
                     average = TRUE, 
                     nbrep = 2, 
                     maxiter = 50, 
                     mindiff = 0.01,
                     write_proba = FALSE,
                     check_names = FALSE)

print(res)

</code></pre>

<hr>
<h2 id='run_model'>Estimate mobility flows based on different trip distribution models</h2><span id='topic+run_model'></span>

<h3>Description</h3>

<p>This function estimates mobility flows using different distribution laws
and models. As described in Lenormand <em>et al.</em> (2016), the
function uses a two-step approach to generate mobility flows by separating
the trip distribution law (gravity or intervening opportunities) from the
modeling approach used to generate the flows based on this law. This function
only uses the second step to generate mobility flow based on a matrix of
probabilities using different models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_model(
  proba,
  model = "UM",
  nb_trips = 1000,
  out_trips = NULL,
  in_trips = out_trips,
  average = FALSE,
  nbrep = 3,
  maxiter = 50,
  mindiff = 0.01,
  check_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_model_+3A_proba">proba</code></td>
<td>
<p>A squared <code>matrix</code> of probability. The sum of the matrix element
must be equal to 1. It will be normalized automatically if it is not the
case.</p>
</td></tr>
<tr><td><code id="run_model_+3A_model">model</code></td>
<td>
<p>A <code>character</code> indicating which model to use.</p>
</td></tr>
<tr><td><code id="run_model_+3A_nb_trips">nb_trips</code></td>
<td>
<p>A <code>numeric</code> value indicating the total number of trips. Must
be an <code>integer</code> if <code>average = FALSE</code> (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_out_trips">out_trips</code></td>
<td>
<p>A <code>numeric</code> vector representing the number of outgoing
trips per location. Must be a vector of integers if <code>average = FALSE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_in_trips">in_trips</code></td>
<td>
<p>A <code>numeric</code> vector representing the number of incoming
trips per location. Must be a vector of integers if <code>average = FALSE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_average">average</code></td>
<td>
<p>A <code>boolean</code> indicating if the average mobility flow matrix
should be generated instead of the <code>nbrep</code> matrices based on random draws
(see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_nbrep">nbrep</code></td>
<td>
<p>An <code>integer</code> indicating the number of replications
associated with the model run. Note that <code>nbrep = 1</code> if <code>average = TRUE</code>
(see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_maxiter">maxiter</code></td>
<td>
<p>An <code>integer</code> indicating the maximal number of iterations for
adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_mindiff">mindiff</code></td>
<td>
<p>A <code>numeric</code> strictly positive value indicating the
stopping criterion for adjusting the Doubly Constrained Model (see Details).</p>
</td></tr>
<tr><td><code id="run_model_+3A_check_names">check_names</code></td>
<td>
<p>A <code>boolean</code> indicating whether the location IDs used as
matrix rownames and colnames should be checked for consistency
(see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We propose four constrained models to generate the flows from these
distribution of probability as described in Lenromand <em>et al.</em> (2016).
These models respect different level of constraints. These constraints can
preserve the total number of trips (argument <code>nb_trips</code>) OR the number of
out-going trips (argument <code>out_trips</code>) AND/OR the number of in-coming
(argument <code>in_trips</code>) according to the model. The sum of out-going trips
should be equal to the sum of in-coming trips.
</p>

<ol>
<li><p> Unconstrained model (<code>model = "UM"</code>). Only <code>nb_trips</code> will be preserved
(arguments <code>out_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Production constrained model (<code>model = "PCM"</code>). Only <code>out_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>in_trips</code> will not be used).
</p>
</li>
<li><p> Attraction constrained model (<code>model = "ACM"</code>). Only <code>in_trips</code> will be
preserved (arguments <code>nb_trips</code> and <code>out_trips</code> will not be used).
</p>
</li>
<li><p> Doubly constrained model (<code>model = "DCM"</code>). Both <code>out_trips</code> and
<code>in_trips</code> will be preserved (arguments <code>nb_trips</code>will not be used). The
doubly constrained model is based on an Iterative Proportional Fitting
process (Deming &amp; Stephan, 1940). The arguments <code>maxiter</code> (50 by
default) and <code>mindiff</code> (0.01 by default) can be used to tune the model.
<code>mindiff</code> is the minimal tolerated relative error between the
simulated and observed marginals. <code>maxiter</code> ensures that the algorithm stops
even if it has not converged toward the <code>mindiff</code> wanted value.
</p>
</li></ol>

<p>By default, when <code>average = FALSE</code>, <code>nbrep</code> matrices are generated from
<code>proba</code> with multinomial random draws that will take different forms
according to the model used. In this case, the models will deal with positive
integers as inputs and outputs. Nevertheless, it is also possible to generate
an average matrix based on a multinomial distribution (based on an infinite
number of drawings). In this case, the models' inputs can be either positive
integer or real numbers and the output (<code>nbrep = 1</code> in this case) will be a
matrix of positive real numbers.
</p>


<h3>Value</h3>

<p>An object of class <code>TDLM</code>. A <code>list</code> of matrices containing the <code>nbrep</code>
simulated matrices.
</p>


<h3>Note</h3>

<p>All inputs should be based on the same number of
locations, sorted in the same order. It is recommended to use the location ID
as <code>matrix</code> <code>rownames</code> and <code>matrix</code> <code>colnames</code> and to set
<code>check_names = TRUE</code> to verify that everything is consistent before running
this function (<code>check_names = FALSE</code> by default). Note that the function
<code><a href="#topic+check_format_names">check_format_names()</a></code> can be used to validate all inputs
before running the main package's functions.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Deming WE &amp; Stephan FF (1940) On a Least Squares Adjustment of a Sample
Frequency Table When the Expected Marginal Totals Are Known. <em>Annals of
Mathematical Statistics</em> 11, 427-444.
</p>
<p>Lenormand M, Bassolas A, Ramasco JJ (2016) Systematic comparison of trip
distribution laws and models. <em>Journal of Transport Geography</em> 51,
158-169.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://epivec.github.io/TDLM/articles/TDLM.html#run-functions">https://epivec.github.io/TDLM/articles/TDLM.html#run-functions</a>.
</p>
<p>Associated functions:
<code><a href="#topic+run_law_model">run_law_model()</a></code>, <code><a href="#topic+run_law">run_law()</a></code>, <code><a href="#topic+gof">gof()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mass)
data(od)

proba &lt;- od / sum(od)

Oi &lt;- as.numeric(mass[, 2])
Dj &lt;- as.numeric(mass[, 3])

res &lt;- run_model(
  proba = proba,
  model = "DCM", nb_trips = NULL, out_trips = Oi, in_trips = Dj,
  average = FALSE, nbrep = 3, maxiter = 50, mindiff = 0.01,
  check_names = FALSE
)

# print(res)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
