<!DOCTYPE html><html><head><title>Help for package smam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smam'><p>smam: Statistical Modeling of Animal Movements</p></a></li>
<li><a href='#approxNormalOrder'><p>Auxiliary for Preparing Discrete Distribution</p>
used to approximating Standard Normal Distribution</a></li>
<li><a href='#dtm'><p>Density for Time Spent in Moving or Resting</p></a></li>
<li><a href='#estimate'><p>Estimate Result of smam Estimators</p></a></li>
<li><a href='#estVarMRME_Godambe'><p>Variance matrix of estimators from moving-resting process with measurement error</p></a></li>
<li><a href='#f109'><p>GPS data of f109</p></a></li>
<li><a href='#f109raw'><p>GPS data of f109 (raw format)</p></a></li>
<li><a href='#fitBMME'><p>Fit a Brownian Motion with Measurement Error</p></a></li>
<li><a href='#fitMM'><p>Fit a Moving-Moving Model with 2 Embedded Brownian Motion</p></a></li>
<li><a href='#fitMR'><p>Fit a Moving-Resting Model with Embedded Brownian Motion</p></a></li>
<li><a href='#fitMRH'><p>Fit a Moving-Resting-Handling Model with Embedded Brownian Motion</p></a></li>
<li><a href='#fitMRME'><p>Fit a Moving-Resting Model with Measurement Error</p></a></li>
<li><a href='#fitStateMR'><p>Estimation of states at each time point with Moving-Resting Process</p></a></li>
<li><a href='#fitStateMRH'><p>Estimation of states at each time point with Moving-Resting-Handling Process</p></a></li>
<li><a href='#integr.control'><p>Auxiliary for Controlling Numerical Integration</p></a></li>
<li><a href='#rBB'><p>Sampling from a Brownian bridge path give a grid time</p></a></li>
<li><a href='#rBMME'><p>Sampling from Brown Motion with Measurement Error</p></a></li>
<li><a href='#rMM'><p>Sampling from a Moving-Moving Process with 2 Embedded Brownian Motion</p></a></li>
<li><a href='#rMR'><p>Sampling from a Moving-Resting Process with Embedded Brownian Motion</p></a></li>
<li><a href='#rMRB'><p>Sampling from a Moving-Resting bridge</p></a></li>
<li><a href='#rMRH'><p>Sampling from a Moving-Resting-Handling Process with Embedded Brownian Motion</p></a></li>
<li><a href='#seasonFilter'><p>Subsetting data during given season for each year (seasonal analysis toolbox)</p></a></li>
<li><a href='#transfData'><p>Transfer raw dataset to the standard dataset (seasonal analysis toolbox)</p></a></li>
<li><a href='#vcov'><p>Variance-Covariance Matrix of smam Estimators</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Modeling of Animal Movements</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Animal movement models including Moving-Resting Process
    with Embedded Brownian Motion
    (Yan et al., 2014, &lt;<a href="https://doi.org/10.1007%2Fs10144-013-0428-8">doi:10.1007/s10144-013-0428-8</a>&gt;;
    Pozdnyakov et al., 2017, &lt;<a href="https://doi.org/10.1007%2Fs11009-017-9547-6">doi:10.1007/s11009-017-9547-6</a>&gt;),
    Brownian Motion with Measurement Error
    (Pozdnyakov et al., 2014, &lt;<a href="https://doi.org/10.1890%2F13-0532.1">doi:10.1890/13-0532.1</a>&gt;),
    Moving-Resting-Handling Process with Embedded Brownian Motion
    (Pozdnyakov et al., 2020, &lt;<a href="https://doi.org/10.1007%2Fs11009-020-09774-1">doi:10.1007/s11009-020-09774-1</a>&gt;),
    Moving-Resting Process with Measurement Error
    (Hu et al., 2021, &lt;<a href="https://doi.org/10.1111%2F2041-210X.13694">doi:10.1111/2041-210X.13694</a>&gt;),
    Moving-Moving Process with two Embedded Brownian Motions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>nloptr, Matrix, stats, Rcpp, RcppParallel, doParallel,
foreach, parallel, doSNOW, methods, numDeriv, EnvStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppGSL, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU GSL, GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ChaoranHu/smam/issues">https://github.com/ChaoranHu/smam/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ChaoranHu/smam">https://github.com/ChaoranHu/smam</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 21:03:45 UTC; chaoranhu</td>
</tr>
<tr>
<td>Author:</td>
<td>Chaoran Hu [aut, cre],
  Vladimir Pozdnyakov [aut],
  Jun Yan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chaoran Hu &lt;huchaoran.stat@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smam'>smam: Statistical Modeling of Animal Movements</h2><span id='topic+smam'></span><span id='topic+smam-package'></span>

<h3>Description</h3>

<p>Animal movement models including
Moving-Resting Process with Embedded Brownian Motion,
Brownian Motion with Measurement Error,
Moving-Resting-Handling Process with Embedded Brownian Motion,
Moving-Resting Process with Measurement Error,
Moving-Moving Process with two Embedded Brownian Motions.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> *maintainer, author* Chaoran Hu <a href="mailto:huchaoran.stat@gmail.com">huchaoran.stat@gmail.com</a>
</p>
</li>
<li><p> *author* Vladimir Pozdnyakov <a href="mailto:vladimir.pozdnyakov@uconn.edu">vladimir.pozdnyakov@uconn.edu</a>
</p>
</li>
<li><p> *author* Jun Yan <a href="mailto:jun.yan@uconn.edu">jun.yan@uconn.edu</a>
</p>
</li></ul>


<hr>
<h2 id='approxNormalOrder'>Auxiliary for Preparing Discrete Distribution
used to approximating Standard Normal Distribution</h2><span id='topic+approxNormalOrder'></span><span id='topic+approxNormalOrder2'></span>

<h3>Description</h3>

<p>Auxiliary for preparing discrete distribution used to
approximate standard normal. This function generates
order statistics of standard normal with same probability
assigned. Then, the discrete distribution is standardized
to variance one and mean zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxNormalOrder(m)

approxNormalOrder2(m, width)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxNormalOrder_+3A_m">m</code></td>
<td>
<p>int, the number of order statistics used</p>
</td></tr>
<tr><td><code id="approxNormalOrder_+3A_width">width</code></td>
<td>
<p>the width between two consecutive grid points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function use <code>EnvStats::evNormOrdStats</code> to get
the order statisics of standard normal distribution. The
same probability is assigned for each order statistics.
</p>


<h3>Value</h3>

<p>A numeric matrix with first column is support of discrete
distribution and second column is corresponding p.m.f..
</p>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>See Also</h3>

<p><code>EnvStats::evNormOrdStats</code> for order
statisics of standard normal. <code><a href="#topic+fitMRMEapprox">fitMRMEapprox</a></code>
for fit MRME with approximated measurement error.
</p>

<hr>
<h2 id='dtm'>Density for Time Spent in Moving or Resting</h2><span id='topic+dtm'></span><span id='topic+dtr'></span>

<h3>Description</h3>

<p>Density for time spent in moving or resting in a time interval,
unconditional or conditional on the initial state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtm(w, t, lamM, lamR, s0 = NULL)

dtr(w, t, lamM, lamR, s0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtm_+3A_w">w</code></td>
<td>
<p>time points at which the density is to be evaluated</p>
</td></tr>
<tr><td><code id="dtm_+3A_t">t</code></td>
<td>
<p>length of the time interval</p>
</td></tr>
<tr><td><code id="dtm_+3A_lamm">lamM</code></td>
<td>
<p>rate parameter of the exponentially distributed duration in moving</p>
</td></tr>
<tr><td><code id="dtm_+3A_lamr">lamR</code></td>
<td>
<p>rate parameter of the exponentially distributed duration in resting</p>
</td></tr>
<tr><td><code id="dtm_+3A_s0">s0</code></td>
<td>
<p>initial state. If <code>NULL</code>, the unconditional density is
returned; otherwise, it is one of &quot;m&quot; or &quot;s&quot;, standing for moving and
resting, respectively, and the conditional density is returned given
the initial state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dtm</code> returns the density for time in moving;
<code>dtr</code> returns the density for time in resting.
</p>


<h3>Value</h3>

<p>a vector of the density evaluated at <code>w</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dtr()</code>: Density of time spent in resting
</p>
</li></ul>


<h3>References</h3>

<p>Yan, J., Chen, Y., Lawrence-Apfel, K., Ortega, I. M., Pozdnyakov, V.,
Williams, S., and Meyer, T. (2014) A moving-resting process with an
embedded Brownian motion for animal movements.
Population Ecology. 56(2): 401&ndash;415.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lamM &lt;- 1
lamR &lt;- c(1/2, 1, 2)
lr &lt;- length(lamR)
totalT &lt;- 10
old.par &lt;- par(no.readonly=TRUE)
par(mfrow=c(1, 2), mar=c(2.5, 2.5, 1.1, 0.1), mgp=c(1.5, 0.5, 0), las=1)
curve(dtm(x, totalT, 1, 1/2, "m"), 0, totalT, lty=1, ylim=c(0, 0.34),
      xlab="M(10)", ylab="density")
curve(dtm(x, totalT, 1, 1, "m"), 0, totalT, lty=2, add=TRUE)
curve(dtm(x, totalT, 1, 2, "m"), 0, totalT, lty=3, add=TRUE)
mtext(expression("S(0) = 1"))
legend("topleft", legend = expression(lambda[r] == 1/2, lambda[r] == 1,
       lambda[r] == 2), lty = 1:lr)
curve(dtm(x, totalT, 1, 1/2, "r"), 0, totalT, lty=1, ylim=c(0, 0.34),
      xlab="M(10)", ylab="density")
curve(dtm(x, totalT, 1, 1, "r"), 0, totalT, lty=2, add=TRUE)
curve(dtm(x, totalT, 1, 2, "r"), 0, totalT, lty=3, add=TRUE)
mtext(expression("S(0) = 0"))
legend("topleft", legend = expression(lambda[r] == 1/2, lambda[r] == 1,
      lambda[r] == 2), lty = 1:lr)
par(old.par)

</code></pre>

<hr>
<h2 id='estimate'>Estimate Result of smam Estimators</h2><span id='topic+estimate'></span><span id='topic+estimate.smam_mrme'></span><span id='topic+estimate.smam_mr'></span><span id='topic+estimate.smam_mm'></span><span id='topic+estimate.smam_mrh'></span><span id='topic+estimate.smam_bmme'></span>

<h3>Description</h3>

<p>'estimate' function returns the estimate result
of 'smam::fitXXXX' from smam package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(x, ...)

## S3 method for class 'smam_mrme'
estimate(x, ...)

## S3 method for class 'smam_mr'
estimate(x, ...)

## S3 method for class 'smam_mm'
estimate(x, ...)

## S3 method for class 'smam_mrh'
estimate(x, ...)

## S3 method for class 'smam_bmme'
estimate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_x">x</code></td>
<td>
<p>a fitted object from one of 'smam::fitXXXX' functions</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## time consuming example
#tgrid &lt;- seq(0, 100, length=100)
#set.seed(123)
#dat &lt;- rMRME(tgrid, 1, 0.5, 1, 0.01, "m")

## fit whole dataset to the MRME model
#fit &lt;- fitMRME(dat, start=c(1, 0.5, 1, 0.01))
#fit

## get covariance matrix of estimators
#estimate(fit)

</code></pre>

<hr>
<h2 id='estVarMRME_Godambe'>Variance matrix of estimators from moving-resting process with measurement error</h2><span id='topic+estVarMRME_Godambe'></span><span id='topic+estVarMRME_pBootstrap'></span><span id='topic+estVarMRMEnaive_Godambe'></span><span id='topic+estVarMRMEnaive_pBootstrap'></span>

<h3>Description</h3>

<p>'estVarMRME_Godambe' uses Godambe information matrix to obtain variance matrix
of estimators from 'fitMRME'.
'estVarMRME_pBootstrap' uses parametric bootstrap to obtain variance matrix
of estimators from 'fitMRME'.
'estVarMRMEnaive_Godambe' use Godambe information matrix to obtain variance matrix
of estimators from 'fitMRME_naive'.
'estVarMRMEnaive_pBootstrap' uses parametric bootstrap to obtain variance matrix
of estimators from 'fitMRME_naive'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estVarMRME_Godambe(
  est_theta,
  data,
  nBS,
  numThreads = 1,
  gradMethod = "simple",
  integrControl = integr.control()
)

estVarMRME_pBootstrap(
  est_theta,
  data,
  nBS,
  detailBS = FALSE,
  numThreads = 1,
  integrControl = integr.control()
)

estVarMRMEnaive_Godambe(
  est_theta,
  data,
  nBS,
  numThreads = 1,
  gradMethod = "simple",
  integrControl = integr.control()
)

estVarMRMEnaive_pBootstrap(
  est_theta,
  data,
  nBS,
  detailBS = FALSE,
  numThreads = 1,
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estVarMRME_Godambe_+3A_est_theta">est_theta</code></td>
<td>
<p>estimators of MRME model</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_data">data</code></td>
<td>
<p>data used to process estimation</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_nbs">nBS</code></td>
<td>
<p>number of bootstrap.</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_numthreads">numThreads</code></td>
<td>
<p>the number of threads for parallel computation. If its value
is greater than 1, then parallel computation will be processed. Otherwise,
serial computation will be processed.</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_gradmethod">gradMethod</code></td>
<td>
<p>method used for numeric gradient (<code>numDeriv::grad</code>).</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_integrcontrol">integrControl</code></td>
<td>
<p>a list of control parameters for the <code>integrate</code>
function: rel.tol, abs.tol, subdivision.</p>
</td></tr>
<tr><td><code id="estVarMRME_Godambe_+3A_detailbs">detailBS</code></td>
<td>
<p>whether or not output estimation results during bootstrap,
which can be used to generate bootstrap CI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance-covariance matrix of estimators
</p>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## time consuming example
tgrid &lt;- seq(0, 10*100, length=100)
set.seed(123)
dat &lt;- rMRME(tgrid, 1, 0.5, 1, 0.01, "m")

estVarMRME_Godambe(c(1, 0.5, 1, 0.01), dat, nBS = 10)
estVarMRME_pBootstrap(c(1, 0.5, 1, 0.01), dat, nBS = 10)
estVarMRMEnaive_Godambe(c(1, 0.5, 1, 0.01), dat, nBS = 10)
estVarMRMEnaive_pBootstrap(c(1, 0.5, 1, 0.01), dat, nBS = 10)

estVarMRME_Godambe(c(1, 0.5, 1, 0.01), dat, nBS = 10, numThreads = 6)
estVarMRME_pBootstrap(c(1, 0.5, 1, 0.01), dat, nBS = 10, numThreads = 6)
estVarMRMEnaive_Godambe(c(1, 0.5, 1, 0.01), dat, nBS = 10, numThreads = 6)
estVarMRMEnaive_pBootstrap(c(1, 0.5, 1, 0.01), dat, nBS = 10, numThreads = 6)
estVarMRMEnaive_pBootstrap(c(1, 0.5, 1, 0.01), dat, nBS = 10, numThreads = 6)

## End(Not run)
</code></pre>

<hr>
<h2 id='f109'>GPS data of f109</h2><span id='topic+f109'></span>

<h3>Description</h3>

<p>A dataset of GPS coordinates of a mature female mountain
lion living in the Gros Ventre Mountain Range near
Jackson, Wyoming. The data were collected by a code-only
GPS wildlife tracking collar from 2009 to 2012.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f109
</code></pre>


<h3>Format</h3>

<p>A data frame with 3919 rows and 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date when the GPS coordinates were collected</p>
</dd>
<dt>cumTime</dt><dd><p>Standardized time when the GPS coordinates were collected (unit: hour)</p>
</dd>
<dt>centerE</dt><dd><p>Standardized UTM easting (unit: km)</p>
</dd>
<dt>centerN</dt><dd><p>Standardized UTM northing (unit: km)</p>
</dd>
</dl>


<hr>
<h2 id='f109raw'>GPS data of f109 (raw format)</h2><span id='topic+f109raw'></span>

<h3>Description</h3>

<p>The original format of 'f109' dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f109raw
</code></pre>


<h3>Format</h3>

<p>A data frame with 3917 rows and 3 variables:
</p>

<dl>
<dt>t</dt><dd><p>Date and time when the GPS coordinates were collected (unit: year)</p>
</dd>
<dt>dE</dt><dd><p>Standardized UTM easting (unit: meter)</p>
</dd>
<dt>dN</dt><dd><p>Standardized UTM northing (unit: meter)</p>
</dd>
</dl>


<hr>
<h2 id='fitBMME'>Fit a Brownian Motion with Measurement Error</h2><span id='topic+fitBMME'></span><span id='topic+fitBmme'></span>

<h3>Description</h3>

<p>Given discretely observed animal movement locations, fit a Brownian
motion model with measurement errors. Using <code>segment</code> to fit
part of observations to the model. A practical application of this
feature is seasonal analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitBMME(
  data,
  start = NULL,
  segment = NULL,
  method = "Nelder-Mead",
  optim.control = list()
)

fitBmme(data, start = NULL, method = "Nelder-Mead", optim.control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitBMME_+3A_data">data</code></td>
<td>
<p>a data.frame whose first column is the observation time, and other
columns are location coordinates. If <code>segment</code> is not <code>NULL</code>,
additional column with the same name given by <code>segment</code> should be
included. This additional column is used to indicate which part of
observations shoule be used to fit model. The value of this column can
be any integer with 0 means discarding this observation and non-0 means
using this obversvation. Using different non-zero numbers indicate different
segments. (See vignette for more details.)</p>
</td></tr>
<tr><td><code id="fitBMME_+3A_start">start</code></td>
<td>
<p>starting value of the model, a vector of two component, one for
sigma (sd of BM) and the other for delta (sd for measurement error).
If unspecified (NULL), a moment estimator will be used assuming equal
sigma and delta.</p>
</td></tr>
<tr><td><code id="fitBMME_+3A_segment">segment</code></td>
<td>
<p>character variable, name of the column which indicates segments,
in the given <code>data.frame</code>. The default value, <code>NULL</code>, means using
whole dataset to fit the model.</p>
</td></tr>
<tr><td><code id="fitBMME_+3A_method">method</code></td>
<td>
<p>the method argument to feed <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitBMME_+3A_optim.control">optim.control</code></td>
<td>
<p>a list of control that is passed down to <code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The joint density of the increment data is multivariate normal with a
sparse (tri-diagonal) covariance matrix. Sparse matrix operation from
package Matrix is used for computing efficiency in handling large data.
</p>


<h3>Value</h3>

<p>A list of the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated parameter vector</p>
</td></tr>
<tr><td><code>var.est</code></td>
<td>
<p>variance matrix of the estimator</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>loglikelihood evaluated at the estimate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code from optim</p>
</td></tr>
</table>


<h3>References</h3>

<p>Pozdnyakov V., Meyer, TH., Wang, Y., and Yan, J. (2013)
On modeling animal movements using Brownian motion with measurement
error. Ecology 95(2): p247&ndash;253. doi:doi:10.1890/13-0532.1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitMR">fitMR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
tgrid &lt;- seq(0, 500, by = 1)
dat &lt;- rBMME(tgrid, sigma = 1, delta = 0.5)

## using whole dataset to fit BMME
fit &lt;- fitBMME(dat)
fit

## using part of dataset to fit BMME
batch &lt;- c(rep(0, 100), rep(1, 200), rep(0, 50), rep(2, 100), rep(0, 51))
dat.segment &lt;- cbind(dat, batch)
fit.segment &lt;- fitBMME(dat.segment, segment = "batch")
head(dat.segment)
fit.segment

</code></pre>

<hr>
<h2 id='fitMM'>Fit a Moving-Moving Model with 2 Embedded Brownian Motion</h2><span id='topic+fitMM'></span><span id='topic+estVarMM'></span>

<h3>Description</h3>

<p>Fit a Moving-Moving Model with 2 Embedded Brownian Motion with animal
movement data at discretely observation times by maximizing a full
likelihood constructed from the marginal density of increment.
'estVarMM' uses parametric bootstrap to obtain variance matrix
of estimators from 'fitMM'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMM(
  data,
  start,
  logtr = FALSE,
  method = "Nelder-Mead",
  optim.control = list(),
  integrControl = integr.control()
)

estVarMM(
  est_theta,
  data,
  nBS,
  detailBS = FALSE,
  numThreads = 1,
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMM_+3A_data">data</code></td>
<td>
<p>data used to process estimation</p>
</td></tr>
<tr><td><code id="fitMM_+3A_start">start</code></td>
<td>
<p>starting value of the model, a vector of four components
in the order of rate for moving1, rate for moving2,
and volatility1(larger), volatility2(smaller).</p>
</td></tr>
<tr><td><code id="fitMM_+3A_logtr">logtr</code></td>
<td>
<p>logical, if TRUE parameters are estimated on the log scale.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_method">method</code></td>
<td>
<p>the method argument to feed <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_optim.control">optim.control</code></td>
<td>
<p>a list of control to be passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_integrcontrol">integrControl</code></td>
<td>
<p>a list of control parameters for the <code>integrate</code>
function: rel.tol, abs.tol, subdivision.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_est_theta">est_theta</code></td>
<td>
<p>estimators of MRME model</p>
</td></tr>
<tr><td><code id="fitMM_+3A_nbs">nBS</code></td>
<td>
<p>number of bootstrap.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_detailbs">detailBS</code></td>
<td>
<p>whether or not output estimation results during bootstrap,
which can be used to generate bootstrap CI.</p>
</td></tr>
<tr><td><code id="fitMM_+3A_numthreads">numThreads</code></td>
<td>
<p>the number of threads for parallel computation. If its value
is greater than 1, then parallel computation will be processed. Otherwise,
serial computation will be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the esimated parameter vector</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>maximized loglikelihood or composite loglikelihood
evaluated at the estimate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code from <code>optim</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, J., Chen, Y., Lawrence-Apfel, K., Ortega, I. M., Pozdnyakov, V.,
Williams, S., and Meyer, T. (2014) A moving-resting process with an
embedded Brownian motion for animal movements.
Population Ecology. 56(2): 401&ndash;415.
</p>
<p>Pozdnyakov, V., Elbroch, L., Labarga, A., Meyer, T., and Yan, J.
(2017) Discretely observed Brownian motion governed by telegraph
process: estimation. Methodology and Computing in Applied Probability.
doi:10.1007/s11009-017-9547-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## time consuming example
tgrid &lt;- seq(0, 100, length=100)
set.seed(123)
dat &lt;- rMM(tgrid, 1, 0.1, 1, 0.1, "m1")

## fit whole dataset to the MR model
fit &lt;- fitMM(dat, start=c(1, 0.1, 1, 0.1))
fit

var &lt;- estVarMM(fit$estimate, dat, nBS = 10, numThreads = 6)
var

## End(Not run)
</code></pre>

<hr>
<h2 id='fitMR'>Fit a Moving-Resting Model with Embedded Brownian Motion</h2><span id='topic+fitMR'></span><span id='topic+fitMovRes'></span>

<h3>Description</h3>

<p>Fit a Moving-Resting Model with Embedded Brownian Motion with animal
movement data at discretely observation times by maximizing a composite
likelihood constructed from the marginal density of increment.
Using <code>segment</code> to fit part of observations to the model. A practical
application of this feature is seasonal analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMR(
  data,
  start,
  segment = NULL,
  likelihood = c("full", "composite"),
  logtr = FALSE,
  method = "Nelder-Mead",
  optim.control = list(),
  integrControl = integr.control()
)

fitMovRes(
  data,
  start,
  likelihood = c("full", "composite"),
  logtr = FALSE,
  method = "Nelder-Mead",
  optim.control = list(),
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMR_+3A_data">data</code></td>
<td>
<p>a data.frame whose first column is the observation time, and other
columns are location coordinates. If <code>segment</code> is not <code>NULL</code>,
additional column with the same name given by <code>segment</code> should be
included. This additional column is used to indicate which part of
observations shoule be used to fit model. The value of this column can
be any integer with 0 means discarding this observation and non-0 means
using this obversvation. Using different non-zero numbers indicate different
segments. (See vignette for more details.)</p>
</td></tr>
<tr><td><code id="fitMR_+3A_start">start</code></td>
<td>
<p>starting value of the model, a vector of three components
in the order of rate for moving, rate for resting, and volatility.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_segment">segment</code></td>
<td>
<p>character variable, name of the column which indicates segments,
in the given <code>data.frame</code>. The default value, <code>NULL</code>, means using
whole dataset to fit the model.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_likelihood">likelihood</code></td>
<td>
<p>a character string specifying the likelihood type to
maximize in estimation. This can be &quot;full&quot; for full likelihood or
&quot;composite' for composite likelihood.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_logtr">logtr</code></td>
<td>
<p>logical, if TRUE parameters are estimated on the log scale.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_method">method</code></td>
<td>
<p>the method argument to feed <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_optim.control">optim.control</code></td>
<td>
<p>a list of control to be passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitMR_+3A_integrcontrol">integrControl</code></td>
<td>
<p>a list of control parameters for the <code>integrate</code>
function: rel.tol, abs.tol, subdivision.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the esimated parameter vector</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>maximized loglikelihood or composite loglikelihood
evaluated at the estimate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code from <code>optim</code></p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>likelihood type (full or composite) from the input</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, J., Chen, Y., Lawrence-Apfel, K., Ortega, I. M., Pozdnyakov, V.,
Williams, S., and Meyer, T. (2014) A moving-resting process with an
embedded Brownian motion for animal movements.
Population Ecology. 56(2): 401&ndash;415.
</p>
<p>Pozdnyakov, V., Elbroch, L., Labarga, A., Meyer, T., and Yan, J.
(2017) Discretely observed Brownian motion governed by telegraph
process: estimation. Methodology and Computing in Applied Probability.
doi:10.1007/s11009-017-9547-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## time consuming example
tgrid &lt;- seq(0, 10, length=500)
set.seed(123)
## make it irregularly spaced
tgrid &lt;- sort(sample(tgrid, 30)) # change to 400 for a larger sample
dat &lt;- rMR(tgrid, 1, 2, 25, "m")

## fit whole dataset to the MR model
fit.fl &lt;- fitMR(dat, start=c(2, 2, 20), likelihood = "full")
fit.fl

fit.cl &lt;- fitMR(dat, start=c(2, 2, 20), likelihood = "composite")
fit.cl

## fit part of dataset to the MR model
batch &lt;- c(rep(0, 5), rep(1, 7), rep(0, 4), rep(2, 10), rep(0, 4))
dat.segment &lt;- cbind(dat, batch)
fit.segment &lt;- fitMR(dat.segment, start = c(2, 2, 20), segment = "batch",
                     likelihood = "full")
head(dat.segment)
fit.segment

## End(Not run)
</code></pre>

<hr>
<h2 id='fitMRH'>Fit a Moving-Resting-Handling Model with Embedded Brownian Motion</h2><span id='topic+fitMRH'></span>

<h3>Description</h3>

<p>Fit a Moving-Resting-Handling Model with Embedded Brownian Motion with
animal movement data at discretely observation times by maximizing
a full likelihood. Using <code>segment</code> to fit part of observations to
the model. A practical application of this feature is seasonal analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMRH(
  data,
  start,
  segment = NULL,
  numThreads = RcppParallel::defaultNumThreads() * 3/4,
  lower = c(0.001, 0.001, 0.001, 0.001, 0.001),
  upper = c(10, 10, 10, 10, 0.999),
  integrControl = integr.control(),
  print_level = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMRH_+3A_data">data</code></td>
<td>
<p>a data.frame whose first column is the observation time, and other
columns are location coordinates. If <code>segment</code> is not <code>NULL</code>,
additional column with the same name given by <code>segment</code> should be
included. This additional column is used to indicate which part of
observations shoule be used to fit model. The value of this column can
be any integer with 0 means discarding this observation and non-0 means
using this obversvation. Using different non-zero numbers indicate different
segments. (See vignette for more details.)</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_start">start</code></td>
<td>
<p>The initial value for optimization, in the order of rate
of moving, rate of resting, rate of handling, volatility and switching
probability.</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_segment">segment</code></td>
<td>
<p>character variable, name of the column which indicates segments,
in the given <code>data.frame</code>. The default value, <code>NULL</code>, means using
whole dataset to fit the model.</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_numthreads">numThreads</code></td>
<td>
<p>int, the number of threads allocated for parallel
computation. The default setup is 3/4 available threads. If this parameter
is less or equal to 1, the serial computation will be processed.</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_lower">lower</code>, <code id="fitMRH_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bound for optimization.</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_integrcontrol">integrControl</code></td>
<td>
<p>Integration control vector includes rel.tol,
abs.tol, and subdivisions.</p>
</td></tr>
<tr><td><code id="fitMRH_+3A_print_level">print_level</code></td>
<td>
<p>print_level passed to nloptr::nloptr. Possible values: 0 (default):
no output; 1: show iteration number and value of objective function; 2: 1 + show
value of (in)equalities; 3: 2 + show value of controls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of estimation result with following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated parameter vector</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>maximized loglikelihood or composite loglikelihood
evaluated at the estimate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code from <code>nloptr</code></p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>fitted data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>References</h3>

<p>Pozdnyakov, V., Elbroch, L.M., Hu, C. et al. On Estimation for
Brownian Motion Governed by Telegraph Process with Multiple Off States.
Methodol Comput Appl Probab 22, 1275–1291 (2020).
doi:10.1007/s11009-020-09774-1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rMRH">rMRH</a></code> for simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## time consuming example
set.seed(06269)
tgrid &lt;- seq(0, 400, by = 8)
dat &lt;- rMRH(tgrid, 4, 0.5, 0.1, 5, 0.8, 'm')
fitMRH(dat, c(4, 0.5, 0.1, 5, 0.8)) ## parallel process
fitMRH(dat, c(4, 0.5, 0.1, 5, 0.8), numThreads = -1) ## serial process

## fit part of dataset to the MRH model
batch &lt;- c(rep(0, 10), rep(1, 7), rep(0, 10), rep(2, 10), rep(0, 14))
dat.segment &lt;- cbind(dat, batch)
fit.segment &lt;- fitMRH(dat.segment, start = c(4, 0.5, 0.1, 5, 0.8), segment = "batch")
head(dat.segment)
fit.segment

## End(Not run)

</code></pre>

<hr>
<h2 id='fitMRME'>Fit a Moving-Resting Model with Measurement Error</h2><span id='topic+fitMRME'></span><span id='topic+fitMRME_naive'></span><span id='topic+fitMRMEapprox'></span>

<h3>Description</h3>

<p>'fitMRME' fits a Moving-Resting Model with Measurement Error. The measurement
error is modeled by Guassian noise. Using <code>segment</code> to fit part
of observations to the model. A practical application of this feature
is seasonal analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMRME(
  data,
  start,
  segment = NULL,
  lower = c(1e-06, 1e-06, 1e-06, 1e-06),
  upper = c(10, 10, 10, 10),
  print_level = 3,
  integrControl = integr.control()
)

fitMRME_naive(
  data,
  start,
  segment = NULL,
  lower = c(1e-06, 1e-06, 1e-06, 1e-06),
  upper = c(10, 10, 10, 10),
  integrControl = integr.control()
)

fitMRMEapprox(
  data,
  start,
  segment = NULL,
  approx_norm_even = approxNormalOrder(5),
  approx_norm_odd = approxNormalOrder(6),
  method = "Nelder-Mead",
  optim.control = list(),
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMRME_+3A_data">data</code></td>
<td>
<p>a data.frame whose first column is the observation time, and other
columns are location coordinates. If <code>segment</code> is not <code>NULL</code>,
additional column with the same name given by <code>segment</code> should be
included. This additional column is used to indicate which part of
observations shoule be used to fit model. The value of this column can
be any integer with 0 means discarding this observation and non-0 means
using this obversvation. Using different non-zero numbers indicate different
segments. (See vignette for more details.)</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_start">start</code></td>
<td>
<p>starting value of the model, a vector of four components
in the order of rate for moving, rate for resting, volatility, and
s.d. of Guassian measurement error.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_segment">segment</code></td>
<td>
<p>character variable, name of the column which indicates segments,
in the given <code>data.frame</code>. The default value, <code>NULL</code>, means using
whole dataset to fit the model.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_lower">lower</code>, <code id="fitMRME_+3A_upper">upper</code></td>
<td>
<p>Lower and upper bound for optimization.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_print_level">print_level</code></td>
<td>
<p>print_level passed to nloptr::nloptr. Possible values: 0 (default):
no output; 1: show iteration number and value of objective function; 2: 1 + show
value of (in)equalities; 3: 2 + show value of controls.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_integrcontrol">integrControl</code></td>
<td>
<p>a list of control parameters for the <code>integrate</code>
function: rel.tol, abs.tol, subdivision.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_approx_norm_even">approx_norm_even</code>, <code id="fitMRME_+3A_approx_norm_odd">approx_norm_odd</code></td>
<td>
<p>numeric matrixes specify the
discrete distributions used to approximate standard normal distribution.
The first column is support of discrete distribution and the second
column is probability mass function. <code>approx_norm_even</code> is used to
approximate even step error and <code>approx_norm_odd</code> is used to
approximate odd step error. We mention that the supports of these two
discrete distributions should not have any common elements.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_method">method</code></td>
<td>
<p>the method argument to feed <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fitMRME_+3A_optim.control">optim.control</code></td>
<td>
<p>a list of control to be passed to <code>optim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the esimated parameter vector</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>maximized loglikelihood or composite loglikelihood
evaluated at the estimate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence code from <code>optim</code></p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>fitted data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>References</h3>

<p>Hu, C., Elbroch, L.M., Meyer, T., Pozdnyakov, V. and Yan, J. (2021),
Moving-resting process with measurement error in animal movement modeling.
Methods in Ecology and Evolution. doi:10.1111/2041-210X.13694
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## time consuming example
#tgrid &lt;- seq(0, 10*100, length=100)
#set.seed(123)
#dat &lt;- rMRME(tgrid, 1, 0.5, 1, 0.01, "m")

## fit whole dataset to the MRME model
#fit &lt;- fitMRME(dat, start=c(1, 0.5, 1, 0.01))
#fit

## fit whole dataset to the MRME model with naive composite likelihood
#fit.naive &lt;- fitMRME_naive(dat, start=c(1, 0.5, 1, 0.01))
#fit.naive

## fit whole dataset to the MRME model with approximate error
#fit.approx &lt;- fitMRMEapprox(dat, start=c(1, 0.5, 1, 0.01))
#fit.approx

## fit part of dataset to the MR model
#batch &lt;- c(rep(0, 5), rep(1, 17), rep(0, 4), rep(2, 30), rep(0, 4), rep(3, 40))
#dat.segment &lt;- cbind(dat, batch)
#fit.segment &lt;- fitMRME(dat.segment, start = c(1, 0.5, 1, 0.01), segment = "batch")
#fit.segment.approx &lt;- fitMRMEapprox(dat.segment, start = c(1, 0.5, 1, 0.01), segment = "batch")
#head(dat.segment)
#fit.segment

</code></pre>

<hr>
<h2 id='fitStateMR'>Estimation of states at each time point with Moving-Resting Process</h2><span id='topic+fitStateMR'></span><span id='topic+fitViterbiMR'></span><span id='topic+fitPartialViterbiMR'></span>

<h3>Description</h3>

<p>Estimate the state at each time point under the Moving-Resting
process with Embedded Brownian Motion with animal movement data at
discretely time points. See the difference between <code>fitStateMR</code>
and <code>fitViterbiMR</code> in detail part. Using <code>fitPartialViterbiMR</code>
to estimate the state within a small piece of time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitStateMR(data, theta, cutoff = 0.5, integrControl = integr.control())

fitViterbiMR(data, theta, cutoff = 0.5, integrControl = integr.control())

fitPartialViterbiMR(
  data,
  theta,
  cutoff = 0.5,
  startpoint,
  pathlength,
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitStateMR_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> whose first column is the observation
time, and other columns are location coordinates.</p>
</td></tr>
<tr><td><code id="fitStateMR_+3A_theta">theta</code></td>
<td>
<p>the parameters for Moving-Resting model, in the
order of rate of moving, rate of resting, volatility.</p>
</td></tr>
<tr><td><code id="fitStateMR_+3A_cutoff">cutoff</code></td>
<td>
<p>the cut-off point for prediction.</p>
</td></tr>
<tr><td><code id="fitStateMR_+3A_integrcontrol">integrControl</code></td>
<td>
<p>Integration control vector includes rel.tol,
abs.tol, and subdivisions.</p>
</td></tr>
<tr><td><code id="fitStateMR_+3A_startpoint">startpoint</code></td>
<td>
<p>Start time point of interested time interval.</p>
</td></tr>
<tr><td><code id="fitStateMR_+3A_pathlength">pathlength</code></td>
<td>
<p>the length of interested time interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitStateMR</code> estimates the most likely state by maximizing
the probability of <code class="reqn">Pr(S(t = t_k) = s_k | X)</code>, where X is the whole
data and <code class="reqn">s_k</code> is the possible sates at <code class="reqn">t_k</code> (moving, resting).
</p>
<p><code>fitViterbiMR</code> estimates the most likely state path by maximizing
<code class="reqn">Pr(S(t = t_0) = s_0, S(t = t_1) = s_1, ..., S(t = t_n) = s_n | X)</code>, where
X is the whole data and <code class="reqn">s_0, s_1, ..., s_n</code> is the possible
state path.
</p>
<p><code>fitPartialViterbiMR</code> estimates the most likely state path of
a small peice of time interval, by maximizing the probability of
<code class="reqn">Pr(S(t = t_k) = s_k, ..., S(t = t_{k+q-1}) = s_{k+q-1} | X)</code>,
where <code class="reqn">k</code> is the start time point and <code class="reqn">q</code> is the length of interested
time interval.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> contains estimated results, with elements:
</p>

<ul>
<li><p> original data be estimated.
</p>
</li>
<li><p> conditional probability of moving, resting (<code>p.m</code>,
<code>p.r</code>), which is <code class="reqn">Pr(S(t = t_k) = s_k | X)</code> for
<code>fitStateMR</code>; <code class="reqn">log-Pr(s_0, ..., s_k | X_k)</code> for
<code>fitViterbiMR</code>, where <code class="reqn">X_k</code> is <code class="reqn">(X_0, ..., X_k)</code>;
and <code class="reqn">log-Pr(s_k, ..., s_{k+q-1}|X)</code> for <code>fitPartialViterbiMR</code>.
</p>
</li>
<li><p> estimated states with 1-moving, 0-resting.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rMR">rMR</a></code> for simulation.
<code><a href="#topic+fitMR">fitMR</a></code> for estimation of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(06269)
tgrid &lt;- seq(0, 400, by = 8)
dat &lt;- rMR(tgrid, 4, 3.8, 5, 'm')
fitStateMR(dat, c(4, 3.8, 5), cutoff = 0.5)
fitViterbiMR(dat, c(4, 3.8, 5), cutoff = 0.5)
fitPartialViterbiMR(dat, c(4, 3.8, 5), cutoff = 0.5, 20, 10)

</code></pre>

<hr>
<h2 id='fitStateMRH'>Estimation of states at each time point with Moving-Resting-Handling Process</h2><span id='topic+fitStateMRH'></span><span id='topic+fitViterbiMRH'></span><span id='topic+fitPartialViterbiMRH'></span>

<h3>Description</h3>

<p>Estimate the state at each time point under the Moving-Resting-Handling
process with Embedded Brownian Motion with animal movement data at
discretely time points. See the difference between <code>fitStateMRH</code>
and <code>fitViterbiMRH</code> in detail part. Using <code>fitPartialViterbiMRH</code>
to estimate the state during a small piece of time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitStateMRH(data, theta, integrControl = integr.control())

fitViterbiMRH(data, theta, integrControl = integr.control())

fitPartialViterbiMRH(
  data,
  theta,
  startpoint,
  pathlength,
  integrControl = integr.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitStateMRH_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> whose first column is the observation
time, and other columns are location coordinates.</p>
</td></tr>
<tr><td><code id="fitStateMRH_+3A_theta">theta</code></td>
<td>
<p>the parameters for Moving-Resting-Handling model, in the
order of rate of moving, rate of resting, rate of handling, volatility
and switching probability.</p>
</td></tr>
<tr><td><code id="fitStateMRH_+3A_integrcontrol">integrControl</code></td>
<td>
<p>Integration control vector includes rel.tol,
abs.tol, and subdivisions.</p>
</td></tr>
<tr><td><code id="fitStateMRH_+3A_startpoint">startpoint</code></td>
<td>
<p>Start time point of interested time interval.</p>
</td></tr>
<tr><td><code id="fitStateMRH_+3A_pathlength">pathlength</code></td>
<td>
<p>the length of interested time interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitStateMRH</code> estimates the most likely state by maximizing
the probability of <code class="reqn">Pr(S(t = t_k) = s_k | X)</code>, where X is the whole
data and <code class="reqn">s_k</code> is the possible sates at <code class="reqn">t_k</code> (moving, resting
or handling).
</p>
<p><code>fitViterbiMRH</code> estimates the most likely state path by maximizing
<code class="reqn">Pr(S(t = t_0) = s_0, S(t = t_1) = s_1, ..., S(t = t_n) = s_n | X)</code>, where
X is the whole data and <code class="reqn">s_0, s_1, ..., s_n</code> is the possible
state path.
</p>
<p><code>fitPartialViterbiMRH</code> estimates the most likely state path of
a small peice of time interval, by maximizing the probability of
<code class="reqn">Pr(S(t = t_k) = s_k, ..., S(t = t_{k+q-1}) = s_{k+q-1} | X)</code>,
where <code class="reqn">k</code> is the start time point and <code class="reqn">q</code> is the length of interested
time interval.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> contains estimated results, with elements:
</p>

<ul>
<li><p> original data be estimated.
</p>
</li>
<li><p> conditional probability of moving, resting, handling (<code>p.m</code>,
<code>p.r</code>, <code>p.h</code>), which is <code class="reqn">Pr(S(t = t_k) = s_k | X)</code> for
<code>fitStateMRH</code>; <code class="reqn">log-Pr(s_0, ..., s_k | X_k)</code> for
<code>fitViterbiMRH</code>, where <code class="reqn">X_k</code> is <code class="reqn">(X_0, ..., X_k)</code>;
and <code class="reqn">log-Pr(s_k, ..., s_{k+q-1}|X)</code> for <code>fitPartialViterbiMRH</code>.
</p>
</li>
<li><p> estimated states with 0-moving, 1-resting, 2-handling.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>References</h3>

<p>Pozdnyakov, V., Elbroch, L.M., Hu, C., Meyer, T., and Yan, J. (2018+)
On estimation for Brownian motion governed by telegraph process with
multiple off states. &lt;arXiv:1806.00849&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rMRH">rMRH</a></code> for simulation.
<code><a href="#topic+fitMRH">fitMRH</a></code> for estimation of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## time consuming example
set.seed(06269)
tgrid &lt;- seq(0, 400, by = 8)
dat &lt;- rMRH(tgrid, 4, 0.5, 0.1, 5, 0.8, 'm')
fitStateMRH(dat, c(4, 0.5, 0.1, 5, 0.8))
fitViterbiMRH(dat, c(4, 0.5, 0.1, 5, 0.8))
fitPartialViterbiMRH(dat, c(4, 0.5, 0.1, 5, 0.8), 20, 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='integr.control'>Auxiliary for Controlling Numerical Integration</h2><span id='topic+integr.control'></span>

<h3>Description</h3>

<p>Auxiliary function for the numerical integration used in the
likelihood and composite likelihood functions. Typically only
used internally by 'fitMR' and 'fitMRH'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integr.control(
  rel.tol = .Machine$double.eps^0.25,
  abs.tol = rel.tol,
  subdivisions = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integr.control_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative accuracy requested.</p>
</td></tr>
<tr><td><code id="integr.control_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="integr.control_+3A_subdivisions">subdivisions</code></td>
<td>
<p>the maximum number of subintervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments are the same as <code>integrate</code>, but passed
down to the C API of Rdqags used by <code>integrate</code>.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>

<hr>
<h2 id='rBB'>Sampling from a Brownian bridge path give a grid time</h2><span id='topic+rBB'></span>

<h3>Description</h3>

<p>A Brownian bridge is a continuous-time stochastic process
B(t) whose probability distribution is the conditional
probability distribution of a standard Wiener process W(t)
subject to the condition (when standardized) that W(T) = 0,
so that the process is pinned to the same value at both t = 0 and t = T.
The implementation here is a generalized Brownian bridge
that allows start point and end point at different locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBB(time, start_pt, end_pt, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rBB_+3A_time">time</code></td>
<td>
<p>time points at which observations are to be simulated</p>
</td></tr>
<tr><td><code id="rBB_+3A_start_pt">start_pt</code></td>
<td>
<p>the start point location of Brownian bridge</p>
</td></tr>
<tr><td><code id="rBB_+3A_end_pt">end_pt</code></td>
<td>
<p>the end point location of Brownian brige</p>
</td></tr>
<tr><td><code id="rBB_+3A_sigma">sigma</code></td>
<td>
<p>volatility parameter of the Brownian motion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points
and second column is coordinate of the locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Brownian bridge starting from location 0 and ending at location 1
## with sigma 0.1 from time 0 to time 10
plot(rBB(seq(0, 10, length.out = 100), 0, 1, 0.1), type = "l")

</code></pre>

<hr>
<h2 id='rBMME'>Sampling from Brown Motion with Measurement Error</h2><span id='topic+rBMME'></span><span id='topic+rBmme'></span>

<h3>Description</h3>

<p>Given the volatility parameters of a Brownian motion and normally
distributed measurement errors, generate the process at discretely
observed time points of a given dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBMME(time, dim = 2, sigma = 1, delta = 1)

rBmme(time, dim = 2, sigma = 1, delta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rBMME_+3A_time">time</code></td>
<td>
<p>vector of time points at which observations are to be sampled</p>
</td></tr>
<tr><td><code id="rBMME_+3A_dim">dim</code></td>
<td>
<p>(integer) dimension of the Brownian motion</p>
</td></tr>
<tr><td><code id="rBMME_+3A_sigma">sigma</code></td>
<td>
<p>volatility parameter (sd) of the Brownian motion</p>
</td></tr>
<tr><td><code id="rBMME_+3A_delta">delta</code></td>
<td>
<p>sd parameter of measurement error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points and whose
other columns are coordinates of the locations.
</p>


<h3>References</h3>

<p>Pozdnyakov V., Meyer, TH., Wang, Y., and Yan, J. (2013)
On modeling animal movements using Brownian motion with measurement
error. Ecology 95(2): p247&ndash;253. doi:doi:10.1890/13-0532.1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tgrid &lt;- seq(0, 10, length = 1001)
## make it irregularly spaced
tgrid &lt;- sort(sample(tgrid, 800))
dat &lt;- rBMME(tgrid, 1, 1)
plot(dat[,1], dat[,2], xlab="t", ylab="X(t)", type="l")

</code></pre>

<hr>
<h2 id='rMM'>Sampling from a Moving-Moving Process with 2 Embedded Brownian Motion</h2><span id='topic+rMM'></span>

<h3>Description</h3>

<p>A moving-moving process consists of two states: moving (large) and moving (small).
The transition between the two states is modeled by an alternating
renewal process, with exponentially distributed duration. An animal
moves according to two Brownian motions with different volatility parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMM(time, lamM1, lamM2, sigma1, sigma2, s0, dim = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMM_+3A_time">time</code></td>
<td>
<p>time points at which observations are to be simulated</p>
</td></tr>
<tr><td><code id="rMM_+3A_lamm1">lamM1</code></td>
<td>
<p>rate parameter of the exponential duration while moving1</p>
</td></tr>
<tr><td><code id="rMM_+3A_lamm2">lamM2</code></td>
<td>
<p>rate parameter of the exponential duration while moving2</p>
</td></tr>
<tr><td><code id="rMM_+3A_sigma1">sigma1</code></td>
<td>
<p>volatility parameter of the Brownian motion while moving1</p>
</td></tr>
<tr><td><code id="rMM_+3A_sigma2">sigma2</code></td>
<td>
<p>volatility parameter of the Brownian motion while moving2</p>
</td></tr>
<tr><td><code id="rMM_+3A_s0">s0</code></td>
<td>
<p>the state at time 0, must be one of &quot;m1&quot; or &quot;m2&quot;, for moving1 and
moving2, respectively</p>
</td></tr>
<tr><td><code id="rMM_+3A_dim">dim</code></td>
<td>
<p>(integer) dimension of the Brownian motion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points and whose
other columns are coordinates of the locations.
</p>


<h3>References</h3>

<p>Yan, J., Chen, Y., Lawrence-Apfel, K., Ortega, I. M., Pozdnyakov, V.,
Williams, S., and Meyer, T. (2014) A moving-resting process with an
embedded Brownian motion for animal movements.
Population Ecology. 56(2): 401&ndash;415.
</p>
<p>Pozdnyakov, V., Elbroch, L., Labarga, A., Meyer, T., and Yan, J.
(2017) Discretely observed Brownian motion governed by telegraph
process: estimation. Methodology and Computing in Applied Probability.
doi:10.1007/s11009-017-9547-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tgrid &lt;- seq(0, 100, length=100)

dat &lt;- rMM(tgrid, 1, 0.1, 1, 0.1, "m1")
plot(dat[,1], dat[,2], xlab="t", ylab="X(t)", type='l')

</code></pre>

<hr>
<h2 id='rMR'>Sampling from a Moving-Resting Process with Embedded Brownian Motion</h2><span id='topic+rMR'></span><span id='topic+rMovRes'></span><span id='topic+rMRME'></span>

<h3>Description</h3>

<p>A moving-resting process consists of two states: moving and resting.
The transition between the two states is modeled by an alternating
renewal process, with exponentially distributed duration. An animal
stays at the same location while resting, and moves according to a
Brownian motion while moving.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMR(time, lamM, lamR, sigma, s0, dim = 2, state = FALSE)

rMovRes(time, lamM, lamR, sigma, s0, dim = 2)

rMRME(time, lamM, lamR, sigma, sig_err, s0, dim = 2, state = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMR_+3A_time">time</code></td>
<td>
<p>time points at which observations are to be simulated</p>
</td></tr>
<tr><td><code id="rMR_+3A_lamm">lamM</code></td>
<td>
<p>rate parameter of the exponential duration while moving</p>
</td></tr>
<tr><td><code id="rMR_+3A_lamr">lamR</code></td>
<td>
<p>rate parameter of the exponential duration while resting</p>
</td></tr>
<tr><td><code id="rMR_+3A_sigma">sigma</code></td>
<td>
<p>volatility parameter of the Brownian motion while moving</p>
</td></tr>
<tr><td><code id="rMR_+3A_s0">s0</code></td>
<td>
<p>the state at time 0, must be one of &quot;m&quot; or &quot;r&quot;, for moving and
resting, respectively</p>
</td></tr>
<tr><td><code id="rMR_+3A_dim">dim</code></td>
<td>
<p>(integer) dimension of the Brownian motion</p>
</td></tr>
<tr><td><code id="rMR_+3A_state">state</code></td>
<td>
<p>indicates whether the simulation show the states at given
time points.</p>
</td></tr>
<tr><td><code id="rMR_+3A_sig_err">sig_err</code></td>
<td>
<p>s.d. of Gaussian white noise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points and whose
other columns are coordinates of the locations.
</p>


<h3>References</h3>

<p>Yan, J., Chen, Y., Lawrence-Apfel, K., Ortega, I. M., Pozdnyakov, V.,
Williams, S., and Meyer, T. (2014) A moving-resting process with an
embedded Brownian motion for animal movements.
Population Ecology. 56(2): 401&ndash;415.
</p>
<p>Pozdnyakov, V., Elbroch, L., Labarga, A., Meyer, T., and Yan, J.
(2017) Discretely observed Brownian motion governed by telegraph
process: estimation. Methodology and Computing in Applied Probability.
doi:10.1007/s11009-017-9547-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tgrid &lt;- seq(0, 10, length=1001)
## make it irregularly spaced
tgrid &lt;- sort(sample(tgrid, 800))
dat &lt;- rMR(tgrid, 1, 1, 1, "m")
plot(dat[,1], dat[,2], xlab="t", ylab="X(t)", type='l')

dat2 &lt;- rMR(tgrid, 1, 1, 1, "m", state = TRUE)
head(dat2)

dat3 &lt;- rMRME(tgrid, 1, 1, 1, 0.01, "m", state = TRUE)
head(dat3)
plot(dat3[,1], dat3[,3], xlab="t", ylab="Z(t)=X(t)+GWN(0.01)", type="l")

</code></pre>

<hr>
<h2 id='rMRB'>Sampling from a Moving-Resting bridge</h2><span id='topic+rMRB'></span>

<h3>Description</h3>

<p>A moving-resting process consists of two states: moving and resting.
The transition between the two states is modeled by an alternating
renewal process, with exponentially distributed duration. An animal
stays at the same location while resting, and moves according to a
Brownian motion while moving. A moving-resting bridge is an extension
of Brownian bridge that uses moving-resting process to bridge given
starting point and ending point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMRB(time, start_pt, end_pt, lamM, lamR, sigma, s0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMRB_+3A_time">time</code></td>
<td>
<p>time points at which observations are to be simulated</p>
</td></tr>
<tr><td><code id="rMRB_+3A_start_pt">start_pt</code></td>
<td>
<p>the start point location of Brownian bridge
(numeric for one dimension, vector for multiple dimension)</p>
</td></tr>
<tr><td><code id="rMRB_+3A_end_pt">end_pt</code></td>
<td>
<p>the end point location of Brownian brige
(numeric for one dimension, vector for multiple dimension)</p>
</td></tr>
<tr><td><code id="rMRB_+3A_lamm">lamM</code></td>
<td>
<p>rate parameter of the exponential duration while moving</p>
</td></tr>
<tr><td><code id="rMRB_+3A_lamr">lamR</code></td>
<td>
<p>rate parameter of the exponential duration while resting</p>
</td></tr>
<tr><td><code id="rMRB_+3A_sigma">sigma</code></td>
<td>
<p>volatility parameter of the Brownian motion while moving</p>
</td></tr>
<tr><td><code id="rMRB_+3A_s0">s0</code></td>
<td>
<p>the state at time 0, must be one of &quot;m&quot; or &quot;r&quot;, for moving and
resting, respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points and whose
other columns are coordinates of the locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tgrid &lt;- seq(0, 10, length=1001)
## make it irregularly spaced
tgrid &lt;- sort(sample(tgrid, 800))

## a 2-dim moving-resting bridge starting from c(0, 0)
## and ending at c(10, -10)
dat &lt;- rMRB(tgrid, start_pt = c(0, 0), end_pt = c(10, -10),
            lamM = 1, lamR = 1, sigma = 1, "m")
par(mfrow = c(2, 1))
plot(dat[,1], dat[,2], xlab="t", ylab="X(t)", type='l')
plot(dat[,1], dat[,3], xlab="t", ylab="X(t)", type='l')
par(mfrow = c(1, 1))

</code></pre>

<hr>
<h2 id='rMRH'>Sampling from a Moving-Resting-Handling Process with Embedded Brownian Motion</h2><span id='topic+rMRH'></span>

<h3>Description</h3>

<p>A moving-resting-handling process consists of three states: moving, resting and handling.
The transition between the three states is modeled by an alternating
renewal process, with expenentially distributed duration.
An animal stays at the same location while resting and handling
(the choice of resting and handling depends on Bernoulli distribution),
and moves according to a Brownian motion while moving state.
The sequence of states is moving, resting or staying, moving, resting or staying ...
or versus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMRH(time, lamM, lamR, lamH, sigma, p, s0, dim = 2, state = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMRH_+3A_time">time</code></td>
<td>
<p>time points at which observations are to be simulated</p>
</td></tr>
<tr><td><code id="rMRH_+3A_lamm">lamM</code></td>
<td>
<p>rate parameter of the exponential duration while moving</p>
</td></tr>
<tr><td><code id="rMRH_+3A_lamr">lamR</code></td>
<td>
<p>rate parameter of the exponential duration while resting</p>
</td></tr>
<tr><td><code id="rMRH_+3A_lamh">lamH</code></td>
<td>
<p>rate parameter of the exponential duration while handling</p>
</td></tr>
<tr><td><code id="rMRH_+3A_sigma">sigma</code></td>
<td>
<p>volatility parameter of the Brownian motion while moving</p>
</td></tr>
<tr><td><code id="rMRH_+3A_p">p</code></td>
<td>
<p>probability of choosing resting,
and 1-p is probability of choosing handling</p>
</td></tr>
<tr><td><code id="rMRH_+3A_s0">s0</code></td>
<td>
<p>the state at time 0, must be one of &quot;m&quot; (moving), &quot;r&quot; (resting) or &quot;h&quot; (handling).</p>
</td></tr>
<tr><td><code id="rMRH_+3A_dim">dim</code></td>
<td>
<p>(integer) dimension of the Brownian motion</p>
</td></tr>
<tr><td><code id="rMRH_+3A_state">state</code></td>
<td>
<p>indicates whether the simulation show the states at given
time points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> whose first column is the time points and whose
other columns are coordinates of the locations. If <code>state</code> is
<code>TRUE</code>, the second column will be the simulation state.
</p>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>References</h3>

<p>Pozdnyakov, V., Elbroch, L.M., Hu, C., Meyer, T., and Yan, J. (2018+)
On estimation for Brownian motion governed by telegraph process with
multiple off states. &lt;arXiv:1806.00849&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitMRH">fitMRH</a></code> for fitting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(06269)
tgrid &lt;- seq(0, 8000, length.out=1001)
dat &lt;- rMRH(time=tgrid, lamM=4, lamR=0.04, lamH=0.2,
            sigma=1000, p=0.5, s0="m", dim=2)
plot(dat$time, dat$X1, type='l')
plot(dat$time, dat$X2, type='l')
plot(dat$X1,   dat$X2, type='l')

set.seed(06269) ## show the usage of state
dat2 &lt;- rMRH(time=tgrid, lamM=4, lamR=0.04, lamH=0.2,
             sigma=1000, p=0.5, s0="m", dim=2, state=TRUE)
head(dat)
head(dat2)

</code></pre>

<hr>
<h2 id='seasonFilter'>Subsetting data during given season for each year (seasonal analysis toolbox)</h2><span id='topic+seasonFilter'></span>

<h3>Description</h3>

<p>Return subsets of data from each year, which is in given
time interval between <code>startDate</code> and <code>endDate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonFilter(data, startDate, endDate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonFilter_+3A_data">data</code></td>
<td>
<p>The data be filtered, which has the same format
as the output from <code><a href="#topic+transfData">transfData</a></code>.</p>
</td></tr>
<tr><td><code id="seasonFilter_+3A_startdate">startDate</code>, <code id="seasonFilter_+3A_enddate">endDate</code></td>
<td>
<p>Start point and end point of
time interval during a year, which has the format &quot;MM-DD&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with inputted data and additional
column 'BATCH' indicates which subset of inputted data is located
within given time interval. In column 'BATCH', different integers
stands for different segments and 0 stands for outside given time
interval.
</p>


<h3>Author(s)</h3>

<p>Chaoran Hu
</p>

<hr>
<h2 id='transfData'>Transfer raw dataset to the standard dataset (seasonal analysis toolbox)</h2><span id='topic+transfData'></span>

<h3>Description</h3>

<p>Transfer the raw location dataset of animal to the standard dataset,
which is acceptable in this packages. The raw dataset contains at least
four components: 1. <code>t1</code>: data information. 2. <code>dt..hr.</code>: the
difference of time between two sample points. 3. <code>e1</code>: the GPS
coordinate of east-west. 4. <code>n1</code>: the GPS coordinate of north-south.
(These weird variable names are from the original GPS data. We will
change them in later version.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfData(data, dateFormat, roundValue = NULL, lengthUnit = "km")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transfData_+3A_data">data</code></td>
<td>
<p>The raw dataset.</p>
</td></tr>
<tr><td><code id="transfData_+3A_dateformat">dateFormat</code></td>
<td>
<p>Charater string indicates the format of date variable.</p>
</td></tr>
<tr><td><code id="transfData_+3A_roundvalue">roundValue</code></td>
<td>
<p>Round GPS coordinate to <code>roundValue</code> with unit meter.
If NULL (default), no rounding will be processed.</p>
</td></tr>
<tr><td><code id="transfData_+3A_lengthunit">lengthUnit</code></td>
<td>
<p>Charater string indicates the length unit of GPS coordinate,
which can be &quot;m&quot; or &quot;km&quot;(default). Usually, we recommend not change the
default setup of this parameter. Otherwise, numerical computation problem
will happen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the following components, which is
standard format of dataset in this package:
</p>

<ul>
<li><p> date: tells us the date of collecting this sample point.
</p>
</li>
<li><p> cumTime: cumulative time line. The collection of this data starts
from time 0 in this time line. (Time unit is hours.)
</p>
</li>
<li><p> centerE: the centered east-west GPS coordinate with the center is
the starting point (when <code>cumTime[1]</code>).
</p>
</li>
<li><p> centerN: the centered north-south GPS coordinate with the center is
the starting point (when <code>cumTime[1]</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chaoran Hu
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.Date">as.Date</a></code> has parameter <code>format</code>, which is the
same as the parameter <code>dateFormat</code> in this function.
</p>

<hr>
<h2 id='vcov'>Variance-Covariance Matrix of smam Estimators</h2><span id='topic+vcov'></span><span id='topic+vcov.smam_mrme'></span><span id='topic+vcov.smam_mm'></span><span id='topic+vcov.smam_mrh'></span><span id='topic+vcov.smam_mr'></span><span id='topic+vcov.smam_bmme'></span>

<h3>Description</h3>

<p>This function calculates variance covariance matrix for
estimators from smam package. Different methods will
be used for different 'smam' models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smam_mrme'
vcov(
  object,
  nBS = 25,
  detailBS = TRUE,
  numThreads = 5,
  gradMethod = "simple",
  vcovMethod = "pBootstrap",
  integrControl = integr.control(),
  ...
)

## S3 method for class 'smam_mm'
vcov(
  object,
  nBS = 25,
  detailBS = TRUE,
  numThreads = 5,
  integrControl = integr.control(),
  ...
)

## S3 method for class 'smam_mrh'
vcov(object, numThreads = 5, integrControl = integr.control(), ...)

## S3 method for class 'smam_mr'
vcov(object, ...)

## S3 method for class 'smam_bmme'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>a fitted object from one of 'smam::fitXXXX' functions</p>
</td></tr>
<tr><td><code id="vcov_+3A_nbs">nBS</code></td>
<td>
<p>number of bootstrap.</p>
</td></tr>
<tr><td><code id="vcov_+3A_detailbs">detailBS</code></td>
<td>
<p>whether or not output estimation results of bootstrap,
which can be used to generate bootstrap CI. Required
when &lsquo;vcovMethod==&rsquo;pBootstrap''.</p>
</td></tr>
<tr><td><code id="vcov_+3A_numthreads">numThreads</code></td>
<td>
<p>the number of threads for parallel computation.
If its value is greater than 1, then parallel computation will be
processed. Otherwise, serial computation will be processed.</p>
</td></tr>
<tr><td><code id="vcov_+3A_gradmethod">gradMethod</code></td>
<td>
<p>method used for numeric gradient (<code>numDeriv::grad</code>).
Required when &lsquo;vcovMethod==&rsquo;Godambe''.</p>
</td></tr>
<tr><td><code id="vcov_+3A_vcovmethod">vcovMethod</code></td>
<td>
<p>method of calculating variance covariance matrix.
This should be one of 'pBootstrap' (default) and 'Godambe'.</p>
</td></tr>
<tr><td><code id="vcov_+3A_integrcontrol">integrControl</code></td>
<td>
<p>a list of control parameters for the <code>integrate</code>
function: rel.tol, abs.tol, subdivision.</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## time consuming example
#tgrid &lt;- seq(0, 100, length=100)
#set.seed(123)
#dat &lt;- rMRME(tgrid, 1, 0.5, 1, 0.01, "m")

## fit whole dataset to the MRME model
#fit &lt;- fitMRME(dat, start=c(1, 0.5, 1, 0.01))
#fit

## get covariance matrix of estimators
#vcov(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
