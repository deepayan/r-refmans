<!DOCTYPE html><html lang="en"><head><title>Help for package DiscreteDists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteDists}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add'><p>Sum of One-Dimensional Functions</p></a></li>
<li><a href='#AR'><p>Auxiliar function for hyper Poisson</p></a></li>
<li><a href='#DBH'><p>The Discrete Burr Hatke family</p></a></li>
<li><a href='#dDBH'><p>The Discrete Burr Hatke distribution</p></a></li>
<li><a href='#dDGEII'><p>Discrete generalized exponential distribution - a second type</p></a></li>
<li><a href='#dDIKUM'><p>The discrete Inverted Kumaraswamy distribution</p></a></li>
<li><a href='#dDLD'><p>The Discrete Lindley distribution</p></a></li>
<li><a href='#dDMOLBE'><p>The DMOLBE distribution</p></a></li>
<li><a href='#DGEII'><p>The DGEII distribution</p></a></li>
<li><a href='#dGGEO'><p>The GGEO distribution</p></a></li>
<li><a href='#dHYPERPO'><p>The hyper-Poisson distribution</p></a></li>
<li><a href='#dHYPERPO_single'><p>Function to obtain the dHYPERPO for a single value x</p></a></li>
<li><a href='#dHYPERPO_vec'><p>Function to obtain the dHYPERPO for a vector x</p></a></li>
<li><a href='#dHYPERPO2'><p>The hyper-Poisson distribution (with mu as mean)</p></a></li>
<li><a href='#DIKUM'><p>The discrete Inverted Kumaraswamy family</p></a></li>
<li><a href='#DLD'><p>The Discrete Lindley family</p></a></li>
<li><a href='#DMOLBE'><p>The DMOLBE family</p></a></li>
<li><a href='#dPOISXL'><p>The Discrete Poisson XLindley</p></a></li>
<li><a href='#estim_mu_DBH'><p>Initial values for Discrete Burr Hatke</p></a></li>
<li><a href='#estim_mu_DLD'><p>Initial values for Discrete Lindley</p></a></li>
<li><a href='#estim_mu_POISXL'><p>Initial values for discrete Poisson XLindley distribution</p></a></li>
<li><a href='#estim_mu_sigma_DGEII'><p>Initial values for DGEII</p></a></li>
<li><a href='#estim_mu_sigma_DIKUM'><p>Initial values for discrete Inverted Kumaraswamy</p></a></li>
<li><a href='#estim_mu_sigma_DMOLBE'><p>Initial values for DMOLBE</p></a></li>
<li><a href='#estim_mu_sigma_GGEO'><p>Initial values for GGEO</p></a></li>
<li><a href='#estim_mu_sigma_HYPERPO'><p>Initial values for hyper Poisson</p></a></li>
<li><a href='#estim_mu_sigma_HYPERPO2'><p>Initial values for hyper Poisson in second parameterization</p></a></li>
<li><a href='#F11'><p>Auxiliar function for hyper Poisson</p></a></li>
<li><a href='#f11_cpp'><p>Function to obtain F11 with C++.</p></a></li>
<li><a href='#GGEO'><p>The GGEO family</p></a></li>
<li><a href='#HYPERPO'><p>The hyper Poisson family</p></a></li>
<li><a href='#HYPERPO2'><p>The hyper Poisson family (with mu as mean)</p></a></li>
<li><a href='#logLik_DBH'><p>logLik function for Discrete Burr Hatke</p></a></li>
<li><a href='#logLik_DGEII'><p>logLik function for DGEII</p></a></li>
<li><a href='#logLik_DIKUM'><p>logLik function for discrete Inverted Kumaraswamy</p></a></li>
<li><a href='#logLik_DLD'><p>logLik function for Discrete Lindley distribution</p></a></li>
<li><a href='#logLik_DMOLBE'><p>logLik function for DMOLBE</p></a></li>
<li><a href='#logLik_GGEO'><p>logLik function for GGEO</p></a></li>
<li><a href='#logLik_HYPERPO'><p>logLik function for hyper Poisson</p></a></li>
<li><a href='#logLik_HYPERPO2'><p>logLik function for hyper Poisson in second parameterization</p></a></li>
<li><a href='#logLik_POISXL'><p>logLik function for Poisson XLindley distribution</p></a></li>
<li><a href='#mean_var_hp'><p>Mean and variance for hyper-Poisson distribution</p></a></li>
<li><a href='#obtaining_lambda'><p>Auxiliar function to obtain lambda from E(X)</p></a></li>
<li><a href='#plot_discrete_cdf'><p>Draw the CDF for a discrete random variable</p></a></li>
<li><a href='#POISXL'><p>The Discrete Poisson XLindley</p></a></li>
<li><a href='#simulate_hp'><p>The simulate_hp</p></a></li>
<li><a href='#stopping'><p>Auxiliar function for F11</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Discrete Statistical Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of new discrete statistical distributions. Each distribution includes the traditional functions as well as an additional function called the family function, which can be used to estimate parameters within the 'gamlss' framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Imports:</td>
<td>gamlss, gamlss.dist, pracma, Rdpack, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fhernanb/DiscreteDists">https://github.com/fhernanb/DiscreteDists</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fhernanb/DiscreteDists/issues">https://github.com/fhernanb/DiscreteDists/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-11 01:13:09 UTC; fhern</td>
</tr>
<tr>
<td>Author:</td>
<td>Freddy Hernandez-Barajas
    <a href="https://orcid.org/0000-0001-7459-3329"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Fernando Marmolejo-Ramos
    <a href="https://orcid.org/0000-0003-4680-1287"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jamiu Olumoh <a href="https://orcid.org/0000-0002-7371-3920"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Osho Ajayi <a href="https://orcid.org/0000-0002-2436-3338"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Olga Usuga-Manco <a href="https://orcid.org/0000-0003-3062-1820"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Freddy Hernandez-Barajas &lt;fhernanb@unal.edu.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-13 18:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add'>Sum of One-Dimensional Functions</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>Sum of One-Dimensional Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(f, lower, upper, ..., abs.tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_+3A_f">f</code></td>
<td>
<p>an R function taking a numeric first argument and returning a numeric vector of the same length.</p>
</td></tr>
<tr><td><code id="add_+3A_lower">lower</code></td>
<td>
<p>the lower limit of sum. Can be infinite.</p>
</td></tr>
<tr><td><code id="add_+3A_upper">upper</code></td>
<td>
<p>the upper limit of sum. Can be infinite.</p>
</td></tr>
<tr><td><code id="add_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to f.</p>
</td></tr>
<tr><td><code id="add_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the sum value.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Poisson expected value
add(f=function(x, lambda) x*dpois(x, lambda), lower=0, upper=Inf,
    lambda=7.5)

# Binomial expected value
add(f=function(x, size, prob) x*dbinom(x, size, prob), lower=0, upper=20,
    size=20, prob=0.5)

# Examples with infinite series
add(f=function(x) 0.5^x, lower=0, upper=100) # Ans=2
add(f=function(x) (1/3)^(x-1), lower=1, upper=Inf) # Ans=1.5
add(f=function(x) 4/(x^2+3*x+2), lower=0, upper=Inf, abs.tol=0.001) # Ans=4.0
add(f=function(x) 1/(x*(log(x)^2)), lower=2, upper=Inf, abs.tol=0.000001) # Ans=2.02
add(f=function(x) 3*0.7^(x-1), lower=1, upper=Inf) # Ans=10
add(f=function(x, a, b) a*b^(x-1), lower=1, upper=Inf, a=3, b=0.7) # Ans=10
add(f=function(x, a=3, b=0.7) a*b^(x-1), lower=1, upper=Inf) # Ans=10

</code></pre>

<hr>
<h2 id='AR'>Auxiliar function for hyper Poisson</h2><span id='topic+AR'></span>

<h3>Description</h3>

<p>This function is used to calculate (a)r.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR(a, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AR_+3A_a">a</code></td>
<td>
<p>first value.</p>
</td></tr>
<tr><td><code id="AR_+3A_r">r</code></td>
<td>
<p>second value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value for the a(r) function.
</p>

<hr>
<h2 id='DBH'>The Discrete Burr Hatke family</h2><span id='topic+DBH'></span>

<h3>Description</h3>

<p>The function <code>DBH()</code> defines the Discrete Burr Hatke distribution, one-parameter
discrete distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBH(mu.link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBH_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;logit&quot; link as the default for the mu parameter. Other links are &quot;probit&quot; and &quot;cloglog&quot;'(complementary log-log)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Burr-Hatke distribution with parameters <code class="reqn">\mu</code> has a support
0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu) = (\frac{1}{x+1}-\frac{\mu}{x+2})\mu^{x}</code>
</p>
<p>The pmf is log-convex for all values of <code class="reqn">0 &lt; \mu &lt; 1</code>, where <code class="reqn">\frac{f(x+1;\mu)}{f(x;\mu)}</code>
is an increasing function in <code class="reqn">x</code> for all values of the parameter <code class="reqn">\mu</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\lambda</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a Discrete Burr-Hatke distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepulveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>El-Morshedy M, Eliwa MS, Altun E (2020).
&ldquo;Discrete Burr-Hatke distribution with properties, estimation methods and regression model.&rdquo;
<em>IEEE access</em>, <b>8</b>, 74359&ndash;74370.
</p>


<h3>See Also</h3>

<p><a href="#topic+dDBH">dDBH</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu
y &lt;- rDBH(n=1000, mu=0.74)

library(gamlss)
mod1 &lt;- gamlss(y~1, family=DBH,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu
# using the inverse logit function
inv_logit &lt;- function(x) exp(x) / (1+exp(x))
inv_logit(coef(mod1, parameter="mu"))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ DBH
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  mu    &lt;- inv_logit(-3 + 5 * x1)
  y &lt;- rDBH(n=n, mu=mu)
  data.frame(y=y, x1=x1)
}

datos &lt;- gendat(n=150)

mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, family=DBH, data=datos,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)

# Example 3
# number of carious teeth among the four deciduous molars.
# Taken from EL-MORSHEDY (2020) page 74364.

y &lt;- rep(0:4, times=c(64, 17, 10, 6, 3))

mod3 &lt;- gamlss(y~1, family=DBH,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu
# using the inverse link function
inv_logit &lt;- function(x) 1/(1 + exp(-x))
inv_logit(coef(mod3, what="mu"))
</code></pre>

<hr>
<h2 id='dDBH'>The Discrete Burr Hatke distribution</h2><span id='topic+dDBH'></span><span id='topic+pDBH'></span><span id='topic+qDBH'></span><span id='topic+rDBH'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Discrete Burr Hatke distribution
with parameter <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDBH(x, mu, log = FALSE)

pDBH(q, mu, lower.tail = TRUE, log.p = FALSE)

qDBH(p, mu = 1, lower.tail = TRUE, log.p = FALSE)

rDBH(n, mu = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dDBH_+3A_x">x</code>, <code id="dDBH_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dDBH_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dDBH_+3A_log">log</code>, <code id="dDBH_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dDBH_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dDBH_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dDBH_+3A_n">n</code></td>
<td>
<p>number of random values to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Burr-Hatke distribution with parameters <code class="reqn">\mu</code> has a support
0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu) = (\frac{1}{x+1}-\frac{\mu}{x+2})\mu^{x}</code>
</p>
<p>The pmf is log-convex for all values of <code class="reqn">0 &lt; \mu &lt; 1</code>, where <code class="reqn">\frac{f(x+1;\mu)}{f(x;\mu)}</code>
is an increasing function in <code class="reqn">x</code> for all values of the parameter <code class="reqn">\mu</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\lambda</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dDBH</code> gives the density, <code>pDBH</code> gives the distribution
function, <code>qDBH</code> gives the quantile function, <code>rDBH</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepulveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>El-Morshedy M, Eliwa MS, Altun E (2020).
&ldquo;Discrete Burr-Hatke distribution with properties, estimation methods and regression model.&rdquo;
<em>IEEE access</em>, <b>8</b>, 74359&ndash;74370.
</p>


<h3>See Also</h3>

<p><a href="#topic+DBH">DBH</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

plot(x=0:5, y=dDBH(x=0:5, mu=0.1),
     type="h", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 1),
     main="Probability mu=0.1")

plot(x=0:10, y=dDBH(x=0:10, mu=0.5),
     type="h", lwd=2, col="tomato", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 1),
     main="Probability mu=0.5")

plot(x=0:15, y=dDBH(x=0:15, mu=0.9),
     type="h", lwd=2, col="green4", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 1),
     main="Probability mu=0.9")

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 15
cumulative_probs1 &lt;- pDBH(q=0:x_max, mu=0.1)
cumulative_probs2 &lt;- pDBH(q=0:x_max, mu=0.5)
cumulative_probs3 &lt;- pDBH(q=0:x_max, mu=0.9)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for Burr-Hatke",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
legend("bottomright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.1",
                "mu=0.5",
                "mu=0.9"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

mu &lt;- 0.4
x_max &lt;- 10
probs1 &lt;- dDBH(x=0:x_max, mu=mu)
names(probs1) &lt;- 0:x_max

x &lt;- rDBH(n=1000, mu=mu)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c("dodgerblue3","firebrick3"), las=1,
              xlab="X", ylab="Proportion")
legend("topright",
       legend=c("Theoretical", "Simulated"),
       bty="n", lwd=3,
       col=c("dodgerblue3","firebrick3"), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 0.97
p &lt;- seq(from=0, to=1, by = 0.01)
qxx &lt;- qDBH(p, mu, lower.tail = TRUE, log.p = FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of BH(mu=0.97)")

</code></pre>

<hr>
<h2 id='dDGEII'>Discrete generalized exponential distribution - a second type</h2><span id='topic+dDGEII'></span><span id='topic+pDGEII'></span><span id='topic+rDGEII'></span><span id='topic+qDGEII'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Discrete generalized exponential distribution
a second type with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDGEII(x, mu = 0.5, sigma = 1.5, log = FALSE)

pDGEII(q, mu = 0.5, sigma = 1.5, lower.tail = TRUE, log.p = FALSE)

rDGEII(n, mu = 0.5, sigma = 1.5)

qDGEII(p, mu = 0.5, sigma = 1.5, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dDGEII_+3A_x">x</code>, <code id="dDGEII_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_sigma">sigma</code></td>
<td>
<p>vector of the sigma parameter.</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_log">log</code>, <code id="dDGEII_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dDGEII_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DGEII distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = (1-\mu^{x+1})^{\sigma}-(1-\mu^x)^{\sigma}</code>
</p>
<p>with <code class="reqn">0 &lt; \mu &lt; 1</code> and <code class="reqn">\sigma &gt; 0</code>. If <code class="reqn">\sigma=1</code>, the DGEII distribution
reduces to the geometric distribution with success probability <code class="reqn">1-\mu</code>.
</p>
<p>Note: in this implementation we changed the original parameters
<code class="reqn">p</code> to <code class="reqn">\mu</code> and <code class="reqn">\alpha</code> to <code class="reqn">\sigma</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dDGEII</code> gives the density, <code>pDGEII</code> gives the distribution
function, <code>qDGEII</code> gives the quantile function, <code>rDGEII</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepulveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Nekoukhou V, Alamatsaz MH, Bidram H (2013).
&ldquo;Discrete generalized exponential distribution of a second type.&rdquo;
<em>Statistics</em>, <b>47</b>(4), 876-887.
</p>


<h3>See Also</h3>

<p><a href="#topic+DGEII">DGEII</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 40
probs1 &lt;- dDGEII(x=0:x_max, mu=0.1, sigma=5)
probs2 &lt;- dDGEII(x=0:x_max, mu=0.5, sigma=5)
probs3 &lt;- dDGEII(x=0:x_max, mu=0.9, sigma=5)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for DGEII",
     ylim=c(0, 0.60))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.1, sigma=5",
                "mu=0.5, sigma=5",
                "mu=0.9, sigma=5"))

# Example 2
# Checking if the cumulative curves converge to 1

#plot1
x_max &lt;- 10
plot_discrete_cdf(x=0:x_max,
                  fx=dDGEII(x=0:x_max, mu=0.3, sigma=15),
                  col="dodgerblue",
                  main="CDF for DGEII",
                  lwd=3)
legend("bottomright", legend="mu=0.3, sigma=15",
       col="dodgerblue", lty=1, lwd=2, cex=0.8)


#plot2
plot_discrete_cdf(x=0:x_max,
                  fx=dDGEII(x=0:x_max, mu=0.5, sigma=30),
                  col="tomato",
                  main="CDF for DGEII",
                  lwd=3)
legend("bottomright", legend="mu=0.5, sigma=30",
       col="tomato", lty=1, lwd=2, cex=0.8)


#plot3
plot_discrete_cdf(x=0:x_max,
                  fx=dDGEII(x=0:x_max, mu=0.5, sigma=50),
                  col="green4",
                  main="CDF for DGEII",
                  lwd=3)
legend("bottomright", legend="mu=0.5, sigma=50",
       col="green4", lty=1, lwd=2, cex=0.8)


# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dDGEII(x=0:x_max, mu=0.5, sigma=5)
names(probs1) &lt;- 0:x_max

x &lt;- rDGEII(n=1000, mu=0.5, sigma=5)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside=TRUE, names.arg=nombres,
              col=c('dodgerblue3','firebrick3'), las=1,
              xlab='X', ylab='Proportion')
legend('topright',
       legend=c('Theoretical', 'Simulated'),
       bty='n', lwd=3,
       col=c('dodgerblue3','firebrick3'), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 0.5
sigma &lt;- 5
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qDGEII(p=p, mu=mu, sigma=sigma, lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of DDGEII(mu=0.5, sigma=5)")

</code></pre>

<hr>
<h2 id='dDIKUM'>The discrete Inverted Kumaraswamy distribution</h2><span id='topic+dDIKUM'></span><span id='topic+pDIKUM'></span><span id='topic+rDIKUM'></span><span id='topic+qDIKUM'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the discrete Inverted Kumaraswamy, DIKUM(), distribution
with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDIKUM(x, mu = 1, sigma = 5, log = FALSE)

pDIKUM(q, mu = 1, sigma = 5, lower.tail = TRUE, log.p = FALSE)

rDIKUM(n, mu = 1, sigma = 5)

qDIKUM(p, mu = 1, sigma = 5, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dDIKUM_+3A_x">x</code>, <code id="dDIKUM_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_sigma">sigma</code></td>
<td>
<p>vector of the sigma parameter.</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_log">log</code>, <code id="dDIKUM_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dDIKUM_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete Inverted Kumaraswamy distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = (1-(2+x)^{-\mu})^{\sigma}-(1-(1+x)^{-\mu})^{\sigma}</code>
</p>
<p>with <code class="reqn">\mu &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> respectively, we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dDIKUM</code> gives the density, <code>pDIKUM</code> gives the distribution
function, <code>qDIKUM</code> gives the quantile function, <code>rDIKUM</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Daniel Felipe Villa Rengifo, <a href="mailto:dvilla@unal.edu.co">dvilla@unal.edu.co</a>
</p>


<h3>References</h3>

<p>EL-Helbawy AA, Hegazy MA, AL-Dayian GR, Abd EL-Kader RE (2022).
&ldquo;A Discrete Analog of the Inverted Kumaraswamy Distribution: Properties and Estimation with Application to COVID-19 Data.&rdquo;
<em>Pakistan Journal of Statistics &amp; Operation Research</em>, <b>18</b>(1).
</p>


<h3>See Also</h3>

<p><a href="#topic+DIKUM">DIKUM</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 30

probs1 &lt;- dDIKUM(x=0:x_max, mu=1, sigma=5)
probs2 &lt;- dDIKUM(x=0:x_max, mu=1, sigma=20)
probs3 &lt;- dDIKUM(x=0:x_max, mu=1, sigma=50)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for Inverted Kumaraswamy Distribution",
     ylim=c(0, 0.12))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=1, sigma=5",
                "mu=1, sigma=20",
                "mu=1, sigma=50"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 500

cumulative_probs1 &lt;- pDIKUM(q=0:x_max, mu=1, sigma=5)
cumulative_probs2 &lt;- pDIKUM(q=0:x_max, mu=1, sigma=20)
cumulative_probs3 &lt;- pDIKUM(q=0:x_max, mu=1, sigma=50)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for Inverted Kumaraswamy Distribution",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
legend("bottomright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=1, sigma=5",
                "mu=1, sigma=20",
                "mu=1, sigma=50"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 20
probs1 &lt;- dDIKUM(x=0:x_max, mu=3, sigma=20)
names(probs1) &lt;- 0:x_max

x &lt;- rDIKUM(n=1000, mu=3, sigma=20)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c('dodgerblue3','firebrick3'), las=1,
              xlab='X', ylab='Proportion')
legend('topright',
       legend=c('Theoretical', 'Simulated'),
       bty='n', lwd=3,
       col=c('dodgerblue3','firebrick3'), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 1
sigma &lt;- 5
p &lt;- seq(from=0.01, to=0.99, by=0.1)
qxx &lt;- qDIKUM(p=p, mu=mu, sigma=sigma, lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of HP(mu = sigma = 3)")

</code></pre>

<hr>
<h2 id='dDLD'>The Discrete Lindley distribution</h2><span id='topic+dDLD'></span><span id='topic+pDLD'></span><span id='topic+qDLD'></span><span id='topic+rDLD'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Discrete Lindley distribution
with parameter <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDLD(x, mu, log = FALSE)

pDLD(q, mu, lower.tail = TRUE, log.p = FALSE)

qDLD(p, mu, lower.tail = TRUE, log.p = FALSE)

rDLD(n, mu = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dDLD_+3A_x">x</code>, <code id="dDLD_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dDLD_+3A_mu">mu</code></td>
<td>
<p>vector of positive values of this parameter.</p>
</td></tr>
<tr><td><code id="dDLD_+3A_log">log</code>, <code id="dDLD_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dDLD_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dDLD_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dDLD_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Lindley distribution with parameters <code class="reqn">\mu</code> has a support
0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu) = \frac{e^{-\mu x}}{1 + \mu} \left[ \mu(1 - 2e^{-\mu}) + (1- e^{-\mu})(1+\mu x)\right]</code>
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\theta</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dDLD</code> gives the density, <code>pDLD</code> gives the distribution
function, <code>qDLD</code> gives the quantile function, <code>rDLD</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Yojan Andrés Alcaraz Pérez, <a href="mailto:yalcaraz@unal.edu.co">yalcaraz@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Bakouch HS, Jazi MA, Nadarajah S (2014).
&ldquo;A new discrete distribution.&rdquo;
<em>Statistics</em>, <b>48</b>(1), 200&ndash;240.
</p>


<h3>See Also</h3>

<p><a href="#topic+DLD">DLD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

plot(x=0:25, y=dDLD(x=0:25, mu=0.2),
     type="h", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 0.1),
     main="Probability mu=0.2")

plot(x=0:15, y=dDLD(x=0:15, mu=0.5),
     type="h", lwd=2, col="tomato", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 0.25),
     main="Probability mu=0.5")

plot(x=0:8, y=dDLD(x=0:8, mu=1),
     type="h", lwd=2, col="green4", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 0.5),
     main="Probability mu=1")

plot(x=0:5, y=dDLD(x=0:5, mu=2),
     type="h", lwd=2, col="red", las=1,
     ylab="P(X=x)", xlab="X", ylim=c(0, 1),
     main="Probability mu=2")

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 10
cumulative_probs1 &lt;- pDLD(q=0:x_max, mu=0.2)
cumulative_probs2 &lt;- pDLD(q=0:x_max, mu=0.5)
cumulative_probs3 &lt;- pDLD(q=0:x_max, mu=1)
cumulative_probs4 &lt;- pDLD(q=0:x_max, mu=2)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for Lindley",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
points(x=0:x_max, y=cumulative_probs4, type="o", col="magenta")
legend("bottomright",
       col=c("dodgerblue", "tomato", "green4", "magenta"), lwd=3,
       legend=c("mu=0.2",
                "mu=0.5",
                "mu=1",
                "mu=2"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

mu &lt;- 0.6
x &lt;- rDLD(n = 1000, mu = mu)
x_max &lt;- max(x)
probs1 &lt;- dDLD(x = 0:x_max, mu = mu)
names(probs1) &lt;- 0:x_max

probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn

mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c('dodgerblue3','firebrick3'), las=1,
              xlab='X', ylab='Proportion')
legend('topright',
       legend=c('Theoretical', 'Simulated'),
       bty='n', lwd=3,
       col=c('dodgerblue3','firebrick3'), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 0.9
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qDLD(p, mu, lower.tail = TRUE, log.p = FALSE)
plot(p, qxx, type="S", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of DL(mu=0.9)")

</code></pre>

<hr>
<h2 id='dDMOLBE'>The DMOLBE distribution</h2><span id='topic+dDMOLBE'></span><span id='topic+pDMOLBE'></span><span id='topic+rDMOLBE'></span><span id='topic+qDMOLBE'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Discrete Marshall–Olkin Length Biased
Exponential DMOLBE distribution
with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDMOLBE(x, mu = 1, sigma = 1, log = FALSE)

pDMOLBE(q, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rDMOLBE(n, mu = 1, sigma = 1)

qDMOLBE(p, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dDMOLBE_+3A_x">x</code>, <code id="dDMOLBE_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_sigma">sigma</code></td>
<td>
<p>vector of the sigma parameter.</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_log">log</code>, <code id="dDMOLBE_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dDMOLBE_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DMOLBE distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\sigma ((1+x/\mu)\exp(-x/\mu)-(1+(x+1)/\mu)\exp(-(x+1)/\mu))}{(1-(1-\sigma)(1+x/\mu)\exp(-x/\mu)) ((1-(1-\sigma)(1+(x+1)/\mu)\exp(-(x+1)/\mu))}</code>
</p>
<p>with <code class="reqn">\mu &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>
</p>


<h3>Value</h3>

<p><code>dDMOLBE</code> gives the density, <code>pDMOLBE</code> gives the distribution
function, <code>qDMOLBE</code> gives the quantile function, <code>rDMOLBE</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Olga Usuga, <a href="mailto:olga.usuga@udea.edu.co">olga.usuga@udea.edu.co</a>
</p>


<h3>References</h3>

<p>Aljohani HM, Ahsan-ul-Haq M, Zafar J, Almetwally EM, Alghamdi AS, Hussam E, Muse AH (2023).
&ldquo;Analysis of Covid-19 data using discrete Marshall-Olkinin Length Biased Exponential: Bayesian and frequentist approach.&rdquo;
<em>Scientific Reports</em>, <b>13</b>(1), 12243.
</p>


<h3>See Also</h3>

<p><a href="#topic+DMOLBE">DMOLBE</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 20
probs1 &lt;- dDMOLBE(x=0:x_max, mu=0.5, sigma=0.5)
probs2 &lt;- dDMOLBE(x=0:x_max, mu=5, sigma=0.5)
probs3 &lt;- dDMOLBE(x=0:x_max, mu=1, sigma=2)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for DMOLBE",
     ylim=c(0, 0.80))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.5, sigma=0.5",
                "mu=5, sigma=0.5",
                "mu=1, sigma=2"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 20
cumulative_probs1 &lt;- pDMOLBE(q=0:x_max, mu=0.5, sigma=0.5)
cumulative_probs2 &lt;- pDMOLBE(q=0:x_max, mu=5, sigma=0.5)
cumulative_probs3 &lt;- pDMOLBE(q=0:x_max, mu=1, sigma=2)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for DMOLBE",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
legend("bottomright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.5, sigma=0.5",
                "mu=5, sigma=0.5",
                "mu=1, sigma=2"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dDMOLBE(x=0:x_max, mu=5, sigma=0.5)
names(probs1) &lt;- 0:x_max

x &lt;- rDMOLBE(n=1000, mu=5, sigma=0.5)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c('dodgerblue3','firebrick3'), las=1,
              xlab='X', ylab='Proportion')
legend('topright',
       legend=c('Theoretical', 'Simulated'),
       bty='n', lwd=3,
       col=c('dodgerblue3','firebrick3'), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 3
sigma &lt;-3
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qDMOLBE(p=p, mu=mu, sigma=sigma, lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of DMOLBE(mu = 3, sigma = 3)")

</code></pre>

<hr>
<h2 id='DGEII'>The DGEII distribution</h2><span id='topic+DGEII'></span>

<h3>Description</h3>

<p>The function <code>DGEII()</code> defines the Discrete generalized exponential distribution,
Second type, a two parameter
distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DGEII(mu.link = "logit", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DGEII_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;logit&quot; link as the default for the mu parameter. Other links are &quot;probit&quot; and &quot;cloglog&quot;'(complementary log-log).</p>
</td></tr>
<tr><td><code id="DGEII_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;log&quot; link as the default for the sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DGEII distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = (1-\mu^{x+1})^{\sigma}-(1-\mu^x)^{\sigma}</code>
</p>
<p>with <code class="reqn">0 &lt; \mu &lt; 1</code> and <code class="reqn">\sigma &gt; 0</code>. If <code class="reqn">\sigma=1</code>, the DGEII distribution
reduces to the geometric distribution with success probability <code class="reqn">1-\mu</code>.
</p>
<p>Note: in this implementation we changed the original parameters
<code class="reqn">p</code> to <code class="reqn">\mu</code> and <code class="reqn">\alpha</code> to <code class="reqn">\sigma</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a DGEII distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepúlveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Nekoukhou V, Alamatsaz MH, Bidram H (2013).
&ldquo;Discrete generalized exponential distribution of a second type.&rdquo;
<em>Statistics</em>, <b>47</b>(4), 876-887.
</p>


<h3>See Also</h3>

<p><a href="#topic+dDGEII">dDGEII</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(189)
y &lt;- rDGEII(n=100, mu=0.75, sigma=0.5)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, family=DGEII,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
inv_logit &lt;- function(x) 1/(1 + exp(-x))

inv_logit(coef(mod1, what="mu"))
exp(coef(mod1, what="sigma"))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ GGEO
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  mu    &lt;- inv_logit(1.7 - 2.8*x1)
  sigma &lt;- exp(0.73 + 1*x2)
  y &lt;- rDGEII(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1, x2=x2)
}

set.seed(1234)
datos &lt;- gendat(n=100)

mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=DGEII, data=datos,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)

# Example 3
# Number of accidents to 647 women working on H. E. Shells
# for 5 weeks. Taken from
# Nekoukhou V, Alamatsaz MH, Bidram H (2013) page 886.

y &lt;- rep(x=0:5, times=c(447, 132, 42, 21, 3, 2))

mod3 &lt;- gamlss(y~1, family=DGEII,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
inv_logit &lt;- function(x) 1/(1 + exp(-x))
inv_logit(coef(mod3, what="mu"))
exp(coef(mod3, what="sigma"))

</code></pre>

<hr>
<h2 id='dGGEO'>The GGEO distribution</h2><span id='topic+dGGEO'></span><span id='topic+pGGEO'></span><span id='topic+rGGEO'></span><span id='topic+qGGEO'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Generalized Geometric distribution
with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGGEO(x, mu = 0.5, sigma = 1, log = FALSE)

pGGEO(q, mu = 0.5, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rGGEO(n, mu = 0.5, sigma = 1)

qGGEO(p, mu = 0.5, sigma = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dGGEO_+3A_x">x</code>, <code id="dGGEO_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_sigma">sigma</code></td>
<td>
<p>vector of the sigma parameter.</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_log">log</code>, <code id="dGGEO_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dGGEO_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GGEO distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\sigma \mu^x (1-\mu)}{(1-(1-\sigma) \mu^{x+1})(1-(1-\sigma) \mu^{x})}</code>
</p>
<p>with <code class="reqn">0 &lt; \mu &lt; 1</code> and <code class="reqn">\sigma &gt; 0</code>. If <code class="reqn">\sigma=1</code>, the GGEO distribution
reduces to the geometric distribution with success probability <code class="reqn">1-\mu</code>.
</p>
<p>Note: in this implementation we changed the original parameters
<code class="reqn">\theta</code> for <code class="reqn">\mu</code> and <code class="reqn">\alpha</code> for <code class="reqn">\sigma</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dGGEO</code> gives the density, <code>pGGEO</code> gives the distribution
function, <code>qGGEO</code> gives the quantile function, <code>rGGEO</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepulveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Gómez-Déniz E (2010).
&ldquo;Another generalization of the geometric distribution.&rdquo;
<em>Test</em>, <b>19</b>, 399-415.
</p>


<h3>See Also</h3>

<p><a href="#topic+GGEO">GGEO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 80
probs1 &lt;- dGGEO(x=0:x_max, mu=0.5, sigma=10)
probs2 &lt;- dGGEO(x=0:x_max, mu=0.7, sigma=30)
probs3 &lt;- dGGEO(x=0:x_max, mu=0.9, sigma=50)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for GGEO",
     ylim=c(0, 0.20))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.5, sigma=10",
                "mu=0.7, sigma=30",
                "mu=0.9, sigma=50"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 10
plot_discrete_cdf(x=0:x_max,
                  fx=dGGEO(x=0:x_max, mu=0.3, sigma=15),
                  col="dodgerblue",
                  main="CDF for GGEO",
                  lwd= 3)
legend("bottomright", legend="mu=0.3, sigma=15", col="dodgerblue",
       lty=1, lwd=2, cex=0.8)

plot_discrete_cdf(x=0:x_max,
                  fx=dGGEO(x=0:x_max, mu=0.5, sigma=30),
                  col="tomato",
                  main="CDF for GGEO",
                  lwd=3)
legend("bottomright", legend="mu=0.5, sigma=30",
       col="tomato", lty=1, lwd=2, cex=0.8)

plot_discrete_cdf(x=0:x_max,
                  fx=dGGEO(x=0:x_max, mu=0.5, sigma=50),
                  col="green4",
                  main="CDF for GGEO",
                  lwd=3)
legend("bottomright", legend="mu=0.5, sigma=50",
       col="green4", lty=1, lwd=2, cex=0.8)

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dGGEO(x=0:x_max, mu=0.5, sigma=5)
names(probs1) &lt;- 0:x_max

x &lt;- rGGEO(n=1000, mu=0.5, sigma=5)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside=TRUE, names.arg=nombres,
              col=c("dodgerblue3", "firebrick3"), las=1,
              xlab="X", ylab="Proportion")
legend("topright",
       legend=c("Theoretical", "Simulated"),
       bty="n", lwd=3,
       col=c("dodgerblue3","firebrick3"), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 0.5
sigma &lt;- 5
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qGGEO(p=p, mu=mu, sigma=sigma, lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of GGEO(mu=0.5, sigma=0.5)")

</code></pre>

<hr>
<h2 id='dHYPERPO'>The hyper-Poisson distribution</h2><span id='topic+dHYPERPO'></span><span id='topic+pHYPERPO'></span><span id='topic+rHYPERPO'></span><span id='topic+qHYPERPO'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the hyper-Poisson, HYPERPO(), distribution
with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHYPERPO(x, mu = 1, sigma = 1, log = FALSE)

pHYPERPO(q, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rHYPERPO(n, mu = 1, sigma = 1)

qHYPERPO(p, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dHYPERPO_+3A_x">x</code>, <code id="dHYPERPO_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_sigma">sigma</code></td>
<td>
<p>vector of the sigma parameter.</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_log">log</code>, <code id="dHYPERPO_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dHYPERPO_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\mu^x}{_1F_1(1;\mu;\sigma)}\frac{\Gamma(\sigma)}{\Gamma(x+\sigma)}</code>
</p>
<p>where the function <code class="reqn">_1F_1(a;c;z)</code> is defined as
</p>
<p><code class="reqn">_1F_1(a;c;z) = \sum_{r=0}^{\infty}\frac{(a)_r}{(c)_r}\frac{z^r}{r!}</code>
</p>
<p>and <code class="reqn">(a)_r = \frac{\gamma(a+r)}{\gamma(a)}</code> for <code class="reqn">a&gt;0</code> and <code class="reqn">r</code> positive integer.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\lambda</code> and <code class="reqn">\gamma</code>
for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> respectively, we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dHYPERPO</code> gives the density, <code>pHYPERPO</code> gives the distribution
function, <code>qHYPERPO</code> gives the quantile function, <code>rHYPERPO</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Sáez-Castillo AJ, Conde-Sánchez A (2013).
&ldquo;A hyper-Poisson regression model for overdispersed and underdispersed count data.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>61</b>, 148&ndash;157.
</p>


<h3>See Also</h3>

<p><a href="#topic+HYPERPO">HYPERPO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 30
probs1 &lt;- dHYPERPO(x=0:x_max, mu=5, sigma=0.1)
probs2 &lt;- dHYPERPO(x=0:x_max, mu=5, sigma=1.0)
probs3 &lt;- dHYPERPO(x=0:x_max, mu=5, sigma=1.8)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for hyper-Poisson",
     ylim=c(0, 0.20))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=5, sigma=0.1",
                "mu=5, sigma=1.0",
                "mu=5, sigma=1.8"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 15
cumulative_probs1 &lt;- pHYPERPO(q=0:x_max, mu=5, sigma=0.1)
cumulative_probs2 &lt;- pHYPERPO(q=0:x_max, mu=5, sigma=1.0)
cumulative_probs3 &lt;- pHYPERPO(q=0:x_max, mu=5, sigma=1.8)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for hyper-Poisson",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
legend("bottomright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=5, sigma=0.1",
                "mu=5, sigma=1.0",
                "mu=5, sigma=1.8"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dHYPERPO(x=0:x_max, mu=3, sigma=1.1)
names(probs1) &lt;- 0:x_max

x &lt;- rHYPERPO(n=1000, mu=3, sigma=1.1)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c("dodgerblue3","firebrick3"), las=1,
              xlab="X", ylab="Proportion")
legend("topright",
       legend=c("Theoretical", "Simulated"),
       bty="n", lwd=3,
       col=c("dodgerblue3","firebrick3"), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 3
sigma &lt;-3
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qHYPERPO(p=p, mu=mu, sigma=sigma,
                lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of HP(mu=3, sigma=3)")

</code></pre>

<hr>
<h2 id='dHYPERPO_single'>Function to obtain the dHYPERPO for a single value x</h2><span id='topic+dHYPERPO_single'></span>

<h3>Description</h3>

<p>Function to obtain the dHYPERPO for a single value x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHYPERPO_single(x, mu = 1, sigma = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dHYPERPO_single_+3A_x">x</code></td>
<td>
<p>numeric value for x.</p>
</td></tr>
<tr><td><code id="dHYPERPO_single_+3A_mu">mu</code></td>
<td>
<p>numeric value for nu.</p>
</td></tr>
<tr><td><code id="dHYPERPO_single_+3A_sigma">sigma</code></td>
<td>
<p>numeric value for sigma.</p>
</td></tr>
<tr><td><code id="dHYPERPO_single_+3A_log">log</code></td>
<td>
<p>logical value for log.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the pmf for a single value x.
</p>

<hr>
<h2 id='dHYPERPO_vec'>Function to obtain the dHYPERPO for a vector x</h2><span id='topic+dHYPERPO_vec'></span>

<h3>Description</h3>

<p>Function to obtain the dHYPERPO for a vector x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHYPERPO_vec(x, mu, sigma, log)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dHYPERPO_vec_+3A_x">x</code></td>
<td>
<p>numeric value for x.</p>
</td></tr>
<tr><td><code id="dHYPERPO_vec_+3A_mu">mu</code></td>
<td>
<p>numeric value for nu.</p>
</td></tr>
<tr><td><code id="dHYPERPO_vec_+3A_sigma">sigma</code></td>
<td>
<p>numeric value for sigma.</p>
</td></tr>
<tr><td><code id="dHYPERPO_vec_+3A_log">log</code></td>
<td>
<p>logical value for log.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the pmf for a vector.
</p>

<hr>
<h2 id='dHYPERPO2'>The hyper-Poisson distribution (with mu as mean)</h2><span id='topic+dHYPERPO2'></span><span id='topic+pHYPERPO2'></span><span id='topic+rHYPERPO2'></span><span id='topic+qHYPERPO2'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the hyper-Poisson in
the second parameterization with parameters <code class="reqn">\mu</code> (as mean) and
<code class="reqn">\sigma</code> as the dispersion parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHYPERPO2(x, mu = 1, sigma = 1, log = FALSE)

pHYPERPO2(q, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rHYPERPO2(n, mu = 1, sigma = 1)

qHYPERPO2(p, mu = 1, sigma = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dHYPERPO2_+3A_x">x</code>, <code id="dHYPERPO2_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_mu">mu</code></td>
<td>
<p>vector of positive values of this parameter.</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_sigma">sigma</code></td>
<td>
<p>vector of positive values of this parameter.</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_log">log</code>, <code id="dHYPERPO2_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_n">n</code></td>
<td>
<p>number of random values to return</p>
</td></tr>
<tr><td><code id="dHYPERPO2_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ...
</p>
<p>Note: in this implementation the parameter <code class="reqn">\mu</code> is the mean
of the distribution and <code class="reqn">\sigma</code> corresponds to
the dispersion parameter. If you fit a model with this parameterization,
the time will increase because an internal procedure to convert <code class="reqn">\mu</code>
to <code class="reqn">\lambda</code> parameter.
</p>


<h3>Value</h3>

<p><code>dHYPERPO2</code> gives the density, <code>pHYPERPO2</code> gives the distribution
function, <code>qHYPERPO2</code> gives the quantile function, <code>rHYPERPO2</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Sáez-Castillo AJ, Conde-Sánchez A (2013).
&ldquo;A hyper-Poisson regression model for overdispersed and underdispersed count data.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>61</b>, 148&ndash;157.
</p>


<h3>See Also</h3>

<p><a href="#topic+HYPERPO2">HYPERPO2</a>, <a href="#topic+HYPERPO">HYPERPO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 30
probs1 &lt;- dHYPERPO2(x=0:x_max, sigma=0.01, mu=3)
probs2 &lt;- dHYPERPO2(x=0:x_max, sigma=0.50, mu=5)
probs3 &lt;- dHYPERPO2(x=0:x_max, sigma=1.00, mu=7)
# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for hyper-Poisson",
     ylim=c(0, 0.30))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("sigma=0.01, mu=3",
                "sigma=0.50, mu=5",
                "sigma=1.00, mu=7"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 15
cumulative_probs1 &lt;- pHYPERPO2(q=0:x_max, mu=1, sigma=1.5)
cumulative_probs2 &lt;- pHYPERPO2(q=0:x_max, mu=3, sigma=1.5)
cumulative_probs3 &lt;- pHYPERPO2(q=0:x_max, mu=5, sigma=1.5)

plot(x=0:x_max, y=cumulative_probs1, col="dodgerblue",
     type="o", las=1, ylim=c(0, 1),
     main="Cumulative probability for hyper-Poisson",
     xlab="X", ylab="Probability")
points(x=0:x_max, y=cumulative_probs2, type="o", col="tomato")
points(x=0:x_max, y=cumulative_probs3, type="o", col="green4")
legend("bottomright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("sigma=1.5, mu=1",
                "sigma=1.5, mu=3",
                "sigma=1.5, mu=5"))

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dHYPERPO2(x=0:x_max, mu=3, sigma=1.1)
names(probs1) &lt;- 0:x_max

x &lt;- rHYPERPO2(n=1000, mu=3, sigma=1.1)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c('dodgerblue3','firebrick3'), las=1,
              xlab='X', ylab='Proportion')
legend('topright',
       legend=c('Theoretical', 'Simulated'),
       bty='n', lwd=3,
       col=c('dodgerblue3','firebrick3'), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 3
sigma &lt;-3
p &lt;- seq(from=0, to=1, by=0.01)
qxx &lt;- qHYPERPO2(p=p, mu=mu, sigma=sigma, lower.tail=TRUE, log.p=FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles of HP2(mu = sigma = 3)")

</code></pre>

<hr>
<h2 id='DIKUM'>The discrete Inverted Kumaraswamy family</h2><span id='topic+DIKUM'></span>

<h3>Description</h3>

<p>The function <code>DIKUM()</code> defines the discrete Inverted Kumaraswamy distribution, a two parameter
distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIKUM(mu.link = "log", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIKUM_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
<tr><td><code id="DIKUM_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;log&quot; link as the default for the sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete Inverted Kumaraswamy distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = (1-(2+x)^{-\mu})^{\sigma}-(1-(1+x)^{-\mu})^{\sigma}</code>
</p>
<p>with <code class="reqn">\mu &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> respectively, we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a discrete Inverted Kumaraswamy distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Daniel Felipe Villa Rengifo, <a href="mailto:dvilla@unal.edu.co">dvilla@unal.edu.co</a>
</p>


<h3>References</h3>

<p>EL-Helbawy AA, Hegazy MA, AL-Dayian GR, Abd EL-Kader RE (2022).
&ldquo;A Discrete Analog of the Inverted Kumaraswamy Distribution: Properties and Estimation with Application to COVID-19 Data.&rdquo;
<em>Pakistan Journal of Statistics &amp; Operation Research</em>, <b>18</b>(1).
</p>


<h3>See Also</h3>

<p><a href="#topic+dDIKUM">dDIKUM</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(150)
y &lt;- rDIKUM(1000, mu=1, sigma=5)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y ~ 1, sigma.fo = ~1, family=DIKUM,
               control = gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
exp(coef(mod1, what='mu'))
exp(coef(mod1, what='sigma'))

# Example 2
# Generating random values under some model

library(gamlss)

# A function to simulate a data set with Y ~ DIKUM
gendat &lt;- function(n) {
  x1 &lt;- runif(n, min=0.4, max=0.6)
  x2 &lt;- runif(n, min=0.4, max=0.6)
  mu    &lt;- exp(1.21 - 3 * x1) # 0.75 approximately
  sigma &lt;- exp(1.26 - 2 * x2) # 1.30 approximately
  y &lt;- rDIKUM(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1, x2=x2)
}

dat &lt;- gendat(n=150)

# Fitting the model
mod2 &lt;- gamlss(y ~ x1, sigma.fo = ~x2, family = "DIKUM", data=dat,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)
</code></pre>

<hr>
<h2 id='DLD'>The Discrete Lindley family</h2><span id='topic+DLD'></span>

<h3>Description</h3>

<p>The function <code>DLD()</code> defines the Discrete Lindley distribution, one-parameter
discrete distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLD(mu.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLD_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Lindley distribution with parameters <code class="reqn">\mu &gt; 0</code> has a support
0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu) = \frac{e^{-\mu x}}{1 + \mu}  (\mu(1 - 2e^{-\mu}) + (1- e^{-\mu})(1+\mu x))</code>
</p>
<p>The parameter <code class="reqn">\mu</code> can be interpreted as a strict upper bound on the failure rate function
</p>
<p>The conventional discrete distributions (such as geometric, Poisson, etc.) are not
suitable for various scenarios like reliability, failure times, and counts. Consequently,
alternative discrete distributions have been created by adapting well-known continuous
models for reliability and failure times. Among these, the discrete Weibull distribution
stands out as the most widely used. But models like these require two parameters and not many
of the known discrete distributions can provide accurate models for both times and counts,
which the Discrete Lindley distribution does.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\theta</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a Discrete Lindley distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Yojan Andrés Alcaraz Pérez, <a href="mailto:yalcaraz@unal.edu.co">yalcaraz@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Bakouch HS, Jazi MA, Nadarajah S (2014).
&ldquo;A new discrete distribution.&rdquo;
<em>Statistics</em>, <b>48</b>(1), 200&ndash;240.
</p>


<h3>See Also</h3>

<p><a href="#topic+dDLD">dDLD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu
y &lt;- rDLD(n=100, mu=0.3)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, family=DLD,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu
# using the inverse link function
exp(coef(mod1, what='mu'))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ DLD
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  mu    &lt;- exp(2 - 4 * x1)
  y &lt;- rDLD(n=n, mu=mu)
  data.frame(y=y, x1=x1)
}

set.seed(1235)
datos &lt;- gendat(n=150)

mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=DLD, data=datos,
                 control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)
</code></pre>

<hr>
<h2 id='DMOLBE'>The DMOLBE family</h2><span id='topic+DMOLBE'></span>

<h3>Description</h3>

<p>The function <code>DMOLBE()</code> defines the Discrete Marshall-Olkin Length Biased
Exponential distribution, a two parameter
distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DMOLBE(mu.link = "log", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DMOLBE_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
<tr><td><code id="DMOLBE_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;log&quot; link as the default for the sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DMOLBE distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\sigma ((1+x/\mu)\exp(-x/\mu)-(1+(x+1)/\mu)\exp(-(x+1)/\mu))}{(1-(1-\sigma)(1+x/\mu)\exp(-x/\mu)) ((1-(1-\sigma)(1+(x+1)/\mu)\exp(-(x+1)/\mu))}</code>
</p>
<p>with <code class="reqn">\mu &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a DMOLBE distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Olga Usuga, <a href="mailto:olga.usuga@udea.edu.co">olga.usuga@udea.edu.co</a>
</p>


<h3>References</h3>

<p>Aljohani HM, Ahsan-ul-Haq M, Zafar J, Almetwally EM, Alghamdi AS, Hussam E, Muse AH (2023).
&ldquo;Analysis of Covid-19 data using discrete Marshall-Olkinin Length Biased Exponential: Bayesian and frequentist approach.&rdquo;
<em>Scientific Reports</em>, <b>13</b>(1), 12243.
</p>


<h3>See Also</h3>

<p><a href="#topic+dDMOLBE">dDMOLBE</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(1234)
y &lt;- rDMOLBE(n=100, mu=10, sigma=7)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, sigma.fo=~1, family=DMOLBE,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
exp(coef(mod1, what='mu'))
exp(coef(mod1, what='sigma'))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ DMOLBE
gendat &lt;- function(n) {
  x1 &lt;- runif(n, min=0.4, max=0.6)
  x2 &lt;- runif(n, min=0.4, max=0.6)
  mu    &lt;- exp(1.21 - 3 * x1) # 0.75 approximately
  sigma &lt;- exp(1.26 - 2 * x2) # 1.30 approximately
  y &lt;- rDMOLBE(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1,x2=x2)
}

set.seed(123)
dat &lt;- gendat(n=350)

# Fitting the model
mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=DMOLBE, data=dat,
                 control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)
</code></pre>

<hr>
<h2 id='dPOISXL'>The Discrete Poisson XLindley</h2><span id='topic+dPOISXL'></span><span id='topic+pPOISXL'></span><span id='topic+qPOISXL'></span><span id='topic+rPOISXL'></span>

<h3>Description</h3>

<p>These functions define the density, distribution function, quantile
function and random generation for the Discrete Poisson XLindley distribution
with parameter <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dPOISXL(x, mu = 0.3, log = FALSE)

pPOISXL(q, mu = 0.3, lower.tail = TRUE, log.p = FALSE)

qPOISXL(p, mu = 0.3, lower.tail = TRUE, log.p = FALSE)

rPOISXL(n, mu = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dPOISXL_+3A_x">x</code>, <code id="dPOISXL_+3A_q">q</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dPOISXL_+3A_mu">mu</code></td>
<td>
<p>vector of the mu parameter.</p>
</td></tr>
<tr><td><code id="dPOISXL_+3A_log">log</code>, <code id="dPOISXL_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dPOISXL_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code>P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dPOISXL_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dPOISXL_+3A_n">n</code></td>
<td>
<p>number of random values to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Poisson XLindley distribution with parameters <code class="reqn">\mu</code> has a support
0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu) = \frac{\mu^2(x+\mu^2+3(1+\mu))}{(1+\mu)^{4+x}}</code>; with <code class="reqn">\mu&gt;0</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\alpha</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p><code>dPOISXL</code> gives the density, <code>pPOISXL</code> gives the distribution
function, <code>qPOISXL</code> gives the quantile function, <code>rPOISXL</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Mariana Blandon Mejia, <a href="mailto:mblandonm@unal.edu.co">mblandonm@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Ahsan-ul-Haq M, Al-Bossly A, El-Morshedy M, Eliwa MS, others (2022).
&ldquo;Poisson XLindley distribution for count data: statistical and reliability properties with estimation techniques and inference.&rdquo;
<em>Computational Intelligence and Neuroscience</em>, <b>2022</b>.
</p>


<h3>See Also</h3>

<p><a href="#topic+POISXL">POISXL</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Plotting the mass function for different parameter values

x_max &lt;- 20
probs1 &lt;- dPOISXL(x=0:x_max, mu=0.2)
probs2 &lt;- dPOISXL(x=0:x_max, mu=0.5)
probs3 &lt;- dPOISXL(x=0:x_max, mu=1.0)

# To plot the first k values
plot(x=0:x_max, y=probs1, type="o", lwd=2, col="dodgerblue", las=1,
     ylab="P(X=x)", xlab="X", main="Probability for Poisson XLindley",
     ylim=c(0, 0.50))
points(x=0:x_max, y=probs2, type="o", lwd=2, col="tomato")
points(x=0:x_max, y=probs3, type="o", lwd=2, col="green4")
legend("topright", col=c("dodgerblue", "tomato", "green4"), lwd=3,
       legend=c("mu=0.2", "mu=0.5", "mu=1.0"))

# Example 2
# Checking if the cumulative curves converge to 1

x_max &lt;- 20

plot_discrete_cdf(x=0:x_max,
                  fx=dPOISXL(x=0:x_max, mu=0.2), col="dodgerblue",
                  main="CDF for Poisson XLindley with mu=0.2")

plot_discrete_cdf(x=0:x_max,
                  fx=dPOISXL(x=0:x_max, mu=0.5), col="tomato",
                  main="CDF for Poisson XLindley with mu=0.5")

plot_discrete_cdf(x=0:x_max,
                  fx=dPOISXL(x=0:x_max, mu=1.0), col="green4",
                  main="CDF for Poisson XLindley with mu=1.0")

# Example 3
# Comparing the random generator output with
# the theoretical probabilities

x_max &lt;- 15
probs1 &lt;- dPOISXL(x=0:x_max, mu=0.3)
names(probs1) &lt;- 0:x_max

x &lt;- rPOISXL(n=3000, mu=0.3)
probs2 &lt;- prop.table(table(x))

cn &lt;- union(names(probs1), names(probs2))
height &lt;- rbind(probs1[cn], probs2[cn])
nombres &lt;- cn
mp &lt;- barplot(height, beside = TRUE, names.arg = nombres,
              col=c("dodgerblue3","firebrick3"), las=1,
              xlab="X", ylab="Proportion")
legend("topright",
       legend=c("Theoretical", "Simulated"),
       bty="n", lwd=3,
       col=c("dodgerblue3","firebrick3"), lty=1)

# Example 4
# Checking the quantile function

mu &lt;- 0.3
p &lt;- seq(from=0, to=1, by = 0.01)
qxx &lt;- qPOISXL(p, mu, lower.tail = TRUE, log.p = FALSE)
plot(p, qxx, type="s", lwd=2, col="green3", ylab="quantiles",
     main="Quantiles for Poisson XLindley mu=0.3")
</code></pre>

<hr>
<h2 id='estim_mu_DBH'>Initial values for Discrete Burr Hatke</h2><span id='topic+estim_mu_DBH'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameter mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_DBH(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_DBH_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a scalar with the MLE estimation.
</p>

<hr>
<h2 id='estim_mu_DLD'>Initial values for Discrete Lindley</h2><span id='topic+estim_mu_DLD'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameter mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_DLD(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_DLD_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a scalar with the MLE estimation.
</p>

<hr>
<h2 id='estim_mu_POISXL'>Initial values for discrete Poisson XLindley distribution</h2><span id='topic+estim_mu_POISXL'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_POISXL(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_POISXL_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a scalar with the MLE estimation.
</p>

<hr>
<h2 id='estim_mu_sigma_DGEII'>Initial values for DGEII</h2><span id='topic+estim_mu_sigma_DGEII'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_DGEII(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_DGEII_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='estim_mu_sigma_DIKUM'>Initial values for discrete Inverted Kumaraswamy</h2><span id='topic+estim_mu_sigma_DIKUM'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_DIKUM(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_DIKUM_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='estim_mu_sigma_DMOLBE'>Initial values for DMOLBE</h2><span id='topic+estim_mu_sigma_DMOLBE'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_DMOLBE(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_DMOLBE_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='estim_mu_sigma_GGEO'>Initial values for GGEO</h2><span id='topic+estim_mu_sigma_GGEO'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_GGEO(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_GGEO_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='estim_mu_sigma_HYPERPO'>Initial values for hyper Poisson</h2><span id='topic+estim_mu_sigma_HYPERPO'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_HYPERPO(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_HYPERPO_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='estim_mu_sigma_HYPERPO2'>Initial values for hyper Poisson in second parameterization</h2><span id='topic+estim_mu_sigma_HYPERPO2'></span>

<h3>Description</h3>

<p>This function generates initial values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_mu_sigma_HYPERPO2(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_mu_sigma_HYPERPO2_+3A_y">y</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the MLE estimations.
</p>

<hr>
<h2 id='F11'>Auxiliar function for hyper Poisson</h2><span id='topic+F11'></span>

<h3>Description</h3>

<p>This function is used inside density function of Hyper Poisson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F11(z, c, maxiter_series = 10000, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F11_+3A_z">z</code>, <code id="F11_+3A_c">c</code></td>
<td>
<p>values for F11.</p>
</td></tr>
<tr><td><code id="F11_+3A_maxiter_series">maxiter_series</code></td>
<td>
<p>maximum value to obtain F11.</p>
</td></tr>
<tr><td><code id="F11_+3A_tol">tol</code></td>
<td>
<p>this is the tolerance of the infinite sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value for the F11 function.
</p>

<hr>
<h2 id='f11_cpp'>Function to obtain F11 with C++.</h2><span id='topic+f11_cpp'></span>

<h3>Description</h3>

<p>Function to obtain F11 with C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f11_cpp(gamma, lambda, maxiter_series = 10000L, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f11_cpp_+3A_gamma">gamma</code></td>
<td>
<p>numeric value for gamma.</p>
</td></tr>
<tr><td><code id="f11_cpp_+3A_lambda">lambda</code></td>
<td>
<p>numeric value for lambda.</p>
</td></tr>
<tr><td><code id="f11_cpp_+3A_maxiter_series">maxiter_series</code></td>
<td>
<p>numeric value.</p>
</td></tr>
<tr><td><code id="f11_cpp_+3A_tol">tol</code></td>
<td>
<p>numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the F11 value.
</p>

<hr>
<h2 id='GGEO'>The GGEO family</h2><span id='topic+GGEO'></span>

<h3>Description</h3>

<p>The function <code>GGEO()</code> defines the Generalized Geometric distribution,
a two parameter distribution,
for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGEO(mu.link = "logit", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GGEO_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
<tr><td><code id="GGEO_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;logit&quot; link as the default for the sigma. Other links are &quot;probit&quot; and &quot;cloglog&quot;'(complementary log-log)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GGEO distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\sigma \mu^x (1-\mu)}{(1-(1-\sigma) \mu^{x+1})(1-(1-\sigma) \mu^{x})}</code>
</p>
<p>with <code class="reqn">0 &lt; \mu &lt; 1</code> and <code class="reqn">\sigma &gt; 0</code>. If <code class="reqn">\sigma=1</code>, the GGEO distribution
reduces to the geometric distribution with success probability <code class="reqn">1-\mu</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a GGEO distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Valentina Hurtado Sepúlveda, <a href="mailto:vhurtados@unal.edu.co">vhurtados@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Gómez-Déniz E (2010).
&ldquo;Another generalization of the geometric distribution.&rdquo;
<em>Test</em>, <b>19</b>, 399-415.
</p>


<h3>See Also</h3>

<p><a href="#topic+dGGEO">dGGEO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(123)
y &lt;- rGGEO(n=200, mu=0.95, sigma=1.5)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, family=GGEO,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
inv_logit &lt;- function(x) 1/(1 + exp(-x))

inv_logit(coef(mod1, what="mu"))
exp(coef(mod1, what="sigma"))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ GGEO
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  mu    &lt;- inv_logit(1.7 - 2.8*x1)
  sigma &lt;- exp(0.73 + 1*x2)
  y &lt;- rGGEO(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1, x2=x2)
}

set.seed(78353)
datos &lt;- gendat(n=100)

mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=GGEO, data=datos,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)

# Example 3
# Number of accidents to 647 women working on H. E. Shells
# for 5 weeks. Taken from Gomez-Deniz (2010) page 411.

y &lt;- rep(x=0:5, times=c(447, 132, 42, 21, 3, 2))

mod3 &lt;- gamlss(y~1, family=GGEO,
               control=gamlss.control(n.cyc=500, trace=TRUE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
inv_logit &lt;- function(x) 1/(1 + exp(-x))

inv_logit(coef(mod3, what="mu"))
exp(coef(mod3, what="sigma"))
</code></pre>

<hr>
<h2 id='HYPERPO'>The hyper Poisson family</h2><span id='topic+HYPERPO'></span>

<h3>Description</h3>

<p>The function <code>HYPERPO()</code> defines the hyper Poisson distribution, a two parameter
distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HYPERPO(mu.link = "log", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HYPERPO_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
<tr><td><code id="HYPERPO_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;log&quot; link as the default for the sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\mu^x}{_1F_1(1;\mu;\sigma)}\frac{\Gamma(\sigma)}{\Gamma(x+\sigma)}</code>
</p>
<p>where the function <code class="reqn">_1F_1(a;c;z)</code> is defined as
</p>
<p><code class="reqn">_1F_1(a;c;z) = \sum_{r=0}^{\infty}\frac{(a)_r}{(c)_r}\frac{z^r}{r!}</code>
</p>
<p>and <code class="reqn">(a)_r = \frac{\gamma(a+r)}{\gamma(a)}</code> for <code class="reqn">a&gt;0</code> and <code class="reqn">r</code> positive integer.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\lambda</code> and <code class="reqn">\gamma</code>
for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> respectively, we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a hyper-Poisson distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Sáez-Castillo AJ, Conde-Sánchez A (2013).
&ldquo;A hyper-Poisson regression model for overdispersed and underdispersed count data.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>61</b>, 148&ndash;157.
</p>


<h3>See Also</h3>

<p><a href="#topic+dHYPERPO">dHYPERPO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(1234)
y &lt;- rHYPERPO(n=200, mu=10, sigma=1.5)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, sigma.fo=~1, family=HYPERPO,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
exp(coef(mod1, what="mu"))
exp(coef(mod1, what="sigma"))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ HYPERPO
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  mu    &lt;- exp(1.21 - 3 * x1) # 0.75 approximately
  sigma &lt;- exp(1.26 - 2 * x2) # 1.30 approximately
  y &lt;- rHYPERPO(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1, x2=x2)
}

set.seed(1235)
datos &lt;- gendat(n=150)

mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=HYPERPO, data=datos,
                 control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)
</code></pre>

<hr>
<h2 id='HYPERPO2'>The hyper Poisson family (with mu as mean)</h2><span id='topic+HYPERPO2'></span>

<h3>Description</h3>

<p>The function <code>HYPERPO2()</code> defines the hyper Poisson distribution, a two parameter
distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HYPERPO2(mu.link = "log", sigma.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HYPERPO2_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
<tr><td><code id="HYPERPO2_+3A_sigma.link">sigma.link</code></td>
<td>
<p>defines the sigma.link, with &quot;log&quot; link as the default for the sigma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ...
</p>
<p>Note: in this implementation the parameter <code class="reqn">\mu</code> is the mean
of the distribution and <code class="reqn">\sigma</code> corresponds to
the dispersion parameter. If you fit a model with this parameterization,
the time will increase because an internal procedure to convert <code class="reqn">\mu</code>
to <code class="reqn">\lambda</code> parameter.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a hyper-Poisson distribution version 2
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Sáez-Castillo AJ, Conde-Sánchez A (2013).
&ldquo;A hyper-Poisson regression model for overdispersed and underdispersed count data.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>61</b>, 148&ndash;157.
</p>


<h3>See Also</h3>

<p><a href="#topic+dHYPERPO2">dHYPERPO2</a>, <a href="#topic+HYPERPO">HYPERPO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu and sigma
set.seed(1234)
y &lt;- rHYPERPO2(n=200, mu=3, sigma=0.5)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, sigma.fo=~1, family=HYPERPO2,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu and sigma
# using the inverse link function
exp(coef(mod1, what='mu'))
exp(coef(mod1, what='sigma'))

# Example 2
# Generating random values under some model


# A function to simulate a data set with Y ~ HYPERPO2
gendat &lt;- function(n) {
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  mu    &lt;- exp(1.21 - 3 * x1) # 0.75 approximately
  sigma &lt;- exp(1.26 - 2 * x2) # 1.30 approximately
  y &lt;- rHYPERPO2(n=n, mu=mu, sigma=sigma)
  data.frame(y=y, x1=x1, x2=x2)
}

set.seed(1234)
datos &lt;- gendat(n=500)

mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, sigma.fo=~x2, family=HYPERPO2, data=datos,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)

</code></pre>

<hr>
<h2 id='logLik_DBH'>logLik function for Discrete Burr Hatke</h2><span id='topic+logLik_DBH'></span>

<h3>Description</h3>

<p>Calculates logLik for Discrete Burr Hatke  distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_DBH(param = 0.5, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_DBH_+3A_param">param</code></td>
<td>
<p>value for mu.</p>
</td></tr>
<tr><td><code id="logLik_DBH_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_DGEII'>logLik function for DGEII</h2><span id='topic+logLik_DGEII'></span>

<h3>Description</h3>

<p>Calculates logLik for DGEII distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_DGEII(transf_param = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_DGEII_+3A_transf_param">transf_param</code></td>
<td>
<p>vector with parameters in log and logit scale.</p>
</td></tr>
<tr><td><code id="logLik_DGEII_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_DIKUM'>logLik function for discrete Inverted Kumaraswamy</h2><span id='topic+logLik_DIKUM'></span>

<h3>Description</h3>

<p>Calculates logLik for discrete Inverted Kumaraswamy distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_DIKUM(param = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_DIKUM_+3A_param">param</code></td>
<td>
<p>vector with parameters in log scale.</p>
</td></tr>
<tr><td><code id="logLik_DIKUM_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_DLD'>logLik function for Discrete Lindley distribution</h2><span id='topic+logLik_DLD'></span>

<h3>Description</h3>

<p>Calculates logLik for Discrete Lindley  distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_DLD(param = 0.5, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_DLD_+3A_param">param</code></td>
<td>
<p>value for mu.</p>
</td></tr>
<tr><td><code id="logLik_DLD_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_DMOLBE'>logLik function for DMOLBE</h2><span id='topic+logLik_DMOLBE'></span>

<h3>Description</h3>

<p>Calculates logLik for DMOLBE distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_DMOLBE(logparam = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_DMOLBE_+3A_logparam">logparam</code></td>
<td>
<p>vector with parameters in log scale.</p>
</td></tr>
<tr><td><code id="logLik_DMOLBE_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_GGEO'>logLik function for GGEO</h2><span id='topic+logLik_GGEO'></span>

<h3>Description</h3>

<p>Calculates logLik for GGEO distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_GGEO(param = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_GGEO_+3A_param">param</code></td>
<td>
<p>vector with parameters in log and logit scale.</p>
</td></tr>
<tr><td><code id="logLik_GGEO_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_HYPERPO'>logLik function for hyper Poisson</h2><span id='topic+logLik_HYPERPO'></span>

<h3>Description</h3>

<p>Calculates logLik for hyper Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_HYPERPO(logparam = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_HYPERPO_+3A_logparam">logparam</code></td>
<td>
<p>vector with parameters in log scale.</p>
</td></tr>
<tr><td><code id="logLik_HYPERPO_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_HYPERPO2'>logLik function for hyper Poisson in second parameterization</h2><span id='topic+logLik_HYPERPO2'></span>

<h3>Description</h3>

<p>Calculates logLik for hyper Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_HYPERPO2(logparam = c(0, 0), x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_HYPERPO2_+3A_logparam">logparam</code></td>
<td>
<p>vector with parameters in log scale.</p>
</td></tr>
<tr><td><code id="logLik_HYPERPO2_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='logLik_POISXL'>logLik function for Poisson XLindley distribution</h2><span id='topic+logLik_POISXL'></span>

<h3>Description</h3>

<p>Calculates logLik for Poisson XLindley distribution distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik_POISXL(param = 0, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_POISXL_+3A_param">param</code></td>
<td>
<p>parameter mu in log scale.</p>
</td></tr>
<tr><td><code id="logLik_POISXL_+3A_x">x</code></td>
<td>
<p>vector with the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the loglikelihood given the parameters and random sample.
</p>

<hr>
<h2 id='mean_var_hp'>Mean and variance for hyper-Poisson distribution</h2><span id='topic+mean_var_hp'></span><span id='topic+mean_var_hp2'></span>

<h3>Description</h3>

<p>This function calculates the mean and variance for the
hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_var_hp(mu, sigma)

mean_var_hp2(mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_var_hp_+3A_mu">mu</code></td>
<td>
<p>value of the mu parameter.</p>
</td></tr>
<tr><td><code id="mean_var_hp_+3A_sigma">sigma</code></td>
<td>
<p>value of the sigma parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hyper-Poisson distribution with parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
has a support 0, 1, 2, ... and density given by
</p>
<p><code class="reqn">f(x | \mu, \sigma) = \frac{\mu^x}{_1F_1(1;\mu;\sigma)}\frac{\Gamma(\sigma)}{\Gamma(x+\sigma)}</code>
</p>
<p>where the function <code class="reqn">_1F_1(a;c;z)</code> is defined as
</p>
<p><code class="reqn">_1F_1(a;c;z) = \sum_{r=0}^{\infty}\frac{(a)_r}{(c)_r}\frac{z^r}{r!}</code>
</p>
<p>and <code class="reqn">(a)_r = \frac{\gamma(a+r)}{\gamma(a)}</code> for <code class="reqn">a&gt;0</code> and <code class="reqn">r</code> positive integer.
</p>
<p>This function calculates the mean and variance of this distribution.
</p>


<h3>Value</h3>

<p>the function returns a list with the mean and variance.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Sáez-Castillo AJ, Conde-Sánchez A (2013).
&ldquo;A hyper-Poisson regression model for overdispersed and underdispersed count data.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>61</b>, 148&ndash;157.
</p>


<h3>See Also</h3>

<p><a href="#topic+HYPERPO">HYPERPO</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

# Theoretical values
mean_var_hp(mu=5.5, sigma=0.1)

# Using simulated values
y &lt;- rHYPERPO(n=1000, mu=5.5, sigma=0.1)
mean(y)
var(y)


# Example 2

# Theoretical values
mean_var_hp2(mu=5.5, sigma=1.9)

# Using simulated values
y &lt;- rHYPERPO2(n=1000, mu=5.5, sigma=1.9)
mean(y)
var(y)
</code></pre>

<hr>
<h2 id='obtaining_lambda'>Auxiliar function to obtain lambda from E(X)</h2><span id='topic+obtaining_lambda'></span>

<h3>Description</h3>

<p>This function implements the procedure given in page 150.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtaining_lambda(media, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtaining_lambda_+3A_media">media</code></td>
<td>
<p>the value for the mean or E(X).</p>
</td></tr>
<tr><td><code id="obtaining_lambda_+3A_gamma">gamma</code></td>
<td>
<p>the value for the gamma parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value of lambda to ensure the mean and gamma.
</p>

<hr>
<h2 id='plot_discrete_cdf'>Draw the CDF for a discrete random variable</h2><span id='topic+plot_discrete_cdf'></span>

<h3>Description</h3>

<p>Draw the CDF for a discrete random variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_discrete_cdf(x, fx, col = "blue", lwd = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_discrete_cdf_+3A_x">x</code></td>
<td>
<p>vector with the values of the random variable <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="plot_discrete_cdf_+3A_fx">fx</code></td>
<td>
<p>vector with the probabilities of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="plot_discrete_cdf_+3A_col">col</code></td>
<td>
<p>color for the line.</p>
</td></tr>
<tr><td><code id="plot_discrete_cdf_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot_discrete_cdf_+3A_...">...</code></td>
<td>
<p>further arguments and graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the cumulative distribution function.
</p>


<h3>Author(s)</h3>

<p>Freddy Hernandez, <a href="mailto:fhernanb@unal.edu.co">fhernanb@unal.edu.co</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# for a particular distribution

x &lt;- 1:6
fx &lt;- c(0.19, 0.21, 0.4, 0.12, 0.05, 0.03)
plot_discrete_cdf(x, fx, las=1, main="")

# Example 2
# for a Poisson distribution
x &lt;- 0:10
fx &lt;- dpois(x, lambda=3)
plot_discrete_cdf(x, fx, las=1,
                  main="CDF for Poisson")
</code></pre>

<hr>
<h2 id='POISXL'>The Discrete Poisson XLindley</h2><span id='topic+POISXL'></span>

<h3>Description</h3>

<p>The function <code>POISXL()</code> defines  the Discrete Poisson XLindley distribution, one-parameter
discrete distribution, for a <code>gamlss.family</code> object to be used in GAMLSS fitting
using the function <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POISXL(mu.link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="POISXL_+3A_mu.link">mu.link</code></td>
<td>
<p>defines the mu.link, with &quot;log&quot; link as the default for the mu parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discrete Poisson XLindley distribution with parameters <code class="reqn">\mu</code> has a support
0, 1, 2, ... and mass function given by
</p>
<p><code class="reqn">f(x | \mu) = \frac{\mu^2(x+\mu^2+3(1+\mu))}{(1+\mu)^{4+x}}</code>; with <code class="reqn">\mu&gt;0</code>.
</p>
<p>Note: in this implementation we changed the original parameters <code class="reqn">\alpha</code> for <code class="reqn">\mu</code>,
we did it to implement this distribution within gamlss framework.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss.family</code> object which can be used
to fit a Discrete Poisson XLindley distribution
in the <code>gamlss()</code> function.
</p>


<h3>Author(s)</h3>

<p>Mariana Blandon Mejia, <a href="mailto:mblandonm@unal.edu.co">mblandonm@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Ahsan-ul-Haq M, Al-Bossly A, El-Morshedy M, Eliwa MS, others (2022).
&ldquo;Poisson XLindley distribution for count data: statistical and reliability properties with estimation techniques and inference.&rdquo;
<em>Computational Intelligence and Neuroscience</em>, <b>2022</b>.
</p>


<h3>See Also</h3>

<p><a href="#topic+dPOISXL">dPOISXL</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generating some random values with
# known mu
y &lt;- rPOISXL(n=1000, mu=1)

# Fitting the model
library(gamlss)
mod1 &lt;- gamlss(y~1, family=POISXL,
               control=gamlss.control(n.cyc=500, trace=FALSE))

# Extracting the fitted values for mu
# using the inverse link function
exp(coef(mod1, what='mu'))

# Example 2
# Generating random values under some model

# A function to simulate a data set with Y ~ POISXL
gendat &lt;- function(n) {
  x1 &lt;- runif(n, min=0.4, max=0.6)
  mu &lt;- exp(1.21 - 3 * x1) # 0.75 approximately
  y &lt;- rPOISXL(n=n, mu=mu)
  data.frame(y=y, x1=x1)
}

dat &lt;- gendat(n=1500)

# Fitting the model
mod2 &lt;- NULL
mod2 &lt;- gamlss(y~x1, family=POISXL, data=dat,
               control=gamlss.control(n.cyc=500, trace=FALSE))

summary(mod2)
</code></pre>

<hr>
<h2 id='simulate_hp'>The simulate_hp</h2><span id='topic+simulate_hp'></span>

<h3>Description</h3>

<p>Auxiliar function to generate a single observation for HYPERPO.
</p>
<p>This function is used inside random function of Hyper Poisson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hp(sigma, mu)

simulate_hp(sigma, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_hp_+3A_sigma">sigma</code></td>
<td>
<p>value for sigma parameter.</p>
</td></tr>
<tr><td><code id="simulate_hp_+3A_mu">mu</code></td>
<td>
<p>value for mu parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single value for the HYPERPO distribution.
</p>

<hr>
<h2 id='stopping'>Auxiliar function for F11</h2><span id='topic+stopping'></span>

<h3>Description</h3>

<p>This function is used inside F11 function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopping(x, tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stopping_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="stopping_+3A_tol">tol</code></td>
<td>
<p>this is the tolerance of the infinite sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a logical value if the tolerance level is met.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
