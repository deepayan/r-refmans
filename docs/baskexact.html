<!DOCTYPE html><html lang="en"><head><title>Help for package baskexact</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baskexact}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust_lambda'><p>Adjust Lambda</p></a></li>
<li><a href='#basket_test'><p>Test for the Results of a Basket Trial</p></a></li>
<li><a href='#check_mon_between'><p>Check Between-Trial Monotonicity</p></a></li>
<li><a href='#check_mon_within'><p>Check Within-Trial Monotonicity</p></a></li>
<li><a href='#ecd'><p>Expected number of correct decisions</p></a></li>
<li><a href='#ess'><p>Expected Sample Size</p></a></li>
<li><a href='#estim'><p>Posterior Mean and Mean Squared Error</p></a></li>
<li><a href='#get_scenarios'><p>Create a Scenario Matrix</p></a></li>
<li><a href='#globalweights_diff'><p>Global Weights Based on Response Rate Differences</p></a></li>
<li><a href='#globalweights_fix'><p>Fixed Global Weights</p></a></li>
<li><a href='#interim_posterior'><p>Interim analysis based on the posterior probability</p></a></li>
<li><a href='#interim_postpred'><p>Interim analysis based on the posterior predictive probability</p></a></li>
<li><a href='#OneStageBasket-class'><p>Class OneStageBasket</p></a></li>
<li><a href='#opt_design'><p>Optimize a Basket Design</p></a></li>
<li><a href='#plot_weights'><p>Plot Weight Functions</p></a></li>
<li><a href='#pow'><p>Power</p></a></li>
<li><a href='#setupOneStageBasket'><p>Setup OneStageBasket</p></a></li>
<li><a href='#setupTwoStageBasket'><p>Setup TwoStageBasket</p></a></li>
<li><a href='#toer'><p>Type 1 Error Rate</p></a></li>
<li><a href='#TwoStageBasket-class'><p>Class TwoStageBasket</p></a></li>
<li><a href='#weights_cpp'><p>Weights Based on the Calibrated Power Prior</p></a></li>
<li><a href='#weights_fujikawa'><p>Weights Based on Fujikawa et al.'s Design</p></a></li>
<li><a href='#weights_jsd'><p>Weights Based on the Jensen-Shannon Divergence</p></a></li>
<li><a href='#weights_mml'><p>Weights Based on the Marginal Maximum Likelihood</p></a></li>
<li><a href='#weights_pool'><p>Pooled Analysis</p></a></li>
<li><a href='#weights_separate'><p>Separate Analysis in Each Basket</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analytical Calculation of Basket Trial Operating Characteristics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Analytically calculates the operating characteristics of
    single-stage and two-stage basket trials with equal sample sizes using the
	power prior design by Baumann et al. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2309.06988">doi:10.48550/arXiv.2309.06988</a>&gt;
	and the design by Fujikawa et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fbimj.201800404">doi:10.1002/bimj.201800404</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lbau7/baskexact">https://github.com/lbau7/baskexact</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>arrangements, doFuture, extraDistr, foreach, ggplot2, methods,
Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, progressr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'class.R' 'adjust_lambda.R' 'analysis.R'
'basket_test.R' 'baskexact-package.R' 'borrowing.R' 'check.R'
'ecd.R' 'ess.R' 'estim.R' 'globalweights.R' 'helper.R'
'interim.R' 'monotonicity.R' 'opt_design.R' 'plot.R' 'pow.R'
'rejection_probabilities.R' 'toer.R' 'validate.R' 'weights.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-09 13:09:54 UTC; uy240</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Baumann <a href="https://orcid.org/0000-0001-7931-7470"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Baumann &lt;baumann@imbi.uni-heidelberg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-09 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust_lambda'>Adjust Lambda</h2><span id='topic+adjust_lambda'></span><span id='topic+adjust_lambda+2COneStageBasket-method'></span><span id='topic+adjust_lambda+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Finds the value for <code>lambda</code> such that the family wise error
rate is protected at level <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_lambda(design, ...)

## S4 method for signature 'OneStageBasket'
adjust_lambda(
  design,
  alpha = 0.025,
  p1 = NULL,
  n,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  prec_digits,
  ...
)

## S4 method for signature 'TwoStageBasket'
adjust_lambda(
  design,
  alpha = 0.025,
  p1 = NULL,
  n,
  n1,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  prec_digits,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_lambda_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_alpha">alpha</code></td>
<td>
<p>The one-sided signifance level.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets. If <code>is.null(p1)</code> then the type 1 error rate under the
global null hypothesis is computed.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_prec_digits">prec_digits</code></td>
<td>
<p>Number of decimal places that are considered when
adjusting lambda.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="adjust_lambda_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adjust_alpha</code> finds the greatest value with
<code>prec_digits</code> for <code>lambda</code> which controls the family wise error
rate at level <code>alpha</code> (one-sided). A combination of the uniroot
function followed by a grid search is used to finde the correct value
for <code>lambda</code>.
</p>


<h3>Value</h3>

<p>The greatest value with <code>prec_digits</code> decimal places for
<code>lambda</code> which controls the family wise error rate at level
<code>alpha</code> (one-sided) and the exact family wise error rate for this
value of <code>lambda</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>adjust_lambda(OneStageBasket)</code>: Adjust lambda for a single-stage design.
</p>
</li>
<li> <p><code>adjust_lambda(TwoStageBasket)</code>: Adjust lambda for a two-stage design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, shape1 = 1, shape2 = 1, p0 = 0.2)
adjust_lambda(design = design, alpha = 0.025, n = 15,
  weight_fun = weights_fujikawa, prec_digits = 4)
</code></pre>

<hr>
<h2 id='basket_test'>Test for the Results of a Basket Trial</h2><span id='topic+basket_test'></span><span id='topic+basket_test+2COneStageBasket-method'></span>

<h3>Description</h3>

<p><code>basket_test</code> evaluates the results of a basket trial and calculates
the posterior distributions with and without borrowing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basket_test(design, ...)

## S4 method for signature 'OneStageBasket'
basket_test(
  design,
  n,
  r,
  lambda,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  details = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basket_test_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_r">r</code></td>
<td>
<p>The vector of observed responses.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="basket_test_+3A_details">details</code></td>
<td>
<p>Whether a detailed list of results or only the vector
of posterior probabilities is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>details = TRUE</code>: A list, including matrices of the weights
that are used for borrowing, posterior distribution parameters for all
baskets without and with borrowing, as well as the posterior probabilities
for all baskets without and with borrowing. If <code>details = FALSE</code>:
The posterior probabilities for all baskets with borrowing.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>basket_test(OneStageBasket)</code>: Testing for a single-stage basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, shape1 = 1, shape2 = 1, p0 = 0.2)
basket_test(design = design, n = 24, r = c(5, 9, 10), lambda = 0.99,
  weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='check_mon_between'>Check Between-Trial Monotonicity</h2><span id='topic+check_mon_between'></span><span id='topic+check_mon_between+2COneStageBasket-method'></span>

<h3>Description</h3>

<p>Checks whether the between-trial monotonicity condition holds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_mon_between(design, ...)

## S4 method for signature 'OneStageBasket'
check_mon_between(
  design,
  n,
  lambda,
  weight_fun,
  weight_params = list(),
  details = TRUE,
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_mon_between_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_details">details</code></td>
<td>
<p>Whether the cases where the monotonicity condition is
violated should be returned, in case there are any.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="check_mon_between_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check_mon_between</code> checks whether the between-trial
monotonicity condition holds. For a single-stage design with equal prior
distributions and equal sample sizes for each basket this condition states
that there are no cases where at least one null hypothesis is rejected when
when there is a case with an equal or higher number of responses in each
basket for which no null hypothesis is rejected.
</p>
<p>If <code>prune = TRUE</code> then the baskets with an observed number of baskets
smaller than the pooled critical value are not borrowed from. The
pooled critical value is the smallest integer c for which all null
hypotheses can be rejected if the number of responses is exactly c for
all baskets.
</p>
<p>The function is vectorized, such that vectors can be specified in
<code>weight_params</code> and <code>globalweight_params</code>.
</p>


<h3>Value</h3>

<p>If <code>details = FALSE</code> then only a logical value is returned.
If <code>details = TRUE</code> then if there are any cases where the
between-trial monotonicity condition is violated, a list of theses cases
and their results are returned.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>check_mon_between(OneStageBasket)</code>: Between-trial monotonicity condition for a
single-stage design.
</p>
</li></ul>


<h3>References</h3>

<p>Baumann, L., Krisam, J., &amp; Kieser, M. (2022). Monotonicity conditions for
avoiding counterintuitive decisions in basket trials. Biometrical Journal,
64(5), 934-947.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 4, shape1 = 1, shape2 = 1, p0 = 0.2)

# Without vectorization, with details
check_mon_between(design = design, n = 24, lambda = 0.99,
  weight_fun = weights_fujikawa, weight_params = list(epsilon = 3,
    tau = 0), details = TRUE)

# Vectorized
check_mon_between(design = design, n = 24, lambda = 0.99,
  weight_fun = weights_fujikawa,
  weight_params = list(epsilon = c(0.5, 1),  tau = c(0, 0.2, 0.3)),
  globalweight_fun = globalweights_fix,
  globalweight_params = list(w = c(0.5, 0.7)))
</code></pre>

<hr>
<h2 id='check_mon_within'>Check Within-Trial Monotonicity</h2><span id='topic+check_mon_within'></span><span id='topic+check_mon_within+2COneStageBasket-method'></span>

<h3>Description</h3>

<p>Checks whether the within-trial monotonicity condition holds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_mon_within(design, ...)

## S4 method for signature 'OneStageBasket'
check_mon_within(
  design,
  n,
  lambda,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  details = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_mon_within_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="check_mon_within_+3A_details">details</code></td>
<td>
<p>Whether the cases where the monotonicity condition is
violated should be returned, in case there are any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check_mon_within</code> checks whether the within-trial
monotonicity condition holds. For a single-stage design with equal
prior distributions and equal sample sizes for each basket this condition
states that there are no cases where the null hypothesis of a basket is
rejected when there is at least one other basket with more observed
responses for which the null hypothesis cannot be rejected.
</p>
<p>If <code>prune = TRUE</code> then the baskets with an observed number of baskets
smaller than the pooled critical value are not borrowed from. The
pooled critical value is the smallest integer c for which all null
hypotheses can be rejected if the number of responses is exactly c for
all baskets.
</p>
<p>The function is vectorized, such that vectors can be specified in
<code>weight_params</code> and <code>globalweight_params</code>.
</p>


<h3>Value</h3>

<p>If <code>details = FALSE</code> then only a logical value is returned.
If <code>details = TRUE</code> then if there are any cases where the
within-trial monotonicity condition is violated, a list of these cases and
their results are returned. If at least one tuning parameter is a vector,
then an array that shows for which combination of parameters the
within-trial monotonicity condition holds. In this case, the argument
<code>details</code> is ignored.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>check_mon_within(OneStageBasket)</code>: Within-trial monotonicity condition for a
single-stage design.
</p>
</li></ul>


<h3>References</h3>

<p>Baumann, L., Krisam, J., &amp; Kieser, M. (2022). Monotonicity conditions for
avoiding counterintuitive decisions in basket trials. Biometrical Journal,
64(5), 934-947.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 4, shape1 = 1, shape2 = 1, p0 = 0.2)

# Without vectorization, with details
design &lt;- setupOneStageBasket(k = 4, shape1 = 1, shape2 = 1, p0 = 0.2)
check_mon_within(design = design, n = 24, lambda = 0.99,
  weight_fun = weights_fujikawa, weight_params = list(epsilon = 0.5,
   tau = 0), details = TRUE)

# Vectorized
check_mon_within(design = design, n = 24, lambda = 0.99,
  weight_fun = weights_fujikawa,
  weight_params = list(epsilon = c(0.5, 1),  tau = c(0, 0.2, 0.3)),
  globalweight_fun = globalweights_fix,
  globalweight_params = list(w = c(0.5, 0.7)))
</code></pre>

<hr>
<h2 id='ecd'>Expected number of correct decisions</h2><span id='topic+ecd'></span><span id='topic+ecd+2COneStageBasket-method'></span><span id='topic+ecd+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Computes the expected number of correct decisions of a basket trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecd(design, ...)

## S4 method for signature 'OneStageBasket'
ecd(
  design,
  p1 = NULL,
  n,
  lambda,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
ecd(
  design,
  p1 = NULL,
  n,
  n1,
  lambda,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecd_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="ecd_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="ecd_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets.</p>
</td></tr>
<tr><td><code id="ecd_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="ecd_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="ecd_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="ecd_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="ecd_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="ecd_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="ecd_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="ecd_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="ecd_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the expected number of correction decisions, i.e. the
expected number of actually active baskets that are declared active and
actually inactive baskets that are declared inactive.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ecd(OneStageBasket)</code>: Expected number of correction decisions for a single-stage
basket design.
</p>
</li>
<li> <p><code>ecd(TwoStageBasket)</code>: Expected number of correction decisions for a two-stage
basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
ecd(design = design, p1 = c(0.5, 0.2, 0.2), n = 20, lambda = 0.99,
weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='ess'>Expected Sample Size</h2><span id='topic+ess'></span><span id='topic+ess+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Computes the expected sample size of a two-stage basket trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess(design, ...)

## S4 method for signature 'TwoStageBasket'
ess(
  design,
  p1 = NULL,
  n,
  n1,
  lambda,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ess_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="ess_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="ess_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets. If <code>is.null(p1)</code> then the type 1 error rate under the
global null hypothesis is computed.</p>
</td></tr>
<tr><td><code id="ess_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="ess_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="ess_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="ess_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="ess_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
<tr><td><code id="ess_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="ess_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="ess_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="ess_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ess(TwoStageBasket)</code>: Expected sample size for two-stage basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupTwoStageBasket(k = 3, p0 = 0.2)
ess(design, n = 20, n1 = 10, lambda = 0.99, weight_fun = weights_fujikawa,
  interim_fun = interim_postpred)
</code></pre>

<hr>
<h2 id='estim'>Posterior Mean and Mean Squared Error</h2><span id='topic+estim'></span><span id='topic+estim+2COneStageBasket-method'></span><span id='topic+estim+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Computes the posterior mean and the mean squared error of a basket trial
design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim(design, ...)

## S4 method for signature 'OneStageBasket'
estim(
  design,
  p1,
  n,
  lambda = NULL,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
estim(
  design,
  p1,
  n,
  n1,
  lambda = NULL,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="estim_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="estim_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets.</p>
</td></tr>
<tr><td><code id="estim_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="estim_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="estim_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="estim_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="estim_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="estim_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="estim_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="estim_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="estim_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing means of the posterior distributions and
the mean squared errors for all baskets.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>estim(OneStageBasket)</code>: Posterior mean and mean squared error for a single-stage
basket design.
</p>
</li>
<li> <p><code>estim(TwoStageBasket)</code>: Posterior mean and mean squared error for a two-stage
basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
estim(design = design, p1 = c(0.2, 0.2, 0.5), n = 15,
  weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='get_scenarios'>Create a Scenario Matrix</h2><span id='topic+get_scenarios'></span>

<h3>Description</h3>

<p>Creates a default scenario matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_scenarios(design, p1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_scenarios_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="get_scenarios_+3A_p1">p1</code></td>
<td>
<p>Probabilitiy under the alternative hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_scenarios</code> creates a default scenario matrix
that can be used for <code><a href="#topic+opt_design">opt_design</a></code>. The function creates
<code>k + 1</code> scenarios, from a global null to a global alternative scenario.
</p>


<h3>Value</h3>

<p>A matrix with <code>k</code> rows and <code>k + 1</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
get_scenarios(design = design, p1 = 0.5)
</code></pre>

<hr>
<h2 id='globalweights_diff'>Global Weights Based on Response Rate Differences</h2><span id='topic+globalweights_diff'></span>

<h3>Description</h3>

<p>Global Weights Based on Response Rate Differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalweights_diff(n, r, eps_global = 1, w = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="globalweights_diff_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="globalweights_diff_+3A_r">r</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="globalweights_diff_+3A_eps_global">eps_global</code></td>
<td>
<p>A tuning parameter that determines the amount of borrowing.
A higher value leads to a smaller weight and therefore less borrowing
when the heterogeneity between the results in the baskets increases.</p>
</td></tr>
<tr><td><code id="globalweights_diff_+3A_w">w</code></td>
<td>
<p>A fixed probability between 0 and 1. <code>w</code> is multiplied to
the weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>globalweights_diff</code> calculates a weight based on the
heterogeneity of the response rates of all baskets that is multiplied
to the pairwise weights calculated with the function that is passed to
<code>weight_fun</code>. The weight is 1 when the number of responses is identical
in all baskets and 0 if the response rates are an equidistant sequence
from 0 to 1. If the maximum weight should be smaller than 1, <code>w</code>
can  be set to a smaller value.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>globalweights_diff(n = 20, r = c(1, 3, 5), eps_global = 2)
</code></pre>

<hr>
<h2 id='globalweights_fix'>Fixed Global Weights</h2><span id='topic+globalweights_fix'></span>

<h3>Description</h3>

<p>Fixed Global Weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalweights_fix(n, r, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="globalweights_fix_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="globalweights_fix_+3A_r">r</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="globalweights_fix_+3A_w">w</code></td>
<td>
<p>Fixed number with wich all weights are multiplied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>globalweights_fix(n = 20, r = c(1, 3, 5), w = 0.5)
</code></pre>

<hr>
<h2 id='interim_posterior'>Interim analysis based on the posterior probability</h2><span id='topic+interim_posterior'></span><span id='topic+interim_posterior+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Conducts an interim analysis based on the posterior probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interim_posterior(design, ...)

## S4 method for signature 'TwoStageBasket'
interim_posterior(
  design,
  n1,
  r1,
  weight_mat,
  globalweight_fun = NULL,
  globalweight_params = list(),
  prob_futstop = 0.1,
  prob_effstop = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interim_posterior_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_r1">r1</code></td>
<td>
<p>Vector of responses after the interim analysis.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_weight_mat">weight_mat</code></td>
<td>
<p>The matrix with all weights. Automatically calculated
in the functions to which <code>interim_postpred</code> is passed.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_prob_futstop">prob_futstop</code></td>
<td>
<p>Probability cut-off for stopping for futility.</p>
</td></tr>
<tr><td><code id="interim_posterior_+3A_prob_effstop">prob_effstop</code></td>
<td>
<p>Probability cut-off for stopping for efficacy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>interim_posterior</code> conducts an interim analysis with possible
stop for efficacy and futility based on the posterior probability. If the
posterior probability is less than <code>prob_fustop</code> the basket is stopped
for futility, if the posterior probability is greater than
<code>prob_effstop</code> the basket is stopped for efficacy. If
<code>prob_fustop = 0</code> or <code>prob_effstop = 1</code> then no futility-stop and
no efficacy stop is possible, respectively.
</p>
<p>The function is generally not called by the user but passed to another
function such as <code><a href="#topic+toer">toer</a></code> and <code><a href="#topic+pow">pow</a></code> to specify which
interim analysis is conducted.
</p>


<h3>Value</h3>

<p>A vector with a length equal to the number of baskets with
elements -1, 0 or 1 where -1 means stop for futility, 0 means continuation
and 1 means stop for efficacy.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>interim_posterior(TwoStageBasket)</code>: Interim analysis based on the posterior
probabilty for two-stage basket designs.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupTwoStageBasket(k = 3, p0 = 0.2)
toer(design, n = 20, n1 = 10, lambda = 0.99, weight_fun = weights_fujikawa,
  interim_fun = interim_posterior, interim_params = list(prob_futstop = 0.05,
    prob_effstop = 0.95))
</code></pre>

<hr>
<h2 id='interim_postpred'>Interim analysis based on the posterior predictive probability</h2><span id='topic+interim_postpred'></span><span id='topic+interim_postpred+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Conducts an interim analysis based on the posterior predictive probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interim_postpred(design, ...)

## S4 method for signature 'TwoStageBasket'
interim_postpred(
  design,
  n,
  n1,
  r1,
  lambda,
  weight_mat,
  globalweight_fun = NULL,
  globalweight_params,
  prob_futstop = 0.1,
  prob_effstop = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interim_postpred_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_r1">r1</code></td>
<td>
<p>Vector of responses after the interim analysis.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_weight_mat">weight_mat</code></td>
<td>
<p>The matrix with all weights. Automatically calculated
in the functions to which <code>interim_postpred</code> is passed.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_prob_futstop">prob_futstop</code></td>
<td>
<p>Probability cut-off for stopping for futility.</p>
</td></tr>
<tr><td><code id="interim_postpred_+3A_prob_effstop">prob_effstop</code></td>
<td>
<p>Probability cut-off for stopping for efficacy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>interim_postpred</code> conducts an interim analysis with possible
stop for efficacy and futility based on the posterior predictive probability.
If the posterior predictive probability is less than <code>prob_fustop</code> the
basket is  stopped for futility, if the posterior predictive probability is
greater than <code>prob_effstop</code> the basket is stopped for efficacy. If
<code>prob_fustop = 0</code> or <code>prob_effstop = 1</code> then no futility-stop and
no efficacy stop is possible, respectively.
</p>
<p>The function is generally not called by the user but passed to another
function such as <code><a href="#topic+toer">toer</a></code> and <code><a href="#topic+pow">pow</a></code> to specify which
interim analysis is conducted.
</p>


<h3>Value</h3>

<p>A vector with a length equal to the number of baskets with
elements -1, 0 or 1 where -1 means stop for futility, 0 means continuation
and 1 means stop for efficacy.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>interim_postpred(TwoStageBasket)</code>: Interim analysis based on the posterior
predictive probabilty for two-stage basket designs.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupTwoStageBasket(k = 3, p0 = 0.2)
toer(design, n = 20, n1 = 10, lambda = 0.99, interim_fun = interim_postpred,
  weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='OneStageBasket-class'>Class OneStageBasket</h2><span id='topic+OneStageBasket-class'></span><span id='topic+OneStageBasket'></span>

<h3>Description</h3>

<p>OneStageBasket is an S4 class. An object of this class contains the most
important design features of a single-stage basket trial.
</p>


<h3>Details</h3>

<p>This class implements a single-stage basket trial based on the power prior
design or the design proposed by Fujikawa et al. In these designs,
information is borrowed between baskets by calculating weights that
reflect the similarity between the baskets (and optionally the overall
heterogeneity). Posterior distributions for each basket are beta
distributions where the parameters are found by adding weighted sums
of the observed responses and non-responses in each basket to the
prior parameters (or in case of Fujikawa's design by calculating
weighted sums of the individual posterior distributions).
</p>
<p>Currently only common prior distributions and a common null
hypothesis are supported.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>The number of baskets.</p>
</dd>
<dt><code>shape1</code></dt><dd><p>First common shape parameter of the beta prior.</p>
</dd>
<dt><code>shape2</code></dt><dd><p>Second common shape parameter of the beta prior.</p>
</dd>
<dt><code>p0</code></dt><dd><p>A common probability under the null hypothesis.</p>
</dd>
</dl>


<h3>References</h3>

<p>Baumann, L., Sauer, L., &amp; Kieser, M. (2024). A basket trial design based on
power priors. arXiv:2309.06988.
</p>
<p>Fujikawa, K., Teramukai, S., Yokota, I., &amp; Daimon, T. (2020).
A Bayesian basket trial design that borrows information across strata based
on the similarity between the posterior distributions of the response
probability. Biometrical Journal, 62(2), 330-338.
</p>

<hr>
<h2 id='opt_design'>Optimize a Basket Design</h2><span id='topic+opt_design'></span><span id='topic+opt_design+2COneStageBasket-method'></span><span id='topic+opt_design+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Finds the optimal tuning parameters using grid search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_design(design, ...)

## S4 method for signature 'OneStageBasket'
opt_design(
  design,
  n,
  alpha,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  scenarios,
  prec_digits,
  ...
)

## S4 method for signature 'TwoStageBasket'
opt_design(
  design,
  n,
  n1,
  alpha,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  scenarios,
  prec_digits,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt_design_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_alpha">alpha</code></td>
<td>
<p>The one-sided signifance level.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_scenarios">scenarios</code></td>
<td>
<p>A matrix of response rate scenarios. Each column corresponds
to a scenario and each row corresponds to a basket. A default scenario
matrix can be created with <code><a href="#topic+get_scenarios">get_scenarios</a></code>.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_prec_digits">prec_digits</code></td>
<td>
<p>Number of decimal places that are considered when
adjusting lambda.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="opt_design_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>opt_design</code> finds the optimal combination of tuning parameter
values from a the set of tuning paramters that is passed to the function.
The objective function for the optimization is the mean of the expected
number of correct decisions (ECD) under the passed scenarios, with the
constraint that the type 1 error under the global null hypothesis must be
below <code>alpha</code>.
</p>


<h3>Value</h3>

<p>A matrix with the ECDs under all scenarios and the mean ECD for
all combinations of tuning parameter values. The matrix is sorted
decreasingly by the mean ECD.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>opt_design(OneStageBasket)</code>: Optimize a single-stage basket design.
</p>
</li>
<li> <p><code>opt_design(TwoStageBasket)</code>: Optimize a two-stage basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
opt_design(design = design, n = 10, alpha = 0.05,
  weight_fun = weights_fujikawa, weight_params = list(epsilon = c(1, 2),
  tau = c(0, 0.5)), scenarios = get_scenarios(design, 0.5), prec_digits = 3)

</code></pre>

<hr>
<h2 id='plot_weights'>Plot Weight Functions</h2><span id='topic+plot_weights'></span><span id='topic+plot_weights+2COneStageBasket-method'></span>

<h3>Description</h3>

<p>Plot Weight Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_weights(design, ...)

## S4 method for signature 'OneStageBasket'
plot_weights(design, n, r1, weight_fun, weight_params = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_weights_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="plot_weights_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="plot_weights_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="plot_weights_+3A_r1">r1</code></td>
<td>
<p>Number of responses in one basket</p>
</td></tr>
<tr><td><code id="plot_weights_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="plot_weights_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design object is only used for the prior parameters,
which affect the weights of some weight functions.
</p>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>plot_weights(OneStageBasket)</code>: Plot weights for a single-stage basket trials
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2, shape1 = 1, shape2 = 1)
plot_weights(design = design, n = 20, r1 = 10, weight_fun = weights_jsd)
</code></pre>

<hr>
<h2 id='pow'>Power</h2><span id='topic+pow'></span><span id='topic+pow+2COneStageBasket-method'></span><span id='topic+pow+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Computes the exact power for a basket trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow(design, ...)

## S4 method for signature 'OneStageBasket'
pow(
  design,
  p1,
  n,
  lambda,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  results = c("ewp", "group"),
  ...
)

## S4 method for signature 'TwoStageBasket'
pow(
  design,
  p1,
  n,
  n1,
  lambda,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  results = c("ewp", "group"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pow_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="pow_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="pow_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets.</p>
</td></tr>
<tr><td><code id="pow_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="pow_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="pow_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="pow_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="pow_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="pow_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="pow_+3A_results">results</code></td>
<td>
<p>Whether only the experimentwise power (option <code>ewp</code>)
or also the rejection probabilities per group (option <code>group</code>) should
be returned.</p>
</td></tr>
<tr><td><code id="pow_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="pow_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="pow_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pow</code> computes the exact experimentwise power and the
exact rejection probabilities per group. The experimentwise power
is the probability to reject at least one null hypothesis for a basket with
p1 &gt; p0. The rejection probabilities correspond to the type 1 error
rate for baskets with p1 = p0 and to the power for baskets with
p1 &gt; p0.
</p>
<p>If <code>prune = TRUE</code> then the baskets with an observed number of baskets
smaller than the pooled critical value are not borrowed from. The
pooled critical value is the smallest integer c for which all null
hypotheses can be rejected if the number of responses is exactly c for
all baskets.
</p>
<p>This method is implemented for the class <code><a href="#topic+OneStageBasket">OneStageBasket</a></code>.
</p>


<h3>Value</h3>

<p>If <code>results = "ewp"</code> then the experimentwise power is
returned as a numeric value. If <code>results = "group"</code> then a list with
the rejection probabilities per group and the experimentwise power
is returned. For baskets with p1 = p0 the rejection probabilities
corresponds to the type 1 error rate, for baskets with p1 &gt; p0 the
rejection probabilities corresponds to the power.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>pow(OneStageBasket)</code>: Power for a single-stage basket design.
</p>
</li>
<li> <p><code>pow(TwoStageBasket)</code>: Power for a two-stage basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
pow(design, p1 = c(0.2, 0.5, 0.5), n = 15, lambda = 0.99,
  weight_fun = weights_fujikawa, weight_params = list(epsilon = 2, tau = 0))
</code></pre>

<hr>
<h2 id='setupOneStageBasket'>Setup OneStageBasket</h2><span id='topic+setupOneStageBasket'></span>

<h3>Description</h3>

<p>Creates an object of class <code><a href="#topic+OneStageBasket">OneStageBasket</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupOneStageBasket(k, shape1 = 1, shape2 = 1, p0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupOneStageBasket_+3A_k">k</code></td>
<td>
<p>The number of baskets.</p>
</td></tr>
<tr><td><code id="setupOneStageBasket_+3A_shape1">shape1</code></td>
<td>
<p>First common shape parameter of the beta prior.</p>
</td></tr>
<tr><td><code id="setupOneStageBasket_+3A_shape2">shape2</code></td>
<td>
<p>Second common shape parameter of the beta prior.</p>
</td></tr>
<tr><td><code id="setupOneStageBasket_+3A_p0">p0</code></td>
<td>
<p>A common probability under the null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+OneStageBasket">OneStageBasket</a></code> object contains the most important
design features of a basket trial. Currently only common prior distributions
and a common null hypothesis are supported.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+OneStageBasket">OneStageBasket</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
</code></pre>

<hr>
<h2 id='setupTwoStageBasket'>Setup TwoStageBasket</h2><span id='topic+setupTwoStageBasket'></span>

<h3>Description</h3>

<p>Creates an object of class <code><a href="#topic+TwoStageBasket">TwoStageBasket</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupTwoStageBasket(k, shape1 = 1, shape2 = 1, p0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupTwoStageBasket_+3A_k">k</code></td>
<td>
<p>The number of baskets.</p>
</td></tr>
<tr><td><code id="setupTwoStageBasket_+3A_shape1">shape1</code></td>
<td>
<p>First common shape parameter of the beta prior.</p>
</td></tr>
<tr><td><code id="setupTwoStageBasket_+3A_shape2">shape2</code></td>
<td>
<p>Second common shape parameter of the beta prior.</p>
</td></tr>
<tr><td><code id="setupTwoStageBasket_+3A_p0">p0</code></td>
<td>
<p>A common probability under the null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+TwoStageBasket">TwoStageBasket</a></code> object contains the most important
design features of a basket trial. Currently only common prior distributions
and a common null hypothesis are supported.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+TwoStageBasket">TwoStageBasket</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupTwoStageBasket(k = 3, p0 = 0.2)
</code></pre>

<hr>
<h2 id='toer'>Type 1 Error Rate</h2><span id='topic+toer'></span><span id='topic+toer+2COneStageBasket-method'></span><span id='topic+toer+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Computes the exact family wise type 1 error rate of a basket trial .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toer(design, ...)

## S4 method for signature 'OneStageBasket'
toer(
  design,
  p1 = NULL,
  n,
  lambda,
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  results = c("fwer", "group"),
  ...
)

## S4 method for signature 'TwoStageBasket'
toer(
  design,
  p1 = NULL,
  n,
  n1,
  lambda,
  interim_fun,
  interim_params = list(),
  weight_fun,
  weight_params = list(),
  globalweight_fun = NULL,
  globalweight_params = list(),
  results = c("fwer", "group"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toer_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="toer_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="toer_+3A_p1">p1</code></td>
<td>
<p>Probabilities under the alternative hypothesis. If
<code>length(p1) ==  1</code>, then this is a common probability for all
baskets. If <code>is.null(p1)</code> then the type 1 error rate under the
global null hypothesis is computed.</p>
</td></tr>
<tr><td><code id="toer_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="toer_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="toer_+3A_weight_fun">weight_fun</code></td>
<td>
<p>Which function should be used to calculate the pairwise
weights.</p>
</td></tr>
<tr><td><code id="toer_+3A_weight_params">weight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>weight_fun</code>.</p>
</td></tr>
<tr><td><code id="toer_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="toer_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="toer_+3A_results">results</code></td>
<td>
<p>Whether only the family wise error rate (option <code>fwer</code>)
or also the rejection probabilities per group (option <code>group</code>) should
be returned.</p>
</td></tr>
<tr><td><code id="toer_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
<tr><td><code id="toer_+3A_interim_fun">interim_fun</code></td>
<td>
<p>Which type of interim analysis should be conducted
in case of a two-stage design.</p>
</td></tr>
<tr><td><code id="toer_+3A_interim_params">interim_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>interim_fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>toer</code> computes the exact family wise type 1 error rate and the
exact rejection probabilities per group. The family wise type 1 error rate
is the probability to reject at least one null hypothesis for a basket with
p1 = p0. If all p1 &gt; p0 then the family wise type 1 error
rate under the global null hypothesis is computed. The rejection
probabilities correspond to the type 1 error rate for baskets with p1 =
p0 and to the power for baskets with p1 &gt; p0.
</p>


<h3>Value</h3>

<p>If <code>results = "fwer"</code> then the family wise type 1 error rate is
returned as a numeric value. If <code>results = "group"</code> then a list with
the rejection probabilities per group and the family wise type 1 error rate
is returned. If all p1 &gt; p0 then the family wise type 1 error rate
is calculated under the global null hypothesis. For baskets with p1 =
p0 the rejection probabilities corresponds to the type 1 error rate, for
baskets with p1 &gt; p0 the rejection probabilities corresponds to the
power.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>toer(OneStageBasket)</code>: Type 1 error rate for a single-stage basket design.
</p>
</li>
<li> <p><code>toer(TwoStageBasket)</code>: Type 1 error rate for two-stage basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='TwoStageBasket-class'>Class TwoStageBasket</h2><span id='topic+TwoStageBasket-class'></span><span id='topic+TwoStageBasket'></span>

<h3>Description</h3>

<p>TwoStageBasket is an S4 class. An object of this class contains the most
important design features of a two-stage basket trial.
</p>


<h3>Details</h3>

<p>This class implements a two-stage basket trial based on the power prior
design or the design proposed by Fujikawa et al. In these designs,
information is borrowed between baskets by calculating weights that
reflect the similarity between the baskets (and optionally the overall
heterogeneity). Posterior distributions for each basket are beta
distributions where the parameters are found by adding weighted sums
of the observed responses and non-responses in each basket to the
prior parameters (or in case of Fujikawa's design by calculating
weighted sums of the individual posterior distributions).
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>The number of baskets.</p>
</dd>
<dt><code>shape1</code></dt><dd><p>First common shape parameter of the beta prior.</p>
</dd>
<dt><code>shape2</code></dt><dd><p>Second common shape parameter of the beta prior.</p>
</dd>
<dt><code>p0</code></dt><dd><p>A common probability under the null hypothesis.</p>
</dd>
</dl>


<h3>References</h3>

<p>Baumann, L., Sauer, L., &amp; Kieser, M. (2024). A basket trial design based on
power priors. arXiv:2309.06988.
</p>
<p>Fujikawa, K., Teramukai, S., Yokota, I., &amp; Daimon, T. (2020).
A Bayesian basket trial design that borrows information across strata based
on the similarity between the posterior distributions of the response
probability. Biometrical Journal, 62(2), 330-338.
</p>

<hr>
<h2 id='weights_cpp'>Weights Based on the Calibrated Power Prior</h2><span id='topic+weights_cpp'></span><span id='topic+weights_cpp+2COneStageBasket-method'></span><span id='topic+weights_cpp+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Weights Based on the Calibrated Power Prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_cpp(design, ...)

## S4 method for signature 'OneStageBasket'
weights_cpp(
  design,
  n,
  a = 1,
  b = 1,
  prune = FALSE,
  lambda,
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
weights_cpp(design, n, n1, a = 1, b = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_cpp_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_a">a</code></td>
<td>
<p>first tuning parameter</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_b">b</code></td>
<td>
<p>second tuning parameter</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_prune">prune</code></td>
<td>
<p>Whether baskets with a number of responses below the
critical pooled value should be pruned before the final analysis.
If this is <code>TRUE</code> then <code>lambda</code> is also required and
if <code>globalweight_fun</code> is not <code>NULL</code> then
<code>globalweight_fun</code> and <code>globalweight_params</code> are also used.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="weights_cpp_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights_cpp</code> calculates the weights based on an approach
by Pan &amp; Yuan (2017). The weight for two baskets i and j is found by at
first calculating <code class="reqn">S_{KS;i,j}</code> as the Kolmogorov-Smirnov statistic,
which is equal to the difference in response rates for binary variables.
<code class="reqn">S_{KS;i,j}</code> is then transformed to <code class="reqn">S_{i,j} = n^{1/4}S_{KS;i,j}</code>.
Then the weight is found as <code class="reqn">1 / (1 + exp(a + b * log(S_{i,j})))</code>, where
a and b are tuning parameters.
</p>
<p>The function is generally not called by the user but passed to another
function such as <code><a href="#topic+toer">toer</a></code> and <code><a href="#topic+pow">pow</a></code> to specificy
how the weights are calculated.
</p>


<h3>Value</h3>

<p>A matrix including the weights of all possible pairwise outcomes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_cpp(OneStageBasket)</code>: Calibrated power prior weights for a single-stage
basket design.
</p>
</li>
<li> <p><code>weights_cpp(TwoStageBasket)</code>: Calibrated power prior weights for a two-stage
basket design.
</p>
</li></ul>


<h3>References</h3>

<p>Baumann, L., Sauer, L., &amp; Kieser, M. (2024). A basket trial design based on
power priors. arXiv:2309.06988.
</p>
<p>Pan, H., Yuan, Y., &amp; Xia, J. (2017). A calibrated power prior
approach to borrow information from historical data with application to
biosimilar clinical trials. Journal of the Royal Statistical Society Series
C: Applied Statistics, 66(5), 979-996.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_cpp)
</code></pre>

<hr>
<h2 id='weights_fujikawa'>Weights Based on Fujikawa et al.'s Design</h2><span id='topic+weights_fujikawa'></span><span id='topic+weights_fujikawa+2COneStageBasket-method'></span><span id='topic+weights_fujikawa+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Weights Based on Fujikawa et al.'s Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_fujikawa(design, ...)

## S4 method for signature 'OneStageBasket'
weights_fujikawa(
  design,
  n,
  lambda,
  epsilon = 1.25,
  tau = 0.5,
  logbase = 2,
  prune = FALSE,
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
weights_fujikawa(design, n, n1, epsilon = 1.25, tau = 0, logbase = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_fujikawa_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_epsilon">epsilon</code></td>
<td>
<p>A tuning parameter that determines the amount of borrowing.
See details for more information.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_tau">tau</code></td>
<td>
<p>A tuning parameter that determines how similar the baskets
have to be that borrowing occurs. See details for more information.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_logbase">logbase</code></td>
<td>
<p>A tuning parameter that determines which logarithm base is
used to compute the Jensen-Shannon divergence. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_prune">prune</code></td>
<td>
<p>Whether baskets with a number of responses below the
critical pooled value should be pruned before the final analysis.
If this is <code>TRUE</code> then <code>lambda</code> is also required and
if <code>globalweight_fun</code> is not <code>NULL</code> then
<code>globalweight_fun</code> and <code>globalweight_params</code> are also used.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="weights_fujikawa_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights_fujikawa</code> calculates the weights used for sharing
information between baskets based on the proposal by Fujikawa et al. (2020).
The weight for two baskets i and j is found as
<code class="reqn">(1 - JSD(i, j))^\varepsilon</code> where <code class="reqn">JSD(i, j)</code> is the Jensen-Shannon
divergence between the individual posterior distributions of the response
probabilities of basket i and j. Note that Fujikawa's weights also share the
prior information between the baskets.
</p>
<p>A small value of epsilon results in stronger borrowing also across baskets
with heterogenous results. If epsilon is large then information is only
borrowed between baskets with similar results. If a weight is smaller than
tau it is set to 0, which results in no borrowing.
</p>
<p>If <code>prune = TRUE</code> then the baskets with an observed number of baskets
smaller than the pooled critical value are not borrowed from. The
pooled critical value is the smallest integer c for which all null
hypotheses can be rejected if the number of responses is exactly c for
all baskets.
</p>
<p>The function is generally not called by the user but passed to another
function such as <code><a href="#topic+toer">toer</a></code> and <code><a href="#topic+pow">pow</a></code> to specificy
how the weights are calculated.
</p>


<h3>Value</h3>

<p>A matrix including the weights of all possible pairwise outcomes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_fujikawa(OneStageBasket)</code>: Fujikawa-weights for a single-stage basket
design.
</p>
</li>
<li> <p><code>weights_fujikawa(TwoStageBasket)</code>: Fujikawa-weights for a two-stage basket design.
</p>
</li></ul>


<h3>References</h3>

<p>Fujikawa, K., Teramukai, S., Yokota, I., &amp; Daimon, T. (2020).
A Bayesian basket trial design that borrows information across strata based
on the similarity between the posterior distributions of the response
probability. Biometrical Journal, 62(2), 330-338.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_fujikawa)
</code></pre>

<hr>
<h2 id='weights_jsd'>Weights Based on the Jensen-Shannon Divergence</h2><span id='topic+weights_jsd'></span><span id='topic+weights_jsd+2COneStageBasket-method'></span><span id='topic+weights_jsd+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Weights Based on the Jensen-Shannon Divergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_jsd(design, ...)

## S4 method for signature 'OneStageBasket'
weights_jsd(
  design,
  n,
  lambda,
  epsilon = 1.25,
  tau = 0.5,
  logbase = 2,
  prune = FALSE,
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
weights_jsd(design, n, n1, epsilon = 1.25, tau = 0, logbase = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_jsd_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_epsilon">epsilon</code></td>
<td>
<p>A tuning parameter that determines the amount of borrowing.
See details for more information.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_tau">tau</code></td>
<td>
<p>A tuning parameter that determines how similar the baskets
have to be that borrowing occurs. See details for more information.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_logbase">logbase</code></td>
<td>
<p>A tuning parameter that determines which logarithm base is
used to compute the Jensen-Shannon divergence. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_prune">prune</code></td>
<td>
<p>Whether baskets with a number of responses below the
critical pooled value should be pruned before the final analysis.
If this is <code>TRUE</code> then <code>lambda</code> is also required and
if <code>globalweight_fun</code> is not <code>NULL</code> then
<code>globalweight_fun</code> and <code>globalweight_params</code> are also used.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="weights_jsd_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights_jsd</code> calculates the weights used for sharing
information between baskets based on the Jensen-Shannon divergence (JSD).
The weight for two baskets i and j is found as
<code class="reqn">(1 - JSD(i, j))^\varepsilon</code> where <code class="reqn">JSD(i, j)</code> is the Jensen-Shannon
divergence between the individual posterior distributions of the response
probabilities of basket i and j. This is identical to how the weights are
calculated in <code><a href="#topic+weights_fujikawa">weights_fujikawa</a></code>, however when Fujikawa's weights
are used the prior information is also shared.
</p>
<p>A small value of epsilon results in stronger borrowing also across baskets
with heterogenous results. If epsilon is large then information is only
borrowed between baskets with similar results. If a weight is smaller than
tau it is set to 0, which results in no borrowing.
</p>
<p>If <code>prune = TRUE</code> then the baskets with an observed number of baskets
smaller than the pooled critical value are not borrowed from. The
pooled critical value is the smallest integer c for which all null
hypotheses can be rejected if the number of responses is exactly c for
all baskets.
</p>
<p>The function is generally not called by the user but passed to another
function such as <code><a href="#topic+toer">toer</a></code> and <code><a href="#topic+pow">pow</a></code> to specificy
how the weights are calculated.
</p>


<h3>Value</h3>

<p>A matrix including the weights of all possible pairwise outcomes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_jsd(OneStageBasket)</code>: Jensen-Shannon Divergence weights for a
single-stage basket design.
</p>
</li>
<li> <p><code>weights_jsd(TwoStageBasket)</code>: Jensen-Shannon Divergence weights for a two-stage
basket design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_jsd)
</code></pre>

<hr>
<h2 id='weights_mml'>Weights Based on the Marginal Maximum Likelihood</h2><span id='topic+weights_mml'></span><span id='topic+weights_mml+2COneStageBasket-method'></span><span id='topic+weights_mml+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Weights Based on the Marginal Maximum Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_mml(design, ...)

## S4 method for signature 'OneStageBasket'
weights_mml(
  design,
  n,
  prune = FALSE,
  lambda,
  globalweight_fun = NULL,
  globalweight_params = list(),
  ...
)

## S4 method for signature 'TwoStageBasket'
weights_mml(design, n, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_mml_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_prune">prune</code></td>
<td>
<p>Whether baskets with a number of responses below the
critical pooled value should be pruned before the final analysis.
If this is <code>TRUE</code> then <code>lambda</code> is also required and
if <code>globalweight_fun</code> is not <code>NULL</code> then
<code>globalweight_fun</code> and <code>globalweight_params</code> are also used.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_lambda">lambda</code></td>
<td>
<p>The posterior probability threshold. See details for more
information.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_globalweight_fun">globalweight_fun</code></td>
<td>
<p>Which function should be used to calculate the
global weights.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_globalweight_params">globalweight_params</code></td>
<td>
<p>A list of tuning parameters specific to
<code>globalweight_fun</code>.</p>
</td></tr>
<tr><td><code id="weights_mml_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights_mml</code> calculates the weights based on the marginal
maximum likelihood approach by Gravestock &amp; Held (2017). In this approach,
the weight is found as the maximum of the marginal likelihood of the
weight-parameter given the dataset that information should be borrowed
from. However, since this can lead to non-symmetric weights (meaning that
the amount of information that data set 1 borrows from data set 2 is
generally not identical to the information data set 2 borrows from data set
1), a symmetrised version is used here: For the sharing-weight of
Basket 1 and Basket 2 the MML is calculted two times - once conditional
on the data of Basket 1 and once conditional on the data of Basket 2.
The mean of these two weights is then used, resulting in symmetrical
sharing.
</p>


<h3>Value</h3>

<p>A matrix including the weights of all possible pairwise outcomes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_mml(OneStageBasket)</code>: Maximum marginal likelihood weights for a
single-stage basket design
</p>
</li>
<li> <p><code>weights_mml(TwoStageBasket)</code>: Maximum marginal likelihood weights for a
two-stage basket design
</p>
</li></ul>


<h3>References</h3>

<p>Gravestock, I., &amp; Held, L. (2017). Adaptive power priors with
empirical Bayes for clinical trials. Pharmaceutical statistics, 16(5),
349-360.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_mml)
</code></pre>

<hr>
<h2 id='weights_pool'>Pooled Analysis</h2><span id='topic+weights_pool'></span><span id='topic+weights_pool+2COneStageBasket-method'></span><span id='topic+weights_pool+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Pooled Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_pool(design, ...)

## S4 method for signature 'OneStageBasket'
weights_pool(design, n, ...)

## S4 method for signature 'OneStageBasket'
weights_pool(design, n, ...)

## S4 method for signature 'TwoStageBasket'
weights_pool(design, n, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_pool_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_pool_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_pool_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_pool_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>weights_pool</code> is used as a weight function, all data
are pooled.
</p>


<h3>Value</h3>

<p>A weight matrix where all weights are 1.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_pool(OneStageBasket)</code>: Pooled analysis for a single-stage basket design
</p>
</li>
<li> <p><code>weights_pool(OneStageBasket)</code>: Pooled analysis for a single-stage basket design
</p>
</li>
<li> <p><code>weights_pool(TwoStageBasket)</code>: Pooled analysis for a two-stage basket design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_pool)
</code></pre>

<hr>
<h2 id='weights_separate'>Separate Analysis in Each Basket</h2><span id='topic+weights_separate'></span><span id='topic+weights_separate+2COneStageBasket-method'></span><span id='topic+weights_separate+2CTwoStageBasket-method'></span>

<h3>Description</h3>

<p>Separate Analysis in Each Basket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_separate(design, ...)

## S4 method for signature 'OneStageBasket'
weights_separate(design, n, ...)

## S4 method for signature 'TwoStageBasket'
weights_separate(design, n, n1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_separate_+3A_design">design</code></td>
<td>
<p>An object of class <code>Basket</code> created by
<code>setupOneStageBasket</code> or <code>setupTwoStageBasket</code>.</p>
</td></tr>
<tr><td><code id="weights_separate_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="weights_separate_+3A_n">n</code></td>
<td>
<p>The sample size per basket.</p>
</td></tr>
<tr><td><code id="weights_separate_+3A_n1">n1</code></td>
<td>
<p>The sample size per basket for the interim analysis in case of a
two-stage design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>weights_separate</code> is used as a weight function, a
separate analysis performed in each basket.
</p>


<h3>Value</h3>

<p>A weight matrix where all weights are 0.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>weights_separate(OneStageBasket)</code>: Separate analysis for a single-stage basket
design
</p>
</li>
<li> <p><code>weights_separate(TwoStageBasket)</code>: Separate analysis for a two-stage basket
design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- setupOneStageBasket(k = 3, p0 = 0.2)
toer(design, n = 15, lambda = 0.99, weight_fun = weights_separate)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
