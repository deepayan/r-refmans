<!DOCTYPE html><html><head><title>Help for package tbea</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tbea}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tbea-package'><p>tbea: Pre- And Post-Processing in Bayesian Evolutionary Analyses</p></a></li>
<li><a href='#andes'><p>Divergence-time estimation data for cis-trans-Andean pairs</p></a></li>
<li><a href='#c_truncauchy'><p>c_truncauchy: Estimate the c parameter for the truncated cauchy L distribution</p>
to be used in MCMCTree</a></li>
<li><a href='#concatNexus'><p>concatNexus: Function for concatenation of nexus matrices both morphological and molecular</p></a></li>
<li><a href='#conflate'><p>conflate: Calculate the conflation of multiple distributions</p>
pdfs, plot = TRUE, from, to, n, add = FALSE</a></li>
<li><a href='#crossplot'><p>crossplot: Plot the median and HPD interval bars for pairs of distribution</p></a></li>
<li><a href='#density_fun'><p>density_fun: A way to represent distributions to be conflated</p></a></li>
<li><a href='#fasta2nexus'><p>fasta2nexus (deprecated): Function for converting molecular alignments from fasta to nexus format</p></a></li>
<li><a href='#findParams'><p>Function for estimation of probability density function parameters through quadratic optimization</p></a></li>
<li><a href='#laventa'><p>Geochronology samples from the Honda Group in Colombia</p></a></li>
<li><a href='#lognormalBeast'><p>Constructing a curve for the user-specified lognormal prior using Beast2 parameters</p></a></li>
<li><a href='#measureSimil'><p>Calculate the Intersection Between Two Densities</p></a></li>
<li><a href='#mswd.test'><p>Reduced chi-square test or mean square weighted deviation (mswd) test</p></a></li>
<li><a href='#stratCI'><p>stratCI: Estimate the confidence intervals of endpoints in</p>
stratigraphic intervals</a></li>
<li><a href='#summaryBrlen'><p>summaryBrlen: Summarise branch lengths on trees with identical topology</p></a></li>
<li><a href='#table2nexus'><p>table2nexus: Read a data matrix in delimited format and convert</p>
into a data matrix in nexus format</a></li>
<li><a href='#tnt2newick'><p>tnt2newick: Function for converting from TNT tree format to newick parenthetical format</p></a></li>
<li><a href='#topoFreq'><p>Frequency of topologies in a tree sample</p></a></li>
<li><a href='#xintercept'><p>xintercept: Estimate the x-intercept of an empirical cdf</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pre- And Post-Processing in Bayesian Evolutionary Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided for prior specification in divergence time
    estimation using fossils as well as other kinds of data. It
    provides tools for interacting with the input and output of Bayesian
    platforms in evolutionary biology such as 'BEAST2', 'MrBayes', 'RevBayes',
    or 'MCMCTree'.
    It Implements a simple measure similarity between probability
    density functions for comparing prior and
    posterior Bayesian densities, as well as code for calculating the
    combination of distributions using conflation of Hill (2008). Functions for estimating the
    origination time in collections of distributions using the x-intercept (e.g., Draper and Smith, 1998) and
    stratigraphic intervals (Marshall 2010) are also available.
    Hill, T. 2008. "Conflations of probability distributions". Transactions of the American Mathematical Society, 363:3351-3372. &lt;<a href="https://doi.org/10.48550%2FarXiv.0808.1808">doi:10.48550/arXiv.0808.1808</a>&gt;,
    Draper, N. R. and Smith, H. 1998. "Applied Regression Analysis". 1&ndash;706. Wiley Interscience, New York. &lt;<a href="https://doi.org/10.1002%2F9781118625590">doi:10.1002/9781118625590</a>&gt;,
    Marshall, C. R. 2010. "Using confidence intervals to quantify the uncertainty in the end-points of stratigraphic ranges". Quantitative Methods in Paleobiology, 291&ndash;316. &lt;<a href="https://doi.org/10.1017%2FS1089332600001911">doi:10.1017/S1089332600001911</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, Rfit, boot, graphics, stats, utils, coda</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gaballench/tbea">https://github.com/gaballench/tbea</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gaballench/tbea/issues">https://github.com/gaballench/tbea/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 15:57:00 UTC; balleng</td>
</tr>
<tr>
<td>Author:</td>
<td>Gustavo A. Ballen [aut, cre],
  Sandra Reinales [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gustavo A. Ballen &lt;gustavo.a.ballen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 16:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='tbea-package'>tbea: Pre- And Post-Processing in Bayesian Evolutionary Analyses</h2><span id='topic+tbea'></span><span id='topic+tbea-package'></span>

<h3>Description</h3>

<p>Functions are provided for prior specification in divergence time estimation using fossils as well as other kinds of data. It provides tools for interacting with the input and output of Bayesian platforms in evolutionary biology such as 'BEAST2', 'MrBayes', 'RevBayes', or 'MCMCTree'. It Implements a simple measure similarity between probability density functions for comparing prior and posterior Bayesian densities, as well as code for calculating the combination of distributions using conflation of Hill (2008). Functions for estimating the origination time in collections of distributions using the x-intercept (e.g., Draper and Smith, 1998) and stratigraphic intervals (Marshall 2010) are also available. Hill, T. 2008. &quot;Conflations of probability distributions&quot;. Transactions of the American Mathematical Society, 363:3351-3372. <a href="https://doi.org/10.48550/arXiv.0808.1808">doi:10.48550/arXiv.0808.1808</a>, Draper, N. R. and Smith, H. 1998. &quot;Applied Regression Analysis&quot;. 1&ndash;706. Wiley Interscience, New York. <a href="https://doi.org/10.1002/9781118625590">doi:10.1002/9781118625590</a>, Marshall, C. R. 2010. &quot;Using confidence intervals to quantify the uncertainty in the end-points of stratigraphic ranges&quot;. Quantitative Methods in Paleobiology, 291&ndash;316. <a href="https://doi.org/10.1017/S1089332600001911">doi:10.1017/S1089332600001911</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gustavo A. Ballen <a href="mailto:gustavo.a.ballen@gmail.com">gustavo.a.ballen@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sandra Reinales <a href="mailto:spreinalesl@gmail.com">spreinalesl@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gaballench/tbea">https://github.com/gaballench/tbea</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/gaballench/tbea/issues">https://github.com/gaballench/tbea/issues</a>
</p>
</li></ul>


<hr>
<h2 id='andes'>Divergence-time estimation data for cis-trans-Andean pairs</h2><span id='topic+andes'></span>

<h3>Description</h3>

<p>A dataset containing point estimates and uncertainty intervals of
divergence times for clade pairs east and west of the Andes,
compiled by Ballen (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(andes)
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt>ages</dt><dd><p>Estimated age (in Ma) from a given rock sample</p>
</dd>
<dt>min</dt><dd><p>Standard deviation of the age estimate</p>
</dd>
<dt>max</dt><dd><p>Sample code as in Table 3.2</p>
</dd>
</dl>



<h3>References</h3>

<p>Ballen, Gustavo A. 2020. Fossil freshwater fishes and the biogeography of northern South America. 2020. PhD thesis, Museu de Zoologia, Universidade de São Paulo, São Paulo, 2020. doi:10.11606/T.38.2020.tde-06052020-181631.
</p>

<hr>
<h2 id='c_truncauchy'>c_truncauchy: Estimate the c parameter for the truncated cauchy L distribution
to be used in MCMCTree</h2><span id='topic+c_truncauchy'></span>

<h3>Description</h3>

<p>c_truncauchy: Estimate the c parameter for the truncated cauchy L distribution
to be used in MCMCTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_truncauchy(tl, tr, p = 0.1, pr = 0.975, al = 0.025, output = "par")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_truncauchy_+3A_tl">tl</code></td>
<td>
<p>minimum age.</p>
</td></tr>
<tr><td><code id="c_truncauchy_+3A_tr">tr</code></td>
<td>
<p>maximum age</p>
</td></tr>
<tr><td><code id="c_truncauchy_+3A_p">p</code></td>
<td>
<p>constant p involved in Cauchy parameters location and scale. Set to 0.1 by default.
It determines how close the mode of the distribution is to the tl min age.</p>
</td></tr>
<tr><td><code id="c_truncauchy_+3A_pr">pr</code></td>
<td>
<p>percentile to the right of the distribution (0.975 by default)</p>
</td></tr>
<tr><td><code id="c_truncauchy_+3A_al">al</code></td>
<td>
<p>alpha to the right of the minimum on x. Set it to zero if a hard minimum is desired, otherwise the random variable can take values below t_L with probability al. Set to 0.025 by default.</p>
</td></tr>
<tr><td><code id="c_truncauchy_+3A_output">output</code></td>
<td>
<p>Whether to return just the parameters or all of the optimisation output. Defaults
to &quot;par&quot;. Leave it blank &quot;&quot; or with different text in order to return all of the optimisation
output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We solve for c while fixing p=0.1 so that the mode of the distribution is closer to the t_L and then we calculate c so that t_R is at the desired max age. note that ar and al are NOT complements, thus both can be 0.025. Optimisation proceeds by fixing p in t_L(1-p) and then using numerical optimisation to find c in c*t_L.
</p>


<h3>Value</h3>

<p>Either the parameter optimisation value as a numeric vector of length one (when output=&quot;par&quot;)
or the
complete optimisation output as a list (otherwise)
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testValues.tr &lt;- c(4.93, 12.12, 24.43, 49.20)
# the values below should be approx. c = 0.2, 0.5, 1, 2
# according to the paml documentation
for (i in testValues.tr) {
    print(c_truncauchy(tl=1, tr=i, p=0.1, pr=0.975, al=0.025))
}
</code></pre>

<hr>
<h2 id='concatNexus'>concatNexus: Function for concatenation of nexus matrices both morphological and molecular</h2><span id='topic+concatNexus'></span>

<h3>Description</h3>

<p>concatNexus: Function for concatenation of nexus matrices both morphological and molecular
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatNexus(
  matrices = NULL,
  pattern,
  path,
  filename,
  morpho = FALSE,
  morphoFilename = NULL,
  sumFilename
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatNexus_+3A_matrices">matrices</code></td>
<td>
<p>A vector of type 'character' with paths to the nexus alignments or their file names. If <code>morphoFilename</code> is non-null, either the path to the morphological partition or its file name must be included too. The default is NULL and it must be defined if none of <code>pattern</code> and <code>path</code> are included.</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_pattern">pattern</code></td>
<td>
<p>A vector of type 'character' and length one containing the text pattern to identify the alignments of interest. It would be tipically be some suffix and/or file extension (see examples).</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_path">path</code></td>
<td>
<p>A vector of type 'character' and length one pointing to the directory where the matrices are located. It is used in combination with <code>pattern</code> in order to build a path to each matrix file (see examples).</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_filename">filename</code></td>
<td>
<p>A vector of type 'character' and length one with the file name (or path and file name) for the concatenated output matrix.</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_morpho">morpho</code></td>
<td>
<p>A vector of type 'logical' and length one indicating whether a morphological matrix is included in the concatenation.</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_morphofilename">morphoFilename</code></td>
<td>
<p>A vector of type 'character' and length one with the file name or path to the morphological nexus matrix. Needed if <code>morpho = TRUE</code>.</p>
</td></tr>
<tr><td><code id="concatNexus_+3A_sumfilename">sumFilename</code></td>
<td>
<p>A vector of type 'character' and length one with the file name or path to the summary information of partition start and end positions. Useful for specifying concatenated analyses in MrBayes where each partition in the matrix might have its own substitution model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will concatenate matrices in nexus format (mandatory) and write to the disk the output and summary information on the partitions. It requires that the input matrices all share the same taxa in the same positions.
</p>


<h3>Value</h3>

<p>This function writes to the disk two files, one with the concatenated matrix and one with the summary information on partition positions in the complete matrix.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Concatenate all the matrices in a given path,
# ending with the pattern 'aligned.nex', including a morphological matrix
# also defined with a pattern
## Not run: 
path &lt;- "sequences"
pattern &lt;- "aligned.nex$"

concatNexus(matrices = NULL, pattern = pattern,
            filename = paste(path, "concatenatedMolmorph.nexus", sep = "/"),
            path = path, 
            morpho = TRUE,
            morphoFilename = paste(path, grep(pattern = "morfologia",
                                              x = dir(path, pattern), value = TRUE),
                                   sep = "/"),
            sumFilename = "partitions.txt")

## End(Not run)
# Concatenate arbitrary matrices in the working directory,
# including a morphological matrix, return a concatenated file in the same dir
## Not run: 
concatNexus(matrices = c("coi.nex", "rag1.nex", "cytb.nex", "morphology.nex"),
            filename = "concatenatedMolmorph.nexus", 
            morpho = TRUE,
            morphoFilename = "morphology.nex",
            sumFilename = "partitions.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='conflate'>conflate: Calculate the conflation of multiple distributions
pdfs, plot = TRUE, from, to, n, add = FALSE</h2><span id='topic+conflate'></span>

<h3>Description</h3>

<p>conflate: Calculate the conflation of multiple distributions
pdfs, plot = TRUE, from, to, n, add = FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conflate(pdfs, plot = TRUE, from, to, n, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conflate_+3A_pdfs">pdfs</code></td>
<td>
<p>A vector of calls to density_fun for defininf each individual distribution.</p>
</td></tr>
<tr><td><code id="conflate_+3A_plot">plot</code></td>
<td>
<p>Whether to plot using curve</p>
</td></tr>
<tr><td><code id="conflate_+3A_from">from</code>, <code id="conflate_+3A_to">to</code>, <code id="conflate_+3A_n">n</code></td>
<td>
<p>The appropriate values from and to which to calculate the conflation, and a number of points n. These are the same used by the function curve but are still necessary even if no plot is required.</p>
</td></tr>
<tr><td><code id="conflate_+3A_add">add</code></td>
<td>
<p>Whether to add the curve to an existing plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces either a plot or a data frame
with the x and y values for the conflated PDF. It uses as input
a vector of densities constructed with
density_fun, and further parameters to be pased to curve
if no plot is desired these are still used for returning
a data frame with the x and y values from evaluation the
conflated PDF on the sequence of x values determined by
a number n of equidistant points between from and to.
</p>


<h3>Value</h3>

<p>A tree of class phylo with summary branch lengths in tree$edge.length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
conflated_normals &lt;- conflate(c("density_fun(x, 'dnorm', mean=0, sd=1)",
                                "density_fun(x, 'dnorm', mean=3, sd=1)"),
                              from=-4, to=4, n=101, plot=FALSE)
plot(conflated_normals)


</code></pre>

<hr>
<h2 id='crossplot'>crossplot: Plot the median and HPD interval bars for pairs of distribution</h2><span id='topic+crossplot'></span>

<h3>Description</h3>

<p>crossplot: Plot the median and HPD interval bars for pairs of distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossplot(
  log1Path,
  log2Path,
  skip.char = "#",
  pattern = NULL,
  idx.cols = NULL,
  bar.lty,
  bar.lwd,
  identity.lty,
  identity.lwd,
  extra.space = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossplot_+3A_log1path">log1Path</code></td>
<td>
<p>character vector of length 1. Path to the first log file.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_log2path">log2Path</code></td>
<td>
<p>character vector of length 1. Path to the second log file.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_skip.char">skip.char</code></td>
<td>
<p>character vector of length 1, with '#' as default value.
Which symbol is used as a comment. This will allow to ignore lines which
start with the symbol when reading data.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_pattern">pattern</code></td>
<td>
<p>character vector of length 1. the pattern for subsetting the
columns containing the data to be plotted.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_idx.cols">idx.cols</code></td>
<td>
<p>either an integer vector with the position of the columns to
pick, or a character vector with the column names to pick. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_bar.lty">bar.lty</code></td>
<td>
<p>The line type to be used as error bars.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_bar.lwd">bar.lwd</code></td>
<td>
<p>As above but the width</p>
</td></tr>
<tr><td><code id="crossplot_+3A_identity.lty">identity.lty</code></td>
<td>
<p>The line type to be used in
the identity y = x line</p>
</td></tr>
<tr><td><code id="crossplot_+3A_identity.lwd">identity.lwd</code></td>
<td>
<p>As above but the width.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_extra.space">extra.space</code></td>
<td>
<p>numeric vector of length 1. How much space to be allowed
in both xlim and ylim depending on the smallest value in highest density
intervals plus or minus extra.space. A value of 0.5 units on the dimension
of interest is used by default.</p>
</td></tr>
<tr><td><code id="crossplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to 'plot' such as 'main', 'xlab',
'ylab', 'pch' and 'cex'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a crossplot, which is a scatterplot where we
are comparing two distributions associated to each point by means of the
medians as the points, and the highest density intervals as bars around the
point. For instance, x may represent the prior of a set of parameters while
y represents the posterior. Error bars on the x axis then are highest density
intervals from the prior, and those on the y axis represent the interval for
the posterior.
</p>
<p>This function can also be used to compare two independent runs for
(visual) convergence: If they are sampling the same posterior distribution,
then they should fall on the identity y=x line.
</p>


<h3>Value</h3>

<p>This function returns nothing, it plots to the graphical device.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
crossplot(log1Path="log1.tsv", log2Path="log2.tsv", skip.char="#",
          pattern="par", cols=NULL, bar.lty=1, bar.lwd=1,
          identity.lty=2, identity.lwd=1,
          extra.space=0.5, main="My plot", xlab="log 1 (prior)", ylab="log 2 (posterior)", pch=19)

## End(Not run)
</code></pre>

<hr>
<h2 id='density_fun'>density_fun: A way to represent distributions to be conflated</h2><span id='topic+density_fun'></span>

<h3>Description</h3>

<p>density_fun: A way to represent distributions to be conflated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_fun(x, dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_fun_+3A_x">x</code></td>
<td>
<p>a symbol which needs to be present in order to allow passing values towards the distruibution generator. It should be just x, without quotation marks (see examples).</p>
</td></tr>
<tr><td><code id="density_fun_+3A_dist">dist</code></td>
<td>
<p>A character (using single quotes!) with the name of the distribution to use.</p>
</td></tr>
<tr><td><code id="density_fun_+3A_...">...</code></td>
<td>
<p>Parameters to be passed on to dist. See examples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a definition of each individual distribution to be conflated
and provides the symbol for non-standard evaluation (x). Single quotes in dist
are mandatory in order to avoid issues when calling expressions under the hood.
See the documentation for each individual distribution to call their parameters
adequately. Argument names and values should be used.
</p>


<h3>Value</h3>

<p>A call from the elements of the distribution to be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c("density_fun(x, 'dnorm', mean=0, sd=1)",
  "density_fun(x, 'dnorm', mean=-1, sd=1)",
  "density_fun(x, 'dnorm', mean=1, sd=1)")


</code></pre>

<hr>
<h2 id='fasta2nexus'>fasta2nexus (deprecated): Function for converting molecular alignments from fasta to nexus format</h2><span id='topic+fasta2nexus'></span>

<h3>Description</h3>

<p>fasta2nexus (deprecated): Function for converting molecular alignments from fasta to nexus format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasta2nexus(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fasta2nexus_+3A_...">...</code></td>
<td>
<p>A placeholder for any argument that used to be in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was deprecated from tbea v1.0.0 onwards. For using this function please install tbea v0.5.0.
</p>


<h3>Value</h3>

<p>This function returns an error because it has been deprecated.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>

<hr>
<h2 id='findParams'>Function for estimation of probability density function parameters through quadratic optimization</h2><span id='topic+findParams'></span>

<h3>Description</h3>

<p>Function for estimation of probability density function parameters through quadratic optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findParams(q, p, output = "complete", pdfunction, params, initVals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findParams_+3A_q">q</code></td>
<td>
<p>A numeric vector of observed quantiles, might come from a HPD from a previous study (along with a median), or from other sources of prior information. See Details.</p>
</td></tr>
<tr><td><code id="findParams_+3A_p">p</code></td>
<td>
<p>A numeric vector of percentiles.</p>
</td></tr>
<tr><td><code id="findParams_+3A_output">output</code></td>
<td>
<p>One of two possible values: <code>"complete"</code> and <code>"parameters"</code>. For the latter the complete output of the <code>optim</code> function is returned with information on convergence and squared errors (that might be useless for simple cases) or just the parameters.</p>
</td></tr>
<tr><td><code id="findParams_+3A_pdfunction">pdfunction</code></td>
<td>
<p>A character vector (of length one) with the name of the PDF function of interest. Technically this argument supports any PDF function of the form pDIST (e.g., <code>pnorm</code>, <code>ppois</code>, <code>pexp</code>).</p>
</td></tr>
<tr><td><code id="findParams_+3A_params">params</code></td>
<td>
<p>A character vector with the name of the parameter(s) to optimize in the probability density function. These should match the parameter names of the respective PDF function, e.g., <code>"lambda"</code> in the function <code>ppois</code></p>
</td></tr>
<tr><td><code id="findParams_+3A_initvals">initVals</code></td>
<td>
<p>A numeric vector with default value <code>NULL</code>. It allows the user to provide initial values, althought this is discouraged in most cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function comes handy whenever we have some values of uncertainty, (e.g., confidence intervals, HPDs, biostratigraphic age constrains) and want to express it in the form of a probability density function of the form <code class="reqn">P(x;\theta)</code>. As we have some values (the quantiles) already and their corresponding percentiles, all we need is a way to approximate the parameters <code class="reqn">\theta</code> that produce the same combination of quantiles for the given percentiles under a given PDF. This is carried out through optimization of a quadratic error function. This is accomplished through the function <code>optim</code>. For instance, if the estimated age of a fossil is Lutetian, in the Eocene (41.2 to 47.8 Ma), and we want to model such uncertainty through a normal distribution, we could assume that these age boundaries are the quantiles for percentiles 0.025 and 0.975 respectively, and add a thir pair with the midpoint corresponding to the percentile 0.5. This is all the information needed in order to estimate the parameters <code>mean</code> and <code>sd</code> in the functiono <code>pnorm</code>.
</p>


<h3>Value</h3>

<p>Either a list with the complete output of convergence, squared errors and parameter values, or just a vector of parameter values. Depends on the value of <code>output</code>.
Warnings may be triggered by the function <code>optim</code> since the optimization is a heuristic process, whenever a given iteration results in an invalid value for a given combination of parameters, the <code>optim</code> function tries another combination of values but inform the user about the problem through a warning. In general these can be safely disregarded.
</p>


<h3>Author(s)</h3>

<p>Main code by Gustavo A. Ballen with important contributions in expression call structure and vectorized design by Klaus Schliep (<a href="mailto:Klaus.Schliep@umb.edu">Klaus.Schliep@umb.edu</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the best parameters for a standard normal density that fit the observed quantiles
# -1.644854, 0, and 1.644854, providing full output for the calculations in the form of
# a list
findParams(q = c(-1.959964, 0.000000, 1.959964),
           p = c(0.025, 0.50, 0.975),
           output = "complete",
           pdfunction = "pnorm",
           params = c("mean", "sd"))

# Given that we have prior on the age of a fossil to be 1 - 10 Ma and that we want to
# model it with a lognormal distribution, fin the parameters of the PDF that best reflect
# the uncertainty in question (i.e., the parameters  for which the observed quantiles are
# 1, 5.5, and 10, assuming that we want the midpoint to reflect the mean of the PDF.
findParams(q = c(1, 5.5, 10),
           p = c(0.025,  0.50, 0.975),
           output = "complete",
           pdfunction = "plnorm",
           params = c("meanlog", "sdlog"))
</code></pre>

<hr>
<h2 id='laventa'>Geochronology samples from the Honda Group in Colombia</h2><span id='topic+laventa'></span>

<h3>Description</h3>

<p>A dataset containing geochronology data from several samples along
the stratigraphic column of the Honda and Huila groups in the Tatacoa
Desert area. The dataset was compiled from the Table 3.2 in Flynn et al.
(1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(laventa)
</code></pre>


<h3>Format</h3>

<p>A data frame with 87 rows and 7 variables:
</p>

<dl>
<dt>age</dt><dd><p>Estimated age (in Ma) from a given rock sample</p>
</dd>
<dt>one_sigma</dt><dd><p>Standard deviation of the age estimate</p>
</dd>
<dt>sample</dt><dd><p>Sample code as in Table 3.2</p>
</dd>
<dt>unit</dt><dd><p>Stratigraphic unit in either the Honda Group or the
Huila Group</p>
</dd>
<dt>elevation</dt><dd><p>Position in the stratigraphic column, in meters</p>
</dd>
<dt>mineral</dt><dd><p>The mineral used for dating the sample</p>
</dd>
<dt>comments</dt><dd><p>Comments from footnotes in the original table</p>
</dd>
</dl>



<h3>References</h3>

<p>Flynn, J.J., Guerrero, J. &amp; Swisher III, C.C. (1997) Geochronology of the Honda Group. In: R. F. Kay, R. H. Madden, R. L. Cifelli, and J. J. Flynn (Eds), Vertebrate Paleontology in the Neotropics: the Miocene Fauna of La Venta, Colombia. Smithsonian Institution Press, pp. 44–60.
</p>

<hr>
<h2 id='lognormalBeast'>Constructing a curve for the user-specified lognormal prior using Beast2 parameters</h2><span id='topic+lognormalBeast'></span>

<h3>Description</h3>

<p>Constructing a curve for the user-specified lognormal prior using Beast2 parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormalBeast(
  M,
  S,
  meanInRealSpace = TRUE,
  offset = 0,
  from = NULL,
  to = NULL,
  by = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lognormalBeast_+3A_m">M</code></td>
<td>
<p>Mean of the lognormal density in Beast2.</p>
</td></tr>
<tr><td><code id="lognormalBeast_+3A_s">S</code></td>
<td>
<p>Standard deviation of the lognormal density in Beast2.</p>
</td></tr>
<tr><td><code id="lognormalBeast_+3A_meaninrealspace">meanInRealSpace</code></td>
<td>
<p>Whether to plot the mean on the real- or log-space (i.e., apply log(M) before plotting). Please see under details.</p>
</td></tr>
<tr><td><code id="lognormalBeast_+3A_offset">offset</code></td>
<td>
<p>Hard lower bound.</p>
</td></tr>
<tr><td><code id="lognormalBeast_+3A_from">from</code>, <code id="lognormalBeast_+3A_to">to</code>, <code id="lognormalBeast_+3A_by">by</code></td>
<td>
<p>Starting and ending point to calculate considering the offset as zero. That is, from will affect produce a starting point of (offset + from) and an ending point of (offset + to). By sets the step size of the sequence from 'from' to 'to' each 'by' steps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a matrix of x,y values given parameters of a lognormal density as specified in the program Beast2. It's main purpose is for plotting but other uses such as similarity quantification are available. Please note that the value of mean depends on whether we expect it to be in real or log space. Please refer to Heath (2015) for more info: <a href="http://phyloworks.org/workshops/DivTime_BEAST2_tutorial_FBD.pdf">Heath, T. A. (2015). Divergence Time Estimation using BEAST v2</a>.
</p>


<h3>Value</h3>

<p>A matrix of two columns consisting of the x and y values of the lognormal density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a matrix for the lognormal density with mean 1 and standard deviation 1, with mean
# in real space, and spanning values in x from 0 to 10
lognormalBeast(M = 1, S = 1, meanInRealSpace = TRUE, from = 0, to = 10)
# The same as above but with an offset of 10, that is, the curve starts at 10 as if it was 0
# to values will start in (offset + from) and finish in (offset + to)
lognormalBeast(M = 1, S = 1, meanInRealSpace = TRUE, offset = 10, from = 0, to = 10)
</code></pre>

<hr>
<h2 id='measureSimil'>Calculate the Intersection Between Two Densities</h2><span id='topic+measureSimil'></span>

<h3>Description</h3>

<p>Calculate the Intersection Between Two Densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureSimil(
  d1,
  d2,
  splits = 500,
  rawData = c(TRUE, TRUE),
  plot = TRUE,
  x_limit = "auto",
  colors = c("red", "blue", "gray"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureSimil_+3A_d1">d1</code>, <code id="measureSimil_+3A_d2">d2</code></td>
<td>
<p>Either two vectors of empirical (i.e., MCMC-produced) values OR a <code>data.frame</code>/<code>matrix</code> with columns x and y for values fitted to a density from which to calculate areas. If <code>rawData</code> is set to <code>TRUE</code> in any instance, the data must be placed in vectors and not multidimensional objects.</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_splits">splits</code></td>
<td>
<p>A numerical argument controling the number of subdivisions of the intersection area for numerical integration</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_rawdata">rawData</code></td>
<td>
<p>Are d1 and/or d2 raw data for which a density should be calculated? A vector of length two containing logical values indicating whenther any of the arguments d1 or d2 are raw data or whether the user is inputing already calculated densities (e.g., the output from the density, curve, or dDIST functions, or any two-dimension object with x and y values)</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_plot">plot</code></td>
<td>
<p>Should a plot be produced?</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_x_limit">x_limit</code></td>
<td>
<p>Whether to define the xlim form the min-max of the combined density x-values</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_colors">colors</code></td>
<td>
<p>A vector of three colors, namely, color of the <code>d1</code> density (e.g., the prior), color of the <code>d2</code> density e.g., the posterior), and color of the intersection.</p>
</td></tr>
<tr><td><code id="measureSimil_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to the graphical functions such as <code>lines</code> and <code>plot</code> internally (e.g., <code>main</code>, <code>xlim</code>, <code>ylim</code>, <code>xlab</code>, <code>ylab</code>, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarity is measured as the overlapping portion between two densities. It has a value between 0 and 1. The values of the vector rawData determine the behavior of the function and therefore attention must be paid to their consistence with the nature of arguments d1 and d2. Despite the function was designed in order to allow to quantify similarity between the posterior and the prior, this can be used to quantify any overlap between two given densities and for any other purpose.
</p>


<h3>Value</h3>

<p>A numeric vector with the value of the intersection between two densities. As a side effect, a plot is produced to an active (or new) graphical device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set seed and colors to use in plots in the order: Prior, posterior, and intersection
set.seed(1985)
colors &lt;- c("red", "blue", "lightgray")
# Similarity between two identical distributions
below &lt;- measureSimil(d1 = rnorm(1000000, mean = 0, 1),
                       d2 = rnorm(1000000, mean = 0, 1),
                       main = "Comp. similarity",
                       colors = colors)
legend(x = "topright", legend = round(below, digits = 2))
# Similarity in two distributions partially overlapping
below &lt;- measureSimil(d1 = rnorm(1000000, mean = 3, 1),
                       d2 = rnorm(1000000, mean = 0, 1),
                       main = "Partial similarity",
                       colors = colors)
legend(x = "topright", legend = round(below, digits = 2))
# Similarity in two completely-different distributions
below &lt;- measureSimil(d1 = rnorm(1000000, mean = 8, 1),
                       d2 = rnorm(1000000, mean = 0, 1),
                       main = "Comp. dissimilarity",
                       colors = colors)
legend(x = "topright", legend = round(below, digits = 2))
# Don't plot, just return the intersection
measureSimil(d1 = rnorm(1000000, mean = 3, 1),
              d2 = rnorm(1000000, mean = 0, 1),
              plot = FALSE)

</code></pre>

<hr>
<h2 id='mswd.test'>Reduced chi-square test or mean square weighted deviation (mswd) test</h2><span id='topic+mswd.test'></span>

<h3>Description</h3>

<p>Reduced chi-square test or mean square weighted deviation (mswd) test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mswd.test(age, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mswd.test_+3A_age">age</code></td>
<td>
<p>A vector of age radiometric age estimates</p>
</td></tr>
<tr><td><code id="mswd.test_+3A_sd">sd</code></td>
<td>
<p>A vector of the standard deviation corresponding to each element in <code>age</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Ludwig (2003:646): &quot;By convention,  probabilities  of  fit  greater  than  0.05  are  generally
considered  as  arguably  satisfying  the  mathematical  assumptions  of  an  isochron,  while  lower
probabilities are generally taken as indicating the presence of “geological” scatter, and hence a significant
possibility of bias in the isochron age.&quot;.
The null hypothesis is that the isochron conditions hold.
</p>


<h3>Value</h3>

<p>A numeric vector of length one with the p-value corresponding to the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laventa)
# Do the age estimates for the boundaries of the Honda Group (i.e., samples at meters 56.4
# and 675.0) conform to the isochron hypothesis?
hondaIndex &lt;- which(laventa$elevation == 56.4 | laventa$elevation == 675.0) 
mswd.test(age = laventa$age[hondaIndex], sd = laventa$one_sigma[hondaIndex])
# The p-value is smaller than the nominal alpha of 0.05, so we can reject the null
# hypothesis of isochron conditions

# Do the age estimates for the samples JG-R 88-2 and JG-R 89-2 conform to the isochron hypothesis?
twoLevelsIndex &lt;- which(laventa$sample == "JG-R 89-2" | laventa$sample == "JG-R 88-2")
dataset &lt;- laventa[twoLevelsIndex, ]
# Remove the values 21 and 23 because of their abnormally large standard deviations
mswd.test(age = dataset$age[c(-21, -23)], sd = dataset$one_sigma[c(-21, -23)])
# The p-value is larger than the nominal alpha of 0.05, so we can
# not reject the null hypothesis of isochron conditions
</code></pre>

<hr>
<h2 id='stratCI'>stratCI: Estimate the confidence intervals of endpoints in
stratigraphic intervals</h2><span id='topic+stratCI'></span>

<h3>Description</h3>

<p>stratCI: Estimate the confidence intervals of endpoints in
stratigraphic intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratCI(times, method, nparams, C, endpoint, confidence, quantile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratCI_+3A_times">times</code></td>
<td>
<p>a vector of occurrences in time for which we want to
estimate the endpoints of the stratigraphic interval</p>
</td></tr>
<tr><td><code id="stratCI_+3A_method">method</code></td>
<td>
<p>a character describing which method to use, either
'Strauss-Sadler89' or 'Marshall94'.</p>
</td></tr>
<tr><td><code id="stratCI_+3A_nparams">nparams</code></td>
<td>
<p>A character indicating whether to estimate one or two
parameters, possible values are 'one.par' and 'two.par'.</p>
</td></tr>
<tr><td><code id="stratCI_+3A_c">C</code></td>
<td>
<p>numeric indicating the confidence level, e.g. 0.95</p>
</td></tr>
<tr><td><code id="stratCI_+3A_endpoint">endpoint</code></td>
<td>
<p>used only for nparams = 'one.par'. Possible values
are 'first' and 'last'.</p>
</td></tr>
<tr><td><code id="stratCI_+3A_confidence">confidence</code></td>
<td>
<p>the confidence interval level, usually 0.95.</p>
</td></tr>
<tr><td><code id="stratCI_+3A_quantile">quantile</code></td>
<td>
<p>the desired confidence level for a quantile representing
the brackets around the confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method='Strauss-Sadler89' we need to provide
&lsquo;nparams', 'C', and 'endpoint'. For method=&rsquo;Marshall94' we need to
provide 'confidence' and 'quantile'.
</p>


<h3>Value</h3>

<p>A named vector when using the 'Strauss-Sadler89' method, or
an unnamed vector when using the 'Marshall94' method.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(andes)
andes &lt;- andes$ages
# remove missing data
andes &lt;- andes[complete.cases(andes)]
# remove outliers
andes &lt;- sort(andes[which(andes &lt; 10)])
stratCI(andes, method="Strauss-Sadler89",
        nparams="one.par", C=0.95, endpoint="first")
stratCI(andes, method="Strauss-Sadler89",
        nparams="one.par", C=0.95, endpoint="last")
stratCI(andes, method="Strauss-Sadler89",
        nparams="two.par", C=0.95)
stratCI(andes, method="Marshall94", confidence = 0.95,
        quantile = 0.8)
stratCI(andes, method="Marshall94", confidence = 0.95,
        quantile = 0.95)

</code></pre>

<hr>
<h2 id='summaryBrlen'>summaryBrlen: Summarise branch lengths on trees with identical topology</h2><span id='topic+summaryBrlen'></span>

<h3>Description</h3>

<p>summaryBrlen: Summarise branch lengths on trees with identical topology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryBrlen(mphy, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryBrlen_+3A_mphy">mphy</code></td>
<td>
<p>An list of objects of class multiPhylo. If a single object in this
argument is of class multiPhylo, it is first enclosed in a list.</p>
</td></tr>
<tr><td><code id="summaryBrlen_+3A_method">method</code></td>
<td>
<p>A character with the function name for the summary to be applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used on the output of topofreq from the $trees element
in order to summarise the branch length on each topology set so that we have a single
tree summarising both topology and branch lengths. Useful for depicting posterior
tree density. Alternatively, it can be used with a single element provided that it is
first enclosed in a list
</p>


<h3>Value</h3>

<p>A tree of class phylo with summary branch lengths in tree$edge.length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
library(ape)
trl &lt;- ape::rmtree(10, 4)
tpf &lt;- topoFreq(unroot(trl), output="trees")
sumtrees &lt;- summaryBrlen(tpf$trees, method = "median")
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,3))
plot(sumtrees[[1]], type="unrooted", show.node.label=FALSE, cex=1.5)
plot(sumtrees[[2]], type="unrooted", show.node.label=FALSE, cex=1.5)
plot(sumtrees[[3]], type="unrooted", show.node.label=FALSE, cex=1.5)
par(oldpar)


</code></pre>

<hr>
<h2 id='table2nexus'>table2nexus: Read a data matrix in delimited format and convert
into a data matrix in nexus format</h2><span id='topic+table2nexus'></span>

<h3>Description</h3>

<p>table2nexus: Read a data matrix in delimited format and convert
into a data matrix in nexus format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table2nexus(
  path,
  datatype = c("standard", "dna", "rna", "protein"),
  header = FALSE,
  sep = ",",
  con = stdout()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table2nexus_+3A_path">path</code></td>
<td>
<p>a character vector of length 1 with the path to the table
file.</p>
</td></tr>
<tr><td><code id="table2nexus_+3A_datatype">datatype</code></td>
<td>
<p>a character vector of length 1 with the desired datatype.
Possible values are STANDARD, DNA, RNA, or PROTEIN.
Multicharacter types such as continuous or nucleotide are not supported.</p>
</td></tr>
<tr><td><code id="table2nexus_+3A_header">header</code></td>
<td>
<p>a logical vector of length 1 indicating whether the table file
has a header. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="table2nexus_+3A_sep">sep</code></td>
<td>
<p>a character vector of length 1 telling the kind of separator in
the table file. Defaults to comma &quot;,&quot;.</p>
</td></tr>
<tr><td><code id="table2nexus_+3A_con">con</code></td>
<td>
<p>the connection to which the matrix should be returned. Defaults
to stdout(), that is, return the text to the console. If writing to a file,
then this should be the path to the output file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will concatenate matrices in nexus format (mandatory) and write to the disk the output and summary information on the partitions. It requires that the input matrices all share the same taxa in the same positions.
</p>


<h3>Value</h3>

<p>This function writes to the connected required a matrix in nexus
format for a morphological dataset (that is, datatype=standard).
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this will return the matrix to the console rather than to a file
table2nexus(path="morpho.csv", datatype="standard", header=FALSE, sep=",")

## End(Not run)
</code></pre>

<hr>
<h2 id='tnt2newick'>tnt2newick: Function for converting from TNT tree format to newick parenthetical format</h2><span id='topic+tnt2newick'></span>

<h3>Description</h3>

<p>tnt2newick: Function for converting from TNT tree format to newick parenthetical format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnt2newick(
  file,
  output = NULL,
  string = NULL,
  return = FALSE,
  subsetting = FALSE,
  name.sep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnt2newick_+3A_file">file</code></td>
<td>
<p>A vector of type 'character' with the path to the original TNT tree file.</p>
</td></tr>
<tr><td><code id="tnt2newick_+3A_output">output</code></td>
<td>
<p>A vector of type 'character' with the path to output files to contain the tree in newick format.</p>
</td></tr>
<tr><td><code id="tnt2newick_+3A_string">string</code></td>
<td>
<p>A vector of type 'character' which can be either an object in memory or a string for interactive transformation, in TNT format. Use file in case your tree(s) are stored in a file instead.</p>
</td></tr>
<tr><td><code id="tnt2newick_+3A_return">return</code></td>
<td>
<p>A 'logical' expression indicating whether to write the newick tree(s) to a file in 'output' (if FALSE, the default), or whether to return to the screen (if TRUE), potentially to be stored in a vector via the '&lt;-' operator.</p>
</td></tr>
<tr><td><code id="tnt2newick_+3A_subsetting">subsetting</code></td>
<td>
<p>A vector of type 'logical' indicating whether subsetting (i.e., chopping at once the first and last line of the TNT tree file) should be done. Otherwise, explicit text replacements removing such lines are used. The default is false because it does not play well with multi-tree TNT files. Only use subsetting = TRUE if you are sure that there is only one tree in the file with the commands, tread and proc as first and last lines.</p>
</td></tr>
<tr><td><code id="tnt2newick_+3A_name.sep">name.sep</code></td>
<td>
<p>A vector of length 2 and type 'character' for carrying out separator conversion in the names of terminals. For instance, if the terminals have names composed of two words separated by an underscore (_) and you want them to be separated by space ( ) then use name.sep = c(&quot;_&quot;, &quot; &quot;). This does not support regular expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been tested for cases where only one tree is in the original tnt tree file. Please be careful with files containing multiple trees.
</p>


<h3>Value</h3>

<p>This function writes to the disk a text file containing the tree converted to newick format. Alternatively, it returns the output to the screen or writes it to an object in memory thanks to the argument 'string'.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tnt2newick(file = "someTrees.tre", return = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='topoFreq'>Frequency of topologies in a tree sample</h2><span id='topic+topoFreq'></span>

<h3>Description</h3>

<p>Frequency of topologies in a tree sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topoFreq(mphy, output = "index", maxtrees = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topoFreq_+3A_mphy">mphy</code></td>
<td>
<p>An object of class multiPhylo</p>
</td></tr>
<tr><td><code id="topoFreq_+3A_output">output</code></td>
<td>
<p>A character indicating whether the tree indices or the actual trees should be returned. Defaults to &quot;index&quot;</p>
</td></tr>
<tr><td><code id="topoFreq_+3A_maxtrees">maxtrees</code></td>
<td>
<p>A numeric indicating whether to warn about having more trees than the arbitrary threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used e.w. with a posterior sample of trees from a Bayesian analysis where we
want to explore the distribution of topologies in the posterior of trees. This way we can assess topological
uncertainty in a more meaningful way than using a majority-rule consensus.
</p>
<p>The use of 'maxtrees' is actually a convenience for keeping in mind that large amounts of trees can cause memory
issues. This can end up in situations which are difficult to debug but that from personal experience have come from
exactly that: More trees than memory can fit or which can be processed for calculating similarity. This number will _not_
break the function call but will return a warning. Try to avoid modifying its default value unless you are sure it will not
cause any issues under your computing conditions (e.g. when lots of trees are being processed but also large RAM is available).
</p>


<h3>Value</h3>

<p>A list with an element containing the the different tree clusters (as multiPhylo)
and the absolute, cumulative, and relative frequencies of each topology in the tree sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tests
set.seed(1)
library(ape)
trl &lt;- ape::rmtree(10, 4)
tpf &lt;- topoFreq(ape::unroot(trl), output="trees")

</code></pre>

<hr>
<h2 id='xintercept'>xintercept: Estimate the x-intercept of an empirical cdf</h2><span id='topic+xintercept'></span>

<h3>Description</h3>

<p>xintercept: Estimate the x-intercept of an empirical cdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xintercept(x, method, alpha = 0.05, p = c(0.025, 0.975), R = 1000, robust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xintercept_+3A_x">x</code></td>
<td>
<p>A vector of type numeric with time data points.</p>
</td></tr>
<tr><td><code id="xintercept_+3A_method">method</code></td>
<td>
<p>Either &quot;Draper-Smith&quot; or &quot;Bootstrap&quot;. The
function will fail otherwise.</p>
</td></tr>
<tr><td><code id="xintercept_+3A_alpha">alpha</code></td>
<td>
<p>A vector of length one and type numeric with
the nominal alpha value for the Draper-Smith method, defaults
to 0.05.</p>
</td></tr>
<tr><td><code id="xintercept_+3A_p">p</code></td>
<td>
<p>A vector of length two and type numeric with the
two-tail probability values for the CI. Defaults to 0.025
and 0.975.</p>
</td></tr>
<tr><td><code id="xintercept_+3A_r">R</code></td>
<td>
<p>The number of iterations to be used in the Bootstrap
method.</p>
</td></tr>
<tr><td><code id="xintercept_+3A_robust">robust</code></td>
<td>
<p>Logical value indicating whether to use robust
regression using 'Rfit::rfit' ('robust = TRUE') or ordinary
least squares 'lm' ('robust = FALSE').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take a vector of time points, calculate
the empirical cumulative density function, and regress its values
in order to infer the x-intercept and its confidence interval. For
plotting purposes, it will also return the x-y empirical cumulative
density values.
</p>


<h3>Value</h3>

<p>A named list with three elements: 'param', the value
of x_hat; 'ci', the lower and upper values of the confidence
interval on x; 'ecdfxy', the x and y points for the empirical
cumulative density curve.
</p>


<h3>Author(s)</h3>

<p>Gustavo A. Ballen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(andes)
ages &lt;- andes$ages
ages &lt;- ages[complete.cases(ages)] # remove NAs
ages &lt;- ages[which(ages &lt; 10)] # remove outliers


# Draper-Smith, OLS
draperSmithNormalX0 &lt;- xintercept(x = ages, method = "Draper-Smith", alpha = 0.05, robust = FALSE)
# Draper-Smith, Robust fit
draperSmithRobustX0 &lt;- xintercept(x = ages, method = "Draper-Smith", alpha = 0.05, robust = TRUE)
# Bootstrap, OLS
bootstrapNormalX0 &lt;- xintercept(x = ages, method = "Bootstrap", p = c(0.025, 0.975), robust = FALSE)
# Bootstrap, Robust fit
bootstrapRobustX0 &lt;- xintercept(x = ages, method = "Bootstrap", p = c(0.025, 0.975), robust = TRUE)
# plot the estimations
hist(ages, probability = TRUE, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.3),
     xlim = c(0, 10), main = "CDF-based on confidence intervals", xlab = "Age (Ma)")
# plot the lines for the estimator of Draper and Smith using lm
arrows(x0 = draperSmithNormalX0$ci["upper"], y0 = 0.025, x1 = draperSmithNormalX0$ci["lower"],
       y1 = 0.025, code = 3, angle = 90, length = 0.1, lwd = 3, col = "darkblue")
# plot the lines for the estimator of Draper and Smith using rfit
arrows(x0 = draperSmithRobustX0$ci["upper"], y0 = 0.05, x1 = draperSmithRobustX0$ci["lower"],
       y1 = 0.05, code = 3, angle = 90, length = 0.1, lwd = 3, col = "darkgreen")
# plot the lines for the estimator based on bootstrap
arrows(x0 = bootstrapRobustX0$ci["upper"], y0 = 0.075, x1 = bootstrapRobustX0$ci["lower"],
       y1 = 0.075, code = 3, angle = 90, length = 0.1, lwd = 3, col = "darkred")
# plot a legend
legend(x = "topright", legend = c("Draper and Smith with lm", "Draper and Smith with rfit",
                                  "Bootstrap on x0"),
       col = c("darkblue", "darkgreen", "darkred"),  lty = 1, lwd = 3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
