<!DOCTYPE html><html lang="en"><head><title>Help for package PAFit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PAFit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PAFit-package'><p>Generative Mechanism Estimation in Temporal Complex Networks</p></a></li>
<li><a href='#as.PAFit_net'>
<p>Converting an edgelist matrix to a PAFit_net object</p></a></li>
<li><a href='#Coauthorship+20network+20of+20scientists+20in+20the+20field+20of+20complex+20networks'><p>A collaboration network between authors of papers in the field of complex networks with article time-stamps</p></a></li>
<li><a href='#from_igraph'>
<p>Convert an igraph object to a PAFit_net object</p></a></li>
<li><a href='#from_networkDynamic'>
<p>Convert a networkDynamic object to a PAFit_net object</p></a></li>
<li><a href='#generate_BA'>
<p>Simulating networks from the generalized Barabasi-Albert model</p></a></li>
<li><a href='#generate_BB'>
<p>Simulating networks from the Bianconi-Barabasi model</p></a></li>
<li><a href='#generate_ER'>
<p>Simulating networks from the Erdos-Renyi model</p></a></li>
<li><a href='#generate_fit_only'>
<p>Simulating networks from the Caldarelli model</p></a></li>
<li><a href='#generate_net'>
<p>Simulating networks from preferential attachment and fitness mechanisms</p></a></li>
<li><a href='#generate_simulated_data_from_estimated_model'>
<p>Generating simulated data from a fitted model</p></a></li>
<li><a href='#get_statistics'>
<p>Getting summarized statistics from input data</p></a></li>
<li><a href='#graph_from_file'>
<p>Read file to a PAFit_net object</p></a></li>
<li><a href='#graph_to_file'>
<p>Write the graph in a PAFit_net object to file</p></a></li>
<li><a href='#Jeong'>
<p>Jeong's method for estimating  the preferential attachment function</p></a></li>
<li><a href='#joint_estimate'>
<p>Joint inference of attachment function and node fitnesses</p></a></li>
<li><a href='#Newman'>
<p>Corrected Newman's method for estimating the preferential attachment function</p></a></li>
<li><a href='#only_A_estimate'>
<p>Estimating the attachment function in isolation by PAFit method</p></a></li>
<li><a href='#only_F_estimate'>
<p>Estimating node fitnesses in isolation</p></a></li>
<li><a href='#PAFit_oneshot'>
<p>Estimating the nonparametric preferential attachment function from one single snapshot.</p></a></li>
<li><a href='#plot_contribution'>
<p>Plotting contributions calculated from the observed data and contributions calculated from simulated data</p></a></li>
<li><a href='#plot.Full_PAFit_result'>
<p>Plotting the estimated attachment function and node fitness</p></a></li>
<li><a href='#plot.PA_result'>
<p>Plotting the estimated attachment function</p></a></li>
<li><a href='#plot.PAFit_net'>
<p>Plot a <code>PAFit_net</code> object</p></a></li>
<li><a href='#plot.PAFit_result'>
<p>Plotting the estimated attachment function and node fitness of a <code>PAFit_result</code> object</p></a></li>
<li><a href='#print.CV_Data'>
<p>Printing simple information of the cross-validation data</p></a></li>
<li><a href='#print.CV_Result'>
<p>Printing simple information of the cross-validation result</p></a></li>
<li><a href='#print.Full_PAFit_result'>
<p>printing information on the estimation result</p></a></li>
<li><a href='#print.PA_result'>
<p>Printing information of the estimated attachment function</p></a></li>
<li><a href='#print.PAFit_data'>
<p>Printing simple information on the statistics of the network stored in a <code>PAFit_data</code> object</p></a></li>
<li><a href='#print.PAFit_net'>
<p>Printing simple information of a <code>PAFit_net</code> object</p></a></li>
<li><a href='#print.PAFit_result'>
<p>printing information on the estimation result stored in a <code>PAFit_result</code> object</p></a></li>
<li><a href='#summary.CV_Data'>
<p>Printing summary information of the cross-validation data</p></a></li>
<li><a href='#summary.CV_Result'>
<p>Output summary information of the cross-validation result</p></a></li>
<li><a href='#summary.Full_PAFit_result'>
<p>Summary information on the estimation result</p></a></li>
<li><a href='#summary.PA_result'>
<p>Summary of the estimated attachment function</p></a></li>
<li><a href='#summary.PAFit_data'>
<p>Output summary information on the statistics of the network stored in a <code>PAFit_data</code> object</p></a></li>
<li><a href='#summary.PAFit_net'>
<p>Summary information of a <code>PAFit_net</code> object</p></a></li>
<li><a href='#summary.PAFit_result'>
<p>Output summary information on the estimation result stored in a <code>PAFit_result</code> object</p></a></li>
<li><a href='#test_linear_PA'>
<p>Fitting various distributions to a degree vector</p></a></li>
<li><a href='#to_igraph'>
<p>Convert a PAFit_net object to an igraph object</p></a></li>
<li><a href='#to_networkDynamic'>
<p>Convert a PAFit_net object to a networkDynamic object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generative Mechanism Estimation in Temporal Complex Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Thong Pham, Paul Sheridan, Hidetoshi Shimodaira</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thong Pham &lt;thongphamthe@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical methods for estimating preferential attachment and node fitness generative mechanisms in temporal complex networks are provided. Thong Pham et al. (2015) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0137796">doi:10.1371/journal.pone.0137796</a>&gt;. Thong Pham et al. (2016) &lt;<a href="https://doi.org/10.1038%2Fsrep32558">doi:10.1038/srep32558</a>&gt;. Thong Pham et al. (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v092.i03">doi:10.18637/jss.v092.i03</a>&gt;. Thong Pham et al. (2021) &lt;<a href="https://doi.org/10.1093%2Fcomnet%2Fcnab024">doi:10.1093/comnet/cnab024</a>&gt;.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thongphamthe/PAFit">https://github.com/thongphamthe/PAFit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thongphamthe/PAFit/issues">https://github.com/thongphamthe/PAFit/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.3) , grDevices, graphics, stats, RColorBrewer,
VGAM, MASS, magicaxis, networkDynamic, network, plyr, igraph,
mapproj, knitr, methods, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 17:02:13 UTC; thong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PAFit-package'>Generative Mechanism Estimation in Temporal Complex Networks</h2><span id='topic+PAFit-package'></span><span id='topic+PAFit'></span>

<h3>Description</h3>

<p>A package for estimating preferential attachment and node fitness generative mechanisms in temporal complex networks. References: Thong Pham et al. (2015) &lt;10.1371/journal.pone.0137796&gt;, Thong Pham et al. (2016) &lt;doi:10.1038/srep32558&gt;, Thong Pham et al. (2020) &lt;doi:10.18637/jss.v092.i03&gt;, Thong Pham et al. (2021) &lt;doi:10.1093/comnet/cnab024&gt;.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PAFit</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.10</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors: </td><td style="text-align: left;"> Thong Pham, Paul Sheridan, Hidetoshi Shimodaira</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a></td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The PAFit package provides a comprehensive framework to deal with growth mechanisms of temporal complex networks. In particular, it implements functions to simulate various temporal network models, gather essential network statistics from raw input data, and use these summarized statistics in the estimation of the attachment function <code class="reqn">A_k</code> and node fitnesses <code class="reqn">\eta_i</code>. The heavy computational parts of the package are implemented in <code>C++</code> through the use of the Rcpp package. Furthermore, users with a multi-core machine can enjoy a hassle-free speed up through OpenMP parallelization mechanisms implemented in the code. Apart from the main functions, the package also includes a real-world collaboration network dataset between scientists in the field of complex networks (<code><a href="#topic+coauthor.net">coauthor.net</a></code>). The main package functionalities are as follows. 
</p>
<p>Firstly, most well-known temporal network models based on the preferential attachment (PA) and node fitness mechanisms can be easily simulated using the package. PAFit implements <code><a href="#topic+generate_BA">generate_BA</a></code> for the Barabási-Albert (BA) model, <code><a href="#topic+generate_ER">generate_ER</a></code> for the growing Erdős–Rényi (ER) model, <code><a href="#topic+generate_BB">generate_BB</a></code> for the Bianconi-Barabási (BB) model and <code><a href="#topic+generate_fit_only">generate_fit_only</a></code> for the Caldarelli model. These functions have many customizable options, for example the number of new edges at each time-step are tunable stochastic variables. They are actually wrappers of the more powerful <code><a href="#topic+generate_net">generate_net</a></code> function, which simulates networks with more flexible attachment function and node fitness settings.
</p>
<p>Secondly, the function <code><a href="#topic+get_statistics">get_statistics</a></code> efficiently collects all temporal network summary statistics. We note that <code><a href="#topic+get_statistics">get_statistics</a></code> automatically handles both directed and undirected networks. It returns a list containing many statistics that can be used to characterize the network growth process. Notable fields are <code>m_tk</code> containing the number of new edges that connect to a degree-<code class="reqn">k</code> node at time-step <code class="reqn">t</code>, and <code>node_degree</code> containing the degree sequence, i.e., the degree of each node at each time-step.
</p>
<p>The most important functionality of the package is estimating the attachment function and node fitnesses of a temporal network. This is implemented through various methods. There are three usages: estimation of the attachment function in isolation, estimation of the node fitnesses in isolation, and the joint estimation of the attachment function and node fitnesses. 
</p>

<ul>
<li><p> The functions for estimating the attachment function in isolation are: <code><a href="#topic+Jeong">Jeong</a></code> for Jeong's method (Ref. 1), <code><a href="#topic+Newman">Newman</a></code> for Newman's method (Ref. 2), and <code><a href="#topic+only_A_estimate">only_A_estimate</a></code> for the PAFit method (Ref. 3). 
</p>
</li>
<li><p> For estimation of node fitnesses in isolation, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> implements a variant of the PAFit method (Ref. 4). 
</p>
</li>
<li><p> For the joint estimation of the attachment function and node fitnesses, we implement the full version of the PAFit method in <code><a href="#topic+joint_estimate">joint_estimate</a></code> (Ref. 4). 
</p>
</li>
<li><p> For estimating the nonparametric attachment function from a single snapshot, use <code><a href="#topic+PAFit_oneshot">PAFit_oneshot</a></code> (Ref. 6).
</p>
</li></ul>

<p>Excluding <code><a href="#topic+PAFit_oneshot">PAFit_oneshot</a></code>, the input of the remaining functions is the output object of the function <code><a href="#topic+get_statistics">get_statistics</a></code>. The output object of these functions contains the estimation results as well as some additional information pertaining to the estimation process. The estimated attachment function and/or node fitnesses can be plotted by using the <code>plot</code> command directly on this output object. This will visualize not only the estimated results but also the remaining uncertainties when possible.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>, Paul Sheridan, and Hidetoshi Shimodaira. 
</p>


<h3>References</h3>

<p>1. Jeong, H., Néda, Z. &amp; Barabási, A. (2003). Measuring Preferential Attachment in Evolving Networks. <em>Europhysics Letters</em> 61(61):567-572. (<a href="https://doi.org/10.1209/epl/i2003-00166-9">doi:10.1209/epl/i2003-00166-9</a>).
</p>
<p>2. Newman, M. (2001). Clustering and Preferential Attachment in Growing Networks. <em>Physical Review E</em> 64(2):025102. (<a href="https://doi.org/10.1103/PhysRevE.64.025102">doi:10.1103/PhysRevE.64.025102</a>).
</p>
<p>3. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. <em>PLOS ONE</em> 10(9):e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>4. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. <em>Scientific Reports</em> 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>
<p>5. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2020). PAFit: An R Package for the Non-Parametric Estimation of Preferential Attachment and Node Fitness in Temporal Complex Networks. <em>Journal of Statistical Software</em> 92 (3). (<a href="https://doi.org/10.18637/jss.v092.i03">doi:10.18637/jss.v092.i03</a>)
</p>
<p>6. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2021). Non-parametric estimation of the preferential attachment function from one network snapshot. Journal of Complex Networks 9(5): cnab024. (<a href="https://doi.org/10.1093/comnet/cnab024">doi:10.1093/comnet/cnab024</a>).
</p>


<h3>See Also</h3>

<p>See the accompanying vignette for a tutorial.
</p>
<p>See also the <a href="https://github.com/thongphamthe/PAFit">GitHub page</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Jointly estimate the attachment function and node fitnesses
   library("PAFit")
   set.seed(1)
  # a Bianconi-Barabasi network 
  # size of initial network = 100
  # number of new nodes at each time-step = 100
  # Ak = k; inverse variance of distribution of fitness: s = 10
  net        &lt;- generate_BB(N        = 1000 , m             = 10 , 
                            num_seed = 100  , multiple_node = 100,
                            s        = 10)
  net_stats  &lt;- get_statistics(net)
  
  #Joint estimation of attachment function Ak and node fitness
  result     &lt;- joint_estimate(net, net_stats)
  
  summary(result)
  
  # plot the estimated attachment function
  plot(result, net_stats)
  
  # true function
  true_A     &lt;- pmax(result$estimate_result$center_k,1)
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  #plot distribution of estimated node fitnesses
  plot(result, net_stats, plot = "f")
  
  #plot the estimated node fitnesses and true node fitnesses
  plot(result, net_stats, true = net$fitness, plot = "true_f")

## End(Not run)
</code></pre>

<hr>
<h2 id='as.PAFit_net'>
Converting an edgelist matrix to a PAFit_net object
</h2><span id='topic+as.PAFit_net'></span>

<h3>Description</h3>

<p>This function converts a graph stored in an edgelist matrix format to a <code>PAFit_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PAFit_net(graph, type = "directed", PA = NULL, fitness = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.PAFit_net_+3A_graph">graph</code></td>
<td>

<p>An edgelist matrix. Each row is assumed to be of the form (<code>from_node_id</code> <code>to_node_id</code> <code>time_stamp</code>). For a directed network ,<code>from_node_id</code> is the id of the source node and <code>to_node_id</code> is the id of the destination node. For an undirected network, the order is ignored and <code>from_node_id</code> and <code>to_node_id</code> are the ids of two ends. <code>time_stamp</code> is the arrival time of the edge. <code>from_node_id</code> and <code>to_node_id</code> are assumed to be integers that are at least <code class="reqn">0</code>. The whole ids need not to be contiguous.
</p>
<p>To register a new node <code class="reqn">i</code> at time <code class="reqn">t</code> without any edge, add a row with format (<code>i -1 t</code>). This works for both undirected and directed networks.
</p>
<p><code>time_stamp</code> can be either numeric or string. The value of a time-stamp can be arbitrary, but we assume that a smaller time_stamp (regarded so by the <code>sort</code> function in <code>R</code>) represents an earlier arrival time. Examples of time-stamps that satisfy this assumption are the integer <code>0:T</code>, the string format &lsquo;yyyy-mm-dd&rsquo;, and the POSIX time.
</p>
</td></tr>
<tr><td><code id="as.PAFit_net_+3A_type">type</code></td>
<td>

<p>String. Indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.
</p>
</td></tr>
<tr><td><code id="as.PAFit_net_+3A_pa">PA</code></td>
<td>

<p>Numeric vector. Contains the PA function. Default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="as.PAFit_net_+3A_fitness">fitness</code></td>
<td>

<p>Numeric vector. Contains node fitnesses. Default value is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PAFit_net</code>
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
# a network from Bianconi-Barabasi model
net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
as.PAFit_net(net$graph)
</code></pre>

<hr>
<h2 id='Coauthorship+20network+20of+20scientists+20in+20the+20field+20of+20complex+20networks'>A collaboration network between authors of papers in the field of complex networks with article time-stamps</h2><span id='topic+ComplexNetCoauthor'></span><span id='topic+coauthor.net'></span><span id='topic+coauthor.truetime'></span><span id='topic+coauthor.author_id'></span>

<h3>Description</h3>

<p>The dataset is collaboration network of authors of network science articles with article time-stamps. An edge between two authors represents an article in common. Time stamps denote article publication dates. The network without time-stamps was compiled by Mark Newman in May 2006 from the bibliographies of two review articles on networks, M. E. J. Newman, SIAM Review 45, 167-256 (2003) and S. Boccaletti et al., Physics Reports 424, 175-308 (2006), with a few additional references added by hand. Paul Sheridan independently supplemented the network with time-stamps and some basic metadata in June 2015. The network is undirected with monthly resolution, and contains no duplicated edges. <code>coauthor.net</code> contains the network. <code>coauthor.truetime</code> contains the real times of processed time-stamps. Finally <code>coauthor.author_id</code> contains author names.  
</p>
<p>Reference: M. E. J. Newman, Finding community structure in networks using the eigenvectors of matrices, Preprint physics/0605087 (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ComplexNetCoauthor)</code></pre>


<h3>Format</h3>

<p><code>coauthor.net</code> is a matrix with 2849 rows and 3 columns. Each row is an edge with the format (author id 1, author id 2, time_stamp). <code>coauthor.truetime</code> is a two-column matrix whose each row is (time_stamp, real time). <code>coauthor.author_id</code> is a two-column matrix whose each row is (author id, author name).</p>


<h3>Source</h3>

<p>https://www.paulsheridan.net/files/collabnet.zip</p>

<hr>
<h2 id='from_igraph'>
Convert an igraph object to a PAFit_net object
</h2><span id='topic+from_igraph'></span>

<h3>Description</h3>

<p>This function converts an <code>igraph</code> object (of package <span class="pkg">igraph</span>) to a <code>PAFit_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  from_igraph(net)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from_igraph_+3A_net">net</code></td>
<td>

<p>An object of class <code>igraph</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>PAFit_net</code> object.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # a network from Bianconi-Barabasi model
  net          &lt;- generate_BB(N = 50 , m = 10 , s = 10)
  igraph_graph &lt;- to_igraph(net)
  back         &lt;- from_igraph(igraph_graph)
</code></pre>

<hr>
<h2 id='from_networkDynamic'>
Convert a networkDynamic object to a PAFit_net object
</h2><span id='topic+from_networkDynamic'></span>

<h3>Description</h3>

<p>This function converts a <code>networkDynamic</code> object (of package <span class="pkg">networkDynamic</span>) to a <code>PAFit_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  from_networkDynamic(net)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from_networkDynamic_+3A_net">net</code></td>
<td>

<p>An object of class <code>networkDynamic</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>PAFit_net</code> object.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
# a network from Bianconi-Barabasi model
net          &lt;- generate_BB(N = 50 , m = 10 , s = 10)
nD_graph     &lt;- to_networkDynamic(net)
back         &lt;- from_networkDynamic(nD_graph)
</code></pre>

<hr>
<h2 id='generate_BA'>
Simulating networks from the generalized Barabasi-Albert model</h2><span id='topic+generate_BA'></span>

<h3>Description</h3>

<p>This function generates networks from the generalized Barabási-Albert model. In this model, the preferential attachment function is power-law, i.e. <code class="reqn">A_k = k^\alpha</code>, and node fitnesses are all equal to <code class="reqn">1</code>. It is a wrapper of the more powerful function <code><a href="#topic+generate_net">generate_net</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_BA(N              = 1000, 
            num_seed       = 2   , 
            multiple_node  = 1   , 
            m              = 1   ,
            alpha          = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_BA_+3A_n">N</code></td>
<td>

<p>Integer. Total number of nodes in the network (including the nodes in the seed graph). Default value is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="generate_BA_+3A_num_seed">num_seed</code></td>
<td>

<p>Integer. The number of nodes of the seed graph (the initial state of the network). The seed graph is a cycle. Default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="generate_BA_+3A_multiple_node">multiple_node</code></td>
<td>

<p>Positive integer. The number of new nodes at each time-step. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_BA_+3A_m">m</code></td>
<td>

<p>Positive integer. The number of edges of each new node. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_BA_+3A_alpha">alpha</code></td>
<td>

<p>Numeric. This is the attachment exponent in the attachment function <code class="reqn">A_k = k^\alpha</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>PAFit_net</code> object, which is a List contains the following four fields:
</p>
<table role = "presentation">
<tr><td><code>graph</code></td>
<td>
<p>a three-column matrix, where each row contains information of one edge, in the form of <code>(from_id, to_id, time_stamp)</code>. <code>from_id</code> is the id of the source, <code>to_id</code> is the id of the destination.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.</p>
</td></tr>
<tr><td><code>PA</code></td>
<td>
<p>a numeric vector contains the true PA function.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>fitness values of nodes in the network. The fitnesses are all equal to <code class="reqn">1</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Albert, R. &amp; Barabási, A. (1999). Emergence of scaling in random networks. Science, 286,509–512 (<a href="https://www.science.org/doi/10.1126/science.286.5439.509">https://www.science.org/doi/10.1126/science.286.5439.509</a>).
</p>


<h3>See Also</h3>

<p>For subsequent estimation procedures, see <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
<p>For other functions to generate networks, see <code><a href="#topic+generate_net">generate_net</a></code>, <code><a href="#topic+generate_ER">generate_ER</a></code>, <code><a href="#topic+generate_BB">generate_BB</a></code> and <code><a href="#topic+generate_fit_only">generate_fit_only</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # generate a network from the BA model with alpha = 1, N = 100, m = 1
  net &lt;- generate_BA(N = 100)
  str(net)
  plot(net)
</code></pre>

<hr>
<h2 id='generate_BB'>
Simulating networks from the Bianconi-Barabasi model</h2><span id='topic+generate_BB'></span>

<h3>Description</h3>

<p>This function generates networks from the Bianconi-Barabási model. It is a &lsquo;preferential attachment with fitness&rsquo; model. In this model, the preferential attachment function is linear, i.e. <code class="reqn">A_k = k</code>, and node fitnesses are sampled from some probability distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_BB(N              = 1000   , 
            num_seed       = 2      , 
            multiple_node  = 1      , 
            m              = 1      ,
            mode_f         = "gamma", 
            s              = 10     )
</code></pre>


<h3>Arguments</h3>

<p>The parameters can be divided into two groups. 
</p>
<p>The first group specifies basic properties of the network:
</p>
<table role = "presentation">
<tr><td><code id="generate_BB_+3A_n">N</code></td>
<td>

<p>Integer. Total number of nodes in the network (including the nodes in the seed graph). Default value is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="generate_BB_+3A_num_seed">num_seed</code></td>
<td>

<p>Integer. The number of nodes of the seed graph (the initial state of the network). The seed graph is a cycle. Default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="generate_BB_+3A_multiple_node">multiple_node</code></td>
<td>

<p>Positive integer. The number of new nodes at each time-step. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_BB_+3A_m">m</code></td>
<td>

<p>Positive integer. The number of edges of each new node. Default value is <code>1</code>.
</p>
</td></tr>
</table>
<p>The final group of parameters specifies the distribution from which node fitnesses are generated:
</p>
<table role = "presentation">
<tr><td><code id="generate_BB_+3A_mode_f">mode_f</code></td>
<td>

<p>String. Possible values:<code>"gamma"</code>, <code>"log_normal"</code> or <code>"power_law"</code>. This parameter indicates the true distribution for node fitness. <code>"gamma"</code> = gamma distribution, <code>"log_normal"</code> = log-normal distribution. <code>"power_law"</code> = power-law (pareto) distribution. Default value is &quot;gamma&quot;.
</p>
</td></tr>
<tr><td><code id="generate_BB_+3A_s">s</code></td>
<td>

<p>Non-negative numeric. The inverse variance parameter. The mean of the distribution is kept at <code class="reqn">1</code> and the variance is <code class="reqn">1/s</code> (since node fitnesses are only meaningful up to scale). This is achieved by setting shape and rate parameters of the Gamma distribution to <code class="reqn">s</code>; setting mean and standard deviation in log-scale of the log-normal distribution to <code class="reqn">-1/2*log (1/s + 1)</code> and <code class="reqn">(log (1/s + 1))^{0.5}</code>; and setting shape and scale parameters of the pareto distribution to <code class="reqn">(s+1)^{0.5} + 1</code> and <code class="reqn">(s+1)^{0.5}/((s+1)^{0.5} + 1)</code>. If <code>s</code> is <code>0</code>, all node fitnesses <code class="reqn">\eta</code> are fixed at <code>1</code> (i.e., Barabási-Albert model). The default value is <code>10</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>PAFit_net</code> object, which is a List contains the following four fields:
</p>
<table role = "presentation">
<tr><td><code>graph</code></td>
<td>
<p>a three-column matrix, where each row contains information of one edge, in the form of <code>(from_id, to_id, time_stamp)</code>. <code>from_id</code> is the id of the source, <code>to_id</code> is the id of the destination.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.</p>
</td></tr>
<tr><td><code>PA</code></td>
<td>
<p>a numeric vector contains the true PA function.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>fitness values of nodes in the network. The name of each value is the ID of the node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Bianconni, G. &amp; Barabási, A. (2001). Competition and multiscaling in evolving networks. Europhys. Lett., 54, 436 (<a href="https://doi.org/10.1209/epl/i2001-00260-6">doi:10.1209/epl/i2001-00260-6</a>).
</p>


<h3>See Also</h3>

<p>For subsequent estimation procedures, see <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
<p>For other functions to generate networks, see <code><a href="#topic+generate_net">generate_net</a></code>, <code><a href="#topic+generate_BA">generate_BA</a></code>, <code><a href="#topic+generate_ER">generate_ER</a></code> and <code><a href="#topic+generate_fit_only">generate_fit_only</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # generate a network from the BB model with alpha = 1, N = 100, m = 1
  # The inverse variance of the Gamma distribution of node fitnesses is s = 10
  net &lt;- generate_BB(N = 100,m = 1,mode = 1, s = 10)
  str(net)
  plot(net)
</code></pre>

<hr>
<h2 id='generate_ER'>
Simulating networks from the Erdos-Renyi model</h2><span id='topic+generate_ER'></span>

<h3>Description</h3>

<p>This function generates networks from the Erdős–Rényi model. In this model, the preferential attachment function is a constant function, i.e. <code class="reqn">A_k = 1</code>, and node fitnesses are all equal to <code class="reqn">1</code>. It is a wrapper of the more powerful function <code><a href="#topic+generate_net">generate_net</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generate_ER(N              = 1000, 
              num_seed       = 2   , 
              multiple_node  = 1   , 
              m              = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_ER_+3A_n">N</code></td>
<td>

<p>Integer. Total number of nodes in the network (including the nodes in the seed graph). Default value is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="generate_ER_+3A_num_seed">num_seed</code></td>
<td>

<p>Integer. The number of nodes of the seed graph (the initial state of the network). The seed graph is a cycle. Default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="generate_ER_+3A_multiple_node">multiple_node</code></td>
<td>

<p>Positive integer. The number of new nodes at each time-step. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_ER_+3A_m">m</code></td>
<td>

<p>Positive integer. The number of edges of each new node. Default value is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>PAFit_net</code> object, which is a List contains the following four fields:
</p>
<table role = "presentation">
<tr><td><code>graph</code></td>
<td>
<p>a three-column matrix, where each row contains information of one edge, in the form of <code>(from_id, to_id, time_stamp)</code>. <code>from_id</code> is the id of the source, <code>to_id</code> is the id of the destination.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.</p>
</td></tr>
<tr><td><code>PA</code></td>
<td>
<p>a numeric vector contains the true PA function.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>fitness values of nodes in the network. The fitnesses are all equal to <code class="reqn">1</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Erdös P. &amp; Rényi A.. On random graphs. Publicationes Mathematicae Debrecen. 1959;6:290–297 (<a href="https://snap.stanford.edu/class/cs224w-readings/erdos59random.pdf">https://snap.stanford.edu/class/cs224w-readings/erdos59random.pdf</a>).
</p>


<h3>See Also</h3>

<p>For subsequent estimation procedures, see <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
<p>For other functions to generate networks, see <code><a href="#topic+generate_net">generate_net</a></code>, <code><a href="#topic+generate_BA">generate_BA</a></code>, <code><a href="#topic+generate_BB">generate_BB</a></code> and <code><a href="#topic+generate_fit_only">generate_fit_only</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # generate a network from the ER model with N = 1000 nodes
  net &lt;- generate_ER(N = 1000)
  str(net)
  plot(net)
</code></pre>

<hr>
<h2 id='generate_fit_only'>
Simulating networks from the Caldarelli model</h2><span id='topic+generate_fit_only'></span>

<h3>Description</h3>

<p>This function generates networks from the Caldarelli model. In this model, the preferential attachment function is constant, i.e. <code class="reqn">A_k = 1</code>, and node fitnesses are sampled from some probability distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_fit_only(N             = 1000   , 
                 num_seed       = 2      , 
                 multiple_node  = 1      , 
                 m              = 1      ,
                 mode_f         = "gamma", 
                 s              = 10     )
</code></pre>


<h3>Arguments</h3>

<p>The parameters can be divided into two groups. 
</p>
<p>The first group specifies basic properties of the network:
</p>
<table role = "presentation">
<tr><td><code id="generate_fit_only_+3A_n">N</code></td>
<td>

<p>Integer. Total number of nodes in the network (including the nodes in the seed graph). Default value is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="generate_fit_only_+3A_num_seed">num_seed</code></td>
<td>

<p>Integer. The number of nodes of the seed graph (the initial state of the network). The seed graph is a cycle. Default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="generate_fit_only_+3A_multiple_node">multiple_node</code></td>
<td>

<p>Positive integer. The number of new nodes at each time-step. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_fit_only_+3A_m">m</code></td>
<td>

<p>Positive integer. The number of edges of each new node. Default value is <code>1</code>.
</p>
</td></tr>
</table>
<p>The final group of parameters specifies the distribution from which node fitnesses are generated:
</p>
<table role = "presentation">
<tr><td><code id="generate_fit_only_+3A_mode_f">mode_f</code></td>
<td>

<p>String. Possible values:<code>"gamma"</code>, <code>"log_normal"</code> or <code>"power_law"</code>. This parameter indicates the true distribution for node fitness. <code>"gamma"</code> = gamma distribution, <code>"log_normal"</code> = log-normal distribution. <code>"power_law"</code> = power-law (pareto) distribution. Default value is &quot;gamma&quot;.
</p>
</td></tr>
<tr><td><code id="generate_fit_only_+3A_s">s</code></td>
<td>

<p>Non-negative numeric. The inverse variance parameter. The mean of the distribution is kept at <code class="reqn">1</code> and the variance is <code class="reqn">1/s</code> (since node fitnesses are only meaningful up to scale). This is achieved by setting shape and rate parameters of the Gamma distribution to <code class="reqn">s</code>; setting mean and standard deviation in log-scale of the log-normal distribution to <code class="reqn">-1/2*log (1/s + 1)</code> and <code class="reqn">(log (1/s + 1))^{0.5}</code>; and setting shape and scale parameters of the pareto distribution to <code class="reqn">(s+1)^{0.5} + 1</code> and <code class="reqn">(s+1)^{0.5}/((s+1)^{0.5} + 1)</code>. If <code>s</code> is <code>0</code>, all node fitnesses <code class="reqn">\eta</code> are fixed at <code>1</code> (i.e., Barabási-Albert model). The default value is <code>10</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>PAFit_net</code> object, which is a List contains the following four fields:
</p>
<table role = "presentation">
<tr><td><code>graph</code></td>
<td>
<p>a three-column matrix, where each row contains information of one edge, in the form of <code>(from_id, to_id, time_stamp)</code>. <code>from_id</code> is the id of the source, <code>to_id</code> is the id of the destination.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.</p>
</td></tr>
<tr><td><code>PA</code></td>
<td>
<p>a numeric vector contains the true PA function.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>fitness values of nodes in the network. The name of each value is the ID of the node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Caldarelli, G., Capocci, A. , De Los Rios, P. &amp; Muñoz, M.A. (2002). Scale-Free Networks from Varying Vertex Intrinsic Fitness. Phys. Rev. Lett., 89, 258702 (<a href="https://doi.org/10.1103/PhysRevLett.89.258702">doi:10.1103/PhysRevLett.89.258702</a>).
</p>


<h3>See Also</h3>

<p>For subsequent estimation procedures, see <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
<p>For other functions to generate networks, see <code><a href="#topic+generate_net">generate_net</a></code>, <code><a href="#topic+generate_BA">generate_BA</a></code>, <code><a href="#topic+generate_ER">generate_ER</a></code> and <code><a href="#topic+generate_BB">generate_BB</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # generate a network from the Caldarelli model with alpha = 1, N = 100, m = 1
  # the inverse variance of distribution of node fitnesses is s = 10
  net &lt;- generate_fit_only(N = 100,m = 1,mode = 1, s = 10)
  str(net)
  plot(net)
</code></pre>

<hr>
<h2 id='generate_net'>
Simulating networks from preferential attachment and fitness mechanisms</h2><span id='topic+generate_net'></span>

<h3>Description</h3>

<p>This function generates networks from the General Temporal model, a generative temporal network model that includes many well-known models such as the Erdős–Rényi model, the Barabási-Albert model or the Bianconi-Barabási model as special cases. This function also includes some flexible mechanisms to vary the number of new nodes and new edges at each time-step in order to generate realistic networks. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_net (N                 = 1000   , 
             num_seed           = 2      , 
             multiple_node      = 1      , 
             specific_start     = NULL   ,
             m                  = 1      ,
             prob_m             = FALSE  ,
             increase           = FALSE  , 
             log                = FALSE  , 
             no_new_node_step   = 0      ,
             m_no_new_node_step = m      ,
             custom_PA          = NULL   ,
             mode               = 1      , 
             alpha              = 1      , 
             beta               = 2      , 
             sat_at             = 100    ,
             offset             = 1      ,
             mode_f             = "gamma", 
             s                  = 10       )
</code></pre>


<h3>Arguments</h3>

<p>The parameters can be divided into four groups. 
</p>
<p>The first group specifies basic properties of the network:
</p>
<table role = "presentation">
<tr><td><code id="generate_net_+3A_n">N</code></td>
<td>

<p>Integer. Total number of nodes in the network (including the nodes in the seed graph). Default value is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_num_seed">num_seed</code></td>
<td>

<p>Integer. The number of nodes of the seed graph (the initial state of the network). The seed graph is a cycle. Default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_multiple_node">multiple_node</code></td>
<td>

<p>Positive integer. The number of new nodes at each time-step. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_specific_start">specific_start</code></td>
<td>

<p>Positive Integer. If <code>specific_start</code> is specified, then all the time-steps from time-step <code>1</code> to <code>specific_start</code> are grouped to become the initial time-step in the final output. This option is usefull when we want to create a network with a large initial network that follows a scale-free degree distribution. Default value is <code>NULL</code>.
</p>
</td></tr>
</table>
<p>The second group specifies the number of new edges at each time-step:
</p>
<table role = "presentation">
<tr><td><code id="generate_net_+3A_m">m</code></td>
<td>

<p>Positive integer. The number of edges of each new node. Default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_prob_m">prob_m</code></td>
<td>

<p>Logical. Indicates whether we fix the number of edges of each new node as a constant, or let it follows a Poisson distribution. If <code>prob_m == TRUE</code>, the number of edges of each new node follows a Poisson distribution. The mean of this distribution depends on the value of <code>increase</code> and <code>log</code>. Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_increase">increase</code></td>
<td>

<p>Logical. Indicates whether we increase the mean of the Poisson distribution over time. If <code>increase == FALSE</code>, the mean is fixed at <code>m</code>. If <code>increase == TRUE</code>, the way the mean increases depends on the value of <code>log</code>. Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_log">log</code></td>
<td>

<p>Logical. Indicates how to increase the mean of the Poisson distribution. If <code>log == TRUE</code>, the mean increases logarithmically with the number of current nodes. If <code>log == FALSE</code>, the mean increases linearly with the number of current nodes. Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_no_new_node_step">no_new_node_step</code></td>
<td>

<p>Non-negative integer. The number of time-steps in which no new node is added, while new edges are added between existing nodes. Default value is <code>0</code>, i.e., new nodes are always added at each time-step.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_m_no_new_node_step">m_no_new_node_step</code></td>
<td>

<p>Positive integer. The number of new edges in the no-new-node steps. Default value is equal to <code>m</code>. Note that the number of new edges in the no-new-node steps is not effected by the parameters <code>increase</code> or <code>prob_m</code>; this number is always the constant specified by <code>m_no_new_node_step</code>.
</p>
</td></tr>
</table>
<p>The third group of parameters specifies the preferential attachment function:
</p>
<table role = "presentation">
<tr><td><code id="generate_net_+3A_custom_pa">custom_PA</code></td>
<td>

<p>Numeric vector. This is the user-input PA function: <code class="reqn">A_0, A_1,..., A_K</code>. If <code>custom_PA</code> is specified, then <code>mode</code> is ignored, and we grow the network using the PA function <code>custom_PA</code>. Degrees greater than <code class="reqn">K</code> will have attachment value <code class="reqn">A_k</code>. Default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_mode">mode</code></td>
<td>

<p>Integer. Indicates the parametric attachment function to be used in generating the network. If <code>mode == 1</code>, the attachment function is <code class="reqn">A_k = k^\alpha</code>. If <code>mode == 2</code>, the attachment function is <code class="reqn">A_k = min(k,sat.at)^\alpha</code>. If <code>mode == 3</code>, the attachment function is <code class="reqn">A_k = \alpha log (k)^\beta</code>. Default value is <code>1</code>.
</p>
</td></tr> 
<tr><td><code id="generate_net_+3A_alpha">alpha</code></td>
<td>

<p>Numeric. If <code>mode == 1</code>, this is the attachment exponent in the attachment function <code class="reqn">A_k = k^\alpha</code>. If <code>mode == 2</code>, this is the attachment exponenet in the attachment function <code class="reqn">A_k = min(k,sat.at)^\alpha</code>. If <code>mode == 3</code>, this is the <code class="reqn">\alpha</code> in the attachment function <code class="reqn">A_k = \alpha log (k)^\beta + 1</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_beta">beta</code></td>
<td>

<p>Numeric. This is the beta in the attachment function <code class="reqn">A_k = \alpha log (k)^\beta + 1</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_sat_at">sat_at</code></td>
<td>

<p>Integer. This is the saturation position <code class="reqn">sat.at</code> in the attachment function <code class="reqn">A_k = min(k,sat.at)^\alpha</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_offset">offset</code></td>
<td>

<p>Numeric. The attachment value of degree <code>0</code>. Default value is <code>1</code>.
</p>
</td></tr>
</table>
<p>The final group of parameters specifies the distribution from which node fitnesses are generated:
</p>
<table role = "presentation">
<tr><td><code id="generate_net_+3A_mode_f">mode_f</code></td>
<td>

<p>String. Possible values:<code>"gamma"</code>, <code>"log_normal"</code> or <code>"power_law"</code>. This parameter indicates the true distribution for node fitness. <code>"gamma"</code> = gamma distribution, <code>"log_normal"</code> = log-normal distribution. <code>"power_law"</code> = power-law (pareto) distribution. Default value is <code>"gamma"</code>.
</p>
</td></tr>
<tr><td><code id="generate_net_+3A_s">s</code></td>
<td>

<p>Non-negative numeric. The inverse variance parameter. The mean of the distribution is kept at <code class="reqn">1</code> and the variance is <code class="reqn">1/s</code> (since node fitnesses are only meaningful up to scale). This is achieved by setting shape and rate parameters of the Gamma distribution to <code class="reqn">s</code>; setting mean and standard deviation in log-scale of the log-normal distribution to <code class="reqn">-1/2*log (1/s + 1)</code> and <code class="reqn">(log (1/s + 1))^{0.5}</code>; and setting shape and scale parameters of the pareto distribution to <code class="reqn">(s+1)^{0.5} + 1</code> and <code class="reqn">(s+1)^{0.5}/((s+1)^{0.5} + 1)</code>. If <code>s</code> is <code>0</code>, all node fitnesses <code class="reqn">\eta</code> are fixed at <code>1</code> (i.e., Barabási-Albert model). The default value is <code>10</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>PAFit_net</code> object, which is a List contains the following four fields:
</p>
<table role = "presentation">
<tr><td><code>graph</code></td>
<td>
<p>a three-column matrix, where each row contains information of one edge, in the form of <code>(from_id, to_id, time_stamp)</code>. <code>from_id</code> is the id of the source, <code>to_id</code> is the id of the destination.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>.</p>
</td></tr>
<tr><td><code>PA</code></td>
<td>
<p>a numeric vector contains the true PA function.</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>fitness values of nodes in the network. The name of each value is the ID of the node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>See Also</h3>

<p>For subsequent estimation procedures, see <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
<p>For simpler functions to generate networks from well-known models, see <code><a href="#topic+generate_BA">generate_BA</a></code>, <code><a href="#topic+generate_ER">generate_ER</a></code>, <code><a href="#topic+generate_BB">generate_BB</a></code> and <code><a href="#topic+generate_fit_only">generate_fit_only</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
#Generate a network from the original BA model with alpha = 1, N = 100, m = 1
net &lt;- generate_net(N = 100,m = 1,mode = 1, alpha = 1, s = 0)
str(net)
plot(net)
</code></pre>

<hr>
<h2 id='generate_simulated_data_from_estimated_model'>
Generating simulated data from a fitted model  
</h2><span id='topic+generate_simulated_data_from_estimated_model'></span>

<h3>Description</h3>

<p>This function generates simulated networks from a fitted model and performs estimations on these simulated networks with the same setting used in the original estimation. Each simulated network is generated using parameters of the fitted model, while keeping other aspects of the growth process as faithfully as possible to the original observed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_simulated_data_from_estimated_model(net_object, net_stat, result, M = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_simulated_data_from_estimated_model_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the original network.
</p>
</td></tr>
<tr><td><code id="generate_simulated_data_from_estimated_model_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summarized statistics of the original network. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. 
</p>
</td></tr>
<tr><td><code id="generate_simulated_data_from_estimated_model_+3A_result">result</code></td>
<td>

<p>An object of class <code>Full_PAFit_result</code> which contains the fitted model obtained by applying the function <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>
</td></tr>
<tr><td><code id="generate_simulated_data_from_estimated_model_+3A_m">M</code></td>
<td>
<p>integer. The number of simulated networks. Default value is <code>5</code>.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Outputs a <code>Simulated_Data_From_Fitted_Model</code> object, which is a list containing the following fields:
</p>

<ul>
<li> <p><code>graph_list</code>: a list containing <code>M</code> simulated graphs.
</p>
</li>
<li> <p><code>stats_list</code>: a list containing <code>M</code> objects of class <code>PAFit_data</code>, which are the results of applying <code><a href="#topic+get_statistics">get_statistics</a></code> on the simulated graphs.
</p>
</li>
<li> <p><code>result_list</code>: a list containing <code>M</code> objects of class <code>Full_PAFit_result</code>, which are the results of applying <code><a href="#topic+joint_estimate">joint_estimate</a></code> on the simulated graphs.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. PLoS ONE 10(9): e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>2. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. Scientific Reports 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>
<p>3. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2020). PAFit: An R Package for the Non-Parametric Estimation of Preferential Attachment and Node Fitness in Temporal Complex Networks. Journal of Statistical Software 92 (3). (<a href="https://doi.org/10.18637/jss.v092.i03">doi:10.18637/jss.v092.i03</a>).
</p>
<p>4. Inoue, M., Pham, T. &amp; Shimodaira, H. (2020). Joint Estimation of Non-parametric Transitivity and Preferential Attachment Functions in Scientific Co-authorship Networks. Journal of Informetrics 14(3). (<a href="https://doi.org/10.1016/j.joi.2020.101042">doi:10.1016/j.joi.2020.101042</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_statistics">get_statistics</a></code>, <code><a href="#topic+joint_estimate">joint_estimate</a></code>, <code><a href="#topic+plot_contribution">plot_contribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  library("PAFit")
  net_object     &lt;- generate_net(N = 500, m = 10, s = 10, alpha = 0.5)
  net_stat       &lt;- get_statistics(net_object) 
  result         &lt;- joint_estimate(net_object, net_stat)
  simulated_data &lt;- generate_simulated_data_from_estimated_model(net_object, net_stat, result)
  plot_contribution(simulated_data, result, which_plot = "PA")
  plot_contribution(simulated_data, result, which_plot = "fit")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='get_statistics'>
Getting summarized statistics from input data  
</h2><span id='topic+get_statistics'></span><span id='topic+PAFit_data'></span>

<h3>Description</h3>

<p>The function summarizes input data into sufficient statistics for estimating the attachment function and node fitness, together with additional information about the data, such as total number of nodes, number of time-steps, maximum degree, and the final degree of the network, etc. .  It also provides mechanisms to automatically deal with very large datasets by binning the degree, setting a degree threshold, or grouping time-steps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_statistics(net_object, only_PA  = FALSE , 
               only_true_deg_matrix = FALSE ,
               binning              = TRUE  , g              = 50    , 
               deg_threshold        = 0     , 
               compress_mode        = 0     , compress_ratio = 0.5   , 
               custom_time          = NULL)
</code></pre>


<h3>Arguments</h3>

<p>The parameters can be divided into four groups. The first group specifies input data and how the data will be summarized:
</p>
<table role = "presentation">
<tr><td><code id="get_statistics_+3A_net_object">net_object</code></td>
<td>

<p>An object of class <code>PAFit_net</code>. You can use the function <code><a href="#topic+as.PAFit_net">as.PAFit_net</a></code> to convert from an edgelist matrix, function <code><a href="#topic+from_igraph">from_igraph</a></code> to convert from an <code>igraph</code> object, function <code><a href="#topic+from_networkDynamic">from_networkDynamic</a></code> to convert from a <code>networkDynamic</code> object, and function <code><a href="#topic+graph_from_file">graph_from_file</a></code> to read from a file.</p>
</td></tr>
<tr><td><code id="get_statistics_+3A_only_pa">only_PA</code></td>
<td>

<p>Logical. Indicates whether only the statistics for estimating <code class="reqn">A_k</code> are summarized. if <code>TRUE</code>, the statistics for estimating <code class="reqn">\eta_i</code> are NOT collected. This will save memory at the cost of unable to estimate node fitness). Default value is <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="get_statistics_+3A_only_true_deg_matrix">only_true_deg_matrix</code></td>
<td>

<p>Logical. Return only the true degree matrix (without binning), and no other statistics is returned. The result cannot be used in <code>PAFit</code> function to estimate PA or fitness. The motivation for this option is that sometimes we only want to get a degree matrix that summarizes the growth process of a very big network for plotting etc. Default value is <code>FALSE</code>.
</p>
</td></tr>
</table>
<p>Second group of parameters specifies how to bin the degrees:
</p>
<table role = "presentation">
<tr><td><code id="get_statistics_+3A_binning">binning</code></td>
<td>

<p>Logical. Indicates whether the degree should be binned together. Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="get_statistics_+3A_g">g</code></td>
<td>

<p>Positive integer. Number of bins. Should be at least <code>3</code>. Default value is <code>50</code>.
</p>
</td></tr>
</table>
<p>Third group contains a single parameter specifying how to reduce the number of node fitnesses:
</p>
<table role = "presentation">
<tr><td><code id="get_statistics_+3A_deg_threshold">deg_threshold</code></td>
<td>

<p>Integer. We only estimate the fitnesses of nodes whose number of new edges acquired is at least <code>deg_threshold</code>. The fitnesses of all other nodes are fixed at <code>1</code>. Default value is <code>0</code>.
</p>
</td></tr>
</table>
<p>Last group of parameters specifies how to group the time-stamps: 
</p>
<table role = "presentation">
<tr><td><code id="get_statistics_+3A_compress_mode">compress_mode</code></td>
<td>

<p>Integer. Indicates whether the timeline should be compressed. The value of CompressMode:
</p>
<p><code>0</code>: No compression
</p>
<p><code>1</code>: Compressed by using a subset of time-steps. The time stamps in this subset are equally spaced. The size of this subset is <code>CompressRatio</code> times the size of the set of all time stamps.
</p>
<p><code>2</code>: Compressed by only starting from the first time-step when <code class="reqn">CompressRatio*100</code> percentages of the total number of edges (in the final state of the network) had already been added to the network.
</p>
<p><code>3</code>: This mode offers the most flexibility, but requires user to supply the time stamps in <code>CustomTime</code>. Only time stamps in this <code>CustomTime</code> will be used. This mode can be used, for example, when investigating the change of the attachment function or node fitness in different time intervals.
</p>
<p>Default value is <code>0</code>, i.e. no compression.
</p>
</td></tr>
<tr><td><code id="get_statistics_+3A_compress_ratio">compress_ratio</code></td>
<td>

<p>Numeric. Indicates how much we should compress if CompressMode is <code>1</code> or <code>2</code>. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="get_statistics_+3A_custom_time">custom_time</code></td>
<td>

<p>Vector. Custom time stamps. This vector is a subset of the vector that contains all time-stamps. Only effective if <code>CompressMode == 3</code>. In that case, only these time stamps are used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PAFit_data</code>, which is a list. Some important fields are:
</p>
<table role = "presentation">
<tr><td><code>offset_tk</code></td>
<td>
<p>A matrix where the <code>(t,k+1)</code> element is the number of nodes with degree <code class="reqn">k</code> at time <code class="reqn">t</code>, counting among all the nodes whose number of new edges acquired is less than <code>deg_thresh</code></p>
</td></tr>
<tr><td><code>n_tk</code></td>
<td>
<p>A matrix where the <code>(t,k+1)</code> element is the number of nodes with degree <code class="reqn">k</code> at time <code class="reqn">t</code></p>
</td></tr>
<tr><td><code>m_tk</code></td>
<td>
<p>A matrix where the <code>(t,k+1)</code> element is the number of new edges connect to a degree-<code class="reqn">k</code> node at time <code class="reqn">t</code></p>
</td></tr>
<tr><td><code>sum_m_k</code></td>
<td>
<p>A vector where the <code>(k+1)</code>-th element is the total number of edges that linked to a degree <code class="reqn">k</code> node, counting over all time steps</p>
</td></tr>
<tr><td><code>node_degree</code></td>
<td>
<p>A matrix recording the degree of all nodes (that satisfy <code>degree_threshold</code> condition) at each time step</p>
</td></tr>
<tr><td><code>m_t</code></td>
<td>
<p>A vector where the <code>t</code>-th element is the number of new edges at time <code class="reqn">t</code></p>
</td></tr>
<tr><td><code>z_j</code></td>
<td>
<p>A vector where the <code>j</code>-th element is the total number of edges that linked to node <code class="reqn">j</code></p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Numeric. The number of nodes in the network</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Numeric. The number of time steps</p>
</td></tr>
<tr><td><code>deg_max</code></td>
<td>
<p>Numeric. The maximum degree in the final network</p>
</td></tr>
<tr><td><code>node_id</code></td>
<td>
<p>A vector contains the id of all nodes</p>
</td></tr>
<tr><td><code>final_deg</code></td>
<td>
<p>A vector contains the final degree of all nodes (including those that do not satisfy the <code>degree_threshold</code> condition)</p>
</td></tr>
<tr><td><code>deg_thresh</code></td>
<td>
<p>Integer. The specified degree threshold.</p>
</td></tr>
<tr><td><code>f_position</code></td>
<td>
<p>Numeric vector. The index in the <code>node_id</code> vector of the nodes we want to estimate (i.e. nodes whose number of new edges acquired is at least <code>deg_thresh</code>)</p>
</td></tr>
<tr><td><code>start_deg</code></td>
<td>
<p>Integer. The specified degree at which we start binning.</p>
</td></tr>
<tr><td><code>begin_deg</code></td>
<td>
<p>Numeric vector contains the beginning degree of each bin</p>
</td></tr>
<tr><td><code>end_deg</code></td>
<td>
<p>Numeric vector contains the ending degree of each bin</p>
</td></tr>
<tr><td><code>interval_length</code></td>
<td>
<p>Numeric vector contains the length of each bin.</p>
</td></tr>
<tr><td><code>binning</code></td>
<td>
<p>Logical. Indicates whether binning was applied or not.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>Integer. Number of bins</p>
</td></tr>
<tr><td><code>time_compress_mode</code></td>
<td>
<p>Integer. The mode of time compression.</p>
</td></tr>
<tr><td><code>t_compressed</code></td>
<td>
<p>Integer. The number of time stamps actually used</p>
</td></tr>
<tr><td><code>compressed_unique_time</code></td>
<td>
<p>The time stamps that are actually used</p>
</td></tr>
<tr><td><code>compress_ratio</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code>custom_time</code></td>
<td>
<p>Vector. The time stamps specified by user.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>See Also</h3>

<p>For creating the needed input for this function (a <code>PAFit_net</code> object), see <code><a href="#topic+as.PAFit_net">as.PAFit_net</a></code>, <code><a href="#topic+from_igraph">from_igraph</a></code>, <code><a href="#topic+from_networkDynamic">from_networkDynamic</a></code>, and <code><a href="#topic+graph_from_file">graph_from_file</a></code>. 
</p>
<p>For the next step, see <code><a href="#topic+Newman">Newman</a></code>, <code><a href="#topic+Jeong">Jeong</a></code> or <code><a href="#topic+only_A_estimate">only_A_estimate</a></code> for estimating the attachment function in isolation, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> for estimating node fitnesses in isolation, and <code><a href="#topic+joint_estimate">joint_estimate</a></code> for joint estimation of the attachment function and node fitnesses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
net        &lt;- generate_BA(N = 100 , m = 1)
net_stats  &lt;- get_statistics(net)
summary(net_stats)
</code></pre>

<hr>
<h2 id='graph_from_file'>
Read file to a PAFit_net object
</h2><span id='topic+graph_from_file'></span>

<h3>Description</h3>

<p>This function reads an input file to a <code>PAFit_net</code> object. Accepted formats are the edgelist format or the <code>gml</code> format. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> graph_from_file(file_name, format = "edgelist", type = "directed")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_from_file_+3A_file_name">file_name</code></td>
<td>

<p>A string indicates the file name.
</p>
</td></tr>
<tr><td><code id="graph_from_file_+3A_format">format</code></td>
<td>

<p>String. Possible values are <code>"edgelist"</code> and <code>"gml"</code>.
</p>
<p>If <code>format</code> is <code>"edgelist"</code>, we assume the following edgelist matrix format. Each row is assumed to be of the form (<code>from_node_id</code> <code>to_node_id</code> <code>time_stamp</code>).
<code>from_node_id</code> is the id of the source node. <code>to_node_id</code> is the id of the destination node. <code>time_stamp</code> is the arrival time of the edge. <code>from_node_id</code> and <code>to_node_id</code> are assumed to be integers that are at least <code class="reqn">0</code>. They need not to be contiguous.
</p>
<p>To register a new node <code class="reqn">i</code> at time <code class="reqn">t</code> without any edge, add a row with format (<code>i -1 t</code>). This works for both undirected and directed networks.
</p>
<p><code>time_stamp</code> can be either numeric or string. The value of a time-stamp can be arbitrary, but we assume that a smaller time_stamp (regarded so by the <code>sort</code> function in <code>R</code>) represents an earlier arrival time. Examples of time-stamps that satisfy this assumption are the integer <code>0:T</code>, the string format &lsquo;yyyy-mm-dd&rsquo;, and the POSIX time.
</p>
<p>If <code>format</code> is <code>"gml"</code>, there must be a binary field <code>directed</code> indicating the type of the network (<code>0</code>: undirected, <code>1</code>: directed). The required fields for an edge are: <code>source</code>, <code>target</code>, and <code>time</code>. <code>source</code> and <code>target</code> are the ID of the source node and the target node, respectively. <code>time</code> is the time-stamp of the edge. The required fields for a node are: <code>id</code>, <code>isolated</code> (binary) and <code>time</code>. The binary field <code>isolated</code> indicates whether this node is an isolated node when it enters the system or not. If <code>isolated</code> is <code>1</code>, then <code>time</code> must contain the node's appearance time. If <code>isolated</code> is <code>0</code>, then we can automatically infer the node's appearance time from its edges, so the field <code>time</code> in this case can be <code>NULL</code>. The assumptions on node IDs and the format of time-stamps are the same as in the case when <code>format = "edgelist"</code>. See <code><a href="#topic+graph_to_file">graph_to_file</a></code> to see detail on the format of the <code>gml</code> file this package outputs.
</p>
</td></tr>
<tr><td><code id="graph_from_file_+3A_type">type</code></td>
<td>

<p>String. Indicates whether the network is <code>"directed"</code> or <code>"undirected"</code>. This option is ignored if <code>format</code> is <code>"gml"</code>, since the information is assumed to be contained in the <code>gml</code> file.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PAFit_net</code> containing the network.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # a network from Bianconi-Barabasi model
  net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
  
  #graph_to_file(net, file_name = "test.gml", format = "gml")
  #reread    &lt;- graph_from_file(file_name = "test.gml", format = "gml")
</code></pre>

<hr>
<h2 id='graph_to_file'>
Write the graph in a PAFit_net object to file
</h2><span id='topic+graph_to_file'></span>

<h3>Description</h3>

<p>This function writes a graph in a <code>PAFit_net</code> object to an output file. Accepted file formats are the edgelist format or the <code>gml</code> format. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_to_file(net_object, file_name, format = "edgelist")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_to_file_+3A_net_object">net_object</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
<tr><td><code id="graph_to_file_+3A_file_name">file_name</code></td>
<td>

<p>A string indicates the file name.
</p>
</td></tr>
<tr><td><code id="graph_to_file_+3A_format">format</code></td>
<td>

<p>String. Possible values are <code>"edgelist"</code> and <code>"gml"</code>.
</p>
<p>If <code>format = "edgelist"</code>, we just output the edgelist matrix contained in the <code>PAFit_net</code> object as it is.
</p>
<p>If <code>format = "gml"</code>, here is the specification of the <code>gml</code> file. There is a binary field <code>directed</code> indicating the type of the network (<code>0</code>: undirected, <code>1</code>: directed). There are three atrributes for an edge: <code>source</code>, <code>target</code>, and <code>time</code>. There are three atrributes for a node: <code>id</code>, <code>isolated</code> (binary) and <code>time</code>. The atrribute <code>time</code> is <code>NULL</code> if the attribute <code>isolated</code> is <code>0</code> (since this is not an isolated node, we do not need to record its first apperance time). On the other hand, <code>time</code> is the node's appearance time if attribute <code>isolated</code> is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function writes directly to the output file.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
# a network from Bianconi-Barabasi model
net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
#graph_to_file(net, file_name = "test.gml", format = "gml")
</code></pre>

<hr>
<h2 id='Jeong'>
Jeong's method for estimating  the preferential attachment function
</h2><span id='topic+Jeong'></span>

<h3>Description</h3>

<p>This function estimates the preferential attachment function by Jeong's method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jeong(net_object                               , 
      net_stat  = get_statistics(net_object)   , 
      T_0_start = 0                            ,
      T_0_end   = round(net_stat$T * 0.75)     ,
      T_1_start = T_0_end + 1                  ,
      T_1_end   = net_stat$T                   ,
      interpolate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jeong_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network.
</p>
</td></tr>
<tr><td><code id="Jeong_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summerized statistics needed in estimation. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. Default value is <code> get_statistics(net_object)</code>.
</p>
</td></tr>
<tr><td><code id="Jeong_+3A_t_0_start">T_0_start</code></td>
<td>
<p>Positive integer. The starting time-step of the <code>T_0_interval</code>. Default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="Jeong_+3A_t_0_end">T_0_end</code></td>
<td>
<p>Positive integer. The ending time-step of <code>T_0_interval</code>. Default value is <code>round(net_stat$T * 0.75)</code>.</p>
</td></tr>
<tr><td><code id="Jeong_+3A_t_1_start">T_1_start</code></td>
<td>
<p>Positive integer. The starting time-step of the <code>T_1_interval</code>. Default value is <code>T_0_end + 1</code>.</p>
</td></tr>
<tr><td><code id="Jeong_+3A_t_1_end">T_1_end</code></td>
<td>
<p>Positive integer. The ending time-step of <code>T_1_interval</code>. Default value is <code>net_stat$T</code>.</p>
</td></tr>
<tr><td><code id="Jeong_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical. If <code>TRUE</code> then all the gaps in the estimated PA function are interpolated by linear interpolating in logarithm scale. Default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs an <code>PA_result</code> object which contains the estimated attachment function. In particular, it contains the following field:
</p>

<ul>
<li> <p><code>k</code> and <code>A</code>: a degree vector and the estimated PA function.
</p>
</li>
<li> <p><code>center_k</code> and <code>theta</code>: when we perform binning, these are the centers of the bins and the estimated PA values for those bins. 
</p>
</li>
<li> <p><code>g</code>: the number of bins used.
</p>
</li>
<li> <p><code>alpha</code> and <code>ci</code>: <code>alpha</code> is the estimated attachment exponenet <code class="reqn">\alpha</code> (when assume <code class="reqn">A_k = k^\alpha</code>), while <code>ci</code> is the confidence interval.
</p>
</li>
<li> <p><code>loglinear_fit</code>: this is the fitting result when we estimate <code class="reqn">\alpha</code>. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Jeong, H., Néda, Z. &amp; Barabási, A. . Measuring preferential attachment in evolving networks. Europhysics Letters. 2003;61(61):567–572. (<a href="https://doi.org/10.1209/epl/i2003-00166-9">doi:10.1209/epl/i2003-00166-9</a>).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+get_statistics">get_statistics</a></code> for how to create summerized statistics needed in this function.
</p>
<p>See <code><a href="#topic+Newman">Newman</a></code> and <code><a href="#topic+only_A_estimate">only_A_estimate</a></code> for other methods to estimate the attachment function in isolation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  net        &lt;- generate_net(N = 1000 , m = 1 , mode = 1 , alpha = 1 , s = 0)
  net_stats  &lt;- get_statistics(net)
  result     &lt;- Jeong(net, net_stats)
  # true function
  true_A     &lt;- result$center_k
  #plot the estimated attachment function
  plot(result , net_stats)
  lines(result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
</code></pre>

<hr>
<h2 id='joint_estimate'>
Joint inference of attachment function and node fitnesses   
</h2><span id='topic+joint_estimate'></span>

<h3>Description</h3>

<p>This function jointly estimates the attachment function <code class="reqn">A_k</code> and node fitnesses <code class="reqn">\eta_i</code>. It first performs a cross-validation to select the optimal parameters <code class="reqn">r</code> and <code class="reqn">s</code>, then estimates <code class="reqn">A_k</code> and <code class="reqn">eta_i</code> using that optimal pair with the full data (Ref. 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_estimate(net_object                               , 
              net_stat      = get_statistics(net_object), 
              p             = 0.75                      ,
              stop_cond     = 10^-8                     ,
              mode_reg_A    = 0                         , 
              ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_estimate_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network.
</p>
</td></tr>
<tr><td><code id="joint_estimate_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summarized statistics needed in estimation. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. The default value is <code>get_statistics(net_object)</code>.
</p>
</td></tr>
<tr><td><code id="joint_estimate_+3A_p">p</code></td>
<td>
<p>Numeric. This is the ratio of the number of new edges in the learning data to that of the full data. The data is then divided into two parts: learning data and testing data based on <code>p</code>. The learning data is used to learn the node fitnesses and the testing data is then used in cross-validation. Default value is <code>0.75</code>.</p>
</td></tr>  
<tr><td><code id="joint_estimate_+3A_stop_cond">stop_cond</code></td>
<td>
<p>Numeric. The iterative algorithm stops when <code class="reqn">abs(h(ii) - h(ii + 1)) / (abs(h(ii)) + 1) &lt; stop.cond</code> where <code class="reqn">h(ii)</code> is the value of the objective function at iteration <code class="reqn">ii</code>. We recommend to choose <code>stop.cond</code> at most equal to <code class="reqn">10^(- number of digits of h - 2)</code>, in order to ensure that when the algorithm stops, the increase in posterior probability is less than 1% of the current posterior probability. Default is <code>10^-8</code>. This threshold is good enough for most applications.</p>
</td></tr>
<tr><td><code id="joint_estimate_+3A_mode_reg_a">mode_reg_A</code></td>
<td>
<p>Binary. Indicates which regularization term is used for <code class="reqn">A_k</code>:
</p>

<ul>
<li> <p><code>0</code>: This is the regularization term used in Ref. 1 and 2.  Please refer to Eq. (4) in the tutorial for the definition of the term. It approximately enforces the power-law form <code class="reqn">A_k = k^\alpha</code>. This is the default value. 
</p>
</li>
<li> <p><code>1</code>: Unlike the default, this regularization term exactly enforces the functional form <code class="reqn">A_k = k^\alpha</code>. Please refer to Eq. (6) in the tutorial for the definition of the term. Its main drawback is it is significantly slower to converge, while its gain over the default one is marginal in most cases.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="joint_estimate_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying algorithm.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a <code>Full_PAFit_result</code> object, which is a list containing the following fields:
</p>

<ul>
<li> <p><code>cv_data</code>: a <code>CV_Data</code> object which contains the cross-validation data. This is the testing data.
</p>
</li>
<li> <p><code>cv_result</code>: a <code>CV_Result</code> object which contains the cross-validation result. Normally the user does not need to pay attention to this data.
</p>
</li>
<li> <p><code>estimate_result</code>: this is a <code>PAFit_result</code> object which contains the estimated attachment function <code class="reqn">A_k</code>, the estimated fitnesses <code class="reqn">\eta_i</code> and their confidence intervals. In particular, the important fields are:      
</p>

<ul>
<li> <p><code>ratio</code>: this is the selected value for the hyper-parameter <code class="reqn">r</code>.
</p>
</li>
<li> <p><code>shape</code>: this is the selected value for the hyper-parameter <code class="reqn">s</code>.
</p>
</li>
<li> <p><code>k</code> and <code>A</code>: a degree vector and the estimated PA function.
</p>
</li>
<li> <p><code>var_A</code>: the estimated variance of <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>var_logA</code>: the estimated variance of <code class="reqn">log A</code>.
</p>
</li>
<li> <p><code>upper_A</code>: the upper value of the interval of two standard deviations around <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>lower_A</code>: the lower value of the interval of two standard deviations around <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>center_k</code> and <code>theta</code>: when we perform binning, these are the centers of the bins and the estimated PA values for those bins. <code>theta</code> is similar to <code>A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>var_bin</code>: the variance of <code>theta</code>. Same as <code>var_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>upper_bin</code>: the upper value of the interval of two standard deviations around <code>theta</code>. Same as <code>upper_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>lower_bin</code>: the lower value of the interval of two standard deviations around <code>theta</code>. Same as <code>lower_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>g</code>: the number of bins used.
</p>
</li>
<li> <p><code>alpha</code> and <code>ci</code>: <code>alpha</code> is the estimated attachment exponent <code class="reqn">\alpha</code> (when assume <code class="reqn">A_k = k^\alpha</code>), while <code>ci</code> is the confidence interval.
</p>
</li>
<li> <p><code>loglinear_fit</code>: this is the fitting result when we estimate <code class="reqn">\alpha</code>. 
</p>
</li>
<li> <p><code>f</code>: the estimated node fitnesses.
</p>
</li>
<li> <p><code>var_f</code>: the estimated variance of <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>upper_f</code>: the estimated upper value of the interval of two standard deviations around <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>lower_f</code>: the estimated lower value of the interval of two standard deviations around <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>objective_value</code>: values of the objective function over iterations in the final run with the full data.
</p>
</li>
<li> <p><code>diverge_zero</code>: logical value indicates whether the algorithm diverged in the final run with the full data.
</p>
</li></ul>

</li>
<li> <p><code>contribution</code>: a list containing an estimate of the contributions of preferential attachment and fitness mechanisms in the growth process of the network. The calculation adapts a quantification method proposed in Section 3 of Ref. 4, which is for preferential attachment and transitivity, to preferential attachment and fitness.
</p>

<ul>
<li> <p><code>PA_contribution</code>: an array containing the contributions of preferential attachment at each time-step 
</p>
</li>
<li> <p><code>fit_contribution</code>: an array containing the contributions of the fitness mechanism at each time-step 
</p>
</li>
<li> <p><code>mean_PA_contrib</code>: the average contribution of preferential attachment through the whole growth process
</p>
</li>
<li> <p><code>mean_fit_contrib</code>: the average contribution of the fitness mechanism through the whole growth process</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. PLoS ONE 10(9): e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>2. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. Scientific Reports 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>
<p>3. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2020). PAFit: An R Package for the Non-Parametric Estimation of Preferential Attachment and Node Fitness in Temporal Complex Networks. Journal of Statistical Software 92 (3). (<a href="https://doi.org/10.18637/jss.v092.i03">doi:10.18637/jss.v092.i03</a>).
</p>
<p>4. Inoue, M., Pham, T. &amp; Shimodaira, H. (2020). Joint Estimation of Non-parametric Transitivity and Preferential Attachment Functions in Scientific Co-authorship Networks. Journal of Informetrics 14(3). (<a href="https://doi.org/10.1016/j.joi.2020.101042">doi:10.1016/j.joi.2020.101042</a>).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+get_statistics">get_statistics</a></code> for how to create summarized statistics needed in this function.
</p>
<p>See <code><a href="#topic+Jeong">Jeong</a></code>, <code><a href="#topic+Newman">Newman</a></code> and <code><a href="#topic+only_A_estimate">only_A_estimate</a></code> for functions to estimate the attachment function in isolation.
</p>
<p>See <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> for a function to estimate node fitnesses in isolation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  library("PAFit")
  #### Example 1: a linear preferential attachment kernel, i.e., A_k = k ############
  set.seed(1)
  # size of initial network = 100
  # number of new nodes at each time-step = 100
  # Ak = k; inverse variance of the distribution of node fitnesse = 5
  net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                            num_seed = 100  , multiple_node = 100,
                            s        = 5)
  net_stats  &lt;- get_statistics(net)
  
  # Joint estimation of attachment function Ak and node fitness
  result     &lt;- joint_estimate(net, net_stats)
  
  summary(result)
  
  # plot the estimated attachment function
  true_A     &lt;- pmax(result$estimate_result$center_k,1) # true function
  plot(result , net_stats, max_A = max(true_A,result$estimate_result$theta))
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
  # plot the estimated node fitnesses and true node fitnesses
  plot(result, net_stats, true = net$fitness, plot = "true_f")
  
  #############################################################################
  #### Example 2: a non-log-linear preferential attachment kernel ############
  set.seed(1)
  # size of initial network = 100
  # number of new nodes at each time-step = 100
  # A_k = alpha* log (max(k,1))^beta + 1, with alpha = 2, and beta = 2
  # inverse variance of the distribution of node fitnesse = 10
  net        &lt;- generate_net(N       = 1000 , m             = 50 , 
                            num_seed = 100  , multiple_node = 100,
                            s        = 10   , mode = 3, alpha = 2, beta = 2)
  net_stats  &lt;- get_statistics(net)
  
  # Joint estimation of attachment function Ak and node fitness
  result     &lt;- joint_estimate(net, net_stats)
  
  summary(result)
  
  # plot the estimated attachment function
  true_A     &lt;- 2 * log(pmax(result$estimate_result$center_k,1))^2 + 1 # true function
  plot(result , net_stats, max_A = max(true_A,result$estimate_result$theta))
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
  # plot the estimated node fitnesses and true node fitnesses
  plot(result, net_stats, true = net$fitness, plot = "true_f")
  #############################################################################
  #### Example 3: another non-log-linear preferential attachment kernel ############
  set.seed(1)
  # size of initial network = 100
  # number of new nodes at each time-step = 100
  # A_k = min(max(k,1),sat_at)^alpha, with alpha = 1, and sat_at = 100
  # inverse variance of the distribution of node fitnesse = 10
  net        &lt;- generate_net(N       = 1000 , m             = 50 , 
                            num_seed = 100  , multiple_node = 100,
                            s        = 10   , mode = 2, alpha = 1, sat_at = 100)
  net_stats  &lt;- get_statistics(net)
  
  # Joint estimation of attachment function Ak and node fitness
  result     &lt;- joint_estimate(net, net_stats)
  
  summary(result)
  
  # plot the estimated attachment function
  true_A     &lt;- pmin(pmax(result$estimate_result$center_k,1),100)^1 # true function
  plot(result , net_stats, max_A = max(true_A,result$estimate_result$theta))
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
  # plot the estimated node fitnesses and true node fitnesses
  plot(result, net_stats, true = net$fitness, plot = "true_f")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Newman'>
Corrected Newman's method for estimating the preferential attachment function
</h2><span id='topic+Newman'></span>

<h3>Description</h3>

<p>This function implements a correction proposed in [1] of the original Newman's method in [2] to estimate the preferential attachment function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Newman(net_object                              , 
         net_stat    = get_statistics(net_object), 
         start       = 1                         , 
         interpolate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Newman_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network.
</p>
</td></tr>
<tr><td><code id="Newman_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summerized statistics needed in estimation. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. Default value is <code> get_statistics(net_object)</code>.
</p>
</td></tr>
<tr><td><code id="Newman_+3A_start">start</code></td>
<td>
<p>Positive integer. The starting time from which the method is applied. Default value is <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="Newman_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical. If <code>TRUE</code> then all the gaps in the estimated PA function are interpolated by linear interpolating in logarithm scale. Default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs an <code>PA_result</code> object which contains the estimated attachment function. In particular, it contains the following field:
</p>

<ul>
<li> <p><code>k</code> and <code>A</code>: a degree vector and the estimated PA function.
</p>
</li>
<li> <p><code>center_k</code> and <code>theta</code>: when we perform binning, these are the centers of the bins and the estimated PA values for those bins. 
</p>
</li>
<li> <p><code>g</code>: the number of bins used.
</p>
</li>
<li> <p><code>alpha</code> and <code>ci</code>: <code>alpha</code> is the estimated attachment exponenet <code class="reqn">\alpha</code> (when assume <code class="reqn">A_k = k^\alpha</code>), while <code>ci</code> is the mean plus/minus two-standard-deviation interval.
</p>
</li>
<li> <p><code>loglinear_fit</code>: this is the fitting result when we estimate <code class="reqn">\alpha</code>. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. PLoS ONE 10(9): e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>2. Newman, M.. Clustering and preferential attachment in growing networks. Physical Review E. 2001;64(2):025102 (<a href="https://doi.org/10.1103/PhysRevE.64.025102">doi:10.1103/PhysRevE.64.025102</a>).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+get_statistics">get_statistics</a></code> for how to create summerized statistics needed in this function.
</p>
<p>See <code><a href="#topic+Jeong">Jeong</a></code>, <code><a href="#topic+only_A_estimate">only_A_estimate</a></code> for other methods to estimate the attachment function in isolation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  net        &lt;- generate_net(N = 1000 , m = 1 , mode = 1 , alpha = 1 , s = 0)
  net_stats  &lt;- get_statistics(net)
  result     &lt;- Newman(net, net_stats)
  summary(result)
  # true function
  true_A     &lt;- result$center_k
  #plot the estimated attachment function
  plot(result , net_stats)
  lines(result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
</code></pre>

<hr>
<h2 id='only_A_estimate'>
Estimating the attachment function in isolation by PAFit method  
</h2><span id='topic+only_A_estimate'></span>

<h3>Description</h3>

<p>This function estimates the attachment function <code class="reqn">A_k</code> by PAFit method. The method has a hyper-parameter <code class="reqn">r</code>. It first performs a cross-validation step to select the optimal parameter <code class="reqn">r</code> for the regularization of <code class="reqn">A_k</code>, then uses that <code class="reqn">r</code> to estimate the attachment function with the full data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>only_A_estimate(net_object                             , 
                net_stat   = get_statistics(net_object), 
                p          = 0.75                      ,
                stop_cond  = 10^-8                     , 
                mode_reg_A = 0                         ,
                MLE        = FALSE                     ,
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="only_A_estimate_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network.
</p>
</td></tr>
<tr><td><code id="only_A_estimate_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summerized statistics needed in estimation. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. The default value is <code>get_statistics(net_object)</code>.
</p>
</td></tr>
<tr><td><code id="only_A_estimate_+3A_p">p</code></td>
<td>
<p>Numeric. This is the ratio of the number of new edges in the learning data to that of the full data. The data is then divided into two parts: learning data and testing data based on <code>p</code>. The learning data is used to learn the node fitnesses and the testing data is then used in cross-validation. Default value is <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="only_A_estimate_+3A_stop_cond">stop_cond</code></td>
<td>
<p>Numeric. The iterative algorithm stops when <code class="reqn">abs(h(ii) - h(ii + 1)) / (abs(h(ii)) + 1) &lt; stop.cond</code> where <code class="reqn">h(ii)</code> is the value of the objective function at iteration <code class="reqn">ii</code>. We recommend to choose <code>stop.cond</code> at most equal to <code class="reqn">10^(- number of digits of h - 2)</code>, in order to ensure that when the algorithm stops, the increase in posterior probability is less than 1% of the current posterior probability. Default is <code>10^-8</code>. This threshold is good enough for most applications.</p>
</td></tr>
<tr><td><code id="only_A_estimate_+3A_mode_reg_a">mode_reg_A</code></td>
<td>
<p>Binary. Indicates which regularization term is used for <code class="reqn">A_k</code>:
</p>

<ul>
<li> <p><code>0</code>: This is the regularization term used in Ref. 1 and 2. Please refer to Eq. (4) in the tutorial for the definition of the term. It approximately enforces the power-law form <code class="reqn">A_k = k^\alpha</code>. This is the default value. 
</p>
</li>
<li> <p><code>1</code>: Unlike the default, this regularization term exactly enforces the functional form <code class="reqn">A_k = k^\alpha</code>. Please refer to Eq. (6) in the tutorial for the definition of the term. Its main drawback is it is significantly slower to converge, while its gain over the default one is marginal in most cases.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="only_A_estimate_+3A_mle">MLE</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then not perform cross-validation and estimate the PA function with <code>r = 0</code>, i.e., maximum likelihood estimation. Default is <code>FALSE</code>. One might want to set this option to <code>TRUE</code> when one believes that there are sufficient data to get a reasonable MLE result, or when one wants to compare the default, regularized result with the MLE result.</p>
</td></tr>
<tr><td><code id="only_A_estimate_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying algorithm.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a <code>Full_PAFit_result</code> object, which is a list containing the following fields:
</p>

<ul>
<li> <p><code>cv_data</code>: a <code>CV_Data</code> object which contains the cross-validation data. This is the final  Normally the user does not need to pay attention to this data. <code>NULL</code> if <code>MLE = TRUE</code>.
</p>
</li>
<li> <p><code>cv_result</code>: a <code>CV_Result</code> object which contains the cross-validation result. Normally the user does not need to pay attention to this data. <code>NULL</code> if <code>MLE = TRUE</code>.
</p>
</li>
<li> <p><code>estimate_result</code>: this is a <code>PAFit_result</code> object which contains the estimated PA function and its confidence interval. It also includes the estimated attachment exponenent <code class="reqn">\alpha</code> (assuming the model <code class="reqn">A_k = k^\alpha</code>) in the field <code>alpha</code>, and the confidence interval of <code class="reqn">\alpha</code> (in the field <code>ci</code>) when possible. In particular, the important fields are:
</p>

<ul>
<li> <p><code>ratio</code>: this is the selected value for the hyper-parameter <code class="reqn">r</code>.
</p>
</li>
<li> <p><code>k</code> and <code>A</code>: a degree vector and the estimated PA function.
</p>
</li>
<li> <p><code>var_A</code>: the estimated variance of <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>var_logA</code>: the estimated variance of <code class="reqn">log A</code>.
</p>
</li>
<li> <p><code>upper_A</code>: the upper value of the interval of two standard deviations around <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>lower_A</code>: the lower value of the interval of two standard deviations around <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>center_k</code> and <code>theta</code>: when we perform binning, these are the centers of the bins and the estimated PA values for those bins. <code>theta</code> is similar to <code>A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>var_bin</code>: the variance of <code>theta</code>. Same as <code>var_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>upper_bin</code>: the upper value of the interval of two standard deviations around <code>theta</code>. Same as <code>upper_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>lower_lower</code>: the lower value of the interval of two standard deviations around <code>theta</code>. Same as <code>lower_A</code> but with duplicated values removed.
</p>
</li>
<li> <p><code>g</code>: the number of bins used.
</p>
</li>
<li> <p><code>alpha</code> and <code>ci</code>: <code>alpha</code> is the estimated attachment exponenet <code class="reqn">\alpha</code> (when assume <code class="reqn">A_k = k^\alpha</code>), while <code>ci</code> is the confidence interval.
</p>
</li>
<li> <p><code>loglinear_fit</code>: this is the fitting result when we estimate <code class="reqn">\alpha</code>. 
</p>
</li>
<li> <p><code>objective_value</code>: values of the objective function over iterations in the final run with the full data.
</p>
</li>
<li> <p><code>diverge_zero</code>: logical value indicates whether the algorithm diverged in the final run with the full data.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. PLoS ONE 10(9): e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>2. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. Scientific Reports 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+get_statistics">get_statistics</a></code> for how to create summerized statistics needed in this function.
</p>
<p>See <code><a href="#topic+Newman">Newman</a></code> and <code><a href="#topic+Jeong">Jeong</a></code> for other methods to estimate the attachment function <code class="reqn">A_k</code> in isolation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library("PAFit")
  set.seed(1)
  #### Example 1: Linear preferential attachment  #########
  # a network from BA model
  net        &lt;- generate_net(N = 1000 , m = 50 , mode = 1, alpha = 1, s = 0)
  
  net_stats  &lt;- get_statistics(net, only_PA = TRUE)
  result     &lt;- only_A_estimate(net, net_stats)
 
  # plot the estimated attachment function
  plot(result, net_stats)
  
  # true function
  true_A     &lt;- result$estimate_result$center_k
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
  #### Example 2: a non-log-linear preferential attachment  #########
  # A_k = alpha* log (max(k,1))^beta + 1, with alpha = 2, and beta = 2
  set.seed(1)
  net        &lt;- generate_net(N = 1000 , m = 50 , mode = 3, alpha = 2, beta = 2, s = 0)
  
  net_stats  &lt;- get_statistics(net,only_PA = TRUE)
  result     &lt;- only_A_estimate(net, net_stats)
 
  # plot the estimated attachment function
  plot(result, net_stats)
  
  # true function
  true_A     &lt;- 2 * log(pmax(result$estimate_result$center_k,1))^2 + 1 # true function
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
  #############################################################################
  #### Example 3: another non-log-linear preferential attachment kernel ############
  set.seed(1)
  # A_k = min(max(k,1),sat_at)^alpha, with alpha = 1, and sat_at = 200
  # inverse variance of the distribution of node fitnesse = 10
  net        &lt;- generate_net(N = 1000 , m = 50 , mode = 2, alpha = 1, sat_at = 200, s = 0)
  net_stats  &lt;- get_statistics(net, only_PA = TRUE)
  
  result     &lt;- only_A_estimate(net, net_stats)
  
  
  # plot the estimated attachment function
  true_A     &lt;- pmin(pmax(result$estimate_result$center_k,1),200)^1 # true function
  plot(result , net_stats, max_A = max(true_A,result$estimate_result$theta))
  lines(result$estimate_result$center_k, true_A, col = "red") # true line
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='only_F_estimate'>
Estimating node fitnesses in isolation   
</h2><span id='topic+only_F_estimate'></span>

<h3>Description</h3>

<p>This function estimates node fitnesses <code class="reqn">\eta_i</code> assusming either <code class="reqn">A_k = k</code> (i.e. linear preferential attachment) or <code class="reqn">A_k = 1</code> (i.e. no preferential attachment). The method has a hyper-parameter <code class="reqn">s</code>. It first performs a cross-validation to select the optimal parameter <code class="reqn">s</code> for the prior of <code class="reqn">\eta_i</code>, then estimates <code class="reqn">eta_i</code> with the full data (Ref. 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>only_F_estimate(net_object                             , 
               net_stat    = get_statistics(net_object), 
               p           = 0.75                      ,
               stop_cond   = 10^-8                     , 
               model_A     = "Linear"                  ,
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="only_F_estimate_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network.
</p>
</td></tr>
<tr><td><code id="only_F_estimate_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code> which contains summerized statistics needed in estimation. This object is created by the function <code><a href="#topic+get_statistics">get_statistics</a></code>. The default value is <code>get_statistics(net_object)</code>.
</p>
</td></tr>
<tr><td><code id="only_F_estimate_+3A_p">p</code></td>
<td>
<p>Numeric. This is the ratio of the number of new edges in the learning data to that of the full data. The data is then divided into two parts: learning data and testing data based on <code>p</code>. The learning data is used to learn the node fitnesses and the testing data is then used in cross-validation. Default value is <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="only_F_estimate_+3A_stop_cond">stop_cond</code></td>
<td>
<p>Numeric. The iterative algorithm stops when <code class="reqn">abs(h(ii) - h(ii + 1)) / (abs(h(ii)) + 1) &lt; stop.cond</code> where <code class="reqn">h(ii)</code> is the value of the objective function at iteration <code class="reqn">ii</code>. We recommend to choose <code>stop.cond</code> at most equal to <code class="reqn">10^(- number of digits of h - 2)</code>, in order to ensure that when the algorithm stops, the increase in posterior probability is less than 1% of the current posterior probability. Default is <code>10^-8</code>. This threshold is good enough for most applications.</p>
</td></tr>
<tr><td><code id="only_F_estimate_+3A_model_a">model_A</code></td>
<td>
<p>String. Indicates which attachment function <code class="reqn">A_k</code> we assume:
</p>

<ul>
<li> <p><code>"Linear"</code>: We assume <code class="reqn">A_k = k</code>, i.e. the Bianconi-Barabási model (Ref. 2).
</p>
</li>
<li> <p><code>"Constant"</code>: We assume <code class="reqn">A_k = 1</code>, i.e. the Caldarelli model (Ref. 3).
</p>
</li></ul>

</td></tr>
<tr><td><code id="only_F_estimate_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying algorithm.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a <code>Full_PAFit_result</code> object, which is a list containing the following fields:
</p>

<ul>
<li> <p><code>cv_data</code>: a <code>CV_Data</code> object which contains the cross-validation data. Normally the user does not need to pay attention to this data.
</p>
</li>
<li> <p><code>cv_result</code>: a <code>CV_Result</code> object which contains the cross-validation result. Normally the user does not need to pay attention to this data.
</p>
</li>
<li> <p><code>estimate_result</code>: this is a <code>PAFit_result</code> object which contains the estimated node fitnesses and their confidence intervals. In particular, the important fields are:      
</p>

<ul>
<li> <p><code>shape</code>: this is the selected value for the hyper-parameter <code class="reqn">s</code>.
</p>
</li>
<li> <p><code>g</code>: the number of bins used.
</p>
</li>
<li> <p><code>f</code>: the estimated node fitnesses.
</p>
</li>
<li> <p><code>var_f</code>: the estimated variance of <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>upper_f</code>: the estimated upper value of the interval of two standard deviations around <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>lower_f</code>: the estimated lower value of the interval of two standard deviations around <code class="reqn">\eta_i</code>.
</p>
</li>
<li> <p><code>objective_value</code>: values of the objective function over iterations in the final run with the full data.
</p>
</li>
<li> <p><code>diverge_zero</code>: logical value indicates whether the algorithm diverged in the final run with the full data.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. Scientific Reports 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>
<p>2. Bianconni, G. &amp; Barabási, A. (2001). Competition and multiscaling in evolving networks. Europhys. Lett., 54, 436 (<a href="https://doi.org/10.1209/epl/i2001-00260-6">doi:10.1209/epl/i2001-00260-6</a>).
</p>
<p>3. Caldarelli, G., Capocci, A. , De Los Rios, P. &amp; Muñoz, M.A. (2002). Scale-Free Networks from Varying Vertex Intrinsic Fitness. Phys. Rev. Lett., 89, 258702 (<a href="https://doi.org/10.1103/PhysRevLett.89.258702">doi:10.1103/PhysRevLett.89.258702</a>).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+get_statistics">get_statistics</a></code> for how to create summerized statistics needed in this function.
</p>
<p>See <code><a href="#topic+joint_estimate">joint_estimate</a></code> for the method to jointly estimate the attachment function <code class="reqn">A_k</code> and node fitnesses <code class="reqn">\eta_i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library("PAFit")
  set.seed(1)
  # size of initial network = 100
  # number of new nodes at each time-step = 100
  # Ak = k; inverse variance of the distribution of node fitnesse = 10
  net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                            num_seed = 100  , multiple_node = 100,
                            s        = 10)
                            
  net_stats  &lt;- get_statistics(net)
  
  # estimate node fitnesses in isolation, assuming Ak = k
  result     &lt;- only_F_estimate(net, net_stats)
 
  # plot the estimated node fitnesses and true node fitnesses
  plot(result, net_stats, true = net$fitness, plot = "true_f")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='PAFit_oneshot'>
Estimating the nonparametric preferential attachment function from one single snapshot.  
</h2><span id='topic+PAFit_oneshot'></span>

<h3>Description</h3>

<p>This function estimates the attachment function <code class="reqn">A_k</code> from one snapshot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PAFit_oneshot(net_object, 
              M    = 10,
              S    = 5,
              loop = 5,
              G    = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PAFit_oneshot_+3A_net_object">net_object</code></td>
<td>

<p>an object of class <code>PAFit_net</code> that contains the network. Any time-step information, if available, will be ignored.
</p>
</td></tr>
<tr><td><code id="PAFit_oneshot_+3A_m">M</code></td>
<td>

<p>Integer. Number of simulated networks in each iteration. Default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="PAFit_oneshot_+3A_s">S</code></td>
<td>

<p>Integer. Number of iterations inside each loop. Default is <code>5</code>.
</p>
</td></tr>
<tr><td><code id="PAFit_oneshot_+3A_loop">loop</code></td>
<td>

<p>Integer. Number of loops of the whole process. Default is <code>5</code>.
</p>
</td></tr>
<tr><td><code id="PAFit_oneshot_+3A_g">G</code></td>
<td>

<p>Integer. Number of bins for the PA function. Default is <code>1000</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a <code>PAFit_result</code> object.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2021). Non-parametric estimation of the preferential attachment function from one network snapshot. Journal of Complex Networks 9(5): cnab024. (<a href="https://doi.org/10.1093/comnet/cnab024">doi:10.1093/comnet/cnab024</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library("PAFit")
  net_1    &lt;- generate_BA(N = 10000, alpha = 1) # true attachment exponent = 1.0
  result_1 &lt;- PAFit_oneshot(net_1)
  print(result_1)

  
  net_2    &lt;- generate_BA(N = 10000, alpha = 0.5) # true attachment exponent = 0.5
  result_2 &lt;- PAFit_oneshot(net_2)
  print(result_2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='plot_contribution'>
Plotting contributions calculated from the observed data and contributions calculated from simulated data
</h2><span id='topic+plot_contribution'></span>

<h3>Description</h3>

<p>This function extracts from a <code>Simulated_Data_From_Fitted_Model</code> object contributions of rich-get-richer and fit-get-richer effects calculated using simulated networks and plots these contributions versus the contributions calculated from the original observed network. See <code><a href="#topic+joint_estimate">joint_estimate</a></code> for a description of how the contributions are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_contribution(simulated_object,
                  original_result,
                  which_plot = "PA",
                  y_label = ifelse("PA" == which_plot,
                  "Contribution of the rich-get-richer effect",
                  "Contribution of the fit-get-richer effect"),
                  legend_pos_x = 0.75,
                  legend_pos_y = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_contribution_+3A_simulated_object">simulated_object</code></td>
<td>

<p>an object of class <code>Simulated_Data_From_Fitted_Model</code> that contains simulated data.
</p>
</td></tr>
<tr><td><code id="plot_contribution_+3A_original_result">original_result</code></td>
<td>

<p>an object of class <code>Full_PAFit_result</code> that contains the estimation results from the original observed data.
</p>
</td></tr>
<tr><td><code id="plot_contribution_+3A_which_plot">which_plot</code></td>
<td>

<p>String. &ldquo;PA&quot;: plots contributions of rich-get-richer effect, &ldquo;fit&quot;: plots contribution of fit-get-richer effect. Default is &ldquo;PA&quot;.
</p>
</td></tr>
<tr><td><code id="plot_contribution_+3A_y_label">y_label</code></td>
<td>

<p>String. The label for y-axis. Default is &quot;Contribution of rich-get-richer effect&quot;. 
</p>
</td></tr>
<tr><td><code id="plot_contribution_+3A_legend_pos_x">legend_pos_x</code></td>
<td>
<p>Numeric. The horizontal position, between (0,1), of the legend. Default value is <code>0.75</code>.</p>
</td></tr>  
<tr><td><code id="plot_contribution_+3A_legend_pos_y">legend_pos_y</code></td>
<td>
<p>Numeric. The vertical position, between (0,1), of the legend. Default value is <code>0.9</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Output a plot.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2015). PAFit: A Statistical Method for Measuring Preferential Attachment in Temporal Complex Networks. PLoS ONE 10(9): e0137796. (<a href="https://doi.org/10.1371/journal.pone.0137796">doi:10.1371/journal.pone.0137796</a>).
</p>
<p>2. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2016). Joint Estimation of Preferential Attachment and Node Fitness in Growing Complex Networks. Scientific Reports 6, Article number: 32558. (<a href="https://doi.org/10.1038/srep32558">doi:10.1038/srep32558</a>).
</p>
<p>3. Pham, T., Sheridan, P. &amp; Shimodaira, H. (2020). PAFit: An R Package for the Non-Parametric Estimation of Preferential Attachment and Node Fitness in Temporal Complex Networks. Journal of Statistical Software 92 (3). (<a href="https://doi.org/10.18637/jss.v092.i03">doi:10.18637/jss.v092.i03</a>).
</p>
<p>4. Inoue, M., Pham, T. &amp; Shimodaira, H. (2020). Joint Estimation of Non-parametric Transitivity and Preferential Attachment Functions in Scientific Co-authorship Networks. Journal of Informetrics 14(3). (<a href="https://doi.org/10.1016/j.joi.2020.101042">doi:10.1016/j.joi.2020.101042</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint_estimate">joint_estimate</a></code>, <code><a href="#topic+plot_contribution">plot_contribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  library("PAFit")
  net_object     &lt;- generate_net(N = 500, m = 10, s = 10, alpha = 0.5)
  net_stat       &lt;- get_statistics(net_object) 
  result         &lt;- joint_estimate(net_object, net_stat)
  simulated_data &lt;- generate_simulated_data_from_estimated_model(net_object, net_stat, result)
  plot_contribution(simulated_data, result, which_plot = "PA")
  plot_contribution(simulated_data, result, which_plot = "fit")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.Full_PAFit_result'>
Plotting the estimated attachment function and node fitness
</h2><span id='topic+plot.Full_PAFit_result'></span>

<h3>Description</h3>

<p>This function plots the estimated attachment function <code class="reqn">A_k</code> and node fitness <code class="reqn">eta_i</code>, together with additional information such as their confidence intervals or the estimated attachment exponent (<code class="reqn">\alpha</code> when assuming <code class="reqn">A_k = k^\alpha</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Full_PAFit_result'
plot(x,
     net_stat                 ,
     true_f         = NULL    , plot             = "A"              , plot_bin   = TRUE ,
     line           = FALSE   , confidence       = TRUE             , high_deg_A = 1    ,
     high_deg_f     = 5       ,
     shade_point    = 0.5     , col_point        = "grey25"         , pch        = 16   ,
     shade_interval = 0.5     , col_interval     = "lightsteelblue" , label_x    = NULL , 
     label_y        = NULL    ,
     max_A          = NULL    , min_A            = NULL             , f_min      = NULL , 
     f_max          = NULL    , plot_true_degree = FALSE , 
     ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Full_PAFit_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>Full_PAFit_result</code>, containing the estimated results from <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code>, containing the summerized statistics.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_true_f">true_f</code></td>
<td>

<p>Vector. Optional parameter for the true value of node fitnesses (only available in simulated datasets). If this parameter is specified and <code>plot == "true_f"</code>, a plot of estimated <code class="reqn">\eta</code> versus true <code class="reqn">\eta</code> is produced (after a suitable rescaling of the estimated <code class="reqn">f</code>).  
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_plot">plot</code></td>
<td>

<p>String. Indicates which plot is produced. 
</p>

<ul>
<li><p> If <code>"A"</code> then PA function is plotted. 
</p>
</li>
<li><p> If <code>"f"</code> then the histogram of estimated fitness is plotted. 
</p>
</li>
<li><p> If <code>"true_f"</code> then estimated fitness and true fitness are plotted together (require supplement of true fitness). 
</p>
</li></ul>

<p>Default value is <code>"A"</code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_plot_bin">plot_bin</code></td>
<td>
<p>Logical. If <code>TRUE</code> then only the center of each bin is plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_line">line</code></td>
<td>

<p>Logical. Indicates whether to plot the line fitted from the log-linear model or not. Default value is <code class="reqn">TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_confidence">confidence</code></td>
<td>

<p>Logical. Indicates whether to plot the confidence intervals of <code class="reqn">A_k</code> and <code class="reqn">eta_i</code> or not. If confidence == TRUE, a 2-sigma confidence interval will be plotted at each <code class="reqn">A_k</code> and <code class="reqn">eta_i</code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_high_deg_a">high_deg_A</code></td>
<td>
<p>Integer. The estimated PA function is plotted starting from <code>high_deg_A</code>. Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_high_deg_f">high_deg_f</code></td>
<td>
<p>Integer. If <code>plot == "true_f"</code>, only nodes whose number of edges acquired is not less than <code>high_deg_f</code> are plotted. Default value is <code>5</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_col_point">col_point</code></td>
<td>
<p>String. The name of the color of the points. Default value is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_shade_point">shade_point</code></td>
<td>

<p>Numeric. Value between 0 and 1. This is the transparency level of the points. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_pch">pch</code></td>
<td>
<p>Numeric. The plot symbol. Default value is <code>16</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_shade_interval">shade_interval</code></td>
<td>

<p>Numeric. Value between 0 and 1. This is the transparency level of the confidence intervals. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_max_a">max_A</code></td>
<td>
<p>Numeric. Specify the maximum of the axis of PA.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_min_a">min_A</code></td>
<td>
<p>Numeric. Specify the minimum of the axis of PA.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_f_min">f_min</code></td>
<td>
<p>Numeric. Specify the minimum of the axis of fitness.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_f_max">f_max</code></td>
<td>
<p>Numeric. Specify the maximum of the axis of fitness.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_plot_true_degree">plot_true_degree</code></td>
<td>
<p>Logical. The degree of each node is plotted or not.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_label_x">label_x</code></td>
<td>
<p>String. The label of x-axis.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_label_y">label_y</code></td>
<td>
<p>String. The label of y-axis.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_col_interval">col_interval</code></td>
<td>
<p>String. The name of the color of the confidence intervals. Default value is <code>"lightsteelblue"</code>.</p>
</td></tr>
<tr><td><code id="plot.Full_PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying plotting function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the desired plot.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Since the runtime is long, we do not let this example run on CRAN
## Not run: 
library("PAFit")
set.seed(1)
# a network from Bianconi-Barabasi model
net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                          num_seed = 100  , multiple_node = 100,
                          s        = 10)
net_stats  &lt;- get_statistics(net)
result     &lt;- joint_estimate(net, net_stats)
#plot A
plot(result , net_stats , plot = "A")
true_A     &lt;- c(1,result$estimate_result$center_k[-1])
lines(result$estimate_result$center_k + 1 , true_A , col = "red") # true line
legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
#plot true_f
plot(result, net_stats , net$fitness, plot = "true_f")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PA_result'>
Plotting the estimated attachment function
</h2><span id='topic+plot.PA_result'></span>

<h3>Description</h3>

<p>This function plots the estimated attachment function from the corrected Newman's method or the Jeong's method. Its also plots additional information such as the estimated attachment exponenent (<code class="reqn">\alpha</code> when assuming <code class="reqn">A_k = k^\alpha</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PA_result'
plot(x, 
     net_stat    = NULL,
     plot_bin    = TRUE   ,
     high_deg    = 1      ,  
     line        = FALSE  , 
     col_point   = "black",
     shade_point = 0.5    , 
     pch         = 16     ,
     max_A       = NULL   , 
     min_A       = NULL   , 
     label_x     = NULL   , 
     label_y     = NULL   ,
     ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PA_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>PA_result</code>, containing the estimated attachment function and the estimated attachment exponenet from either <code><a href="#topic+Newman">Newman</a></code> or <code><a href="#topic+Jeong">Jeong</a></code> functions. 
</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PA_data</code>, containing the summerized statistics. This object is created from the function <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_plot_bin">plot_bin</code></td>
<td>
<p>Logical. If <code>TRUE</code> then only the center of each bin is plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_high_deg">high_deg</code></td>
<td>
<p>Integer. Specifies the starting degree from which <code class="reqn">A_k</code> is plotted. If this parameter is specified, the estimated attachment function is plotted from <code>k = high_deg</code></p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_line">line</code></td>
<td>

<p>Logical. Indicates whether to plot the line fitted from the log-linear model or not. Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_col_point">col_point</code></td>
<td>
<p>String. The name of the color of the points. Default value is <code class="reqn">"black"</code>.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_shade_point">shade_point</code></td>
<td>

<p>Numeric. Value between <code>0</code> and <code>1</code>. This is the transparency level of the points. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_pch">pch</code></td>
<td>
<p>Numeric. The plot symbol. Default value is <code>16</code>.</p>
</td></tr>  
<tr><td><code id="plot.PA_result_+3A_max_a">max_A</code></td>
<td>
<p>Numeric. Specify the maximum of the horizontal axis.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_min_a">min_A</code></td>
<td>
<p>Numeric. Specify the minimum of the horizontal axis.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_label_x">label_x</code></td>
<td>
<p>String. The label of x-axis. If <code>NULL</code>, then <code>"Degree k"</code> is used.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_label_y">label_y</code></td>
<td>
<p>String. The label of y-axis. If <code>NULL</code>, then <code>"Attachment function"</code> is used.</p>
</td></tr>
<tr><td><code id="plot.PA_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying plotting function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the desired plot.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  net        &lt;- generate_net(N = 1000 , m = 1 , mode = 1 , alpha = 1 , s = 0)
  net_stats  &lt;- get_statistics(net)
  result     &lt;- Newman(net, net_stats)
  # true function
  true_A     &lt;- result$center_k
  # plot the estimated attachment function
  plot(result , net_stats)
  lines(result$center_k, true_A, col = "red") # true attachment function
  legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
</code></pre>

<hr>
<h2 id='plot.PAFit_net'>
Plot a <code>PAFit_net</code> object
</h2><span id='topic+plot.PAFit_net'></span>

<h3>Description</h3>

<p>This function plots a <code>PAFit_net</code> object. There are four options of <code>plot</code> to specify the type of plot. 
</p>
<p>The first two concern plotting the graph in <code>$graph</code> of the <code>PAFit_net</code> object. Option <code>plot = "graph"</code> plots the graph, while <code>plot = "degree"</code> plots the degree distribution. Option <code>slice</code> allows selection of the time-step at which the temporal graph is plotted. 
</p>
<p>The last two options concern plotting the PA function and node fitnesses (if they are not <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PAFit_net'
plot(x,
     plot = "graph"                         ,
     slice = length(unique(x$graph[,3])) - 1,
     ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PAFit_net_+3A_x">x</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_net_+3A_plot">plot</code></td>
<td>

<p>String. Possible values are <code>"graph"</code>, <code>"degree"</code>, <code>"PA"</code>, and <code>"fit"</code>. Default value is <code>"graph"</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_net_+3A_slice">slice</code></td>
<td>

<p>Integer. Ignored when <code>plot</code> is not <code>"graph"</code> or <code>"degree"</code>. Specifies the time-step at which the graph is plotted. Default value is the final time-step.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_net_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying plotting function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the desired plot.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>. When <code>plot = "graph"</code>, the function uses <code><a href="network.html#topic+plot.network.default">plot.network.default</a></code> in the <span class="pkg">network</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library("PAFit")
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
    plot(net, plot = "graph")
    plot(net, plot = "degree")
    plot(net, plot = "PA")
    plot(net, plot = "fit")
</code></pre>

<hr>
<h2 id='plot.PAFit_result'>
Plotting the estimated attachment function and node fitness of a <code>PAFit_result</code> object
</h2><span id='topic+plot.PAFit_result'></span>

<h3>Description</h3>

<p>This function plots the estimated attachment function <code class="reqn">A_k</code> and node fitness <code class="reqn">eta_i</code>, together with additional information such as their confidence intervals or the estimated attachment exponent (<code class="reqn">\alpha</code> when assuming <code class="reqn">A_k = k^\alpha</code>) of a <code>PAFit_result</code> object. This object is stored in the field <code>$estimate_result</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_result'
plot(x,
    net_stat       = NULL    ,
    true_f         = NULL    , plot             = "A"              , plot_bin   = TRUE ,
    line           = FALSE   , confidence       = TRUE             , high_deg_A = 1    ,
    high_deg_f     = 5       ,
    shade_point    = 0.5     , col_point        = "grey25"         , pch        = 16   ,
    shade_interval = 0.5     , col_interval     = "lightsteelblue" , label_x    = NULL , 
    label_y        = NULL    ,
    max_A          = NULL    , min_A            = NULL             , f_min      = NULL , 
    f_max          = NULL    , plot_true_degree = FALSE , 
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PAFit_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>PAFit_result</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_net_stat">net_stat</code></td>
<td>

<p>An object of class <code>PAFit_data</code>, containing the summerized statistics.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_true_f">true_f</code></td>
<td>

<p>Vector. Optional parameter for the true value of node fitnesses (only available in simulated datasets). If this parameter is specified and <code>plot == "true_f"</code>, a plot of estimated <code class="reqn">\eta</code> versus true <code class="reqn">\eta</code> is produced (after a suitable rescaling of the estimated <code class="reqn">f</code>).  
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_plot">plot</code></td>
<td>

<p>String. Indicates which plot is produced. 
</p>

<ul>
<li><p> If <code>"A"</code> then PA function is plotted. 
</p>
</li>
<li><p> If <code>"f"</code> then the histogram of estimated fitness is plotted. 
</p>
</li>
<li><p> If <code>"true_f"</code> then estimated fitness and true fitness are plotted together (require supplement of true fitness). 
</p>
</li></ul>

<p>Default value is <code>"A"</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_plot_bin">plot_bin</code></td>
<td>
<p>Logical. If <code>TRUE</code> then only the center of each bin is plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_line">line</code></td>
<td>

<p>Logical. Indicates whether to plot the line fitted from the log-linear model or not. Default value is <code class="reqn">TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_confidence">confidence</code></td>
<td>

<p>Logical. Indicates whether to plot the confidence intervals of <code class="reqn">A_k</code> and <code class="reqn">eta_i</code> or not. If confidence == TRUE, a 2-sigma confidence interval will be plotted at each <code class="reqn">A_k</code> and <code class="reqn">eta_i</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_high_deg_a">high_deg_A</code></td>
<td>
<p>Integer. The estimated PA function is plotted starting from <code>high_deg_A</code>. Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_high_deg_f">high_deg_f</code></td>
<td>
<p>Integer. If <code>plot == "true_f"</code>, only nodes whose number of edges acquired is not less than <code>high_deg_f</code> are plotted. Default value is <code>5</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_col_point">col_point</code></td>
<td>
<p>String. The name of the color of the points. Default value is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_shade_point">shade_point</code></td>
<td>

<p>Numeric. Value between 0 and 1. This is the transparency level of the points. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_pch">pch</code></td>
<td>
<p>Numeric. The plot symbol. Default value is <code>16</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_shade_interval">shade_interval</code></td>
<td>

<p>Numeric. Value between 0 and 1. This is the transparency level of the confidence intervals. Default value is <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_max_a">max_A</code></td>
<td>
<p>Numeric. Specify the maximum of the axis of PA.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_min_a">min_A</code></td>
<td>
<p>Numeric. Specify the minimum of the axis of PA.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_f_min">f_min</code></td>
<td>
<p>Numeric. Specify the minimum of the axis of fitness.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_f_max">f_max</code></td>
<td>
<p>Numeric. Specify the maximum of the axis of fitness.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_plot_true_degree">plot_true_degree</code></td>
<td>
<p>Logical. The degree of each node is plotted or not.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_label_x">label_x</code></td>
<td>
<p>String. The label of x-axis.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_label_y">label_y</code></td>
<td>
<p>String. The label of y-axis.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_col_interval">col_interval</code></td>
<td>
<p>String. The name of the color of the confidence intervals. Default value is <code>"lightsteelblue"</code>.</p>
</td></tr>
<tr><td><code id="plot.PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the underlying plotting function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the desired plot.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    #plot A
    plot(result$estimate_result , net_stats , plot = "A")
    true_A     &lt;- c(1,result$estimate_result$center_k[-1])
    lines(result$estimate_result$center_k + 1 , true_A , col = "red") # true line
    legend("topleft" , legend = "True function" , col = "red" , lty = 1 , bty = "n")
    #plot true_f
    plot(result, net_stats , net$fitness, plot = "true_f")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.CV_Data'>
Printing simple information of the cross-validation data
</h2><span id='topic+print.CV_Data'></span>

<h3>Description</h3>

<p>This function prints simple information of the cross-validation data stored in a <code>CV_Data</code> object. This object is the field <code>$cv_data</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'CV_Data'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CV_Data_+3A_x">x</code></td>
<td>

<p>An object of class <code>CV_Data</code>.
</p>
</td></tr>
<tr><td><code id="print.CV_Data_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints simple information of the cross-validation data.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    print(result$cv_data)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.CV_Result'>
Printing simple information of the cross-validation result
</h2><span id='topic+print.CV_Result'></span>

<h3>Description</h3>

<p>This function prints simple information of the cross-validation result stored in a <code>CV_Result</code> object. This object is the field <code>$cv_result</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'CV_Result'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CV_Result_+3A_x">x</code></td>
<td>

<p>An object of class <code>CV_Result</code>.
</p>
</td></tr>
<tr><td><code id="print.CV_Result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints simple information of the cross-validation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    print(result$cv_result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.Full_PAFit_result'>
printing information on the estimation result
</h2><span id='topic+print.Full_PAFit_result'></span>

<h3>Description</h3>

<p>This function outputs simple information of the estimation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'Full_PAFit_result'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Full_PAFit_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>Full_PAFit_result</code>, containing the estimated results from <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>.
</p>
</td></tr>
<tr><td><code id="print.Full_PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information on the estimation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    print(result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.PA_result'>
Printing information of the estimated attachment function
</h2><span id='topic+print.PA_result'></span>

<h3>Description</h3>

<p>This function outputs simple information of the estimated attachment function from the corrected Newman's method or the Jeong's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PA_result'
print(x, 
                              ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PA_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>PA_result</code>, containing the estimated attachment function and the estimated attachment exponenet from either <code><a href="#topic+Newman">Newman</a></code> or <code><a href="#topic+Jeong">Jeong</a></code> functions. 
</p>
</td></tr>
<tr><td><code id="print.PA_result_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simple information of the estimated attachment function.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  net        &lt;- generate_net(N = 1000 , m = 1 , mode = 1 , alpha = 1 , s = 0)
  net_stats  &lt;- get_statistics(net)
  result     &lt;- Newman(net, net_stats)
  print(result)
</code></pre>

<hr>
<h2 id='print.PAFit_data'>
Printing simple information on the statistics of the network stored in a <code>PAFit_data</code> object
</h2><span id='topic+print.PAFit_data'></span>

<h3>Description</h3>

<p>This function prints simple information of the statistics stored in a <code>PAFit_data</code> object. This object is the returning value of <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_data'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PAFit_data_+3A_x">x</code></td>
<td>

<p>An object of class <code>PAFit_data</code>.
</p>
</td></tr>
<tr><td><code id="print.PAFit_data_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints simple information of the network statistics.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    print(net_stats)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.PAFit_net'>
Printing simple information of a <code>PAFit_net</code> object
</h2><span id='topic+print.PAFit_net'></span>

<h3>Description</h3>

<p>This function outputs simple information of a <code>PAFit_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_net'
print(x,
                            ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PAFit_net_+3A_x">x</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
<tr><td><code id="print.PAFit_net_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs simple information of the network. 
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # a network from Bianconi-Barabasi model
  net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
  print(net)
</code></pre>

<hr>
<h2 id='print.PAFit_result'>
printing information on the estimation result stored in a <code>PAFit_result</code> object
</h2><span id='topic+print.PAFit_result'></span>

<h3>Description</h3>

<p>This function outputs simple information of the estimation result stored in a <code>PAFit_result</code> object. This object is stored in the field <code>$estimate_result</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_result'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PAFit_result_+3A_x">x</code></td>
<td>

<p>An object of class <code>PAFit_result</code>.
</p>
</td></tr>
<tr><td><code id="print.PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information on the estimation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    print(result$estimate_result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.CV_Data'>
Printing summary information of the cross-validation data
</h2><span id='topic+summary.CV_Data'></span>

<h3>Description</h3>

<p>This function outputs summary information of the cross-validation data stored in a <code>CV_Data</code> object. This object is the field <code>$cv_data</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'CV_Data'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CV_Data_+3A_object">object</code></td>
<td>

<p>An object of class <code>CV_Data</code>.
</p>
</td></tr>
<tr><td><code id="summary.CV_Data_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information of the cross-validation data.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    summary(result$cv_data)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.CV_Result'>
Output summary information of the cross-validation result
</h2><span id='topic+summary.CV_Result'></span>

<h3>Description</h3>

<p>This function outputs summary information of the cross-validation result stored in a <code>CV_Result</code> object. This object is the field <code>$cv_result</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'CV_Result'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CV_Result_+3A_object">object</code></td>
<td>

<p>An object of class <code>CV_Result</code>.
</p>
</td></tr>
<tr><td><code id="summary.CV_Result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information of the cross-validation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    summary(result$cv_result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.Full_PAFit_result'>
Summary information on the estimation result
</h2><span id='topic+summary.Full_PAFit_result'></span>

<h3>Description</h3>

<p>This function outputs a summary on the estimation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'Full_PAFit_result'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Full_PAFit_result_+3A_object">object</code></td>
<td>

<p>An object of class <code>Full_PAFit_result</code>, containing the estimated results from <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.Full_PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information on the estimation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    summary(result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.PA_result'>
Summary of the estimated attachment function
</h2><span id='topic+summary.PA_result'></span>

<h3>Description</h3>

<p>This function outputs summary information of the estimated attachment function from the corrected Newman's method or the Jeong's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PA_result'
summary(object, 
                           ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PA_result_+3A_object">object</code></td>
<td>

<p>An object of class <code>PA_result</code>, containing the estimated attachment function and the estimated attachment exponenet from either <code><a href="#topic+Newman">Newman</a></code> or <code><a href="#topic+Jeong">Jeong</a></code> functions. 
</p>
</td></tr>
<tr><td><code id="summary.PA_result_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary information of the estimated attachment function.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  net        &lt;- generate_net(N = 1000 , m = 1 , mode = 1 , alpha = 1 , s = 0)
  net_stats  &lt;- get_statistics(net)
  result     &lt;- Newman(net, net_stats)
  summary(result)
</code></pre>

<hr>
<h2 id='summary.PAFit_data'>
Output summary information on the statistics of the network stored in a <code>PAFit_data</code> object
</h2><span id='topic+summary.PAFit_data'></span>

<h3>Description</h3>

<p>This function outputs summary information of the statistics stored in a <code>PAFit_data</code> object. This object is the returning value of <code><a href="#topic+get_statistics">get_statistics</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_data'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PAFit_data_+3A_object">object</code></td>
<td>

<p>An object of class <code>PAFit_data</code>.
</p>
</td></tr>
<tr><td><code id="summary.PAFit_data_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information of the network statistics.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    summary(net_stats)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.PAFit_net'>
Summary information of a <code>PAFit_net</code> object
</h2><span id='topic+summary.PAFit_net'></span>

<h3>Description</h3>

<p>This function outputs summary information of a <code>PAFit_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_net'
summary(object,
                           ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PAFit_net_+3A_object">object</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
<tr><td><code id="summary.PAFit_net_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information of the network. 
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # a network from Bianconi-Barabasi model
  net        &lt;- generate_BB(N = 50 , m = 10 , s = 10)
  summary(net)
</code></pre>

<hr>
<h2 id='summary.PAFit_result'>
Output summary information on the estimation result stored in a <code>PAFit_result</code> object
</h2><span id='topic+summary.PAFit_result'></span>

<h3>Description</h3>

<p>This function outputs summary information of the estimation result stored in a <code>PAFit_result</code> object. This object is stored in the field <code>$estimate_result</code> of a <code>Full_PAFit_result</code> object, which in turn is the returning value of <code><a href="#topic+only_A_estimate">only_A_estimate</a></code>, <code><a href="#topic+only_F_estimate">only_F_estimate</a></code> or <code><a href="#topic+joint_estimate">joint_estimate</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'PAFit_result'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PAFit_result_+3A_object">object</code></td>
<td>

<p>An object of class <code>PAFit_result</code>.
</p>
</td></tr>
<tr><td><code id="summary.PAFit_result_+3A_...">...</code></td>
<td>

<p>Other arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs summary information on the estimation result.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Since the runtime is long, we do not let this example run on CRAN
  ## Not run: 
    library("PAFit")
    set.seed(1)
    # a network from Bianconi-Barabasi model
    net        &lt;- generate_BB(N        = 1000 , m             = 50 , 
                              num_seed = 100  , multiple_node = 100,
                              s        = 10)
    net_stats  &lt;- get_statistics(net)
    result     &lt;- joint_estimate(net, net_stats)
    summary(result$estimate_result)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='test_linear_PA'>
Fitting various distributions to a degree vector
</h2><span id='topic+test_linear_PA'></span>

<h3>Description</h3>

<p>This function implements the method in Handcock and Jones (2004) to fit various distributions to a degree vector. The implemented distributions are Yule, Waring, Poisson, geometric and negative binomial. The Yule and Waring distributions correspond to a preferential attachment situation. In particular, the two distributions correspond to the case of <code class="reqn">A_k = k</code> for <code class="reqn">k \ge 1</code> and <code class="reqn">\eta_i = 1</code> for all <code class="reqn">i</code> (note that, the number of new edges and new nodes at each time-step are implicitly assumed to be <code class="reqn">1</code>). 
</p>
<p>Thus, if the best fitted distribution, which is chosen by either the Akaike Information Criterion (AIC) or the Bayesian Information Criterion (BIC), is NOT Yule or Waring, then the case of <code class="reqn">A_k = k</code> for <code class="reqn">k \ge 1</code> and  <code class="reqn">\eta_i = 1</code> for all <code class="reqn">i</code>  is NOT consistent with the observed degree vector.
</p>
<p>The method allows the low-tail probabilities to NOT follow the parametric distribution, i.e., <code class="reqn">P(K = k) = \pi_k</code> for all <code class="reqn">k \le k_{min}</code> and <code class="reqn">P(K = k) = f(k,\theta)</code> for all <code class="reqn">k &gt; k_{min}</code>. Here <code class="reqn">k_{min}</code> is the degree threshold above which the parametric distribution holds, <code class="reqn">\pi_k</code> are probabilities of the low-tail, <code class="reqn">f(.,\theta)</code> is the parametric distribution with parameter vector <code class="reqn">\theta</code>. 
</p>
<p>For fixed <code class="reqn">k_{min}</code> and <code class="reqn">f</code>, <code class="reqn">\pi_k</code> and <code class="reqn">\theta</code> can be estimated by Maximum Likelihood Estimation. We can choose the best <code class="reqn">k_{min}</code> for each <code class="reqn">f</code> by comparing the AIC (or BIC). More details can be founded in Handcock and Jones (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> test_linear_PA(degree_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_linear_PA_+3A_degree_vector">degree_vector</code></td>
<td>

<p>a degree vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a <code>Linear_PA_test_result</code> object which contains the fitting of five distributions to the degree vector: Yule (<code>yule</code>), Waring (<code>waring</code>), Poisson (<code>pois</code>), geometric (<code>geom</code>) and negative binomial (<code>nb</code>). In particular, for each distribution, the AIC and BIC are calcualted for each <code class="reqn">k_min</code>. 
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>References</h3>

<p>1. Handcock MS, Jones JH (2004). “Likelihood-based inference for stochastic models of sexual network formation.” Theoretical Population Biology, 65(4), 413 – 422. ISSN 0040-5809. <a href="https://doi.org/10.1016/j.tpb.2003.09.006">doi:10.1016/j.tpb.2003.09.006</a>. Demography in the 21st Century, <a href="https://www.sciencedirect.com/science/article/pii/S0040580904000310">https://www.sciencedirect.com/science/article/pii/S0040580904000310</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library("PAFit")
  set.seed(1)
  net   &lt;- generate_BA(n = 1000)
  stats &lt;- get_statistics(net, only_PA = TRUE)
  u     &lt;- test_linear_PA(stats$final_deg)
  print(u)

## End(Not run)
</code></pre>

<hr>
<h2 id='to_igraph'>
Convert a PAFit_net object to an igraph object
</h2><span id='topic+to_igraph'></span>

<h3>Description</h3>

<p>This function converts a <code>PAFit_net</code> object to an <code>igraph</code> object (of package <span class="pkg">igraph</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_igraph(net_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_igraph_+3A_net_object">net_object</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an <code>igraph</code> object.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PAFit")
# a network from Bianconi-Barabasi model
net          &lt;- generate_BB(N = 50 , m = 10 , s = 10)
igraph_graph &lt;- to_igraph(net)
</code></pre>

<hr>
<h2 id='to_networkDynamic'>
Convert a PAFit_net object to a networkDynamic object
</h2><span id='topic+to_networkDynamic'></span>

<h3>Description</h3>

<p>This function converts a <code>PAFit_net</code> object to a <code>networkDynamic</code> object (of package <span class="pkg">networkDynamic</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  to_networkDynamic(net_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_networkDynamic_+3A_net_object">net_object</code></td>
<td>

<p>An object of class <code>PAFit_net</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>networkDynamic</code> object.
</p>


<h3>Author(s)</h3>

<p>Thong Pham <a href="mailto:thongphamthe@gmail.com">thongphamthe@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("PAFit")
  # a network from Bianconi-Barabasi model
  net          &lt;- generate_BB(N = 50 , m = 10 , s = 10)
  nD_graph     &lt;- to_networkDynamic(net)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
