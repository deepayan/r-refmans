<!DOCTYPE html><html lang="en"><head><title>Help for package httr2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {httr2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#httr2-package'><p>httr2: Perform HTTP Requests and Process the Responses</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#curl_translate'><p>Translate curl syntax to httr2</p></a></li>
<li><a href='#example_url'><p>Code for examples</p></a></li>
<li><a href='#is_online'><p>Is your computer currently online?</p></a></li>
<li><a href='#iterate_with_offset'><p>Iteration helpers</p></a></li>
<li><a href='#jwt_claim'><p>Create and encode a JWT</p></a></li>
<li><a href='#last_response'><p>Retrieve most recent request/response</p></a></li>
<li><a href='#multi_req_perform'><p>Perform a list of requests in parallel</p></a></li>
<li><a href='#oauth_cache_clear'><p>Clear OAuth cache</p></a></li>
<li><a href='#oauth_cache_path'><p>httr2 OAuth cache location</p></a></li>
<li><a href='#oauth_client'><p>Create an OAuth client</p></a></li>
<li><a href='#oauth_client_req_auth'><p>OAuth client authentication</p></a></li>
<li><a href='#oauth_flow_auth_code_url'><p>OAuth authorization code components</p></a></li>
<li><a href='#oauth_redirect_uri'><p>Default redirect url for OAuth</p></a></li>
<li><a href='#oauth_token'><p>Create an OAuth token</p></a></li>
<li><a href='#oauth_token_cached'><p>Retrieve an OAuth token using the cache</p></a></li>
<li><a href='#obfuscate'><p>Obfuscate mildly secret information</p></a></li>
<li><a href='#progress_bars'><p>Progress bars in httr2</p></a></li>
<li><a href='#req_auth_aws_v4'><p>Sign a request with the AWS SigV4 signing protocol</p></a></li>
<li><a href='#req_auth_basic'><p>Authenticate request with HTTP basic authentication</p></a></li>
<li><a href='#req_auth_bearer_token'><p>Authenticate request with bearer token</p></a></li>
<li><a href='#req_body'><p>Send data in request body</p></a></li>
<li><a href='#req_cache'><p>Automatically cache requests</p></a></li>
<li><a href='#req_cookie_preserve'><p>Set and preserve cookies</p></a></li>
<li><a href='#req_dry_run'><p>Perform a dry run</p></a></li>
<li><a href='#req_error'><p>Control handling of HTTP errors</p></a></li>
<li><a href='#req_headers'><p>Modify request headers</p></a></li>
<li><a href='#req_method'><p>Set HTTP method in request</p></a></li>
<li><a href='#req_oauth'><p>OAuth authentication</p></a></li>
<li><a href='#req_oauth_auth_code'><p>OAuth with authorization code</p></a></li>
<li><a href='#req_oauth_bearer_jwt'><p>OAuth with a bearer JWT (JSON web token)</p></a></li>
<li><a href='#req_oauth_client_credentials'><p>OAuth with client credentials</p></a></li>
<li><a href='#req_oauth_device'><p>OAuth with device flow</p></a></li>
<li><a href='#req_oauth_password'><p>OAuth with username and password</p></a></li>
<li><a href='#req_oauth_refresh'><p>OAuth with a refresh token</p></a></li>
<li><a href='#req_oauth_token_exchange'><p>OAuth token exchange</p></a></li>
<li><a href='#req_options'><p>Set arbitrary curl options in request</p></a></li>
<li><a href='#req_perform'><p>Perform a request to get a response</p></a></li>
<li><a href='#req_perform_connection'><p>Perform a request and return a streaming connection</p></a></li>
<li><a href='#req_perform_iterative'><p>Perform requests iteratively, generating new requests from previous responses</p></a></li>
<li><a href='#req_perform_parallel'><p>Perform a list of requests in parallel</p></a></li>
<li><a href='#req_perform_promise'><p>Perform request asynchronously using the promises package</p></a></li>
<li><a href='#req_perform_sequential'><p>Perform multiple requests in sequence</p></a></li>
<li><a href='#req_perform_stream'><p>Perform a request and handle data as it streams back</p></a></li>
<li><a href='#req_progress'><p>Add a progress bar to long downloads or uploads</p></a></li>
<li><a href='#req_proxy'><p>Use a proxy for a request</p></a></li>
<li><a href='#req_retry'><p>Automatically retry a request on failure</p></a></li>
<li><a href='#req_template'><p>Set request method/path from a template</p></a></li>
<li><a href='#req_throttle'><p>Rate limit a request by automatically adding a delay</p></a></li>
<li><a href='#req_timeout'><p>Set time limit for a request</p></a></li>
<li><a href='#req_url'><p>Modify request URL</p></a></li>
<li><a href='#req_user_agent'><p>Set user-agent for a request</p></a></li>
<li><a href='#req_verbose'><p>Show extra output when request is performed</p></a></li>
<li><a href='#request'><p>Create a new HTTP request</p></a></li>
<li><a href='#resp_body_raw'><p>Extract body from response</p></a></li>
<li><a href='#resp_check_content_type'><p>Check the content type of a response</p></a></li>
<li><a href='#resp_content_type'><p>Extract response content type and encoding</p></a></li>
<li><a href='#resp_date'><p>Extract request date from response</p></a></li>
<li><a href='#resp_headers'><p>Extract headers from a response</p></a></li>
<li><a href='#resp_link_url'><p>Parse link URL from a response</p></a></li>
<li><a href='#resp_raw'><p>Show the raw response</p></a></li>
<li><a href='#resp_request'><p>Find the request responsible for a response</p></a></li>
<li><a href='#resp_retry_after'><p>Extract wait time from a response</p></a></li>
<li><a href='#resp_status'><p>Extract HTTP status from response</p></a></li>
<li><a href='#resp_stream_raw'><p>Read a streaming body a chunk at a time</p></a></li>
<li><a href='#resp_url'><p>Get URL/components from the response</p></a></li>
<li><a href='#response'><p>Create a new HTTP response</p></a></li>
<li><a href='#resps_successes'><p>Tools for working with lists of responses</p></a></li>
<li><a href='#secrets'><p>Secret management</p></a></li>
<li><a href='#signal_total_pages'><p>Signal total number pages</p></a></li>
<li><a href='#throttle_status'><p>Display internal throttle status</p></a></li>
<li><a href='#url_build'><p>Build a string from a URL object</p></a></li>
<li><a href='#url_modify'><p>Modify a URL</p></a></li>
<li><a href='#url_parse'><p>Parse a URL into its component pieces</p></a></li>
<li><a href='#url_query_parse'><p>Parse query parameters and/or build a string</p></a></li>
<li><a href='#with_mocked_responses'><p>Temporarily mock requests</p></a></li>
<li><a href='#with_verbosity'><p>Temporarily set verbosity for all requests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Perform HTTP Requests and Process the Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for creating and modifying HTTP requests, then
    performing them and processing the results. 'httr2' is a modern
    re-imagining of 'httr' that uses a pipe-based interface and solves
    more of the problems that API wrapping packages face.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://httr2.r-lib.org">https://httr2.r-lib.org</a>, <a href="https://github.com/r-lib/httr2">https://github.com/r-lib/httr2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/httr2/issues">https://github.com/r-lib/httr2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.0), curl (&ge; 6.2.1), glue, lifecycle, magrittr,
openssl, R6, rappdirs, rlang (&ge; 1.1.0), vctrs (&ge; 0.6.3),
withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>askpass, bench, clipr, covr, docopt, httpuv, jose, jsonlite,
knitr, later (&ge; 1.4.0), paws.common, promises, rmarkdown,
testthat (&ge; 3.1.8), tibble, webfakes, xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>multi-req, resp-stream, req-perform</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-05 14:50:50 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Posit Software, PBC [cph, fnd],
  Maximilian Girlich [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-08 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='httr2-package'>httr2: Perform HTTP Requests and Process the Responses</h2><span id='topic+httr2'></span><span id='topic+httr2-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Tools for creating and modifying HTTP requests, then performing them and processing the results. 'httr2' is a modern re-imagining of 'httr' that uses a pipe-based interface and solves more of the problems that API wrapping packages face.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p> Maximilian Girlich [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://httr2.r-lib.org">https://httr2.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/httr2">https://github.com/r-lib/httr2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/httr2/issues">https://github.com/r-lib/httr2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='curl_translate'>Translate curl syntax to httr2</h2><span id='topic+curl_translate'></span><span id='topic+curl_help'></span>

<h3>Description</h3>

<p>The curl command line tool is commonly used to demonstrate HTTP APIs and can
easily be generated from
<a href="https://everything.curl.dev/cmdline/copyas.html">browser developer tools</a>.
<code>curl_translate()</code> saves you the pain of manually translating these calls
by implementing a partial, but frequently used, subset of curl options.
Use <code>curl_help()</code> to see the supported options, and <code>curl_translate()</code>
to translate a curl invocation copy and pasted from elsewhere.
</p>
<p>Inspired by <a href="https://github.com/hrbrmstr/curlconverter">curlconverter</a>
written by <a href="https://rud.is/b/">Bob Rudis</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_translate(cmd, simplify_headers = TRUE)

curl_help()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curl_translate_+3A_cmd">cmd</code></td>
<td>
<p>Call to curl. If omitted and the clipr package is installed,
will be retrieved from the clipboard.</p>
</td></tr>
<tr><td><code id="curl_translate_+3A_simplify_headers">simplify_headers</code></td>
<td>
<p>Remove typically unimportant headers included when
copying a curl command from the browser. This includes:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;sec-fetch-*&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sec-ch-ua*&#8288;</code>
</p>
</li>
<li> <p><code>referer</code>, <code>pragma</code>, <code>connection</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the translated httr2 code. If the input
was copied from the clipboard, the translation will be copied back
to the clipboard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curl_translate("curl http://example.com")
curl_translate("curl http://example.com -X DELETE")
curl_translate("curl http://example.com --header A:1 --header B:2")
curl_translate("curl http://example.com --verbose")
</code></pre>

<hr>
<h2 id='example_url'>Code for examples</h2><span id='topic+example_url'></span><span id='topic+example_github_client'></span>

<h3>Description</h3>

<p><code>example_url()</code> runs a simple websever using the webfakes package with the
following endpoints:
</p>

<ul>
<li><p> all the ones from the <code><a href="webfakes.html#topic+httpbin_app">webfakes::httpbin_app()</a></code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;/iris&#8288;</code>: paginate through the iris dataset. It has the query parameters
<code>page</code> and <code>limit</code> to control the pagination.
</p>
</li></ul>

<p><code>example_github_client()</code> is an OAuth client for GitHub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_url(path = "/")

example_github_client()
</code></pre>

<hr>
<h2 id='is_online'>Is your computer currently online?</h2><span id='topic+is_online'></span>

<h3>Description</h3>

<p>This function uses some cheap heuristics to determine if your computer is
currently online. It's a simple wrapper around <code><a href="curl.html#topic+nslookup">curl::has_internet()</a></code>
exported from httr2 for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_online()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>is_online()
</code></pre>

<hr>
<h2 id='iterate_with_offset'>Iteration helpers</h2><span id='topic+iterate_with_offset'></span><span id='topic+iterate_with_cursor'></span><span id='topic+iterate_with_link_url'></span>

<h3>Description</h3>

<p>These functions are intended for use with the <code>next_req</code> argument to
<code><a href="#topic+req_perform_iterative">req_perform_iterative()</a></code>. Each implements iteration for a common
pagination pattern:
</p>

<ul>
<li> <p><code>iterate_with_offset()</code> increments a query parameter, e.g. <code>?page=1</code>,
<code>?page=2</code>, or <code>?offset=1</code>, <code>offset=21</code>.
</p>
</li>
<li> <p><code>iterate_with_cursor()</code> updates a query parameter with the value of a
cursor found somewhere in the response.
</p>
</li>
<li> <p><code>iterate_with_link_url()</code> follows the url found in the <code>Link</code> header.
See <code>resp_link_url()</code> for more details.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>iterate_with_offset(
  param_name,
  start = 1,
  offset = 1,
  resp_pages = NULL,
  resp_complete = NULL
)

iterate_with_cursor(param_name, resp_param_value)

iterate_with_link_url(rel = "next")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_with_offset_+3A_param_name">param_name</code></td>
<td>
<p>Name of query parameter.</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_start">start</code></td>
<td>
<p>Starting value.</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_offset">offset</code></td>
<td>
<p>Offset for each page. The default is set to <code>1</code> so you get
(e.g.) <code>?page=1</code>, <code>?page=2</code>, ... If <code>param_name</code> refers to an element
index (rather than a page index) you'll want to set this to a larger number
so you get (e.g.) <code>?items=20</code>, <code>?items=40</code>, ...</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_resp_pages">resp_pages</code></td>
<td>
<p>A callback function that takes a response (<code>resp</code>) and
returns the total number of pages, or <code>NULL</code> if unknown. It will only
be called once.</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_resp_complete">resp_complete</code></td>
<td>
<p>A callback function that takes a response (<code>resp</code>)
and returns <code>TRUE</code> if there are no further pages.</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_resp_param_value">resp_param_value</code></td>
<td>
<p>A callback function that takes a response (<code>resp</code>)
and returns the next cursor value. Return <code>NULL</code> if there are no further
pages.</p>
</td></tr>
<tr><td><code id="iterate_with_offset_+3A_rel">rel</code></td>
<td>
<p>The &quot;link relation type&quot; to use to retrieve the next page.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url()) |&gt;
  req_url_path("/iris") |&gt;
  req_throttle(10) |&gt;
  req_url_query(limit = 50)

# If you don't know the total number of pages in advance, you can
# provide a `resp_complete()` callback
is_complete &lt;- function(resp) {
  length(resp_body_json(resp)$data) == 0
}
resps &lt;- req_perform_iterative(
  req,
  next_req = iterate_with_offset("page_index", resp_complete = is_complete),
  max_reqs = Inf
)

## Not run: 
# Alternatively, if the response returns the total number of pages (or you
# can easily calculate it), you can use the `resp_pages()` callback which
# will generate a better progress bar.

resps &lt;- req_perform_iterative(
  req |&gt; req_url_query(limit = 1),
  next_req = iterate_with_offset(
    "page_index",
    resp_pages = function(resp) resp_body_json(resp)$pages
  ),
  max_reqs = Inf
)

## End(Not run)
</code></pre>

<hr>
<h2 id='jwt_claim'>Create and encode a JWT</h2><span id='topic+jwt_claim'></span><span id='topic+jwt_encode_sig'></span><span id='topic+jwt_encode_hmac'></span>

<h3>Description</h3>

<p><code>jwt_claim()</code> is a wrapper around <code><a href="jose.html#topic+jwt_claim">jose::jwt_claim()</a></code> that creates a JWT
claim set with a few extra default values. <code>jwt_encode_sig()</code> and
<code>jwt_encode_hmac()</code> are thin wrappers around <code><a href="jose.html#topic+jwt_encode">jose::jwt_encode_sig()</a></code> and
<code><a href="jose.html#topic+jwt_encode">jose::jwt_encode_hmac()</a></code> that exist primarily to make specification
in other functions a little simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jwt_claim(
  iss = NULL,
  sub = NULL,
  aud = NULL,
  exp = unix_time() + 5L * 60L,
  nbf = unix_time(),
  iat = unix_time(),
  jti = NULL,
  ...
)

jwt_encode_sig(claim, key, size = 256, header = list())

jwt_encode_hmac(claim, secret, size = 256, header = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jwt_claim_+3A_iss">iss</code></td>
<td>
<p>Issuer claim. Identifies the principal that issued the JWT.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_sub">sub</code></td>
<td>
<p>Subject claim. Identifies the principal that is the subject of
the JWT (i.e. the entity that the claims apply to).</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_aud">aud</code></td>
<td>
<p>Audience claim. Identifies the recipients that the JWT is
intended. Each principle intended to process the JWT must be identified
with a unique value.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_exp">exp</code></td>
<td>
<p>Expiration claim. Identifies the expiration time on or after which
the JWT MUST NOT be accepted for processing. Defaults to 5 minutes.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_nbf">nbf</code></td>
<td>
<p>Not before claim. Identifies the time before which the JWT
MUST NOT be accepted for processing. Defaults to current time.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_iat">iat</code></td>
<td>
<p>Issued at claim. Identifies the time at which the JWT was
issued.  Defaults to current time.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_jti">jti</code></td>
<td>
<p>JWT ID claim. Provides a unique identifier for the JWT.
If omitted, uses a random 32-byte sequence encoded with base64url.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_...">...</code></td>
<td>
<p>Any additional claims to include in the claim set.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_claim">claim</code></td>
<td>
<p>Claim set produced by <code><a href="#topic+jwt_claim">jwt_claim()</a></code>.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_key">key</code></td>
<td>
<p>RSA or EC private key either specified as a path to a file,
a connection, or a string (PEM/SSH format), or a raw vector (DER format).</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_size">size</code></td>
<td>
<p>Size, in bits, of sha2 signature, i.e. 256, 384 or 512.
Only for HMAC/RSA, not applicable for ECDSA keys.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_header">header</code></td>
<td>
<p>A named list giving additional fields to include in the
JWT header.</p>
</td></tr>
<tr><td><code id="jwt_claim_+3A_secret">secret</code></td>
<td>
<p>String or raw vector with a secret passphrase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 list with class <code>jwt_claim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>claim &lt;- jwt_claim()
str(claim)
</code></pre>

<hr>
<h2 id='last_response'>Retrieve most recent request/response</h2><span id='topic+last_response'></span><span id='topic+last_request'></span>

<h3>Description</h3>

<p>These functions retrieve the most recent request made by httr2 and
the response it received, to facilitate debugging problems <em>after</em> they
occur. If the request did not succeed (or no requests have been made)
<code>last_response()</code> will be <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_response()

last_request()
</code></pre>


<h3>Value</h3>

<p>An HTTP <a href="#topic+response">response</a>/<a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>invisible(request("http://httr2.r-lib.org") |&gt; req_perform())
last_request()
last_response()
</code></pre>

<hr>
<h2 id='multi_req_perform'>Perform a list of requests in parallel</h2><span id='topic+multi_req_perform'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Please use <code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code> instead, and note:
</p>

<ul>
<li> <p><code>cancel_on_error = FALSE</code> is now <code>on_error = "continue"</code>
</p>
</li>
<li> <p><code>cancel_on_error = TRUE</code> is now <code>on_error = "return"</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>multi_req_perform(
  reqs,
  paths = NULL,
  pool = deprecated(),
  cancel_on_error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_req_perform_+3A_reqs">reqs</code></td>
<td>
<p>A list of <a href="#topic+request">request</a>s.</p>
</td></tr>
<tr><td><code id="multi_req_perform_+3A_paths">paths</code></td>
<td>
<p>An optional character vector of paths, if you want to download
the response bodies to disk. If supplied, must be the same length as
<code>reqs</code>.</p>
</td></tr>
<tr><td><code id="multi_req_perform_+3A_pool">pool</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. No longer supported;
to control the maximum number of concurrent requests, set <code>max_active</code>.</p>
</td></tr>
<tr><td><code id="multi_req_perform_+3A_cancel_on_error">cancel_on_error</code></td>
<td>
<p>Should all pending requests be cancelled when you
hit an error? Set this to <code>TRUE</code> to stop all requests as soon as you
hit an error. Responses that were never performed be <code>NULL</code> in the result.</p>
</td></tr>
</table>

<hr>
<h2 id='oauth_cache_clear'>Clear OAuth cache</h2><span id='topic+oauth_cache_clear'></span>

<h3>Description</h3>

<p>Use this function to clear cached credentials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_cache_clear(client, cache_disk = FALSE, cache_key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_cache_clear_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="oauth_cache_clear_+3A_cache_disk">cache_disk</code></td>
<td>
<p>Should the access token be cached on disk? This reduces
the number of times that you need to re-authenticate at the cost of
storing access credentials on disk.
</p>
<p>Learn more in <a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.</p>
</td></tr>
<tr><td><code id="oauth_cache_clear_+3A_cache_key">cache_key</code></td>
<td>
<p>If you want to cache multiple tokens per app, use this
key to disambiguate them.</p>
</td></tr>
</table>

<hr>
<h2 id='oauth_cache_path'>httr2 OAuth cache location</h2><span id='topic+oauth_cache_path'></span>

<h3>Description</h3>

<p>When opted-in to, httr2 caches OAuth tokens in this directory. By default,
it uses a OS-standard cache directory, but, if needed, you can override the
location by setting the <code>HTTR2_OAUTH_CACHE</code> env var.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_cache_path()
</code></pre>

<hr>
<h2 id='oauth_client'>Create an OAuth client</h2><span id='topic+oauth_client'></span>

<h3>Description</h3>

<p>An OAuth app is the combination of a client, a set of endpoints
(i.e. urls where various requests should be sent), and an authentication
mechanism. A client consists of at least a <code>client_id</code>, and also often
a <code>client_secret</code>. You'll get these values when you create the client on
the API's website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_client(
  id,
  token_url,
  secret = NULL,
  key = NULL,
  auth = c("body", "header", "jwt_sig"),
  auth_params = list(),
  name = hash(id)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_client_+3A_id">id</code></td>
<td>
<p>Client identifier.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_token_url">token_url</code></td>
<td>
<p>Url to retrieve an access token.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_secret">secret</code></td>
<td>
<p>Client secret. For most apps, this is technically confidential
so in principle you should avoid storing it in source code. However, many
APIs require it in order to provide a user friendly authentication
experience, and the risks of including it are usually low. To make things
a little safer, I recommend using <code><a href="#topic+obfuscate">obfuscate()</a></code> when recording the client
secret in public code.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_key">key</code></td>
<td>
<p>Client key. As an alternative to using a <code>secret</code>, you can
instead supply a confidential private key. This should never be included
in a package.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_auth">auth</code></td>
<td>
<p>Authentication mechanism used by the client to prove itself to
the API. Can be one of three built-in methods (&quot;body&quot;, &quot;header&quot;, or &quot;jwt&quot;),
or a function that will be called with arguments <code>req</code>, <code>client</code>, and
the contents of <code>auth_params</code>.
</p>
<p>The most common mechanism in the wild is <code>"body"</code> where the <code>client_id</code> and
(optionally) <code>client_secret</code> are added to the body. <code>"header"</code> sends the
<code>client_id</code> and <code>client_secret</code> in HTTP Authorization header. <code>"jwt_sig"</code>
will generate a JWT, and include it in a <code>client_assertion</code> field in the
body.
</p>
<p>See <code><a href="#topic+oauth_client_req_auth">oauth_client_req_auth()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_auth_params">auth_params</code></td>
<td>
<p>Additional parameters passed to the function specified
by <code>auth</code>.</p>
</td></tr>
<tr><td><code id="oauth_client_+3A_name">name</code></td>
<td>
<p>Optional name for the client. Used when generating the cache
directory. If <code>NULL</code>, generated from hash of <code>client_id</code>. If you're
defining a client for use in a package, I recommend that you use
the package name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An OAuth client: An S3 list with class <code>httr2_oauth_client</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oauth_client("myclient", "http://example.com/token_url", secret = "DONTLOOK")
</code></pre>

<hr>
<h2 id='oauth_client_req_auth'>OAuth client authentication</h2><span id='topic+oauth_client_req_auth'></span><span id='topic+oauth_client_req_auth_header'></span><span id='topic+oauth_client_req_auth_body'></span><span id='topic+oauth_client_req_auth_jwt_sig'></span>

<h3>Description</h3>

<p><code>oauth_client_req_auth()</code> authenticates a request using the authentication
strategy defined by the <code>auth</code> and <code>auth_param</code> arguments to <code><a href="#topic+oauth_client">oauth_client()</a></code>.
This is used to authenticate the client as part of the OAuth flow, <strong>not</strong>
to authenticate a request on behalf of a user.
</p>
<p>There are three built-in strategies:
</p>

<ul>
<li> <p><code>oauth_client_req_body()</code> adds the client id and (optionally) the secret
to the request body, as described in <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1">Section 2.3.1 of RFC 6749</a>.
</p>
</li>
<li> <p><code>oauth_client_req_header()</code> adds the client id and secret using HTTP
basic authentication with the <code>Authorization</code> header, as described
in <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1">Section 2.3.1 of RFC 6749</a>.
</p>
</li>
<li> <p><code>oauth_client_jwt_rs256()</code> adds a client assertion to the body using a
JWT signed with <code>jwt_sign_rs256()</code> using a private key, as described
in <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.2">Section 2.2 of RFC 7523</a>.
</p>
</li></ul>

<p>You will generally not call these functions directly but will instead
specify them through the <code>auth</code> argument to <code><a href="#topic+oauth_client">oauth_client()</a></code>. The <code>req</code> and
<code>client</code> parameters are automatically filled in; other parameters come from
the <code>auth_params</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_client_req_auth(req, client)

oauth_client_req_auth_header(req, client)

oauth_client_req_auth_body(req, client)

oauth_client_req_auth_jwt_sig(req, client, claim, size = 256, header = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_client_req_auth_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="oauth_client_req_auth_+3A_client">client</code></td>
<td>
<p>An <a href="#topic+oauth_client">oauth_client</a>.</p>
</td></tr>
<tr><td><code id="oauth_client_req_auth_+3A_claim">claim</code></td>
<td>
<p>Claim set produced by <code><a href="#topic+jwt_claim">jwt_claim()</a></code>.</p>
</td></tr>
<tr><td><code id="oauth_client_req_auth_+3A_size">size</code></td>
<td>
<p>Size, in bits, of sha2 signature, i.e. 256, 384 or 512.
Only for HMAC/RSA, not applicable for ECDSA keys.</p>
</td></tr>
<tr><td><code id="oauth_client_req_auth_+3A_header">header</code></td>
<td>
<p>A named list giving additional fields to include in the
JWT header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show what the various forms of client authentication look like
req &lt;- request("https://example.com/whoami")

client1 &lt;- oauth_client(
  id = "12345",
  secret = "56789",
  token_url = "https://example.com/oauth/access_token",
  name = "oauth-example",
  auth = "body" # the default
)
# calls oauth_client_req_auth_body()
req_dry_run(oauth_client_req_auth(req, client1))

client2 &lt;- oauth_client(
  id = "12345",
  secret = "56789",
  token_url = "https://example.com/oauth/access_token",
  name = "oauth-example",
  auth = "header"
)
# calls oauth_client_req_auth_header()
req_dry_run(oauth_client_req_auth(req, client2))

client3 &lt;- oauth_client(
  id = "12345",
  key = openssl::rsa_keygen(),
  token_url = "https://example.com/oauth/access_token",
  name = "oauth-example",
  auth = "jwt_sig",
  auth_params = list(claim = jwt_claim())
)
# calls oauth_client_req_auth_header_jwt_sig()
req_dry_run(oauth_client_req_auth(req, client3))
</code></pre>

<hr>
<h2 id='oauth_flow_auth_code_url'>OAuth authorization code components</h2><span id='topic+oauth_flow_auth_code_url'></span><span id='topic+oauth_flow_auth_code_listen'></span><span id='topic+oauth_flow_auth_code_parse'></span><span id='topic+oauth_flow_auth_code_pkce'></span>

<h3>Description</h3>

<p>These low-level functions can be used to assemble a custom flow for
APIs that are further from the spec:
</p>

<ul>
<li> <p><code>oauth_flow_auth_code_url()</code> generates the url that should be opened in a
browser.
</p>
</li>
<li> <p><code>oauth_flow_auth_code_listen()</code> starts a temporary local webserver that
listens for the response from the resource server.
</p>
</li>
<li> <p><code>oauth_flow_auth_code_parse()</code> parses the query parameters returned from
the server redirect, verifying that the <code>state</code> is correct, and returning
the authorisation code.
</p>
</li>
<li> <p><code>oauth_flow_auth_code_pkce()</code> generates code verifier, method, and challenge
components as needed for PKCE, as defined in <a href="https://datatracker.ietf.org/doc/html/rfc7636">RFC 7636</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>oauth_flow_auth_code_url(
  client,
  auth_url,
  redirect_uri = NULL,
  scope = NULL,
  state = NULL,
  auth_params = list()
)

oauth_flow_auth_code_listen(redirect_uri = "http://localhost:1410")

oauth_flow_auth_code_parse(query, state)

oauth_flow_auth_code_pkce()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_flow_auth_code_url_+3A_state">state</code></td>
<td>
<p>Random state generated by <code>oauth_flow_auth_code()</code>. Used to
verify that we're working with an authentication request that we created.
(This is an unlikely threat for R packages since the webserver that
listens for authorization responses is transient.)</p>
</td></tr>
<tr><td><code id="oauth_flow_auth_code_url_+3A_query">query</code></td>
<td>
<p>List of query parameters returned by <code>oauth_flow_auth_code_listen()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='oauth_redirect_uri'>Default redirect url for OAuth</h2><span id='topic+oauth_redirect_uri'></span>

<h3>Description</h3>

<p>The default redirect uri used by <code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code()</a></code>. Defaults to
<code style="white-space: pre;">&#8288;http://localhost&#8288;</code> unless the <code>HTTR2_OAUTH_REDIRECT_URL</code> envvar is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_redirect_uri()
</code></pre>

<hr>
<h2 id='oauth_token'>Create an OAuth token</h2><span id='topic+oauth_token'></span>

<h3>Description</h3>

<p>Creates a S3 object of class <code style="white-space: pre;">&#8288;&lt;httr2_token&gt;&#8288;</code> representing an OAuth token
returned from the access token endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_token(
  access_token,
  token_type = "bearer",
  expires_in = NULL,
  refresh_token = NULL,
  ...,
  .date = Sys.time()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_token_+3A_access_token">access_token</code></td>
<td>
<p>The access token used to authenticate request</p>
</td></tr>
<tr><td><code id="oauth_token_+3A_token_type">token_type</code></td>
<td>
<p>Type of token; only <code>"bearer"</code> is currently supported.</p>
</td></tr>
<tr><td><code id="oauth_token_+3A_expires_in">expires_in</code></td>
<td>
<p>Number of seconds until token expires.</p>
</td></tr>
<tr><td><code id="oauth_token_+3A_refresh_token">refresh_token</code></td>
<td>
<p>Optional refresh token; if supplied, this can be
used to cheaply get a new access token when this one expires.</p>
</td></tr>
<tr><td><code id="oauth_token_+3A_...">...</code></td>
<td>
<p>Additional components returned by the endpoint</p>
</td></tr>
<tr><td><code id="oauth_token_+3A_.date">.date</code></td>
<td>
<p>Date the request was made; used to convert the relative
<code>expires_in</code> to an absolute <code>expires_at</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An OAuth token: an S3 list with class <code>httr2_token</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oauth_token_cached">oauth_token_cached()</a></code> to use the token cache with a specified
OAuth flow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oauth_token("abcdef")
oauth_token("abcdef", expires_in = 3600)
oauth_token("abcdef", refresh_token = "ghijkl")
</code></pre>

<hr>
<h2 id='oauth_token_cached'>Retrieve an OAuth token using the cache</h2><span id='topic+oauth_token_cached'></span>

<h3>Description</h3>

<p>This function wraps around a <code>oauth_flow_</code> function to retrieve a token
from the cache, or to generate and cache a token if needed. Use this for
manual token management that still takes advantage of httr2's caching
system. You should only need to use this function if you're passing
the token
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth_token_cached(
  client,
  flow,
  flow_params = list(),
  cache_disk = FALSE,
  cache_key = NULL,
  reauth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oauth_token_cached_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="oauth_token_cached_+3A_flow">flow</code></td>
<td>
<p>An <code>oauth_flow_</code> function used to generate the access token.</p>
</td></tr>
<tr><td><code id="oauth_token_cached_+3A_flow_params">flow_params</code></td>
<td>
<p>Parameters for the flow. This should be a named list
whose names match the argument names of <code>flow</code>.</p>
</td></tr>
<tr><td><code id="oauth_token_cached_+3A_cache_disk">cache_disk</code></td>
<td>
<p>Should the access token be cached on disk? This reduces
the number of times that you need to re-authenticate at the cost of
storing access credentials on disk.
</p>
<p>Learn more in <a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.</p>
</td></tr>
<tr><td><code id="oauth_token_cached_+3A_cache_key">cache_key</code></td>
<td>
<p>If you want to cache multiple tokens per app, use this
key to disambiguate them.</p>
</td></tr>
<tr><td><code id="oauth_token_cached_+3A_reauth">reauth</code></td>
<td>
<p>Set to <code>TRUE</code> to force re-authentication via flow, regardless
of whether or not token is expired.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
token &lt;- oauth_token_cached(
  client = example_github_client(),
  flow = oauth_flow_auth_code,
  flow_params = list(
    auth_url = "https://github.com/login/oauth/authorize"
  ),
  cache_disk = TRUE
)
token

## End(Not run)
</code></pre>

<hr>
<h2 id='obfuscate'>Obfuscate mildly secret information</h2><span id='topic+obfuscate'></span><span id='topic+obfuscated'></span>

<h3>Description</h3>

<p>Use <code>obfuscate("value")</code> to generate a call to <code>obfuscated()</code>, which will
unobfuscate the value at the last possible moment. Obfuscated values only
work in limited locations:
</p>

<ul>
<li><p> The <code>secret</code> argument to <code><a href="#topic+oauth_client">oauth_client()</a></code>
</p>
</li>
<li><p> Elements of the <code>data</code> argument to <code><a href="#topic+req_body_form">req_body_form()</a></code>, <code>req_body_json()</code>,
and <code>req_body_multipart()</code>.
</p>
</li></ul>

<p>Working together this pair of functions provides a way to obfuscate mildly
confidential information, like OAuth client secrets. The secret can not be
revealed from your inspecting source code, but a skilled R programmer could
figure it out with some effort. The main goal is to protect against scraping;
there's no way for an automated tool to grab your obfuscated secrets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obfuscate(x)

obfuscated(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obfuscate_+3A_x">x</code></td>
<td>
<p>A string to <code>obfuscate</code>, or mark as <code>obfuscated</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>obfuscate()</code> prints the <code>obfuscated()</code> call to include in your
code. <code>obfuscated()</code> returns an S3 class marking the string as obfuscated
so it can be unobfuscated when needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obfuscate("good morning")

# Every time you obfuscate you'll get a different value because it
# includes 16 bytes of random data which protects against certain types of
# brute force attack
obfuscate("good morning")
</code></pre>

<hr>
<h2 id='progress_bars'>Progress bars in httr2</h2><span id='topic+progress_bars'></span>

<h3>Description</h3>

<p>Some of httr2's perform functions have a <code>progress</code> argument that you can use
to create a progress bar. <code>progress</code> can be:
</p>

<ul>
<li> <p><code>FALSE</code>, the default: does not create a progress bar.
</p>
</li>
<li> <p><code>TRUE</code>: creates a basic unnamed progress bar.
</p>
</li>
<li><p> A string: creates a basic progress bar with the given name.
</p>
</li>
<li><p> A named list of progress bar parameters, as described below.
</p>
</li></ul>

<p>It's good practice to name your progress bars, to make it clear what
calculation or process they belong to. We recommend keeping the names
under 20 characters, so the whole progress bar fits comfortably even on
on narrower displays.
</p>


<h4>Progress bar parameters</h4>


<ul>
<li> <p><code>clear</code>: whether to remove the progress bar from the screen after
termination. Defaults to <code>TRUE</code>.
</p>
</li>
<li> <p><code>format</code>: format string. This overrides the default format string of
the progress bar type. It must be given for the <code>custom</code> type.
Format strings may contain R expressions to evaluate in braces.
They support cli <a href="cli.html#topic+pluralization">pluralization</a>, and
<a href="cli.html#topic+inline-markup">styling</a> and they can contain special
<a href="cli.html#topic+progress-variables">progress variables</a>.
</p>
</li>
<li> <p><code>format_done</code>: format string for successful termination. By default
the same as <code>format</code>.
</p>
</li>
<li> <p><code>format_failed</code>: format string for unsuccessful termination.
By default the same as <code>format</code>.
</p>
</li>
<li> <p><code>name</code>: progress bar name. This is by default the empty string and it
is displayed at the beginning of the progress bar.
</p>
</li>
<li> <p><code>type</code>: progress bar type. Currently supported types are:
</p>

<ul>
<li> <p><code>iterator</code>: the default, a for loop or a mapping function,
</p>
</li>
<li> <p><code>tasks</code>: a (typically small) number of tasks,
</p>
</li>
<li> <p><code>download</code>: download of one file,
</p>
</li>
<li> <p><code>custom</code>: custom type, <code>format</code> must not be <code>NULL</code> for this type.
The default display is different for each progress bar type.
</p>
</li></ul>

</li></ul>




<h4>Further documentation</h4>

<p>purrr's progress bars are powered by cli, so see
<a href="https://cli.r-lib.org/articles/progress.html">Introduction to progress bars in cli</a>
and <a href="https://cli.r-lib.org/articles/progress-advanced.html">Advanced cli progress bars</a>
for more details.
</p>


<hr>
<h2 id='req_auth_aws_v4'>Sign a request with the AWS SigV4 signing protocol</h2><span id='topic+req_auth_aws_v4'></span>

<h3>Description</h3>

<p>This is a custom auth protocol implemented by AWS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_auth_aws_v4(
  req,
  aws_access_key_id,
  aws_secret_access_key,
  aws_session_token = NULL,
  aws_service = NULL,
  aws_region = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_auth_aws_v4_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_auth_aws_v4_+3A_aws_access_key_id">aws_access_key_id</code>, <code id="req_auth_aws_v4_+3A_aws_secret_access_key">aws_secret_access_key</code></td>
<td>
<p>AWS key and secret.</p>
</td></tr>
<tr><td><code id="req_auth_aws_v4_+3A_aws_session_token">aws_session_token</code></td>
<td>
<p>AWS session token, if required.</p>
</td></tr>
<tr><td><code id="req_auth_aws_v4_+3A_aws_service">aws_service</code>, <code id="req_auth_aws_v4_+3A_aws_region">aws_region</code></td>
<td>
<p>The AWS service and region to use for the
request. If not supplied, will be automatically parsed from the URL
hostname.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
creds &lt;- paws.common::locate_credentials()
model_id &lt;- "anthropic.claude-3-5-sonnet-20240620-v1:0"
req &lt;- request("https://bedrock-runtime.us-east-1.amazonaws.com")
# https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html
req &lt;- req_url_path_append(req, "model", model_id, "converse")
req &lt;- req_body_json(req, list(
  messages = list(list(
    role = "user",
    content = list(list(text = "What's your name?"))
  ))
))
req &lt;- req_auth_aws_v4(
  req,
  aws_access_key_id = creds$access_key_id,
  aws_secret_access_key = creds$secret_access_key,
  aws_session_token = creds$session_token
)
resp &lt;- req_perform_connection(req)
str(resp_body_json(resp))

</code></pre>

<hr>
<h2 id='req_auth_basic'>Authenticate request with HTTP basic authentication</h2><span id='topic+req_auth_basic'></span>

<h3>Description</h3>

<p>This sets the Authorization header. See details at
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_auth_basic(req, username, password = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_auth_basic_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_auth_basic_+3A_username">username</code></td>
<td>
<p>User name.</p>
</td></tr>
<tr><td><code id="req_auth_basic_+3A_password">password</code></td>
<td>
<p>Password. You should avoid entering the password directly
when calling this function as it will be captured by <code>.Rhistory</code>. Instead,
leave it unset and the default behaviour will prompt you for it
interactively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request("http://example.com") |&gt; req_auth_basic("hadley", "SECRET")
req
req |&gt; req_dry_run()

# httr2 does its best to redact the Authorization header so that you don't
# accidentally reveal confidential data. Use `redact_headers` to reveal it:
print(req, redact_headers = FALSE)
req |&gt; req_dry_run(redact_headers = FALSE)

# We do this because the authorization header is not encrypted and the
# so password can easily be discovered:
rawToChar(jsonlite::base64_dec("aGFkbGV5OlNFQ1JFVA=="))
</code></pre>

<hr>
<h2 id='req_auth_bearer_token'>Authenticate request with bearer token</h2><span id='topic+req_auth_bearer_token'></span>

<h3>Description</h3>

<p>A bearer token gives the bearer access to confidential resources
(so you should keep them secure like you would with a user name and
password). They are usually produced by some large authentication scheme
(like the various OAuth 2.0 flows), but you are sometimes given then
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_auth_bearer_token(req, token)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_auth_bearer_token_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_auth_bearer_token_+3A_token">token</code></td>
<td>
<p>A bearer token</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>See Also</h3>

<p>See <a href="https://datatracker.ietf.org/doc/html/rfc6750">RFC 6750</a> for more details about bearer token usage
with OAuth 2.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request("http://example.com") |&gt; req_auth_bearer_token("sdaljsdf093lkfs")
req

# httr2 does its best to redact the Authorization header so that you don't
# accidentally reveal confidential data. Use `redact_headers` to reveal it:
print(req, redact_headers = FALSE)
</code></pre>

<hr>
<h2 id='req_body'>Send data in request body</h2><span id='topic+req_body_raw'></span><span id='topic+req_body_file'></span><span id='topic+req_body_json'></span><span id='topic+req_body_json_modify'></span><span id='topic+req_body_form'></span><span id='topic+req_body_multipart'></span>

<h3>Description</h3>


<ul>
<li> <p><code>req_body_file()</code> sends a local file.
</p>
</li>
<li> <p><code>req_body_raw()</code> sends a string or raw vector.
</p>
</li>
<li> <p><code>req_body_json()</code> sends JSON encoded data. Named components of this data
can later be modified with <code>req_body_json_modify()</code>.
</p>
</li>
<li> <p><code>req_body_form()</code> sends form encoded data.
</p>
</li>
<li> <p><code>req_body_multipart()</code> creates a multi-part body.
</p>
</li></ul>

<p>Adding a body to a request will automatically switch the method to POST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_body_raw(req, body, type = NULL)

req_body_file(req, path, type = NULL)

req_body_json(
  req,
  data,
  auto_unbox = TRUE,
  digits = 22,
  null = "null",
  type = "application/json",
  ...
)

req_body_json_modify(req, ...)

req_body_form(.req, ..., .multi = c("error", "comma", "pipe", "explode"))

req_body_multipart(.req, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_body_+3A_req">req</code>, <code id="req_body_+3A_.req">.req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_body_+3A_body">body</code></td>
<td>
<p>A literal string or raw vector to send as body.</p>
</td></tr>
<tr><td><code id="req_body_+3A_type">type</code></td>
<td>
<p>MIME content type. Will be ignored if you have manually set
a <code>Content-Type</code> header.</p>
</td></tr>
<tr><td><code id="req_body_+3A_path">path</code></td>
<td>
<p>Path to file to upload.</p>
</td></tr>
<tr><td><code id="req_body_+3A_data">data</code></td>
<td>
<p>Data to include in body.</p>
</td></tr>
<tr><td><code id="req_body_+3A_auto_unbox">auto_unbox</code></td>
<td>
<p>Should length-1 vectors be automatically &quot;unboxed&quot; to
JSON scalars?</p>
</td></tr>
<tr><td><code id="req_body_+3A_digits">digits</code></td>
<td>
<p>How many digits of precision should numbers use in JSON?</p>
</td></tr>
<tr><td><code id="req_body_+3A_null">null</code></td>
<td>
<p>Should <code>NULL</code> be translated to JSON's null (<code>"null"</code>)
or an empty list (<code>"list"</code>).</p>
</td></tr>
<tr><td><code id="req_body_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Name-data pairs used to send
data in the body.
</p>

<ul>
<li><p> For <code>req_body_form()</code>, the values must be strings (or things easily
coerced to strings). Vectors are convertd to strings using the
value of <code>.multi</code>.
</p>
</li>
<li><p> For <code>req_body_multipart()</code> the values must be strings or objects
produced by <code><a href="curl.html#topic+multipart">curl::form_file()</a></code>/<code><a href="curl.html#topic+multipart">curl::form_data()</a></code>.
</p>
</li>
<li><p> For <code>req_body_json_modify()</code>, any simple data made from atomic vectors
and lists.
</p>
</li></ul>

<p><code>req_body_json()</code> uses this argument differently; it takes additional
arguments passed on to  <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>.</p>
</td></tr>
<tr><td><code id="req_body_+3A_.multi">.multi</code></td>
<td>
<p>Controls what happens when a value is a vector:
</p>

<ul>
<li> <p><code>"error"</code>, the default, throws an error.
</p>
</li>
<li> <p><code>"comma"</code>, separates values with a <code style="white-space: pre;">&#8288;,&#8288;</code>, e.g. <code style="white-space: pre;">&#8288;?x=1,2&#8288;</code>.
</p>
</li>
<li> <p><code>"pipe"</code>, separates values with a <code>|</code>, e.g. <code>?x=1|2</code>.
</p>
</li>
<li> <p><code>"explode"</code>, turns each element into its own parameter, e.g. <code>?x=1&amp;x=2</code>
</p>
</li></ul>

<p>If none of these options work for your needs, you can instead supply a
function that takes a character vector of argument values and returns a
a single string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url()) |&gt;
  req_url_path("/post")

# Most APIs expect small amounts of data in either form or json encoded:
req |&gt;
  req_body_form(x = "A simple text string") |&gt;
  req_dry_run()

req |&gt;
  req_body_json(list(x = "A simple text string")) |&gt;
  req_dry_run()

# For total control over the body, send a string or raw vector
req |&gt;
  req_body_raw("A simple text string") |&gt;
  req_dry_run()

# There are two main ways that APIs expect entire files
path &lt;- tempfile()
writeLines(letters[1:6], path)

# You can send a single file as the body:
req |&gt;
  req_body_file(path) |&gt;
  req_dry_run()

# You can send multiple files, or a mix of files and data
# with multipart encoding
req |&gt;
  req_body_multipart(a = curl::form_file(path), b = "some data") |&gt;
  req_dry_run()
</code></pre>

<hr>
<h2 id='req_cache'>Automatically cache requests</h2><span id='topic+req_cache'></span>

<h3>Description</h3>

<p>Use <code>req_perform()</code> to automatically cache HTTP requests. Most API requests
are not cacheable, but static files often are.
</p>
<p><code>req_cache()</code> caches responses to GET requests that have status code 200 and
at least one of the standard caching headers (e.g. <code>Expires</code>,
<code>Etag</code>, <code>Last-Modified</code>, <code>Cache-Control</code>), unless caching has been expressly
prohibited with <code>Cache-Control: no-store</code>. Typically, a request will still
be sent to the server to check that the cached value is still up-to-date,
but it will not need to re-download the body value.
</p>
<p>To learn more about HTTP caching, I recommend the MDN article
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">HTTP caching</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_cache(
  req,
  path,
  use_on_error = FALSE,
  debug = getOption("httr2_cache_debug", FALSE),
  max_age = Inf,
  max_n = Inf,
  max_size = 1024^3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_cache_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_cache_+3A_path">path</code></td>
<td>
<p>Path to cache directory. Will be created automatically if it
does not exist.
</p>
<p>For quick and easy caching within a session, you can use <code>tempfile()</code>.
To cache requests within a package, you can use something like
<code>file.path(tools::R_user_dir("pkgdown", "cache"), "httr2")</code>.
</p>
<p>httr2 doesn't provide helpers to manage the cache, but if you want to
empty it, you can use something like
<code>unlink(dir(cache_path, full.names = TRUE))</code>.</p>
</td></tr>
<tr><td><code id="req_cache_+3A_use_on_error">use_on_error</code></td>
<td>
<p>If the request errors, and there's a cache response,
should <code>req_perform()</code> return that instead of generating an error?</p>
</td></tr>
<tr><td><code id="req_cache_+3A_debug">debug</code></td>
<td>
<p>When <code>TRUE</code> will emit useful messages telling you about
cache hits and misses. This can be helpful to understand whether or
not caching is actually doing anything for your use case.</p>
</td></tr>
<tr><td><code id="req_cache_+3A_max_n">max_n</code>, <code id="req_cache_+3A_max_age">max_age</code>, <code id="req_cache_+3A_max_size">max_size</code></td>
<td>
<p>Automatically prune the cache by specifying
one or more of:
</p>

<ul>
<li> <p><code>max_age</code>: to delete files older than this number of seconds.
</p>
</li>
<li> <p><code>max_n</code>: to delete files (from oldest to newest) to preserve at
most this many files.
</p>
</li>
<li> <p><code>max_size</code>: to delete files (from oldest to newest) to preserve at
most this many bytes.
</p>
</li></ul>

<p>The cache pruning is performed at most once per minute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GitHub uses HTTP caching for all raw files.
url &lt;- paste0(
  "https://raw.githubusercontent.com/allisonhorst/palmerpenguins/",
  "master/inst/extdata/penguins.csv"
)
# Here I set debug = TRUE so you can see what's happening
req &lt;- request(url) |&gt; req_cache(tempdir(), debug = TRUE)

# First request downloads the data
resp &lt;- req |&gt; req_perform()

# Second request retrieves it from the cache
resp &lt;- req |&gt; req_perform()
</code></pre>

<hr>
<h2 id='req_cookie_preserve'>Set and preserve cookies</h2><span id='topic+req_cookie_preserve'></span><span id='topic+req_cookies_set'></span>

<h3>Description</h3>

<p>Use <code>req_cookie_set()</code> to set client side cookies that are sent to the
server.
</p>
<p>By default, httr2 uses a clean slate for every request meaning that cookies
are not automatically preserved across requests. To preserve cookies, use
<code>req_cookie_preserve()</code> along with the path to cookie file that will be
read before and updated after each request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_cookie_preserve(req, path)

req_cookies_set(req, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_cookie_preserve_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_cookie_preserve_+3A_path">path</code></td>
<td>
<p>A path to a file where cookies will be read from before and updated after the request.</p>
</td></tr>
<tr><td><code id="req_cookie_preserve_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
Name-value pairs that define query parameters. Each value must be
an atomic vector, which is automatically escaped. To opt-out of escaping,
wrap strings in <code>I()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use `req_cookies_set()` to set client-side cookies
request(example_url()) |&gt;
  req_cookies_set(a = 1, b = 1) |&gt;
  req_dry_run()

# Use `req_cookie_preserve()` to preserve server-side cookies across requests
path &lt;- tempfile()

# Set a server-side cookie
request(example_url()) |&gt;
  req_cookie_preserve(path) |&gt;
  req_template("/cookies/set/:name/:value", name = "chocolate", value = "chip") |&gt;
  req_perform() |&gt;
  resp_body_json()

# Set another sever-side cookie
request(example_url()) |&gt;
  req_cookie_preserve(path) |&gt;
  req_template("/cookies/set/:name/:value", name = "oatmeal", value = "raisin") |&gt;
  req_perform() |&gt;
  resp_body_json()

# Add a client side cookie
request(example_url()) |&gt;
  req_url_path("/cookies/set") |&gt;
  req_cookie_preserve(path) |&gt;
  req_cookies_set(snicker = "doodle") |&gt;
  req_perform() |&gt;
  resp_body_json()

# The cookie path has a straightforward format
cat(readChar(path, nchars = 1e4))
</code></pre>

<hr>
<h2 id='req_dry_run'>Perform a dry run</h2><span id='topic+req_dry_run'></span>

<h3>Description</h3>

<p>This shows you exactly what httr2 will send to the server, without
actually sending anything. It requires the httpuv package because it
works by sending the real HTTP request to a local webserver, thanks to
the magic of <code><a href="curl.html#topic+curl_echo">curl::curl_echo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_dry_run(
  req,
  quiet = FALSE,
  redact_headers = TRUE,
  testing_headers = is_testing(),
  pretty_json = getOption("httr2_pretty_json", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_dry_run_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_dry_run_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> doesn't print anything.</p>
</td></tr>
<tr><td><code id="req_dry_run_+3A_redact_headers">redact_headers</code></td>
<td>
<p>Redact confidential data in the headers? Currently
redacts the contents of the Authorization header to prevent you from
accidentally leaking credentials when debugging/reprexing.</p>
</td></tr>
<tr><td><code id="req_dry_run_+3A_testing_headers">testing_headers</code></td>
<td>
<p>If <code>TRUE</code>, removes headers that httr2 would otherwise
be automatically added, which are likely to change across test runs. This
currently includes:
</p>

<ul>
<li><p> The default <code>User-Agent</code>, which varies based on libcurl, curl, and
httr2 versions.
</p>
</li>
<li><p> The 'Host&ldquo; header, which is often set to a testing server.
</p>
</li>
<li><p> The <code>Content-Length</code> header, which will often vary by platform because
of varying newline encodings. (And is also not correct if you have
<code>pretty_json = TRUE</code>.)
</p>
</li>
<li><p> The <code>Accept-Encoding</code> header, which varies based on how libcurl was
built.
</p>
</li></ul>
</td></tr>
<tr><td><code id="req_dry_run_+3A_pretty_json">pretty_json</code></td>
<td>
<p>If <code>TRUE</code>, automatically prettify JSON bodies.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Limitations</h4>


<ul>
<li><p> The HTTP version is always <code>HTTP/1.1</code> (since you can't determine what it
will actually be without connecting to the real server).
</p>
</li></ul>




<h3>Value</h3>

<p>Invisibly, a list containing information about the request,
including <code>method</code>, <code>path</code>, and <code>headers</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># httr2 adds default User-Agent, Accept, and Accept-Encoding headers
request("http://example.com") |&gt; req_dry_run()

# the Authorization header is automatically redacted to avoid leaking
# credentials on the console
req &lt;- request("http://example.com") |&gt; req_auth_basic("user", "password")
req |&gt; req_dry_run()

# if you need to see it, use redact_headers = FALSE
req |&gt; req_dry_run(redact_headers = FALSE)
</code></pre>

<hr>
<h2 id='req_error'>Control handling of HTTP errors</h2><span id='topic+req_error'></span>

<h3>Description</h3>

<p><code>req_perform()</code> will automatically convert HTTP errors (i.e. any 4xx or 5xx
status code) into R errors. Use <code>req_error()</code> to either override the
defaults, or extract additional information from the response that would
be useful to expose to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_error(req, is_error = NULL, body = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_error_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_error_+3A_is_error">is_error</code></td>
<td>
<p>A predicate function that takes a single argument (the
response) and returns <code>TRUE</code> or <code>FALSE</code> indicating whether or not an
R error should be signalled.</p>
</td></tr>
<tr><td><code id="req_error_+3A_body">body</code></td>
<td>
<p>A callback function that takes a single argument (the response)
and returns a character vector of additional information to include in the
body of the error. This vector is passed along to the <code>message</code> argument
of <code><a href="rlang.html#topic+abort">rlang::abort()</a></code> so you can use any formatting that it supports.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Error handling</h3>

<p><code>req_perform()</code> is designed to succeed if and only if you get a valid HTTP
response. There are two ways a request can fail:
</p>

<ul>
<li><p> The HTTP request might fail, for example if the connection is dropped
or the server doesn't exist. This type of error will have class
<code>c("httr2_failure", "httr2_error")</code>.
</p>
</li>
<li><p> The HTTP request might succeed, but return an HTTP status code that
represents an error, e.g. a <code style="white-space: pre;">&#8288;404 Not Found&#8288;</code> if the specified resource is
not found. This type of error will have (e.g.) class
<code>c("httr2_http_404", "httr2_http", "httr2_error")</code>.
</p>
</li></ul>

<p>These error classes are designed to be used in conjunction with R's
condition handling tools (<a href="https://adv-r.hadley.nz/conditions.html">https://adv-r.hadley.nz/conditions.html</a>).
For example, if you want to return a default value when the server returns
a 404, use <code>tryCatch()</code>:
</p>
<div class="sourceCode"><pre>tryCatch(
  req |&gt; req_perform() |&gt; resp_body_json(),
  httr2_http_404 = function(cnd) NULL
)
</pre></div>
<p>Or if you want to re-throw the error with some additional context, use
<code>withCallingHandlers()</code>, e.g.:
</p>
<div class="sourceCode R"><pre>withCallingHandlers(
  req |&gt; req_perform() |&gt; resp_body_json(),
  httr2_http_404 = function(cnd) {
    rlang::abort("Couldn't find user", parent = cnd)
  }
)
</pre></div>
<p>Learn more about error chaining at <a href="rlang.html#topic+topic-error-chaining">rlang::topic-error-chaining</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+req_retry">req_retry()</a></code> to control when errors are automatically retried.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Performing this request usually generates an error because httr2
# converts HTTP errors into R errors:
req &lt;- request(example_url()) |&gt;
  req_url_path("/status/404")
try(req |&gt; req_perform())
# You can still retrieve it with last_response()
last_response()

# But you might want to suppress this behaviour:
resp &lt;- req |&gt;
  req_error(is_error = \(resp) FALSE) |&gt;
  req_perform()
resp

# Or perhaps you're working with a server that routinely uses the
# wrong HTTP error codes only 500s are really errors
request("http://example.com") |&gt;
  req_error(is_error = \(resp) resp_status(resp) == 500)

# Most typically you'll use req_error() to add additional information
# extracted from the response body (or sometimes header):
error_body &lt;- function(resp) {
  resp_body_json(resp)$error
}
request("http://example.com") |&gt;
  req_error(body = error_body)
# Learn more in https://httr2.r-lib.org/articles/wrapping-apis.html
</code></pre>

<hr>
<h2 id='req_headers'>Modify request headers</h2><span id='topic+req_headers'></span><span id='topic+req_headers_redacted'></span>

<h3>Description</h3>

<p><code>req_headers()</code> allows you to set the value of any header.
</p>
<p><code>req_headers_redacted()</code> is a variation that adds &quot;redacted&quot; headers, which
httr2 avoids printing on the console. This is good practice for
authentication headers to avoid accidentally leaking them in log files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_headers(.req, ..., .redact = NULL)

req_headers_redacted(.req, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_headers_+3A_.req">.req</code></td>
<td>
<p>A <a href="#topic+request">request</a>.</p>
</td></tr>
<tr><td><code id="req_headers_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Name-value pairs of headers
and their values.
</p>

<ul>
<li><p> Use <code>NULL</code> to reset a value to httr2's default
</p>
</li>
<li><p> Use <code>""</code> to remove a header
</p>
</li>
<li><p> Use a character vector to repeat a header.
</p>
</li></ul>
</td></tr>
<tr><td><code id="req_headers_+3A_.redact">.redact</code></td>
<td>
<p>A character vector of headers to redact. The Authorization
header is always redacted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request("http://example.com")

# Use req_headers() to add arbitrary additional headers to the request
req |&gt;
  req_headers(MyHeader = "MyValue") |&gt;
  req_dry_run()

# Repeated use overrides the previous value:
req |&gt;
  req_headers(MyHeader = "Old value") |&gt;
  req_headers(MyHeader = "New value") |&gt;
  req_dry_run()

# Setting Accept to NULL uses curl's default:
req |&gt;
  req_headers(Accept = NULL) |&gt;
  req_dry_run()

# Setting it to "" removes it:
req |&gt;
  req_headers(Accept = "") |&gt;
  req_dry_run()

# If you need to repeat a header, provide a vector of values
# (this is rarely needed, but is important in a handful of cases)
req |&gt;
  req_headers(HeaderName = c("Value 1", "Value 2", "Value 3")) |&gt;
  req_dry_run()

# If you have headers in a list, use !!!
headers &lt;- list(HeaderOne = "one", HeaderTwo = "two")
req |&gt;
  req_headers(!!!headers, HeaderThree = "three") |&gt;
  req_dry_run()

# Use `req_headers_redacted()`` to hide a header in the output
req_secret &lt;- req |&gt;
  req_headers_redacted(Secret = "this-is-private") |&gt;
  req_headers(Public = "but-this-is-not")

req_secret
req_secret |&gt; req_dry_run()
</code></pre>

<hr>
<h2 id='req_method'>Set HTTP method in request</h2><span id='topic+req_method'></span>

<h3>Description</h3>

<p>Use this function to use a custom HTTP method like <code>HEAD</code>,
<code>DELETE</code>, <code>PATCH</code>, <code>UPDATE</code>, or <code>OPTIONS</code>. The default method is
<code>GET</code> for requests without a body, and <code>POST</code> for requests with a body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_method(req, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_method_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_method_+3A_method">method</code></td>
<td>
<p>Custom HTTP method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>request(example_url()) |&gt; req_method("PATCH")
request(example_url()) |&gt; req_method("PUT")
request(example_url()) |&gt; req_method("HEAD")
</code></pre>

<hr>
<h2 id='req_oauth'>OAuth authentication</h2><span id='topic+req_oauth'></span>

<h3>Description</h3>

<p>This is a low-level helper for automatically authenticating a request with
an OAuth flow, caching the access token and refreshing it where possible.
You should only need to use this function if you're implementing your own
OAuth flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth(req, flow, flow_params, cache)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_+3A_flow">flow</code></td>
<td>
<p>An <code>oauth_flow_</code> function used to generate the access token.</p>
</td></tr>
<tr><td><code id="req_oauth_+3A_flow_params">flow_params</code></td>
<td>
<p>Parameters for the flow. This should be a named list
whose names match the argument names of <code>flow</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_+3A_cache">cache</code></td>
<td>
<p>An object that controls how the token is cached. This should
be a list containing three functions:
</p>

<ul>
<li> <p><code>get()</code> retrieves the token from the cache, returning <code>NULL</code> if not
cached yet.
</p>
</li>
<li> <p><code>set()</code> saves the token to the cache.
</p>
</li>
<li> <p><code>clear()</code> removes the token from the cache
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+oauth_token">oauth_token</a>.
</p>

<hr>
<h2 id='req_oauth_auth_code'>OAuth with authorization code</h2><span id='topic+req_oauth_auth_code'></span><span id='topic+oauth_flow_auth_code'></span>

<h3>Description</h3>

<p>Authenticate using the OAuth <strong>authorization code flow</strong>, as defined
by <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1">Section 4.1 of RFC 6749</a>.
</p>
<p>This flow is the most commonly used OAuth flow where the user
opens a page in their browser, approves the access, and then returns to R.
When possible, it redirects the browser back to a temporary local webserver
to capture the authorization code. When this is not possible (e.g., when
running on a hosted platform like RStudio Server), provide a custom
<code>redirect_uri</code> and httr2 will prompt the user to enter the code manually.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>, and more about the motivations
behind this flow in
<a href="https://stack-auth.com/blog/oauth-from-first-principles">https://stack-auth.com/blog/oauth-from-first-principles</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_auth_code(
  req,
  client,
  auth_url,
  scope = NULL,
  pkce = TRUE,
  auth_params = list(),
  token_params = list(),
  redirect_uri = oauth_redirect_uri(),
  cache_disk = FALSE,
  cache_key = NULL,
  host_name = deprecated(),
  host_ip = deprecated(),
  port = deprecated()
)

oauth_flow_auth_code(
  client,
  auth_url,
  scope = NULL,
  pkce = TRUE,
  auth_params = list(),
  token_params = list(),
  redirect_uri = oauth_redirect_uri(),
  host_name = deprecated(),
  host_ip = deprecated(),
  port = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_auth_code_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_auth_url">auth_url</code></td>
<td>
<p>Authorization url; you'll need to discover this by reading
the documentation.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_pkce">pkce</code></td>
<td>
<p>Use &quot;Proof Key for Code Exchange&quot;? This adds an extra layer of
security and should always be used if supported by the server.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_auth_params">auth_params</code></td>
<td>
<p>A list containing additional parameters passed to
<code><a href="#topic+oauth_flow_auth_code_url">oauth_flow_auth_code_url()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_redirect_uri">redirect_uri</code></td>
<td>
<p>URL to redirect back to after authorization is complete.
Often this must be registered with the API in advance.
</p>
<p>httr2 supports three forms of redirect. Firstly, you can use a <code>localhost</code>
url (the default), where httr2 will set up a temporary webserver to listen
for the OAuth redirect. In this case, httr2 will automatically append a
random port. If you need to set it to a fixed port because the API requires
it, then specify it with (e.g.) <code>"http://localhost:1011"</code>. This technique
works well when you are working on your own computer.
</p>
<p>Secondly, you can provide a URL to a website that uses Javascript to
give the user a code to copy and paste back into the R session (see
<a href="https://www.tidyverse.org/google-callback/">https://www.tidyverse.org/google-callback/</a> and
<a href="https://github.com/r-lib/gargle/blob/main/inst/pseudo-oob/google-callback/index.html">https://github.com/r-lib/gargle/blob/main/inst/pseudo-oob/google-callback/index.html</a>
for examples). This is less convenient (because it requires more
user interaction) but also works in hosted environments like RStudio
Server.
</p>
<p>Finally, hosted platforms might set the <code>HTTR2_OAUTH_REDIRECT_URL</code> and
<code>HTTR2_OAUTH_CODE_SOURCE_URL</code> environment variables. In this case, httr2
will use <code>HTTR2_OAUTH_REDIRECT_URL</code> for redirects by default, and poll the
<code>HTTR2_OAUTH_CODE_SOURCE_URL</code> endpoint with the state parameter until it
receives a code in the response (or encounters an error). This delegates
completion of the authorization flow to the hosted platform.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_cache_disk">cache_disk</code></td>
<td>
<p>Should the access token be cached on disk? This reduces
the number of times that you need to re-authenticate at the cost of
storing access credentials on disk.
</p>
<p>Learn more in <a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_cache_key">cache_key</code></td>
<td>
<p>If you want to cache multiple tokens per app, use this
key to disambiguate them.</p>
</td></tr>
<tr><td><code id="req_oauth_auth_code_+3A_host_name">host_name</code>, <code id="req_oauth_auth_code_+3A_host_ip">host_ip</code>, <code id="req_oauth_auth_code_+3A_port">port</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Now use <code>redirect_uri</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_auth_code()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_auth_code()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>Security considerations</h3>

<p>The authorization code flow is used for both web applications and native
applications (which are equivalent to R packages). <a href="https://datatracker.ietf.org/doc/html/rfc8252">RFC 8252</a> spells out
important considerations for native apps. Most importantly there's no way
for native apps to keep secrets from their users. This means that the
server should either not require a <code>client_secret</code> (i.e. it should be a
public client and not a confidential client) or ensure that possession of
the <code>client_secret</code> doesn't grant any significant privileges.
</p>
<p>Only modern APIs from major providers (like Azure and Google) explicitly
support native apps. However, in most cases, even for older APIs, possessing
the <code>client_secret</code> provides limited ability to perform harmful actions.
Therefore, our general principle is that it's acceptable to include it in an
R package, as long as it's mildly obfuscated to protect against credential
scraping attacks (which aim to acquire large numbers of client secrets by
scanning public sites like GitHub). The goal is to ensure that obtaining your
client credentials is more work than just creating a new client.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oauth_flow_auth_code_url">oauth_flow_auth_code_url()</a></code> for the components necessary to
write your own auth code flow, if the API you are wrapping does not adhere
closely to the standard.
</p>
<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_bearer_jwt">req_oauth_bearer_jwt</a>()</code>,
<code><a href="#topic+req_oauth_client_credentials">req_oauth_client_credentials</a>()</code>,
<code><a href="#topic+req_oauth_password">req_oauth_password</a>()</code>,
<code><a href="#topic+req_oauth_refresh">req_oauth_refresh</a>()</code>,
<code><a href="#topic+req_oauth_token_exchange">req_oauth_token_exchange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req_auth_github &lt;- function(req) {
  req_oauth_auth_code(
    req,
    client = example_github_client(),
    auth_url = "https://github.com/login/oauth/authorize"
  )
}

request("https://api.github.com/user") |&gt;
  req_auth_github()
</code></pre>

<hr>
<h2 id='req_oauth_bearer_jwt'>OAuth with a bearer JWT (JSON web token)</h2><span id='topic+req_oauth_bearer_jwt'></span><span id='topic+oauth_flow_bearer_jwt'></span>

<h3>Description</h3>

<p>Authenticate using a <strong>Bearer JWT</strong> (JSON web token) as an authorization
grant to get an access token, as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7523#section-2.1">Section 2.1 of RFC 7523</a>.
It is often used for service accounts, accounts that are used primarily in
automated environments.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_bearer_jwt(
  req,
  client,
  claim,
  signature = "jwt_encode_sig",
  signature_params = list(),
  scope = NULL,
  token_params = list()
)

oauth_flow_bearer_jwt(
  client,
  claim,
  signature = "jwt_encode_sig",
  signature_params = list(),
  scope = NULL,
  token_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_bearer_jwt_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_claim">claim</code></td>
<td>
<p>A list of claims. If all elements of the claim set are static
apart from <code>iat</code>, <code>nbf</code>, <code>exp</code>, or <code>jti</code>, provide a list and
<code><a href="#topic+jwt_claim">jwt_claim()</a></code> will automatically fill in the dynamic components.
If other components need to vary, you can instead provide a zero-argument
callback function which should call <code>jwt_claim()</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_signature">signature</code></td>
<td>
<p>Function use to sign <code>claim</code>, e.g. <code><a href="#topic+jwt_encode_sig">jwt_encode_sig()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_signature_params">signature_params</code></td>
<td>
<p>Additional arguments passed to <code>signature</code>, e.g.
<code>size</code>, <code>header</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_bearer_jwt_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_bearer_jwt()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_bearer_jwt()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>See Also</h3>

<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code</a>()</code>,
<code><a href="#topic+req_oauth_client_credentials">req_oauth_client_credentials</a>()</code>,
<code><a href="#topic+req_oauth_password">req_oauth_password</a>()</code>,
<code><a href="#topic+req_oauth_refresh">req_oauth_refresh</a>()</code>,
<code><a href="#topic+req_oauth_token_exchange">req_oauth_token_exchange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req_auth &lt;- function(req) {
  req_oauth_bearer_jwt(
    req,
    client = oauth_client("example", "https://example.com/get_token"),
    claim = jwt_claim()
  )
}

request("https://example.com") |&gt;
 req_auth()
</code></pre>

<hr>
<h2 id='req_oauth_client_credentials'>OAuth with client credentials</h2><span id='topic+req_oauth_client_credentials'></span><span id='topic+oauth_flow_client_credentials'></span>

<h3>Description</h3>

<p>Authenticate using OAuth <strong>client credentials flow</strong>, as defined by
<a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.4">Section 4.4 of RFC 6749</a>. It is used to allow the client to access resources that
it controls directly, not on behalf of an user.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_client_credentials(req, client, scope = NULL, token_params = list())

oauth_flow_client_credentials(client, scope = NULL, token_params = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_client_credentials_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_client_credentials_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_client_credentials_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_client_credentials_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_client_credentials()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_client_credentials()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>See Also</h3>

<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code</a>()</code>,
<code><a href="#topic+req_oauth_bearer_jwt">req_oauth_bearer_jwt</a>()</code>,
<code><a href="#topic+req_oauth_password">req_oauth_password</a>()</code>,
<code><a href="#topic+req_oauth_refresh">req_oauth_refresh</a>()</code>,
<code><a href="#topic+req_oauth_token_exchange">req_oauth_token_exchange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req_auth &lt;- function(req) {
  req_oauth_client_credentials(
    req,
    client = oauth_client("example", "https://example.com/get_token")
  )
}

request("https://example.com") |&gt;
  req_auth()
</code></pre>

<hr>
<h2 id='req_oauth_device'>OAuth with device flow</h2><span id='topic+req_oauth_device'></span><span id='topic+oauth_flow_device'></span>

<h3>Description</h3>

<p>Authenticate using the OAuth <strong>device flow</strong>, as defined by <a href="https://datatracker.ietf.org/doc/html/rfc8628">RFC 8628</a>.
It's designed for devices that don't have access to a web browser (if you've
ever authenticated an app on your TV, this is probably the flow you've used),
but it also works well from within R.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_device(
  req,
  client,
  auth_url,
  scope = NULL,
  auth_params = list(),
  token_params = list(),
  cache_disk = FALSE,
  cache_key = NULL
)

oauth_flow_device(
  client,
  auth_url,
  pkce = FALSE,
  scope = NULL,
  auth_params = list(),
  token_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_device_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_auth_url">auth_url</code></td>
<td>
<p>Authorization url; you'll need to discover this by reading
the documentation.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_auth_params">auth_params</code></td>
<td>
<p>A list containing additional parameters passed to
<code><a href="#topic+oauth_flow_auth_code_url">oauth_flow_auth_code_url()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_cache_disk">cache_disk</code></td>
<td>
<p>Should the access token be cached on disk? This reduces
the number of times that you need to re-authenticate at the cost of
storing access credentials on disk.
</p>
<p>Learn more in <a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_cache_key">cache_key</code></td>
<td>
<p>If you want to cache multiple tokens per app, use this
key to disambiguate them.</p>
</td></tr>
<tr><td><code id="req_oauth_device_+3A_pkce">pkce</code></td>
<td>
<p>Use &quot;Proof Key for Code Exchange&quot;? This adds an extra layer of
security and should always be used if supported by the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_device()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_device()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req_auth_github &lt;- function(req) {
  req_oauth_device(
    req,
    client = example_github_client(),
    auth_url = "https://github.com/login/device/code"
  )
}

request("https://api.github.com/user") |&gt;
  req_auth_github()
</code></pre>

<hr>
<h2 id='req_oauth_password'>OAuth with username and password</h2><span id='topic+req_oauth_password'></span><span id='topic+oauth_flow_password'></span>

<h3>Description</h3>

<p>This function implements the OAuth <strong>resource owner password flow</strong>, as
defined by <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.3">Section 4.3 of RFC 6749</a>. It allows the user to supply their password
once, exchanging it for an access token that can be cached locally.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_password(
  req,
  client,
  username,
  password = NULL,
  scope = NULL,
  token_params = list(),
  cache_disk = FALSE,
  cache_key = username
)

oauth_flow_password(
  client,
  username,
  password = NULL,
  scope = NULL,
  token_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_password_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_username">username</code></td>
<td>
<p>User name.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_password">password</code></td>
<td>
<p>Password. You should avoid entering the password directly
when calling this function as it will be captured by <code>.Rhistory</code>. Instead,
leave it unset and the default behaviour will prompt you for it
interactively.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_cache_disk">cache_disk</code></td>
<td>
<p>Should the access token be cached on disk? This reduces
the number of times that you need to re-authenticate at the cost of
storing access credentials on disk.
</p>
<p>Learn more in <a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_password_+3A_cache_key">cache_key</code></td>
<td>
<p>If you want to cache multiple tokens per app, use this
key to disambiguate them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_password()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_password()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>See Also</h3>

<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code</a>()</code>,
<code><a href="#topic+req_oauth_bearer_jwt">req_oauth_bearer_jwt</a>()</code>,
<code><a href="#topic+req_oauth_client_credentials">req_oauth_client_credentials</a>()</code>,
<code><a href="#topic+req_oauth_refresh">req_oauth_refresh</a>()</code>,
<code><a href="#topic+req_oauth_token_exchange">req_oauth_token_exchange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req_auth &lt;- function(req) {
  req_oauth_password(req,
    client = oauth_client("example", "https://example.com/get_token"),
    username = "username"
  )
}
if (interactive()) {
  request("https://example.com") |&gt;
    req_auth()
}
</code></pre>

<hr>
<h2 id='req_oauth_refresh'>OAuth with a refresh token</h2><span id='topic+req_oauth_refresh'></span><span id='topic+oauth_flow_refresh'></span>

<h3>Description</h3>

<p>Authenticate using a <strong>refresh token</strong>, following the process described in
<a href="https://datatracker.ietf.org/doc/html/rfc6749#section-6">Section 6 of RFC 6749</a>.
</p>
<p>This technique is primarily useful for testing: you can manually retrieve
a OAuth token using another OAuth flow (e.g. with <code><a href="#topic+oauth_flow_auth_code">oauth_flow_auth_code()</a></code>),
extract the refresh token from the result, and then save in an environment
variable for use in automated tests.
</p>
<p>When requesting an access token, the server may also return a new refresh
token. If this happens, <code>oauth_flow_refresh()</code> will warn, and you'll have
retrieve a new update refresh token and update the stored value. If you find
this happening a lot, it's a sign that you should be using a different flow
in your automated tests.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_refresh(
  req,
  client,
  refresh_token = Sys.getenv("HTTR2_REFRESH_TOKEN"),
  scope = NULL,
  token_params = list()
)

oauth_flow_refresh(
  client,
  refresh_token = Sys.getenv("HTTR2_REFRESH_TOKEN"),
  scope = NULL,
  token_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_refresh_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_refresh_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_refresh_+3A_refresh_token">refresh_token</code></td>
<td>
<p>A refresh token. This is equivalent to a password
so shouldn't be typed into the console or stored in a script. Instead,
we recommend placing in an environment variable; the default behaviour
is to look in <code>HTTR2_REFRESH_TOKEN</code>.</p>
</td></tr>
<tr><td><code id="req_oauth_refresh_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_refresh_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_refresh()</code> returns a modified HTTP <a href="#topic+request">request</a> that will
use OAuth; <code>oauth_flow_refresh()</code> returns an <a href="#topic+oauth_token">oauth_token</a>.
</p>


<h3>See Also</h3>

<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code</a>()</code>,
<code><a href="#topic+req_oauth_bearer_jwt">req_oauth_bearer_jwt</a>()</code>,
<code><a href="#topic+req_oauth_client_credentials">req_oauth_client_credentials</a>()</code>,
<code><a href="#topic+req_oauth_password">req_oauth_password</a>()</code>,
<code><a href="#topic+req_oauth_token_exchange">req_oauth_token_exchange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>client &lt;- oauth_client("example", "https://example.com/get_token")
req &lt;- request("https://example.com")
req |&gt; req_oauth_refresh(client)
</code></pre>

<hr>
<h2 id='req_oauth_token_exchange'>OAuth token exchange</h2><span id='topic+req_oauth_token_exchange'></span><span id='topic+oauth_flow_token_exchange'></span>

<h3>Description</h3>

<p>Authenticate by exchanging one security token for another, as defined by
<a href="https://datatracker.ietf.org/doc/html/rfc8693#section-2">Section 2 of RFC 8693</a>. It is typically used for advanced authorization flows that
involve &quot;delegation&quot; or &quot;impersonation&quot; semantics, such as when a client
accesses a resource on behalf of another party, or when a client's identity
is federated from another provider.
</p>
<p>Learn more about the overall OAuth authentication flow in
<a href="https://httr2.r-lib.org/articles/oauth.html">https://httr2.r-lib.org/articles/oauth.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_oauth_token_exchange(
  req,
  client,
  subject_token,
  subject_token_type,
  resource = NULL,
  audience = NULL,
  scope = NULL,
  requested_token_type = NULL,
  actor_token = NULL,
  actor_token_type = NULL,
  token_params = list()
)

oauth_flow_token_exchange(
  client,
  subject_token,
  subject_token_type,
  resource = NULL,
  audience = NULL,
  scope = NULL,
  requested_token_type = NULL,
  actor_token = NULL,
  actor_token_type = NULL,
  token_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_oauth_token_exchange_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_client">client</code></td>
<td>
<p>An <code><a href="#topic+oauth_client">oauth_client()</a></code>.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_subject_token">subject_token</code></td>
<td>
<p>The security token to exchange. This is usually an
OpenID Connect ID token or a SAML2 assertion.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_subject_token_type">subject_token_type</code></td>
<td>
<p>A URI that describes the type of the security
token. Usually one of the options in <a href="https://datatracker.ietf.org/doc/html/rfc8693#section-3">Section 3 of RFC 8693</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_resource">resource</code></td>
<td>
<p>The URI that identifies the resource that the client is
trying to access, if applicable.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_audience">audience</code></td>
<td>
<p>The logical name that identifies the resource that the client
is trying to access, if applicable. Usually one of <code>resource</code> or <code>audience</code>
must be supplied.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_scope">scope</code></td>
<td>
<p>Scopes to be requested from the resource owner.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_requested_token_type">requested_token_type</code></td>
<td>
<p>An optional URI that describes the type of the
security token being requested. Usually one of the options in
<a href="https://datatracker.ietf.org/doc/html/rfc8693#section-3">Section 3 of RFC 8693</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_actor_token">actor_token</code></td>
<td>
<p>An optional security token that represents the client,
rather than the identity behind the subject token.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_actor_token_type">actor_token_type</code></td>
<td>
<p>When <code>actor_token</code> is not <code>NULL</code>, this must be the
URI that describes the type of the security token being requested. Usually
one of the options in <a href="https://datatracker.ietf.org/doc/html/rfc8693#section-3">Section 3 of RFC 8693</a>.</p>
</td></tr>
<tr><td><code id="req_oauth_token_exchange_+3A_token_params">token_params</code></td>
<td>
<p>List containing additional parameters passed to the
<code>token_url</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>req_oauth_token_exchange()</code> returns a modified HTTP <a href="#topic+request">request</a> that
will exchange one security token for another; <code>oauth_flow_token_exchange()</code>
returns the resulting <a href="#topic+oauth_token">oauth_token</a> directly.
</p>


<h3>See Also</h3>

<p>Other OAuth flows: 
<code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code</a>()</code>,
<code><a href="#topic+req_oauth_bearer_jwt">req_oauth_bearer_jwt</a>()</code>,
<code><a href="#topic+req_oauth_client_credentials">req_oauth_client_credentials</a>()</code>,
<code><a href="#topic+req_oauth_password">req_oauth_password</a>()</code>,
<code><a href="#topic+req_oauth_refresh">req_oauth_refresh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List Google Cloud storage buckets using an OIDC token obtained
# from e.g. Microsoft Entra ID or Okta and federated to Google. (A real
# project ID and workforce pool would be required for this in practice.)
#
# See: https://cloud.google.com/iam/docs/workforce-obtaining-short-lived-credentials
oidc_token &lt;- "an ID token from Okta"
request("https://storage.googleapis.com/storage/v1/b?project=123456") |&gt;
  req_oauth_token_exchange(
    client = oauth_client("gcp", "https://sts.googleapis.com/v1/token"),
    subject_token = oidc_token,
    subject_token_type = "urn:ietf:params:oauth:token-type:id_token",
    scope = "https://www.googleapis.com/auth/cloud-platform",
    requested_token_type = "urn:ietf:params:oauth:token-type:access_token",
    audience = "//iam.googleapis.com/locations/global/workforcePools/123/providers/456",
    token_params = list(
      options = '{"userProject":"123456"}'
    )
  )
</code></pre>

<hr>
<h2 id='req_options'>Set arbitrary curl options in request</h2><span id='topic+req_options'></span>

<h3>Description</h3>

<p><code>req_options()</code> is for expert use only; it allows you to directly set
libcurl options to access features that are otherwise not available in
httr2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_options(.req, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_options_+3A_.req">.req</code></td>
<td>
<p>A <a href="#topic+request">request</a>.</p>
</td></tr>
<tr><td><code id="req_options_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Name-value pairs. The name
should be a valid curl option, as found in <code><a href="curl.html#topic+curl_options">curl::curl_options()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># req_options() allows you to access curl options that are not otherwise
# exposed by httr2. For example, in very special cases you may need to
# turn off SSL verification. This is generally a bad idea so httr2 doesn't
# provide a convenient wrapper, but if you really know what you're doing
# you can still access this libcurl option:
req &lt;- request("https://example.com") |&gt;
  req_options(ssl_verifypeer = 0)
</code></pre>

<hr>
<h2 id='req_perform'>Perform a request to get a response</h2><span id='topic+req_perform'></span>

<h3>Description</h3>

<p>After preparing a <a href="#topic+request">request</a>, call <code>req_perform()</code> to perform it, fetching
the results back to R as a <a href="#topic+response">response</a>.
</p>
<p>The default HTTP method is <code>GET</code> unless a body (set by <a href="#topic+req_body_json">req_body_json</a> and
friends) is present, in which case it will be <code>POST</code>. You can override
these defaults with <code><a href="#topic+req_method">req_method()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_perform(
  req,
  path = NULL,
  verbosity = NULL,
  mock = getOption("httr2_mock", NULL),
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_perform_+3A_path">path</code></td>
<td>
<p>Optionally, path to save body of the response. This is useful
for large responses since it avoids storing the response in memory.</p>
</td></tr>
<tr><td><code id="req_perform_+3A_verbosity">verbosity</code></td>
<td>
<p>How much information to print? This is a wrapper
around <code><a href="#topic+req_verbose">req_verbose()</a></code> that uses an integer to control verbosity:
</p>

<ul>
<li> <p><code>0</code>: no output
</p>
</li>
<li> <p><code>1</code>: show headers
</p>
</li>
<li> <p><code>2</code>: show headers and bodies
</p>
</li>
<li> <p><code>3</code>: show headers, bodies, and curl status messages.
</p>
</li></ul>

<p>Use <code><a href="#topic+with_verbosity">with_verbosity()</a></code> to control the verbosity of requests that
you can't affect directly.</p>
</td></tr>
<tr><td><code id="req_perform_+3A_mock">mock</code></td>
<td>
<p>A mocking function. If supplied, this function is called
with the request. It should return either <code>NULL</code> (if it doesn't want to
handle the request) or a <a href="#topic+response">response</a> (if it does). See <code><a href="#topic+with_mock">with_mock()</a></code>/
<code>local_mock()</code> for more details.</p>
</td></tr>
<tr><td><code id="req_perform_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If the HTTP request succeeds, and the status code is ok (e.g. 200),
an HTTP <a href="#topic+response">response</a>.
</p>
</li>
<li><p> If the HTTP request succeeds, but the status code is an error
(e.g a 404), an error with class <code>c("httr2_http_404", "httr2_http")</code>.
By default, all 400 and 500 status codes will be treated as an error,
but you can customise this with <code><a href="#topic+req_error">req_error()</a></code>.
</p>
</li>
<li><p> If the HTTP request fails (e.g. the connection is dropped or the
server doesn't exist), an error with class <code>"httr2_failure"</code>.
</p>
</li></ul>



<h3>Requests</h3>

<p>Note that one call to <code>req_perform()</code> may perform multiple HTTP requests:
</p>

<ul>
<li><p> If the <code>url</code> is redirected with a 301, 302, 303, or 307, curl will
automatically follow the <code>Location</code> header to the new location.
</p>
</li>
<li><p> If you have configured retries with <code><a href="#topic+req_retry">req_retry()</a></code> and the request
fails with a transient problem, <code>req_perform()</code> will try again after
waiting a bit. See <code><a href="#topic+req_retry">req_retry()</a></code> for details.
</p>
</li>
<li><p> If you are using OAuth, and the cached token has expired, <code>req_perform()</code>
will get a new token either using the refresh token (if available)
or by running the OAuth flow.
</p>
</li></ul>



<h3>Progress bar</h3>

<p><code>req_perform()</code> will automatically add a progress bar if it needs to wait
between requests for <code><a href="#topic+req_throttle">req_throttle()</a></code> or <code><a href="#topic+req_retry">req_retry()</a></code>. You can turn the
progress bar off (and just show the total time to wait) by setting
<code>options(httr2_progress = FALSE)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code> to perform multiple requests in parallel.
<code><a href="#topic+req_perform_iterative">req_perform_iterative()</a></code> to perform multiple requests iteratively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>request("https://google.com") |&gt;
  req_perform()
</code></pre>

<hr>
<h2 id='req_perform_connection'>Perform a request and return a streaming connection</h2><span id='topic+req_perform_connection'></span>

<h3>Description</h3>

<p>Use <code>req_perform_connection()</code> to perform a request if you want to stream the
response body. A response returned by <code>req_perform_connection()</code> includes a
connection as the body. You can then use <code><a href="#topic+resp_stream_raw">resp_stream_raw()</a></code>,
<code><a href="#topic+resp_stream_lines">resp_stream_lines()</a></code>, or <code><a href="#topic+resp_stream_sse">resp_stream_sse()</a></code> to retrieve data a chunk at a
time. Always finish up by closing the connection by calling
<code>close(response)</code>.
</p>
<p>This is an alternative interface to <code><a href="#topic+req_perform_stream">req_perform_stream()</a></code> that returns a
<a href="base.html#topic+connections">connection</a> that you can use to pull the data, rather
than providing callbacks that the data is pushed to. This is useful if you
want to do other work in between handling inputs from the stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_perform_connection(req, blocking = TRUE, verbosity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_connection_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_perform_connection_+3A_blocking">blocking</code></td>
<td>
<p>When retrieving data, should the connection block and wait
for the desired information or immediately return what it has (possibly
nothing)?</p>
</td></tr>
<tr><td><code id="req_perform_connection_+3A_verbosity">verbosity</code></td>
<td>
<p>How much information to print? This is a wrapper
around <code><a href="#topic+req_verbose">req_verbose()</a></code> that uses an integer to control verbosity:
</p>

<ul>
<li> <p><code>0</code>: no output
</p>
</li>
<li> <p><code>1</code>: show headers
</p>
</li>
<li> <p><code>2</code>: show headers and bodies as they're streamed
</p>
</li>
<li> <p><code>3</code>: show headers, bodies, curl status messages, raw SSEs, and stream
buffer management
</p>
</li></ul>

<p>Use <code><a href="#topic+with_verbosity">with_verbosity()</a></code> to control the verbosity of requests that
you can't affect directly.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url()) |&gt;
  req_url_path("/stream-bytes/32768")
resp &lt;- req_perform_connection(req)

length(resp_stream_raw(resp, kb = 16))
length(resp_stream_raw(resp, kb = 16))
# When the stream has no more data, you'll get an empty result:
length(resp_stream_raw(resp, kb = 16))

# Always close the response when you're done
close(resp)

# You can loop until complete with resp_stream_is_complete()
resp &lt;- req_perform_connection(req)
while (!resp_stream_is_complete(resp)) {
  print(length(resp_stream_raw(resp, kb = 12)))
}
close(resp)
</code></pre>

<hr>
<h2 id='req_perform_iterative'>Perform requests iteratively, generating new requests from previous responses</h2><span id='topic+req_perform_iterative'></span>

<h3>Description</h3>

<p><code>req_perform_iterative()</code> iteratively generates and performs requests,
using a callback function, <code>next_req</code>, to define the next request based on
the current request and response. You will probably want to pair it with an
<a href="#topic+iterate_with_offset">iteration helper</a> and use a
<a href="#topic+resps_successes">multi-response handler</a> to process the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_perform_iterative(
  req,
  next_req,
  path = NULL,
  max_reqs = 20,
  on_error = c("stop", "return"),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_iterative_+3A_req">req</code></td>
<td>
<p>The first <a href="#topic+request">request</a> to perform.</p>
</td></tr>
<tr><td><code id="req_perform_iterative_+3A_next_req">next_req</code></td>
<td>
<p>A function that takes the previous response (<code>resp</code>) and
request (<code>req</code>) and returns a <a href="#topic+request">request</a> for the next page or <code>NULL</code> if
the iteration should terminate. See below for more details.</p>
</td></tr>
<tr><td><code id="req_perform_iterative_+3A_path">path</code></td>
<td>
<p>Optionally, path to save the body of request. This should be
a glue string that uses <code>{i}</code> to distinguish different requests.
Useful for large responses because it avoids storing the response in
memory.</p>
</td></tr>
<tr><td><code id="req_perform_iterative_+3A_max_reqs">max_reqs</code></td>
<td>
<p>The maximum number of requests to perform. Use <code>Inf</code> to
perform all requests until <code>next_req()</code> returns <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="req_perform_iterative_+3A_on_error">on_error</code></td>
<td>
<p>What should happen if a request fails?
</p>

<ul>
<li> <p><code>"stop"</code>, the default: stop iterating with an error.
</p>
</li>
<li> <p><code>"return"</code>: stop iterating, returning all the successful responses so
far, as well as an error object for the failed request.
</p>
</li></ul>
</td></tr>
<tr><td><code id="req_perform_iterative_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar for the status of all requests? Use
<code>TRUE</code> to turn on a basic progress bar, use a string to give it a name,
or see <a href="#topic+progress_bars">progress_bars</a> to customize it in other ways. Not compatible with
<code><a href="#topic+req_progress">req_progress()</a></code>, as httr2 can only display a single progress bar at a
time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, at most length <code>max_reqs</code>, containing <a href="#topic+response">response</a>s and possibly one
error object, if <code>on_error</code> is <code>"return"</code> and one of the requests errors.
If present, the error object will always be the last element in the list.
</p>
<p>Only httr2 errors are captured; see <code><a href="#topic+req_error">req_error()</a></code> for more details.
</p>


<h3><code>next_req()</code></h3>

<p>The key piece that makes <code>req_perform_iterative()</code> work is the <code>next_req()</code>
argument. For most common cases, you can use one of the canned helpers,
like <code><a href="#topic+iterate_with_offset">iterate_with_offset()</a></code>. If, however, the API you're wrapping uses a
different pagination system, you'll need to write your own. This section
gives some advice.
</p>
<p>Generally, your function needs to inspect the response, extract some data
from it, then use that to modify the previous request. For example, imagine
that the response returns a cursor, which needs to be added to the body of
the request. The simplest version of this function might look like this:
</p>
<div class="sourceCode R"><pre>next_req &lt;- function(resp, req) {
  cursor &lt;- resp_body_json(resp)$next_cursor
  req |&gt; req_body_json_modify(cursor = cursor)
}
</pre></div>
<p>There's one problem here: if there are no more pages to return, then
<code>cursor</code> will be <code>NULL</code>, but <code>req_body_json_modify()</code> will still generate
a meaningful request. So we need to handle this specifically by
returning <code>NULL</code>:
</p>
<div class="sourceCode R"><pre>next_req &lt;- function(resp, req) {
  cursor &lt;- resp_body_json(resp)$next_cursor
  if (is.null(cursor))
    return(NULL)
  req |&gt; req_body_json_modify(cursor = cursor)
}
</pre></div>
<p>A value of <code>NULL</code> lets <code>req_perform_iterative()</code> know there are no more
pages remaining.
</p>
<p>There's one last feature you might want to add to your iterator: if you
know the total number of pages, then it's nice to let
<code>req_perform_iterative()</code> know so it can adjust the progress bar.
(This will only ever decrease the number of pages, not increase it.)
You can signal the total number of pages by calling <code><a href="#topic+signal_total_pages">signal_total_pages()</a></code>,
like this:
</p>
<div class="sourceCode R"><pre>next_req &lt;- function(resp, req) {
  body &lt;- resp_body_json(resp)
  cursor &lt;- body$next_cursor
  if (is.null(cursor))
    return(NULL)

  signal_total_pages(body$pages)
  req |&gt; req_body_json_modify(cursor = cursor)
}
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url()) |&gt;
  req_url_path("/iris") |&gt;
  req_throttle(10) |&gt;
  req_url_query(limit = 5)

resps &lt;- req_perform_iterative(req, iterate_with_offset("page_index"))

data &lt;- resps |&gt; resps_data(function(resp) {
  data &lt;- resp_body_json(resp)$data
  data.frame(
    Sepal.Length = sapply(data, `[[`, "Sepal.Length"),
    Sepal.Width = sapply(data, `[[`, "Sepal.Width"),
    Petal.Length = sapply(data, `[[`, "Petal.Length"),
    Petal.Width = sapply(data, `[[`, "Petal.Width"),
    Species = sapply(data, `[[`, "Species")
  )
})
str(data)
</code></pre>

<hr>
<h2 id='req_perform_parallel'>Perform a list of requests in parallel</h2><span id='topic+req_perform_parallel'></span>

<h3>Description</h3>

<p>This variation on <code><a href="#topic+req_perform_sequential">req_perform_sequential()</a></code> performs multiple requests in
parallel. Never use it without <code><a href="#topic+req_throttle">req_throttle()</a></code>; otherwise it's too easy to
pummel a server with a very large number of simultaneous requests.
</p>
<p>While running, you'll get a progress bar that looks like:
<code style="white-space: pre;">&#8288;[working] (1 + 4) -&gt; 5 -&gt; 5&#8288;</code>. The string tells you the current status of
the queue (e.g. working, waiting, errored) followed by (the
number of pending requests + pending retried requests) -&gt; the number of
active requests -&gt; the number of complete requests.
</p>


<h4>Limitations</h4>

<p>The main limitation of <code>req_perform_parallel()</code> is that it assumes applies
<code><a href="#topic+req_throttle">req_throttle()</a></code> and <code><a href="#topic+req_retry">req_retry()</a></code> are across all requests. This means,
for example, that if request 1 is throttled, but request 2 is not,
<code>req_perform_parallel()</code> will wait for request 1 before performing request 2.
This makes it most suitable for performing many parallel requests to the same
host, rather than a mix of different hosts. It's probably possible to remove
these limitation, but it's enough work that I'm unlikely to do it unless
I know that people would fine it useful: so please let me know!
</p>
<p>Additionally, it does not respect the <code>max_tries</code> argument to <code>req_retry()</code>
because if you have five requests in flight and the first one gets rate
limited, it's likely that all the others do too. This also means that
the circuit breaker is never triggered.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>req_perform_parallel(
  reqs,
  paths = NULL,
  pool = deprecated(),
  on_error = c("stop", "return", "continue"),
  progress = TRUE,
  max_active = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_parallel_+3A_reqs">reqs</code></td>
<td>
<p>A list of <a href="#topic+request">request</a>s.</p>
</td></tr>
<tr><td><code id="req_perform_parallel_+3A_paths">paths</code></td>
<td>
<p>An optional character vector of paths, if you want to download
the response bodies to disk. If supplied, must be the same length as
<code>reqs</code>.</p>
</td></tr>
<tr><td><code id="req_perform_parallel_+3A_pool">pool</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. No longer supported;
to control the maximum number of concurrent requests, set <code>max_active</code>.</p>
</td></tr>
<tr><td><code id="req_perform_parallel_+3A_on_error">on_error</code></td>
<td>
<p>What should happen if one of the requests fails?
</p>

<ul>
<li> <p><code>stop</code>, the default: stop iterating with an error.
</p>
</li>
<li> <p><code>return</code>: stop iterating, returning all the successful responses
received so far, as well as an error object for the failed request.
</p>
</li>
<li> <p><code>continue</code>: continue iterating, recording errors in the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="req_perform_parallel_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar for the status of all requests? Use
<code>TRUE</code> to turn on a basic progress bar, use a string to give it a name,
or see <a href="#topic+progress_bars">progress_bars</a> to customize it in other ways. Not compatible with
<code><a href="#topic+req_progress">req_progress()</a></code>, as httr2 can only display a single progress bar at a
time.</p>
</td></tr>
<tr><td><code id="req_perform_parallel_+3A_max_active">max_active</code></td>
<td>
<p>Maximum number of concurrent requests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, the same length as <code>reqs</code>, containing <a href="#topic+response">response</a>s and possibly
error objects, if <code>on_error</code> is <code>"return"</code> or <code>"continue"</code> and one of the
responses errors. If <code>on_error</code> is <code>"return"</code> and it errors on the ith
request, the ith element of the result will be an error object, and the
remaining elements will be <code>NULL</code>. If <code>on_error</code> is <code>"continue"</code>, it will
be a mix of requests and error objects.
</p>
<p>Only httr2 errors are captured; see <code><a href="#topic+req_error">req_error()</a></code> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requesting these 4 pages one at a time would take 2 seconds:
request_base &lt;- request(example_url()) |&gt;
  req_throttle(capacity = 100, fill_time_s = 60)
reqs &lt;- list(
  request_base |&gt; req_url_path("/delay/0.5"),
  request_base |&gt; req_url_path("/delay/0.5"),
  request_base |&gt; req_url_path("/delay/0.5"),
  request_base |&gt; req_url_path("/delay/0.5")
)
# But it's much faster if you request in parallel
system.time(resps &lt;- req_perform_parallel(reqs))

# req_perform_parallel() will fail on error
reqs &lt;- list(
  request_base |&gt; req_url_path("/status/200"),
  request_base |&gt; req_url_path("/status/400"),
  request("FAILURE")
)
try(resps &lt;- req_perform_parallel(reqs))

# but can use on_error to capture all successful results
resps &lt;- req_perform_parallel(reqs, on_error = "continue")

# Inspect the successful responses
resps |&gt; resps_successes()

# And the failed responses
resps |&gt; resps_failures() |&gt; resps_requests()
</code></pre>

<hr>
<h2 id='req_perform_promise'>Perform request asynchronously using the promises package</h2><span id='topic+req_perform_promise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This variation on <code><a href="#topic+req_perform">req_perform()</a></code> returns a <code><a href="promises.html#topic+promise">promises::promise()</a></code> object immediately
and then performs the request in the background, returning program control before the request
is finished. See the
<a href="https://rstudio.github.io/promises/articles/promises_01_motivation.html">promises package documentation</a>
for more details on how to work with the resulting promise object.
</p>
<p>If using together with <code><a href="later.html#topic+create_loop">later::with_temp_loop()</a></code> or other private event loops,
a new curl pool made by <code><a href="curl.html#topic+multi">curl::new_pool()</a></code> should be created for requests made
within the loop to ensure that only these requests are being polled by the loop.
</p>
<p>Like with <code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code>, exercise caution when using this function;
it's easy to pummel a server with many simultaneous requests. Also, not all servers
can handle more than 1 request at a time, so the responses may still return
sequentially.
</p>
<p><code>req_perform_promise()</code> also has similar limitations to the
<code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code> function, it:
</p>

<ul>
<li><p> Will not retrieve a new OAuth token if it expires after the promised request
is created but before it is actually requested.
</p>
</li>
<li><p> Does not perform throttling with <code><a href="#topic+req_throttle">req_throttle()</a></code>.
</p>
</li>
<li><p> Does not attempt retries as described by <code><a href="#topic+req_retry">req_retry()</a></code>.
</p>
</li>
<li><p> Only consults the cache set by <code><a href="#topic+req_cache">req_cache()</a></code> when the request is promised.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>req_perform_promise(req, path = NULL, pool = NULL, verbosity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_promise_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_perform_promise_+3A_path">path</code></td>
<td>
<p>Optionally, path to save body of the response. This is useful
for large responses since it avoids storing the response in memory.</p>
</td></tr>
<tr><td><code id="req_perform_promise_+3A_pool">pool</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. No longer supported;
to control the maximum number of concurrent requests, set <code>max_active</code>.</p>
</td></tr>
<tr><td><code id="req_perform_promise_+3A_verbosity">verbosity</code></td>
<td>
<p>How much information to print? This is a wrapper
around <code><a href="#topic+req_verbose">req_verbose()</a></code> that uses an integer to control verbosity:
</p>

<ul>
<li> <p><code>0</code>: no output
</p>
</li>
<li> <p><code>1</code>: show headers
</p>
</li>
<li> <p><code>2</code>: show headers and bodies
</p>
</li>
<li> <p><code>3</code>: show headers, bodies, and curl status messages.
</p>
</li></ul>

<p>Use <code><a href="#topic+with_verbosity">with_verbosity()</a></code> to control the verbosity of requests that
you can't affect directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="promises.html#topic+promise">promises::promise()</a></code> object which resolves to a <a href="#topic+response">response</a> if
successful or rejects on the same errors thrown by <code><a href="#topic+req_perform">req_perform()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(promises)
request_base &lt;- request(example_url()) |&gt; req_url_path_append("delay")

p &lt;- request_base |&gt; req_url_path_append(2) |&gt; req_perform_promise()

# A promise object, not particularly useful on its own
p

# Use promise chaining functions to access results
p %...&gt;%
  resp_body_json() %...&gt;%
  print()


# Can run two requests at the same time
p1 &lt;- request_base |&gt; req_url_path_append(2) |&gt; req_perform_promise()
p2 &lt;- request_base |&gt; req_url_path_append(1) |&gt; req_perform_promise()

p1 %...&gt;%
  resp_url_path %...&gt;%
  paste0(., " finished") %...&gt;%
  print()

p2 %...&gt;%
  resp_url_path %...&gt;%
  paste0(., " finished") %...&gt;%
  print()

# See the [promises package documentation](https://rstudio.github.io/promises/)
# for more information on working with promises

## End(Not run)
</code></pre>

<hr>
<h2 id='req_perform_sequential'>Perform multiple requests in sequence</h2><span id='topic+req_perform_sequential'></span>

<h3>Description</h3>

<p>Given a list of requests, this function performs each in turn, returning
a list of responses. It's the serial equivalent of <code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_perform_sequential(
  reqs,
  paths = NULL,
  on_error = c("stop", "return", "continue"),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_sequential_+3A_reqs">reqs</code></td>
<td>
<p>A list of <a href="#topic+request">request</a>s.</p>
</td></tr>
<tr><td><code id="req_perform_sequential_+3A_paths">paths</code></td>
<td>
<p>An optional character vector of paths, if you want to download
the response bodies to disk. If supplied, must be the same length as
<code>reqs</code>.</p>
</td></tr>
<tr><td><code id="req_perform_sequential_+3A_on_error">on_error</code></td>
<td>
<p>What should happen if one of the requests fails?
</p>

<ul>
<li> <p><code>stop</code>, the default: stop iterating with an error.
</p>
</li>
<li> <p><code>return</code>: stop iterating, returning all the successful responses
received so far, as well as an error object for the failed request.
</p>
</li>
<li> <p><code>continue</code>: continue iterating, recording errors in the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="req_perform_sequential_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar for the status of all requests? Use
<code>TRUE</code> to turn on a basic progress bar, use a string to give it a name,
or see <a href="#topic+progress_bars">progress_bars</a> to customize it in other ways. Not compatible with
<code><a href="#topic+req_progress">req_progress()</a></code>, as httr2 can only display a single progress bar at a
time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, the same length as <code>reqs</code>, containing <a href="#topic+response">response</a>s and possibly
error objects, if <code>on_error</code> is <code>"return"</code> or <code>"continue"</code> and one of the
responses errors. If <code>on_error</code> is <code>"return"</code> and it errors on the ith
request, the ith element of the result will be an error object, and the
remaining elements will be <code>NULL</code>. If <code>on_error</code> is <code>"continue"</code>, it will
be a mix of requests and error objects.
</p>
<p>Only httr2 errors are captured; see <code><a href="#topic+req_error">req_error()</a></code> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One use of req_perform_sequential() is if the API allows you to request
# data for multiple objects, you want data for more objects than can fit
# in one request.
req &lt;- request("https://api.restful-api.dev/objects")

# Imagine we have 50 ids:
ids &lt;- sort(sample(100, 50))

# But the API only allows us to request 10 at time. So we first use split
# and some modulo arithmetic magic to generate chunks of length 10
chunks &lt;- unname(split(ids, (seq_along(ids) - 1) %/% 10))

# Then we use lapply to generate one request for each chunk:
reqs &lt;- chunks |&gt; lapply(\(idx) req |&gt; req_url_query(id = idx, .multi = "comma"))

# Then we can perform them all and get the results
## Not run: 
resps &lt;- reqs |&gt; req_perform_sequential()
resps_data(resps, \(resp) resp_body_json(resp))

## End(Not run)
</code></pre>

<hr>
<h2 id='req_perform_stream'>Perform a request and handle data as it streams back</h2><span id='topic+req_perform_stream'></span><span id='topic+req_stream'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>We now recommend <code><a href="#topic+req_perform_connection">req_perform_connection()</a></code> since it has a considerably more
flexible interface. Unless I hear compelling reasons otherwise, I'm likely
to deprecate <code>req_perform_stream()</code> in a future release.
</p>
<p>After preparing a request, call <code>req_perform_stream()</code> to perform the request
and handle the result with a streaming callback. This is useful for
streaming HTTP APIs where potentially the stream never ends.
</p>
<p>The <code>callback</code> will only be called if the result is successful. If you need
to stream an error response, you can use <code><a href="#topic+req_error">req_error()</a></code> to suppress error
handling so that the body is streamed to you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_perform_stream(
  req,
  callback,
  timeout_sec = Inf,
  buffer_kb = 64,
  round = c("byte", "line")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_perform_stream_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_perform_stream_+3A_callback">callback</code></td>
<td>
<p>A single argument callback function. It will be called
repeatedly with a raw vector whenever there is at least <code>buffer_kb</code>
worth of data to process. It must return <code>TRUE</code> to continue streaming.</p>
</td></tr>
<tr><td><code id="req_perform_stream_+3A_timeout_sec">timeout_sec</code></td>
<td>
<p>Number of seconds to process stream for.</p>
</td></tr>
<tr><td><code id="req_perform_stream_+3A_buffer_kb">buffer_kb</code></td>
<td>
<p>Buffer size, in kilobytes.</p>
</td></tr>
<tr><td><code id="req_perform_stream_+3A_round">round</code></td>
<td>
<p>How should the raw vector sent to <code>callback</code> be rounded?
Choose <code>"byte"</code>, <code>"line"</code>, or supply your own function that takes a
raw vector of <code>bytes</code> and returns the locations of possible cut points
(or <code>integer()</code> if there are none).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An HTTP <a href="#topic+response">response</a>. The body will be empty if the request was
successful (since the <code>callback</code> function will have handled it). The body
will contain the HTTP response body if the request was unsuccessful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show_bytes &lt;- function(x) {
  cat("Got ", length(x), " bytes\n", sep = "")
  TRUE
}
resp &lt;- request(example_url()) |&gt;
  req_url_path("/stream-bytes/100000") |&gt;
  req_perform_stream(show_bytes, buffer_kb = 32)
resp
</code></pre>

<hr>
<h2 id='req_progress'>Add a progress bar to long downloads or uploads</h2><span id='topic+req_progress'></span>

<h3>Description</h3>

<p>When uploading or downloading a large file, it's often useful to
provide a progress bar so that you know how long you have to wait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_progress(req, type = c("down", "up"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_progress_+3A_req">req</code></td>
<td>
<p>A <a href="#topic+request">request</a>.</p>
</td></tr>
<tr><td><code id="req_progress_+3A_type">type</code></td>
<td>
<p>Type of progress to display: either number of bytes uploaded
or downloaded.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request("https://r4ds.s3.us-west-2.amazonaws.com/seattle-library-checkouts.csv") |&gt;
  req_progress()

## Not run: 
path &lt;- tempfile()
req |&gt; req_perform(path = path)

## End(Not run)
</code></pre>

<hr>
<h2 id='req_proxy'>Use a proxy for a request</h2><span id='topic+req_proxy'></span>

<h3>Description</h3>

<p>Use a proxy for a request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_proxy(
  req,
  url,
  port = NULL,
  username = NULL,
  password = NULL,
  auth = "basic"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_proxy_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_proxy_+3A_url">url</code>, <code id="req_proxy_+3A_port">port</code></td>
<td>
<p>Location of proxy.</p>
</td></tr>
<tr><td><code id="req_proxy_+3A_username">username</code>, <code id="req_proxy_+3A_password">password</code></td>
<td>
<p>Login details for proxy, if needed.</p>
</td></tr>
<tr><td><code id="req_proxy_+3A_auth">auth</code></td>
<td>
<p>Type of HTTP authentication to use. Should be one of the
following: <code>basic</code>, <code>digest</code>, <code>digest_ie</code>, <code>gssnegotiate</code>, <code>ntlm</code>, <code>any</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Proxy from https://www.proxynova.com/proxy-server-list/
## Not run: 
request("http://hadley.nz") |&gt;
  req_proxy("20.116.130.70", 3128) |&gt;
  req_perform()

## End(Not run)
</code></pre>

<hr>
<h2 id='req_retry'>Automatically retry a request on failure</h2><span id='topic+req_retry'></span>

<h3>Description</h3>

<p><code>req_retry()</code> allows <code><a href="#topic+req_perform">req_perform()</a></code> to automatically retry failing
requests. It's particularly important for APIs with rate limiting, but can
also be useful when dealing with flaky servers.
</p>
<p>By default, <code>req_perform()</code> will retry if the response is a 429
(&quot;too many requests&quot;, often used for rate limiting) or 503
(&quot;service unavailable&quot;). If the API you are wrapping has other transient
status codes (or conveys transience with some other property of the
response), you can override the default with <code>is_transient</code>. And
if you set <code>retry_on_failure = TRUE</code>, the request will retry
if either the HTTP request or HTTP response doesn't complete successfully,
leading to an error from curl, the lower-level library that httr2 uses to
perform HTTP requests. This occurs, for example, if your Wi-Fi is down.
</p>


<h4>Delay</h4>

<p>It's a bad idea to immediately retry a request, so <code>req_perform()</code> will
wait a little before trying again:
</p>

<ul>
<li><p> If the response contains the <code>Retry-After</code> header, httr2 will wait the
amount of time it specifies. If the API you are wrapping conveys this
information with a different header (or other property of the response),
you can override the default behavior with <code>retry_after</code>.
</p>
</li>
<li><p> Otherwise, httr2 will use &quot;truncated exponential backoff with full
jitter&quot;, i.e., it will wait a random amount of time between one second and
<code>2 ^ tries</code> seconds, capped at a maximum of 60 seconds. In other words, it
waits <code>runif(1, 1, 2)</code> seconds after the first failure, <code>runif(1, 1, 4)</code>
after the second, <code>runif(1, 1, 8)</code> after the third, and so on. If you'd
prefer a different strategy, you can override the default with <code>backoff</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>req_retry(
  req,
  max_tries = NULL,
  max_seconds = NULL,
  retry_on_failure = FALSE,
  is_transient = NULL,
  backoff = NULL,
  after = NULL,
  failure_threshold = Inf,
  failure_timeout = 30,
  failure_realm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_retry_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_max_tries">max_tries</code>, <code id="req_retry_+3A_max_seconds">max_seconds</code></td>
<td>
<p>Cap the maximum number of attempts
(<code>max_tries</code>), the total elapsed time from the first request
(<code>max_seconds</code>), or both.
</p>
<p><code>max_tries</code> is the total number of attempts made, so this should always
be greater than one.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_retry_on_failure">retry_on_failure</code></td>
<td>
<p>Treat low-level failures as if they are
transient errors that can be retried.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_is_transient">is_transient</code></td>
<td>
<p>A predicate function that takes a single argument
(the response) and returns <code>TRUE</code> or <code>FALSE</code> specifying whether or not
the response represents a transient error.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_backoff">backoff</code></td>
<td>
<p>A function that takes a single argument (the number of failed
attempts so far) and returns the number of seconds to wait.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_after">after</code></td>
<td>
<p>A function that takes a single argument (the response) and
returns either a number of seconds to wait or <code>NA</code>. <code>NA</code> indicates
that a precise wait time is not available and that the <code>backoff</code> strategy
should be used instead.</p>
</td></tr>
<tr><td><code id="req_retry_+3A_failure_threshold">failure_threshold</code>, <code id="req_retry_+3A_failure_timeout">failure_timeout</code>, <code id="req_retry_+3A_failure_realm">failure_realm</code></td>
<td>
<p>Set <code>failure_threshold</code> to activate &quot;circuit breaking&quot; where if a request
continues to fail after <code>failure_threshold</code> times, cause the request to
error until a timeout of <code>failure_timeout</code> seconds has elapsed. This
timeout will persist across all requests with the same <code>failure_realm</code>
(which defaults to the hostname of the request) and is intended to detect
failing servers without needing to wait each time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+req_throttle">req_throttle()</a></code> if the API has a rate-limit but doesn't expose
the limits in the response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># google APIs assume that a 500 is also a transient error
request("http://google.com") |&gt;
  req_retry(is_transient = \(resp) resp_status(resp) %in% c(429, 500, 503))

# use a constant 10s delay after every failure
request("http://example.com") |&gt;
  req_retry(backoff = \(resp) 10)

# When rate-limited, GitHub's API returns a 403 with
# `X-RateLimit-Remaining: 0` and an Unix time stored in the
# `X-RateLimit-Reset` header. This takes a bit more work to handle:
github_is_transient &lt;- function(resp) {
  resp_status(resp) == 403 &amp;&amp;
    identical(resp_header(resp, "X-RateLimit-Remaining"), "0")
}
github_after &lt;- function(resp) {
  time &lt;- as.numeric(resp_header(resp, "X-RateLimit-Reset"))
  time - unclass(Sys.time())
}
request("http://api.github.com") |&gt;
  req_retry(
    is_transient = github_is_transient,
    after = github_after
  )
</code></pre>

<hr>
<h2 id='req_template'>Set request method/path from a template</h2><span id='topic+req_template'></span>

<h3>Description</h3>

<p>Many APIs document their methods with a lightweight template mechanism
that looks like <code>GET /user/{user}</code> or <code style="white-space: pre;">&#8288;POST /organisation/:org&#8288;</code>. This
function makes it easy to copy and paste such snippets and retrieve template
variables either from function arguments or the current environment.
</p>
<p><code>req_template()</code> will append to the existing path so that you can set a
base url in the initial <code><a href="#topic+request">request()</a></code>. This means that you'll generally want
to avoid multiple <code>req_template()</code> calls on the same request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_template(req, template, ..., .env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_template_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_template_+3A_template">template</code></td>
<td>
<p>A template string which consists of a optional HTTP method
and a path containing variables labelled like either <code style="white-space: pre;">&#8288;:foo&#8288;</code> or <code>{foo}</code>.</p>
</td></tr>
<tr><td><code id="req_template_+3A_...">...</code></td>
<td>
<p>Template variables.</p>
</td></tr>
<tr><td><code id="req_template_+3A_.env">.env</code></td>
<td>
<p>Environment in which to look for template variables not found
in <code>...</code>. Expert use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>httpbin &lt;- request(example_url())

# You can supply template parameters in `...`
httpbin |&gt; req_template("GET /bytes/{n}", n = 100)

# or you retrieve from the current environment
n &lt;- 200
httpbin |&gt; req_template("GET /bytes/{n}")

# Existing path is preserved:
httpbin_test &lt;- request(example_url()) |&gt; req_url_path("/test")
name &lt;- "id"
value &lt;- "a3fWa"
httpbin_test |&gt; req_template("GET /set/{name}/{value}")
</code></pre>

<hr>
<h2 id='req_throttle'>Rate limit a request by automatically adding a delay</h2><span id='topic+req_throttle'></span>

<h3>Description</h3>

<p>Use <code>req_throttle()</code> to ensure that repeated calls to <code><a href="#topic+req_perform">req_perform()</a></code> never
exceed a specified rate.
</p>
<p>Throttling is implemented using a &quot;token bucket&quot;, which steadily fills up to
a maximum of <code>capacity</code> tokens over <code>fill_time_s</code>. Each time you make a
request, it takes a token out of the bucket, and if the bucket is empty,
the request will wait until the bucket refills. This ensures that you never
make more than <code>capacity</code> requests in <code>fill_time_s</code>, but you can make
requests more quickly if the bucket is full. For example, if you have
<code>capacity = 10</code> and <code>fill_time_s = 60</code>, you can make 10 requests
without waiting, but the next request will wait 60 seconds. This gives the
same average throttling rate as the previous approach, but gives you much
better performance if you're only making a small number of requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_throttle(req, rate, capacity, fill_time_s = 60, realm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_throttle_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_throttle_+3A_rate">rate</code></td>
<td>
<p>For backwards compatibility, you can still specify the <code>rate</code>,
which is converted to <code>capacity</code> by multiplying by <code>fill_time_s</code>.
However, we recommend using <code>capacity</code> and <code>fill_time_s</code> as it gives more
control.</p>
</td></tr>
<tr><td><code id="req_throttle_+3A_capacity">capacity</code></td>
<td>
<p>The size of the bucket, i.e. the maximum number of
tokens that can accumulate.</p>
</td></tr>
<tr><td><code id="req_throttle_+3A_fill_time_s">fill_time_s</code></td>
<td>
<p>Time in seconds to fill the capacity. Defaults to 60s.</p>
</td></tr>
<tr><td><code id="req_throttle_+3A_realm">realm</code></td>
<td>
<p>A string that uniquely identifies the throttle pool to use
(throttling limits always apply <em>per pool</em>). If not supplied, defaults
to the hostname of the request.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+req_retry">req_retry()</a></code> for another way of handling rate-limited APIs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ensure we never send more than 30 requests a minute
req &lt;- request(example_url()) |&gt;
  req_throttle(capacity = 30, fill_time_s = 60)

resp &lt;- req_perform(req)
throttle_status()
resp &lt;- req_perform(req)
throttle_status()


</code></pre>

<hr>
<h2 id='req_timeout'>Set time limit for a request</h2><span id='topic+req_timeout'></span>

<h3>Description</h3>

<p>An error will be thrown if the request does not complete in the time limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_timeout(req, seconds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_timeout_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_timeout_+3A_seconds">seconds</code></td>
<td>
<p>Maximum number of seconds to wait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Give up after at most 10 seconds
request("http://example.com") |&gt; req_timeout(10)
</code></pre>

<hr>
<h2 id='req_url'>Modify request URL</h2><span id='topic+req_url'></span><span id='topic+req_url_relative'></span><span id='topic+req_url_query'></span><span id='topic+req_url_path'></span><span id='topic+req_url_path_append'></span>

<h3>Description</h3>


<ul>
<li> <p><code>req_url()</code> replaces the entire URL.
</p>
</li>
<li> <p><code>req_url_relative()</code> navigates to a relative URL.
</p>
</li>
<li> <p><code>req_url_query()</code> modifies individual query components.
</p>
</li>
<li> <p><code>req_url_path()</code> modifies just the path.
</p>
</li>
<li> <p><code>req_url_path_append()</code> adds to the path.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>req_url(req, url)

req_url_relative(req, url)

req_url_query(
  .req,
  ...,
  .multi = c("error", "comma", "pipe", "explode"),
  .space = c("percent", "form")
)

req_url_path(req, ...)

req_url_path_append(req, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_url_+3A_req">req</code>, <code id="req_url_+3A_.req">.req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_url_+3A_url">url</code></td>
<td>
<p>A new URL; either an absolute URL for <code>req_url()</code> or a
relative URL for <code>req_url_relative()</code>.</p>
</td></tr>
<tr><td><code id="req_url_+3A_...">...</code></td>
<td>
<p>For <code>req_url_query()</code>: &lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
Name-value pairs that define query parameters. Each value must be either
an atomic vector or <code>NULL</code> (which removes the corresponding parameters).
If you want to opt out of escaping, wrap strings in <code>I()</code>.
</p>
<p>For <code>req_url_path()</code> and <code>req_url_path_append()</code>: A sequence of path
components that will be combined with <code>/</code>.</p>
</td></tr>
<tr><td><code id="req_url_+3A_.multi">.multi</code></td>
<td>
<p>Controls what happens when a value is a vector:
</p>

<ul>
<li> <p><code>"error"</code>, the default, throws an error.
</p>
</li>
<li> <p><code>"comma"</code>, separates values with a <code style="white-space: pre;">&#8288;,&#8288;</code>, e.g. <code style="white-space: pre;">&#8288;?x=1,2&#8288;</code>.
</p>
</li>
<li> <p><code>"pipe"</code>, separates values with a <code>|</code>, e.g. <code>?x=1|2</code>.
</p>
</li>
<li> <p><code>"explode"</code>, turns each element into its own parameter, e.g. <code>?x=1&amp;x=2</code>
</p>
</li></ul>

<p>If none of these options work for your needs, you can instead supply a
function that takes a character vector of argument values and returns a
a single string.</p>
</td></tr>
<tr><td><code id="req_url_+3A_.space">.space</code></td>
<td>
<p>How should spaces in query params be escaped? The default,
&quot;percent&quot;, uses standard percent encoding (i.e. <code style="white-space: pre;">&#8288;%20&#8288;</code>), but you can opt-in
to &quot;form&quot; encoding, which uses <code>+</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>See Also</h3>


<ul>
<li><p> To modify a URL without creating a request, see <code><a href="#topic+url_modify">url_modify()</a></code> and
friends.
</p>
</li>
<li><p> To use a template like <code>GET /user/{user}</code>, see <code><a href="#topic+req_template">req_template()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Change complete url
req &lt;- request("http://example.com")
req |&gt; req_url("http://google.com")

# Use a relative url
req &lt;- request("http://example.com/a/b/c")
req |&gt; req_url_relative("..")
req |&gt; req_url_relative("/d/e/f")

# Change url components
req |&gt;
  req_url_path_append("a") |&gt;
  req_url_path_append("b") |&gt;
  req_url_path_append("search.html") |&gt;
  req_url_query(q = "the cool ice")

# Modify individual query parameters
req &lt;- request("http://example.com?a=1&amp;b=2")
req |&gt; req_url_query(a = 10)
req |&gt; req_url_query(a = NULL)
req |&gt; req_url_query(c = 3)

# Use .multi to control what happens with vector parameters:
req |&gt; req_url_query(id = 100:105, .multi = "comma")
req |&gt; req_url_query(id = 100:105, .multi = "explode")

# If you have query parameters in a list, use !!!
params &lt;- list(a = "1", b = "2")
req |&gt;
  req_url_query(!!!params, c = "3")
</code></pre>

<hr>
<h2 id='req_user_agent'>Set user-agent for a request</h2><span id='topic+req_user_agent'></span>

<h3>Description</h3>

<p>This overrides the default user-agent set by httr2 which includes the
version numbers of httr2, the curl package, and libcurl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>req_user_agent(req, string = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_user_agent_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_user_agent_+3A_string">string</code></td>
<td>
<p>String to be sent in the <code>User-Agent</code> header. If <code>NULL</code>,
will user default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default user-agent:
request("http://example.com") |&gt; req_dry_run()

request("http://example.com") |&gt; req_user_agent("MyString") |&gt; req_dry_run()

# If you're wrapping in an API in a package, it's polite to set the
# user agent to identify your package.
request("http://example.com") |&gt;
  req_user_agent("MyPackage (http://mypackage.com)") |&gt;
  req_dry_run()
</code></pre>

<hr>
<h2 id='req_verbose'>Show extra output when request is performed</h2><span id='topic+req_verbose'></span>

<h3>Description</h3>

<p><code>req_verbose()</code> uses the following prefixes to distinguish between
different components of the HTTP requests and responses:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;* &#8288;</code> informative curl messages
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-&gt;&#8288;</code> request headers
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&gt;&gt;&#8288;</code> request body
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;-&#8288;</code> response headers
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;&lt;&#8288;</code> response body
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>req_verbose(
  req,
  header_req = TRUE,
  header_resp = TRUE,
  body_req = FALSE,
  body_resp = FALSE,
  info = FALSE,
  redact_headers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="req_verbose_+3A_req">req</code></td>
<td>
<p>A httr2 <a href="#topic+request">request</a> object.</p>
</td></tr>
<tr><td><code id="req_verbose_+3A_header_req">header_req</code>, <code id="req_verbose_+3A_header_resp">header_resp</code></td>
<td>
<p>Show request/response headers?</p>
</td></tr>
<tr><td><code id="req_verbose_+3A_body_req">body_req</code>, <code id="req_verbose_+3A_body_resp">body_resp</code></td>
<td>
<p>Should request/response bodies? When the response
body is compressed, this will show the number of bytes received in
each &quot;chunk&quot;.</p>
</td></tr>
<tr><td><code id="req_verbose_+3A_info">info</code></td>
<td>
<p>Show informational text from curl? This is mainly useful
for debugging https and auth problems, so is disabled by default.</p>
</td></tr>
<tr><td><code id="req_verbose_+3A_redact_headers">redact_headers</code></td>
<td>
<p>Redact confidential data in the headers? Currently
redacts the contents of the Authorization header to prevent you from
accidentally leaking credentials when debugging/reprexing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified HTTP <a href="#topic+request">request</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+req_perform">req_perform()</a></code> which exposes a limited subset of these options
through the <code>verbosity</code> argument and <code><a href="#topic+with_verbosity">with_verbosity()</a></code> which allows you
to control the verbosity of requests deeper within the call stack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use `req_verbose()` to see the headers that are sent back and forth when
# making a request
resp &lt;- request("https://httr2.r-lib.org") |&gt;
  req_verbose() |&gt;
  req_perform()

# Or use one of the convenient shortcuts:
resp &lt;- request("https://httr2.r-lib.org") |&gt;
  req_perform(verbosity = 1)
</code></pre>

<hr>
<h2 id='request'>Create a new HTTP request</h2><span id='topic+request'></span>

<h3>Description</h3>

<p>There are three steps needed to perform a HTTP request with httr2:
</p>

<ol>
<li><p> Create a request object with <code>request(url)</code> (this function).
</p>
</li>
<li><p> Define its behaviour with <code>req_</code> functions, e.g.:
</p>

<ul>
<li> <p><code><a href="#topic+req_headers">req_headers()</a></code> to set header values.
</p>
</li>
<li> <p><code><a href="#topic+req_url_path">req_url_path()</a></code> and friends to modify the url.
</p>
</li>
<li> <p><code><a href="#topic+req_body_json">req_body_json()</a></code> and friends to add a body.
</p>
</li>
<li> <p><code><a href="#topic+req_auth_basic">req_auth_basic()</a></code> to perform basic HTTP authentication.
</p>
</li>
<li> <p><code><a href="#topic+req_oauth_auth_code">req_oauth_auth_code()</a></code> to use the OAuth auth code flow.
</p>
</li></ul>

</li>
<li><p> Perform the request and fetch the response with <code><a href="#topic+req_perform">req_perform()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>request(base_url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="request_+3A_base_url">base_url</code></td>
<td>
<p>Base URL for request.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An HTTP request: an S3 list with class <code>httr2_request</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>request("http://r-project.org")
</code></pre>

<hr>
<h2 id='resp_body_raw'>Extract body from response</h2><span id='topic+resp_body_raw'></span><span id='topic+resp_has_body'></span><span id='topic+resp_body_string'></span><span id='topic+resp_body_json'></span><span id='topic+resp_body_html'></span><span id='topic+resp_body_xml'></span>

<h3>Description</h3>


<ul>
<li> <p><code>resp_body_raw()</code> returns the raw bytes.
</p>
</li>
<li> <p><code>resp_body_string()</code> returns a UTF-8 string.
</p>
</li>
<li> <p><code>resp_body_json()</code> returns parsed JSON.
</p>
</li>
<li> <p><code>resp_body_html()</code> returns parsed HTML.
</p>
</li>
<li> <p><code>resp_body_xml()</code> returns parsed XML.
</p>
</li>
<li> <p><code>resp_has_body()</code> returns <code>TRUE</code> if the response has a body.
</p>
</li></ul>

<p><code>resp_body_json()</code> and <code>resp_body_xml()</code> check that the content-type header
is correct; if the server returns an incorrect type you can suppress the
check with <code>check_type = FALSE</code>. These two functions also cache the parsed
object so the second and subsequent calls are low-cost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_body_raw(resp)

resp_has_body(resp)

resp_body_string(resp, encoding = NULL)

resp_body_json(resp, check_type = TRUE, simplifyVector = FALSE, ...)

resp_body_html(resp, check_type = TRUE, ...)

resp_body_xml(resp, check_type = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_body_raw_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_body_raw_+3A_encoding">encoding</code></td>
<td>
<p>Character encoding of the body text. If not specified,
will use the encoding specified by the content-type, falling back to
UTF-8 with a warning if it cannot be found. The resulting string is
always re-encoded to UTF-8.</p>
</td></tr>
<tr><td><code id="resp_body_raw_+3A_check_type">check_type</code></td>
<td>
<p>Check that response has expected content type? Set to
<code>FALSE</code> to suppress the automated check</p>
</td></tr>
<tr><td><code id="resp_body_raw_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>Should JSON arrays containing only primitives (i.e.
booleans, numbers, and strings) be caused to atomic vectors?</p>
</td></tr>
<tr><td><code id="resp_body_raw_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code> and
<code><a href="xml2.html#topic+read_xml">xml2::read_xml()</a></code> respectively.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>resp_body_raw()</code> returns a raw vector.
</p>
</li>
<li> <p><code>resp_body_string()</code> returns a string.
</p>
</li>
<li> <p><code>resp_body_json()</code> returns NULL, an atomic vector, or list.
</p>
</li>
<li> <p><code>resp_body_html()</code> and <code>resp_body_xml()</code> return an <code>xml2::xml_document</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- request("https://httr2.r-lib.org") |&gt; req_perform()
resp

resp |&gt; resp_has_body()
resp |&gt; resp_body_raw()
resp |&gt; resp_body_string()

if (requireNamespace("xml2", quietly = TRUE)) {
  resp |&gt; resp_body_html()
}
</code></pre>

<hr>
<h2 id='resp_check_content_type'>Check the content type of a response</h2><span id='topic+resp_check_content_type'></span>

<h3>Description</h3>

<p>A different content type than expected often leads to an error in parsing
the response body. This function checks that the content type of the response
is as expected and fails otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_check_content_type(
  resp,
  valid_types = NULL,
  valid_suffix = NULL,
  check_type = TRUE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_check_content_type_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_check_content_type_+3A_valid_types">valid_types</code></td>
<td>
<p>A character vector of valid MIME types. Should only
be specified with <code>type/subtype</code>.</p>
</td></tr>
<tr><td><code id="resp_check_content_type_+3A_valid_suffix">valid_suffix</code></td>
<td>
<p>A string given an &quot;structured media type&quot; suffix.</p>
</td></tr>
<tr><td><code id="resp_check_content_type_+3A_check_type">check_type</code></td>
<td>
<p>Should the type actually be checked? Provided as a
convenience for when using this function inside <code style="white-space: pre;">&#8288;resp_body_*&#8288;</code> helpers.</p>
</td></tr>
<tr><td><code id="resp_check_content_type_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side-effect; erroring if the response does not
have the expected content type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- response(headers = list(`content-type` = "application/json"))
resp_check_content_type(resp, "application/json")
try(resp_check_content_type(resp, "application/xml"))

# `types` can also specify multiple valid types
resp_check_content_type(resp, c("application/xml", "application/json"))
</code></pre>

<hr>
<h2 id='resp_content_type'>Extract response content type and encoding</h2><span id='topic+resp_content_type'></span><span id='topic+resp_encoding'></span>

<h3>Description</h3>

<p><code>resp_content_type()</code> returns the just the type and subtype of the
from the <code>Content-Type</code> header. If <code>Content-Type</code> is not provided; it
returns <code>NA</code>. Used by <code><a href="#topic+resp_body_json">resp_body_json()</a></code>, <code><a href="#topic+resp_body_html">resp_body_html()</a></code>, and
<code><a href="#topic+resp_body_xml">resp_body_xml()</a></code>.
</p>
<p><code>resp_encoding()</code> returns the likely character encoding of text
types, as parsed from the <code>charset</code> parameter of the <code>Content-Type</code>
header. If that header is not found, not valid, or no charset parameter
is found, returns <code>UTF-8</code>. Used by <code><a href="#topic+resp_body_string">resp_body_string()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_content_type(resp)

resp_encoding(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_content_type_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string. If no content type is specified <code>resp_content_type()</code>
will return a character <code>NA</code>; if no encoding is specified,
<code>resp_encoding()</code> will return <code>"UTF-8"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- response(headers = "Content-type: text/html; charset=utf-8")
resp |&gt; resp_content_type()
resp |&gt; resp_encoding()

# No Content-Type header
resp &lt;- response()
resp |&gt; resp_content_type()
resp |&gt; resp_encoding()
</code></pre>

<hr>
<h2 id='resp_date'>Extract request date from response</h2><span id='topic+resp_date'></span>

<h3>Description</h3>

<p>All responses contain a request date in the <code>Date</code> header; if not provided
by the server will be automatically added by httr2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_date(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_date_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>POSIXct</code> date-time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- response(headers = "Date: Wed, 01 Jan 2020 09:23:15 UTC")
resp |&gt; resp_date()

# If server doesn't add header (unusual), you get the time the request
# was created:
resp &lt;- response()
resp |&gt; resp_date()
</code></pre>

<hr>
<h2 id='resp_headers'>Extract headers from a response</h2><span id='topic+resp_headers'></span><span id='topic+resp_header'></span><span id='topic+resp_header_exists'></span>

<h3>Description</h3>


<ul>
<li> <p><code>resp_headers()</code> retrieves a list of all headers.
</p>
</li>
<li> <p><code>resp_header()</code> retrieves a single header.
</p>
</li>
<li> <p><code>resp_header_exists()</code> checks if a header is present.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>resp_headers(resp, filter = NULL)

resp_header(resp, header, default = NULL)

resp_header_exists(resp, header)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_headers_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_headers_+3A_filter">filter</code></td>
<td>
<p>A regular expression used to filter the header names.
<code>NULL</code>, the default, returns all headers.</p>
</td></tr>
<tr><td><code id="resp_headers_+3A_header">header</code></td>
<td>
<p>Header name (case insensitive)</p>
</td></tr>
<tr><td><code id="resp_headers_+3A_default">default</code></td>
<td>
<p>Default value to use if header doesn't exist.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>resp_headers()</code> returns a list.
</p>
</li>
<li> <p><code>resp_header()</code> returns a string if the header exists and <code>NULL</code> otherwise.
</p>
</li>
<li> <p><code>resp_header_exists()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- request("https://httr2.r-lib.org") |&gt; req_perform()
resp |&gt; resp_headers()
resp |&gt; resp_headers("x-")

resp |&gt; resp_header_exists("server")
resp |&gt; resp_header("server")
# Headers are case insensitive
resp |&gt; resp_header("SERVER")

# Returns NULL if header doesn't exist
resp |&gt; resp_header("this-header-doesnt-exist")
</code></pre>

<hr>
<h2 id='resp_link_url'>Parse link URL from a response</h2><span id='topic+resp_link_url'></span>

<h3>Description</h3>

<p>Parses URLs out of the the <code>Link</code> header as defined by <a href="https://datatracker.ietf.org/doc/html/rfc8288">RFC 8288</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_link_url(resp, rel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_link_url_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_link_url_+3A_rel">rel</code></td>
<td>
<p>The &quot;link relation type&quot; value for which to retrieve a URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a string providing a URL, if the specified <code>rel</code> exists, or
<code>NULL</code> if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate response from GitHub code search
resp &lt;- response(headers = paste0("Link: ",
  '&lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=2&gt;; rel="next",',
  '&lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel="last"'
))

resp_link_url(resp, "next")
resp_link_url(resp, "last")
resp_link_url(resp, "prev")
</code></pre>

<hr>
<h2 id='resp_raw'>Show the raw response</h2><span id='topic+resp_raw'></span>

<h3>Description</h3>

<p>This function reconstructs the HTTP message that httr2 received from the
server. It's unlikely to be exactly byte-for-byte identical (because most
servers compress at least the body, and HTTP/2 can also compress the
headers), but it conveys the same information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_raw(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_raw_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>resp</code> (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- request(example_url()) |&gt;
  req_url_path("/json") |&gt;
  req_perform()
resp |&gt; resp_raw()
</code></pre>

<hr>
<h2 id='resp_request'>Find the request responsible for a response</h2><span id='topic+resp_request'></span>

<h3>Description</h3>

<p>To make debugging easier, httr2 includes the request that was used to
generate every response. You can use this function to access it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_request(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_request_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url())
resp &lt;- req_perform(req)
resp_request(resp)
</code></pre>

<hr>
<h2 id='resp_retry_after'>Extract wait time from a response</h2><span id='topic+resp_retry_after'></span>

<h3>Description</h3>

<p>Computes how many seconds you should wait before retrying a request by
inspecting the <code>Retry-After</code> header. It parses both forms (absolute and
relative) and returns the number of seconds to wait. If the heading is not
found, it will return <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_retry_after(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_retry_after_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar double giving the number of seconds to wait before retrying
a request.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- response(headers = "Retry-After: 30")
resp |&gt; resp_retry_after()

resp &lt;- response(headers = "Retry-After: Mon, 20 Sep 2025 21:44:05 UTC")
resp |&gt; resp_retry_after()
</code></pre>

<hr>
<h2 id='resp_status'>Extract HTTP status from response</h2><span id='topic+resp_status'></span><span id='topic+resp_status_desc'></span><span id='topic+resp_is_error'></span><span id='topic+resp_check_status'></span>

<h3>Description</h3>


<ul>
<li> <p><code>resp_status()</code> retrieves the numeric HTTP status code
</p>
</li>
<li> <p><code>resp_status_desc()</code> retrieves the brief textual description.
</p>
</li>
<li> <p><code>resp_is_error()</code> returns <code>TRUE</code> if the status code represents an error
(i.e. a 4xx or 5xx status).
</p>
</li>
<li> <p><code>resp_check_status()</code> turns HTTPs errors into R errors.
</p>
</li></ul>

<p>These functions are mostly for internal use because in most cases you
will only ever see a 200 response:
</p>

<ul>
<li><p> 1xx are handled internally by curl.
</p>
</li>
<li><p> 3xx redirects are automatically followed. You will only see them if you
have deliberately suppressed redirects with
<code>req |&gt; req_options(followlocation = FALSE)</code>.
</p>
</li>
<li><p> 4xx client and 5xx server errors are automatically turned into R errors.
You can stop them from being turned into R errors with <code><a href="#topic+req_error">req_error()</a></code>,
e.g. <code>req |&gt; req_error(is_error = ~ FALSE)</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>resp_status(resp)

resp_status_desc(resp)

resp_is_error(resp)

resp_check_status(resp, info = NULL, error_call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_status_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_status_+3A_info">info</code></td>
<td>
<p>A character vector of additional information to include in
the error message. Passed to <code><a href="rlang.html#topic+abort">rlang::abort()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_status_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>resp_status()</code> returns a scalar integer
</p>
</li>
<li> <p><code>resp_status_desc()</code> returns a string
</p>
</li>
<li> <p><code>resp_is_error()</code> returns <code>TRUE</code> or <code>FALSE</code>
</p>
</li>
<li> <p><code>resp_check_status()</code> invisibly returns the response if it's ok;
otherwise it throws an error with class <code style="white-space: pre;">&#8288;httr2_http_{status}&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># An HTTP status code you're unlikely to see in the wild:
resp &lt;- response(418)
resp |&gt; resp_is_error()
resp |&gt; resp_status()
resp |&gt; resp_status_desc()
</code></pre>

<hr>
<h2 id='resp_stream_raw'>Read a streaming body a chunk at a time</h2><span id='topic+resp_stream_raw'></span><span id='topic+resp_stream_lines'></span><span id='topic+resp_stream_sse'></span><span id='topic+resp_stream_aws'></span><span id='topic+close.httr2_response'></span><span id='topic+resp_stream_is_complete'></span>

<h3>Description</h3>


<ul>
<li> <p><code>resp_stream_raw()</code> retrieves bytes (<code>raw</code> vectors).
</p>
</li>
<li> <p><code>resp_stream_lines()</code> retrieves lines of text (<code>character</code> vectors).
</p>
</li>
<li> <p><code>resp_stream_sse()</code> retrieves a single <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent event</a>.
</p>
</li>
<li> <p><code>resp_stream_aws()</code> retrieves a single event from an AWS stream
(i.e. mime type 'application/vnd.amazon.eventstream&ldquo;).
</p>
</li></ul>

<p>Use <code>resp_stream_is_complete()</code> to determine if there is further data
waiting on the stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_stream_raw(resp, kb = 32)

resp_stream_lines(resp, lines = 1, max_size = Inf, warn = TRUE)

resp_stream_sse(resp, max_size = Inf)

resp_stream_aws(resp, max_size = Inf)

## S3 method for class 'httr2_response'
close(con, ...)

resp_stream_is_complete(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_stream_raw_+3A_resp">resp</code>, <code id="resp_stream_raw_+3A_con">con</code></td>
<td>
<p>A streaming <a href="#topic+response">response</a> created by <code><a href="#topic+req_perform_connection">req_perform_connection()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_stream_raw_+3A_kb">kb</code></td>
<td>
<p>How many kilobytes (1024 bytes) of data to read.</p>
</td></tr>
<tr><td><code id="resp_stream_raw_+3A_lines">lines</code></td>
<td>
<p>The maximum number of lines to return at once.</p>
</td></tr>
<tr><td><code id="resp_stream_raw_+3A_max_size">max_size</code></td>
<td>
<p>The maximum number of bytes to buffer; once this number of
bytes has been exceeded without a line/event boundary, an error is thrown.</p>
</td></tr>
<tr><td><code id="resp_stream_raw_+3A_warn">warn</code></td>
<td>
<p>Like <code><a href="base.html#topic+readLines">readLines()</a></code>: warn if the connection ends without a final
EOL.</p>
</td></tr>
<tr><td><code id="resp_stream_raw_+3A_...">...</code></td>
<td>
<p>Not used; included for compatibility with generic.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>resp_stream_raw()</code>: a raw vector.
</p>
</li>
<li> <p><code>resp_stream_lines()</code>: a character vector.
</p>
</li>
<li> <p><code>resp_stream_sse()</code>: a list with components <code>type</code>, <code>data</code>, and <code>id</code>.
<code>type</code>, <code>data</code>, and <code>id</code> are always strings; <code>data</code> and <code>id</code> may be empty
strings.
</p>
</li>
<li> <p><code>resp_stream_aws()</code>: a list with components <code>headers</code> and <code>body</code>.
<code>body</code> will be automatically parsed if the event contents a <code style="white-space: pre;">&#8288;:content-type&#8288;</code>
header with <code>application/json</code>.
</p>
</li></ul>

<p><code>resp_stream_sse()</code> and <code>resp_stream_aws()</code> will return <code>NULL</code> to signal that
the end of the stream has been reached or, if in nonblocking mode, that
no event is currently available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- request(example_url()) |&gt;
  req_template("GET /stream/:n", n = 5)

con &lt;- req |&gt; req_perform_connection()
while (!resp_stream_is_complete(con)) {
  lines &lt;- con |&gt; resp_stream_lines(2)
  cat(length(lines), " lines received\n", sep = "")
}
close(con)

# You can also see what's happening by setting verbosity
con &lt;- req |&gt; req_perform_connection(verbosity = 2)
while (!resp_stream_is_complete(con)) {
  lines &lt;- con |&gt; resp_stream_lines(2)
}
close(con)
</code></pre>

<hr>
<h2 id='resp_url'>Get URL/components from the response</h2><span id='topic+resp_url'></span><span id='topic+resp_url_path'></span><span id='topic+resp_url_query'></span><span id='topic+resp_url_queries'></span>

<h3>Description</h3>


<ul>
<li> <p><code>resp_url()</code> returns the complete url.
</p>
</li>
<li> <p><code>resp_url_path()</code> returns the path component.
</p>
</li>
<li> <p><code>resp_url_query()</code> returns a single query component.
</p>
</li>
<li> <p><code>resp_url_queries()</code> returns the query component as a named list.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>resp_url(resp)

resp_url_path(resp)

resp_url_query(resp, name, default = NULL)

resp_url_queries(resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resp_url_+3A_resp">resp</code></td>
<td>
<p>A httr2 <a href="#topic+response">response</a> object, created by <code><a href="#topic+req_perform">req_perform()</a></code>.</p>
</td></tr>
<tr><td><code id="resp_url_+3A_name">name</code></td>
<td>
<p>Query parameter name.</p>
</td></tr>
<tr><td><code id="resp_url_+3A_default">default</code></td>
<td>
<p>Default value to use if query parameter doesn't exist.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>resp &lt;- request(example_url()) |&gt;
  req_url_path("/get?hello=world") |&gt;
  req_perform()

resp |&gt; resp_url()
resp |&gt; resp_url_path()
resp |&gt; resp_url_queries()
resp |&gt; resp_url_query("hello")
</code></pre>

<hr>
<h2 id='response'>Create a new HTTP response</h2><span id='topic+response'></span><span id='topic+response_json'></span>

<h3>Description</h3>

<p>Generally, you should not need to call this function directly; you'll
get a real HTTP response by calling <code><a href="#topic+req_perform">req_perform()</a></code> and friends. This
function is provided primarily for testing, and a place to describe
the key components of a response.
</p>
<p><code>response()</code> creates a generic response; <code>response_json()</code> creates a
response with a JSON body, automatically adding the correct Content-Type
header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(
  status_code = 200,
  url = "https://example.com",
  method = "GET",
  headers = list(),
  body = raw()
)

response_json(
  status_code = 200,
  url = "https://example.com",
  method = "GET",
  headers = list(),
  body = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="response_+3A_status_code">status_code</code></td>
<td>
<p>HTTP status code. Must be a single integer.</p>
</td></tr>
<tr><td><code id="response_+3A_url">url</code></td>
<td>
<p>URL response came from; might not be the same as the URL in
the request if there were any redirects.</p>
</td></tr>
<tr><td><code id="response_+3A_method">method</code></td>
<td>
<p>HTTP method used to retrieve the response.</p>
</td></tr>
<tr><td><code id="response_+3A_headers">headers</code></td>
<td>
<p>HTTP headers. Can be supplied as a raw or character vector
which will be parsed using the standard rules, or a named list.</p>
</td></tr>
<tr><td><code id="response_+3A_body">body</code></td>
<td>
<p>Response, if any, contained in the response body.
For <code>response_json()</code>, a R data structure to serialize to JSON.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An HTTP response: an S3 list with class <code>httr2_response</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>response()
response(404, method = "POST")
response(headers = c("Content-Type: text/html", "Content-Length: 300"))
</code></pre>

<hr>
<h2 id='resps_successes'>Tools for working with lists of responses</h2><span id='topic+resps_successes'></span><span id='topic+resps_failures'></span><span id='topic+resps_requests'></span><span id='topic+resps_data'></span>

<h3>Description</h3>

<p>These function provide a basic toolkit for operating with lists of
responses and possibly errors, as returned by <code><a href="#topic+req_perform_parallel">req_perform_parallel()</a></code>,
<code><a href="#topic+req_perform_sequential">req_perform_sequential()</a></code> and <code><a href="#topic+req_perform_iterative">req_perform_iterative()</a></code>.
</p>

<ul>
<li> <p><code>resps_successes()</code> returns a list successful responses.
</p>
</li>
<li> <p><code>resps_failures()</code> returns a list failed responses (i.e. errors).
</p>
</li>
<li> <p><code>resps_requests()</code> returns the list of requests that corresponds to
each request.
</p>
</li>
<li> <p><code>resps_data()</code> returns all the data in a single vector or data frame.
It requires the vctrs package to be installed.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>resps_successes(resps)

resps_failures(resps)

resps_requests(resps)

resps_data(resps, resp_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resps_successes_+3A_resps">resps</code></td>
<td>
<p>A list of responses (possibly including errors).</p>
</td></tr>
<tr><td><code id="resps_successes_+3A_resp_data">resp_data</code></td>
<td>
<p>A function that takes a response (<code>resp</code>) and
returns the data found inside that response as a vector or data frame.
</p>
<p>NB: If you're using <code><a href="#topic+resp_body_raw">resp_body_raw()</a></code>, you're likely to want to wrap its
output in <code>list()</code> to avoid combining all the bodies into a single raw
vector, e.g. <code style="white-space: pre;">&#8288;resps |&gt; resps_data(\(resp) list(resp_body_raw(resp)))&#8288;</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>reqs &lt;- list(
  request(example_url()) |&gt; req_url_path("/ip"),
  request(example_url()) |&gt; req_url_path("/user-agent"),
  request(example_url()) |&gt; req_template("/status/:status", status = 404),
  request("INVALID")
)
resps &lt;- req_perform_parallel(reqs, on_error = "continue")

# find successful responses
resps |&gt; resps_successes()

# collect all their data
resps |&gt;
  resps_successes() |&gt;
  resps_data(\(resp) resp_body_json(resp))

# find requests corresponding to failure responses
resps |&gt;
  resps_failures() |&gt;
  resps_requests()
</code></pre>

<hr>
<h2 id='secrets'>Secret management</h2><span id='topic+secret_make_key'></span><span id='topic+secret_encrypt'></span><span id='topic+secret_decrypt'></span><span id='topic+secret_write_rds'></span><span id='topic+secret_read_rds'></span><span id='topic+secret_decrypt_file'></span><span id='topic+secret_encrypt_file'></span><span id='topic+secret_has_key'></span>

<h3>Description</h3>

<p>httr2 provides a handful of functions designed for working with confidential
data. These are useful because testing packages that use httr2 often
requires some confidential data that needs to be available for testing,
but should not be available to package users.
</p>

<ul>
<li> <p><code>secret_encrypt()</code> and <code>secret_decrypt()</code> work with individual strings
</p>
</li>
<li> <p><code>secret_encrypt_file()</code> encrypts a file in place and
<code>secret_decrypt_file()</code> decrypts a file in a temporary location.
</p>
</li>
<li> <p><code>secret_write_rds()</code> and <code>secret_read_rds()</code> work with <code>.rds</code> files
</p>
</li>
<li> <p><code>secret_make_key()</code> generates a random string to use as a key.
</p>
</li>
<li> <p><code>secret_has_key()</code> returns <code>TRUE</code> if the key is available; you can
use it in examples and vignettes that you want to evaluate on your CI,
but not for CRAN/package users.
</p>
</li></ul>

<p>These all look for the key in an environment variable. When used inside of
testthat, they will automatically <code><a href="testthat.html#topic+skip">testthat::skip()</a></code> the test if the env var
isn't found. (Outside of testthat, they'll error if the env var isn't
found.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secret_make_key()

secret_encrypt(x, key)

secret_decrypt(encrypted, key)

secret_write_rds(x, path, key)

secret_read_rds(path, key)

secret_decrypt_file(path, key, envir = parent.frame())

secret_encrypt_file(path, key)

secret_has_key(key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secrets_+3A_x">x</code></td>
<td>
<p>Object to encrypt. Must be a string for <code>secret_encrypt()</code>.</p>
</td></tr>
<tr><td><code id="secrets_+3A_key">key</code></td>
<td>
<p>Encryption key; this is the password that allows you to &quot;lock&quot;
and &quot;unlock&quot; the secret. The easiest way to specify this is as the
name of an environment variable. Alternatively, if you already have
a base64url encoded string, you can wrap it in <code>I()</code>, or you can pass
the raw vector in directly.</p>
</td></tr>
<tr><td><code id="secrets_+3A_encrypted">encrypted</code></td>
<td>
<p>String to decrypt</p>
</td></tr>
<tr><td><code id="secrets_+3A_path">path</code></td>
<td>
<p>Path to file to encrypted file to read or write. For
<code>secret_write_rds()</code> and <code>secret_read_rds()</code> this should be an <code>.rds</code>
file.</p>
</td></tr>
<tr><td><code id="secrets_+3A_envir">envir</code></td>
<td>
<p>The decrypted file will be automatically deleted when
this environment exits. You should only need to set this argument if you
want to pass the unencrypted file to another function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>secret_decrypt()</code> and <code>secret_encrypt()</code> return strings.
</p>
</li>
<li> <p><code>secret_decrypt_file()</code> returns a path to a temporary file;
<code>secret_encrypt_file()</code> encrypts the file in place.
</p>
</li>
<li> <p><code>secret_write_rds()</code> returns <code>x</code> invisibly; <code>secret_read_rds()</code>
returns the saved object.
</p>
</li>
<li> <p><code>secret_make_key()</code> returns a string with class <code>AsIs</code>.
</p>
</li>
<li> <p><code>secret_has_key()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>Basic workflow</h3>


<ol>
<li><p> Use <code>secret_make_key()</code> to generate a password. Make this available
as an env var (e.g. <code style="white-space: pre;">&#8288;{MYPACKAGE}_KEY&#8288;</code>) by adding a line to your
<code>.Renviron</code>.
</p>
</li>
<li><p> Encrypt strings with <code>secret_encrypt()</code>, files with
<code>secret_encrypt_file()</code>, and other data with <code>secret_write_rds()</code>,
setting <code>key = "{MYPACKAGE}_KEY"</code>.
</p>
</li>
<li><p> In your tests, decrypt the data with <code>secret_decrypt()</code>,
<code>secret_decrypt_file()</code>, or <code>secret_read_rds()</code> to match how you encrypt
it.
</p>
</li>
<li><p> If you push this code to your CI server, it will already &quot;work&quot; because
all functions automatically skip tests when your <code style="white-space: pre;">&#8288;{MYPACKAGE}_KEY&#8288;</code>
env var isn't set. To make the tests actually run, you'll need to set
the env var using whatever tool your CI system provides for setting
env vars. Make sure to carefully inspect the test output to check that
the skips have actually gone away.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>key &lt;- secret_make_key()

path &lt;- tempfile()
secret_write_rds(mtcars, path, key = key)
secret_read_rds(path, key)

# While you can manage the key explicitly in a variable, it's much
# easier to store in an environment variable. In real life, you should
# NEVER use `Sys.setenv()` to create this env var because you will
# also store the secret in your `.Rhistory`. Instead add it to your
# .Renviron using `usethis::edit_r_environ()` or similar.
Sys.setenv("MY_KEY" = key)

x &lt;- secret_encrypt("This is a secret", "MY_KEY")
x
secret_decrypt(x, "MY_KEY")
</code></pre>

<hr>
<h2 id='signal_total_pages'>Signal total number pages</h2><span id='topic+signal_total_pages'></span>

<h3>Description</h3>

<p>To be called within a <code>next_req</code> callback function used with
<code><a href="#topic+req_perform_iterative">req_perform_iterative()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_total_pages(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signal_total_pages_+3A_n">n</code></td>
<td>
<p>Total number of pages.</p>
</td></tr>
</table>

<hr>
<h2 id='throttle_status'>Display internal throttle status</h2><span id='topic+throttle_status'></span>

<h3>Description</h3>

<p>Sometimes useful for debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>throttle_status()
</code></pre>


<h3>Value</h3>

<p>A data frame with three columns:
</p>

<ul>
<li><p> The <code>realm</code>.
</p>
</li>
<li><p> Number of <code>tokens</code> remaining in the bucket.
</p>
</li>
<li><p> Time <code>to_wait</code> in seconds for next token.
</p>
</li></ul>


<hr>
<h2 id='url_build'>Build a string from a URL object</h2><span id='topic+url_build'></span>

<h3>Description</h3>

<p>This is the inverse of <code><a href="#topic+url_parse">url_parse()</a></code>, taking a parsed URL object and
turning it back into a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_build(url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="url_build_+3A_url">url</code></td>
<td>
<p>An URL object created by <a href="#topic+url_parse">url_parse</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other URL manipulation: 
<code><a href="#topic+url_modify">url_modify</a>()</code>,
<code><a href="#topic+url_parse">url_parse</a>()</code>
</p>

<hr>
<h2 id='url_modify'>Modify a URL</h2><span id='topic+url_modify'></span><span id='topic+url_modify_relative'></span><span id='topic+url_modify_query'></span>

<h3>Description</h3>

<p>Use <code>url_modify()</code> to modify any component of the URL,
<code>url_modify_relative()</code> to modify with a relative URL,
or <code>url_modify_query()</code> to modify individual query parameters.
</p>
<p>For <code>url_modify()</code>, components that aren't specified in the
function call will be left as is; components set to <code>NULL</code> will be removed,
and all other values will be updated. Note that removing <code>scheme</code> or
<code>hostname</code> will create a relative URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_modify(
  url,
  scheme = as_is,
  hostname = as_is,
  username = as_is,
  password = as_is,
  port = as_is,
  path = as_is,
  query = as_is,
  fragment = as_is
)

url_modify_relative(url, relative_url)

url_modify_query(
  .url,
  ...,
  .multi = c("error", "comma", "pipe", "explode"),
  .space = c("percent", "form")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="url_modify_+3A_url">url</code>, <code id="url_modify_+3A_.url">.url</code></td>
<td>
<p>A string or <a href="#topic+url_parse">parsed URL</a>.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_scheme">scheme</code></td>
<td>
<p>The scheme, typically either <code>http</code> or <code>https</code>.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_hostname">hostname</code></td>
<td>
<p>The hostname, e.g., <code>www.google.com</code> or <code>posit.co</code>.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_username">username</code>, <code id="url_modify_+3A_password">password</code></td>
<td>
<p>Username and password to embed in the URL.
Not generally recommended but needed for some legacy applications.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_port">port</code></td>
<td>
<p>An integer port number.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_path">path</code></td>
<td>
<p>The path, e.g., <code style="white-space: pre;">&#8288;/search&#8288;</code>. Paths must start with <code>/</code>, so this
will be automatically added if omitted.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_query">query</code></td>
<td>
<p>Either a query string or a named list of query components.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_fragment">fragment</code></td>
<td>
<p>The fragment, e.g., <code style="white-space: pre;">&#8288;#section-1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_relative_url">relative_url</code></td>
<td>
<p>A relative URL to append to the base URL.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
Name-value pairs that define query parameters. Each value must be either
an atomic vector or <code>NULL</code> (which removes the corresponding parameters).
If you want to opt out of escaping, wrap strings in <code>I()</code>.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_.multi">.multi</code></td>
<td>
<p>Controls what happens when a value is a vector:
</p>

<ul>
<li> <p><code>"error"</code>, the default, throws an error.
</p>
</li>
<li> <p><code>"comma"</code>, separates values with a <code style="white-space: pre;">&#8288;,&#8288;</code>, e.g. <code style="white-space: pre;">&#8288;?x=1,2&#8288;</code>.
</p>
</li>
<li> <p><code>"pipe"</code>, separates values with a <code>|</code>, e.g. <code>?x=1|2</code>.
</p>
</li>
<li> <p><code>"explode"</code>, turns each element into its own parameter, e.g. <code>?x=1&amp;x=2</code>
</p>
</li></ul>

<p>If none of these options work for your needs, you can instead supply a
function that takes a character vector of argument values and returns a
a single string.</p>
</td></tr>
<tr><td><code id="url_modify_+3A_.space">.space</code></td>
<td>
<p>How should spaces in query params be escaped? The default,
&quot;percent&quot;, uses standard percent encoding (i.e. <code style="white-space: pre;">&#8288;%20&#8288;</code>), but you can opt-in
to &quot;form&quot; encoding, which uses <code>+</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>url</code>.
</p>


<h3>See Also</h3>

<p>Other URL manipulation: 
<code><a href="#topic+url_build">url_build</a>()</code>,
<code><a href="#topic+url_parse">url_parse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url_modify("http://hadley.nz", path = "about")
url_modify("http://hadley.nz", scheme = "https")
url_modify("http://hadley.nz/abc", path = "/cde")
url_modify("http://hadley.nz/abc", path = "")
url_modify("http://hadley.nz?a=1", query = "b=2")
url_modify("http://hadley.nz?a=1", query = list(c = 3))

url_modify_query("http://hadley.nz?a=1&amp;b=2", c = 3)
url_modify_query("http://hadley.nz?a=1&amp;b=2", b = NULL)
url_modify_query("http://hadley.nz?a=1&amp;b=2", a = 100)

url_modify_relative("http://hadley.nz/a/b/c.html", "/d.html")
url_modify_relative("http://hadley.nz/a/b/c.html", "d.html")
url_modify_relative("http://hadley.nz/a/b/c.html", "../d.html")
</code></pre>

<hr>
<h2 id='url_parse'>Parse a URL into its component pieces</h2><span id='topic+url_parse'></span>

<h3>Description</h3>

<p><code>url_parse()</code> parses a URL into its component parts, powered by
<code><a href="curl.html#topic+curl_parse_url">curl::curl_parse_url()</a></code>. The parsing algorithm follows the specifications
detailed in <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_parse(url, base_url = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="url_parse_+3A_url">url</code></td>
<td>
<p>A string containing the URL to parse.</p>
</td></tr>
<tr><td><code id="url_parse_+3A_base_url">base_url</code></td>
<td>
<p>Use this as a parent, if <code>url</code> is a relative URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>httr2_url</code> with the following components:
<code>scheme</code>, <code>hostname</code>, <code>username</code>, <code>password</code>, <code>port</code>, <code>path</code>, <code>query</code>, and
<code>fragment</code>.
</p>


<h3>See Also</h3>

<p>Other URL manipulation: 
<code><a href="#topic+url_build">url_build</a>()</code>,
<code><a href="#topic+url_modify">url_modify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url_parse("http://google.com/")
url_parse("http://google.com:80/")
url_parse("http://google.com:80/?a=1&amp;b=2")
url_parse("http://username@google.com:80/path;test?a=1&amp;b=2#40")

# You can parse a relative URL if you also provide a base url
url_parse("foo", "http://google.com/bar/")
url_parse("..", "http://google.com/bar/")
</code></pre>

<hr>
<h2 id='url_query_parse'>Parse query parameters and/or build a string</h2><span id='topic+url_query_parse'></span><span id='topic+url_query_build'></span>

<h3>Description</h3>

<p><code>url_query_parse()</code> parses a query string into a named list;
<code>url_query_build()</code> builds a query string from a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_query_parse(query)

url_query_build(query, .multi = c("error", "comma", "pipe", "explode"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="url_query_parse_+3A_query">query</code></td>
<td>
<p>A string, when parsing; a named list when building.</p>
</td></tr>
<tr><td><code id="url_query_parse_+3A_.multi">.multi</code></td>
<td>
<p>Controls what happens when a value is a vector:
</p>

<ul>
<li> <p><code>"error"</code>, the default, throws an error.
</p>
</li>
<li> <p><code>"comma"</code>, separates values with a <code style="white-space: pre;">&#8288;,&#8288;</code>, e.g. <code style="white-space: pre;">&#8288;?x=1,2&#8288;</code>.
</p>
</li>
<li> <p><code>"pipe"</code>, separates values with a <code>|</code>, e.g. <code>?x=1|2</code>.
</p>
</li>
<li> <p><code>"explode"</code>, turns each element into its own parameter, e.g. <code>?x=1&amp;x=2</code>
</p>
</li></ul>

<p>If none of these options work for your needs, you can instead supply a
function that takes a character vector of argument values and returns a
a single string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>str(url_query_parse("a=1&amp;b=2"))

url_query_build(list(x = 1, y = "z"))
url_query_build(list(x = 1, y = 1:2), .multi = "explode")
</code></pre>

<hr>
<h2 id='with_mocked_responses'>Temporarily mock requests</h2><span id='topic+with_mocked_responses'></span><span id='topic+with_mock'></span><span id='topic+local_mocked_responses'></span><span id='topic+local_mock'></span>

<h3>Description</h3>

<p>Mocking allows you to selectively and temporarily replace the response
you would typically receive from a request with your own code. It's
primarily used for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mocked_responses(mock, code)

local_mocked_responses(mock, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_mocked_responses_+3A_mock">mock</code></td>
<td>
<p>A function, a list, or <code>NULL</code>.
</p>

<ul>
<li> <p><code>NULL</code> disables mocking and returns httr2 to regular operation.
</p>
</li>
<li><p> A list of responses will be returned in sequence. After all responses
have been used up, will return 503 server errors.
</p>
</li>
<li><p> For maximum flexibility, you can supply a function that that takes a
single argument, <code>req</code>, and returns either <code>NULL</code> (if it doesn't want to
handle the request) or a <a href="#topic+response">response</a> (if it does).
</p>
</li></ul>
</td></tr>
<tr><td><code id="with_mocked_responses_+3A_code">code</code></td>
<td>
<p>Code to execute in the temporary environment.</p>
</td></tr>
<tr><td><code id="with_mocked_responses_+3A_env">env</code></td>
<td>
<p>Environment to use for scoping changes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>with_mock()</code> returns the result of evaluating <code>code</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function should perform a response against google.com:
google &lt;- function() {
  request("http://google.com") |&gt;
    req_perform()
}

# But I can use a mock to instead return my own made up response:
my_mock &lt;- function(req) {
  response(status_code = 403)
}
try(with_mock(my_mock, google()))
</code></pre>

<hr>
<h2 id='with_verbosity'>Temporarily set verbosity for all requests</h2><span id='topic+with_verbosity'></span><span id='topic+local_verbosity'></span>

<h3>Description</h3>

<p><code>with_verbosity()</code> and <code>local_verbosity()</code> are useful for debugging httr2
code buried deep inside another package, because they allow you to change
the verbosity even when you don't have access to the request.
</p>
<p>Both functions work by temporarily setting the <code>httr2_verbosity</code> option. You
can also control verbosity by setting the <code>HTTR2_VERBOSITY</code> environment
variable. This has lower precedence than the option, but can be more easily
changed outside of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_verbosity(code, verbosity = 1)

local_verbosity(verbosity, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_verbosity_+3A_code">code</code></td>
<td>
<p>Code to execture</p>
</td></tr>
<tr><td><code id="with_verbosity_+3A_verbosity">verbosity</code></td>
<td>
<p>How much information to print? This is a wrapper
around <code><a href="#topic+req_verbose">req_verbose()</a></code> that uses an integer to control verbosity:
</p>

<ul>
<li> <p><code>0</code>: no output
</p>
</li>
<li> <p><code>1</code>: show headers
</p>
</li>
<li> <p><code>2</code>: show headers and bodies
</p>
</li>
<li> <p><code>3</code>: show headers, bodies, and curl status messages.
</p>
</li></ul>

<p>Use <code><a href="#topic+with_verbosity">with_verbosity()</a></code> to control the verbosity of requests that
you can't affect directly.</p>
</td></tr>
<tr><td><code id="with_verbosity_+3A_env">env</code></td>
<td>
<p>Environment to use for scoping changes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>with_verbosity()</code> returns the result of evaluating <code>code</code>.
<code>local_verbosity()</code> is called for its side-effect and invisibly returns
the previous value of the option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- function() {
  request("https://httr2.r-lib.org") |&gt; req_perform()
}
with_verbosity(fun())

fun &lt;- function() {
  local_verbosity(2)
  # someotherpackage::fun()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
