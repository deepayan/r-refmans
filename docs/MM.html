<!DOCTYPE html><html><head><title>Help for package MM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MM-package'>
<p>The Multiplicative Multivariate distribution, and the Multivariate</p>
Multiplicative Binomial Distribution</a></li>
<li><a href='#danaher'><p>Dataset due to Danaher</p></a></li>
<li><a href='#Extract.paras'><p>Extract or Replace parameters of a <code>paras</code> object</p></a></li>
<li><a href='#gunter'>
<p>Convert from multiple multivariate observations to tabular form</p></a></li>
<li><a href='#Lindsey'>
<p>The Poisson device of Lindsey and Mersch (1992).</p></a></li>
<li><a href='#MB'><p>Multivariate multiplicative binomial distribution</p></a></li>
<li><a href='#MM'><p>Various multiplicative multinomial probability utilities</p></a></li>
<li><a href='#MM-internal'><p>Internal MM objects</p></a></li>
<li><a href='#multinomial'>
<p>Multinomial function</p></a></li>
<li><a href='#NormC'><p>Normalizing constant for the multiplicative multinomial</p></a></li>
<li><a href='#optimizer'><p>Maximum likelihood estimator for the MM</p></a></li>
<li><a href='#paras'><p>Manipulate a paras object</p></a></li>
<li><a href='#pollen'>
<p>Pollen data from Mosimann 1962</p></a></li>
<li><a href='#powell'>
<p>Dataset due to Powell (1990)</p></a></li>
<li><a href='#rMM'>
<p>Random samples from the multiplicative multinomial</p></a></li>
<li><a href='#skellam'>
<p>Brassica Dataset due to Catcheside</p></a></li>
<li><a href='#suffstats'>
<p>Sufficient statistics for the multiplicative multinomial</p></a></li>
<li><a href='#sweets'>
<p>Synthetic dataset due to Hankin</p></a></li>
<li><a href='#voting'>
<p>Synthetic dataset of voting behaviour due to Altham</p></a></li>
<li><a href='#wilson'>
<p>Housing Dataset due to Wilson</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Multiplicative Multinomial Distribution</td>
</tr>
<tr>
<td>Description:</td>
<td>Various utilities for the Multiplicative Multinomial distribution.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6-7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), Oarray (&ge; 1.4-6), partitions (&ge; 1.9-14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magic (&ge; 1.5-6), abind, emulator (&ge; 1.2-13), methods,
mathjaxr</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin and P. M. E. Altham</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/MM">https://github.com/RobinHankin/MM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/MM/issues">https://github.com/RobinHankin/MM/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 21:10:07 UTC; rhankin</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MM-package'>
The Multiplicative Multivariate distribution, and the Multivariate
Multiplicative Binomial Distribution
</h2><span id='topic+MM-package'></span>

<h3>Description</h3>

<p>Two generalizations of the Multiplicative Binomial distribution of
Altham (1978).
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Multiplicative Multinomial Distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Various utilities for the Multiplicative Multinomial distribution.</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10.0), Oarray (&gt;= 1.4-6), partitions (&gt;= 1.9-14)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> magic (&gt;= 1.5-6), abind, emulator (&gt;= 1.2-13), methods, mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin and P. M. E. Altham</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/MM</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/MM/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Lindsey                 The Poisson device of Lindsey and Mersch
                        (1992).
MB                      Multivariate multiplicative binomial
                        distribution
MM                      Various multiplicative multinomial probability
                        utilities
MM-package              The Multiplicative Multivariate distribution,
                        and the Multivariate Multiplicative Binomial
                        Distribution
NormC                   Normalizing constant for the multiplicative
                        multinomial
[.paras                 Extract or Replace parameters of a 'paras'
                        object
danaher                 Dataset due to Danaher
gunter                  Convert from multiple multivariate observations
                        to tabular form
multinomial             Multinomial function
optimizer               Maximum likelihood estimator for the MM
paras                   Manipulate a paras object
pollen                  Pollen data from Mosimann 1962
powell                  Dataset due to Powell (1990)
rMM                     Random samples from the multiplicative
                        multinomial
skellam                 Brassica Dataset due to Catcheside
suffstats               Sufficient statistics for the multiplicative
                        multinomial
sweets                  Synthetic dataset due to Hankin
voting                  Synthetic dataset of voting behaviour due to
                        Altham
wilson                  Housing Dataset due to Wilson
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin and P. M. E. Altham
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>P. M. E. Altham 1978.  &ldquo;Two Generalizations of the Binomial
Distribution&rdquo;.  <em>Applied Statistics</em> 27:162&ndash;167
</p>
<p>P. M. E. Altham and Robin K. S. Hankin 2012. &ldquo;Multivariate
Generalizations of the Multiplicative Binomial Distribution: Introducing
the MM Package&rdquo;, <em>Journal of Statistical Software</em>, 46(12),
1-23. <a href="https://doi.org/10.18637/jss.v046.i12">doi:10.18637/jss.v046.i12</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
Lindsey(voting, voting_tally)

jj &lt;- paras(3)
rMM(10,4,jj)

</code></pre>

<hr>
<h2 id='danaher'>Dataset due to Danaher</h2><span id='topic+danaher'></span>

<h3>Description</h3>

<p>Dataset due to Danaher; also an analysis <em>ab initio</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(danaher)</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>danaher</code> is a matrix (of class <code>Oarray</code>) that
represents Danaher and Hardie's Table 1 
</p>
</li></ul>



<h3>Details</h3>

<p>Since bacon is often <em>eaten</em> with eggs, it is reasonable to
expect that it is <em>purchased</em> with eggs.
</p>
<p>Danaher and Hardie use a dataset obtained from a sample of 548 households over
four consecutive store trips.  They considered only grocery shopping
trips with a total basket value of at least five dollars.  For each
household, they counted the total number of bacon purchases in their
four eligible shopping trips, and the total number of egg purchases
for the same trips.
</p>
<p>Object <code>danaher</code> is a five-by-five matrix of class <code>Oarray</code>
with entry <code class="reqn">(i,j)</code> indicating the number of shoppers buying bacon
on <code class="reqn">i</code> occasions and eggs on <code class="reqn">j</code> occasions (note the zero
offset).  Thus <code>danaher[1,2]=16</code> indicates that 16 shoppers
bought bacon on 1 occasion and eggs on 2 occasions.
</p>


<h3>References</h3>

<p>P. J. Danaher and B. G. S. Hardie 2005.  &ldquo;Bacon with your eggs?
Applications of a new bivariate beta-binomial distribution&rdquo;.
<em>The American Statistician</em>, 59(4):282
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimizer">optimizer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(danaher)
Lindsey_MB(danaher)

# Dataset from table 3 follows; see also the example at Lindsey.Rd
mags &lt;-
c(2463, 35, 44, 14, 16, 7, 262, 20, 2, 2, 0, 0, 0, 2, 17, 2,
0, 2, 0, 0, 3, 8, 0, 0, 1, 0, 0, 4, 8, 0, 1, 1, 0, 0, 3, 3,
0, 0, 0, 0, 0, 1, 52, 2, 1, 0, 2, 0, 22)
dim(mags) &lt;- c(7,7)
mags &lt;- as.Oarray(mags,offset=0)
dimnames(mags) &lt;- 
list(AA=as.character(0:6),Sig=as.character(0:6))  # messy kludge in Lindsey_MB()
summary(Lindsey_MB(mags))

</code></pre>

<hr>
<h2 id='Extract.paras'>Extract or Replace parameters of a <code>paras</code> object</h2><span id='topic++5B.paras'></span><span id='topic++5B+3C-.paras'></span><span id='topic++5B+2Cparas-method'></span><span id='topic++5B+3C-+2Cparas-method'></span><span id='topic+extract'></span>

<h3>Description</h3>

<p>Methods for <code>"["</code> and  <code>"[&lt;-"</code>, i.e., extraction or
subsetting of <code>paras</code> objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.paras_+3A_x">x</code></td>
<td>
<p>Object of class <code>paras</code></p>
</td></tr>
<tr><td><code id="Extract.paras_+3A_i">i</code></td>
<td>
<p>Elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.paras_+3A_value">value</code></td>
<td>
<p>Replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns an object of class <code>paras</code>.
</p>


<h3>Methods</h3>


<ul>
<li><p> x[i]
</p>
</li>
<li><p> x[i] &lt;- value
</p>
</li>
<li><p> x[i,j]
</p>
</li>
<li><p> x[i,j] &lt;- value
</p>
</li></ul>



<h3>Note</h3>

<p>These methods are included for completeness; it's not clear to me that
they are likely to be used by anyone.  It might be better to always
use constructions like <code>x &lt;- paras(4) ; p(x)[2] &lt;- 0.1</code> instead;
YMMV.    
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- paras(4)
x[2] &lt;- 0.1
x[1,2] &lt;- 0.12
x

</code></pre>

<hr>
<h2 id='gunter'>
Convert from multiple multivariate observations to tabular form
</h2><span id='topic+gunter'></span><span id='topic+print.gunter'></span><span id='topic+gunter+2CMB-method'></span><span id='topic+gunter+2COarray-method'></span><span id='topic+gunter+2Cdata.frame-method'></span><span id='topic+gunter+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Convert from a matrix with rows corresponding to multivariate
observations, to a tabular form listing every possible combination
together with the number of times that combination was observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gunter(obs)
## S3 method for class 'gunter'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gunter_+3A_obs">obs</code></td>
<td>

<p>Argument.  If a matrix, interpret each row as  a
multivariate observation (so the rowsums are constant).  If an
object of class <code>MB</code>, interpret appropriately; if an
<code>Oarray</code>, coerce to an <code>MB</code> object
</p>
</td></tr>
<tr><td><code id="gunter_+3A_x">x</code></td>
<td>
<p>Object of class <code>gunter</code> to be printed by the print method</p>
</td></tr>
<tr><td><code id="gunter_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For matrices and data frames, function <code>gunter()</code>
returns an object of class <code>gunter</code>: a list of two elments, the
first being a matrix (&lsquo;<code>obs</code>&rsquo;) with rows being possible
observations, and the second (&lsquo;<code>d</code>&rsquo;) a vector with one
entry for each row of matrix <code>obs</code>.
</p>
<p>For <code>MB</code> objects and <code>Oarray</code> objects, function
<code>gunter()</code> returns an object of class <code>gunter_MB</code>.
</p>
<p>The print method returns its argument, invisibly, after printing it
coerced to a list.
</p>


<h3>Author(s)</h3>

<p>Bert Gunter, with tiny alterations by Robin Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wilson)
gunter(non_met)

data(danaher)
gunter(danaher)  # object of class gunter_MB

</code></pre>

<hr>
<h2 id='Lindsey'>
The Poisson device of Lindsey and Mersch (1992).
</h2><span id='topic+Lindsey'></span><span id='topic+Lindsey_MB'></span><span id='topic+print.Lindsey_output'></span><span id='topic+bioChemists'></span>

<h3>Description</h3>

<p>Function <code>Lindsey()</code> returns a maximum likelihood fit of the
multiplicative multinomial using the Poisson device of Lindsey and
Mersch (1992), and in the context of the multiplicative multinomial by
Altham and Lindsey (1998).
</p>
<p>Function <code>Lindsey_MB()</code> returns a maximum likelihood fit for the
multivariate multiplicative binomial, for the special case of a
bivariate distribution.  An example of coercing a table to the correct
form for use with <code>Lindsey_MB()</code> is given in the examples section
below.  Also, see <code>danaher</code> for another example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lindsey(obs, n = NULL, give_fit = FALSE)
Lindsey_MB(a)
## S3 method for class 'Lindsey_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lindsey_+3A_obs">obs</code></td>
<td>

<p>In <code>Lindsey()</code>, an integer matrix with each row corresponding to
an observation.  All row sums must match</p>
</td></tr>
<tr><td><code id="Lindsey_+3A_n">n</code></td>
<td>

<p>Vector with elements corresponding to the rows of <code>obs</code>;
default of <code>NULL</code> corresponds to observing each row of
<code>obs</code> once</p>
</td></tr>
<tr><td><code id="Lindsey_+3A_a">a</code></td>
<td>

<p>In <code>Lindsey_MB()</code>, an object that is coerced to one of class
<code>gunter_MB</code>.  Typically, the user supplies an <code>Oarray</code>
object or an <code>MB</code> object</p>
</td></tr>
<tr><td><code id="Lindsey_+3A_give_fit">give_fit</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return
just the fit, coerced to an object of class <code>paras</code> and
<code>TRUE</code> meaning to return a list with two elements, the first
being a <code>paras</code> object and the second being the fit returned by
<code>glm()</code>
</p>
</td></tr>
<tr><td><code id="Lindsey_+3A_x">x</code></td>
<td>
<p>In the print method, object of class <code>Lindsey_output</code></p>
</td></tr>
<tr><td><code id="Lindsey_+3A_...">...</code></td>
<td>
<p>In the print method, further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the device first described by Lindsey in 1992; the &lsquo;meat&rsquo;
of which has <span class="rlang"><b>R</b></span> idiom
</p>
<p><code>Off &lt;- -rowSums(lfactorial(jj$tbl))</code>
</p>
<p><code>glm(jj$d ~ -1 + offset(Off) + (.)^2, data=data, family=poisson)</code>
</p>
<p>Function <code>Lindsey(..., give_fit=TRUE)</code> returns an object of class
<code>Lindsey_output</code>, which has its own print method (which 
prints the summary of the fit rather than use the default method).
</p>
<p>Function <code>Lindsey(..., give_fit=FALSE)</code> returns an object of
class <code>paras</code>, which can then be passed on to functions such as
<code>rMM()</code>, which take a <code>paras</code> object.
</p>
<p>Function <code>Lindsey_MB()</code> returns an object of class <code>glm</code>.
</p>


<h3>Author(s)</h3>

<p>P. M. E. Altham and Robin  K. S. Hankin
</p>


<h3>References</h3>


<ul>
<li>
<p>J. K. Lindsey and G. Mersch 1992. &ldquo;Fitting and comparing
probability distributions with log linear models&rdquo;, <em>Computational
Statistics and Data Analysis</em>, 13(4):373&ndash;384
</p>
</li>
<li><p> P. M. E. Altham and J. K. Lindsey, 1998.  &ldquo;Analysis of the
human sex ratio using overdispersion models&rdquo;, <em>Applied
Statistics</em>, 47:149&ndash;157
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gunter">gunter</a></code>,  <code><a href="#topic+danaher">danaher</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
(o &lt;- Lindsey(voting, voting_tally))
rMM(10,5,o)

data(danaher)
Lindsey_MB(danaher)

## Not run:   #(takes a long time)
data(pollen)
Lindsey(pollen)

## End(Not run)

# Example of Lindsey_MB() in use follows.
 
a &lt;- matrix(c(63,40,26,7,69,42,19,5,48,21,16,2,33,11,9,1,21,8,9,0,
    7,8,1,0,5,3,1,0,9,2,0,0),byrow=TRUE,ncol=4)

# Alternatively, you can get this from the pscl package as follows:
# library(pscl); data(bioChemists)
# a &lt;- table(subset(bioChemists, fem == 'Men' &amp; art &lt; 8))

dimnames(a) &lt;- list(papers=0:7,children=0:3)
require(Oarray)
a &lt;- as.Oarray(a,offset=0)
# thus a[3,1]==11 means that 11 subjects had 3 papers and 1 child

summary(Lindsey_MB(a))
</code></pre>

<hr>
<h2 id='MB'>Multivariate multiplicative binomial distribution</h2><span id='topic+MB'></span><span id='topic+MB-class'></span><span id='topic+as.array.MB'></span><span id='topic+as.array.gunter_MB'></span><span id='topic+print.gunter_MB'></span><span id='topic+counts+2CMB-method'></span><span id='topic+counts'></span><span id='topic+getM+2CMB-method'></span><span id='topic+getM'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Various utilities to coerce and manipulate <code>MB</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB(dep, m, pnames=character(0))
## S3 method for class 'MB'
as.array(x, ...)
## S4 method for signature 'MB'
getM(x)
## S3 method for class 'gunter_MB'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MB_+3A_dep">dep</code></td>
<td>

<p>Primary argument to <code>MB()</code>.  Typically a matrix with each row
being an observation (see &lsquo;details&rsquo; section below for an
example).  If an object of class <code>Oarray</code>, function <code>MB()</code>
coerces to an <code>MB</code> object
</p>
</td></tr>
<tr><td><code id="MB_+3A_m">m</code></td>
<td>

<p>Vector containing the relative sizes of the various marginal
binomial distributions
</p>
</td></tr>
<tr><td><code id="MB_+3A_x">x</code></td>
<td>

<p>Object of class <code>MB</code> to be converted to an <code>Oarray</code> object
</p>
</td></tr>
<tr><td><code id="MB_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>as.array()</code>, currently ignored
</p>
</td></tr>
<tr><td><code id="MB_+3A_pnames">pnames</code></td>
<td>
<p>In function <code>MB()</code>, a character vector of
names for the entries
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>MB()</code> returns an object of class <code>MB</code>.  This is
essentially a matrix with one row corresponding to a single
observation; repeated rows indicate identical observations as shown
below.  Observational data is typically in this form.  The idea is
that the user can coerce to a <code>gunter_MB</code> object, which is then
analyzable by <code>Lindsey()</code>.
</p>
<p>The multivariate multiplicative binomial distribution is defined by
\[
    \prod_{i=1}^t
    {m_i\choose x_i\, z_i}p_i^{x_i}q_i^{z_i}\theta_i^{x_iz_i}
    \prod_{i < j}\phi_{ij}^{x_ix_j}
  \]
</p>
<p>Thus if \(\theta=\phi=1\) the system reduces to a product of
independent binomial distributions with probability \(p_i\) and size
\(m_i\) for \(i=1,\ldots,t\).
</p>
<p>There follows a short <span class="rlang"><b>R</b></span> transcript showing the <code>MB</code> class in use,
with annotation.
</p>
<p>The first step is to define an <code>m</code> vector:
</p>
<pre>
R&gt; m &lt;- c(2,3,1)
 </pre>
<p>This means that \(m_1=2,m_2=3,m_3=1\).  So
\(m_1=2\) means that \(i=1\) corresponds to a binomial
distribution with size 2 [that is, the observation is in the set
\({0,1,2}\)]; and \(m_2=3\) means that \(i=2\)
corresponds to a binomial with size 3 [ie the set
\({0,1,2,3}\)].
</p>
<p>Now we need some observations:
</p>
<pre>
R&gt; a &lt;- matrix(c(1,0,0, 1,0,0, 1,1,1, 2,3,1, 2,0,1),5,3,byrow=T)
R&gt; a
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    1    0    0
[3,]    1    1    1
[4,]    2    3    1
[5,]    2    0    1 
</pre>
<p>In matrix <code>a</code>, the first observation, viz <code>c(1,0,0)</code> is
interpreted as \(x_1=1,x_2=0,x_3=0\).  Thus, because
\(x_i+z_i=m_i\), we have \(z_1=1,z_2=3,z_3=1\).  Now
we can create an object of class <code>MB</code>, using function <code>MB()</code>:
</p>
<pre>
R&gt;  mx &lt;- MB(a, m, letters[1:3])   
</pre>
<p>The third argument gives names to the observations corresponding to the
columns of <code>a</code>.   The values of \(m_1, m_2, m_3\) may
be extracted using <code>getM()</code>:
</p>
<pre>
R&gt; getM(mx)
a b c 
2 3 1 
R&gt; 
</pre>
<p>The <code>getM()</code> function returns a named vector, with names
given as the third argument to <code>MB()</code>.
</p>
<p>Now we illustrate the print method:
</p>
<pre>
R&gt; mx
     a na     b nb     c nc    
[1,] 1 1      0 3      0 1     
[2,] 1 1      0 3      0 1     
[3,] 1 1      1 2      1 0     
[4,] 2 0      3 0      1 0     
[5,] 2 0      0 3      1 0     
R&gt; 
</pre>
<p>See how the columns are in pairs: the first pair total 2 (because
\(m_1=2\)), the second pair total 3 (because \(m_2=3\)),
and the third pair total 1 (because \(m_3=1\)).  Each pair of
columns has only a single degree of freedom, because \(m_i\) is known.
</p>
<p>Also observe how the column names are in pairs.  The print method puts
these in place.  Take the first two columns.  These are named
&lsquo;<code>a</code>&rsquo; and &lsquo;<code>na</code>&rsquo;: this is intented to mean
&lsquo;<code>a</code>&rsquo; and &lsquo;not <code>a</code>&rsquo;.
</p>
<p>We can now coerce to a <code>gunter_MB</code>:
</p>
<pre>
R&gt; (gx &lt;- gunter(mx))
$tbl
   a b c
1  0 0 0
2  1 0 0
3  2 0 0
[snip]
24 2 3 1

$d
 [1] 0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1

$m
a b c 
2 3 1 
</pre>
<p>Take the second line of the element <code>tbl</code> of <code>gx</code>, as an
example.  This reads <code>c(1,0,0)</code> corresponding to the observations
of <code>a,b,c</code> respectively, and the second line of element <code>d</code>
[&ldquo;<code>d</code>&rdquo; for &ldquo;data&rdquo;], viz 2, shows that this
observation occurred twice (and in fact these were the first two lines
of <code>a</code>).
</p>
<p>Now we can coerce object <code>mx</code> to an array:
</p>
<pre>
R&gt; (ax &lt;- as.array(mx))
, , c = 0

   b
a   0 1 2 3
  0 0 0 0 0
  1 0 0 2 0
  2 0 0 0 0

, , c = 1

   b
a   0 1 2 3
  0 0 1 0 0
  1 0 0 0 0
  2 1 1 0 0
&gt;
</pre>
<p>(actually, <code>ax</code> is an <code>Oarray</code> object).  The location of an
element in <code>ax</code> corresponds to an observation of <code>abc</code>, and
the entry corresponds to the number of times that observation was made.
For example, <code>ax[1,2,0]=2</code> shows that <code>c(1,2,0)</code> occurred
twice (the first two lines of <code>a</code>).
</p>
<p>The Lindsey Poisson device is applicable: see <code>help(danaher)</code> for
an application to the bivariate case and <code>help(Lindsey)</code> for an
example where a table is created from scratch.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MM">MM</a></code>, <code><a href="#topic+Lindsey">Lindsey</a></code>, <code><a href="#topic+danaher">danaher</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- matrix(c(1,0,0, 1,0,0, 1,1,1, 2,3,1, 2,0,1),5,3,byrow=TRUE)
m &lt;- c(2,3,1)
mx &lt;- MB(a, m, letters[1:3])   # mx is of class 'MB'; column headings
                   #  mean "a" and "not a".
ax &lt;- as.array(mx)
gx &lt;- gunter(ax)
ax2 &lt;- as.array(gx)

data(danaher)
summary(Lindsey_MB(danaher))

</code></pre>

<hr>
<h2 id='MM'>Various multiplicative multinomial probability utilities</h2><span id='topic+MM'></span><span id='topic+MM_allsamesum'></span><span id='topic+MM_differsums'></span><span id='topic+MM_allsamesum_A'></span><span id='topic+MM_differsums_A'></span><span id='topic+MM_single'></span><span id='topic+MM_support'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Various multiplicative multinomial probability utilities for different
types of observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MM(y,n=NULL,paras)
MM_allsamesum(y, n=NULL, paras)
MM_differsums(y, n=NULL, paras)
MM_allsamesum_A(y, paras)
MM_differsums_A(y, paras)
MM_single(yrow, paras, givelog=FALSE)
MM_support(paras, ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MM_+3A_y">y</code></td>
<td>
<p>Observations: a matrix, each row is a single observation</p>
</td></tr>
<tr><td><code id="MM_+3A_yrow">yrow</code></td>
<td>
<p>A single observation corresponding to one row of
matrix <code>y</code></p>
</td></tr>
<tr><td><code id="MM_+3A_n">n</code></td>
<td>
<p>Integer vector with one element for each row of <code>y</code>.
Default value of <code>NULL</code> means to interpret each row of <code>y</code>
as being observed once</p>
</td></tr>
<tr><td><code id="MM_+3A_ss">ss</code></td>
<td>
<p>Sufficient statistics, as returned by <code>suffstats()</code></p>
</td></tr>
<tr><td><code id="MM_+3A_givelog">givelog</code></td>
<td>
<p>Boolean in <code>MM_single()</code> with <code>TRUE</code> meaning
to return the log likelihood and default <code>FALSE</code> meaning to
return the likelihood</p>
</td></tr>
<tr><td><code id="MM_+3A_paras">paras</code></td>
<td>
<p>Object of class <code>paras</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider non-negative integers \(y_1,\ldots,y_k\) with
\(\sum y_i=y\).  Then suppose the frequency function
of the distribution \(Y_1,\ldots,Y_k\) is
</p>
\[C\cdot{y\choose y_1,\ldots,y_k}
    \prod_{i=1}^k p_i^{y_i}
    \prod_{1\leq i < j\leq k}{\theta_{ij}}^{y_iy_j}
    \]
<p>where \(p_i,\ldots,p_k\geq 0\), \(\sum
      p_i=1\) correspond to probabilities; and
\(\theta_{ij} > 0\) for \(1\leq i < j\leq k\) are additional parameters.
</p>
<p>Here \(C\) stands for a normalization constant:
</p>
\[C=C(p,\theta,Y)=
      \sum_{y_1 + \cdots + y_k=y}
    \prod_{i=1}^k p_i^{y_i}
    \prod_{1\leq i < j\leq k}{\theta_{ij}}^{y_iy_j}
    \]
<p>which is evaluated numerically.  This is computationally expensive.
</p>
<p>The usual case is to use function <code>MM()</code>.
</p>

<ul>
<li><p> Function <code>MM()</code> returns the log of the probability of a
matrix of rows of independent multinomial observations.  It is a
wrapper for <code>MM_allsamesum()</code> and
<code>MM_differsums()</code>.  Recall that optional argument <code>n</code>
specifies the number of times that each row is observed.  Calls
<code>NormC()</code>. 
</p>
</li>
<li><p> Function <code>MM_allsamesum()</code> gives the log of the
probability of observing a matrix where the rowsums are identical.
Calls <code>NormC()</code>. 
</p>
</li>
<li><p> Function <code>MM_differsums()</code> gives the log of the
probability of observing a matrix where the rowsums are not
necessarily identical.  <strong>Warning:</strong> This function takes a long
time to run.  Calls <code>NormC()</code>, possibly many times.
</p>
</li>
<li><p> Functions <code>MM_allsamesum_A()</code> and
<code>MM_differsums_A()</code> are analogous to functions
<code>MM_allsamesum()</code> and <code>MM_differsums()</code> but interpret the
matrix <code>y</code> as having rows corresponding to observations; each row
is observed once, as in <code>data(pollen)</code>. Both call <code>NormC()</code>. 
</p>
</li>
<li><p> Function <code>MM_single()</code> gives a likelihood function for a
<code>paras</code> object with a single multinomial observation (that is,
a single line of matrix <code>y</code>).  Does not call <code>NormC()</code>. 
</p>
</li>
<li><p> Function <code>MM_support()</code> gives the support (that is, the
log-likelihood) of a <code>paras</code> object; argument <code>ss</code> is the
sufficient statistic, as returned by <code>suffstats()</code>.  Does not
call <code>NormC()</code>. 
</p>
</li>
<li><p> Function <code>dMM()</code> [documented more fully at <code>rMM.Rd</code>]
gives the probability of a single multivariate observation (ie a
single row of the matrix argument <code>y</code>).  Calls <code>NormC()</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)

data(voting)
p &lt;- Lindsey(voting, voting_tally)

MM(voting,voting_tally,p)   #No other value of 'p' gives a bigger value


</code></pre>

<hr>
<h2 id='MM-internal'>Internal MM objects</h2><span id='topic+.fun'></span><span id='topic+.paras_print'></span><span id='topic+.paras_valid'></span><span id='topic+.required'></span>

<h3>Description</h3>

<p>Internal MM objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='multinomial'>
Multinomial function
</h2><span id='topic+multinomial'></span><span id='topic+lmultinomial'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The multinomial function and its logarithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial(x)
lmultinomial(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomial_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>multinomial()</code> returns
</p>
\[{n\choose n_1,n_2,\ldots,n_k} = \frac{n!}{n_1!n_2!\cdots
    n_k!}\]
<p>where \(\sum_i n_i=n\), and function
<code>lmultinomial()</code> returns the natural logarithm of this.
</p>


<h3>Note</h3>

<p>Uses logarithmic functions to avoid overflow.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10)

exp(lmultinomial(x)) - multinomial(x) #should be small 
</code></pre>

<hr>
<h2 id='NormC'>Normalizing constant for the multiplicative multinomial</h2><span id='topic+NormC'></span>

<h3>Description</h3>

<p>Calculates the normalizing constant for the multiplicative
multinomial using direct numerical summation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormC(Y, paras, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormC_+3A_y">Y</code></td>
<td>

<p>Total number of observations
</p>
</td></tr>
<tr><td><code id="NormC_+3A_paras">paras</code></td>
<td>

<p>Object of class <code>paras</code>
</p>
</td></tr>
<tr><td><code id="NormC_+3A_log">log</code></td>
<td>

<p>Boolean, with default <code>FALSE</code> meaning to return the value, and
<code>TRUE</code> meaning to return the natural logarithm
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jj &lt;- paras(3)
theta(jj) &lt;- 2
NormC(5,jj)

</code></pre>

<hr>
<h2 id='optimizer'>Maximum likelihood estimator for the MM</h2><span id='topic+optimizer'></span><span id='topic+optimizer_allsamesum'></span><span id='topic+optimizer_differsums'></span>

<h3>Description</h3>

<p>Maximum likelihood estimator for the MM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizer(y, n = NULL, start = NULL, method = "nlm",
            printing = FALSE, give_fit=FALSE, ...)
optimizer_allsamesum(y, n = NULL, start = NULL, method = "nlm",
            printing = FALSE, give_fit=FALSE, ...)
optimizer_differsums(y, n = NULL, start = NULL, method = "nlm",
            printing = FALSE, give_fit=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizer_+3A_y">y</code></td>
<td>

<p>Matrix with each row being a possible observation
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_n">n</code></td>
<td>

<p>Counts of observations corresponding to rows of <code>y</code>
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_start">start</code></td>
<td>

<p>Start value for optimization routine, taken to be an object of class
<code>paras</code>.  Default value of <code>NULL</code> means to start with
<code>Lindsey(y,n)</code>, which theoretically should be the maximum
likelihood estimate
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_method">method</code></td>
<td>
<p>String giving which optimization method to use.  Default
of <code>Nelder</code> means to use  <code>optim()</code> with the Nelder-Mead
method; the other supported option is <code>nlm</code>
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_printing">printing</code></td>
<td>

<p>Boolean, with <code>TRUE</code> meaning to print information as the
optimization progresses and default <code>FALSE</code> meaning to print
nothing
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_give_fit">give_fit</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return
the maximum likelihood estimate in the form of a <code>paras</code>
object, and <code>TRUE</code> meaning to return a two-element list, the
first being the output of <code>nlm()</code> or <code>optim()</code> and the
second being the MLE
</p>
</td></tr>
<tr><td><code id="optimizer_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the optimization routine.  In
particular,  note that <code>hessian=TRUE</code> is useful in conjunction
with <code>give_fit=TRUE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>optimizer()</code> is the user-friendly version: it is a wrapper for
<code>optimizer_samesum()</code> and <code>optimizer_differsums()</code>; it
dispatches according to whether the rowsums are identical or not.
</p>
<p>These functions are slow because they need to evaluate <code>NormC()</code>
repeatedly, which is expensive.
</p>
<p>Function <code>optimizer_samesum()</code> nominally produces the same output
as <code>Lindsey()</code>, but is more computationally intensive.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lindsey">Lindsey</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
p1 &lt;- Lindsey(voting,voting_tally)
p2 &lt;- optimizer(voting,voting_tally,start=p1)

theta(p1) - theta(p2)   # Should be zero

## Not run: 
data(pollen)
p1 &lt;- optimizer(pollen)
p2 &lt;- Lindsey(pollen)
theta(p1) - theta(p2)   #  Isn't zero...numerical scruff...

## End(Not run)

</code></pre>

<hr>
<h2 id='paras'>Manipulate a paras object</h2><span id='topic+paras'></span><span id='topic+paras-class'></span><span id='topic+p'></span><span id='topic+p+2Cparas-method'></span><span id='topic+p+3C-'></span><span id='topic+p+3C-+2Cparas-method'></span><span id='topic+theta'></span><span id='topic+theta+3C-'></span><span id='topic+theta+2Cparas-method'></span><span id='topic+theta+3C-+2Cparas-method'></span><span id='topic+pnames'></span><span id='topic+pnames+2Cparas-method'></span><span id='topic+pnames+2CMB-method'></span><span id='topic+pnames+3C-'></span><span id='topic+pnames+3C-+2Cparas-method'></span><span id='topic+pnames+3C-+2CMB-method'></span><span id='topic+getVals'></span><span id='topic+getVals+2Cparas-method'></span><span id='topic+length+2Cparas-method'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Various utilities to manipulate <code>paras</code> objects.  Functions
<code>pnames()</code> and <code>pnames&lt;-()</code> operate on <code>MB</code> objects as
expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paras(x, p, theta, pnames = character(0))
p(x) &lt;- value
theta(x) &lt;- value
p(x)
theta(x)
pnames(x)
pnames(x) &lt;- value
getVals(x)
## S4 method for signature 'paras'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paras_+3A_x">x</code></td>
<td>

<p>Object of class <code>paras</code>
</p>
</td></tr>
<tr><td><code id="paras_+3A_p">p</code></td>
<td>

<p>In function <code>paras()</code>, a vector of the first \(k-1\)
elements of the probabilities
</p>
</td></tr>
<tr><td><code id="paras_+3A_theta">theta</code></td>
<td>

<p>In function <code>paras()</code>, a \(k\) by \(k\) matrix with
diagonal composed of ones
</p>
</td></tr>
<tr><td><code id="paras_+3A_pnames">pnames</code></td>
<td>
<p>In function <code>paras()</code>, a character vector of
names for the entries
</p>
</td></tr>
<tr><td><code id="paras_+3A_value">value</code></td>
<td>
<p>Replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>paras</code> object contains the parameters needed to specify a
multiplicative multinomial distribution.
</p>
<p>Suppose <code>p</code> is an object of class <code>paras</code> object.  Then
<code>p</code> is a list of two elements.  The first element, <code>p</code>, is a
vector of length <code>length(p)</code> and the second is an upper-diagonal
matrix square matrix of size <code>length(p)</code>.  The vignette gives
further details.
</p>
<p>The functions documented here allow the user to inspect and change
<code>paras</code> objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MM">MM</a></code>, <code><a href="#topic+MB">MB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jj &lt;- paras(5)
pnames(jj) &lt;- letters[1:5]
p(jj) &lt;- c(0.1, 0.1, 0.3, 0.1)
theta(jj) &lt;- matrix(1:25,5,5)
pnames(jj) &lt;- letters[1:5]
jj

# OK, we've defined jj, now use it with some other functions:
dMM(rep(1,5),jj)
MM_single(1:5,jj)
rMM(2,9,jj)

</code></pre>

<hr>
<h2 id='pollen'>
Pollen data from Mosimann 1962
</h2><span id='topic+pollen'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Data from Mosimann 1962 detailing forest pollen counts 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pollen)</code></pre>


<h3>Format</h3>

<p>A matrix with four columns and 76 rows.
</p>


<h3>Details</h3>

<p>The rows each sum to 100; the values are counts of four different
types of pollen.  Each row corresponds to a different level in the
core; the levels are in sequence with the first row being most
recent and the last row being the oldest.
</p>


<h3>References</h3>

<p>J. E. Mosimann 1962.  &ldquo;On the compound multinomial distribution,
the multivariate \(\beta\)-distribution, and correlations
among proportions&rdquo;.  <em>Biometrika</em>, volume 49, numbers 1 and 2,
pp65-82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(pollen)
Lindsey(pollen)

## End(Not run)

</code></pre>

<hr>
<h2 id='powell'>
Dataset due to Powell (1990)
</h2><span id='topic+powell'></span><span id='topic+Powell'></span><span id='topic+powell_counts'></span>

<h3>Description</h3>

<p>Dataset due to Powell (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(powell)</code></pre>


<h3>Format</h3>

<p>A frequency table of counts of association data.
</p>


<h3>Source</h3>


<ul>
<li><p> W. Powell, M. Coleman and J. McNicol 1990  &ldquo;The
statistical analysis of potato culture data&rdquo;.
<em>Plant Cell, Tissue and Organ Culture</em> 23:159-164
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(powell)
Lindsey(powell, powell_counts)
</code></pre>

<hr>
<h2 id='rMM'>
Random samples from the multiplicative multinomial
</h2><span id='topic+rMM'></span><span id='topic+dMM'></span>

<h3>Description</h3>

<p>Density, and random samples drawn from, the 
multiplicative multinomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMM(n, Y, paras, burnin = 4*Y, every = 4*Y, start = NULL)
dMM(Y, paras)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMM_+3A_n">n</code></td>
<td>
<p>Number of observations to make
</p>
</td></tr>
<tr><td><code id="rMM_+3A_y">Y</code></td>
<td>

<p>Sum of each observation (for example, 100 for the <code>pollen</code> dataset,
4 for <code>voting</code>)
</p>
</td></tr>
<tr><td><code id="rMM_+3A_paras">paras</code></td>
<td>

<p>Parameters of the MM distribution; an object of class <code>paras</code>
</p>
</td></tr>
<tr><td><code id="rMM_+3A_every">every</code></td>
<td>

<p>Each row is recorded every <code>every</code> steps through the Markov
chain.  Thus <code>every=10</code> means every tenth row is written to the
returned matrix during  MH process (and the other nine
values are discarded)
</p>
</td></tr>
<tr><td><code id="rMM_+3A_burnin">burnin</code></td>
<td>
  
<p>Number of initial observations to ignore
</p>
</td></tr>
<tr><td><code id="rMM_+3A_start">start</code></td>
<td>

<p>Observation to start simulation, with default <code>NULL</code>
corresponding to using a random start vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rMM()</code> uses standard Metropolis-Hastings simulation.
</p>
<p>Function <code>dMM()</code> is documented here for convenience; see
<code>help(MM)</code> for related functionality.
</p>


<h3>Value</h3>

<p>Returns a matrix with <code>n</code> rows and <code>length(paras)</code> columns.
Each row is an observation.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MM">MM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
rMM(10,4,Lindsey(voting,voting_tally))

p &lt;- paras(3)
theta(p) &lt;- 2
dMM(1:3,p)

</code></pre>

<hr>
<h2 id='skellam'>
Brassica Dataset due to Catcheside
</h2><span id='topic+skellam'></span><span id='topic+Skellam'></span><span id='topic+skellam_counts'></span><span id='topic+Catcheside'></span><span id='topic+catcheside'></span>

<h3>Description</h3>

<p>Dataset due to Catcheside, used by Skellam (1948) and subsequently by
Altham (1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(skellam)</code></pre>


<h3>Format</h3>

<p>A frequency table of counts of association data.
</p>


<h3>Source</h3>


<ul>
<li><p> J. G. Skellam 1948.  &ldquo;A probability distribution
derived from the binomial distribution by regarding the
probability of success as variable between the sets of trials&rdquo;.
<em>Journal of the Royal Statistical Society, series B
(Methodological)</em>.  Volume 10, number 2, pp257-248.
</p>
</li>
<li><p> D. Catcheside 1937.  Cytologia, Fujii Jub. Vol.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(skellam)
Lindsey(skellam, skellam_counts)

</code></pre>

<hr>
<h2 id='suffstats'>
Sufficient statistics for the multiplicative multinomial
</h2><span id='topic+suffstats'></span><span id='topic+expected_suffstats'></span><span id='topic+print.suffstats'></span><span id='topic+summary.suffstats'></span><span id='topic+print.summary.suffstats'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Calculate, manipulate, and display sufficient statistics of the
multiplicative multinomial.  Functionality for analysing datasets, and
distributions specified by their parameters is given; summary and
print methods are also documented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suffstats(y, n = NULL)
expected_suffstats(L,Y)
## S3 method for class 'suffstats'
print(x, ...)
## S3 method for class 'suffstats'
summary(object, ...)
## S3 method for class 'summary.suffstats'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suffstats_+3A_y">y</code>, <code id="suffstats_+3A_n">n</code></td>
<td>
<p>In function <code>suffstats()</code>, argument <code>y</code> is a
matrix with each row being a possible observation and <code>n</code> is
counts of observations corresponding to rows of <code>y</code> with
default <code>NULL</code> interpreted as each row of <code>y</code> being
observed once.  If <code>y</code> is an object of class <code>gunter</code>,
this is interpreted sensibly</p>
</td></tr>
<tr><td><code id="suffstats_+3A_l">L</code>, <code id="suffstats_+3A_y">Y</code></td>
<td>
<p>In function <code>expected_suffstats()</code>, argument <code>L</code>
is an object of class <code>Lindsey</code> [typically returned by function
<code>Lindsey()</code>], and <code>Y</code> is the known constant sum (ie the
<code>rowSums()</code> of the observations)</p>
</td></tr>
<tr><td><code id="suffstats_+3A_x">x</code>, <code id="suffstats_+3A_object">object</code></td>
<td>
<p>An object of class <code>suffstats</code> or
<code>summary.suffstats</code>, to be printed or summarized</p>
</td></tr>
<tr><td><code id="suffstats_+3A_...">...</code></td>
<td>
<p>Further arguments to the print or summary methods.
Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>suffstats()</code> returns a list comprising a set of
sufficient statistics for the observations <code>y,[n]</code>.
</p>
<p>This function requires that the rowsums of <code>y</code> are all
identical.
</p>


<h3>Value</h3>

<p>Function <code>suffstats()</code> returns a list of four components:
</p>

<dl>
<dt>Y</dt><dd><p>Rowsums of <code>y</code></p>
</dd>
<dt>nobs</dt><dd><p>Number of observations</p>
</dd>
<dt>row_sums</dt><dd><p>Column sums of <code>y</code>, counted with multiplicity</p>
</dd>
<dt>cross_prods</dt><dd><p>Matrix of summed squares</p>
</dd>
</dl>

<p>Function <code>summary.suffstats()</code> provides a summary of a
<code>suffstats</code> object that is a list with two elements:
<code>row_sums</code> and <code>cross_prods</code>, normalized with <code>nobs</code> and
<code>Y</code> so that the values are comparable with that returned by
<code>expected_suffstats()</code>.  In particular, the sum of <code>row_sums</code>
is the known sum \(y\).
</p>


<h3>Author(s)</h3>

<p>Robin Hankin and P. M. E. Altham
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
suffstats(voting, voting_tally)

data(wilson)
wilson &lt;- gunter(non_met)
suffstats(wilson)

L &lt;- Lindsey(wilson)

expected_suffstats(L,5)
summary(suffstats(wilson))  ## matches.

summary(suffstats(rMM(10,5,L))) # should be close.




</code></pre>

<hr>
<h2 id='sweets'>
Synthetic dataset due to Hankin
</h2><span id='topic+sweets'></span><span id='topic+sweets_tally'></span><span id='topic+sweets_table'></span><span id='topic+sweets_array'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Four objects:
</p>

<ul>
<li><p><code>sweets</code> is a \(2\times 3\times 21\) array
</p>
</li>
<li><p><code>sweets_tally</code> is a length 37 vector
</p>
</li>
<li><p><code>sweets_array</code> is a \(2\times 3\times 37\)
vector
</p>
</li>
<li><p><code>sweets_table</code> is a \(37\times 6\) matrix
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(sweets)</code></pre>


<h3>Details</h3>

<p>Object <code>sweets</code> is the raw dataset; objects <code>sweets_table</code>
and <code>sweets_tally</code> are processed versions which are easier to
analyze.
</p>
<p>The father of a certain family brings home nine sweets of type
<code>mm</code> and nine sweets of type <code>jb</code> each day for 21 days to
his children, <code>AMH</code>, <code>ZJH</code>, and <code>AGH</code>.
</p>
<p>The children share the sweets amongst themselves in such a way that
each child receives exactly 6 sweets.
</p>

<ul>
<li><p> Array <code>sweets</code> has dimension <code>c(2,3,21)</code>: 2 types of
sweets, 3 children, and 21 days. Thus <code>sweets[,,1]</code> shows that on
the first day, <code>AMH</code> chose 0 sweets of type <code>mm</code> and 6
sweets of type <code>jb</code>; child <code>ZJH</code> chose 3 of each, and child
<code>AGH</code> chose 6 sweets of type <code>mm</code> and 0 sweets of type
<code>jb</code>.
</p>
<p>Observe the constant marginal totals: the kids have the same overall
number of sweets each, and there are a fixed number of each kind of
sweet.
</p>
</li>
<li><p> Array <code>sweets_array</code> has dimension <code>c(2,3,37)</code>: 2
sweets, 3 children, and 37 possible ways of arranging a matrix with
the specified marginal totals.  This can be produced by
<code>allboards()</code> of the <span class="pkg">aylmer</span> package.
</p>
</li>
<li> <p><code>sweets_table</code> is a dataframe with six columns, one for
each combination of child and sweet, and 37 rows, each row showing a
permissible arrangement.  All possibilities are present.  The six
entries of <code>sweets[,,1]</code> correspond to the six elements of
<code>sweets_table[1,]</code>; the column names are mnemonics.
</p>
</li>
<li><p><code>sweets_tally</code> shows how often each of the arrangements in
<code>sweets_tally</code> was observed (that is, it's a table of the 21
observations in <code>sweets</code>)
</p>
</li></ul>
 


<h3>Source</h3>

<p>The Hankin family
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sweets)

# show correspondence between sweets_table and sweets_tally:
cbind(sweets_table, sweets_tally)

# Sum the data, by sweet and child and test:
fisher.test(apply(sweets,1:2,sum))
# Not significant!




# Now test for overdispersion.
# First set up the regressors:

jj1 &lt;- apply(sweets_array,3,tcrossprod)
jj2 &lt;- apply(sweets_array,3, crossprod)
dim(jj1) &lt;- c(2,2,37)
dim(jj2) &lt;- c(3,3,37)

theta_xy &lt;- jj1[1,2,]
  phi_ab &lt;- jj2[1,2,]
  phi_ac &lt;- jj2[1,3,]
  phi_bc &lt;- jj2[2,3,]

# Now the offset:
Off &lt;- apply(sweets_array,3,function(x){-sum(lfactorial(x))})

# Now the formula:
f &lt;- formula(sweets_tally~ -1 + theta_xy + phi_ab + phi_ac + phi_bc)

# Now the Lindsey Poisson device:
out &lt;- glm(formula=f, offset=Off, family=poisson)

summary(out)
#  See how the residual deviance is comparable with the degrees of freedom  

</code></pre>

<hr>
<h2 id='voting'>
Synthetic dataset of voting behaviour due to Altham
</h2><span id='topic+voting'></span><span id='topic+voting_tally'></span><span id='topic+Nvoting_tally'></span>

<h3>Description</h3>

<p>Synthetic dataset of voting behaviour due to Altham
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(voting)</code></pre>


<h3>Format</h3>

<p><code>voting</code> is a three-column matrix with each row being a
configuration of voting in a household with four members, and three
choices.  Vector <code>voting_tally</code> is a list of how many households
voted, and <code>Nvoting_tally</code> is a more extreme dataset of the same
type, used to uncover bugs in <code>Lindsey()</code>.
</p>


<h3>Source</h3>

<p>Supplied by P. M. E. Altham
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(voting)
Lindsey(voting,voting_tally)
</code></pre>

<hr>
<h2 id='wilson'>
Housing Dataset due to Wilson
</h2><span id='topic+wilson'></span><span id='topic+met_area'></span><span id='topic+non_met'></span>

<h3>Description</h3>

<p>Dataset due to Wilson
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wilson)</code></pre>


<h3>Format</h3>

<p>Two objects, <code>met_area</code> and <code>non_met</code>, which  have three
columns and either 17 or 18 rows.  Each row corresponds to a
neighborhood of five households, each of which votes for one of three
choices: US, S, or VS.  Each   column corresponds to one of these
choices.  The rowsums are constant because there are exactly five
households in each neighborhood.
</p>


<h3>Source</h3>


<ul>
<li><p> J. R. Wilson 1989.  &ldquo;Chi-square tests for
Overdispersion with Multiparameter Estimates&rdquo;, <em>Journal of
the Royal Statistical Society.  Series C (Applied Statistics)</em>,
38(3):441&ndash;453
</p>
</li>
<li><p> S. S. Brier 1980. &ldquo;Analysis of Contingency Tables Under
Cluster Sampling&rdquo;, <em>Biometrika</em> 67(3):591&ndash;596
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(wilson)
Lindsey(non_met)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
