<!DOCTYPE html><html><head><title>Help for package EbayesThresh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EbayesThresh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta.cauchy'><p>Function beta for the quasi-Cauchy prior</p></a></li>
<li><a href='#beta.laplace'><p>Function beta for the Laplace prior</p></a></li>
<li><a href='#ebayesthresh'><p>Empirical Bayes thresholding on a sequence</p></a></li>
<li><a href='#ebayesthresh.wavelet'><p>Empirical Bayes thresholding on the levels of a wavelet transform.</p></a></li>
<li><a href='#isotone'><p>Weighted least squares monotone regression</p></a></li>
<li><a href='#postmean'><p>Posterior mean estimator</p></a></li>
<li><a href='#postmed'><p>Posterior median estimator</p></a></li>
<li><a href='#tfromw'><p>Find threshold from mixing weight</p></a></li>
<li><a href='#tfromx'><p>Find thresholds from data</p></a></li>
<li><a href='#threshld'><p>Threshold data with hard or soft thresholding</p></a></li>
<li><a href='#vecbinsolv'><p>Solve systems of nonlinear equations based on a monotonic function</p></a></li>
<li><a href='#wandafromx'><p>Find weight and scale factor from data if Laplace prior is used.</p></a></li>
<li><a href='#wfromt'><p>Mixing weight from posterior median threshold</p></a></li>
<li><a href='#wfromx'><p>Find Empirical Bayes weight from data</p></a></li>
<li><a href='#wmonfromx'><p>Find monotone Empirical Bayes weights from data.</p></a></li>
<li><a href='#zetafromx'><p>Estimation of a parameter in the prior weight sequence in the</p>
EbayesThresh paradigm.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Bayes Thresholding and Related Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-29</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stephenslab/EbayesThresh">https://github.com/stephenslab/EbayesThresh</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenslab/EbayesThresh/issues">https://github.com/stephenslab/EbayesThresh/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical Bayes thresholding using the methods developed
    by I. M. Johnstone and B. W. Silverman. The basic problem is to
    estimate a mean vector given a vector of observations of the mean
    vector plus white noise, taking advantage of possible sparsity in
    the mean vector. Within a Bayesian formulation, the elements of
    the mean vector are modelled as having, independently, a
    distribution that is a mixture of an atom of probability at zero
    and a suitable heavy-tailed distribution. The mixing parameter can
    be estimated by a marginal maximum likelihood approach. This leads
    to an adaptive thresholding approach on the original data.
    Extensions of the basic method, in particular to wavelet
    thresholding, are also implemented within the package.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, wavethresh</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, dplyr, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-30 12:06:51 UTC; pcarbo</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernard W. Silverman [aut],
  Ludger Evers [aut],
  Kan Xu [aut],
  Peter Carbonetto [aut, cre],
  Matthew Stephens [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Carbonetto &lt;peter.carbonetto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-08 04:02:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta.cauchy'>Function beta for the quasi-Cauchy prior</h2><span id='topic+beta.cauchy'></span>

<h3>Description</h3>

<p>Given a value or vector <code class="reqn">x</code> of values, find the value(s) of the
function <code class="reqn">\beta(x)=g(x)/\phi(x) - 1</code>,
where <code class="reqn">g</code> is the convolution of the quasi-Cauchy with the normal
density <code class="reqn">\phi(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.cauchy(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.cauchy_+3A_x">x</code></td>
<td>
<p>a real value or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code class="reqn">x</code>, containing the value(s)
<code class="reqn">\beta(x)</code>.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.laplace">beta.laplace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  beta.cauchy(c(-2,1,0,-4,8,50))
</code></pre>

<hr>
<h2 id='beta.laplace'>Function beta for the Laplace prior</h2><span id='topic+beta.laplace'></span>

<h3>Description</h3>

<p>Given a single value or a vector of <code class="reqn">x</code> and <code class="reqn">s</code>, find the
value(s) of the function <code class="reqn">\beta(x;s,a)=g(x;s,a)/fn(x;0,s) -
1</code>, where <code class="reqn">fn(x;0,s)</code> is the
normal density with mean 0 and standard deviation <code class="reqn">s</code>, and <code class="reqn">g</code>
is the convolution of the Laplace density with scale parameter <code class="reqn">a</code>,
<code class="reqn">\gamma_a(\mu)</code>, with the normal density
<code class="reqn">fn(x;\mu,s)</code> with mean <code class="reqn">mu</code> and standard deviation
<code class="reqn">s</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.laplace(x, s = 1, a = 0.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.laplace_+3A_x">x</code></td>
<td>
<p>the value or vector of data values</p>
</td></tr>
<tr><td><code id="beta.laplace_+3A_s">s</code></td>
<td>
<p>the value or vector of standard deviations; if vector, must
have the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="beta.laplace_+3A_a">a</code></td>
<td>
<p>the scale parameter of the Laplace distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> is returned,
containing the value(s) <code class="reqn">beta(x)</code>.
</p>


<h3>Note</h3>

<p>The Laplace density is given by <code class="reqn">\gamma(u;a) = \frac{1}{2} a
e^{-a|u|}</code> and is also known as the
double exponential density.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.cauchy">beta.cauchy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>beta.laplace(c(-2,1,0,-4,8,50), s=1)
beta.laplace(c(-2,1,0,-4,8,50), s=1:6, a=1)
</code></pre>

<hr>
<h2 id='ebayesthresh'>Empirical Bayes thresholding on a sequence</h2><span id='topic+ebayesthresh'></span>

<h3>Description</h3>

<p>Given a sequence of data, performs Empirical Bayes thresholding, 
as discussed in Johnstone and Silverman (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebayesthresh(x, prior = "laplace", a = 0.5, bayesfac = FALSE, 
sdev = NA, verbose = FALSE, threshrule = "median", universalthresh = TRUE,
stabadjustment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebayesthresh_+3A_x">x</code></td>
<td>
<p>Vector of data values.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used conditional on the
mean being nonzero; can be <code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy prior
is used. If, on entry, <code>a = NA</code> and <code>prior = "laplace"</code>,
then the scale parameter will also be estimated by marginal
maximum likelihood. If <code>a</code> is not specified then the
default value 0.5 will be used.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_bayesfac">bayesfac</code></td>
<td>
<p>If <code>bayesfac = TRUE</code>, then whenever a threshold
is explicitly calculated, the Bayes factor threshold will be
used.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_sdev">sdev</code></td>
<td>
<p>The sampling standard deviation of the data <code>x</code>. If,
on entry, <code>sdev = NA</code>, then the standard deviation will be
estimated using the median absolute deviation from zero, as
<code>mad(x, center = 0)</code>. If a single value is passed to
<code>sdev</code>, sampling standard deviation will be the same for
all observations. A vector of the same length as data sequence
can be passed to allow heterogeneous standard deviation,
currently only for Laplace prior.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_verbose">verbose</code></td>
<td>
<p>Controls the level of output. See below.</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_threshrule">threshrule</code></td>
<td>
<p>Specifies the thresholding rule to be applied to the
data. Possible values are <code>"median"</code> (use the posterior
median); <code>"mean"</code> (use the posterior mean); <code>"hard"</code>
(carry out hard thresholding); <code>"soft"</code> (carry out soft
thresholding); <code>"none"</code> (find various parameters, but do
not carry out any thresholding).</p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_universalthresh">universalthresh</code></td>
<td>
<p>If <code>universalthresh = TRUE</code>, the
thresholds will be upper bounded by universal threshold;
otherwise, the thresholds can take any non-negative values. </p>
</td></tr>
<tr><td><code id="ebayesthresh_+3A_stabadjustment">stabadjustment</code></td>
<td>
<p>If
<code>stabadjustment = TRUE</code>, the vectors of standard deviations
and data values will be divided by the mean of standard
deviations in case of inefficiency caused by large value of
standard deviation. For heterogeneous sampling standard deviation only;
ignored if standard deviation is homogeneous.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the data vector <code class="reqn">(x_1, \ldots, x_n)</code> is such that
each <code class="reqn">x_i</code> is drawn independently from a normal distribution with
mean <code class="reqn">\theta_i</code> and variance <code class="reqn">\sigma_i^2</code> (<code class="reqn">\sigma_i</code> is the
same in the homogeneous case). The prior distribution of each
<code class="reqn">\theta_i</code> is a mixture with probability <code class="reqn">1-w</code> of zero and
probability <code class="reqn">w</code> of a given symmetric heavy-tailed distribution. The
mixing weight, and possibly a scale factor in the symmetric
distribution, are estimated by marginal maximum likelihood. The
resulting values are used as the hyperparameters in the prior.
</p>
<p>The true effects <code class="reqn">\theta_i</code> can be estimated as the posterior median
or the posterior mean given the data, or by hard or soft thresholding
using the posterior median threshold. If hard or soft thresholding is
chosen, then there is the additional choice of using the Bayes factor
threshold, which is the value such thatthe posterior probability of zero
is exactly half if the data value is equal to the threshold.
</p>


<h3>Value</h3>

<p>If <code>verbose = FALSE</code>, a vector giving the values of the estimates
of the underlying mean vector.
</p>
<p>If <code>verbose = TRUE</code>, a list with the following elements:
</p>
<table>
<tr><td><code>muhat</code></td>
<td>
<p>the estimated mean vector (omitted if <code>threshrule =
    "none"</code>)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the data vector as supplied</p>
</td></tr>
<tr><td><code>threshold.sdevscale</code></td>
<td>
<p>the threshold as a multiple of the standard
deviation <code>sdev</code></p>
</td></tr>
<tr><td><code>threshold.origscale</code></td>
<td>
<p> the threshold measured on the original
scale of the data</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>the prior that was used</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the mixing weight as estimated by marginal maximum
likelihood</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>(only present if Laplace prior used) the scale factor as
supplied or estimated</p>
</td></tr>
<tr><td><code>bayesfac</code></td>
<td>
<p>the value of the parameter <code>bayesfac</code>,
determining whether Bayes factor or posterior median thresholds are
used</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviations of the data as supplied or
estimated</p>
</td></tr>
<tr><td><code>threshrule</code></td>
<td>
<p>the thresholding rule used, as specified above</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>Johnstone, I. M. and Silverman, B. W. (2004) Needles and straw in
haystacks: Empirical Bayes estimates of possibly sparse
sequences. <em>Annals of Statistics</em>, <b>32</b>, 1594&ndash;1649.
</p>
<p>Johnstone, I. M. and Silverman, B. W. (2004) EbayesThresh: R software
for Empirical Bayes thresholding. <em>Journal of Statistical
Software</em>, <b>12</b>.
</p>
<p>Johnstone, I. M. (2004) 'Function Estimation and Classical Normal
Theory' &lsquo;The Threshold Selection Problem&rsquo;. The Wald Lectures I and II,
2004. Available from <a href="http://www-stat.stanford.edu/~imj">http://www-stat.stanford.edu/~imj</a>.
</p>
<p>Johnstone, I. M. and Silverman, B. W. (2005) Empirical Bayes selection
of wavelet thresholds. <em>Annals of Statistics</em>, <b>33</b>,
1700&ndash;1752.
</p>
<p>The papers by Johnstone and Silverman are available from
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a>.
</p>
<p>See also <a href="http://www-stat.stanford.edu/~imj">http://www-stat.stanford.edu/~imj</a> for further
references, including the draft of a monograph by I. M. Johnstone.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfromx">tfromx</a></code>, <code><a href="#topic+threshld">threshld</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data with homogeneous sampling standard deviation using 
# Cauchy prior.
eb1 &lt;- ebayesthresh(x = rnorm(100, c(rep(0,90),rep(5,10))),
                     prior = "cauchy", sdev = NA)

# Data with homogeneous sampling standard deviation using 
# Laplace prior.
eb2 &lt;- ebayesthresh(x = rnorm(100, c(rep(0,90), rep(5,10))),
                     prior = "laplace", sdev = 1)
             
# Data with heterogeneous sampling standard deviation using 
# Laplace prior.
set.seed(123)
mu &lt;- c(rep(0,90), rep(5,10))
sd &lt;- c(rep(1, 40), rep(3, 60))
x  &lt;- mu + rnorm(100, sd = sd)

# With constraints on thresholds.
eb3 &lt;- ebayesthresh(x = x, prior = "laplace", a = NA, sdev = sd)

# Without constraints on thresholds. Observe that the estimates with
# constraints on thresholds have fewer zeroes than the estimates without
# constraints.
eb4 &lt;- ebayesthresh(x = x, prior = "laplace", a = NA, sdev = sd,
                     universalthresh = FALSE)
print(sum(eb3 == 0))
print(sum(eb4 == 0))

# Data with heterogeneous sampling standard deviation using Laplace
# prior.
set.seed(123)
mu &lt;- c(rep(0,90), rep(5,10))
sd &lt;- c(rep(1, 40), rep(5,40), rep(15, 20))
x  &lt;- mu + rnorm(100, sd = sd)

# In this example, infinity is returned as estimate when some of the
# sampling standard deviations are extremely large. However, this can
# be solved by stabilizing the data sequence before the analysis.
eb5 &lt;- ebayesthresh(x = x, prior = "laplace", a = NA, sdev = sd)

# With stabilization.
eb6 &lt;- ebayesthresh(x = x, prior = "laplace", a = NA, sdev = sd,
                    stabadjustment = TRUE)

</code></pre>

<hr>
<h2 id='ebayesthresh.wavelet'>Empirical Bayes thresholding on the levels of a wavelet transform.</h2><span id='topic+ebayesthresh.wavelet'></span><span id='topic+ebayesthresh.wavelet.dwt'></span><span id='topic+ebayesthresh.wavelet.wd'></span><span id='topic+ebayesthresh.wavelet.splus'></span>

<h3>Description</h3>

<p>Apply an Empirical Bayes thresholding approach level by level to the
detail coefficients in a wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebayesthresh.wavelet(xtr, vscale = "independent", smooth.levels = Inf, 
      prior = "laplace", a = 0.5, bayesfac = FALSE, 
      threshrule = "median")

ebayesthresh.wavelet.dwt(x.dwt, vscale = "independent", smooth.levels = Inf, 
      prior = "laplace", a = 0.5, bayesfac = FALSE,
      threshrule = "median")

ebayesthresh.wavelet.wd(x.wd, vscale = "independent", smooth.levels = Inf,
      prior = "laplace", a = 0.5, bayesfac = FALSE,
      threshrule = "median")

ebayesthresh.wavelet.splus(x.dwt, vscale = "independent", smooth.levels = Inf, 
      prior = "laplace", a = 0.5, bayesfac = FALSE,
      threshrule = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebayesthresh.wavelet_+3A_xtr">xtr</code></td>
<td>
<p>The wavelet transform of a vector of data. The transform
is obtained using one of the wavelet transform routines in <span class="rlang"><b>R</b></span> or
in S+WAVELETS. Any choice of wavelet, boundary condition, etc
provided by these routines can be used.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_x.dwt">x.dwt</code></td>
<td>
<p>Wavelet transform input for <code>ebayesthresh.wavelet.dwt</code>.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_x.wd">x.wd</code></td>
<td>
<p>Wavelet transform input for <code>ebayesthresh.wavelet.wd</code>.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_vscale">vscale</code></td>
<td>
<p>Controls the scale used at different levels of the
transform. If <code>vscale</code> is a scalar quantity, then it will
be assumed that the wavelet coefficients at every level have
this standard deviation. If <code>vscale = "independent"</code>, the
standard deviation will be estimated from the highest level of
the wavelet transform and will then be used for all levels
processed. If <code>vscale="level"</code>, then the standard
deviation will be estimated separately for each level processed,
allowing standard deviation that is level-dependent.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_smooth.levels">smooth.levels</code></td>
<td>
<p>The number of levels to be processed, if less
than the number of levels of detail calculated by the wavelet
transform.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used for the coefficients at
each level, conditional on their mean being nonzero; can be
<code>cauchy</code> or <code>laplace</code>.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used.  Ignored if Cauchy
prior is used. If, on entry, <code>a=NA</code> and
<code>prior="laplace"</code>, then the scale parameter will also be
estimated at each level by marginal maximum likelihood.  If
<code>a</code> is not specified then the default value 0.5 will be
used.</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_bayesfac">bayesfac</code></td>
<td>
<p>If <code>bayesfac=TRUE</code>, then whenever a threshold is
explicitly calculated, the Bayes factor threshold will be used.
</p>
</td></tr>
<tr><td><code id="ebayesthresh.wavelet_+3A_threshrule">threshrule</code></td>
<td>
<p>Specifies the thresholding rule to be applied to the
coefficients. Possible values are <code>median</code> (use the
posterior median); <code>mean</code> (use the posterior mean);
<code>hard</code> (carry out hard thresholding); <code>soft</code> (carry
out soft thresholding).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine <code>ebayesthresh.wavelet</code> can process a wavelet transform
obtained using the routine <code>wd</code> in the WaveThresh <span class="rlang"><b>R</b></span> package, the
routines <code>dwt</code> or <code>modwt</code> in the waveslim <span class="rlang"><b>R</b></span> package, or one
of the routines (either dwt or nd.dwt) in S+WAVELETS.
</p>
<p>Note that the wavelet transform must be calculated before the routine
ebayesthresh.wavelet is called; the choice of wavelet, boundary
conditions, decimated vs nondecimated wavelet, and so on, are made when
the wavelet transform is calculated.
</p>
<p>Apart from some housekeeping to estimate the standard deviation if
necessary, and to determine the number of levels to be processed, the
main part of the routine is a call, for each level, to the smoothing
routine <code><a href="#topic+ebayesthresh">ebayesthresh</a></code>.
</p>
<p>The basic notion of processing each level of detail coefficients is
easily transferred to transforms constructed using other wavelet
software. Similarly, it is straightforward to modify the routine to
give other details of the wavelet transform, if necessary using the
option <code>verbose = TRUE</code> in the calls to <code><a href="#topic+ebayesthresh">ebayesthresh</a></code>.
</p>
<p>The main routine <code>ebayesthresh.wavelet</code> calls the relevant one of
the routines <code>ebayesthresh.wavelet.wd</code> (for a transform obtained
from WaveThresh), <code>ebayesthresh.wavelet.dwt</code> (for transforms
obtained from either <code>dwt</code> or <code>modwt</code> in waveslim) or
<code>ebayesthresh.wavelet.splus</code> (for transforms obtained from
S+WAVELETS.
</p>


<h3>Value</h3>

<p>The wavelet transform (in the same format as that supplied to the
routine) of the values of the estimated regression function underlying
the original data.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>Johnstone, I. M. and Silverman, B. W. (2005)  
Empirical Bayes selection of wavelet thresholds.
<em>Annals of Statistics</em>, <b>33</b>, 1700&ndash;1752.
</p>
<p>See also the other references given for <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
at <a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ebayesthresh">ebayesthresh</a></code></p>

<hr>
<h2 id='isotone'>Weighted least squares monotone regression</h2><span id='topic+isotone'></span>

<h3>Description</h3>

<p>Given a vector of data and a vector of weights, find the
monotone sequence closest to the data in the sense of weighted least
squares with the given weights.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isotone(x, wt = rep(1, length(x)), increasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isotone_+3A_x">x</code></td>
<td>
<p>a vector of data</p>
</td></tr>
<tr><td><code id="isotone_+3A_wt">wt</code></td>
<td>
<p>a vector the same length as <code>x</code>, giving the weights to
be used in the weighted least squares algorithm</p>
</td></tr>
<tr><td><code id="isotone_+3A_increasing">increasing</code></td>
<td>
<p>logical variable indicating whether the required fit
is to be increasing or decreasing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard pool-adjacent-violators algorithm is used. Maximal
decreasing subsequences are found within the current sequence. Each
such decreasing subsequence is replaced by a constant sequence with
value equal to the weighted average. Within the algorithm, the
subsequence is replaced by a single point, with weight the sum of the
weights within the subsequence. This process is iterated to termination.
The resulting sequence is then unpacked back to the original ordering to
give the weighted least squares monotone fit.
</p>
<p>If <code>increasing = FALSE</code>, the original sequence is negated and the
resulting estimate negated.
</p>


<h3>Value</h3>

<p>The vector giving the best fitting monotone sequence is
returned.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wmonfromx">wmonfromx</a></code></p>

<hr>
<h2 id='postmean'>Posterior mean estimator</h2><span id='topic+postmean'></span><span id='topic+postmean.laplace'></span><span id='topic+postmean.cauchy'></span>

<h3>Description</h3>

<p>Given a single value or a vector of data and sampling
standard deviations (sd equals 1 for Cauchy prior), find the
corresponding posterior mean estimate(s) of the underlying signal
value(s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>postmean(x, s, w = 0.5, prior = "laplace", a = 0.5)
postmean.laplace(x, s = 1, w = 0.5, a = 0.5)
postmean.cauchy(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postmean_+3A_x">x</code></td>
<td>
<p>A data value or a vector of data.</p>
</td></tr>
<tr><td><code id="postmean_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If a vector, must have the same length as
<code>x</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="postmean_+3A_w">w</code></td>
<td>
<p>The value of the prior probability that the signal is
nonzero.</p>
</td></tr>
<tr><td><code id="postmean_+3A_prior">prior</code></td>
<td>
<p>Family of the nonzero part of the prior; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="postmean_+3A_a">a</code></td>
<td>
<p>The scale parameter of the nonzero part of the prior if the
Laplace prior is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">x</code> is a scalar, the posterior mean <code class="reqn">E(\theta|x)</code>
where <code class="reqn">\theta</code> is the mean of the distribution from which
<code class="reqn">x</code> is drawn. If <code class="reqn">x</code> is a vector with elements <code class="reqn">x_1, ... ,
x_n</code> and <code class="reqn">s</code> is a vector with elements <code class="reqn">s_1, ... , s_n</code> (s_i is
1 for Cauchy prior), then the vector returned has elements
<code class="reqn">E(\theta_i|x_i, s_i)</code>, where each <code class="reqn">x_i</code>
has mean <code class="reqn">\theta_i</code> and standard deviation <code class="reqn">s_i</code>, all
with the given prior.
</p>


<h3>Note</h3>

<p>If the quasicauchy prior is used, the argument <code>a</code> and
<code>s</code> are ignored.
</p>
<p>If <code>prior="laplace"</code>, the routine calls <code>postmean.laplace</code>,
which finds the posterior mean explicitly, as the product of the
posterior probability that the parameter is nonzero and the posterior
mean conditional on not being zero.
</p>
<p>If <code>prior="cauchy"</code>, the routine calls <code>postmean.cauchy</code>; in
that case the posterior mean is found by expressing the quasi-Cauchy
prior as a mixture: The mean conditional on the mixing parameter is
found and is then averaged over the posterior distribution of the mixing
parameter, including the atom of probability at zero variance.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+postmed">postmed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>postmean(c(-2,1,0,-4,8,50), w = 0.05, prior = "cauchy")
postmean(c(-2,1,0,-4,8,50), s = 1:6, w = 0.2, prior = "laplace", a = 0.3)
</code></pre>

<hr>
<h2 id='postmed'>Posterior median estimator</h2><span id='topic+postmed'></span><span id='topic+postmed.laplace'></span><span id='topic+postmed.cauchy'></span><span id='topic+cauchy.medzero'></span>

<h3>Description</h3>

<p>Given a single value or a vector of data and sampling standard
deviations (sd is 1 for Cauchy prior), find the corresponding
posterior median estimate(s) of the underlying signal value(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postmed(x, s, w = 0.5, prior = "laplace", a = 0.5)
postmed.laplace(x, s = 1, w = 0.5, a = 0.5)
postmed.cauchy(x, w)
cauchy.medzero(x, z, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postmed_+3A_x">x</code></td>
<td>
<p>A data value or a vector of data.</p>
</td></tr>
<tr><td><code id="postmed_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If a vector, must have the same length as
<code>x</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="postmed_+3A_w">w</code></td>
<td>
<p>The value of the prior probability that the signal is
nonzero.</p>
</td></tr>
<tr><td><code id="postmed_+3A_prior">prior</code></td>
<td>
<p>Family of the nonzero part of the prior; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="postmed_+3A_a">a</code></td>
<td>
<p>The scale parameter of the nonzero part of the prior if the
Laplace prior is used.</p>
</td></tr>
<tr><td><code id="postmed_+3A_z">z</code></td>
<td>
<p>The data vector (or scalar) provided as input to
<code>cauchy.medzero</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine calls the relevant one of the routines
<code>postmed.laplace</code> or <code>postmed.cauchy</code>. In the Laplace case,
the posterior median is found explicitly, without any need for the
numerical solution of an equation. In the quasi-Cauchy case, the
posterior median is found by finding the zero, component by component,
of the vector function <code>cauchy.medzero</code>.
</p>


<h3>Value</h3>

<p>If <code class="reqn">x</code> is a scalar, the posterior median
<code class="reqn">\mbox{med}(\theta|x)</code> where <code class="reqn">\theta</code> is
the mean of the distribution from which <code class="reqn">x</code> is drawn.  If <code class="reqn">x</code> is
a vector with elements <code class="reqn">x_1, ... , x_n</code> and <code class="reqn">s</code> is a vector with
elements <code class="reqn">s_1, ... , s_n</code> (s_i is 1 for Cauchy prior), then the
vector returned has elements <code class="reqn">\mbox{med}(\theta_i|x_i,
s_i)</code>, where each <code class="reqn">x_i</code> has mean
<code class="reqn">\theta_i</code> and standard deviation <code class="reqn">s_i</code>, all with the
given prior.
</p>


<h3>Note</h3>

<p>If the quasicauchy prior is used, the argument <code>a</code> and
<code>s</code> are ignored. The routine calls the approprate one of
<code>postmed.laplace</code> or <code>postmed.cauchy</code>.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+postmean">postmean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>postmed(c(-2,1,0,-4,8,50), w = 0.05, prior = "cauchy")
postmed(c(-2,1,0,-4,8,50), s = 1:6, w = 0.2, prior = "laplace", a = 0.3)
</code></pre>

<hr>
<h2 id='tfromw'>Find threshold from mixing weight</h2><span id='topic+tfromw'></span><span id='topic+laplace.threshzero'></span><span id='topic+cauchy.threshzero'></span>

<h3>Description</h3>

<p>Given a single value or a vector of weights (i.e. prior
probabilities that the parameter is nonzero) and sampling standard
deviations (sd equals 1 for Cauchy prior), find the corresponding
threshold(s) under the specified prior.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tfromw(w, s = 1, prior = "laplace", bayesfac = FALSE, a = 0.5)

  laplace.threshzero(x, s = 1, w = 0.5, a = 0.5)

  cauchy.threshzero(z, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfromw_+3A_x">x</code></td>
<td>
<p>Parameter value passed to <code>laplace.threshzero</code> objective
function.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_w">w</code></td>
<td>
<p>Prior weight or vector of weights.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If <code>w</code> is a vector, must have the same
length as <code>w</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_bayesfac">bayesfac</code></td>
<td>
<p>Specifies whether Bayes factor threshold should be
used instead of posterior median threshold.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy
prior is used.</p>
</td></tr>
<tr><td><code id="tfromw_+3A_z">z</code></td>
<td>
<p>The putative threshold vector for <code>cauchy.threshzero</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayes factor method uses a threshold such that the posterior
probability of zero is exactly half if the data value is equal to the
threshold. If <code>bayesfac</code> is set to <code>FALSE</code> (the default) then
the threshold is that of the posterior median function given the data
value.
</p>
<p>The routine carries out a binary search over each component of an
appropriate vector function, using the routine <code><a href="#topic+vecbinsolv">vecbinsolv</a></code>.
</p>
<p>For the posterior median threshold, the function to be zeroed is
<code>laplace.threshzero</code> or <code>cauchy.threshzero</code>.
</p>
<p>For the Bayes factor threshold, the corresponding functions are
<code><a href="#topic+beta.laplace">beta.laplace</a></code> or <code><a href="#topic+beta.cauchy">beta.cauchy</a></code>.
</p>


<h3>Value</h3>

<p>The value or vector of values of the estimated threshold(s).</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wfromx">wfromx</a></code>, <code><a href="#topic+tfromx">tfromx</a></code>,
<code><a href="#topic+wandafromx">wandafromx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tfromw(c(0.05, 0.1), s = 1) 
tfromw(c(0.05, 0.1), prior = "cauchy", bayesfac = TRUE)
</code></pre>

<hr>
<h2 id='tfromx'>Find thresholds from data</h2><span id='topic+tfromx'></span>

<h3>Description</h3>

<p>Given a vector of data and standard deviations (sd equals 1 for Cauchy
prior), find the value or vector (heterogeneous sampling standard
deviation with Laplace prior) of thresholds corresponding to the
marginal maximum likelihood choice of weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tfromx(x, s = 1, prior = "laplace", bayesfac = FALSE, a = 0.5,
         universalthresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfromx_+3A_x">x</code></td>
<td>
<p>Vector of data.</p>
</td></tr>
<tr><td><code id="tfromx_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If a vector, must have the same length as
<code>x</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="tfromx_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="tfromx_+3A_bayesfac">bayesfac</code></td>
<td>
<p>Specifies whether Bayes factor threshold should be
used instead of posterior median threshold.</p>
</td></tr>
<tr><td><code id="tfromx_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy
prior is used.</p>
</td></tr>
<tr><td><code id="tfromx_+3A_universalthresh">universalthresh</code></td>
<td>
<p>If <code>universalthresh = TRUE</code>, the thresholds
will be upper bounded by universal threshold; otherwise, the
thresholds can take any non-negative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the routine <code><a href="#topic+wfromx">wfromx</a></code> is called to find the estimated
weight. Then the routine <code><a href="#topic+tfromw">tfromw</a></code> is used to find the
threshold. See the documentation for these routines for more details.
</p>


<h3>Value</h3>

<p>The numerical value or vector of the estimated thresholds is
returned.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tfromw">tfromw</a></code>, <code><a href="#topic+wfromx">wfromx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tfromx(x = rnorm(100, c(rep(0,90),rep(5,10))), prior = "cauchy")
</code></pre>

<hr>
<h2 id='threshld'>Threshold data with hard or soft thresholding</h2><span id='topic+threshld'></span>

<h3>Description</h3>

<p>Given a data value or a vector of data, threshold the data at a
specified value, using hard or soft thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshld(x, t, hard = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshld_+3A_x">x</code></td>
<td>
<p>a data value or a vector of data</p>
</td></tr>
<tr><td><code id="threshld_+3A_t">t</code></td>
<td>
<p>value of threshold to be used</p>
</td></tr>
<tr><td><code id="threshld_+3A_hard">hard</code></td>
<td>
<p> specifies whether hard or soft thresholding is applied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value or vector of values the same length as <code>x</code>, containing
the result of the relevant thresholding rule applied to <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ebayesthresh">ebayesthresh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>threshld(-5:5, 1.4, FALSE)
</code></pre>

<hr>
<h2 id='vecbinsolv'>Solve systems of nonlinear equations based on a monotonic function</h2><span id='topic+vecbinsolv'></span>

<h3>Description</h3>

<p>Solve a nonlinear equation or a vector of nonlinear equations 
based on an increasing function in a specified interval.</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecbinsolv(zf, fun, tlo, thi, nits = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecbinsolv_+3A_zf">zf</code></td>
<td>
<p>the right hand side of the equation(s) to be solved</p>
</td></tr>
<tr><td><code id="vecbinsolv_+3A_fun">fun</code></td>
<td>
<p>an increasing function of a scalar argument, or a
vector of such functions</p>
</td></tr>
<tr><td><code id="vecbinsolv_+3A_tlo">tlo</code></td>
<td>
<p>lower limit of interval over which the solution is sought</p>
</td></tr>
<tr><td><code id="vecbinsolv_+3A_thi">thi</code></td>
<td>
<p>upper limit of interval over which the solution is sought</p>
</td></tr>
<tr><td><code id="vecbinsolv_+3A_nits">nits</code></td>
<td>
<p>number of binary subdivisions carried out</p>
</td></tr>
<tr><td><code id="vecbinsolv_+3A_...">...</code></td>
<td>
<p>additional arguments to the function <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fun</code> is a scalar monotone function, the routine finds a vector
<code>t</code> the same length as <code>zf</code> such that, component-wise,
<code class="reqn">fun(t) = zf</code>, where this is possible within the interval
<code class="reqn">\code{(tlo,thi)}</code>. The relevant value returned is the
nearer extreme to the solution if there is no solution in the specified
range for any particular component of <code>zf</code>. The routine will also
work if <code>fun</code> is a vector of monotone functions, allowing different
functions to be considered for different components.  The interval over
which the search is conducted has to be the same for each component.
</p>
<p>The accuracy of the solution is determined by the number of binary
subdivisions; if <code>nits=30</code> then the solution(s) will
be accurate to about 9 orders of magnitude less than the length of the
original interval <code class="reqn">(tlo, thi)</code>.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>

<hr>
<h2 id='wandafromx'>Find weight and scale factor from data if Laplace prior is used.</h2><span id='topic+wandafromx'></span><span id='topic+negloglik.laplace'></span>

<h3>Description</h3>

<p>Given a vector of data and a single value or vector of sampling standard
deviations, find the marginal maximum likelihood choice of both weight
and scale factor under the Laplace prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wandafromx(x, s = 1, universalthresh = TRUE)
negloglik.laplace(xpar, xx, ss, tlo, thi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wandafromx_+3A_x">x</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations. If
vector, must have the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_universalthresh">universalthresh</code></td>
<td>
<p>If <code>universalthresh = TRUE</code>, the thresholds
will be upper bounded by universal threshold; otherwise, the
thresholds can take any non-negative values.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_xx">xx</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_xpar">xpar</code></td>
<td>
<p>Vector of two parameters: <code>xpar[1]</code> : a value between
0 and 1, which will be adjusted to range of w; <code>xpar[2]</code>, 
scale factor &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_ss">ss</code></td>
<td>
<p>Vector of standard deviations.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_tlo">tlo</code></td>
<td>
<p>Lower bound of thresholds.</p>
</td></tr>
<tr><td><code id="wandafromx_+3A_thi">thi</code></td>
<td>
<p>Upper bound of thresholds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters are found by marginal maximum likelihood.
</p>
<p>The search is over weights corresponding to threshold <code class="reqn">t_i</code> in the
range <code class="reqn">[0, s_i \sqrt{2 \log n}]</code> if
<code>universalthresh=TRUE</code>, where <code class="reqn">n</code> is the length of the data
vector and <code class="reqn">(s_1, ... , s_n)</code> is the vector of sampling standard
deviation of data <code class="reqn">(x_1, ... , x_n)</code>; otherwise, the search is over
<code class="reqn">[0,1]</code>.
</p>
<p>The search uses a nonlinear optimization routine (<code><a href="stats.html#topic+optim">optim</a></code> in
<span class="rlang"><b>R</b></span>) to minimize the negative log likelihood function
<code>negloglik.laplace</code>.  The range over which the scale factor is
searched is (0.04, 3).  For reasons of numerical stability within the
optimization, the prior is parametrized internally by the threshold and
the scale parameter.
</p>


<h3>Value</h3>

<p>A list with values:
</p>
<table>
<tr><td><code>w</code></td>
<td>
<p>The estimated weight.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The estimated scale factor.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wfromx">wfromx</a></code>, <code><a href="#topic+tfromw">tfromw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>wandafromx(rnorm(100, c(rep(0,90),rep(5,10))), s = 1)
</code></pre>

<hr>
<h2 id='wfromt'>Mixing weight from posterior median threshold</h2><span id='topic+wfromt'></span>

<h3>Description</h3>

<p>Given a value or vector of thresholds and sampling standard deviations
(sd equals 1 for Cauchy prior), find the mixing weight for which this
is(these are) the threshold(s) of the posterior median estimator.  If a
vector of threshold values is provided, the vector of corresponding
weights is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wfromt(tt, s = 1, prior = "laplace", a = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfromt_+3A_tt">tt</code></td>
<td>
<p>Threshold value or vector of values.</p>
</td></tr>
<tr><td><code id="wfromt_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If a vector, must have the same length as
<code>tt</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="wfromt_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="wfromt_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy
prior is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numerical value or vector of values of the corresponding
weight is returned.
</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tfromw">tfromw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>wfromt(c(2,3,5), prior = "cauchy" )
</code></pre>

<hr>
<h2 id='wfromx'>Find Empirical Bayes weight from data</h2><span id='topic+wfromx'></span>

<h3>Description</h3>

<p>Suppose the vector <code class="reqn">(x_1, \ldots, x_n)</code> is such that <code class="reqn">x_i</code> is
drawn independently from a normal distribution with mean
<code class="reqn">\theta_i</code> and standard deviation <code class="reqn">s_i</code> (s_i equals 1
for Cauchy prior). The prior distribution of the
<code class="reqn">\theta_i</code> is a mixture with probability <code class="reqn">1-w</code> of zero
and probability <code class="reqn">w</code> of a given symmetric heavy-tailed distribution.
This routine finds the marginal maximum likelihood estimate of the
parameter <code class="reqn">w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wfromx(x, s = 1, prior = "laplace", a = 0.5, universalthresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wfromx_+3A_x">x</code></td>
<td>
<p>Vector of data.</p>
</td></tr>
<tr><td><code id="wfromx_+3A_s">s</code></td>
<td>
<p>A single value or a vector of standard deviations if the
Laplace prior is used. If a vector, must have the same length as
<code>x</code>. Ignored if Cauchy prior is used.</p>
</td></tr>
<tr><td><code id="wfromx_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used; can be
<code>"cauchy"</code> or <code>"laplace"</code>.</p>
</td></tr>
<tr><td><code id="wfromx_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy
prior is used.</p>
</td></tr>
<tr><td><code id="wfromx_+3A_universalthresh">universalthresh</code></td>
<td>
<p>If <code>universalthresh = TRUE</code>, the
thresholds will be upper bounded by universal threshold;
otherwise, the thresholds can take any non-negative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weight is found by marginal maximum likelihood.
</p>
<p>The search is over weights corresponding to threshold <code class="reqn">t_i</code> in the
range <code class="reqn">[0, s_i \sqrt{2 \log n}]</code> if
<code>universalthresh=TRUE</code>, where <code class="reqn">n</code> is the length of the data
vector and <code class="reqn">(s_1, ... , s_n)</code> (s_i is 1 for Cauchy prior) is the
vector of sampling standard deviation of data <code class="reqn">(x_1, ... , x_n)</code>;
otherwise, the search is over <code class="reqn">[0, 1]</code>.
</p>
<p>The search is by binary search for a solution to the equation 
<code class="reqn">S(w)=0</code>, where <code class="reqn">S</code> is the derivative of the log likelihood.
The binary search is on a logarithmic scale in <code class="reqn">w</code>.
</p>
<p>If the Laplace prior is used, the scale parameter is fixed at the value
given for <code>a</code>, and defaults to 0.5 if no value is provided.  To
estimate <code>a</code> as well as <code>w</code> by marginal maximum likelihood,
use the routine <code><a href="#topic+wandafromx">wandafromx</a></code>.
</p>


<h3>Value</h3>

<p>The numerical value of the estimated weight.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wandafromx">wandafromx</a></code>, <code><a href="#topic+tfromx">tfromx</a></code>,
<code><a href="#topic+tfromw">tfromw</a></code>, <code><a href="#topic+wfromt">wfromt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wfromx(x = rnorm(100, s = c(rep(0,90),rep(5,10))), prior = "cauchy")
</code></pre>

<hr>
<h2 id='wmonfromx'>Find monotone Empirical Bayes weights from data.</h2><span id='topic+wmonfromx'></span>

<h3>Description</h3>

<p>Given a vector of data, find the marginal maximum likelihood choice of
weight sequence subject to the constraints that the weights are monotone
decreasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmonfromx(xd, prior = "laplace", a = 0.5, tol = 1e-08, maxits = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmonfromx_+3A_xd">xd</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="wmonfromx_+3A_prior">prior</code></td>
<td>
<p>Specification of the prior to be used; can be
<code>cauchy</code> or <code>laplace</code>.</p>
</td></tr>
<tr><td><code id="wmonfromx_+3A_a">a</code></td>
<td>
<p>Scale parameter in prior if <code>prior="laplace"</code>. Ignored
if <code>prior="cauchy"</code>.</p>
</td></tr>
<tr><td><code id="wmonfromx_+3A_tol">tol</code></td>
<td>
<p>Absolute tolerance to within which estimates are
calculated.</p>
</td></tr>
<tr><td><code id="wmonfromx_+3A_maxits">maxits</code></td>
<td>
<p>Maximum number of weighted least squares iterations
within the calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights is found by marginal maximum likelihood. The search is over
weights corresponding to thresholds in the range <code class="reqn">[0, \sqrt{2 \log
n}]</code>, where <code class="reqn">n</code> is the length of the data vector.
</p>
<p>An iterated least squares monotone regression algorithm is used to
maximize the log likelihood. The weighted least squares monotone
regression routine <code><a href="#topic+isotone">isotone</a></code> is used.
</p>
<p>To turn the weights into thresholds, use the routine
<code><a href="#topic+tfromw">tfromw</a></code>; to process the data with these thresholds, use the
routine <code><a href="#topic+threshld">threshld</a></code>.
</p>


<h3>Value</h3>

<p>The vector of estimated weights is returned.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wfromx">wfromx</a></code>, <code><a href="#topic+isotone">isotone</a></code></p>

<hr>
<h2 id='zetafromx'>Estimation of a parameter in the prior weight sequence in the
EbayesThresh paradigm.</h2><span id='topic+zetafromx'></span>

<h3>Description</h3>

<p>Suppose a sequence of data has underlying mean vector with elements
<code class="reqn">\theta_i</code>. Given the sequence of data, and a vector of scale
factors <code>cs</code> and a lower limit <code>pilo</code>, this routine finds the
marginal maximum likelihood estimate of the parameter <code>zeta</code> such
that the prior probability of <code class="reqn">\theta_i</code> being nonzero is of the
form <code>median(pilo, zeta*cs, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zetafromx(xd, cs, pilo = NA, prior = "laplace", a = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zetafromx_+3A_xd">xd</code></td>
<td>
<p>A vector of data.</p>
</td></tr>
<tr><td><code id="zetafromx_+3A_cs">cs</code></td>
<td>
<p>A vector of scale factors, of the same length as <code>xd</code>.</p>
</td></tr>
<tr><td><code id="zetafromx_+3A_pilo">pilo</code></td>
<td>
<p>The lower limit for the estimated weights. If
<code>pilo=NA</code> it is calculated according to the sample size to be
the weight corresponding to the universal threshold <code class="reqn">\sqrt{2
    \log n}</code>.</p>
</td></tr>
<tr><td><code id="zetafromx_+3A_prior">prior</code></td>
<td>
<p>Specification of prior to be used conditional on the mean
being nonzero; can be <code>cauchy</code> or <code>laplace</code>.</p>
</td></tr>
<tr><td><code id="zetafromx_+3A_a">a</code></td>
<td>
<p>Scale factor if Laplace prior is used. Ignored if Cauchy
prior is used. If, on entry, <code>a=NA</code> and <code>prior="laplace"</code>,
then the scale parameter will also be estimated by marginal maximum
likelihood. If <code>a</code> is not specified then the default value 0.5
will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An exact algorithm is used, based on splitting the range up for
<code>zeta</code> into subintervals over which no element of <code>zeta*cs</code>
crosses either <code>pilo</code> or 1.
</p>
<p>Within each of these subintervals, the log likelihood is concave and its
maximum can be found to arbitrary accuracy; first the derivatives at
each end of the interval are checked to see if there is an internal
maximum at all, and if there is this can be found by a binary search for
a zero of the derivative.
</p>
<p>Finally, the maximum of all the local maxima over these subintervals is
found.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>zeta</code></td>
<td>
<p>The value of <code>zeta</code> that yields the marginal maximum
likelihood.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The weights (prior probabilities of nonzero) yielded by this
value of <code>zeta</code>.</p>
</td></tr>
<tr><td><code>cs</code></td>
<td>
<p>The factors as supplied to the program.</p>
</td></tr>
<tr><td><code>pilo</code></td>
<td>
<p>The lower bound on the weight, either as supplied or as
calculated internally.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Once the maximizing <code>zeta</code> and corresponding weights have
been found, the thresholds can be found using the program
<code><a href="#topic+tfromw">tfromw</a></code>, and these can be used to process the original
data using the routine <code><a href="#topic+threshld">threshld</a></code>.</p>


<h3>Author(s)</h3>

<p>Bernard Silverman</p>


<h3>References</h3>

<p>See <code><a href="#topic+ebayesthresh">ebayesthresh</a></code> and
<a href="http://www.bernardsilverman.com">http://www.bernardsilverman.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tfromw">tfromw</a></code>, <code><a href="#topic+threshld">threshld</a></code>,
<code><a href="#topic+wmonfromx">wmonfromx</a></code>, <code><a href="#topic+wfromx">wfromx</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
