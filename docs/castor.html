<!DOCTYPE html><html><head><title>Help for package castor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {castor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asr_empirical_probabilities'>
<p>Empirical ancestral state probabilities.</p></a></li>
<li><a href='#asr_independent_contrasts'>
<p>Ancestral state reconstruction via phylogenetic independent contrasts.</p></a></li>
<li><a href='#asr_max_parsimony'>
<p>Maximum-parsimony ancestral state reconstruction.</p></a></li>
<li><a href='#asr_mk_model'>
<p>Ancestral state reconstruction with Mk models and rerooting</p></a></li>
<li><a href='#asr_squared_change_parsimony'>
<p>Squared-change parsimony ancestral state reconstruction.</p></a></li>
<li><a href='#asr_subtree_averaging'>
<p>Ancestral state reconstruction via subtree averaging.</p></a></li>
<li><a href='#castor-package'>
<p>Efficient computations on large phylogenetic trees.</p></a></li>
<li><a href='#clade_densities'>
<p>Estimate the density of tips &amp; nodes in a timetree.</p></a></li>
<li><a href='#collapse_monofurcations'>
<p>Remove monofurcations from a tree.</p></a></li>
<li><a href='#collapse_tree_at_resolution'>
<p>Collapse nodes of a tree at a phylogenetic resolution.</p></a></li>
<li><a href='#congruent_divergence_times'>
<p>Extract dating anchors for a target tree, using a dated reference tree</p></a></li>
<li><a href='#congruent_hbds_model'>
<p>Generate a congruent homogenous-birth-death-sampling model.</p></a></li>
<li><a href='#consensus_taxonomies'>
<p>Compute consensus taxonomies across a tree.</p></a></li>
<li><a href='#consentrait_depth'>
<p>Calculate phylogenetic depth of a binary trait using the consenTRAIT metric.</p></a></li>
<li><a href='#correlate_phylo_geodistances'>
<p>Correlations between phylogenetic &amp; geographic distances.</p></a></li>
<li><a href='#count_lineages_through_time'>
<p>Count number of lineages through time (LTT).</p></a></li>
<li><a href='#count_tips_per_node'>
<p>Count descending tips.</p></a></li>
<li><a href='#count_transitions_between_clades'>
<p>Count the number of state transitions between tips or nodes.</p></a></li>
<li><a href='#date_tree_red'>
<p>Date a tree based on relative evolutionary divergences.</p></a></li>
<li><a href='#discrete_trait_depth'>
<p>Calculate phylogenetic depth of a discrete trait.</p></a></li>
<li><a href='#evaluate_spline'>
<p>Evaluate a scalar spline at arbitrary locations.</p></a></li>
<li><a href='#expanded_tree_from_jplace'>
<p>Place queries on a tree from a jplace file.</p></a></li>
<li><a href='#expected_distances_sbm'>
<p>Expected distances traversed by a Spherical Brownian Motion.</p></a></li>
<li><a href='#exponentiate_matrix'>
<p>Exponentiate a matrix.</p></a></li>
<li><a href='#extend_tree_to_height'>
<p>Extend a rooted tree up to a specific height.</p></a></li>
<li><a href='#extract_deep_frame'>
<p>Extract tips representing a tree's deep splits.</p></a></li>
<li><a href='#extract_fasttree_constraints'>
<p>Extract tree constraints in FastTree alignment format.</p></a></li>
<li><a href='#extract_tip_neighborhood'>
<p>Extract a subtree spanning tips within a certain neighborhood.</p></a></li>
<li><a href='#extract_tip_radius'>
<p>Extract a subtree spanning tips within a certain radius.</p></a></li>
<li><a href='#find_farthest_tip_pair'>
<p>Find the two most distant tips in a tree.</p></a></li>
<li><a href='#find_farthest_tips'>
<p>Find farthest tip to each tip &amp; node of a tree.</p></a></li>
<li><a href='#find_nearest_tips'>
<p>Find nearest tip to each tip &amp; node of a tree.</p></a></li>
<li><a href='#find_root'>
<p>Find the root of a tree.</p></a></li>
<li><a href='#find_root_of_monophyletic_tips'>
<p>Find the node or tip that, as root, would make a set of target tips monophyletic.</p></a></li>
<li><a href='#fit_and_compare_bm_models'>
<p>Fit and compare Brownian Motion models for multivariate trait evolution between two data sets.</p></a></li>
<li><a href='#fit_and_compare_sbm_const'>
<p>Fit and compare Spherical Brownian Motion models for diffusive geographic dispersal between two data sets.</p></a></li>
<li><a href='#fit_bm_model'>
<p>Fit a Brownian Motion model for multivariate trait evolution.</p></a></li>
<li><a href='#fit_hbd_model_on_grid'>
<p>Fit a homogenous birth-death model on a discrete time grid.</p></a></li>
<li><a href='#fit_hbd_model_parametric'>
<p>Fit a parametric homogenous birth-death model to a timetree.</p></a></li>
<li><a href='#fit_hbd_pdr_on_best_grid_size'>
<p>Fit pulled diversification rates of birth-death models on a time grid with optimal size.</p></a></li>
<li><a href='#fit_hbd_pdr_on_grid'>
<p>Fit pulled diversification rates of birth-death models on a time grid.</p></a></li>
<li><a href='#fit_hbd_pdr_parametric'>
<p>Fit parameterized pulled diversification rates of birth-death models.</p></a></li>
<li><a href='#fit_hbd_psr_on_best_grid_size'>
<p>Fit pulled speciation rates of birth-death models on a time grid with optimal size.</p></a></li>
<li><a href='#fit_hbd_psr_on_grid'>
<p>Fit pulled speciation rates of birth-death models on a time grid.</p></a></li>
<li><a href='#fit_hbd_psr_parametric'>
<p>Fit parameterized pulled speciation rates of birth-death models.</p></a></li>
<li><a href='#fit_hbds_model_on_grid'>
<p>Fit a homogenous birth-death-sampling model on a discrete time grid.</p></a></li>
<li><a href='#fit_hbds_model_parametric'>
<p>Fit a parametric homogenous birth-death-sampling model to a timetree.</p></a></li>
<li><a href='#fit_mk'>
<p>Fit a Markov (Mk) model for discrete trait evolution.</p></a></li>
<li><a href='#fit_musse'>
<p>Fit a discrete-state-dependent diversification model via maximum-likelihood.</p></a></li>
<li><a href='#fit_sbm_const'>
<p>Fit a phylogeographic Spherical Brownian Motion model.</p></a></li>
<li><a href='#fit_sbm_geobiased_const'>
<p>Fit a phylogeographic Spherical Brownian Motion model with geographic sampling bias.</p></a></li>
<li><a href='#fit_sbm_linear'>
<p>Fit a phylogeographic Spherical Brownian Motion model with linearly varying diffusivity.</p></a></li>
<li><a href='#fit_sbm_on_grid'>
<p>Fit a phylogeographic Spherical Brownian Motion model with piecewise-linear diffusivity.</p></a></li>
<li><a href='#fit_sbm_parametric'>
<p>Fit a time-dependent phylogeographic Spherical Brownian Motion model.</p></a></li>
<li><a href='#fit_tree_model'>
<p>Fit a cladogenic model to an existing tree.</p></a></li>
<li><a href='#gamma_statistic'>
<p>Calculate the gamma-statistic of a tree.</p></a></li>
<li><a href='#generate_gene_tree_msc'>
<p>Generate a gene tree based on the multi-species coalescent model.</p></a></li>
<li><a href='#generate_gene_tree_msc_hgt_dl'>
<p>Generate gene trees based on the multi-species coalescent, horizontal gene transfers and duplications/losses.</p></a></li>
<li><a href='#generate_random_tree'>
<p>Generate a tree using a Poissonian speciation/extinction model.</p></a></li>
<li><a href='#generate_tree_hbd_reverse'>
<p>Generate a tree from a birth-death model in reverse time.</p></a></li>
<li><a href='#generate_tree_hbds'>
<p>Generate a tree from a birth-death-sampling model in forward time.</p></a></li>
<li><a href='#generate_tree_with_evolving_rates'>
<p>Generate a random tree with evolving speciation/extinction rates.</p></a></li>
<li><a href='#geographic_acf'>
<p>Phylogenetic autocorrelation function of geographic locations.</p></a></li>
<li><a href='#get_all_distances_to_root'>
<p>Get distances of all tips and nodes to the root.</p></a></li>
<li><a href='#get_all_distances_to_tip'>
<p>Get distances of all tips/nodes to a focal tip.</p></a></li>
<li><a href='#get_all_node_depths'>
<p>Get the phylogenetic depth of each node in a tree.</p></a></li>
<li><a href='#get_all_pairwise_distances'>
<p>Get distances between all pairs of tips and/or nodes.</p></a></li>
<li><a href='#get_ancestral_nodes'>
<p>Compute ancestral nodes.</p></a></li>
<li><a href='#get_clade_list'>
<p>Get a representation of a tree as a table listing tips/nodes.</p></a></li>
<li><a href='#get_independent_contrasts'>
<p>Phylogenetic independent contrasts for continuous traits.</p></a></li>
<li><a href='#get_independent_sister_tips'>
<p>Extract disjoint tip pairs with independent relationships.</p></a></li>
<li><a href='#get_mrca_of_set'>
<p>Most recent common ancestor of a set of tips/nodes.</p></a></li>
<li><a href='#get_pairwise_distances'>
<p>Get distances between pairs of tips or nodes.</p></a></li>
<li><a href='#get_pairwise_mrcas'>
<p>Get most recent common ancestors of tip/node pairs.</p></a></li>
<li><a href='#get_random_diffusivity_matrix'>
<p>Create a random diffusivity matrix for a Brownian motion model.</p></a></li>
<li><a href='#get_random_mk_transition_matrix'>
<p>Create a random transition matrix for an Mk model.</p></a></li>
<li><a href='#get_reds'>
<p>Calculate relative evolutionary divergences in a tree.</p></a></li>
<li><a href='#get_stationary_distribution'>
<p>Stationary distribution of Markov transition matrix.</p></a></li>
<li><a href='#get_subtree_at_node'>
<p>Extract a subtree descending from a specific node.</p></a></li>
<li><a href='#get_subtree_with_tips'>
<p>Extract a subtree spanning a specific subset of tips.</p></a></li>
<li><a href='#get_subtrees_at_nodes'>
<p>Extract subtrees descending from specific nodes.</p></a></li>
<li><a href='#get_tips_for_mrcas'>
<p>Find tips with specific most recent common ancestors.</p></a></li>
<li><a href='#get_trait_acf'>
<p>Phylogenetic autocorrelation function of a numeric trait.</p></a></li>
<li><a href='#get_trait_stats_over_time'>
<p>Calculate mean &amp; standard deviation of a numeric trait on a dated tree over time.</p></a></li>
<li><a href='#get_transition_index_matrix'>
<p>Create an index matrix for a Markov transition model.</p></a></li>
<li><a href='#get_tree_span'>
<p>Get min and max distance of any tip to the root.</p></a></li>
<li><a href='#get_tree_traversal_root_to_tips'>
<p>Traverse tree from root to tips.</p></a></li>
<li><a href='#hsp_binomial'>
<p>Hidden state prediction for a binary trait based on the binomial distribution.</p></a></li>
<li><a href='#hsp_empirical_probabilities'>
<p>Hidden state prediction via empirical probabilities.</p></a></li>
<li><a href='#hsp_independent_contrasts'>
<p>Hidden state prediction via phylogenetic independent contrasts.</p></a></li>
<li><a href='#hsp_max_parsimony'>
<p>Hidden state prediction via maximum parsimony.</p></a></li>
<li><a href='#hsp_mk_model'>
<p>Hidden state prediction with Mk models and rerooting</p></a></li>
<li><a href='#hsp_nearest_neighbor'>
<p>Hidden state prediction based on nearest neighbor.</p></a></li>
<li><a href='#hsp_squared_change_parsimony'>
<p>Hidden state prediction via squared-change parsimony.</p></a></li>
<li><a href='#hsp_subtree_averaging'>
<p>Hidden state prediction via subtree averaging.</p></a></li>
<li><a href='#is_bifurcating'>
<p>Determine if a tree is bifurcating.</p></a></li>
<li><a href='#is_monophyletic'>
<p>Determine if a set of tips is monophyletic.</p></a></li>
<li><a href='#join_rooted_trees'>
<p>Join two rooted trees.</p></a></li>
<li><a href='#loglikelihood_hbd'>
<p>Galculate the log-likelihood of a homogenous birth-death model.</p></a></li>
<li><a href='#map_to_state_space'>
<p>Map states of a discrete trait to integers.</p></a></li>
<li><a href='#mean_abs_change_scalar_ou'>
<p>Compute the expected absolute change of an Ornstein-Uhlenbeck process.</p></a></li>
<li><a href='#merge_nodes_to_multifurcations'>
<p>Merge specific nodes into multifurcations.</p></a></li>
<li><a href='#merge_short_edges'>
<p>Eliminate short edges in a tree by merging nodes into multifurcations.</p></a></li>
<li><a href='#model_adequacy_hbd'>
<p>Check if a birth-death model adequately explains a timetree.</p></a></li>
<li><a href='#model_adequacy_hbds'>
<p>Check if a birth-death-sampling model adequately explains a timetree.</p></a></li>
<li><a href='#multifurcations_to_bifurcations'>
<p>Expand multifurcations to bifurcations.</p></a></li>
<li><a href='#pick_random_tips'>
<p>Pick random subsets of tips on a tree.</p></a></li>
<li><a href='#place_tips_taxonomically'>
<p>Place queries on a tree based on taxonomic identities.</p></a></li>
<li><a href='#read_tree'>
<p>Load a tree from a string or file in Newick (parenthetic) format.</p></a></li>
<li><a href='#reconstruct_past_diversification'>
<p>Reconstruct past diversification dynamics from a diversity time series.</p></a></li>
<li><a href='#reorder_tree_edges'>
<p>Reorder tree edges in preorder or postorder.</p></a></li>
<li><a href='#root_at_midpoint'>
<p>Root a tree at the midpoint node.</p></a></li>
<li><a href='#root_at_node'>
<p>Root a tree at a specific node.</p></a></li>
<li><a href='#root_in_edge'>
<p>Root a tree in the middle of an edge.</p></a></li>
<li><a href='#root_via_outgroup'>
<p>Root a tree based on an outgroup tip.</p></a></li>
<li><a href='#root_via_rtt'>
<p>Root a tree via root-to-tip regression.</p></a></li>
<li><a href='#shift_clade_times'>
<p>Shift the time of specific nodes &amp; tips.</p></a></li>
<li><a href='#simulate_bm_model'>
<p>Simulate a Brownian motion model for multivariate trait co-evolution.</p></a></li>
<li><a href='#simulate_deterministic_hbd'>
<p>Simulate a deterministic homogenous birth-death model.</p></a></li>
<li><a href='#simulate_deterministic_hbds'>
<p>Simulate a deterministic homogenous birth-death-sampling model.</p></a></li>
<li><a href='#simulate_diversification_model'>
<p>Simulate a deterministic uniform speciation/extinction model.</p></a></li>
<li><a href='#simulate_dsse'>
<p>Simulate a Discrete-State Speciation and Extinction (dSSE) model.</p></a></li>
<li><a href='#simulate_mk_model'>
<p>Simulate an Mk model for discrete trait evolution.</p></a></li>
<li><a href='#simulate_ou_model'>
<p>Simulate an Ornstein-Uhlenbeck model for continuous trait evolution.</p></a></li>
<li><a href='#simulate_rou_model'>
<p>Simulate a reflected Ornstein-Uhlenbeck model for continuous trait evolution.</p></a></li>
<li><a href='#simulate_sbm'>
<p>Simulate Spherical Brownian Motion on a tree.</p></a></li>
<li><a href='#simulate_tdsse'>
<p>Simulate a time-dependent Discrete-State Speciation and Extinction (tdSSE) model.</p></a></li>
<li><a href='#spline_coefficients'>
<p>Get the polynomial coefficients of a spline.</p></a></li>
<li><a href='#split_tree_at_height'>
<p>Split a tree into subtrees at a specific height.</p></a></li>
<li><a href='#tree_distance'>
<p>Calculate the distance between two trees.</p></a></li>
<li><a href='#tree_from_branching_ages'>
<p>Generate a random timetree with specific branching ages.</p></a></li>
<li><a href='#tree_from_sampling_branching_ages'>
<p>Generate a random timetree with specific tip/sampling and node/branching ages.</p></a></li>
<li><a href='#tree_imbalance'>
<p>Calculate various imbalance statistics for a tree.</p></a></li>
<li><a href='#trim_tree_at_height'>
<p>Trim a rooted tree down to a specific height.</p></a></li>
<li><a href='#write_tree'>
<p>Write a tree in Newick (parenthetic) format.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Phylogenetics on Large Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Stilianos Louca</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stilianos Louca &lt;louca.research@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient phylogenetic analyses on massive phylogenies comprising up to millions of tips. Functions include pruning, rerooting, calculation of most-recent common ancestors, calculating distances from the tree root and calculating pairwise distances. Calculation of phylogenetic signal and mean trait depth (trait conservatism), ancestral state reconstruction and hidden character prediction of discrete characters, simulating and fitting models of trait evolution, fitting and simulating diversification models, dating trees, comparing trees, and reading/writing trees in Newick format. Citation: Louca, Stilianos and Doebeli, Michael (2017) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx701">doi:10.1093/bioinformatics/btx701</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp (&ge; 0.12.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, naturalsort, stats, Matrix, RSpectra, jsonlite,
methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nloptr, ape</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 08:47:48 UTC; stilianoslouca</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 12:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='asr_empirical_probabilities'>
Empirical ancestral state probabilities.
</h2><span id='topic+asr_empirical_probabilities'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and the states of a discrete trait for each tip, calculate the empirical state frequencies/probabilities for each node in the tree, i.e. the frequencies/probabilities of states across all tips descending from that node. This may be used as a very crude estimate of ancestral state probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_empirical_probabilities(tree, tip_states, Nstates=NULL, 
                            probabilities=TRUE, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_empirical_probabilities_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_empirical_probabilities_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree as an integer from 1 to Nstates, where Nstates is the possible number of states (see below).
</p>
</td></tr>
<tr><td><code id="asr_empirical_probabilities_+3A_nstates">Nstates</code></td>
<td>

<p>Either <code>NULL</code>, or an integer specifying the number of possible states of the trait. If <code>NULL</code>, then it will be computed based on the maximum value encountered in <code>tip_states</code>
</p>
</td></tr>
<tr><td><code id="asr_empirical_probabilities_+3A_probabilities">probabilities</code></td>
<td>

<p>Logical, specifying whether empirical frequencies should be normalized to represent probabilities. If <code>FALSE</code>, then the raw occurrence counts are returned.
</p>
</td></tr>
<tr><td><code id="asr_empirical_probabilities_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g., characters or factors), you should map them to a set of integers 1,..,Nstates. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The function has asymptotic time complexity O(Nedges x Nstates).
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>ancestral_likelihoods</code></td>
<td>

<p>A 2D integer (if <code>probabilities==FALSE</code>) or numeric (if <code>probabilities==TRUE</code>) matrix, listing the frequency or probability of each state for each node. This matrix will have size Nnodes x Nstates, where Nstates was either explicitly provided as an argument or inferred from <code>tip_states</code>. The rows in this matrix will be in the order in which nodes are indexed in the tree, i.e. the [n,s]-th entry will be the frequency or probability of the s-th state for the n-th node. Note that the name was chosen for compatibility with other ASR functions.
</p>
</td></tr>
<tr><td><code>ancestral_states</code></td>
<td>

<p>Integer vector of length Nnodes, listing the ancestral states with highest probability. In the case of ties, the first state with maximum probability is chosen. This vector is computed based on <code>ancestral_likelihoods</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>, 
<code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
Ntips = 100
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# create a random transition matrix
Nstates = 3
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER", max_rate=0.01)
cat(sprintf("Simulated ER transition rate=%g\n",Q[1,2]))

# simulate the trait's evolution
simulation = simulate_mk_model(tree, Q)
tip_states = simulation$tip_states

# calculate empirical probabilities of tip states
asr_empirical_probabilities(tree, tip_states=tip_states, Nstates=Nstates)

## End(Not run)
</code></pre>

<hr>
<h2 id='asr_independent_contrasts'>
Ancestral state reconstruction via phylogenetic independent contrasts.
</h2><span id='topic+asr_independent_contrasts'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states for a continuous (numeric) trait using phylogenetic independent contrasts (PIC; Felsenstein, 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_independent_contrasts(tree, 
                          tip_states,
                          weighted    = TRUE, 
                          include_CI  = FALSE,
                          check_input = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_independent_contrasts_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_independent_contrasts_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the known state of each tip in the tree.
</p>
</td></tr>
<tr><td><code id="asr_independent_contrasts_+3A_weighted">weighted</code></td>
<td>

<p>Logical, specifying whether to weight tips and nodes by the inverse length of their incoming edge, as in the original method by Felsenstein (1985). If <code>FALSE</code>, edge lengths are treated as if they were 1.
</p>
</td></tr>
<tr><td><code id="asr_independent_contrasts_+3A_include_ci">include_CI</code></td>
<td>

<p>Logical, specifying whether to also calculate standard errors and confidence intervals for the reconstructed states under a Brownian motion model, as described by Garland et al (1999).
</p>
</td></tr>
<tr><td><code id="asr_independent_contrasts_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function traverses the tree in postorder (tips&ndash;&gt;root) and estimates the state of each node as a convex combination of the estimated states of its chilren. These estimates are the intermediate &quot;X&quot; variables introduced by Felsenstein (1985) in his phylogenetic independent contrasts method. For the root, this yields the same globally parsimonious state as the squared-changes parsimony algorithm implemented in <code>asr_squared_change_parsimony</code> (Maddison 1991). For any other node, PIC only yields locally parsimonious reconstructions, i.e. reconstructed states only depend on the subtree descending from the node (see discussion by Maddison 1991).
</p>
<p>If <code>weighted==TRUE</code>, then this function yields the same ancestral state reconstructions as
</p>
<p><code>ape::ace(phy=tree, x=tip_states, type="continuous", method="pic", model="BM", CI=FALSE)</code>
</p>
<p>in the <code>ape</code> package (v. 0.5-64). Note that in contrast to the CI95 returned by <code>ape::ace</code>, the confidence intervals calculated here have the same units as the trait and depend both on the tree topology as well as the tip states.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. This is the same as setting <code>weighted=FALSE</code>. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). Edges with length 0 will be adjusted internally to some tiny length if needed (if <code>weighted==TRUE</code>).
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>). All tip states must be non-NA; otherwise, consider using one of the functions for hidden-state-prediction (e.g., <code><a href="#topic+hsp_independent_contrasts">hsp_independent_contrasts</a></code>).
</p>
<p>The function has asymptotic time complexity O(Nedges).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>ancestral_states</code></td>
<td>

<p>A numeric vector of size Nnodes, listing the reconstructed state of each node. The entries in this vector will be in the order in which nodes are indexed in the tree.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size Nnodes, listing the phylogenetically estimated standard error for the state in each node, under a Brownian motion model. The standard errors have the same units as the trait and depend both on the tree topology as well as the tip states. Calculated as described by Garland et al. (1999, page 377). Only included if <code>include_CI==TRUE</code>.
</p>
</td></tr>
<tr><td><code>CI95</code></td>
<td>

<p>Numeric vector of size Nnodes, listing the radius (half width) of the 95% confidence interval of the state in each node. Confidence intervals have same units as the trait and depend both on the tree topology as well as the tip states. For each node, the confidence interval is calculated according to the Student's t-distribution with Npics degrees of freedom, where Npics is the number of internally calculated independent contrasts descending from the node [Garland et al, 1999]. Only included if <code>include_CI==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the Comparative Method. The American Naturalist. 125:1-15.
</p>
<p>W. P. Maddison (1991). Squared-change parsimony reconstructions of ancestral states for continuous-valued characters on a phylogenetic tree. Systematic Zoology. 40:304-314.
</p>
<p>T. Garland Jr., P. E. Midford, A. R. Ives (1999). An introduction to phylogenetically based statistical methods, with a new method for confidence intervals on ancestral values. American Zoologist. 39:374-388. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>,
<code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>,
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree, 
                               stationary_mean=0,
                               stationary_std=1,
                               decay_rate=0.001)$tip_states

# reconstruct node states via weighted PIC
asr = asr_independent_contrasts(tree, tip_states, weighted=TRUE, include_CI=TRUE)
node_states = asr$ancestral_states

# get lower bounds of 95% CIs
lower_bounds = node_states - asr$CI95
</code></pre>

<hr>
<h2 id='asr_max_parsimony'>
Maximum-parsimony ancestral state reconstruction.
</h2><span id='topic+asr_max_parsimony'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states for a discrete trait using maximum parsimony. Transition costs can vary between transitions, and can optionally be weighted by edge length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_max_parsimony(tree, tip_states, Nstates=NULL, 
                  transition_costs="all_equal",
                  edge_exponent=0, weight_by_scenarios=TRUE,
                  check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_max_parsimony_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree as an integer from 1 to Nstates, where Nstates is the possible number of states (see below).
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_nstates">Nstates</code></td>
<td>

<p>Either <code>NULL</code>, or an integer specifying the number of possible states of the trait. If <code>NULL</code>, then Nstates will be computed based on the maximum value encountered in <code>tip_states</code>
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_transition_costs">transition_costs</code></td>
<td>

<p>Either &quot;all_equal&quot;,&quot;sequential&quot;, &quot;proportional&quot;, &quot;exponential&quot;, or a quadratic non-negatively valued matrix of size Nstates x Nstates, specifying the transition costs between all possible states (which can include 0 as well as <code>Inf</code>). The [r,c]-th entry of the matrix is the cost of transitioning from state r to state c. The option &quot;all_equal&quot; specifies that all transitions are permitted and are equally costly. &quot;sequential&quot; means that only transitions between adjacent states are permitted from a node to its children, and all permitted transitions are equally costly. &quot;proportional&quot; means that all transitions are permitted, but the cost increases proportional to the distance between states. &quot;exponential&quot; means that all transitions are permitted, but the cost increases exponentially with the distance between states. The options &quot;sequential&quot; and &quot;proportional&quot; only make sense if states exhibit an order relation (as reflected in their integer representation).
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_edge_exponent">edge_exponent</code></td>
<td>

<p>Non-negative real-valued number. Optional exponent for weighting transition costs by the inverse length of edge lengths. If 0, edge lengths do not influence the ancestral state reconstruction (this is the conventional max-parsimony). If &gt;0, then at each edge the transition costs are multiplied by <code class="reqn">1/L^e</code>, where <code class="reqn">L</code> is the edge length and <code class="reqn">e</code> is the edge exponent. This parameter is mostly experimental; modify at your own discretion.
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_weight_by_scenarios">weight_by_scenarios</code></td>
<td>

<p>Logical, indicating whether to weight each optimal state of a node by the number of optimal maximum-parsimony scenarios in which the node is in that state. If FALSE, then all optimal states of a node are weighted equally (i.e. are assigned equal probabilities).
</p>
</td></tr>
<tr><td><code id="asr_max_parsimony_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. The order of states (if relevant) should be reflected in their integer representation. For example, if your original states are &quot;small&quot;, &quot;medium&quot; and &quot;large&quot; and <code>transition_costs=="sequential"</code>, it is advised to represent these states as integers 1,2,3. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>This function utilizes Sankoff's (1975) dynamic programming algorithm for determining the smallest number (or least costly if transition costs are uneven) of state changes along edges needed to reproduce the observed tip states. The function has asymptotic time complexity O(Ntips+Nnodes x Nstates).
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. If <code>edge_exponent</code> is 0, then edge lengths do not influence the result. If <code>edge_exponent!=0</code>, then all edges must have non-zero length. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). 
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. None of the input vectors or matrixes need include row or column names; if they do, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree, when the state of each tip is known. If some of the tips have unknown state, consider either pruning the tree to keep only tips with known states, or using the function <code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>.
</p>
<p>Not all datasets are consistent with all possible transition cost models, i.e., it could happen that for some peculiar datasets some rather constrained models (e.g. &quot;sequential&quot;) cannot possibly produce the data. In this case, castor will most likely return non-sensical ancestral state estimates and <code>total_cost=Inf</code>, although this has not thoroughly been tested.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>
<p>Boolean, indicating whether ASR was successful. If <code>FALSE</code>, the remaining returned elements may be undefined.</p>
</td></tr>
<tr><td><code>ancestral_likelihoods</code></td>
<td>

<p>A 2D numeric matrix, listing the probability of each node being in each state. This matrix will have size Nnodes x Nstates, where Nstates was either explicitly provided as an argument or inferred from <code>tip_states</code>. The rows in this matrix will be in the order in which nodes are indexed in the tree, i.e. the [n,s]-th entry will be the probability of the s-th state for the n-th node. These probabilities are calculated based on <code>scenario_counts</code> (see below), assuming that every maximum parsimony scenario is equally likely. Note that the name was chosen for compatibility with other ASR functions.
</p>
</td></tr>
<tr><td><code>scenario_counts</code></td>
<td>

<p>A 2D numeric matrix of size Nnodes x Nstates, listing for each node and each state the number of maximum parsimony scenarios in which the node was in the specific state. If only a single maximum parsimony scenario exists for the whole tree, then the sum of entries in each row will be one.
</p>
</td></tr>
<tr><td><code>ancestral_states</code></td>
<td>

<p>Integer vector of length Nnodes, listing the ancestral states with highest likelihoods. In the case of ties, the first state with maximum likelihood is chosen. This vector is computed based on <code>ancestral_likelihoods</code>.
</p>
</td></tr>
<tr><td><code>total_cost</code></td>
<td>
<p>Real number, specifying the total transition cost across the tree for the most parsimonious scenario. In the classical case where <code>transition_costs="all_equal"</code>, the <code>total_cost</code> equals the total number of state changes in the tree under the most parsimonious scenario. Under some constrained transition models (e.g., &quot;sequential&quot;), <code>total_cost</code> may sometimes be Inf, which basically means that the data violates the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. Sankoff (1975). Minimal mutation trees of sequences. SIAM Journal of Applied Mathematics. 28:35-42.
</p>
<p>J. Felsenstein (2004). Inferring Phylogenies. Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 10
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a discrete trait
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER")
tip_states = simulate_mk_model(tree, Q)$tip_states

# reconstruct node states via MPR
results = asr_max_parsimony(tree, tip_states, Nstates)
node_states = max.col(results$ancestral_likelihoods)

# print reconstructed node states
print(node_states)

## End(Not run)</code></pre>

<hr>
<h2 id='asr_mk_model'>
Ancestral state reconstruction with Mk models and rerooting
</h2><span id='topic+asr_mk_model'></span>

<h3>Description</h3>

<p>Ancestral state reconstruction of a discrete trait using a fixed-rates continuous-time Markov model (a.k.a. &quot;Mk model&quot;). This function can estimate the (instantaneous) transition matrix using maximum likelihood, or take a specified transition matrix. The function can optionally calculate marginal ancestral state likelihoods for each node in the tree, using the rerooting method by Yang et al. (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_mk_model( tree, 
              tip_states, 
              Nstates               = NULL, 
              tip_priors            = NULL, 
              rate_model            = "ER", 
              transition_matrix     = NULL, 
              include_ancestral_likelihoods = TRUE, 
              reroot                = TRUE,
              root_prior            = "auto", 
              Ntrials               = 1, 
              optim_algorithm       = "nlminb",
              optim_max_iterations  = 200,
              optim_rel_tol         = 1e-8,
              store_exponentials    = TRUE,
              check_input           = TRUE, 
              Nthreads              = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_mk_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree in terms of an integer from 1 to Nstates, where Ntips is the number of tips and Nstates is the number of possible states (see below). Can also be <code>NULL</code>. If <code>tip_states==NULL</code>, then <code>tip_priors</code> must not be <code>NULL</code> (see below).
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_nstates">Nstates</code></td>
<td>

<p>Either NULL, or an integer specifying the number of possible states of the trait. If <code>Nstates==NULL</code>, then it will be computed based on the maximum value encountered in <code>tip_states</code> or based on the number of columns in <code>tip_priors</code> (whichever is non-<code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_tip_priors">tip_priors</code></td>
<td>

<p>A 2D numeric matrix of size Ntips x Nstates, where Nstates is the possible number of states for the character modelled. Hence, <code>tip_priors[i,s]</code> is the likelihood of the observed state of tip i, if the tip's true state was in state s. For example, if you know for certain that a tip is in state k, then set <code>tip_priors[i,s]=1</code> for s=k and <code>tip_priors[i,s]=0</code> for all other s.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_rate_model">rate_model</code></td>
<td>

<p>Rate model to be used for fitting the transition rate matrix. Can be &quot;ER&quot; (all rates equal), &quot;SYM&quot; (transition rate i&ndash;&gt;j is equal to transition rate j&ndash;&gt;i), &quot;ARD&quot; (all rates can be different), &quot;SUEDE&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, all 'up' transitions are equal, all 'down' transitions are equal) or &quot;SRD&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, and each rate can be different). Can also be an index matrix that maps entries of the transition matrix to the corresponding independent rate parameter to be fitted. Diagonal entries should map to 0, since diagonal entries are not treated as independent rate parameters but are calculated from the remaining entries in the transition matrix. All other entries that map to 0 represent a transition rate of zero. The format of this index matrix is similar to the format used by the <code>ace</code> function in the <code>ape</code> package. <code>rate_model</code> is only relevant if <code>transition_matrix==NULL</code>.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_transition_matrix">transition_matrix</code></td>
<td>

<p>Either a numeric quadratic matrix of size Nstates x Nstates containing fixed transition rates, or <code>NULL</code>. The [r,c]-th entry in this matrix should store the transition rate from state r to state c. Each row in this matrix must have sum zero.
If <code>NULL</code>, then the transition rates will be estimated using maximum likelihood, based on the <code>rate_model</code> specified.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_root_prior">root_prior</code></td>
<td>

<p>Prior probability distribution of the root's states, used to calculate the model's overall likelihood from the root's marginal ancestral state likelihoods. Can be &quot;<code>flat</code>&quot; (all states equal), &quot;<code>empirical</code>&quot; (empirical probability distribution of states across the tree's tips), &quot;<code>stationary</code>&quot; (stationary probability distribution of the transition matrix), &quot;<code>likelihoods</code>&quot; (use the root's state likelihoods as prior) or &quot;<code>max_likelihood</code>&quot; (put all weight onto the state with maximum likelihood). If &quot;<code>stationary</code>&quot; and <code>transition_matrix==NULL</code>, then a transition matrix is first fitted using a flat root prior, and then used to calculate the stationary distribution. <code>root_prior</code> can also be a non-negative numeric vector of size Nstates and with total sum equal to 1.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_include_ancestral_likelihoods">include_ancestral_likelihoods</code></td>
<td>

<p>Include the marginal ancestral likelihoods for each node (conditional scaled state likelihoods) in the return values. Note that this may increase the computation time and memory needed, so you may set this to <code>FALSE</code> if you don't need marginal ancestral states.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_reroot">reroot</code></td>
<td>

<p>Reroot tree at each node when computing marginal ancestral likelihoods, according to Yang et al. (1995). This is the default and recommended behavior, but leads to increased computation time. If <code>FALSE</code>, ancestral likelihoods at each node are computed solely based on the subtree descending from that node, without rerooting. Caution: Rerooting is strictly speaking only valid if the Mk model is time-reversible (for example, if the transition matrix is symmetric). Do not use the rerooting method if <code>rate_model="ARD"</code>.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_ntrials">Ntrials</code></td>
<td>

<p>Number of trials (starting points) for fitting the transition matrix. Only relevant if <code>transition_matrix=NULL</code>. A higher number may reduce the risk of landing in a local non-global optimum of the likelihood function, but will increase computation time during fitting.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_optim_algorithm">optim_algorithm</code></td>
<td>

<p>Either &quot;optim&quot; or &quot;nlminb&quot;, specifying which optimization algorithm to use for maximum-likelihood estimation of the transition matrix. Only relevant if <code>transition_matrix==NULL</code>.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_optim_max_iterations">optim_max_iterations</code></td>
<td>

<p>Maximum number of iterations (per fitting trial) allowed for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_optim_rel_tol">optim_rel_tol</code></td>
<td>

<p>Relative tolerance (stop criterion) for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_store_exponentials">store_exponentials</code></td>
<td>

<p>Logical, specifying whether to pre-calculate and store exponentials of the transition matrix during calculation of ancestral likelihoods. This may reduce computation time because each exponential is only calculated once, but requires more memory since all exponentials are stored. 
</p>
<p>Only relevant if <code>include_ancestral_likelihoods==TRUE</code>, otherwise exponentials are never stored.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
<tr><td><code id="asr_mk_model_+3A_nthreads">Nthreads</code></td>
<td>

<p>Number of parallel threads to use for running multiple fitting trials simultaneously. This only makes sense if your computer has multiple cores/CPUs and if <code>Ntrials&gt;1</code>, and is only relevant if <code>transition_matrix==NULL</code>. This option is ignored on Windows, because Windows does not support forking.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. The order of states (if relevant) should be reflected in their integer representation. For example, if your original states are &quot;small&quot;, &quot;medium&quot; and &quot;large&quot; and <code>rate_model=="SUEDE"</code>, it is advised to represent these states as integers 1,2,3. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>This function allows the specification of the precise tip states (if these are known) using the vector <code>tip_states</code>. Alternatively, if some tip states are only known in terms of a probability distribution, you can pass these probability distributions using the matrix <code>tip_priors</code>. Note that exactly one of the two arguments, <code>tip_states</code> or <code>tip_priors</code>, must be non-<code>NULL</code>. 
</p>
<p>Tips must be represented in <code>tip_states</code> or <code>tip_priors</code> in the same order as in <code>tree$tip.label</code>. None of the input vectors or matrixes need include row or column names; if they do, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>The tree is either assumed to be complete (i.e. include all possible species), or to represent a random subset of species chosen independently of their states. The rerooting method by Yang et al (1995) is used to calculate the marginal ancestral state likelihoods for each node by treating the node as a root and calculating its conditional scaled likelihoods. Note that the re-rooting algorithm is strictly speaking only valid for reversible Mk models, that is, satisfying the criterion
</p>
<p style="text-align: center;"><code class="reqn">
\pi_i Q_{ij}=\pi_j Q_{ji},\quad\forall i,j,
</code>
</p>

<p>where <code class="reqn">Q</code> is the transition rate matrix and <code class="reqn">\pi</code> is the stationary distribution of the model. The rate models &ldquo;ER&rdquo;, 'SYM&rdquo;, &ldquo;SUEDE&rdquo; and &ldquo;SRD&rdquo; are reversible. For example, for &ldquo;SUEDE&rdquo; or &ldquo;SRD&rdquo; choose <code class="reqn">\pi_{i+1}=\pi_{i}Q_{i,i+1}/Q_{i+1,i}</code>. In contrast, &ldquo;ARD&rdquo; models are generally not reversible.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). This function is similar to <code>rerootingMethod</code> in the <code>phytools</code> package (v0.5-64) and similar to <code>ape::ace</code> (v4.1) with options <code>method="ML", type="discrete"</code> and <code>marginal=FALSE</code>, but tends to be much faster than <code>rerootingMethod</code> and <code>ace</code> for large trees.
</p>
<p>Internally, this function uses <code><a href="#topic+fit_mk">fit_mk</a></code> to estimate the transition matrix if the latter is not provided. If you only care about estimating the transition matrix but not the ancestral states, consider using the more versatile function <code><a href="#topic+fit_mk">fit_mk</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether ASR was successful. If <code>FALSE</code>, all other return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>Nstates</code></td>
<td>

<p>Integer, specifying the number of modeled trait states.
</p>
</td></tr>
<tr><td><code>transition_matrix</code></td>
<td>

<p>A numeric quadratic matrix of size Nstates x Nstates, containing the transition rates of the Markov model. The [r,c]-th entry is the transition rate from state r to state c. Will be the same as the input <code>transition_matrix</code>, if the latter was not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Log-likelihood of the observed tip states under the fitted (or provided) Mk model. If <code>transition_matrix</code> was <code>NULL</code> in the input, then this will be the log-likelihood maximized during fitting.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>Numeric, the Akaike Information Criterion for the fitted Mk model (if applicable), defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of independent fitted parameters and <code class="reqn">L</code> is the maximized likelihood. If the transition matrix was provided as input, then no fitting was performed and hence AIC will be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>ancestral_likelihoods</code></td>
<td>

<p>Optional, only returned if <code>include_ancestral_likelihoods</code> was <code>TRUE</code>. A 2D numeric matrix, listing the likelihood of each state at each node (marginal ancestral likelihoods). This matrix will have size Nnodes x Nstates, where Nstates was either explicitly provided as an argument, or inferred from <code>tip_states</code> or <code>tip_priors</code> (whichever was non-<code>NULL</code>). The rows in this matrix will be in the order in which nodes are indexed in the tree, i.e. the [n,s]-th entry will be the likelihood of the s-th state at the n-th node. For example, <code>likelihoods[1,3]</code> will store the likelihood of observing the tree's tip states (if <code>reroot=TRUE</code>) or the descending subtree's tip states (if <code>reroot=FALSE</code>), if the first node was in state 3. Note that likelihoods are rescaled (normalized) to sum to 1 for convenience and numerical stability. The marginal likelihoods at a node should not, however, be interpreted as a probability distribution among states.
</p>
</td></tr>
<tr><td><code>ancestral_states</code></td>
<td>

<p>Integer vector of length Nnodes, listing the ancestral states with highest likelihoods. In the case of ties, the first state with maximum likelihood is chosen. This vector is computed based on <code>ancestral_likelihoods</code> and is only included if <code>include_ancestral_likelihoods=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Z. Yang, S. Kumar and M. Nei (1995). A new method for inference of ancestral nucleotide and amino acid sequences. Genetics. 141:1641-1650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>,
<code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>,
<code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>,
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>,
<code><a href="#topic+fit_mk">fit_mk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 1000
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# create random transition matrix
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER", max_rate=0.01)
cat(sprintf("Simulated ER transition rate=%g\n",Q[1,2]))

# simulate the trait's evolution
simulation = simulate_mk_model(tree, Q)
tip_states = simulation$tip_states
cat(sprintf("Simulated states for last 20 nodes:\n"))
print(tail(simulation$node_states,20))

# reconstruct node states from simulated tip states
# at each node, pick state with highest marginal likelihood
results = asr_mk_model(tree, tip_states, Nstates, rate_model="ER", Ntrials=2)
node_states = max.col(results$ancestral_likelihoods)

# print Mk model fitting summary
cat(sprintf("Mk model: log-likelihood=%g\n",results$loglikelihood))
cat(sprintf("Fitted ER transition rate=%g\n",results$transition_matrix[1,2]))

# print reconstructed node states for last 20 nodes
print(tail(node_states,20))

## End(Not run)</code></pre>

<hr>
<h2 id='asr_squared_change_parsimony'>
Squared-change parsimony ancestral state reconstruction.
</h2><span id='topic+asr_squared_change_parsimony'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states for a continuous (numeric) trait using squared-change maximum parsimony (Maddison, 1991). Transition costs can optionally be weighted by the inverse edge lengths (&quot;weighted squared-change parsimony&quot; by Maddison).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_squared_change_parsimony(tree, tip_states,  weighted=TRUE, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_squared_change_parsimony_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_squared_change_parsimony_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the known state of each tip in the tree.
</p>
</td></tr>
<tr><td><code id="asr_squared_change_parsimony_+3A_weighted">weighted</code></td>
<td>

<p>Logical, specifying whether to weight transition costs by the inverted edge lengths. This corresponds to the &quot;weighted squared-change parsimony&quot; reconstruction by Maddison (1991) for a Brownian motion model of trait evolution.
</p>
</td></tr>
<tr><td><code id="asr_squared_change_parsimony_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function traverses the tree in postorder (tips&ndash;&gt;root) to calculate the quadratic parameters described by Maddison (1991) and obtain the globally parsimonious squared-change parsimony state for the root. The function then reroots at each node, updates all affected quadratic parameters in the tree and calculates the node's globally parsimonious squared-change parsimony state.
The function has asymptotic time complexity O(Nedges).
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. This is the same as setting <code>weighted=FALSE</code>. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). Edges with length 0 will be adjusted internally to some tiny length if needed (if <code>weighted==TRUE</code>).
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>If <code>weighted==FALSE</code>, then this function yields the same ancestral state reconstructions as
</p>
<p><code>ape::ace(tip_states, tree, type="continuous", method="ML", model="BM", CI=FALSE)</code> 
</p>
<p>in the <code>ape</code> package (v. 0.5-64), assuming the tree as unit edge lengths. If <code>weighted==TRUE</code>, then this function yields the same ancestral state reconstructions as the maximum likelihood estimates under a Brownian motion model, as implemented by the <code>Rphylopars</code> package (v. 0.2.10):
</p>
<p><code>Rphylopars::anc.recon(tip_states, tree, vars=FALSE, CI=FALSE).</code>
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>ancestral_states</code></td>
<td>

<p>A numeric vector of size Nnodes, listing the reconstructed state of each node. The entries in this vector will be in the order in which nodes are indexed in the tree.
</p>
</td></tr>
<tr><td><code>total_sum_of_squared_changes</code></td>
<td>

<p>The total sum of squared changes, minimized by the (optionally weighted) squared-change parsimony algorithm. This is equation 7 in (Maddison, 1991).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>W. P. Maddison (1991). Squared-change parsimony reconstructions of ancestral states for continuous-valued characters on a phylogenetic tree. Systematic Zoology. 40:304-314.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_independent_contrasts">asr_independent_contrasts</a></code>
<code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>,
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree, 
                               stationary_mean=0,
                               stationary_std=1,
                               decay_rate=0.001)$tip_states

# reconstruct node states based on simulated tip states
node_states = asr_squared_change_parsimony(tree, tip_states, weighted=TRUE)$ancestral_states
</code></pre>

<hr>
<h2 id='asr_subtree_averaging'>
Ancestral state reconstruction via subtree averaging.
</h2><span id='topic+asr_subtree_averaging'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states in a phylogenetic tree for a continuous (numeric) trait by averaging trait values over descending subtrees. That is, for each node the reconstructed state is set to the arithmetic average state of all tips descending from that node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr_subtree_averaging(tree, tip_states, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_subtree_averaging_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="asr_subtree_averaging_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the known state of each tip in the tree.
</p>
</td></tr>
<tr><td><code id="asr_subtree_averaging_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the estimated ancestral states (=averages) as well as the corresponding standard deviations. Note that reconstructed states are local estimates, i.e. they only take into account the tips descending from the reconstructed node.
</p>
<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). Edge lengths and distances between tips and nodes are not taken into account. All tip states are assumed to be known, and <code>NA</code> or <code>NaN</code> are not allowed in <code>tip_states</code>.
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether ASR was sucessful. If all input data are valid then this will always be <code>TRUE</code>, but it is provided for consistency with other ASR functions.
</p>
</td></tr>
<tr><td><code>ancestral_states</code></td>
<td>

<p>A numeric vector of size Nnodes, listing the reconstructed state (=average over descending tips) for each node. The entries in this vector will be in the order in which nodes are indexed in the tree.
</p>
</td></tr>
<tr><td><code>ancestral_stds</code></td>
<td>

<p>A numeric vector of size Nnodes, listing the standard deviations corresponding to <code>ancestral_stds</code>.
</p>
</td></tr>
<tr><td><code>ancestral_counts</code></td>
<td>

<p>A numeric vector of size Nnodes, listing the number of (descending) tips used to reconstruct the state of each node.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_independent_contrasts">asr_independent_contrasts</a></code>,
<code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree, stationary_mean=0, 
                               stationary_std=1, decay_rate=0.001)$tip_states

# reconstruct node states by averaging simulated tip states
node_states = asr_subtree_averaging(tree, tip_states)$ancestral_states
</code></pre>

<hr>
<h2 id='castor-package'>
Efficient computations on large phylogenetic trees.
</h2><span id='topic+castor-package'></span><span id='topic+castor'></span>

<h3>Description</h3>

<p>This package provides efficient tree manipulation functions including pruning, rerooting, calculation of most-recent common ancestors, calculating distances from the tree root and calculating pairwise distance matrices. Calculation of phylogenetic signal and mean trait depth (trait conservatism). Efficient ancestral state reconstruction and hidden character prediction of discrete characters on phylogenetic trees, using Maximum Likelihood and Maximum Parsimony methods. Simulating models of trait evolution, and generating random trees.
</p>


<h3>Details</h3>

<p>The most important data unit is a phylogenetic tree of class &quot;phylo&quot;, with the tree topology encoded in the member variable <code>tree.edge</code>. See the <code>ape</code> package manual for details on the &quot;phylo&quot; format. The castor package was designed to be efficient for large phylogenetic trees (&gt;10,000 tips), and scales well to trees with millions of tips. Most functions have asymptotically linear time complexity O(N) in the number of edges N. This efficiency is achived via temporary auxiliary data structures, use of dynamic programing, heavy use of C++, and integer-based indexing instead of name-based indexing of arrays. All functions support trees that include monofurcations (nodes with a single child) as well as multifurcations (nodes with more than 2 children). See the associated paper by Louca et al. for a comparison with other packages.
</p>
<p>Throughout this manual, &quot;Ntips&quot; refers to the number of tips, &quot;Nnodes&quot; to the number of nodes and &quot;Nedges&quot; to the number of edges in a tree. In the context of discrete trait evolution/reconstruction, &quot;Nstates&quot; refers to the number of possible states of the trait. In the context of multivariate trait evolution, &quot;Ntraits&quot; refers to the number of traits.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca
</p>
<p>Maintainer: Stilianos Louca &lt;louca@zoology.ubc.ca&gt;
</p>


<h3>References</h3>

<p>S. Louca and M. Doebeli (2017). Efficient comparative phylogenetics on large trees. Bioinformatics. DOI:10.1093/bioinformatics/btx701
</p>

<hr>
<h2 id='clade_densities'>
Estimate the density of tips &amp; nodes in a timetree.
</h2><span id='topic+clade_densities'></span>

<h3>Description</h3>

<p>Given a rooted timetree (i.e., a tree whose edge lengths represent time intervals), estimate the density of tips and nodes as a function of age (tips or nodes per time unit), on a discrete grid. Optionally the densities can be normalized by the local number of lineages. If the tree is full (includes all extinct &amp; extant clades), then the normalized tip (node) density is an estimate for the per-capita extinction (speciation) rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clade_densities(tree, 
                Nbins       = NULL,
                min_age     = NULL,
                max_age     = NULL,
                normalize   = TRUE,
                ultrametric	= FALSE)		
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clade_densities_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;, where edge lengths represent time intervals (or similar).
</p>
</td></tr>
<tr><td><code id="clade_densities_+3A_nbins">Nbins</code></td>
<td>

<p>Integer, number of equidistant age bins at which to calculate densities.
</p>
</td></tr>
<tr><td><code id="clade_densities_+3A_min_age">min_age</code></td>
<td>

<p>Numeric, minimum age to consider. If <code>NULL</code>, it will be set to the minimum possible.
</p>
</td></tr>
<tr><td><code id="clade_densities_+3A_max_age">max_age</code></td>
<td>

<p>Numeric, maximum age to consider. If <code>NULL</code>, it will be set to the maximum possible.
</p>
</td></tr>
<tr><td><code id="clade_densities_+3A_normalize">normalize</code></td>
<td>

<p>Logical, whether to normalize densities by the local number of lineages (in addition to dividing by the age interval). Hence, tip (or node) densities will represent number of tips (or nodes) per time unit per lineage.
</p>
</td></tr>
<tr><td><code id="clade_densities_+3A_ultrametric">ultrametric</code></td>
<td>

<p>Logical, specifying whether the input tree is guaranteed to be ultrametric, even in the presence of some numerical inaccuracies causing some tips not have exactly the same distance from the root.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes the full considered age range (from <code>min_age</code> to <code>max_age</code>) into <code>Nbins</code> discrete disjoint bins, then computes the number of tips and nodes in each bin, and finally divides those numbers by the bin width. If <code>normalize==True</code>, the densities are further divided by the number of lineages in the middle of each age bin. For typical timetrees it is generally recommended to omit the most recent tips (i.e., extant at age 0), by setting <code>min_age</code> to a small non-zero value; otherwise, the first age bin will typically be associated with a high tip density, i.e., tip densities will be zero-inflated.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Nbins</code></td>
<td>

<p>Integer, indicating the number of discrete age bins.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>

<p>Numeric vector of size Nbins, listing the centres of the age bins.
</p>
</td></tr>
<tr><td><code>tip_densities</code></td>
<td>

<p>Numeric vector of size Nbins, listing the tip densities in the corresponding age bins.
</p>
</td></tr>
<tr><td><code>node_densities</code></td>
<td>

<p>Numeric vector of size Nbins, listing the node densities in the corresponding age bins.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p>count_lineages_through_time
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random full tree, including all extinct &amp; extant tips
tree = generate_random_tree(list(birth_rate_intercept=1), 
                            max_tips=1000, coalescent=FALSE)$tree

# compute node densities, as an estimate for the speciation rate
densities = clade_densities(tree, Nbins=10, normalize=TRUE)

# plot node densities
plot(densities$ages, densities$node_densities, type="l", xlab="age", ylab="node density")
</code></pre>

<hr>
<h2 id='collapse_monofurcations'>
Remove monofurcations from a tree.
</h2><span id='topic+collapse_monofurcations'></span>

<h3>Description</h3>

<p>Eliminate monofurcations (nodes with only a single child) from a phylogenetic tree, by connecting their incoming and outgoing edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_monofurcations(tree, force_keep_root=TRUE, as_edge_counts=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_monofurcations_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="collapse_monofurcations_+3A_force_keep_root">force_keep_root</code></td>
<td>

<p>Logical, indicating whether the root node should always be kept (i.e., even if it only has a single child).
</p>
</td></tr>
<tr><td><code id="collapse_monofurcations_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, indicating whether all edges should be assumed to have length 1. If <code>TRUE</code>, the outcome is the same as if the tree had no edges.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All tips in the input tree retain their original indices, however the returned tree may include fewer nodes and edges. Edge and node indices may change.
</p>
<p>If <code>tree$edge.length</code> is missing, then all edges in the input tree are assumed to have length 1.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing only bifurcations (and multifurcations, if these existed in the input tree). The number of nodes in this tree, Nnodes_new, may be lower than of the input tree.
</p>
</td></tr>
<tr><td><code>new2old_node</code></td>
<td>

<p>Integer vector of length Nnodes_new, mapping node indices in the new tree to node indices in the old tree.
</p>
</td></tr>
<tr><td><code>Nnodes_removed</code></td>
<td>

<p>Integer. Number of nodes (monofurcations) removed from the tree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+multifurcations_to_bifurcations">multifurcations_to_bifurcations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1), max_tips=Ntips)$tree

# prune the tree to generate random monofurcations
random_tips = sample.int(n=Ntips, size=0.5 * Ntips, replace=FALSE)
tree = get_subtree_with_tips(tree, only_tips=random_tips, collapse_monofurcations=FALSE)$subtree

# collapse monofurcations
new_tree = collapse_monofurcations(tree)$tree

# print summary of old and new tree
cat(sprintf("Old tree has %d nodes\n",tree$Nnode))
cat(sprintf("New tree has %d nodes\n",new_tree$Nnode))
</code></pre>

<hr>
<h2 id='collapse_tree_at_resolution'>
Collapse nodes of a tree at a phylogenetic resolution.
</h2><span id='topic+collapse_tree_at_resolution'></span>

<h3>Description</h3>

<p>Given a rooted tree and a phylogenetic resolution threshold, collapse all nodes whose distance to all descending tips does not exceed the threshold (or whose sum of descending edge lengths does not exceed the threshold), into new tips. This function can be used to obtain a &quot;coarser&quot; version of the tree, or to cluster closely related tips into a single tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_tree_at_resolution(tree, 
                            resolution             = 0, 
                            by_edge_count          = FALSE,
                            shorten                = TRUE,
                            rename_collapsed_nodes = FALSE,
                            criterion              = 'max_tip_depth')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_tree_at_resolution_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="collapse_tree_at_resolution_+3A_resolution">resolution</code></td>
<td>

<p>Numeric, specifying the phylogenetic resolution at which to collapse the tree. This is the maximum distance a descending tip can have from a node, such that the node is collapsed into a new tip. If set to 0 (default), then only nodes whose descending tips are identical to the node will be collapsed.
</p>
</td></tr>
<tr><td><code id="collapse_tree_at_resolution_+3A_by_edge_count">by_edge_count</code></td>
<td>

<p>Logical. Instead of considering edge lengths, consider edge counts as phylogenetic distance between nodes and tips. This is the same as if all edges had length equal to 1.
</p>
</td></tr>
<tr><td><code id="collapse_tree_at_resolution_+3A_shorten">shorten</code></td>
<td>

<p>Logical, indicating whether collapsed nodes should be turned into tips at the same location (thus potentially shortening the tree). If <code>FALSE</code>, then the incoming edge of each collapsed node is extended by some length L, where L is the distance of the node to its farthest descending tip (thus maintaining the height of the tree).
</p>
</td></tr>
<tr><td><code id="collapse_tree_at_resolution_+3A_rename_collapsed_nodes">rename_collapsed_nodes</code></td>
<td>

<p>Logical, indicating whether collapsed nodes should be renamed using a representative tip name (the farthest descending tip). See details below.
</p>
</td></tr>
<tr><td><code id="collapse_tree_at_resolution_+3A_criterion">criterion</code></td>
<td>

<p>Character, specifying the criterion to use for collapsing (i.e. how to interpret <code>resolution</code>). '<code>max_tip_depth</code>': Collapse nodes based on their maximum distance to any descending tip. '<code>sum_tip_paths</code>': Collapse nodes based on the sum of descending edges (each edge counted once). '<code>max_tip_pair_dist</code>': Collapse nodes based on the maximum distance between any pair of descending tips.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree is traversed from root to tips and nodes are collapsed into tips as soon as the criterion equals or falls below the resolution threshold.
</p>
<p>The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
Tip labels and uncollapsed node labels of the collapsed tree are inheritted from the original tree. If <code>rename_collapsed_nodes==FALSE</code>, then labels of collapsed nodes will be the node labels from the original tree (in this case the original tree should include node labels). If <code>rename_collapsed_nodes==TRUE</code>, each collapsed node is given the label of its farthest descending tip. If <code>shorten==TRUE</code>, then edge lengths are the same as in the original tree. If <code>shorten==FALSE</code>, then edges leading into collapsed nodes may be longer than before.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, containing the collapsed tree.
</p>
</td></tr>
<tr><td><code>root_shift</code></td>
<td>

<p>Numeric, indicating the phylogenetic distance between the old and the new root. Will always be non-negative.
</p>
</td></tr>
<tr><td><code>collapsed_nodes</code></td>
<td>

<p>Integer vector, listing indices of collapsed nodes in the original tree (subset of 1,..,Nnodes).
</p>
</td></tr>
<tr><td><code>farthest_tips</code></td>
<td>

<p>Integer vector of the same length as <code>collapsed_nodes</code>, listing indices of the farthest tips for each collapsed node. Hence, <code>farthest_tips[n]</code> will be the index of a tip in the original tree that descended from node <code>collapsed_nodes[n]</code> and had the greatest distance from that node among all descending tips.
</p>
</td></tr>
<tr><td><code>new2old_clade</code></td>
<td>

<p>Integer vector of length equal to the number of tips+nodes in the collapsed tree, with values in 1,..,Ntips+Nnodes, mapping tip/node indices of the collapsed tree to tip/node indices in the original tree.
</p>
</td></tr>
<tr><td><code>new2old_edge</code></td>
<td>

<p>Integer vector of length equal to the number of edges in the collapsed tree, with values in 1,..,Nedges, mapping edge indices of the collapsed tree to edge indices in the original tree.
</p>
</td></tr>
<tr><td><code>old2new_clade</code></td>
<td>

<p>Integer vector of length equal to the number of tips+nodes in the original tree, mapping tip/node indices of the original tree to tip/node indices in the collapsed tree. Non-mapped tips/nodes (i.e., missing from the collapsed tree) will be represented by zeros.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# print number of nodes
cat(sprintf("Simulated tree has %d nodes\n",tree$Nnode))

# collapse any nodes with tip-distances &lt; 20
collapsed = collapse_tree_at_resolution(tree, resolution=20)$tree

# print number of nodes
cat(sprintf("Collapsed tree has %d nodes\n",collapsed$Nnode))
</code></pre>

<hr>
<h2 id='congruent_divergence_times'>
Extract dating anchors for a target tree, using a dated reference tree
</h2><span id='topic+congruent_divergence_times'></span>

<h3>Description</h3>

<p>Given a reference tree and a target tree, this function maps target nodes to concordant reference nodes when possible, and extracts divergence times of the mapped reference nodes from the reference tree. This function can be used to define secondary dating constraints for a larger target tree, based on a time-calibrated smaller reference tree (Eastman et al. 2013). This only makes sense if the reference tree is time-calibrated. A provided mapping specifies which and how tips in the target tree correspond to tips in the reference tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruent_divergence_times(reference_tree, target_tree, mapping)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruent_divergence_times_+3A_reference_tree">reference_tree</code></td>
<td>

<p>A rooted tree object of class &quot;phylo&quot;. Usually this tree will be time-calibrated (i.e. edge lengths represent time intervals).
</p>
</td></tr>
<tr><td><code id="congruent_divergence_times_+3A_target_tree">target_tree</code></td>
<td>

<p>A rooted tree object of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="congruent_divergence_times_+3A_mapping">mapping</code></td>
<td>

<p>A table mapping a subset of target tips to a subset of reference tips, as described by Eastman et al (2013). Multiple target tips may map to the same reference tip, but not vice versa (i.e. every target tip can appear at most once in the mapping). In general, a tip mapped to in the reference tree is assumed to represent a monophyletic group of tips in the target tree, although this assumption may be violated in practice (Eastman et al. 2013). 
</p>
<p>The <code>mapping</code> must be in one of the following formats:
</p>
<p>Option 1: A 2D integer array of size NM x 2 (with NM being the number of mapped target tips), listing target tip indices mapped to reference tip indices (mapping[m,1] (target tip) &ndash;&gt; mapping[m,2] (reference tip)). 
</p>
<p>Option 2: A 2D character array of size NM x 2, listing target tip labels mapped to reference tip labels. 
</p>
<p>Option 3: A data frame of size NM x 1, whose row names are target tip labels and whose entries are either integers (reference tip indices) or characters (reference tip labels). This is the format used by <code>geiger::congruify.phylo</code> (v.206). 
</p>
<p>Option 4: A vector of size NM, whose names are target tip labels and whose entries are either integers (reference tip indices) or characters (reference tip labels).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both the reference and target tree may include monofurcations and/or multifurcations. In principle, neither of the two trees needs to be ultrametric, although in most applications <code>reference_tree</code> will be ultrametric. 
</p>
<p>In special cases each reference tip may be found in the target tree, i.e. the reference tree is a subtree of the target tree. This may occur e.g. if a smaller subtree of the target tree has been extracted and dated, and subsequently the larger target tree is to be dated using secondary constraints inferred from the dated subtree.
</p>
<p>The function returns a table that maps a subset of target nodes to an equally sized subset of concordant reference nodes. Ages (divergence times) of the mapped reference nodes are extracted and associated with the concordant target nodes.
</p>
<p>For bifurcating trees the average time complexity of this function is O(TNtips x log(RNtips) x NM), where TNtips and RNtips are the number of tips in the target and reference tree, respectively. This function is similar to <code>geiger::congruify.phylo</code> (v.206). For large trees, this function tends to be much faster than <code>geiger::congruify.phylo</code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>Rnodes</code></td>
<td>

<p>Integer vector of length NC (where NC is the number of concordant node pairs found) and with values in 1,..,RNnodes, listing indices of reference nodes that could be matched with (i.e. were concordant to) a target node. Entries in <code>Rnodes</code> will correspond to entries in <code>Tnodes</code> and <code>ages</code>.
</p>
</td></tr>
<tr><td><code>Tnodes</code></td>
<td>

<p>Integer vector of length NC and with values in 1,..,TNnodes, listing indices of target nodes that could be matched with (i.e. were concordant to) a reference node. Entries in <code>Tnodes</code> will correspond to entries in <code>Rnodes</code> and <code>ages</code>.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>

<p>Numeric vector of length NC, listing divergence times (ages) of the reference nodes listed in <code>Rnodes</code>. These ages can be used as fixed anchors for time-calibrating the target tree using a separate program (such as <code>PATHd8</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. M. Eastman, L. J. Harmon, D. C. Tank (2013). Congruification: support for time scaling large phylogenetic trees. Methods in Ecology and Evolution. 4:688-691.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extend_tree_to_height">extend_tree_to_height</a></code>,
<code><a href="#topic+date_tree_red">date_tree_red</a></code>,
<code><a href="#topic+get_tips_for_mrcas">get_tips_for_mrcas</a></code>,
<code><a href="#topic+tree_distance">tree_distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree (target tree)
Ntips = 10000
tree  = castor::generate_random_tree(parameters=list(birth_rate_intercept=1), max_tips=Ntips)$tree

# extract random subtree (reference tree)
Nsubtips    = 10
subtips     = sample.int(n=Ntips,size=Nsubtips,replace=FALSE)
subtreeing  = castor::get_subtree_with_tips(tree, only_tips=subtips)
subtree     = subtreeing$subtree

# map subset of target tips to reference tips
mapping = matrix(c(subtreeing$new2old_tip,(1:Nsubtips)),ncol=2,byrow=FALSE)

# extract divergence times by congruification
congruification = congruent_divergence_times(subtree, tree, mapping)

cat("Concordant target nodes:\n")
print(congruification$target_nodes)

cat("Ages of concordant nodes:\n")
print(congruification$ages)
</code></pre>

<hr>
<h2 id='congruent_hbds_model'>
Generate a congruent homogenous-birth-death-sampling model.
</h2><span id='topic+congruent_hbds_model'></span>

<h3>Description</h3>

<p>Given a homogenous birth-death-sampling (HBDS) model (or abstract congruence class), obtain the congruent model (or member of the congruence class) with a specific speciation rate <code class="reqn">\lambda</code>, or extinction rate <code class="reqn">\mu</code>, or sampling rate <code class="reqn">\psi</code>, or effective reproduction ratio <code class="reqn">R_e</code> or removal rate <code class="reqn">\mu+\psi</code> (aka. &quot;become uninfectious&quot;&quot; rate). All input and output time-profiles are specified as piecewise polynomial curves (splines), defined on a discrete grid of ages. This function allows exploration of a model's congruence class, by obtaining various members of the congruence class depending on the specified <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code>, <code class="reqn">R_e</code> or removal rate. For more details on HBDS models and congruence classes see the documentation of <code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruent_hbds_model(age_grid,
                     PSR,
                     PDR,
                     lambda_psi,
                     lambda             = NULL,
                     mu                 = NULL,
                     psi                = NULL,
                     Reff               = NULL,
                     removal_rate       = NULL,
                     lambda0            = NULL,
                     CSA_ages           = NULL,
                     CSA_pulled_probs   = NULL,
                     CSA_PSRs           = NULL,
                     splines_degree     = 1,
                     ODE_relative_dt    = 0.001,
                     ODE_relative_dy    = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruent_hbds_model_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing discrete ages (time before present) on which the various model variables (e.g., <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> etc) are specified. Listed ages must be strictly increasing, and must include the present-day (i.e. age 0).
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_psr">PSR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the pulled speciation rate (PSR) (in units 1/time) at the ages listed in <code>age_grid</code>. The PSR is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code>PSR</code> is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_pdr">PDR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the pulled diversification rate (PDR) (in units 1/time) at the ages listed in <code>age_grid</code>. The PDR is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). The PDR of a HBDS model is defined as <code class="reqn">PDR=\lambda-\mu-\psi+(1/\lambda)d\lambda/dt</code> (where <code class="reqn">t</code> denotes age). Can also be a single number, in which case <code>PDR</code> is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_lambda_psi">lambda_psi</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the product of speciation rate and sampling rate (<code class="reqn">\lambda\psi</code>, in units 1/time^2) at the ages listed in <code>age_grid</code>. <code class="reqn">\lambda\psi</code> is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code class="reqn">\lambda\psi</code> is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the speciation rate (<code class="reqn">\lambda</code>, in units 1/time) at the ages listed in <code>age_grid</code>. The speciation rate is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code class="reqn">\lambda</code> is assumed to be time-independent. By providing <code class="reqn">\lambda</code>, one can select a specific model from the congruence class. Note that exactly one of <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>Reff</code> or <code>removal_rate</code> must be provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the extinction rate (<code class="reqn">\mu</code>, in units 1/time) at the ages listed in <code>age_grid</code>. The extinction rate is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code class="reqn">\mu</code> is assumed to be time-independent. In an epidemiological context, <code class="reqn">\mu</code> typically corresponds to the recovery rate plus the death rate of infected individuals. By providing <code class="reqn">\mu</code> (together with <code>lambda0</code>, see below), one can select a specific model from the congruence class. Note that exactly one of <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>Reff</code> or <code>removal_rate</code> must be provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_psi">psi</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the (Poissonian) sampling rate (<code class="reqn">\psi</code>, in units 1/time) at the ages listed in <code>age_grid</code>. The sampling rate is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code class="reqn">\psi</code> is assumed to be time-independent. By providing <code class="reqn">\psi</code>, one can select a specific model from the congruence class. Note that exactly one of <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>Reff</code> or <code>removal_rate</code> must be provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_reff">Reff</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the effective reproduction ratio (<code class="reqn">R_e</code>, unitless) at the ages listed in <code>age_grid</code>. The <code class="reqn">R_e</code> is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case <code class="reqn">R_e</code> is assumed to be time-independent. By providing <code class="reqn">R_e</code> (together with <code>lambda0</code>, see below), one can select a specific model from the congruence class. Note that exactly one of <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>Reff</code> or <code>removal_rate</code> must be provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_removal_rate">removal_rate</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code>, specifying the removal rate (<code class="reqn">\mu+\psi</code>, in units 1/time) at the ages listed in <code>age_grid</code>. IN an epidemiological context this is also known as &quot;become uninfectious&quot; rate. The removal rate is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be a single number, in which case the removal rate is assumed to be time-independent. By providing <code class="reqn">\mu+\psi</code> (together with <code>lambda0</code>, see below), one can select a specific model from the congruence class. Note that exactly one of <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>Reff</code> or <code>removal_rate</code> must be provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_lambda0">lambda0</code></td>
<td>

<p>Numeric, specifying the speciation rate at the present-day (i.e., at age 0). Must be provided if and only if one of <code>mu</code>, <code>Reff</code> or <code>removal_rate</code> is provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_csa_ages">CSA_ages</code></td>
<td>

<p>Optional numeric vector, listing the ages of concentrated sampling attempts, in ascending order. Concentrated sampling is assumed to occur in addition to any continuous (Poissonian) sampling specified by <code>psi</code>.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_csa_pulled_probs">CSA_pulled_probs</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_ages</code>, listing pulled sampling probabilities at each concentrated sampling attempt (CSA). Note that in contrast to the sampling rates <code>psi</code>, the <code>CSA_pulled_probs</code> are interpreted as probabilities and must thus be between 0 and 1. <code>CSA_pulled_probs</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_csa_psrs">CSA_PSRs</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_ages</code>, specifying the pulled sampling rate (PSR) during each concentrated sampling attempt. While in principle the PSR is already provided by the argument <code>PSR</code>, the PSR may be non-continuous at CSAs, which makes a representation as piecewise polynomial function difficult; hence, you must explicitly provide the correct PSR at each CSA. <code>CSA_PSRs</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided time-dependent variables between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided PDR, PSR and so on are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> they are interpreted as quadratic splines; if <code>splines_degree==3</code> they are interpreted as cubic splines. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_ode_relative_dt">ODE_relative_dt</code></td>
<td>

<p>Positive unitless number, specifying the default relative time step for internally used ordinary differential equation solvers. Typical values are 0.01-0.001.
</p>
</td></tr>
<tr><td><code id="congruent_hbds_model_+3A_ode_relative_dy">ODE_relative_dy</code></td>
<td>

<p>Positive unitless number, specifying the relative difference between subsequent simulated and interpolated values, in internally used ODE solvers. Typical values are 1e-2 to 1e-5. A smaller <code>ODE_relative_dy</code> increases interpolation accuracy, but also increases memory requirements and adds runtime.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDR, PSR and the product <code class="reqn">\lambda\psi</code> are variables that are invariant across the entire congruence class of an HBDS model, i.e. any two congruent models have the same PSR, PDR and product <code class="reqn">\lambda\psi</code>. Reciprocally, any HBDS congruence class is fully determined by its PDR, PSR and <code class="reqn">\lambda\psi</code>. This function thus allows &quot;collapsing&quot; a congruence class down to a single member (a specific HBDS model) by specifying one or more additional variables over time (such as <code class="reqn">\lambda</code>, or <code class="reqn">\psi</code>, or <code class="reqn">\mu</code> and <code class="reqn">\lambda_0</code>). Alternatively, this function may be used to obtain alternative models that are congruent to some reference model, for example to explore the robustness of specific epidemiological quantities of interest. The function returns a specific HBDS model in terms of the time profiles of various variables (such as <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\psi</code>).
</p>
<p>In the current implementation it is assumed that any sampled lineages are immediately removed from the pool, that is, this function cannot accommodate models with a non-zero retention probability upon sampling. This is a common assumption in molecular epidemiology.
Note that in this function age always refers to time before present, i.e., present day age is 0, and age increases towards the root.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the calculation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) providing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>valid</code></td>
<td>

<p>Logical, indicating whether the returned model appears to be biologically valid (for example, does not have negative <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> or <code class="reqn">\psi</code>). In principle, a congruence class may include biologically invalid models, which might be returned depending on the input to <code>congruent_hbds_model</code>. Note that only biologically valid models can be subsequently simulated using <code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>
<p>Numeric vector of size NG, specifying the discrete ages (time before present) on which all returned time-curves are specified. Will always be equal to <code>age_grid</code>.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Numeric vector of size NG, listing the speciation rates <code class="reqn">\lambda</code> of the returned model at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Numeric vector of size NG, listing the extinction rates <code class="reqn">\mu</code> of the returned model at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>Numeric vector of size NG, listing the (Poissonian) sampling rates <code class="reqn">\psi</code> of the returned model at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>lambda_psi</code></td>
<td>
<p>Numeric vector of size NG, listing the product <code class="reqn">\lambda\psi</code> at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>Reff</code></td>
<td>
<p>Numeric vector of size NG, listing the effective reproduction ratio <code class="reqn">R_e</code> of the returned model at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>removal_rate</code></td>
<td>
<p>Numeric vector of size NG, listing the removal rate (<code class="reqn">\mu+\psi</code>, aka. &quot;become uninfectious&quot; rate) of the returned model at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>Pmissing</code></td>
<td>
<p>Numeric vector of size NG, listing the probability that a past lineage extant during <code>ages[]</code> will be missing from a tree generated by the model.
</p>
</td></tr>
<tr><td><code>CSA_probs</code></td>
<td>
<p>Numeric vector of the same size as <code>CSA_ages</code>, listing the sampling probabilities at each of the CSAs.</p>
</td></tr>
<tr><td><code>CSA_Pmissings</code></td>
<td>
<p>Numeric vector of the same size as <code>CSA_ages</code>, listing the probability that a past lineage extant during each of <code>CSA_ages[]</code> will be missing from a tree generated by the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler, D. Kuehnert, S. Bonhoeffer, A. J. Drummond (2013). Birth-death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV). PNAS. 110:228-233.
</p>
<p>A. MacPherson, S. Louca, A. McLaughlin, J. B. Joy, M. W. Pennell (in review as of 2020). A general birth-death-sampling model for epidemiology and macroevolution. DOI:10.1101/2020.10.10.334383
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_tree_hbds">generate_tree_hbds</a></code>,
<code><a href="#topic+fit_hbds_model_parametric">fit_hbds_model_parametric</a></code>,
<code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an HBDS model with exponentially decreasing speciation/extinction rates
# and constant Poissonian sampling rate psi
oldest_age= 10
age_grid  = seq(from=0,to=oldest_age,by=0.1) # choose a sufficiently fine age grid
lambda    = 1*exp(0.01*age_grid) # define lambda on the age grid
mu        = 0.2*lambda # assume similarly shaped but smaller mu

# simulate deterministic HBD model
# scale LTT such that it is 100 at age 1
sim = simulate_deterministic_hbds(age_grid  = age_grid,
                                  lambda    = lambda,
                                  mu        = mu,
                                  psi       = 0.1,
                                  age0      = 1,
                                  LTT0      = 100)
                                         
# calculate a congruent HBDS model with an alternative sampling rate
# use the previously simulated variables to define the congruence class
new_psi = 0.1*exp(-0.01*sim$ages) # consider a psi decreasing with age
congruent = congruent_hbds_model(age_grid   = sim$ages,
                                 PSR        = sim$PSR,
                                 PDR        = sim$PDR,
                                 lambda_psi = sim$lambda_psi,
                                 psi        = new_psi)
											 
# compare the deterministic LTT of the two models
# to confirm that the models are indeed congruent
if(!congruent$valid){
    cat("WARNING: Congruent model is not biologically valid\n")
}else{
    # simulate the congruent model to get the LTT
    csim = simulate_deterministic_hbds(age_grid = congruent$ages,
                                       lambda   = congruent$lambda,
                                       mu       = congruent$mu,
                                       psi      = congruent$psi,
                                       age0     = 1,
                                       LTT0     = 100)

    # plot deterministic LTT of the original and congruent model
    plot( x = sim$ages, y = sim$LTT, type='l',
          main='dLTT', xlab='age', ylab='lineages', 
          xlim=c(oldest_age,0), col='red')
    lines(x= csim$ages, y=csim$LTT, 
          type='p', pch=21, col='blue')
}
</code></pre>

<hr>
<h2 id='consensus_taxonomies'>
Compute consensus taxonomies across a tree.
</h2><span id='topic+consensus_taxonomies'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and taxonomies for all tips, compute corresponding consensus taxonomies for all nodes in the tree based on their descending tips. The consensus taxonomy of a given node is the longest possible taxonomic path (i.e., to the lowest possible level) such that the taxonomies of all descending tips are nested within that taxonomic path. Some tip taxonomies may be incomplete, i.e., truncated at higher taxonomic levels. In that case, consensus taxonomy building will be conservative, i.e., no assumptions will be made about the missing taxonomic levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_taxonomies(tree, tip_taxonomies = NULL, delimiter = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_taxonomies_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="consensus_taxonomies_+3A_tip_taxonomies">tip_taxonomies</code></td>
<td>

<p>Optional, character vector of length Ntips, listing taxonomic paths for the tips. If <code>NULL</code>, then tip labels in the tree are assumed to be tip taxonomies.
</p>
</td></tr>
<tr><td><code id="consensus_taxonomies_+3A_delimiter">delimiter</code></td>
<td>

<p>Character, the delimiter between taxonomic levels (e.g., &quot;;&quot; for SILVA and Greengenes taxonomies).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples:
</p>

<ul>
<li><p> If the descending tips of a node have taxonomies &quot;A;B;C&quot; and &quot;A;B;C;D&quot; and &quot;A;B;C;E&quot;, then their consensus taxonomy is &quot;A;B;C&quot;.
</p>
</li>
<li><p> If the descending tips of a node have taxonomies &quot;A;B&quot; and &quot;A;B;C;D&quot; and &quot;A;B;C;E&quot;, then their consensus taxonomy is &quot;A;B&quot;.
</p>
</li>
<li><p> If the descending tips of a node have taxonomies &quot;X;B;C&quot; and &quot;Y;B;C&quot;, then their consensus taxonomy is &quot;&quot; (i.e., empty).
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector of length Nnodes, listing the inferred consensus taxonomies for all nodes in the tree.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+place_tips_taxonomically">place_tips_taxonomically</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_factor=0.1), max_tips=7)$tree

# define a character vector storing hypothetical tip taxonomies
tip_taxonomies = c("R;BB;C", "AA;BB;C;DD", "AA;BB;C;E", 
                   "AA;BB", "AA;BB;D", "AA;BB;C;F", "AA;BB;C;X")

# compute consensus taxonomies and store them in the tree as node labels
tree$node.label = castor::consensus_taxonomies(tree, 
                                               tip_taxonomies = tip_taxonomies, 
                                               delimiter = ";")
</code></pre>

<hr>
<h2 id='consentrait_depth'>
Calculate phylogenetic depth of a binary trait using the consenTRAIT metric.
</h2><span id='topic+consentrait_depth'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and presences/absences of a binary trait for each tip, calculate the mean phylogenetic depth at which the trait is conserved across clades, in terms of the consenTRAIT metric introduced by Martiny et al (2013). This is the mean depth of clades that are positive in the trait (i.e. in which a sufficient fraction of tips exhibits the trait).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consentrait_depth(tree, 
                  tip_states, 
                  min_fraction        = 0.9, 
                  count_singletons    = TRUE,
                  singleton_resolution= 0,
                  weighted            = FALSE, 
                  Npermutations       = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consentrait_depth_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips indicating absence (value &lt;=0) or presence (value &gt;0) of a particular trait at each tip of the tree. Note that tip_states[i] (where i is an integer index) must correspond to the i-th tip in the tree.
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_min_fraction">min_fraction</code></td>
<td>

<p>Minimum fraction of tips in a clade exhibiting the trait, for the clade to be considered &quot;positive&quot; in the trait. In the original paper by Martiny et al (2013), this was 0.9.
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_count_singletons">count_singletons</code></td>
<td>

<p>Logical, specifying whether to include singletons in the statistics (tips positive in the trait, but not part of a larger positive clade). The phylogenetic depth of singletons is taken to be half the length of their incoming edge, as proposed by Martiny et al (2013). If FALSE, singletons are ignored.
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_singleton_resolution">singleton_resolution</code></td>
<td>

<p>Numeric, specifying the phylogenetic resolution at which to resolve singletons. Any clade found to be positive in a trait will be considered a singleton if the distance of the clade's root to all descending tips is below this threshold.
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_weighted">weighted</code></td>
<td>

<p>Whether to weight positive clades by their number of positive tips. If FALSE, each positive clades is weighted equally, as proposed by Martiny et al (2013).
</p>
</td></tr>
<tr><td><code id="consentrait_depth_+3A_npermutations">Npermutations</code></td>
<td>

<p>Number of random permutations for estimating the statistical significance of the mean trait depth. If zero (default), the statistical significance is not calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the &quot;consenTRAIT&quot; metric (or variants thereof) proposed by Martiny et al. (2013) for measuring the mean phylogenetic depth at which a binary trait (e.g. presence/absence of a particular metabolic function) is conserved across clades. A greater mean depth means that the trait tends to be conserved in deeper-rooting clades. In their original paper, Martiny et al. proposed to consider a trait as conserved in a clade (i.e. marking a clade as &quot;positive&quot; in the trait) if at least 90% of the clade's tips exhibit the trait (i.e. are &quot;positive&quot; in the trait). This fraction can be controlled using the <code>min_fraction</code> parameter. The depth of a clade is taken as the average distance of its tips to the clade's root. 
</p>
<p>Note that the consenTRAIT metric does not treat &quot;presence&quot; and &quot;absence&quot; equally, i.e., if one were to reverse all presences and absences then the consenTRAIT metric will generally have a different value. This is because the focus is on the presence of the trait (e.g., presence of a metabolic function, or presence of a morphological feature).
</p>
<p>The default parameters of this function reflect the original choices made by Martiny et al. (2013), however in some cases it may be sensible to adjust them. For example, if you suspect a high risk of false positives in the detection of a trait, it may be worth setting <code>count_singletons</code> to <code>FALSE</code> to avoid skewing the distribution of conservation depths towards shallower depths due to false positives.
</p>
<p>The statistical significance of the calculated mean depth, i.e. the probability of encountering such a mean dept or higher by chance, is estimated based on a null model in which each tip is re-assigned a presence or absence of the trait by randomly reshuffling the original <code>tip_states</code>.
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is missing, then every edge is assumed to have length 1.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>mean_depth</code></td>
<td>

<p>Mean phylogenetic depth of clades that are positive in the trait.
</p>
</td></tr>
<tr><td><code>var_depth</code></td>
<td>

<p>Variance of phylogenetic depths of clades that are positive in the trait.
</p>
</td></tr>
<tr><td><code>min_depth</code></td>
<td>

<p>Minimum phylogenetic depth of clades that are positive in the trait.
</p>
</td></tr>
<tr><td><code>max_depth</code></td>
<td>

<p>Maximum phylogenetic depth of clades that are positive in the trait.
</p>
</td></tr>
<tr><td><code>Npositives</code></td>
<td>

<p>Number of clades that are positive in the trait.
</p>
</td></tr>
<tr><td><code>P</code></td>
<td>

<p>Statistical significance (P-value) of mean_depth, under a null model of random trait presences/absences (see details above). This is the probability that, under the null model, the <code>mean_depth</code> would be at least as high as observed in the data.
</p>
</td></tr>
<tr><td><code>mean_random_depth</code></td>
<td>

<p>Mean random mean_depth, under a null model of random trait presences/absences (see details above).
</p>
</td></tr>
<tr><td><code>positive_clades</code></td>
<td>

<p>Integer vector, listing indices of tips and nodes (from 1 to Ntips+Nnodes) that were found to be positive in the trait and counted towards the statistic.
</p>
</td></tr>
<tr><td><code>positives_per_clade</code></td>
<td>

<p>Integer vector of size Ntips+Nnodes, listing the number of descending tips per clade (tip or node) that were positive in the trait.
</p>
</td></tr>
<tr><td><code>mean_depth_per_clade</code></td>
<td>

<p>Numeric vector of size Ntips+Nnodes, listing the mean phylogenetic depth of each clade (tip or node), i.e. the average distance to all its descending tips.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>A. C. Martiny, K. Treseder and G. Pusch (2013). Phylogenetic trait conservatism of functional traits in microorganisms. ISME Journal. 7:830-838.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trait_acf">get_trait_acf</a></code>, 
<code><a href="#topic+discrete_trait_depth">discrete_trait_depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# simulate binary trait evolution on the tree
Q = get_random_mk_transition_matrix(Nstates=2, rate_model="ARD", max_rate=0.1)
tip_states = simulate_mk_model(tree, Q)$tip_states

# change states from 1/2 to 0/1 (presence/absence)
tip_states = tip_states - 1

# calculate phylogenetic conservatism of trait
results = consentrait_depth(tree, tip_states, count_singletons=FALSE, weighted=TRUE)
cat(sprintf("Mean depth = %g, std = %g\n",results$mean_depth,sqrt(results$var_depth)))

## End(Not run)</code></pre>

<hr>
<h2 id='correlate_phylo_geodistances'>
Correlations between phylogenetic &amp; geographic distances.
</h2><span id='topic+correlate_phylo_geodistances'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and geographic coordinates (latitudes &amp; longitudes) of each tip, examine the correlation between pairwise phylogenetic and geographic distances of tips. The statistical significance is computed by randomly permuting the tip coordinates, which is essentially a phylogenetic version of the Mantel test and accounts for shared evolutionary history between tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlate_phylo_geodistances(tree,
                             tip_latitudes,
                             tip_longitudes,
                             correlation_method,
                             max_phylodistance  = Inf,
                             Npermutations      = 1000,
                             alternative        = "right",
                             radius             = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlate_phylo_geodistances_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of size Ntips, specifying the latitudes (decimal degrees) of the tree's tips. By convention, positive latitudes correspond to the northern hemisphere. Note that <code>tip_latitudes[i]</code> must correspond to the i-th tip in the tree, i.e. as listed in <code>tree$tip.label</code>.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of size Ntips, specifying the longitudes (decimal degrees) of the tree's tips. By convention, positive longitudes correspond to the eastern hemisphere.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_correlation_method">correlation_method</code></td>
<td>

<p>Character, one of &quot;<code>pearson</code>&quot;, &quot;<code>spearman</code>&quot; or &quot;<code>kendall</code>&quot;.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum phylodistance between tips to consider, in the same units as the tree's edge lengths. If <code>Inf</code>, all tip pairs will be considered.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_npermutations">Npermutations</code></td>
<td>

<p>Integer, number of random permutations to consider for estimating the statistical significance (P value). If 0, the significance will not be computed. A larger number improves accuracy but at the cost of increased computing time.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_alternative">alternative</code></td>
<td>

<p>Character, one of &quot;<code>two_sided</code>&quot;, &quot;<code>right</code>&quot; or &quot;<code>left</code>&quot;, specifying which part of the null model's distribution to use as P-value.
</p>
</td></tr>
<tr><td><code id="correlate_phylo_geodistances_+3A_radius">radius</code></td>
<td>

<p>Optional numeric, radius to assume for the sphere. If 1, then all geodistances are measured in multiples of the sphere radius. This does not affect the correlation or P-value, but it affects the returned geodistances. Note that Earth's average radius is about 6371 km.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compute the statistical significance (P value) of the observed correlation <code>C</code>, this function repeatedly randomly permutes the tip coordinates, each time recomputing the corresponding &quot;random&quot; correlation, and then examines the distribution of the random correlations. If <code>alternative="right"</code>, the P value is set to the fraction of random correlations equal to or greater than <code>C</code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>correlation</code></td>
<td>

<p>Numeric between -1 and 1, the correlation between phylodistances and geodistances.
</p>
</td></tr>
<tr><td><code>Npairs</code></td>
<td>

<p>Integer, the number of tip pairs considered.
</p>
</td></tr>
<tr><td><code>Pvalue</code></td>
<td>

<p>Numeric between 0 and 1, estimated statistical significance of the correlation. Only returned if <code>Npermutations&gt;0</code>.
</p>
</td></tr>
<tr><td><code>mean_random_correlation</code></td>
<td>

<p>Numeric between -1 and 1, the mean correlation obtained across all random permutations. Only returned if <code>Npermutations&gt;0</code>.
</p>
</td></tr>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of length <code>Npairs</code>, listing the pairwise phylodistances between tips, used to compute the correlation.
</p>
</td></tr>
<tr><td><code>geodistances</code></td>
<td>

<p>Numeric vector of length <code>Npairs</code>, listing the pairwise geodistances between tips, used to compute the correlation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+geographic_acf">geographic_acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random tree
Ntips = 50
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate spherical Brownian motion (a dispersal model) on the tree
simul = simulate_sbm(tree, radius=6371, diffusivity=50)

# Analyze correlations between geodistances &amp; phylodistances
coranal = correlate_phylo_geodistances(tree               = tree,
                                       tip_latitudes      = simul$tip_latitudes,
                                       tip_longitudes     = simul$tip_longitudes,
                                       correlation_method = "spearman",
                                       Npermutations      = 100,
                                       max_phylodistance  = 100,
                                       radius             = 6371)
print(coranal$correlation)
print(coranal$Pvalue)
plot(coranal$phylodistances, coranal$geodistances,
     xlab="phylodistance", ylab="geodistance", type="p")
</code></pre>

<hr>
<h2 id='count_lineages_through_time'>
Count number of lineages through time (LTT).
</h2><span id='topic+count_lineages_through_time'></span>

<h3>Description</h3>

<p>Given a rooted timetree (i.e., a tree whose edge lengths represent time intervals), calculate the number of lineages represented in the tree at various time points, otherwise known as &quot;lineages through time&quot;&quot; (LTT) curve. The root is interpreted as time 0, and the distance of any node or tip from the root is interpreted as time elapsed since the root. Optionally, the slopes and relative slopes of the LTT curve are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_lineages_through_time(  tree, 
                              Ntimes        = NULL, 
                              min_time      = NULL,
                              max_time      = NULL,
                              times         = NULL, 
                              include_slopes= FALSE,
                              ultrametric   = FALSE,
                              degree        = 1,
                              regular_grid  = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_lineages_through_time_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;, where edge lengths represent time intervals (or similar).
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_ntimes">Ntimes</code></td>
<td>

<p>Integer, number of equidistant time points at which to count lineages. Can also be <code>NULL</code>, in which case <code>times</code> must be provided.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_min_time">min_time</code></td>
<td>

<p>Minimum time (distance from root) to consider. If <code>NULL</code>, this will be set to the minimum possible (i.e. 0). Only relevant if <code>times==NULL</code>.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_max_time">max_time</code></td>
<td>

<p>Maximum time (distance from root) to consider. If <code>NULL</code>, this will be set to the maximum possible. Only relevant if <code>times==NULL</code>.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_times">times</code></td>
<td>

<p>Integer vector, listing time points (in ascending order) at which to count lineages. Can also be <code>NULL</code>, in which case <code>Ntimes</code> must be provided.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_include_slopes">include_slopes</code></td>
<td>

<p>Logical, specifying whether the slope and the relative slope of the returned clades-per-time-point curve should also be returned.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_ultrametric">ultrametric</code></td>
<td>

<p>Logical, specifying whether the input tree is guaranteed to be ultrametric, even in the presence of some numerical inaccuracies causing some tips not have exactly the same distance from the root. If you know the tree is ultrametric, then this option helps the function choose a better time grid for the LTT.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_degree">degree</code></td>
<td>

<p>Integer, specifying the &quot;degree&quot; of the LTT curve: LTT(t) will be the number of lineages in the tree at time t that have at least n descending tips in the tree. Typically <code>order=1</code>, which corresponds to the classical LTT curve.
</p>
</td></tr>
<tr><td><code id="count_lineages_through_time_+3A_regular_grid">regular_grid</code></td>
<td>

<p>Logical, specifying whether the automatically generated time grid should be regular (equal distances between grid points). This option only matters if <code>times==NULL</code>. If <code>regular_grid==FALSE</code> and <code>times==NULL</code>, the time grid will be irregular, with grid point density being roughly proportional to the square root of the number of lineages at any particular time (i.e., the grid becomes finer towards the tips).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a sequence of time points between a tree's root and tips, this function essentially counts how many edges &quot;cross&quot; each time point (if <code>degree==1</code>). The slopes and relative slopes are calculated from this curve using finite differences.
</p>
<p>Note that the classical LTT curve (<code>degree=1</code>) is non-decreasing over time, whereas higher-degree LTT's may be decreasing as well as increasing over time.
</p>
<p>If <code>tree$edge.length</code> is missing, then every edge in the tree is assumed to be of length 1. The tree may include multifurcations as well as monofurcations (i.e. nodes with only one child). The tree need not be ultrametric, although in general this function only makes sense for dated trees (e.g., where edge lengths are time intervals or similar).
</p>
<p>Either <code>Ntimes</code> or <code>times</code> must be non-<code>NULL</code>, but not both. If <code>times!=NULL</code>, then <code>min_time</code> and <code>max_time</code> must be <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Ntimes</code></td>
<td>

<p>Integer, indicating the number of returned time points. Equal to the provided <code>Ntimes</code> if applicable.
</p>
</td></tr>
<tr><td><code>times</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the time points at which the LTT was calculated. If <code>times</code> was provided as an argument to the function, then this will be the same as provided, otherwise times will be listed in ascending order.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the ages (time before the youngest tip) corresponding to the returned times[].
</p>
</td></tr>
<tr><td><code>lineages</code></td>
<td>

<p>Integer vector of size Ntimes, listing the number of lineages represented in the tree at each time point that have at least <code>degree</code> descending tips, i.e. the LTT curve.
</p>
</td></tr>
<tr><td><code>slopes</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the slopes (finite-difference approximation of 1st derivative) of the LTT curve.
</p>
</td></tr>
<tr><td><code>relative_slopes</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the relative slopes of the LTT curve, i.e. <code>slopes</code> divided by a sliding-window average of <code>lineages</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1), max_tips=1000)$tree

# calculate classical LTT curve
results = count_lineages_through_time(tree, Ntimes=100)

# plot classical LTT curve
plot(results$times, results$lineages, type="l", xlab="time", ylab="# clades")
</code></pre>

<hr>
<h2 id='count_tips_per_node'>
Count descending tips.
</h2><span id='topic+count_tips_per_node'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, count the number of tips descending (directy or indirectly) from each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_tips_per_node(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_tips_per_node_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymptotic time complexity of this function is O(Nedges), where Nedges is the number of edges.
</p>


<h3>Value</h3>

<p>An integer vector of size Nnodes, with the i-th entry being the number of tips descending (directly or indirectly) from the i-th node.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_subtree_at_node">get_subtree_at_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a tree using a simple speciation model 
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# count number of tips descending from each node
tips_per_node = count_tips_per_node(tree);

# plot histogram of tips-per-node
barplot(table(tips_per_node[tips_per_node&lt;10]), xlab="# tips", ylab="# nodes")
</code></pre>

<hr>
<h2 id='count_transitions_between_clades'>
Count the number of state transitions between tips or nodes.
</h2><span id='topic+count_transitions_between_clades'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, one or more pairs of tips and/or nodes, and the state of some discrete trait at each tip and node, calculate the number of state transitions along the shortest path between each pair of tips/nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_transitions_between_clades(tree, A, B, states, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_transitions_between_clades_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="count_transitions_between_clades_+3A_a">A</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the first of the two members of each pair of tips/nodes. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="count_transitions_between_clades_+3A_b">B</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the second of the two members of each pair of tips/nodes. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="count_transitions_between_clades_+3A_states">states</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, listing the discrete state of each tip and node in the tree. The order of entries must match the order of tips and nodes in the tree; this requirement is only verified if <code>states</code> has names and <code>check_input==TRUE</code>.
</p>
</td></tr>
<tr><td><code id="count_transitions_between_clades_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete state must be represented by integers (both negatives and positives are allowed); characters and other data types are not allowed. If tip/node states are originally encoded as characters rather than integers, you can use <code>map_to_state_space</code> to convert these to integers (for example &ldquo;<code>male</code>&rdquo; &amp; &ldquo;<code>female</code>&rdquo; may be represented as 1 &amp; 2). Also note that a state must be provided for each tip and ancestral node, not just for the tips. If you only know the states of tips, you can use an ancestral state reconstruction tool to estimate ancestral states first.
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). If <code>A</code> and/or <code>B</code> is a character vector, then <code>tree$tip.label</code> must exist. If node names are included in <code>A</code> and/or <code>B</code>, then <code>tree$node.label</code> must also exist.
</p>


<h3>Value</h3>

<p>An integer vector of size Npairs, with the i-th element being the number of state transitions between tips/nodes <code>A[i]</code> and <code>B[i]</code> (along their shortest connecting path).
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick 3 random pairs of tips or nodes
Npairs = 3
A = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)
B = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)

# assign a random state to each tip &amp; node in the tree
# consider a binary trait
states = sample.int(n=2, size=Ntips+tree$Nnode, replace=TRUE)

# calculate number of transitions for each tip pair
Ntransitions = count_transitions_between_clades(tree, A, B, states=states)
</code></pre>

<hr>
<h2 id='date_tree_red'>
Date a tree based on relative evolutionary divergences.
</h2><span id='topic+date_tree_red'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a single node ('anchor') of known age (distance from the present), rescale all edge lengths so that the tree becomes ultrametric and edge lengths correspond to time intervals. The function is based on relative evolutionary divergences (RED), which measure the relative position of each node between the root and its descending tips (Parks et al. 2018). If no anchor node is provided, the root is simply assumed to have age 1. This function provides a heuristic quick-and-dirty way to date a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_tree_red(tree, anchor_node = NULL, anchor_age = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_tree_red_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="date_tree_red_+3A_anchor_node">anchor_node</code></td>
<td>

<p>Integer, ranging between 1 and Nnodes. Index of the node to be used as dating anchor. If <code>NULL</code>, the tree's root is used as anchor.
</p>
</td></tr>
<tr><td><code id="date_tree_red_+3A_anchor_age">anchor_age</code></td>
<td>

<p>Positive numeric. Age of the anchor node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RED of a node measures its relative placement between the root and the node's descending tips (Parks et al. 2018). The root's RED is set to 0. Traversing from root to tips (preorder traversal), for each node the RED is set to <code class="reqn">P+(a/(a+b))\cdot(1-P)</code>, where <code class="reqn">P</code> is the RED of the node's parent, <code class="reqn">a</code> is the edge length connecting the node to its parent, and <code class="reqn">b</code> is the average distance from the node to its descending tips. The RED of all tips is set to 1.
</p>
<p>For each edge, the RED difference between child &amp; parent is used to set the new length of that edge, multiplied by some common scaling factor to translate RED units into time units. The scaling factor is chosen such that the new distance of the anchor node from its descending tips equals <code>anchor_age</code>. All tips will have age 0. The topology of the dated tree, as well as tip/node/edge indices, remain unchanged.
</p>
<p>This function provides a heuristic approach to making a tree ultrametric, and has not been derived from a specific evolutionary model. In particular, its statistical properties are unknown to the author.
</p>
<p>The time complexity of this function is O(Nedges).
The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is <code>NULL</code>, then all edges in the input tree are assumed to have length 1.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the dating was successful. If <code>FALSE</code>, all other return values (except for <code>error</code>) may be undefined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, representing the dated tree.
</p>
</td></tr>
<tr><td><code>REDs</code></td>
<td>

<p>Numeric vector of size Nnodes, listing the RED of each node in the input tree.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, listing any error message if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. H. Parks, M. Chuvochina et al. (2018). A proposal for a standardized bacterial taxonomy based on genome phylogeny. bioRxiv 256800. DOI:10.1101/256800
</p>


<h3>See Also</h3>

<p><code><a href="#topic+congruent_divergence_times">congruent_divergence_times</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random non-ultrametric tree
params = list(birth_rate_intercept=1, death_rate_intercept=0.8)
tree = generate_random_tree(params, max_time=1000, coalescent=FALSE)$tree

# make ultrametric, by setting the root to 2 million years
dated_tree = date_tree_red(tree, anchor_age=2e6)
</code></pre>

<hr>
<h2 id='discrete_trait_depth'>
Calculate phylogenetic depth of a discrete trait.
</h2><span id='topic+discrete_trait_depth'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and the state of a discrete trait at each tip, calculate the mean phylogenetic depth at which the trait is conserved across clades, using a modification of the consenTRAIT metric introduced by Martiny et al (2013). This is the mean depth of clades that are &quot;maximally uniform&quot; in the trait (see below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_trait_depth(tree, 
                     tip_states, 
                     min_fraction         = 0.9, 
                     count_singletons     = TRUE,
                     singleton_resolution = 0,
                     weighted             = FALSE, 
                     Npermutations        = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_trait_depth_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_tip_states">tip_states</code></td>
<td>

<p>A vector of size Ntips specifying the state at each tip. Note that <code>tip_states[i]</code> (where i is an integer index) must correspond to the i-th tip in the tree. This vector may be of any base data type, although character or integer are the most typical types.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_min_fraction">min_fraction</code></td>
<td>

<p>Minimum fraction of tips in a clade that must have the dominant state, for the clade to be considered &quot;uniform&quot; in the trait.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_count_singletons">count_singletons</code></td>
<td>

<p>Logical, specifying whether to consider singleton clades in the statistics (e.g., tips not part of a larger uniform clade). The phylogenetic depth of singletons is taken to be half the length of their incoming edge, as proposed by Martiny et al (2013). If FALSE, singletons are ignored. If you suspect a high risk of false positives in the detection of a trait, it may be worth setting <code>count_singletons</code> to <code>FALSE</code> to avoid skewing the distribution of conservation depths towards shallower depths due to false positives.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_singleton_resolution">singleton_resolution</code></td>
<td>

<p>Numeric, specifying the phylogenetic resolution at which to resolve singletons. A clade will be considered a singleton if the distance of the clade's root to all descending tips is below this threshold.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_weighted">weighted</code></td>
<td>

<p>Whether to weight uniform clades by their number of tips in the dominant state. If <code>FALSE</code>, each uniform clades is weighted equally.
</p>
</td></tr>
<tr><td><code id="discrete_trait_depth_+3A_npermutations">Npermutations</code></td>
<td>

<p>Number of random permutations for estimating the statistical significance of the mean trait depth. If zero (default), the statistical significance is not calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The depth of a clade is defined as the average distance of its tips to the clade's root. The &quot;dominant&quot; state of a clade is defined as the most frequent state among all of the clade's tips. A clade is considered &quot;uniform&quot; in the trait if the frequency of its dominant state is equal to or greater than <code>min_fraction</code>. The clade is &quot;maximally uniform&quot; if it is uniform and not descending from another uniform clade. The mean depth of the trait is defined as the average phylogenetic depth of all considered maximal uniform clades (whether a maximally uniform clade is considered in this statistic depends on <code>count_singletons</code> and <code>singleton_resolution</code>). A greater mean depth means that the trait tends to be conserved in deeper-rooting clades.
</p>
<p>This function implements a modification of the &quot;consenTRAIT&quot; metric proposed by Martiny et al. (2013) for measuring the mean phylogenetic depth at which a binary trait is conserved across clades. Note that the original consenTRAIT metric by Martiny et al. (2013) does not treat the two states of a binary trait (&quot;presence&quot; and &quot;absence&quot;) equally, whereas the function <code>discrete_trait_depth</code> does. If you want the original consenTRAIT metric for a binary trait, see the function <code><a href="#topic+consentrait_depth">consentrait_depth</a></code>.
</p>
<p>The statistical significance of the calculated mean depth, i.e. the probability of encountering such a mean dept or higher by chance, is estimated based on a null model in which each tip is re-assigned a state by randomly reshuffling the original <code>tip_states</code>. A low P value indicates that the trait exhibits a phylogenetic signal, whereas a high P value means that there is insufficient evidence in the data to suggest a phylogenetic signal (i.e., the trait's phylogenetic conservatism is indistinguishable from the null model of zero conservatism).
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is missing, then every edge is assumed to have length 1.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>unique_states</code></td>
<td>

<p>Vector of the same type as <code>tip_states</code> and of length <code>Nstates</code>, listing the unique possible states of the trait.
</p>
</td></tr>
<tr><td><code>mean_depth</code></td>
<td>

<p>Numeric, specifying the mean phylogenetic depth of the trait, i.e., the mean depth of considered maximally uniform clades.
</p>
</td></tr>
<tr><td><code>var_depth</code></td>
<td>

<p>Numeric, specifying the variance of phylogenetic depths of considered maximally uniform clades.
</p>
</td></tr>
<tr><td><code>min_depth</code></td>
<td>

<p>Numeric, specifying the minimum phylogenetic depth of considered maximally uniform clades.
</p>
</td></tr>
<tr><td><code>max_depth</code></td>
<td>

<p>Numeric, specifying the maximum phylogenetic depth of considered maximally uniform clades.
</p>
</td></tr>
<tr><td><code>Nmax_uniform</code></td>
<td>

<p>Number of considered maximal uniform clades.
</p>
</td></tr>
<tr><td><code>mean_depth_per_state</code></td>
<td>

<p>Numeric vector of size Nstates. Mean depth of considered maximally uniform clades, separately for each state and in the same order as <code>unique_states</code>. Hence, <code>mean_depth_per_state[s]</code> lists the mean depth of considered maximally uniform clades whose dominant state is <code>unique_states[s]</code>.
</p>
</td></tr>
<tr><td><code>var_depth_per_state</code></td>
<td>

<p>Numeric vector of size Nstates. Variance of depths of considered maximally uniform clades, separately for each state and in the same order as <code>unique_states</code>
</p>
</td></tr>
<tr><td><code>min_depth_per_state</code></td>
<td>

<p>Numeric vector of size Nstates. Minimum phylogenetic depth of considered maximally uniform clades, separately for each state and in the same order as <code>unique_states</code>
</p>
</td></tr>
<tr><td><code>max_depth_per_state</code></td>
<td>

<p>Numeric vector of size Nstates. Maximum phylogenetic depth of considered maximally uniform clades, separately for each state and in the same order as <code>unique_states</code>
</p>
</td></tr>
<tr><td><code>Nmax_uniform_per_state</code></td>
<td>

<p>Integer vector of size Nstates. Number of considered maximally uniform clades, seperately for each state and in the same order as <code>unique_states</code>
</p>
</td></tr>
<tr><td><code>P</code></td>
<td>

<p>Statistical significance (P-value) of mean_depth, under a null model of random tip states (see details above). This is the probability that, under the null model, the <code>mean_depth</code> would be at least as high as observed in the data.
</p>
</td></tr>
<tr><td><code>mean_random_depth</code></td>
<td>

<p>Mean random mean_depth, under the null model of random tip states (see details above).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>A. C. Martiny, K. Treseder and G. Pusch (2013). Phylogenetic trait conservatism of functional traits in microorganisms. ISME Journal. 7:830-838.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trait_acf">get_trait_acf</a></code>, 
<code><a href="#topic+consentrait_depth">consentrait_depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# simulate discrete trait evolution on the tree
# consider a trait with 3 discrete states
Q = get_random_mk_transition_matrix(Nstates=3, rate_model="ARD", max_rate=0.1)
tip_states = simulate_mk_model(tree, Q)$tip_states

# calculate phylogenetic conservatism of trait
results = discrete_trait_depth(tree, tip_states, count_singletons=FALSE, weighted=TRUE)
cat(sprintf("Mean depth = %g, std = %g\n",results$mean_depth,sqrt(results$var_depth)))

## End(Not run)</code></pre>

<hr>
<h2 id='evaluate_spline'>
Evaluate a scalar spline at arbitrary locations.
</h2><span id='topic+evaluate_spline'></span>

<h3>Description</h3>

<p>Given a natural spline function <code class="reqn">Y:\R\to\R</code>, defined as a series of Y values on a discrete X grid, evaluate its values (or derivative) at arbitrary X points. Supported splines degrees are 0 (Y is piecewise constant), 1 (piecewise linear), 2 (piecewise quadratic) and 3 (piecewise cubic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_spline(Xgrid, 
                Ygrid,
                splines_degree,
                Xtarget,
                extrapolate = "const",
                derivative  = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_spline_+3A_xgrid">Xgrid</code></td>
<td>

<p>Numeric vector, listing x-values in ascending order.
</p>
</td></tr>
<tr><td><code id="evaluate_spline_+3A_ygrid">Ygrid</code></td>
<td>

<p>Numeric vector of the same length as <code>Xgrid</code>, listing the values of Y on <code>Xgrid</code>.
</p>
</td></tr>
<tr><td><code id="evaluate_spline_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0, 1, 2 or 3, specifying the polynomial degree of the spline curve Y between grid points. For example, 0 means Y is piecewise constant, 1 means Y is piecewise linear and so on.
</p>
</td></tr>
<tr><td><code id="evaluate_spline_+3A_xtarget">Xtarget</code></td>
<td>

<p>Numeric vector, listing arbitrary X values on which to evaluate Y.
</p>
</td></tr>
<tr><td><code id="evaluate_spline_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Character, specifying how to extrapolate Y beyond <code>Xgrid</code> if needed. Available options are &quot;const&quot; (i.e. use the value of Y on the nearest <code>Xgrid</code> point) or &quot;splines&quot; (i.e. use the polynomial coefficients from the nearest grid point).
</p>
</td></tr>
<tr><td><code id="evaluate_spline_+3A_derivative">derivative</code></td>
<td>

<p>Integer, specifying which derivative to return. To return the spline's value, set <code>derivative=0</code>. Currently only the options 0,1,2 are supported.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline functions are returned by some of castor's fitting routines, so <code>evaluate_spline</code> is meant to aid with the evaluation and plotting of such functions. A spline function of degree <code class="reqn">D\geq1</code> has continuous derivatives up to degree <code class="reqn">D-1</code>. The function <code>evaluate_spline</code> is much more efficient if <code>Xtarget</code> is monotonically increasing or decreasing.
</p>
<p>This function is used to evaluate the spline's values at arbitrary points. To obtain the spline's polynomial coefficients, use <code><a href="#topic+spline_coefficients">spline_coefficients</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>Xtarget</code>, listing the values (or derivatives, if <code>derivative&gt;0</code>) of Y on <code>Xtarget</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+spline_coefficients">spline_coefficients</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify Y on a coarse X grid
Xgrid = seq(from=0,to=10,length.out=10)
Ygrid = sin(Xgrid)

# define a fine grid of target X values
Xtarget = seq(from=0,to=10,length.out=1000)

# evaluate Y on Xtarget, either as piecewise linear or piecewise cubic function
Ytarget_lin = evaluate_spline(Xgrid,Ygrid,splines_degree=1,Xtarget=Xtarget)
Ytarget_cub = evaluate_spline(Xgrid,Ygrid,splines_degree=3,Xtarget=Xtarget)

# plot both the piecewise linear and piecewise cubic curves
plot(x=Xtarget, y=Ytarget_cub, type='l', col='red', xlab='X', ylab='Y')
lines(x=Xtarget, y=Ytarget_lin, type='l', col='blue', xlab='X', ylab='Y')
</code></pre>

<hr>
<h2 id='expanded_tree_from_jplace'>
Place queries on a tree from a jplace file.
</h2><span id='topic+expanded_tree_from_jplace'></span>

<h3>Description</h3>

<p>Given a <code>jplace</code> file (e.g., as generated by <code>pplacer</code> or <code>EPA-NG</code>), construct an expanded tree consisting of the original reference tree and additional tips representing the placed query sequences. The reference tree and placements are loaded from the jplace file. If multiple placements are listed for a query, this function can either add the best (maximum-likelihood) placement or all listed placements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expanded_tree_from_jplace(file_path,
                          only_best_placements  = TRUE,
                          max_names_per_query   = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expanded_tree_from_jplace_+3A_file_path">file_path</code></td>
<td>

<p>Character, the path to the input <code>jplace</code> file.
</p>
</td></tr>
<tr><td><code id="expanded_tree_from_jplace_+3A_only_best_placements">only_best_placements</code></td>
<td>

<p>Logical, only keep the best placement of each query, i.e., the placement with maximum likelihood.
</p>
</td></tr>
<tr><td><code id="expanded_tree_from_jplace_+3A_max_names_per_query">max_names_per_query</code></td>
<td>

<p>Positive integer, maximum number of sequence names to keep from each query. Only relevant if queries in the jplace file include multiple sequence names (these typically represent identical sequences). If greater than 1, and a query includes multiple sequence names, then each of these sequence names will be added as a tip to the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes version 3 of the jplace file format, as defined by Matsen et al. (2012).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>Object of class &quot;phylo&quot;, the extended tree constructed by adding the placements on the reference tree.
</p>
</td></tr>
<tr><td><code>placed_tips</code></td>
<td>

<p>Integer vector, specifying which tips in the returned tree correspond to placements.
</p>
</td></tr>
<tr><td><code>reference_tree</code></td>
<td>

<p>Object of class &quot;phylo&quot;, the original reference tree loaded from the jplace file. This will be a subtree of <code>tree</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Frederick A. Matsen et al. (2012). A format for  phylogenetic placements. PLOS One. 7:e31009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+place_tips_taxonomically">place_tips_taxonomically</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load jplace file and create expanded tree
J = expanded_tree_from_jplace("epa_ng_output.jplace")

# save the reference and expanded tree as Newick files
write_tree(J$reference_tree, file="reference.tre")
write_tree(J$tree, file="expanded.tre")

## End(Not run)
</code></pre>

<hr>
<h2 id='expected_distances_sbm'>
Expected distances traversed by a Spherical Brownian Motion.
</h2><span id='topic+expected_distances_sbm'></span>

<h3>Description</h3>

<p>Given a Spherical Brownian Motion (SBM) process with constant diffusivity, compute the expected geodesic distance traversed over specific time intervals. This quantity may be used as a measure for how fast a lineage disperses across the globe over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_distances_sbm(diffusivity,
                       radius,
                       deltas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_distances_sbm_+3A_diffusivity">diffusivity</code></td>
<td>

<p>Numeric, the diffusivity (aka. diffusion coefficient) of the SBM. The units of the diffusivity must be consistent with the units used for specifying the <code>radius</code> and time intervals (<code>deltas</code>); for example, if <code>radius</code> is in km and <code>deltas</code> are in years, then <code>diffusivity</code> must be specified in km^2/year.
</p>
</td></tr>
<tr><td><code id="expected_distances_sbm_+3A_radius">radius</code></td>
<td>

<p>Positive numeric, the radius of the sphere.
</p>
</td></tr>
<tr><td><code id="expected_distances_sbm_+3A_deltas">deltas</code></td>
<td>

<p>Numeric vector, listing time intervals for which to compute the expected geodesic distances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns expected geodesic distances (i.e. accounting for spherical geometry) for a diffusion process on a sphere, with isotropic and homogeneous diffusivity. 
</p>


<h3>Value</h3>

<p>A non-negative numeric vector of the same length as <code>deltas</code>, specifying the expected geodesic distance for each time interval in <code>deltas</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute the expected geodistance (in km) after 100 and 1000 years
# assuming a diffusivity of 20 km^2/year
expected_distances = expected_distances_sbm(diffusivity = 20,
                                            radius      = 6371,
                                            deltas      = c(100,1000))
</code></pre>

<hr>
<h2 id='exponentiate_matrix'>
Exponentiate a matrix.
</h2><span id='topic+exponentiate_matrix'></span>

<h3>Description</h3>

<p>Calculate the exponential <code class="reqn">\exp(T\cdot A)</code> of some quadratic real-valued matrix A for one or more scalar scaling factors T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponentiate_matrix(A, scalings=1, max_absolute_error=1e-3, 
                    min_polynomials=1, max_polynomials=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponentiate_matrix_+3A_a">A</code></td>
<td>

<p>A real-valued quadratic matrix of size N x N.
</p>
</td></tr>
<tr><td><code id="exponentiate_matrix_+3A_scalings">scalings</code></td>
<td>

<p>Vector of real-valued scalar scaling factors T, for each of which the exponential <code class="reqn">\exp(T\cdot A)</code> should be calculated.
</p>
</td></tr>
<tr><td><code id="exponentiate_matrix_+3A_max_absolute_error">max_absolute_error</code></td>
<td>

<p>Maximum allowed absolute error for the returned approximations. A smaller allowed error implies a greater computational cost as more matrix polynomials need to be included (see below). The returned approximations may have a greater error if the parameter <code>max_polynomials</code> is set too low.
</p>
</td></tr>
<tr><td><code id="exponentiate_matrix_+3A_min_polynomials">min_polynomials</code></td>
<td>

<p>Minimum number of polynomials to include in the approximations (see equation below), even if <code>max_absolute_error</code> may be satisfied with fewer polynomials. If you don't know how to choose this, in most cases the default is fine. Note that regardless of <code>min_polynomials</code> and <code>max_absolute_error</code>, the number of polynomials used will not exceed <code>max_polynomials</code>.
</p>
</td></tr>
<tr><td><code id="exponentiate_matrix_+3A_max_polynomials">max_polynomials</code></td>
<td>

<p>Maximum allowed number of polynomials to include in the approximations (see equation below). Meant to provide a safety limit for the amount of memory and the computation time required. For example, a value of 1000 means that up to 1000 matrices (powers of A) of size N x N may be computed and stored temporarily in memory. Note that if <code>max_polynomials</code> is too low, the requested accuracy (via <code>max_absolute_error</code>) may not be achieved. That said, for large trees more memory may be required to store the actual result rather than the intermediate polynomials, i.e. for purposes of saving RAM it doesn't make much sense to choose <code>max_polynomials</code> much smaller than the length of <code>scalings</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discrete character evolution Markov models often involve repeated exponentiations of the same transition matrix along each edge of the tree (i.e. with the scaling T being the edge length). Matrix exponentiation can become a serious computational bottleneck for larger trees or large matrices (i.e. spanning multiple discrete states). This function pre-calculates polynomials <code class="reqn">A^p/p!</code> of the matrix, and then uses linear combinations of the same polynomials for each requested T: 
</p>
<p style="text-align: center;"><code class="reqn">
\exp(T\cdot A) = \sum_{p=0}^P T^p\frac{A^p}{p!} + ...
</code>
</p>

<p>This function thus becomes very efficient when the number of scaling factors is large (e.g. &gt;10,000).
The number of polynomials included is determined based on the specified <code>max_absolute_error</code>, and based on the largest (by magnitude) scaling factor requested. The function utilizes the balancing algorithm proposed by James et al (2014, Algorithm 3) and the scaling &amp; squaring method (Moler and Van Loan, 2003) to improve the conditioning of the matrix prior to exponentiation.
</p>


<h3>Value</h3>

<p>A 3D numeric matrix of size N x N x S, where N is the number of rows &amp; column of the input matrix A and S is the length of <code>scalings</code>. The [r,c,s]-th element of this matrix is the entry in the r-th row and c-th column of <code class="reqn">\exp(scalings[s]\cdot A)</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>R. James, J. Langou and B. R. Lowery (2014). On matrix balancing and eigenvector computation. arXiv:1401.5766
</p>
<p>C. Moler and C. Van Loan (2003). Nineteen dubious ways to compute the exponential of a matrix, twenty-five years later. SIAM Review. 45:3-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random 5 x 5 matrix
A = get_random_mk_transition_matrix(Nstates=5, rate_model="ER")

# calculate exponentials exp(0.1*A) and exp(10*A)
exponentials = exponentiate_matrix(A, scalings=c(0.1,10))

# print 1st exponential: exp(0.1*A)
print(exponentials[,,1])

# print 2nd exponential: exp(10*A)
print(exponentials[,,2])
</code></pre>

<hr>
<h2 id='extend_tree_to_height'>
Extend a rooted tree up to a specific height.
</h2><span id='topic+extend_tree_to_height'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a specific distance from the root (&ldquo;new height&rdquo;), elongate terminal edges (i.e. leading into tips) as needed so that all tips have a distance from the root equal to the new height. If a tip already extends beyond the specified new height, its incoming edge remains unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_tree_to_height(tree, new_height=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_tree_to_height_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="extend_tree_to_height_+3A_new_height">new_height</code></td>
<td>

<p>Numeric, specifying the phylogenetic distance from the root to which tips are to be extended. If <code>NULL</code> or negative, then it is set to the maximum distance of any tip from the root.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). All tip, edge and node indices remain unchanged. This function provides a quick-and-dirty way to make a tree ultrametric, or to correct small numerical inaccuracies in supposed-to-be ultrametric trees.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, representing the extended tree.
</p>
</td></tr>
<tr><td><code>max_extension</code></td>
<td>

<p>Numeric. The largest elongation added to a terminal edge.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim_tree_at_height">trim_tree_at_height</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random non-ultrametric tree
tree = generate_random_tree(list(birth_rate_intercept=1,death_rate_intercept=0.5),
                            max_time=1000,
                            coalescent=FALSE)$tree
                            
# print min &amp; max distance from root
span = get_tree_span(tree)
cat(sprintf("Min &amp; max tip height = %g &amp; %g\n",span$min_distance,span$max_distance))

# make tree ultrametric by extending terminal edges
extended = extend_tree_to_height(tree)$tree

# print new min &amp; max distance from root
span = get_tree_span(extended)
cat(sprintf("Min &amp; max tip height = %g &amp; %g\n",span$min_distance,span$max_distance))
</code></pre>

<hr>
<h2 id='extract_deep_frame'>
Extract tips representing a tree's deep splits.
</h2><span id='topic+extract_deep_frame'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, extract a subset of tips representing the tree's deepest splits (nodes), thus obtaining a rough &quot;frame&quot; of the tree. For example, if <code>Nsplits=1</code> and the tree is bifurcating, then two tips will be extracted representing the two clades splitting at the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_deep_frame(tree,
                   Nsplits    = 1,
                   only_tips  = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_deep_frame_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="extract_deep_frame_+3A_nsplits">Nsplits</code></td>
<td>

<p>Strictly positive integer, specifying the maximum number of splits to descend from the root. A larger value generally implies that more tips will be extracted, representing a larger number of splits.
</p>
</td></tr>
<tr><td><code id="extract_deep_frame_+3A_only_tips">only_tips</code></td>
<td>

<p>Boolean, specifying whether to only return the subset of extracted tips, rather than the subtree spanned by those tips. If <code>FALSE</code>, a subtree is returned in addition to the tips (this comes at a computational cost).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). No guarantee is made as to the precise subset of tips extracted.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>tips</code></td>
<td>

<p>Integer vector with values from 1 to Ntips, listing the indices of the extracted tips.
</p>
</td></tr>
<tr><td><code>subtree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, the subtree spanned by the extracted tips. Only included if <code>only_tips==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_mrcas">get_pairwise_mrcas</a></code>, <code><a href="#topic+get_tips_for_mrcas">get_tips_for_mrcas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_factor=0.1),Ntips)$tree

# extract a subtree representing the deep splits
subtree = extract_deep_frame(tree, Nsplits=3)$subtree

</code></pre>

<hr>
<h2 id='extract_fasttree_constraints'>
Extract tree constraints in FastTree alignment format.
</h2><span id='topic+extract_fasttree_constraints'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, extract binary constraints in FastTree alignment format. Every internal bifurcating node with more than 2 descending tips will constitute an separate constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fasttree_constraints(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_fasttree_constraints_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to define constraints based on a backbone subtree, to be used to generate a larger tree using FastTree (as of v2.1.11). Only bifurcating nodes with at least 3 descending tips are used as constraints. 
</p>
<p>The constraints are returned as a 2D matrix; the actual fasta file with the constraint alignments can be written easily from this matrix. For more details on FastTree constraints see the original FastTree documentation.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Nconstraints</code></td>
<td>

<p>Integer, specifying the number of constraints extracted.
</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>

<p>2D character matrix of size Ntips x Nconstraints, with values '0', '1' or '-', specifying which side (&quot;left&quot; or &quot;right&quot;) of a constraint (node) each tip is found on.
</p>
</td></tr>
<tr><td><code>constraint2node</code></td>
<td>

<p>Integer vector of size Nconstraints, with values in 1,..,Nnodes, specifying the original node index used to define each constraint.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a simple rooted tree, with tip names tip.1, tip.2, ...
Ntips = 10
tree  = generate_random_tree(list(birth_rate_intercept=1),
                             max_tips=Ntips,
                             tip_basename="tip.")$tree

# extract constraints
constraints = castor::extract_fasttree_constraints(tree)$constraints

# print constraints to screen in fasta format
cat(paste(sapply(1:Ntips, 
    FUN=function(tip) sprintf("&gt;%s\n%s\n",tree$tip.label[tip],
    paste(as.character(constraints[tip,]),collapse=""))),collapse=""))
</code></pre>

<hr>
<h2 id='extract_tip_neighborhood'>
Extract a subtree spanning tips within a certain neighborhood.
</h2><span id='topic+extract_tip_neighborhood'></span>

<h3>Description</h3>

<p>Given a rooted tree and a focal tip, extract a subtree comprising various representative nodes and tips in the vicinity of the focal tip using a heuristic algorithm. This may be used for example to display closely related taxa from a reference tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_tip_neighborhood(tree, 
                   focal_tip,
                   Nbackward,
                   Nforward,
                   force_tips 		= NULL,
                   include_subtree 	= TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_tip_neighborhood_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="extract_tip_neighborhood_+3A_focal_tip">focal_tip</code></td>
<td>

<p>Either a character, specifying the name of the focal tip, or an integer between 1 and Ntips, specifying the focal tip's index.
</p>
</td></tr>
<tr><td><code id="extract_tip_neighborhood_+3A_nbackward">Nbackward</code></td>
<td>

<p>Integer &gt;=1, specifying how many splits backward (towards the root) to explore. A larger value of <code>Nbackward</code> will generally lead to a larger extracted subtree (i.e., including deeper splits).
</p>
</td></tr>
<tr><td><code id="extract_tip_neighborhood_+3A_nforward">Nforward</code></td>
<td>

<p>Non-negative integer, specifying how many splits forward (towards the tips) to explore. A larger value of <code>Nforward</code> will generally lead to a larger extracted subtree (i.e., including more representative tips from each sister branch).
</p>
</td></tr>
<tr><td><code id="extract_tip_neighborhood_+3A_force_tips">force_tips</code></td>
<td>

<p>Optional integer or character list, specifying indices or names of tips to force-include in any case.
</p>
</td></tr>
<tr><td><code id="extract_tip_neighborhood_+3A_include_subtree">include_subtree</code></td>
<td>

<p>Logical, whether to actually extract the subtree, rather than just returning the inferred neighbor tips.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence which tips are extracted.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>neighbor_tips</code></td>
<td>

<p>Integer vector with values in 1,..,Ntips, specifying which tips were found to be neighbors of the focal tip.
</p>
</td></tr>
<tr><td><code>subtree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing a subset of the tips and nodes in the vicinity of the focal tip. Only returned if <code>include_subtree=TRUE</code>.
</p>
</td></tr>
<tr><td><code>new2old_tip</code></td>
<td>

<p>Integer vector of length Ntips_extracted (=number of tips in the extracted subtree) with values in 1,..,Ntips, mapping tip indices of the extracted subtree to tip indices in the original tree. In particular, <code>tree$tip.label[new2old_tip]</code> will be equal to <code>subtree$tip.label</code>. Only returned if <code>include_subtree=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_subtree_with_tips">get_subtree_with_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 50
tree  = generate_random_tree(list(birth_rate_factor=0.1),
                             max_tips = Ntips,
                             tip_basename="tip.")$tree

# extract a subtree in the vicinity of a focal tip
subtree = extract_tip_neighborhood(tree, 
                                   focal_tip="tip.39",
                                   Nbackward=5,
                                   Nforward=2)$subtree
</code></pre>

<hr>
<h2 id='extract_tip_radius'>
Extract a subtree spanning tips within a certain radius.
</h2><span id='topic+extract_tip_radius'></span>

<h3>Description</h3>

<p>Given a rooted tree, a focal tip and a phylogenetic (patristic) distance radius, extract a subtree comprising all tips located within the provided radius from the focal tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_tip_radius(tree, 
                   focal_tip,
                   radius,
                   include_subtree = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_tip_radius_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="extract_tip_radius_+3A_focal_tip">focal_tip</code></td>
<td>

<p>Either a character, specifying the name of the focal tip, or an integer between 1 and Ntips, specifying the focal tip's index.
</p>
</td></tr>
<tr><td><code id="extract_tip_radius_+3A_radius">radius</code></td>
<td>

<p>Non-negative numeric, specifying the patristic distance radius to consider around the focal tip.
</p>
</td></tr>
<tr><td><code id="extract_tip_radius_+3A_include_subtree">include_subtree</code></td>
<td>

<p>Logical, whether to actually extract the subtree, rather than just returning the inferred within-radius tips.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;patristic distance&quot; between two tips and/or nodes is the shortest cumulative branch length that must be traversed along the tree in order to reach one tip/node from the other. If <code>tree$edge.length</code> is missing, then each edge is assumed to be of length 1.
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence which tips are extracted.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>radius_tips</code></td>
<td>

<p>Integer vector with values in 1,..,Ntips, specifying which tips were found to be within the specified radius of the focal tip.
</p>
</td></tr>
<tr><td><code>subtree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing only the tips within the specified radius from the focal tip, and the nodes &amp; edges connecting those tips to the root. Only returned if <code>include_subtree=TRUE</code>.
</p>
</td></tr>
<tr><td><code>new2old_tip</code></td>
<td>

<p>Integer vector of length Ntips_extracted (=number of tips in the extracted subtree, i.e., within the specified distance radius from the focal tip) with values in 1,..,Ntips, mapping tip indices of the extracted subtree to tip indices in the original tree. In particular, <code>tree$tip.label[new2old_tip]</code> will be equal to <code>subtree$tip.label</code>. Only returned if <code>include_subtree=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_distances_to_tip">get_all_distances_to_tip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 50
tree  = generate_random_tree(list(birth_rate_factor=0.1),
                             max_tips = Ntips,
                             tip_basename="tip.")$tree

# extract all tips within radius 50 from a focal tip
subtree = extract_tip_radius(tree, 
                             focal_tip="tip.39",
                             radius=50)$subtree
</code></pre>

<hr>
<h2 id='find_farthest_tip_pair'>
Find the two most distant tips in a tree.
</h2><span id='topic+find_farthest_tip_pair'></span>

<h3>Description</h3>

<p>Given a phylogenetic tree, find the two most phylogenetically distant tips (to each other) in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_farthest_tip_pair(tree, as_edge_counts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_farthest_tip_pair_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. While the tree must be rooted for technical reasons, the outcome does not actually depend on the rooting.
</p>
</td></tr>
<tr><td><code id="find_farthest_tip_pair_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether to count phylogenetic distance in terms of edge counts instead of cumulative edge lengths. This is the same as setting all edge lengths to 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree$edge.length</code> is missing or NULL, then each edge is assumed to have length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>tip1</code></td>
<td>

<p>An integer between 1 and Ntips, specifying the first of the two most distant tips.
</p>
</td></tr>
<tr><td><code>tip2</code></td>
<td>

<p>An integer between 1 and Ntips, specifying the second of the two most distant tips.
</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>

<p>Numeric, specifying the phylogenetic (patristic) distance between the <code>farthest_tip1</code> and <code>farthest_tip2</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_nearest_tips">find_nearest_tips</a></code>, <code><a href="#topic+find_farthest_tips">find_farthest_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
parameters = list(birth_rate_intercept=1,death_rate_intercept=0.9)
tree = generate_random_tree(parameters,Ntips,coalescent=FALSE)$tree

# find farthest pair of tips
results = find_farthest_tip_pair(tree)

# print results
cat(sprintf("Tip %d and %d have distance %g\n",
            results$tip1,results$tip2,results$distance))
</code></pre>

<hr>
<h2 id='find_farthest_tips'>
Find farthest tip to each tip &amp; node of a tree.
</h2><span id='topic+find_farthest_tips'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a subset of potential target tips, for each tip and node in the tree find the farthest target tip. The set of target tips can also be taken as the whole set of tips in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_farthest_tips( tree, 
                    only_descending_tips = FALSE, 
                    target_tips          = NULL, 
                    as_edge_counts       = FALSE, 
                    check_input          = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_farthest_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="find_farthest_tips_+3A_only_descending_tips">only_descending_tips</code></td>
<td>

<p>A logical indicating whether the farthest tip to a node or tip should be chosen from its descending tips only. If FALSE, then the whole set of possible target tips is considered.
</p>
</td></tr>
<tr><td><code id="find_farthest_tips_+3A_target_tips">target_tips</code></td>
<td>

<p>Optional integer vector or character vector listing the subset of target tips to restrict the search to. If an integer vector, this should list tip indices (values in 1,..,Ntips). If a character vector, it should list tip names (in this case <code>tree$tip.label</code> must exist). If <code>target_tips</code> is <code>NULL</code>, then all tips of the tree are considered as target tips.
</p>
</td></tr>
<tr><td><code id="find_farthest_tips_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether to count phylogenetic distance in terms of edge counts instead of cumulative edge lengths. This is the same as setting all edge lengths to 1.
</p>
</td></tr>
<tr><td><code id="find_farthest_tips_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>only_descending_tips</code> is <code>TRUE</code>, then only descending target tips are considered when searching for the farthest target tip of a node/tip. In that case, if a node/tip has no descending target tip, its farthest target tip is set to NA. If <code>tree$edge.length</code> is missing or NULL, then each edge is assumed to have length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>farthest_tip_per_tip</code></td>
<td>

<p>An integer vector of size Ntips, listing the farthest target tip for each tip in the tree. Hence, <code>farthest_tip_per_tip[i]</code> is the index of the farthest tip (from the set of target tips), with respect to tip i (where i=1,..,Ntips). Some values may appear multiple times in this vector, if multiple tips share the same farthest target tip.
</p>
</td></tr>
<tr><td><code>farthest_tip_per_node</code></td>
<td>

<p>An integer vector of size Nnodes, listing the index of the farthest target tip for each node in the tree. Hence, <code>farthest_tip_per_node[i]</code> is the index of the farthest tip (from the set of target tips), with respect to node i (where i=1,..,Nnodes). Some values may appear multiple times in this vector, if multiple nodes share the same farthest target tip.
</p>
</td></tr>
<tr><td><code>farthest_distance_per_tip</code></td>
<td>

<p>Integer vector of size Ntips. Phylogenetic (&quot;patristic&quot;) distance of each tip in the tree to its farthest target tip. If <code>only_descending_tips</code> was set to <code>TRUE</code>, then <code>farthest_distance_per_tip[i]</code> will be set to infinity for any tip i that is not a target tip.
</p>
</td></tr>
<tr><td><code>farthest_distance_per_node</code></td>
<td>

<p>Integer vector of size Nnodes. Phylogenetic (&quot;patristic&quot;) distance of each node in the tree to its farthest target tip. If <code>only_descending_tips</code> was set to <code>TRUE</code>, then <code>farthest_distance_per_node[i]</code> will be set to infinity for any node i that has no descending target tips.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>M. G. I. Langille, J. Zaneveld, J. G. Caporaso et al (2013). Predictive functional profiling of microbial communities using 16S rRNA marker gene sequences. Nature Biotechnology. 31:814-821.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_nearest_tips">find_nearest_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
parameters = list(birth_rate_intercept=1,death_rate_intercept=0.9)
tree = generate_random_tree(parameters,Ntips,coalescent=FALSE)$tree

# pick a random set of "target" tips
target_tips = sample.int(n=Ntips, size=5, replace=FALSE)

# find farthest target tip to each tip &amp; node in the tree
results = find_farthest_tips(tree, target_tips=target_tips)

# plot histogram of distances to target tips (across all tips of the tree)
distances = results$farthest_distance_per_tip
hist(distances, breaks=10, xlab="farthest distance", ylab="number of tips", prob=FALSE);
</code></pre>

<hr>
<h2 id='find_nearest_tips'>
Find nearest tip to each tip &amp; node of a tree.
</h2><span id='topic+find_nearest_tips'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a subset of potential target tips, for each tip and node in the tree find the nearest target tip. The set of target tips can also be taken as the whole set of tips in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_nearest_tips(tree, 
                  only_descending_tips = FALSE, 
                  target_tips          = NULL, 
                  as_edge_counts       = FALSE, 
                  check_input          = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_nearest_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="find_nearest_tips_+3A_only_descending_tips">only_descending_tips</code></td>
<td>

<p>A logical indicating whether the nearest tip to a node or tip should be chosen from its descending tips only. If FALSE, then the whole set of possible target tips is considered.
</p>
</td></tr>
<tr><td><code id="find_nearest_tips_+3A_target_tips">target_tips</code></td>
<td>

<p>Optional integer vector or character vector listing the subset of target tips to restrict the search to. If an integer vector, this should list tip indices (values in 1,..,Ntips). If a character vector, it should list tip names (in this case <code>tree$tip.label</code> must exist). If <code>target_tips</code> is <code>NULL</code>, then all tips of the tree are considered as target tips.
</p>
</td></tr>
<tr><td><code id="find_nearest_tips_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether to count phylogenetic distance in terms of edge counts instead of cumulative edge lengths. This is the same as setting all edge lengths to 1.
</p>
</td></tr>
<tr><td><code id="find_nearest_tips_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Langille et al. (2013) introduced the Nearest Sequenced Taxon Index (NSTI) as a measure for how well a set of microbial operational taxonomic units (OTUs) is represented by a set of sequenced genomes of related organisms. Specifically, the NSTI of a microbial community is the average phylogenetic distance of any OTU in the community, to the closest relative with an available sequenced genome (&quot;target tips&quot;). In analogy to the NSTI, the function <code>find_nearest_tips</code> provides a means to find the nearest tip (from a subset of target tips) to each tip and node in a phylogenetic tree, together with the corresponding phylogenetic (&quot;patristic&quot;) distance. 
</p>
<p>If <code>only_descending_tips</code> is <code>TRUE</code>, then only descending target tips are considered when searching for the nearest target tip of a node/tip. In that case, if a node/tip has no descending target tip, its nearest target tip is set to NA. If <code>tree$edge.length</code> is missing or NULL, then each edge is assumed to have length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>nearest_tip_per_tip</code></td>
<td>

<p>An integer vector of size Ntips, listing the nearest target tip for each tip in the tree. Hence, <code>nearest_tip_per_tip[i]</code> is the index of the nearest tip (from the set of target tips), with respect to tip i (where i=1,..,Ntips). Some values may appear multiple times in this vector, if multiple tips share the same nearest target tip.
</p>
</td></tr>
<tr><td><code>nearest_tip_per_node</code></td>
<td>

<p>An integer vector of size Nnodes, listing the index of the nearest target tip for each node in the tree. Hence, <code>nearest_tip_per_node[i]</code> is the index of the nearest tip (from the set of target tips), with respect to node i (where i=1,..,Nnodes). Some values may appear multiple times in this vector, if multiple nodes share the same nearest target tip.
</p>
</td></tr>
<tr><td><code>nearest_distance_per_tip</code></td>
<td>

<p>Numeric vector of size Ntips. Phylogenetic (&quot;patristic&quot;) distance of each tip in the tree to its nearest target tip. If <code>only_descending_tips</code> was set to <code>TRUE</code>, then <code>nearest_distance_per_tip[i]</code> will be set to infinity for any tip i that is not a target tip.
</p>
</td></tr>
<tr><td><code>nearest_distance_per_node</code></td>
<td>

<p>Numeric vector of size Nnodes. Phylogenetic (&quot;patristic&quot;) distance of each node in the tree to its nearest target tip. If <code>only_descending_tips</code> was set to <code>TRUE</code>, then <code>nearest_distance_per_node[i]</code> will be set to infinity for any node i that has no descending target tips.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>M. G. I. Langille, J. Zaneveld, J. G. Caporaso et al (2013). Predictive functional profiling of microbial communities using 16S rRNA marker gene sequences. Nature Biotechnology. 31:814-821.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_farthest_tips">find_farthest_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick a random set of "target" tips
target_tips = sample.int(n=Ntips, size=as.integer(Ntips/10), replace=FALSE)

# find nearest target tip to each tip &amp; node in the tree
results = find_nearest_tips(tree, target_tips=target_tips)

# plot histogram of distances to target tips (across all tips of the tree)
distances = results$nearest_distance_per_tip
hist(distances, breaks=10, xlab="nearest distance", ylab="number of tips", prob=FALSE);
</code></pre>

<hr>
<h2 id='find_root'>
Find the root of a tree.
</h2><span id='topic+find_root'></span>

<h3>Description</h3>

<p>Find the root of a phylogenetic tree. The root is defined as the unique node with no parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_root(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_root_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;. If the tree is not rooted, the function will return <code>NA</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention, the root of a &quot;phylo&quot; tree is typically the first node (i.e. with index Ntips+1), however this is not always guaranteed. This function finds the root of a tree by searching for the node with no parent. If no such node exists, <code>NA</code> is returned. If multiple such nodes exist, <code>NA</code> is returned. If any node has more than 1 parent, <code>NA</code> is returned. Hence, this function can be used to test if a tree is rooted purely based on the edge structure, assuming that the tree is connected (i.e. not a forest).
</p>
<p>The asymptotic time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>Index of the tree's root, as listed in <code>tree$edge</code>. An integer ranging from Ntips+1 to Ntips+Nnodes, where Ntips and Nnodes is the number of tips and nodes in the tree, respectively. By convention, the root will typically be Ntips+1 but this is not guaranteed.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_root_of_monophyletic_tips">find_root_of_monophyletic_tips</a></code>,
<code><a href="#topic+root_at_node">root_at_node</a></code>,
<code><a href="#topic+root_at_midpoint">root_at_midpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# reroot the tree at the 20-th node
new_root_node = 20
tree = root_at_node(tree, new_root_node, update_indices=FALSE)

# find new root index and compare with expectation
cat(sprintf("New root is %d, expected at %d\n",find_root(tree),new_root_node+Ntips))
</code></pre>

<hr>
<h2 id='find_root_of_monophyletic_tips'>
Find the node or tip that, as root, would make a set of target tips monophyletic.
</h2><span id='topic+find_root_of_monophyletic_tips'></span>

<h3>Description</h3>

<p>Given a tree (rooted or unrooted) and a specific set of target tips, this function finds the tip or node that, if turned into root, would make a set of target tips a monophyletic group that either descends from a single child of the new root (if <code>as_MRCA==FALSE</code>) or whose MRCA is the new root (if <code>as_MRCA==TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_root_of_monophyletic_tips(tree, monophyletic_tips, as_MRCA=TRUE, is_rooted=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_root_of_monophyletic_tips_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted.
</p>
</td></tr>
<tr><td><code id="find_root_of_monophyletic_tips_+3A_monophyletic_tips">monophyletic_tips</code></td>
<td>

<p>Character or integer vector, specifying the names or indices, respectively, of the target tips that should be turned monophyletic. If an integer vector, its elements must be between 1 and Ntips. If a character vector, its elements must be elements in <code>tree$tip.label</code>.
</p>
</td></tr>
<tr><td><code id="find_root_of_monophyletic_tips_+3A_as_mrca">as_MRCA</code></td>
<td>

<p>Logical, specifying whether the new root should become the MRCA of the target tips. If <code>FALSE</code>, the new root is chosen such that the MRCA of the target tips is the child of the new root.
</p>
</td></tr>
<tr><td><code id="find_root_of_monophyletic_tips_+3A_is_rooted">is_rooted</code></td>
<td>

<p>Logical, specifying whether the input tree can be assumed to be rooted. If you are sure that the input tree is rooted, set this to <code>TRUE</code> for computational efficiency, otherwise to be on the safe side set this to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include an arbitrary number of incoming and outgoing edges per node (but only one edge per tip), and the direction of these edges can be arbitrary. Of course, the undirected graph defined by all edges must still be a valid tree (i.e. a connected acyclic graph). Note that this function does not change the tree, it just determines which tip or node should be made root for the target tips to be a monophyletic group.
</p>
<p>The asymptotic time complexity of this function is O(Nedges).
</p>


<h3>Value</h3>

<p>A single integer between 1 and (Ntips+Nnodes), specifying the index of the tip or node that, if made root, would make the target tips monophyletic. If this was not possible, <code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_root">find_root</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# pick a random node and find all descending tips
MRCA = sample.int(tree$Nnode,size=1)
monophyletic_tips = get_subtree_at_node(tree, MRCA)$new2old_tip

# change root of tree (change edge directions)
tree = root_at_node(tree, new_root_node=10, update_indices=FALSE)

# determine root that would make target tips monophyletic
new_root = find_root_of_monophyletic_tips(tree, monophyletic_tips, as_MRCA=TRUE, is_rooted=FALSE)

# compare expectation with result
cat(sprintf("MRCA = %d, new root node=%d\n",MRCA,new_root-Ntips))
</code></pre>

<hr>
<h2 id='fit_and_compare_bm_models'>
Fit and compare Brownian Motion models for multivariate trait evolution between two data sets.
</h2><span id='topic+fit_and_compare_bm_models'></span>

<h3>Description</h3>

<p>Given two rooted phylogenetic trees and states of one or more continuous (numeric) traits on the trees' tips, fit a multivariate Brownian motion model of correlated evolution to each data set and compare the fitted models. This function estimates the diffusivity matrix for each data set (i.e., each tree/tip-states set) via maximum-likelihood and assesses whether the log-difference between the two fitted diffusivity matrixes is statistically significant, under the null hypothesis that the two data sets exhibit the same diffusivity. Optionally, multiple trees can be used as input for each data set, under the assumption that the trait evolved on each tree according to the same BM model. For more details on how BM is fitted to each data set see the function <code><a href="#topic+fit_bm_model">fit_bm_model</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_and_compare_bm_models(  trees1, 
                            tip_states1,
                            trees2,
                            tip_states2,
                            Nbootstraps     = 0,
                            Nsignificance   = 0,
                            check_input     = TRUE,
                            verbose         = FALSE,
                            verbose_prefix  = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_and_compare_bm_models_+3A_trees1">trees1</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;, corresponding to the first data set on which a BM model is to be fitted. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_tip_states1">tip_states1</code></td>
<td>

<p>Numeric state of each trait at each tip in each tree in the first data set. If <code>trees1</code> is a single tree, then <code>tip_states1</code> must either be a numeric vector of size Ntips or a 2D numeric matrix of size Ntips x Ntraits, listing the trait states for each tip in the tree.
If <code>trees1</code> is a list of Ntrees trees, then <code>tip_states1</code> must be a list of length Ntrees, each element of which lists the trait states for the corresponding tree (as a vector or 2D matrix, similarly to the single-tree case).
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_trees2">trees2</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;, corresponding to the second data set on which a BM model is to be fitted. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_tip_states2">tip_states2</code></td>
<td>

<p>Numeric state of each trait at each tip in each tree in the second data set, similarly to <code>tip_states1</code>.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for calculating the confidence intervals of BM diffusivities fitted to each data set. If &lt;=0, no bootstrapping is performed.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_nsignificance">Nsignificance</code></td>
<td>

<p>Integer, specifying the number of simulations to perform for assessing the statistical significance of the log-transformed difference between the diffusivities fitted to the two data sets, i.e. of <code class="reqn">|\log(D_1)-\log(D_2)|</code>. Set to 0 to not calculate the statistical significance. See below for additional details.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress report messages to the screen.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_bm_models_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying a prefix to include in front of progress report messages on each line. Only relevant if <code>verbose==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the Brownian Motion model see <code><a href="#topic+fit_bm_model">fit_bm_model</a></code> and <code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>. This function separately fits a single-variate or multi-variate BM model with constant diffusivity (diffusivity matrix, in the multivariate case) to each data set; internally, this function applies <code>fit_bm_model</code> to each data set. 
</p>
<p>If <code>Nsignificance&gt;0</code>, the statistical significance of the log-transformed difference of the two fitted diffusivity matrixes, <code class="reqn">|\log(D_1)-\log(D_2)|</code>, is assessed, under the null hypothesis that both data sets were generated by the same common BM model. The diffusivity of this common BM model is estimated by fitting to both datasets at once, i.e. after merging the two datasets into a single dataset of trees and tip states (see return variable <code>fit_common</code> below). For each of the <code>Nsignificance</code> random simulations of the common BM model on the two tree sets, the diffusivities are again separately fitted on the two simulated sets and the resulting log-difference is compared to the one of the original data sets. The returned <code>significance</code> is the probability that the diffusivities would have a log-difference larger than the observed one, if the two data sets had been generated under the common BM model.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child). Note that multifurcations are internally expanded to bifurcations, prior to model fitting.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful for both data sets. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>fit1</code></td>
<td>

<p>A named list containing the fitting results for the first data set, in the same format as returned by <code><a href="#topic+fit_bm_model">fit_bm_model</a></code>. In particular, the diffusivity fitted to the first data set will be stored in <code>fit1$diffusivity</code>.
</p>
</td></tr>
<tr><td><code>fit2</code></td>
<td>

<p>A named list containing the fitting results for the second data set, in the same format as returned by <code><a href="#topic+fit_bm_model">fit_bm_model</a></code>. In particular, the diffusivity fitted to the second data set will be stored in <code>fit2$diffusivity</code>.
</p>
</td></tr>
<tr><td><code>log_difference</code></td>
<td>

<p>The absolute difference between the log-transformed diffusivities, i.e. <code class="reqn">|\log(D_1)-\log(D_2)|</code>. In the multivariate case, this will be a matrix of size Ntraits x Ntraits.
</p>
</td></tr>
<tr><td><code>significance</code></td>
<td>

<p>Numeric, statistical significance of the observed log-difference under the null hypothesis that the two data sets were generated by a common BM model. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
<tr><td><code>fit_common</code></td>
<td>

<p>A named list containing the fitting results for the two data sets combined, in the same format as returned by <code><a href="#topic+fit_bm_model">fit_bm_model</a></code>. The common diffusivity, <code>fit_common$diffusivity</code> is used for the random simulations when assessing the statistical significance of the log-difference of the separately fitted diffusivities. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the Comparative Method. The American Naturalist. 125:1-15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>,
<code><a href="#topic+fit_bm_model">fit_bm_model</a></code>,
<code><a href="#topic+get_independent_contrasts">get_independent_contrasts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate distinct BM models on two random trees
D1 = 1
D2 = 2
tree1 = generate_random_tree(list(birth_rate_factor=1),max_tips=100)$tree
tree2 = generate_random_tree(list(birth_rate_factor=1),max_tips=100)$tree
tip_states1 = simulate_bm_model(tree1, diffusivity = D1)$tip_states
tip_states2 = simulate_bm_model(tree2, diffusivity = D2)$tip_states

# fit and compare BM models between the two data sets
fit = fit_and_compare_bm_models(trees1          = tree1, 
                                tip_states1     = tip_states1, 
                                trees2          = tree2,
                                tip_states2     = tip_states2,
                                Nbootstraps     = 100,
                                Nsignificance   = 100)

# print summary of results
cat(sprintf("Fitted D1 = %g, D2 = %g, significance of log-diff. = %g\n",
            fit$fit1$diffusivity, fit$fit2$diffusivity, fit$significance))
</code></pre>

<hr>
<h2 id='fit_and_compare_sbm_const'>
Fit and compare Spherical Brownian Motion models for diffusive geographic dispersal between two data sets.
</h2><span id='topic+fit_and_compare_sbm_const'></span>

<h3>Description</h3>

<p>Given two rooted phylogenetic trees and geographic coordinates of the trees' tips, fit a Spherical Brownian Motion (SBM) model of diffusive geographic dispersal with constant diffusivity to each tree and compare the fitted models. This function estimates the diffusivity (<code class="reqn">D</code>) for each data set (i.e., each set of trees + tip-coordinates) via maximum-likelihood and assesses whether the log-difference between the two fitted diffusivities is statistically significant, under the null hypothesis that the two data sets exhibit the same diffusivity. Optionally, multiple trees can be used as input for each data set, under the assumption that dispersal occurred according to the same diffusivity in each tree of that dataset. For more details on how SBM is fitted to each data set see the function <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_and_compare_sbm_const(  trees1, 
                            tip_latitudes1,
                            tip_longitudes1,
                            trees2,
                            tip_latitudes2,
                            tip_longitudes2,
                            radius,
                            planar_approximation    = FALSE,
                            only_basal_tip_pairs    = FALSE,
                            only_distant_tip_pairs  = FALSE,
                            min_MRCA_time           = 0,
                            max_MRCA_age            = Inf,
                            max_phylodistance       = Inf,
                            min_diffusivity         = NULL,
                            max_diffusivity         = NULL,
                            Nbootstraps             = 0,
                            Nsignificance           = 0,
                            SBM_PD_functor          = NULL,
                            verbose                 = FALSE,
                            verbose_prefix          = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_and_compare_sbm_const_+3A_trees1">trees1</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;, corresponding to the first data set on which an SBM model is to be fitted. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_tip_latitudes1">tip_latitudes1</code></td>
<td>

<p>Numeric vector listing the latitude (in decimal degrees) of each tip in each tree in the first data set. If <code>trees1</code> is a single tree, then <code>tip_latitudes1</code> must be a numeric vector of size Ntips, listing the latitudes for each tip in the tree.
If <code>trees1</code> is a list of Ntrees trees, then <code>tip_latitudes1</code> must be a list of length Ntrees, each element of which lists the latitudes for the corresponding tree (as a vector, similarly to the single-tree case).
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_tip_longitudes1">tip_longitudes1</code></td>
<td>

<p>Similar to <code>tip_latitudes1</code>, but listing longitudes (in decimal degrees) of each tip in each tree in the first data set.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_trees2">trees2</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;, corresponding to the second data set on which an SBM model is to be fitted. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_tip_latitudes2">tip_latitudes2</code></td>
<td>

<p>Numeric vector listing the latitude (in decimal degrees) of each tip in each tree in the second data set, similarly to <code>tip_latitudes1</code>.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_tip_longitudes2">tip_longitudes2</code></td>
<td>

<p>Numeric vector listing the longitude (in decimal degrees) of each tip in each tree in the second data set, similarly to <code>tip_longitudes1</code>.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_planar_approximation">planar_approximation</code></td>
<td>

<p>Logical, specifying whether to estimate the diffusivity based on a planar approximation of the SBM model, i.e. by assuming that geographic distances between tips are as if tips are distributed on a 2D cartesian plane. This approximation is only accurate if geographical distances between tips are small compared to the sphere's radius.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time&lt;=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_min_diffusivity">min_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the minimum possible diffusivity. If NULL, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_max_diffusivity">max_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the maximum possible diffusivity. If NULL, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for calculating the confidence intervals of SBM diffusivities fitted to each data set. If &lt;=0, no bootstrapping is performed.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_nsignificance">Nsignificance</code></td>
<td>

<p>Integer, specifying the number of simulations to perform for assessing the statistical significance of the linear difference and log-transformed difference between the diffusivities fitted to the two data sets, i.e. of <code class="reqn">|D_1-D_2|</code> and of <code class="reqn">|\log(D_1)-\log(D_2)|</code>. Set to 0 to not calculate statistical significances. See below for additional details.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally and for debugging purposes. Unless you know what you're doing, you should keep this <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress report messages to the screen.
</p>
</td></tr>
<tr><td><code id="fit_and_compare_sbm_const_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying a prefix to include in front of progress report messages on each line. Only relevant if <code>verbose==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the Spherical Brownian Motion model see <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> and <code><a href="#topic+simulate_sbm">simulate_sbm</a></code>. This function separately fits an SBM model with constant diffusivity to each of two data sets; internally, this function applies <code>fit_sbm_const</code> to each data set. 
</p>
<p>If <code>Nsignificance&gt;0</code>, the statistical significance of the linear difference (<code class="reqn">|D_1-D_2|</code>) and log-transformed difference (<code class="reqn">|\log(D_1)-\log(D_2)|</code>) of the two fitted diffusivities is assessed under the null hypothesis that both data sets were generated by the same common SBM model. The diffusivity of this common SBM model is estimated by fitting to both datasets at once, i.e. after merging the two datasets into a single dataset of trees and tip coordinates (see return variable <code>fit_common</code> below). For each of the <code>Nsignificance</code> random simulations of the common SBM model on the two tree sets, the diffusivities are again separately fitted on the two simulated sets and the resulting difference and log-difference is compared to those of the original data sets. The returned <code>lin_significance</code> (or <code>log_significance</code>) is the probability that the diffusivities would have a difference (or log-difference) larger than the observed one, if the two data sets had been generated under the common SBM model.
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. Trees may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful for both data sets. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>fit1</code></td>
<td>

<p>A named list containing the fitting results for the first data set, in the same format as returned by <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>. In particular, the diffusivity fitted to the first data set will be stored in <code>fit1$diffusivity</code>.
</p>
</td></tr>
<tr><td><code>fit2</code></td>
<td>

<p>A named list containing the fitting results for the second data set, in the same format as returned by <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>. In particular, the diffusivity fitted to the second data set will be stored in <code>fit2$diffusivity</code>.
</p>
</td></tr>
<tr><td><code>lin_difference</code></td>
<td>

<p>The absolute difference between the two diffusivities, i.e. <code class="reqn">|D_1-D_2|</code>.
</p>
</td></tr>
<tr><td><code>log_difference</code></td>
<td>

<p>The absolute difference between the two log-transformed diffusivities, i.e. <code class="reqn">|\log(D_1)-\log(D_2)|</code>.
</p>
</td></tr>
<tr><td><code>lin_significance</code></td>
<td>

<p>Numeric, statistical significance of the observed lin-difference under the null hypothesis that the two data sets were generated by a common SBM model. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
<tr><td><code>log_significance</code></td>
<td>

<p>Numeric, statistical significance of the observed log-difference under the null hypothesis that the two data sets were generated by a common SBM model. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
<tr><td><code>fit_common</code></td>
<td>

<p>A named list containing the fitting results for the two data sets combined, in the same format as returned by <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>. The common diffusivity, <code>fit_common$diffusivity</code> is used for the random simulations when assessing the statistical significance of the lin-difference and log-difference of the separately fitted diffusivities. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca (in review as of 2020). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>,
<code><a href="#topic+fit_sbm_linear">fit_sbm_linear</a></code>,
<code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate distinct SBM models on two random trees
radius = 6371   # Earth's radius
D1     = 1      # diffusivity on 1st tree
D2     = 3      # diffusivity on 2nd tree
tree1  = generate_random_tree(list(birth_rate_factor=1),max_tips=100)$tree
tree2  = generate_random_tree(list(birth_rate_factor=1),max_tips=100)$tree
sim1   = simulate_sbm(tree=tree1, radius=radius, diffusivity=D1)
sim2   = simulate_sbm(tree=tree2, radius=radius, diffusivity=D2)
tip_latitudes1  = sim1$tip_latitudes
tip_longitudes1 = sim1$tip_longitudes
tip_latitudes2  = sim2$tip_latitudes
tip_longitudes2 = sim2$tip_longitudes

# fit and compare SBM models between the two hypothetical data sets
fit = fit_and_compare_sbm_const(trees1          = tree1, 
                                tip_latitudes1  = tip_latitudes1, 
                                tip_longitudes1 = tip_longitudes1, 
                                trees2          = tree2,
                                tip_latitudes2  = tip_latitudes2, 
                                tip_longitudes2 = tip_longitudes2, 
                                radius          = radius,
                                Nbootstraps     = 0,
                                Nsignificance   = 100)

# print summary of results
cat(sprintf("Fitted D1 = %g, D2 = %g, significance of log-diff. = %g\n",
            fit$fit1$diffusivity, fit$fit2$diffusivity, fit$log_significance))

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_bm_model'>
Fit a Brownian Motion model for multivariate trait evolution.
</h2><span id='topic+fit_bm_model'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and states of one or more continuous (numeric) traits on the tree's tips, fit a multivariate Brownian motion model of correlated co-evolution of these traits. This estimates a single diffusivity matrix, which describes the variance-covariance structure of each trait's random walk. The model assumes a fixed diffusivity matrix on the entire tree. Optionally, multiple trees can be used as input, under the assumption that the trait evolved on each tree according to the same BM model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_bm_model(   trees, 
                tip_states, 
                isotropic   = FALSE,
                Nbootstraps = 0,
                check_input = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_bm_model_+3A_trees">trees</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;. The root of each tree is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_bm_model_+3A_tip_states">tip_states</code></td>
<td>

<p>Numeric state of each trait at each tip in each tree. If <code>trees</code> was a single tree, then <code>tip_states</code> must either be a numeric vector of size Ntips or a 2D numeric matrix of size Ntips x Ntraits, listing the trait states for each tip in the tree.
If <code>trees</code> is a list of Ntrees trees, then <code>tip_states</code> must be a list of length Ntrees, each element of which lists the trait states for the corresponding tree (as a vector or 2D matrix, similarly to the single-tree case).
</p>
</td></tr>
<tr><td><code id="fit_bm_model_+3A_isotropic">isotropic</code></td>
<td>

<p>Logical, specifying whether diffusion should be assumed to be isotropic (i.e., independent of the direction). Hence, if <code>isotropic=TRUE</code>, then the diffusivity matrix is forced to be diagonal, with all entries being equal. If <code>isotropic=FALSE</code>, an arbitrary diffusivity matrix is fitted (i.e., the diffusivity matrix is only constrained to be symmetric and non-negative definite).
</p>
</td></tr>
<tr><td><code id="fit_bm_model_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for calculating the confidence intervals. If &lt;=0, no bootstrapping is performed.
</p>
</td></tr>
<tr><td><code id="fit_bm_model_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BM model is defined by the stochastic differential equation
</p>
<p style="text-align: center;"><code class="reqn">
dX = \sigma \cdot dW
</code>
</p>

<p>where <code class="reqn">W</code> is a multidimensional Wiener process with Ndegrees independent components and <code class="reqn">\sigma</code> is a matrix of size Ntraits x Ndegrees, sometimes known as &quot;volatility&quot; or &quot;instantaneous variance&quot;. Alternatively, the same model can be defined as a Fokker-Planck equation for the probability density <code class="reqn">\rho</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{\partial \rho}{\partial t} = \sum_{i,j}D_{ij}\frac{\partial^2\rho}{\partial x_i\partial x_j}.
</code>
</p>

<p>The matrix <code class="reqn">D</code> is referred to as the diffusivity matrix (or diffusion tensor), and <code class="reqn">2D=\sigma\cdot\sigma^T</code>. Note that in the multidimensional case <code class="reqn">\sigma</code> can be obtained from <code class="reqn">D</code> by means of a Cholesky decomposition; in the scalar case we have simply <code class="reqn">\sigma=\sqrt{2D}</code>.
</p>
<p>The function uses phylogenetic independent contrasts (Felsenstein, 1985) to retrieve independent increments of the multivariate random walk. The diffusivity matrix <code class="reqn">D</code> is then fitted using maximum-likelihood on the intrinsic geometry of positive-definite matrices. If multiple trees are provided as input, then independent contrasts are extracted from all trees and combined into a single set of independent contrasts (i.e., as if they had been extracted from a single tree).
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child). Note that multifurcations are internally expanded to bifurcations, prior to model fitting.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>diffusivity</code></td>
<td>

<p>Either a single non-negative number (if <code>tip_states</code> was a vector) or a 2D quadratic non-negative-definite matrix (if <code>tip_states</code> was a 2D matrix). The fitted diffusivity matrix of the multivariate Brownian motion model.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model, given the provided tip states data.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The AIC (Akaike Information Criterion) of the fitted model.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The BIC (Bayesian Information Criterion) of the fitted model.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts used to estimate the diffusivity. This corresponds to the number of independent data points used.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Either a single numeric or a 2D numeric matrix of size Ntraits x Ntraits, listing the estimated standard errors of the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Either a single numeric or a 2D numeric matrix of size Ntraits x Ntraits, listing the lower bounds of the 50% confidence interval for the estimated diffusivity (25-75% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Either a single numeric or a 2D numeric matrix of size Ntraits x Ntraits, listing the upper bound of the 50% confidence interval for the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Either a single numeric or a 2D numeric matrix of size Ntraits x Ntraits, listing the lower bound of the 95% confidence interval for the estimated diffusivity (2.5-97.5% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Either a single numeric or a 2D numeric matrix of size Ntraits x Ntraits, listing the upper bound of the 95% confidence interval for the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. If <code class="reqn">L</code> denotes the loglikelihood of new data generated by the fitted model (under the same model) and <code class="reqn">M</code> denotes the expectation of <code class="reqn">L</code>, then <code>consistency</code> is the probability that <code class="reqn">|L-M|</code> will be greater or equal to <code class="reqn">|X-M|</code>, where <code class="reqn">X</code> is the loglikelihood of the original data under the fitted model.
Only returned if <code>Nbootstraps&gt;0</code>. A low consistency (e.g., &lt;0.05) indicates that the fitted model is a poor description of the data. See Lindholm et al. (2019) for background.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the Comparative Method. The American Naturalist. 125:1-15.
</p>
<p>A. Lindholm, D. Zachariah, P. Stoica, T. B. Schoen (2019). Data consistency approach to model validation. IEEE Access. 7:59788-59796.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>,
<code><a href="#topic+get_independent_contrasts">get_independent_contrasts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1), 10000)$tree


# Example 1: Scalar case
# - - - - - - - - - - - - - -
# simulate scalar continuous trait on the tree
D = 1
tip_states = simulate_bm_model(tree, diffusivity=D)$tip_states

# estimate original diffusivity from the generated data
fit = fit_bm_model(tree, tip_states)
cat(sprintf("True D=%g, fitted D=%g\n",D,fit$diffusivity))


# Example 2: Multivariate case
# - - - - - - - - - - - - - - -
# simulate vector-valued continuous trait on the tree
D = get_random_diffusivity_matrix(Ntraits=5)
tip_states = simulate_bm_model(tree, diffusivity=D)$tip_states

# estimate original diffusivity matrix from the generated data
fit = fit_bm_model(tree, tip_states)

# compare true and fitted diffusivity matrices
cat("True D:\n"); print(D)
cat("Fitted D:\n"); print(fit$diffusivity)
</code></pre>

<hr>
<h2 id='fit_hbd_model_on_grid'>
Fit a homogenous birth-death model on a discrete time grid.
</h2><span id='topic+fit_hbd_model_on_grid'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, fit a homogenous birth-death (HBD) model in which speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">mu</code>) are defined on a fixed grid of discrete time points and assumed to vary polynomially between grid points. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates (in the literature this is sometimes referred to simply as &ldquo;birth-death model&rdquo;). Every HBD model is defined based on the values that <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> take over time as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). This function estimates the values of <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> at each grid point by maximizing the likelihood (Morlon et al. 2011) of the timetree under the resulting HBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_model_on_grid(tree, 
                      oldest_age        = NULL,
                      age0              = 0,
                      age_grid          = NULL,
                      min_lambda        = 0,
                      max_lambda        = +Inf,
                      min_mu            = 0,
                      max_mu            = +Inf,
                      min_rho0          = 1e-10,
                      max_rho0          = 1,
                      guess_lambda      = NULL,
                      guess_mu          = NULL,
                      guess_rho0        = 1,
                      fixed_lambda      = NULL,
                      fixed_mu          = NULL,
                      fixed_rho0        = NULL,
                      const_lambda      = FALSE,
                      const_mu          = FALSE,
                      splines_degree    = 1,
                      condition         = "auto",
                      relative_dt       = 1e-3,
                      Ntrials           = 1,
                      Nthreads          = 1,
                      max_model_runtime = NULL,
                      fit_control       = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_model_on_grid_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated reconstructed phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>rho</code> is defined. If <code>age0&gt;0</code>, then <code>rho0</code> refers to the sampling fraction at age <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are included in the tree. See below for more details.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing ages in ascending order, on which <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are allowed to vary independently. This grid must cover <code>age0</code>. If <code>splines_degree&gt;0</code> (see option below) then the age grid must also cover <code>oldest_age</code>. If <code>NULL</code> or of length &lt;=1 (regardless of value), then <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_min_lambda">min_lambda</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted <code class="reqn">\lambda</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_max_lambda">max_lambda</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted <code class="reqn">\lambda</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_min_mu">min_mu</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying lower bounds for the fitted <code class="reqn">\mu</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_max_mu">max_mu</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted <code class="reqn">\mu</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_min_rho0">min_rho0</code></td>
<td>

<p>Numeric, specifying a lower bound for the fitted sampling fraction <code class="reqn">\rho</code> (fraction of extant species included in the tree).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_max_rho0">max_rho0</code></td>
<td>

<p>Numeric, specifying an upper bound for the fitted sampling fraction <code class="reqn">\rho</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_guess_lambda">guess_lambda</code></td>
<td>

<p>Initial guess for <code class="reqn">\lambda</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\lambda</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\lambda</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_guess_mu">guess_mu</code></td>
<td>

<p>Initial guess for <code class="reqn">\mu</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\mu</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\mu</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_guess_rho0">guess_rho0</code></td>
<td>

<p>Numeric, specifying an initial guess for the sampling fraction <code class="reqn">\rho</code> at <code>age0</code>. Setting this to <code>NULL</code> or <code>NA</code> is the same as setting it to 1.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_fixed_lambda">fixed_lambda</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\lambda</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\lambda</code> is not fixed anywhere), or a single numeric (<code class="reqn">\lambda</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (<code class="reqn">\lambda</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_fixed_mu">fixed_mu</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\mu</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\mu</code> is not fixed anywhere), or a single numeric (<code class="reqn">\mu</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (<code class="reqn">\mu</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_fixed_rho0">fixed_rho0</code></td>
<td>

<p>Numeric between 0 and 1, optionallly specifying a fixed value for the sampling fraction <code class="reqn">\rho</code>. If <code>NULL</code> or <code>NA</code>, the sampling fraction <code class="reqn">\rho</code> is estimated, however note that this may not always be meaningful (Stadler 2009, Stadler 2013).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_const_lambda">const_lambda</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\lambda</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_lambda=TRUE</code> reduces the number of free (i.e., independently fitted) parameters.
If <code class="reqn">\lambda</code> is fixed on some grid points (i.e. via <code>fixed_lambda</code>), then only the non-fixed lambdas are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_const_mu">const_mu</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\mu</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_mu=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If <code class="reqn">\mu</code> is fixed on some grid points (i.e. via <code>fixed_mu</code>), then only the non-fixed mus are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> between age-grid points. If 0, then <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are considered piecewise constant, if 1 then <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are considered piecewise linear, if 2 or 3 then <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are considered to be splines of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended, despite the fact that it has been historically popular. The case <code>splines_degree=0</code> is also known as &ldquo;skyline&rdquo; model.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier. &quot;none&quot; is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_on_grid_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: Unless well-justified constraints are imposed on either <code class="reqn">\lambda</code> and/or <code class="reqn">\mu</code> and <code class="reqn">\rho</code>, it is generally impossible to reliably estimate <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> from extant timetrees alone (Louca and Pennell, 2020). This routine (and any other software that claims to estimate <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> solely from extant timetrees) should thus be used with great suspicion. If your only source of information is an extant timetree, and you have no a priori information on how <code class="reqn">\lambda</code> or <code class="reqn">\mu</code> might have looked like, you should consider using the more appropriate routines <code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code> and <code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code> instead.
</p>
<p>If <code>age0&gt;0</code>, the input tree is essentially trimmed at <code>age0</code> (omitting anything younger than <code>age0</code>), and the various variables are fitted to this new (shorter) tree, with time shifted appropriately. For example, the fitted <code>rho0</code> is thus the sampling fraction at <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are represented in the timetree.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbd_model_on_grid</code> as possible, including reasonable lower and upper bounds (<code>min_lambda</code>, <code>max_lambda</code>, <code>min_mu</code>, <code>max_mu</code>, <code>min_rho0</code> and <code>max_rho0</code>) and a reasonable parameter guess (<code>guess_lambda</code>, <code>guess_mu</code> and <code>guess_rho0</code>). It is also important that the <code>age_grid</code> is sufficiently fine to capture the expected major variations of <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> over time, but keep in mind the serious risk of overfitting when <code>age_grid</code> is too fine and/or the tree is too small.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>fitted_lambda</code></td>
<td>

<p>Numeric vector of size Ngrid, listing fitted or fixed speciation rates <code class="reqn">\lambda</code> at each age-grid point. Between grid points <code class="reqn">\lambda</code> should be interpreted as a piecewise polynomial function (natural spline) of degree <code>splines_degree</code>; to evaluate this function at arbitrary ages use the <code>castor</code> routine <code><a href="#topic+evaluate_spline">evaluate_spline</a></code>.
</p>
</td></tr>
<tr><td><code>fitted_mu</code></td>
<td>

<p>Numeric vector of size Ngrid, listing fitted or fixed extinction rates <code class="reqn">\mu</code> at each age-grid point. Between grid points <code class="reqn">\mu</code> should be interpreted as a piecewise polynomial function (natural spline) of degree <code>splines_degree</code>; to evaluate this function at arbitrary ages use the <code>castor</code> routine <code><a href="#topic+evaluate_spline">evaluate_spline</a></code>.
</p>
</td></tr>
<tr><td><code>fitted_rho</code></td>
<td>

<p>Numeric, specifying the fitted or fixed sampling fraction <code class="reqn">\rho</code>.
</p>
</td></tr>
<tr><td><code>guess_lambda</code></td>
<td>

<p>Numeric vector of size Ngrid, specifying the initial guess for <code class="reqn">\lambda</code> at each age-grid point.
</p>
</td></tr>
<tr><td><code>guess_mu</code></td>
<td>

<p>Numeric vector of size Ngrid, specifying the initial guess for <code class="reqn">\mu</code> at each age-grid point.
</p>
</td></tr>
<tr><td><code>guess_rho0</code></td>
<td>

<p>Numeric, specifying the initial guess for <code class="reqn">\rho</code>.
</p>
</td></tr>
<tr><td><code>age_grid</code></td>
<td>

<p>The age-grid on which <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> are defined. This will be the same as the provided <code>age_grid</code>, unless the latter was <code>NULL</code> or of length &lt;=1.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of free (i.e., independently) fitted parameters. If none of the <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho</code> were fixed, and <code>const_lambda=FALSE</code> and <code>const_mu=FALSE</code>, then <code>NFP</code> will be equal to 2*Ngrid+1.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>

<p>Character, specifying what conditioning was root for the likelihood (e.g. &quot;crown&quot; or &quot;stem&quot;).
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler (2009). On incomplete sampling under birth-death models and connections to the sampling-based coalescent. Journal of Theoretical Biology. 261:58-66.
</p>
<p>T. Stadler (2013). How can we improve accuracy of macroevolutionary rate estimates? Systematic Biology. 62:321-329.
</p>
<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
sim       = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)
tree = sim$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))


# Fit mu on grid
# Assume that lambda &amp; rho are known
Ngrid     = 5
age_grid  = seq(from=0,to=root_age,length.out=Ngrid)
fit = fit_hbd_model_on_grid(tree, 
          age_grid    = age_grid,
          max_mu      = 100,
          fixed_lambda= approx(x=time_grid,y=lambdas,xout=sim$final_time-age_grid)$y,
          fixed_rho0   = rho,
          condition   = "crown",
          Ntrials     = 10,	# perform 10 fitting trials
          Nthreads    = 2,	# use two CPUs
          max_model_runtime = 1) 	# limit model evaluation to 1 second
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
  cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
  
  # plot fitted &amp; true mu
  plot( x     = fit$age_grid,
        y     = fit$fitted_mu,
        main  = 'Fitted &amp; true mu',
        xlab  = 'age',
        ylab  = 'mu',
        type  = 'b',
        col   = 'red',
        xlim  = c(root_age,0))
  lines(x     = sim$final_time-time_grid,
        y     = mus,
        type  = 'l',
        col   = 'blue');
        
  # get fitted mu as a function of age
  mu_fun = approxfun(x=fit$age_grid, y=fit$fitted_mu)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_model_parametric'>
Fit a parametric homogenous birth-death model to a timetree.
</h2><span id='topic+fit_hbd_model_parametric'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, fit a homogenous birth-death (HBD) model in which speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) are given as parameterized functions of time before present.  &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates (in the literature this is sometimes referred to simply as &ldquo;birth-death model&rdquo;). Every HBD model is defined based on the values that <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> take over time as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled); in turn, <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho</code> can be parameterized by a finite set of parameters. This function estimates these parameters by maximizing the likelihood (Morlon et al. 2011) of the timetree under the resulting HBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_model_parametric( tree, 
                          param_values,
                          param_guess           = NULL,
                          param_min             = -Inf,
                          param_max             = +Inf,
                          param_scale           = NULL,
                          oldest_age            = NULL,
                          age0                  = 0,
                          lambda,
                          mu                    = 0,
                          rho0                  = 1,
                          age_grid              = NULL,
                          condition             = "auto",
                          relative_dt           = 1e-3,
                          Ntrials               = 1,
                          max_start_attempts    = 1,
                          Nthreads              = 1,
                          max_model_runtime     = NULL,
                          Nbootstraps           = 0,
                          Ntrials_per_bootstrap = NULL,
                          fit_algorithm         = "nlminb",
                          fit_control           = list(),
                          focal_param_values    = NULL,
                          verbose               = FALSE,
                          diagnostics           = FALSE,
                          verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_model_parametric_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated reconstructed phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_param_values">param_values</code></td>
<td>

<p>Numeric vector, specifying fixed values for a some or all model parameters. For fitted (i.e., non-fixed) parameters, use <code>NaN</code> or <code>NA</code>. For example, the vector <code>c(1.5,NA,40)</code> specifies that the 1st and 3rd model parameters are fixed at the values 1.5 and 40, respectively, while the 2nd parameter is to be fitted. The length of this vector defines the total number of model parameters. If entries in this vector are named, the names are taken as parameter names. Names should be included if you'd like returned parameter vectors to have named entries, or if the functions <code>lambda</code>, <code>mu</code> or <code>rho</code> query parameter values by name (as opposed to numeric index).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_param_guess">param_guess</code></td>
<td>

<p>Numeric vector of size NP, specifying a first guess for the value of each model parameter. For fixed parameters, guess values are ignored. Can be <code>NULL</code> only if all model parameters are fixed.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_param_min">param_min</code></td>
<td>

<p>Optional numeric vector of size NP, specifying lower bounds for model parameters. If of size 1, the same lower bound is applied to all parameters. Use <code>-Inf</code> to omit a lower bound for a parameter. If <code>NULL</code>, no lower bounds are applied. For fixed parameters, lower bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_param_max">param_max</code></td>
<td>

<p>Optional numeric vector of size NP, specifying upper bounds for model parameters. If of size 1, the same upper bound is applied to all parameters. Use <code>+Inf</code> to omit an upper bound for a parameter. If <code>NULL</code>, no upper bounds are applied. For fixed parameters, upper bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_param_scale">param_scale</code></td>
<td>

<p>Optional numeric vector of size NP, specifying typical scales for model parameters. If of size 1, the same scale is assumed for all parameters. If <code>NULL</code>, scales are determined automatically. For fixed parameters, scales are ignored. It is strongly advised to provide reasonable scales, as this facilitates the numeric optimization algorithm.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>rho</code> is defined. If <code>age0&gt;0</code>, then <code>rho0</code> refers to the sampling fraction at age <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are included in the tree. See below for more details.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_lambda">lambda</code></td>
<td>

<p>Function specifying the speciation rate at any given age (time before present) and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with strictly positive entries. Can also be a single number (i.e., lambda is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_mu">mu</code></td>
<td>

<p>Function specifying the extinction rate at any given age and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with non-negative entries. Can also be a single number (i.e., mu is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_rho0">rho0</code></td>
<td>

<p>Function specifying the sampling fraction (fraction of extant species sampled at <code>age0</code>) for any given parameter values. This function must take exactly one argument, a numeric vector of size NP (parameter values), and return a numeric between 0 (exclusive) and 1 (inclusive). Can also be a single number (i.e., rho0 is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, specifying ages at which the <code>lambda</code> and <code>mu</code> functionals should be evaluated. This age grid must be fine enough to capture the possible variation in <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> over time, within the permissible parameter range. If of size 1, then lambda &amp; mu are assumed to be time-independent.
Listed ages must be strictly increasing, and must cover at least the full considered age interval (from 0 to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the speciation rate and extinction rate is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier. &quot;none&quot; is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly choosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated model parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_fit_algorithm">fit_algorithm</code></td>
<td>

<p>Character, specifying which optimization algorithm to use. Either &quot;nlminb&quot; or &quot;subplex&quot; are allowed.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> or <code>subplex</code> optimization routine, depending on the choice of <code>fit_algorithm</code>. For example, for &quot;nlminb&quot; commonly modified options are <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package or of <code>nloptr</code> in the <code>nloptr</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_focal_param_values">focal_param_values</code></td>
<td>

<p>Optional numeric matrix having NP columns and an arbitrary number of rows, listing combinations of parameter values of particular interest and for which the log-likelihoods should be returned. This may be used for diagnostic purposes, e.g., to examine the shape of the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_hbd_model_parametric_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate a finite set of scalar parameters (<code class="reqn">p_1,..,p_n\in\R</code>) that determine the speciation rate <code class="reqn">\lambda</code>, the extinction rate <code class="reqn">\mu</code> and the sampling fraction <code class="reqn">\rho</code>, by maximizing the likelihood of observing a given timetree under the HBD model. For example, the investigator may assume that both <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> vary exponentially over time, i.e. they can be described by <code class="reqn">\lambda(t)=\lambda_o\cdot e^{-\alpha t}</code> and <code class="reqn">\mu(t)=\mu_o\cdot e^{-\beta t}</code> (where <code class="reqn">\lambda_o</code>, <code class="reqn">\mu_o</code> are unknown present-day rates and <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> are unknown factors, and <code class="reqn">t</code> is time before present), and that the sampling fraction <code class="reqn">\rho</code> is known. In this case the model has 4 free parameters, <code class="reqn">p_1=\lambda_o</code>, <code class="reqn">p_2=\mu_o</code>, <code class="reqn">p_3=\alpha</code> and <code class="reqn">p_4=\beta</code>, each of which may be fitted to the tree.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbd_model_parametric</code> as possible, including reasonable lower and upper bounds (<code>param_min</code> and <code>param_max</code>), a reasonable parameter guess (<code>param_guess</code>) and reasonable parameter scales <code>param_scale</code>. If some model parameters can vary over multiple orders of magnitude, it is advised to transform them so that they vary across fewer orders of magnitude (e.g., via log-transformation). It is also important that the <code>age_grid</code> is sufficiently fine to capture the variation of <code>lambda</code> and <code>mu</code> over time, since the likelihood is calculated under the assumption that both vary linearly between grid points.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Numeric vector of size NP (number of model parameters), listing all fitted or fixed model parameters in their standard order (see details above). If <code>param_names</code> was provided, elements in <code>fitted_params</code> will be named.
</p>
</td></tr>
<tr><td><code>param_guess</code></td>
<td>

<p>Numeric vector of size NP, listing guessed or fixed values for all model parameters in their standard order. If <code>param_names</code> was provided, elements in <code>param_guess</code> will be named.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>

<p>Character, specifying what conditioning was root for the likelihood (e.g. &quot;crown&quot; or &quot;stem&quot;).
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size NP, estimated standard error of the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>Numeric vector of size NP, median the estimated parameters across parametric bootstraps. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 50% confidence interval (25-75% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 50% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 95% confidence interval (2.5-97.5% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 95% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model (Lindholm et al. 2019). See the documentation of <code><a href="#topic+fit_hbds_model_on_grid">fit_hbds_model_on_grid</a></code> for an explanation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>A. Lindholm, D. Zachariah, P. Stoica, T. B. Schoen (2019). Data consistency approach to model validation. IEEE Access. 7:59788-59796.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
tree      = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Define a parametric HBD model, with exponentially varying lambda &amp; mu
# Assume that the sampling fraction is known
# The model thus has 4 parameters: lambda0, mu0, alpha, beta
lambda_function = function(ages,params){
	return(params['lambda0']*exp(-params['alpha']*ages));
}
mu_function = function(ages,params){
	return(params['mu0']*exp(-params['beta']*ages));
}
rho_function = function(params){
	return(rho) # rho does not depend on any of the parameters
}

# Define an age grid on which lambda_function &amp; mu_function shall be evaluated
# Should be sufficiently fine to capture the variation in lambda &amp; mu
age_grid = seq(from=0,to=100,by=0.01)

# Perform fitting
# Lets suppose extinction rates are already known
cat(sprintf("Fitting model to tree..\n"))
fit = fit_hbd_model_parametric(	tree, 
                      param_values  = c(lambda0=NA, mu0=3, alpha=NA, beta=-0.09),
                      param_guess   = c(1,1,0,0),
                      param_min     = c(0,0,-1,-1),
                      param_max     = c(10,10,1,1),
                      param_scale   = 1, # all params are in the order of 1
                      lambda        = lambda_function,
                      mu            = mu_function,
                      rho0          = rho_function,
                      age_grid      = age_grid,
                      Ntrials       = 10,    # perform 10 fitting trials
                      Nthreads      = 2,     # use 2 CPUs
                      max_model_runtime = 1, # limit model evaluation to 1 second
                      fit_control       = list(rel.tol=1e-6))
if(!fit$success){
	cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
	cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
	print(fit)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_pdr_on_best_grid_size'>
Fit pulled diversification rates of birth-death models on a time grid with optimal size.
</h2><span id='topic+fit_hbd_pdr_on_best_grid_size'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled diversification rate of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood, automatically determining the optimal time-grid size based on the data. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that predict the same deterministic lineages-through-time curve and yield the same likelihood for any given reconstructed timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on the tree. 
</p>
<p>Each congruence class is uniquely described by the &ldquo;pulled diversification rate&rdquo; (PDR; Louca et al 2018), defined as <code class="reqn">PDR=\lambda-\mu+\lambda^{-1}d\lambda/d\tau</code> (where <code class="reqn">\tau</code> is time before present) as well as the product <code class="reqn">\rho\lambda_o</code> (where <code class="reqn">\lambda_o</code> is the present-day speciation rate). That is, two HBD models are congruent if and only if they have the same PDR and the same product <code class="reqn">\rho\lambda_o</code>. This function is designed to estimate the generating congruence class for the tree, by fitting the PDR on a grid of discrete times as well as the product <code class="reqn">\rho\lambda_o</code>. Internally, the function uses <code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code> to perform the fitting. The &quot;best&quot; grid size is determined based on some optimality criterion, such as AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_pdr_on_best_grid_size(tree,
                              oldest_age            = NULL,
                              age0                  = 0,
                              grid_sizes            = c(1,10),
                              uniform_grid          = FALSE,
                              criterion             = "AIC",
                              exhaustive            = TRUE,
                              min_PDR               = -Inf,
                              max_PDR               = +Inf,
                              min_rholambda0        = 1e-10,
                              max_rholambda0        = +Inf,
                              guess_PDR             = NULL,
                              guess_rholambda0      = NULL,
                              fixed_PDR             = NULL,
                              fixed_rholambda0      = NULL,
                              splines_degree        = 1,
                              condition             = "auto",
                              relative_dt           = 1e-3,
                              Ntrials               = 1,
                              Nbootstraps           = 0,
                              Ntrials_per_bootstrap = NULL,
                              Nthreads              = 1,
                              max_model_runtime	    = NULL,
                              fit_control           = list(),
                              verbose               = FALSE,
                              verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting. If <code>age0&gt;0</code>, the tree essentially is trimmed at <code>age0</code>, omitting anything younger than <code>age0</code>, and the PDR and <code class="reqn">\rho\lambda_o</code> are fitted to the trimmed tree while shifting time appropriately.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_grid_sizes">grid_sizes</code></td>
<td>

<p>Numeric vector, listing alternative grid sizes to consider.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_uniform_grid">uniform_grid</code></td>
<td>

<p>Logical, specifying whether to use uniform time grids (equal time intervals) or non-uniform time grids (more grid points towards the present, where more data are available).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_criterion">criterion</code></td>
<td>

<p>Character, specifying which criterion to use for selecting the best grid. Options are &quot;AIC&quot; and &quot;BIC&quot;.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_exhaustive">exhaustive</code></td>
<td>

<p>Logical, whether to try all grid sizes before choosing the best one. If <code>FALSE</code>, the grid size is gradually increased until the selection criterio (e.g., AIC) starts becoming worse, at which point the search is halted. This avoids fitting models with excessive grid sizes when an optimum already seems to have been found at a smaller grid size.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_min_pdr">min_PDR</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted PDR at each point in the age grid. If a single numeric, the same lower bound applies at all ages. Note that in general the PDR may be negative as well as positive.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_max_pdr">max_PDR</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted PDR at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_min_rholambda0">min_rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the lower bound for the fitted <code class="reqn">\rho\lambda_o</code> (sampling fraction times present-day extinction rate).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_max_rholambda0">max_rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the upper bound for the fitted <code class="reqn">\rho\lambda_o</code>. Set to <code>+Inf</code> to omit this upper bound.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_guess_pdr">guess_PDR</code></td>
<td>

<p>Initial guess for the PDR at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing a constant PDR at all ages), or a function handle (for generating guesses at each grid point; this function may also return <code>NA</code> at some time points for which a guess shall be computed automatically).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_guess_rholambda0">guess_rholambda0</code></td>
<td>

<p>Numeric, specifying an initial guess for the product <code class="reqn">\rho\lambda_o</code>. If <code>NULL</code>, a guess will be computed automatically.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_fixed_pdr">fixed_PDR</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) PDR values. Either <code>NULL</code> (none of the PDR values are fixed) or a function handle specifying the PDR for any arbitrary age (PDR will be fixed at any age for which this function returns a finite number). The function <code>fixed_PDR()</code> need not return finite values for all times, in fact doing so would mean that the PDR is not fitted anywhere.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_fixed_rholambda0">fixed_rholambda0</code></td>
<td>

<p>Numeric, optionally specifying a fixed value for the product <code class="reqn">\rho\lambda_o</code>. If <code>NULL</code> or <code>NA</code>, the product <code class="reqn">\rho\lambda_o</code> is estimated.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of the PDR between age-grid points. If 0, then the PDR is considered to be piecewise constant, if 1 then the PDR is considered piecewise linear, if 2 or 3 then the PDR is considered to be a spline of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying an optional number of bootstrap samplings to perform, for estimating standard errors and confidence intervals of maximum-likelihood fitted parameters. If 0, no bootstrapping is performed. Typical values are 10-100. At each bootstrap sampling, a random timetree is generated under the birth-death model according to the fitted PDR and  <code class="reqn">\rho\lambda_o</code>, the parameters are estimated anew based on the generated tree, and subsequently compared to the original fitted parameters. Each bootstrap sampling will use roughly the same information and similar computational resources as the original maximum-likelihood fit (e.g., same number of trials, same optimization parameters, same initial guess, etc). Bootstrapping is only performed for the best grid size.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_best_grid_size_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is generally advised to provide as much information to the function <code>fit_hbd_pdr_on_best_grid_size</code> as possible, including reasonable lower and upper bounds (<code>min_PDR</code>, <code>max_PDR</code>, <code>min_rholambda0</code> and <code>max_rholambda0</code>) and a reasonable parameter guess (<code>guess_PDR</code> and <code>guess_rholambda0</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the function executed successfully. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>best_fit</code></td>
<td>

<p>A named list containing the fitting results for the best grid size. This list has the same structure as the one returned by <code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>.
</p>
</td></tr>
<tr><td><code>grid_sizes</code></td>
<td>

<p>Numeric vector, listing the grid sizes as provided during the function call.
</p>
</td></tr>
<tr><td><code>AICs</code></td>
<td>

<p>Numeric vector of the same length as <code>grid_sizes</code>, listing the AIC for each considered grid size. Note that some entries may be <code>NA</code>, if the corresponding grid sizes were not considered (if <code>exhaustive=FALSE</code>).
</p>
</td></tr>
<tr><td><code>BICs</code></td>
<td>

<p>Numeric vector of the same length as <code>grid_sizes</code>, listing the BIC for each considered grid size. Note that some entries may be <code>NA</code>, if the corresponding grid sizes were not considered (if <code>exhaustive=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_on_best_grid_size">fit_hbd_psr_on_best_grid_size</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>
<p><code><a href="#topic+evaluate_spline">evaluate_spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
sim       = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)
tree = sim$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Fit PDR on grid, with the grid size chosen automatically between 1 and 5
fit = fit_hbd_pdr_on_best_grid_size(tree, 
                                    max_PDR           = 100,
                                    grid_sizes        = c(1:5),
                                    exhaustive        = FALSE,
                                    uniform_grid      = FALSE,
                                    Ntrials           = 10,
                                    Nthreads          = 4,
                                    verbose           = TRUE,
                                    max_model_runtime = 1)
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
  best_fit = fit$best_fit
  cat(sprintf("Fitting succeeded:\nBest grid size=%d\n",length(best_fit$age_grid)))
  # plot fitted PDR
  plot( x     = best_fit$age_grid,
        y     = best_fit$fitted_PDR,
        main  = 'Fitted PDR',
        xlab  = 'age',
        ylab  = 'PDR',
        type  = 'b',
        xlim  = c(root_age,0))         
  # get fitted PDR as a function of age
  PDR_fun = approxfun(x=best_fit$age_grid, y=best_fit$fitted_PDR)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_pdr_on_grid'>
Fit pulled diversification rates of birth-death models on a time grid.
</h2><span id='topic+fit_hbd_pdr_on_grid'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled diversification rate of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that predict the same deterministic lineages-through-time curve and yield the same likelihood for any given reconstructed timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on the tree. 
</p>
<p>Each congruence class is uniquely described by the &ldquo;pulled diversification rate&rdquo; (PDR; Louca et al 2018), defined as <code class="reqn">PDR=\lambda-\mu+\lambda^{-1}d\lambda/d\tau</code> (where <code class="reqn">\tau</code> is time before present) as well as the product <code class="reqn">\rho\lambda_o</code> (where <code class="reqn">\lambda_o</code> is the present-day speciation rate). That is, two HBD models are congruent if and only if they have the same PDR and the same product <code class="reqn">\rho\lambda_o</code>. This function is designed to estimate the generating congruence class for the tree, by fitting the PDR on a grid of discrete times as well as the product <code class="reqn">\rho\lambda_o</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_pdr_on_grid(  tree, 
                      oldest_age            = NULL,
                      age0                  = 0,
                      age_grid              = NULL,
                      min_PDR               = -Inf,
                      max_PDR               = +Inf,
                      min_rholambda0        = 1e-10,
                      max_rholambda0        = +Inf,
                      guess_PDR             = NULL,
                      guess_rholambda0      = NULL,
                      fixed_PDR             = NULL,
                      fixed_rholambda0      = NULL,
                      splines_degree        = 1,
                      condition             = "auto",
                      relative_dt           = 1e-3,
                      Ntrials               = 1,
                      Nbootstraps           = 0,
                      Ntrials_per_bootstrap = NULL,
                      Nthreads              = 1,
                      max_model_runtime     = NULL,
                      fit_control           = list(),
                      verbose               = FALSE,
                      verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>rholambda0</code> is defined. If <code>age0&gt;0</code>, then <code>rholambda0</code> refers to the product of the sampling fraction at age <code>age0</code> and the speciation rate at age <code>age0</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing ages in ascending order at which the PDR is allowed to vary independently. This grid must cover at least the age range from <code>age0</code> to <code>oldest_age</code>. If <code>NULL</code> or of length &lt;=1 (regardless of value), then the PDR is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_min_pdr">min_PDR</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted PDR at each point in the age grid. If a single numeric, the same lower bound applies at all ages. Use <code>-Inf</code> to omit lower bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_max_pdr">max_PDR</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted PDR at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_min_rholambda0">min_rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the lower bound for the fitted <code class="reqn">\rho\lambda_o</code> (sampling fraction times present-day extinction rate).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_max_rholambda0">max_rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the upper bound for the fitted <code class="reqn">\rho\lambda_o</code>. Set to <code>+Inf</code> to omit this upper bound.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_guess_pdr">guess_PDR</code></td>
<td>

<p>Initial guess for the PDR at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same PDR at all ages) or a numeric vector of size Ngrid specifying a separate guess at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_guess_rholambda0">guess_rholambda0</code></td>
<td>

<p>Numeric, specifying an initial guess for the product <code class="reqn">\rho\lambda_o</code>. If <code>NULL</code>, a guess will be computed automatically.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_fixed_pdr">fixed_PDR</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) PDR values on one or more age-grid points. Either <code>NULL</code> (PDR is not fixed anywhere), or a single numeric (PDR fixed to the same value at all grid points) or a numeric vector of size Ngrid (PDR fixed at one or more age-grid points, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_fixed_rholambda0">fixed_rholambda0</code></td>
<td>

<p>Numeric, optionally specifying a fixed value for the product <code class="reqn">\rho\lambda_o</code>. If <code>NULL</code> or <code>NA</code>, the product <code class="reqn">\rho\lambda_o</code> is estimated.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of the PDR between age-grid points. If 0, then the PDR is considered piecewise constant, if 1 then the PDR is considered piecewise linear, if 2 or 3 then the PDR is considered to be a spline of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying an optional number of bootstrap samplings to perform, for estimating standard errors and confidence intervals of maximum-likelihood fitted parameters. If 0, no bootstrapping is performed. Typical values are 10-100. At each bootstrap sampling, a random timetree is generated under the birth-death model according to the fitted PDR and <code class="reqn">\rho\lambda_o</code>, the parameters are estimated anew based on the generated tree, and subsequently compared to the original fitted parameters. Each bootstrap sampling will use roughly the same information and similar computational resources as the original maximum-likelihood fit (e.g., same number of trials, same optimization parameters, same initial guess, etc).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_on_grid_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>age0&gt;0</code>, the input tree is essentially trimmed at <code>age0</code> (omitting anything younger than <code>age0</code>), and the PDR and <code>rholambda0</code> are fitted to this new (shorter) tree, with time shifted appropriately. The fitted <code>rholambda0</code> is thus the product of the sampling fraction at <code>age0</code> and the speciation rate at <code>age0</code>. Note that the sampling fraction at <code>age0</code> is simply the fraction of lineages extant at <code>age0</code> that are represented in the timetree.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbd_pdr_on_grid</code> as possible, including reasonable lower and upper bounds (<code>min_PDR</code>, <code>max_PDR</code>, <code>min_rholambda0</code> and <code>max_rholambda0</code>) and a reasonable parameter guess (<code>guess_PDR</code> and <code>guess_rholambda0</code>). It is also important that the <code>age_grid</code> is sufficiently fine to capture the expected major variations of the PDR over time, but keep in mind the serious risk of overfitting when <code>age_grid</code> is too fine and/or the tree is too small.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>fitted_PDR</code></td>
<td>

<p>Numeric vector of size Ngrid, listing fitted or fixed pulled diversification rates (PDR) at each age-grid point. Between grid points the fitted PDR should be interpreted as a piecewise polynomial function (natural spline) of degree <code>splines_degree</code>; to evaluate this function at arbitrary ages use the <code>castor</code> routine <code><a href="#topic+evaluate_spline">evaluate_spline</a></code>.
</p>
</td></tr>
<tr><td><code>fitted_rholambda0</code></td>
<td>

<p>Numeric, specifying the fitted or fixed product <code class="reqn">\rho\lambda(0)</code>.
</p>
</td></tr>
<tr><td><code>guess_PDR</code></td>
<td>

<p>Numeric vector of size Ngrid, specifying the initial guess for the PDR at each age-grid point.
</p>
</td></tr>
<tr><td><code>guess_rholambda0</code></td>
<td>

<p>Numeric, specifying the initial guess for <code class="reqn">\rho\lambda(0)</code>.
</p>
</td></tr>
<tr><td><code>age_grid</code></td>
<td>

<p>The age-grid on which the PDR is defined. This will be the same as the provided <code>age_grid</code>, unless the latter was <code>NULL</code> or of length &lt;=1.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) parameters. If none of the PDRs or <code class="reqn">\rho\lambda0</code> were fixed, this will be equal to Ngrid+1.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>bootstrap_estimates</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a named list containing the elements <code>PDR</code> (numeric matrix of size <code>Nbootstraps</code> x Ngrid, listing the fitted PDR at each grid point and for each bootstrap) and <code>rholambda0</code> (a numeric vector of size <code>Nbootstraps</code>, listing the fitted <code class="reqn">\rho\lambda_o</code> for each bootstrap).
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a named list containing the elements <code>PDR</code> (numeric vector of size Ngrid, listing bootstrap-estimated standard errors for the fitted PDRs) and <code>rholambda0</code> (a single numeric, bootstrap-estimated standard error for the fitted <code class="reqn">\rho\lambda_o</code>).
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a named list containing the elements <code>PDR</code> (numeric vector of size Ngrid, listing median fitted PDRs across bootstraps) and <code>rholambda0</code> (a single numeric, median fitted <code class="reqn">\rho\lambda_o</code> across bootstraps).
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a named list containing the elements <code>PDR</code> (numeric vector of size Ngrid, listing bootstrap-estimated lower bounds of the 50-percent confidence intervals for the fitted PDRs) and <code>rholambda0</code> (a single numeric, bootstrap-estimated lower bound of the 50-percent confidence intervals for the fitted <code class="reqn">\rho\lambda_o</code>).
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Similar to <code>CI50lower</code>, listing upper bounds of 50-percentile confidence intervals.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Similar to <code>CI50lower</code>, listing lower bounds of 95-percentile confidence intervals.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Similar to <code>CI95lower</code>, listing upper bounds of 95-percentile confidence intervals.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>
<p><code><a href="#topic+evaluate_spline">evaluate_spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
sim       = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)
tree = sim$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# calculate true PDR
lambda_slopes = diff(lambdas)/diff(time_grid);
lambda_slopes = c(lambda_slopes[1],lambda_slopes)
PDRs = lambdas - mus - (lambda_slopes/lambdas)


# Fit PDR on grid
Ngrid     = 10
age_grid  = seq(from=0,to=root_age,length.out=Ngrid)
fit = fit_hbd_pdr_on_grid(tree, 
          age_grid    = age_grid,
          min_PDR     = -100,
          max_PDR     = +100,
          condition   = "crown",
          Ntrials     = 10,	# perform 10 fitting trials
          Nthreads    = 2,	# use two CPUs
          max_model_runtime = 1) 	# limit model evaluation to 1 second
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
  cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
  
  # plot fitted &amp; true PDR
  plot( x     = fit$age_grid,
        y     = fit$fitted_PDR,
        main  = 'Fitted &amp; true PDR',
        xlab  = 'age',
        ylab  = 'PDR',
        type  = 'b',
        col   = 'red',
        xlim  = c(root_age,0)) 
  lines(x     = sim$final_time-time_grid,
        y     = PDRs,
        type  = 'l',
        col   = 'blue');
        
  # get fitted PDR as a function of age
  PDR_fun = approxfun(x=fit$age_grid, y=fit$fitted_PDR)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_pdr_parametric'>
Fit parameterized pulled diversification rates of birth-death models.
</h2><span id='topic+fit_hbd_pdr_parametric'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled diversification rate (PDR) of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood, assuming that the PDR is given as a parameterized function of time before present. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that generate extant trees with the same probability distributions and yield the same likelihood for any given extant timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on an extant timetree. 
</p>
<p>Each congruence class is uniquely described by its PDR, defined as <code class="reqn">PDR=\lambda-\mu+\lambda^{-1}d\lambda/d\tau</code> (where <code class="reqn">\tau</code> is time before present) as well as the product <code class="reqn">\rho\lambda_o</code> (where <code class="reqn">\lambda_o</code> is the present-day speciation rate). That is, two HBD models are congruent if and only if they have the same PDR and the same product <code class="reqn">\rho\lambda_o</code>. This function is designed to estimate the generating congruence class for the tree, by fitting a finite number of parameters defining the PDR and <code class="reqn">\rho\lambda_o</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_pdr_parametric( tree, 
                        param_values,
                        param_guess        = NULL,
                        param_min          = -Inf,
                        param_max          = +Inf,
                        param_scale        = NULL,
                        oldest_age         = NULL,
                        age0               = 0,
                        PDR,
                        rholambda0,
                        age_grid           = NULL,
                        condition          = "auto",
                        relative_dt        = 1e-3,
                        Ntrials            = 1,
                        max_start_attempts = 1,
                        Nthreads           = 1,
                        max_model_runtime  = NULL,
                        fit_control        = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_param_values">param_values</code></td>
<td>

<p>Numeric vector, specifying fixed values for a some or all model parameters. For fitted (i.e., non-fixed) parameters, use <code>NaN</code> or <code>NA</code>. For example, the vector <code>c(1.5,NA,40)</code> specifies that the 1st and 3rd model parameters are fixed at the values 1.5 and 40, respectively, while the 2nd parameter is to be fitted. The length of this vector defines the total number of model parameters. If entries in this vector are named, the names are taken as parameter names. Names should be included if you'd like returned parameter vectors to have named entries, or if the functions <code>PDR</code> or <code>rho</code> query parameter values by name (as opposed to numeric index).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_param_guess">param_guess</code></td>
<td>

<p>Numeric vector of size NP, specifying a first guess for the value of each model parameter. For fixed parameters, guess values are ignored. Can be <code>NULL</code> only if all model parameters are fixed.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_param_min">param_min</code></td>
<td>

<p>Optional numeric vector of size NP, specifying lower bounds for model parameters. If of size 1, the same lower bound is applied to all parameters. Use <code>-Inf</code> to omit a lower bound for a parameter. If <code>NULL</code>, no lower bounds are applied. For fixed parameters, lower bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_param_max">param_max</code></td>
<td>

<p>Optional numeric vector of size NP, specifying upper bounds for model parameters. If of size 1, the same upper bound is applied to all parameters. Use <code>+Inf</code> to omit an upper bound for a parameter. If <code>NULL</code>, no upper bounds are applied. For fixed parameters, upper bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_param_scale">param_scale</code></td>
<td>

<p>Optional numeric vector of size NP, specifying typical scales for model parameters. If of size 1, the same scale is assumed for all parameters. If <code>NULL</code>, scales are determined automatically. For fixed parameters, scales are ignored. It is strongly advised to provide reasonable scales, as this facilitates the numeric optimization algorithm.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>rholambda0</code> is defined. If <code>age0&gt;0</code>, then <code>rholambda0</code> refers to the product of the sampling fraction at age <code>age0</code> and the speciation rate at age <code>age0</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_pdr">PDR</code></td>
<td>

<p>Function specifying the pulled diversification rate at any given age (time before present) and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument. Can also be a single number (i.e., PDR is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_rholambda0">rholambda0</code></td>
<td>

<p>Function specifying the product <code class="reqn">\rho\lambda_o</code> (sampling fraction times speciation rate at <code>age0</code>) for any given parameter values. This function must take exactly one argument, a numeric vector of size NP (parameter values), and return a strictly positive numeric. Can also be a single number (i.e., rholambda0 is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, specifying ages at which the <code>PDR</code> function should be evaluated. This age grid must be fine enough to capture the possible variation in the PDR over time, within the permissible parameter range. If of size 1, then the PDR is assumed to be time-independent.
Listed ages must be strictly increasing, and must cover at least the full considered age interval (from <code>age0</code> to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the PDR is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly choosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_pdr_parametric_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate a finite set of scalar parameters (<code class="reqn">p_1,..,p_n\in\R</code>) that determine the PDR and the product <code class="reqn">\rho\lambda_o</code> (sampling fraction times present-dat extinction rate), by maximizing the likelihood of observing a given timetree under the HBD model. For example, the investigator may assume that the PDR varies exponentially over time, i.e. can be described by <code class="reqn">PDR(t)=A\cdot e^{-B t}</code> (where <code class="reqn">A</code> and <code class="reqn">B</code> are unknown coefficients and <code class="reqn">t</code> is time before present), and that the product <code class="reqn">\rho\lambda_o</code> is unknown. In this case the model has 3 free parameters, <code class="reqn">p_1=A</code>, <code class="reqn">p_2=B</code> and <code class="reqn">p_3=\rho\lambda_o</code>, each of which may be fitted to the tree.
</p>
<p>If <code>age0&gt;0</code>, the input tree is essentially trimmed at <code>age0</code> (omitting anything younger than <code>age0</code>), and the PDR and <code>rholambda0</code> are fitted to this new (shorter) tree, with time shifted appropriately. The fitted <code>rholambda0</code> is thus the product of the sampling fraction at <code>age0</code> and the speciation rate at <code>age0</code>. Note that the sampling fraction at <code>age0</code> is simply the fraction of lineages extant at <code>age0</code> that are represented in the timetree. Most users will typically want to leave <code>age0=0</code>.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbd_pdr_parametric</code> as possible, including reasonable lower and upper bounds (<code>param_min</code> and <code>param_max</code>), a reasonable parameter guess (<code>param_guess</code>) and reasonable parameter scales <code>param_scale</code>. If some model parameters can vary over multiple orders of magnitude, it is advised to transform them so that they vary across fewer orders of magnitude (e.g., via log-transformation). It is also important that the <code>age_grid</code> is sufficiently fine to capture the variation of the PDR over time, since the likelihood is calculated under the assumption that both vary linearly between grid points.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Numeric vector of size NP (number of model parameters), listing all fitted or fixed model parameters in their standard order (see details above). If <code>param_names</code> was provided, elements in <code>fitted_params</code> will be named.
</p>
</td></tr>
<tr><td><code>param_guess</code></td>
<td>

<p>Numeric vector of size NP, listing guessed or fixed values for all model parameters in their standard order.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_parametric">fit_hbd_psr_parametric</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
tree      = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Define a parametric HBD congruence class, with exponentially varying PDR
# The model thus has 3 parameters
PDR_function = function(ages,params){
	return(params['A']*exp(-params['B']*ages));
}
rholambda0_function = function(params){
	return(params['rholambda0'])
}

# Define an age grid on which PDR_function shall be evaluated
# Should be sufficiently fine to capture the variation in the PDR
age_grid = seq(from=0,to=100,by=0.01)

# Perform fitting
cat(sprintf("Fitting class to tree..\n"))
fit = fit_hbd_pdr_parametric(	tree, 
                      param_values  = c(A=NA, B=NA, rholambda0=NA),
                      param_guess   = c(1,0,1),
                      param_min     = c(-10,-10,0),
                      param_max     = c(10,10,10),
                      param_scale   = 1, # all params are in the order of 1
                      PDR           = PDR_function,
                      rholambda0    = rholambda0_function,
                      age_grid      = age_grid,
                      Ntrials       = 10,    # perform 10 fitting trials
                      Nthreads      = 2,     # use 2 CPUs
                      max_model_runtime = 1, # limit model evaluation to 1 second
                      fit_control       = list(rel.tol=1e-6))
if(!fit$success){
	cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
	cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
	print(fit)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_psr_on_best_grid_size'>
Fit pulled speciation rates of birth-death models on a time grid with optimal size.
</h2><span id='topic+fit_hbd_psr_on_best_grid_size'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled speciation rate of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood, automatically determining the optimal time-grid size based on the data. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that predict the same deterministic lineages-through-time curve and yield the same likelihood for any given reconstructed timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on the tree. 
</p>
<p>Each congruence class is uniquely described by the &ldquo;pulled speciation rate&rdquo; (PSR), defined as the relative slope of the deterministic LTT over time, <code class="reqn">PSR=-M^{-1}dM/d\tau</code> (where <code class="reqn">\tau</code> is time before present). In other words, two HBD models are congruent if and only if they have the same PSR. This function is designed to estimate the generating congruence class for the tree, by fitting the PSR on a discrete time grid. Internally, the function uses <code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code> to perform the fitting. The &quot;best&quot; grid size is determined based on some optimality criterion, such as AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_psr_on_best_grid_size(tree,
                              oldest_age            = NULL,
                              age0                  = 0,
                              grid_sizes            = c(1,10),
                              uniform_grid          = FALSE,
                              criterion             = "AIC",
                              exhaustive            = TRUE,
                              min_PSR               = 0,
                              max_PSR               = +Inf,
                              guess_PSR             = NULL,
                              fixed_PSR             = NULL,
                              splines_degree        = 1,
                              condition             = "auto",
                              relative_dt           = 1e-3,
                              Ntrials               = 1,
                              Nbootstraps           = 0,
                              Ntrials_per_bootstrap = NULL,
                              Nthreads              = 1,
                              max_model_runtime	    = NULL,
                              fit_control           = list(),
                              verbose               = FALSE,
                              verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age. If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting. If <code>age0&gt;0</code>, the tree essentially is trimmed at <code>age0</code>, omitting anything younger than <code>age0</code>, and the PSR is fitted to the trimmed tree while shifting time appropriately.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_grid_sizes">grid_sizes</code></td>
<td>

<p>Numeric vector, listing alternative grid sizes to consider.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_uniform_grid">uniform_grid</code></td>
<td>

<p>Logical, specifying whether to use uniform time grids (equal time intervals) or non-uniform time grids (more grid points towards the present, where more data are available).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_criterion">criterion</code></td>
<td>

<p>Character, specifying which criterion to use for selecting the best grid. Options are &quot;AIC&quot; and &quot;BIC&quot;.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_exhaustive">exhaustive</code></td>
<td>

<p>Logical, whether to try all grid sizes before choosing the best one. If <code>FALSE</code>, the grid size is gradually increased until the selection criterio (e.g., AIC) starts becoming worse, at which point the search is halted. This avoids fitting models with excessive grid sizes when an optimum already seems to have been found at a smaller grid size.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_min_psr">min_PSR</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted PSR at each point in the age grid. If a single numeric, the same lower bound applies at all ages. Note that the PSR is never negative.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_max_psr">max_PSR</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted PSR at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_guess_psr">guess_PSR</code></td>
<td>

<p>Initial guess for the PSR at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing a constant PSR at all ages), or a function handle (for generating guesses at each grid point; this function may also return <code>NA</code> at some time points for which a guess shall be computed automatically).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_fixed_psr">fixed_PSR</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) PSR values. Either <code>NULL</code> (none of the PSR values are fixed) or a function handle specifying the PSR for any arbitrary age (PSR will be fixed at any age for which this function returns a finite number). The function <code>fixed_PSR()</code> need not return finite values for all times, in fact doing so would mean that the PSR is not fitted anywhere.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of the PSR between age-grid points. If 0, then the PSR is considered piecewise constant, if 1 then the PSR is considered piecewise linear, if 2 or 3 then the PSR is considered to be a spline of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying an optional number of bootstrap samplings to perform, for estimating standard errors and confidence intervals of maximum-likelihood fitted parameters. If 0, no bootstrapping is performed. Typical values are 10-100. At each bootstrap sampling, a random timetree is generated under the birth-death model according to the fitted PSR, the parameters are estimated anew based on the generated tree, and subsequently compared to the original fitted parameters. Each bootstrap sampling will use roughly the same information and similar computational resources as the original maximum-likelihood fit (e.g., same number of trials, same optimization parameters, same initial guess, etc). Bootstrapping is only performed for the best grid size.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_best_grid_size_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is generally advised to provide as much information to the function <code>fit_hbd_psr_on_best_grid_size</code> as possible, including reasonable lower and upper bounds (<code>min_PSR</code> and <code>max_PSR</code>) and a reasonable parameter guess (<code>guess_PSR</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the function executed successfully. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>best_fit</code></td>
<td>

<p>A named list containing the fitting results for the best grid size. This list has the same structure as the one returned by <code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code>.
</p>
</td></tr>
<tr><td><code>grid_sizes</code></td>
<td>

<p>Numeric vector, listing the grid sizes as provided during the function call.
</p>
</td></tr>
<tr><td><code>AICs</code></td>
<td>

<p>Numeric vector of the same length as <code>grid_sizes</code>, listing the AIC for each considered grid size. Note that some entries may be <code>NA</code>, if the corresponding grid sizes were not considered (if <code>exhaustive=FALSE</code>).
</p>
</td></tr>
<tr><td><code>BICs</code></td>
<td>

<p>Numeric vector of the same length as <code>grid_sizes</code>, listing the BIC for each considered grid size. Note that some entries may be <code>NA</code>, if the corresponding grid sizes were not considered (if <code>exhaustive=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_best_grid_size">fit_hbd_pdr_on_best_grid_size</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
sim       = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)
tree = sim$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Fit PSR on grid, with the grid size chosen automatically between 1 and 5
fit = fit_hbd_psr_on_best_grid_size(tree, 
                                    max_PSR           = 100,
                                    grid_sizes        = c(1:5),
                                    exhaustive        = FALSE,
                                    uniform_grid      = FALSE,
                                    Ntrials           = 10,
                                    Nthreads          = 4,
                                    verbose           = TRUE,
                                    max_model_runtime = 1)
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
  best_fit = fit$best_fit
  cat(sprintf("Fitting succeeded:\nBest grid size=%d\n",length(best_fit$age_grid)))
  # plot fitted PSR
  plot( x     = best_fit$age_grid,
        y     = best_fit$fitted_PSR,
        main  = 'Fitted PSR',
        xlab  = 'age',
        ylab  = 'PSR',
        type  = 'b',
        xlim  = c(root_age,0))         
  # get fitted PSR as a function of age
  PSR_fun = approxfun(x=best_fit$age_grid, y=best_fit$fitted_PSR)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_psr_on_grid'>
Fit pulled speciation rates of birth-death models on a time grid.
</h2><span id='topic+fit_hbd_psr_on_grid'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled speciation rate of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that predict the same deterministic lineages-through-time curve and yield the same likelihood for any given reconstructed timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on the tree. 
</p>
<p>Each congruence class is uniquely described by the &ldquo;pulled speciation rate&rdquo; (PSR), defined as the relative slope of the deterministic LTT over time, <code class="reqn">PSR=-M^{-1}dM/d\tau</code> (where <code class="reqn">\tau</code> is time before present). In other words, two HBD models are congruent if and only if they have the same PSR. This function is designed to estimate the generating congruence class for the tree, by fitting the PSR on a discrete time grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_psr_on_grid(  tree, 
                      oldest_age            = NULL,
                      age0                  = 0,
                      age_grid              = NULL,
                      min_PSR               = 0,
                      max_PSR               = +Inf,
                      guess_PSR             = NULL,
                      fixed_PSR             = NULL,
                      splines_degree        = 1,
                      condition             = "auto",
                      relative_dt           = 1e-3,
                      Ntrials               = 1,
                      Nbootstraps           = 0,
                      Ntrials_per_bootstrap = NULL,
                      Nthreads              = 1,
                      max_model_runtime     = NULL,
                      fit_control           = list(),
                      verbose               = FALSE,
                      diagnostics           = FALSE,
                      verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting. If <code>age0&gt;0</code>, the tree essentially is trimmed at <code>age0</code>, omitting anything younger than <code>age0</code>, and the PSR is fitted to the trimmed tree while shifting time appropriately.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing ages in ascending order at which the PSR is allowed to vary independently. This grid must cover at least the age range from <code>age0</code> to <code>oldest_age</code>. If <code>NULL</code> or of length &lt;=1 (regardless of value), then the PSR is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_min_psr">min_PSR</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted PSR at each point in the age grid. If a single numeric, the same lower bound applies at all ages. Note that the PSR is never negative.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_max_psr">max_PSR</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted PSR at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_guess_psr">guess_PSR</code></td>
<td>

<p>Initial guess for the PSR at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same PSR at all ages) or a numeric vector of size Ngrid specifying a separate guess at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_fixed_psr">fixed_PSR</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) PSR values on one or more age-grid points. Either <code>NULL</code> (PSR is not fixed anywhere), or a single numeric (PSR fixed to the same value at all grid points) or a numeric vector of size Ngrid (PSR fixed at one or more age-grid points, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of the PSR between age-grid points. If 0, then the PSR is considered piecewise constant, if 1 then the PSR is considered piecewise linear, if 2 or 3 then the PSR is considered to be a spline of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying an optional number of bootstrap samplings to perform, for estimating standard errors and confidence intervals of maximum-likelihood fitted parameters. If 0, no bootstrapping is performed. Typical values are 10-100. At each bootstrap sampling, a random timetree is generated under the birth-death model according to the fitted PSR, the parameters are estimated anew based on the generated tree, and subsequently compared to the original fitted parameters. Each bootstrap sampling will use roughly the same information and similar computational resources as the original maximum-likelihood fit (e.g., same number of trials, same optimization parameters, same initial guess, etc).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_on_grid_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is generally advised to provide as much information to the function <code>fit_hbd_psr_on_grid</code> as possible, including reasonable lower and upper bounds (<code>min_PSR</code> and <code>max_PSR</code>) and a reasonable parameter guess (<code>guess_PSR</code>). It is also important that the <code>age_grid</code> is sufficiently fine to capture the expected major variations of the PSR over time, but keep in mind the serious risk of overfitting when <code>age_grid</code> is too fine and/or the tree is too small.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>fitted_PSR</code></td>
<td>

<p>Numeric vector of size Ngrid, listing fitted or fixed pulled speciation rates (PSR) at each age-grid point. Between grid points the fitted PSR should be interpreted as a piecewise polynomial function (natural spline) of degree <code>splines_degree</code>; to evaluate this function at arbitrary ages use the <code>castor</code> routine <code><a href="#topic+evaluate_spline">evaluate_spline</a></code>.
</p>
</td></tr>
<tr><td><code>guess_PSR</code></td>
<td>

<p>Numeric vector of size Ngrid, specifying the initial guess for the PSR at each age-grid point.
</p>
</td></tr>
<tr><td><code>age_grid</code></td>
<td>

<p>The age-grid on which the PSR is defined. This will be the same as the provided <code>age_grid</code>, unless the latter was <code>NULL</code> or of length &lt;=1.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) parameters. If none of the PSRs were fixed, this will be equal to Ngrid.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>bootstrap_estimates</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a numeric matrix of size <code>Nbootstraps</code> x Ngrid, listing the fitted PSR at each grid point and for each bootstrap.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a numeric vector of size NGrid, listing bootstrap-estimated standard errors for the fitted PSR at each grid point.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>If <code>Nbootstraps&gt;0</code>, this will be a numeric vector of size Ngrid, listing bootstrap-estimated lower bounds of the 50-percent confidence intervals for the fitted PSR at each grid point.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Similar to <code>CI50lower</code>, listing upper bounds of 50-percentile confidence intervals.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Similar to <code>CI50lower</code>, listing lower bounds of 95-percentile confidence intervals.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Similar to <code>CI95lower</code>, listing upper bounds of 95-percentile confidence intervals.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_psr_on_best_grid_size">fit_hbd_psr_on_best_grid_size</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
sim       = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)
tree = sim$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Fit PSR on grid
oldest_age=root_age/2 # only consider recent times when fitting
Ngrid     = 10
age_grid  = seq(from=0,to=oldest_age,length.out=Ngrid)
fit = fit_hbd_psr_on_grid(tree, 
          oldest_age  = oldest_age,
          age_grid    = age_grid,
          min_PSR     = 0,
          max_PSR     = +100,
          condition   = "crown",
          Ntrials     = 10,
          Nthreads    = 4,
          max_model_runtime = 1) 	# limit model evaluation to 1 second
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
  cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
  # plot fitted PSR
  plot( x     = fit$age_grid,
        y     = fit$fitted_PSR,
        main  = 'Fitted PSR',
        xlab  = 'age',
        ylab  = 'PSR',
        type  = 'b',
        xlim  = c(root_age,0)) 
        
 # plot deterministic LTT of fitted model
  plot( x     = fit$age_grid,
        y     = fit$fitted_LTT,
        main  = 'Fitted dLTT',
        xlab  = 'age',
        ylab  = 'lineages',
        type  = 'b',
        log   = 'y',
        xlim  = c(root_age,0)) 

  # get fitted PSR as a function of age
  PSR_fun = approxfun(x=fit$age_grid, y=fit$fitted_PSR)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbd_psr_parametric'>
Fit parameterized pulled speciation rates of birth-death models.
</h2><span id='topic+fit_hbd_psr_parametric'></span>

<h3>Description</h3>

<p>Given an ultrametric timetree, estimate the pulled speciation rate (PSR) of homogenous birth-death (HBD) models that best explains the tree via maximum likelihood, assuming that the PSR is given as a parameterized function of time before present. Every HBD model is defined by some speciation and extinction rates (<code class="reqn">\lambda</code> and <code class="reqn">\mu</code>) over time, as well as the sampling fraction <code class="reqn">\rho</code> (fraction of extant species sampled). &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates. For any given HBD model there exists an infinite number of alternative HBD models that generate extant trees with the same probability distributions and yield the same likelihood for any given extant timetree; these &ldquo;congruent&rdquo; models cannot be distinguished from one another solely based on an extant timetree. 
</p>
<p>Each congruence class is uniquely described by its PSR, defined as <code class="reqn">PSR=\lambda\cdot(1-E)</code>, where <code class="reqn">\tau</code> is time before present and <code class="reqn">1-E(\tau)</code> is the probability that a lineage alive at age <code class="reqn">\tau</code> will survive to the present and be included in the extant tree. That is, two HBD models are congruent if and only if they have the same PSR profile. This function is designed to estimate the generating congruence class for the tree, by fitting a finite number of parameters defining the PSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbd_psr_parametric( tree, 
                        param_values,
                        param_guess        = NULL,
                        param_min          = -Inf,
                        param_max          = +Inf,
                        param_scale        = NULL,
                        oldest_age         = NULL,
                        age0               = 0,
                        PSR,
                        age_grid           = NULL,
                        condition          = "auto",
                        relative_dt        = 1e-3,
                        Ntrials            = 1,
                        max_start_attempts = 1,
                        Nthreads           = 1,
                        max_model_runtime  = NULL,
                        fit_control        = list(),
                        verbose            = FALSE,
                        diagnostics        = FALSE,
                        verbose_prefix     = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbd_psr_parametric_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;, representing the time-calibrated phylogeny of a set of extant sampled species.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_param_values">param_values</code></td>
<td>

<p>Numeric vector, specifying fixed values for a some or all model parameters. For fitted (i.e., non-fixed) parameters, use <code>NaN</code> or <code>NA</code>. For example, the vector <code>c(1.5,NA,40)</code> specifies that the 1st and 3rd model parameters are fixed at the values 1.5 and 40, respectively, while the 2nd parameter is to be fitted. The length of this vector defines the total number of model parameters. If entries in this vector are named, the names are taken as parameter names. Names should be included if you'd like returned parameter vectors to have named entries, or if the function <code>PSR</code> queries parameter values by name (as opposed to numeric index).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_param_guess">param_guess</code></td>
<td>

<p>Numeric vector of size NP, specifying a first guess for the value of each model parameter. For fixed parameters, guess values are ignored. Can be <code>NULL</code> only if all model parameters are fixed.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_param_min">param_min</code></td>
<td>

<p>Optional numeric vector of size NP, specifying lower bounds for model parameters. If of size 1, the same lower bound is applied to all parameters. Use <code>-Inf</code> to omit a lower bound for a parameter. If <code>NULL</code>, no lower bounds are applied. For fixed parameters, lower bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_param_max">param_max</code></td>
<td>

<p>Optional numeric vector of size NP, specifying upper bounds for model parameters. If of size 1, the same upper bound is applied to all parameters. Use <code>+Inf</code> to omit an upper bound for a parameter. If <code>NULL</code>, no upper bounds are applied. For fixed parameters, upper bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_param_scale">param_scale</code></td>
<td>

<p>Optional numeric vector of size NP, specifying typical scales for model parameters. If of size 1, the same scale is assumed for all parameters. If <code>NULL</code>, scales are determined automatically. For fixed parameters, scales are ignored. It is strongly advised to provide reasonable scales, as this facilitates the numeric optimization algorithm.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>PSR</code> is defined. See below for more details. Most users will typically keep <code>age0=0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_psr">PSR</code></td>
<td>

<p>Function specifying the pulled speciation rate at any given age (time before present) and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, specifying ages at which the <code>PSR</code> function should be evaluated. This age grid must be fine enough to capture the possible variation in the PSR over time, within the permissible parameter range. If of size 1, then the PSR is assumed to be time-independent.
Listed ages must be strictly increasing, and must cover at least the full considered age interval (from <code>age0</code> to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the PSR is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot;, &quot;stemN&quot; or &quot;crownN&quot; (where N is an integer &gt;=2), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root at that time. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage, with the process having started at <code>oldest_age</code>. Note that &quot;crown&quot; and &quot;crownN&quot;&quot; really only make sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. If &quot;stem2&quot;, the condition is that the process yielded at least two sampled tips, and similarly for &quot;stem3&quot; etc. If &quot;crown3&quot;, the condition is that a splitting occurred at the root age, both child clades survived, and in total yielded at least 3 sampled tips (and similarly for &quot;crown4&quot; etc). If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time, when calculating the likelihood. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly choosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_hbd_psr_parametric_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate a finite set of scalar parameters (<code class="reqn">p_1,..,p_n\in\R</code>) that determine the PSR and the product <code class="reqn">\rho\lambda_o</code> (sampling fraction times present-dat extinction rate), by maximizing the likelihood of observing a given timetree under the HBD model. For example, the investigator may assume that the PSR varies exponentially over time, i.e. can be described by <code class="reqn">PSR(t)=A\cdot e^{-B t}</code> (where <code class="reqn">A</code> and <code class="reqn">B</code> are unknown coefficients and <code class="reqn">t</code> is time before present); in this case the model has 2 free parameters, <code class="reqn">p_1=A</code> and <code class="reqn">p_2=B</code>, each of which may be fitted to the tree. It is also possible to include explicit dependencies on environmental parameters (e.g., temperature). For example, the investigator may assume that the PSR depends exponentially on global average temperature, i.e. can be described by <code class="reqn">PSR(t)=A\cdot e^{-B T(t)}</code> (where <code class="reqn">A</code> and <code class="reqn">B</code> are unknown fitted parameters and <code class="reqn">T(t)</code> is temperature at time <code class="reqn">t</code>). To incorporate such environmental dependencies, one can simply define the function <code>PSR</code> appropriately.
</p>
<p>If <code>age0&gt;0</code>, the input tree is essentially trimmed at <code>age0</code> (omitting anything younger than <code>age0</code>), and the PSR is fitted to this new (shorter) tree, with time shifted appropriately. The fitted <code>PSR(t)</code> is thus the product of the speciation rate at time <code class="reqn">t</code> and the probability of a lineage being in the tree at time <code>age0</code>. Most users will typically want to leave <code>age0=0</code>.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbd_psr_parametric</code> as possible, including reasonable lower and upper bounds (<code>param_min</code> and <code>param_max</code>), a reasonable parameter guess (<code>param_guess</code>) and reasonable parameter scales <code>param_scale</code>. If some model parameters can vary over multiple orders of magnitude, it is advised to transform them so that they vary across fewer orders of magnitude (e.g., via log-transformation). It is also important that the <code>age_grid</code> is sufficiently fine to capture the variation of the PSR over time, since the likelihood is calculated under the assumption that both vary linearly between grid points.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Numeric vector of size NP (number of model parameters), listing all fitted or fixed model parameters in their standard order (see details above). If <code>param_names</code> was provided, elements in <code>fitted_params</code> will be named.
</p>
</td></tr>
<tr><td><code>param_guess</code></td>
<td>

<p>Numeric vector of size NP, listing guessed or fixed values for all model parameters in their standard order.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>
<p>S. Louca (2020). Simulating trees with millions of species. Bioinformatics. 36:2907-2908.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>
<p><code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu
Ntips     = 10000
rho       = 0.5 # sampling fraction
time_grid = seq(from=0, to=100, by=0.01)
lambdas   = 2*exp(0.1*time_grid)
mus       = 1.5*exp(0.09*time_grid)
tree      = generate_random_tree( parameters  = list(rarefaction=rho), 
                                  max_tips    = Ntips/rho,
                                  coalescent  = TRUE,
                                  added_rates_times     = time_grid,
                                  added_birth_rates_pc  = lambdas,
                                  added_death_rates_pc  = mus)$tree
root_age = castor::get_tree_span(tree)$max_distance
cat(sprintf("Tree has %d tips, spans %g Myr\n",length(tree$tip.label),root_age))

# Define a parametric HBD congruence class, with exponentially varying PSR
# The model thus has 2 parameters
PSR_function = function(ages,params){
	return(params['A']*exp(-params['B']*ages));
}

# Define an age grid on which PSR_function shall be evaluated
# Should be sufficiently fine to capture the variation in the PSR
age_grid = seq(from=0,to=100,by=0.01)

# Perform fitting
cat(sprintf("Fitting class to tree..\n"))
fit = fit_hbd_psr_parametric(	tree, 
                      param_values  = c(A=NA, B=NA),
                      param_guess   = c(1,0),
                      param_min     = c(-10,-10),
                      param_max     = c(10,10),
                      param_scale   = 1, # all params are in the order of 1
                      PSR           = PSR_function,
                      age_grid      = age_grid,
                      Ntrials       = 10,    # perform 10 fitting trials
                      Nthreads      = 2,     # use 2 CPUs
                      max_model_runtime = 1, # limit model evaluation to 1 second
                      fit_control       = list(rel.tol=1e-6))
if(!fit$success){
	cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
	cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
	print(fit)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbds_model_on_grid'>
Fit a homogenous birth-death-sampling model on a discrete time grid.
</h2><span id='topic+fit_hbds_model_on_grid'></span>

<h3>Description</h3>

<p>Given a timetree (potentially sampled through time and not necessarily ultrametric), fit a homogenous birth-death-sampling (HBDS) model in which speciation, extinction and lineage sampling occurs at some continuous (Poissonian) rates <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\psi</code>, which are defined on a fixed grid of discrete time points and assumed to vary polynomially between grid points. Sampled lineages are kept in the pool of extant lineages at some &ldquo;retention probability&rdquo; <code class="reqn">\kappa</code>, which may also depend on time. In addition, this model can include concentrated sampling attempts (CSAs) at a finite set of discrete time points <code class="reqn">t_1,..,t_m</code>. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction/sampling rates. Every HBDS model is thus defined based on the values that <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> take over time, as well as the sampling probabilities <code class="reqn">\rho_1,..,\rho_m</code> and retention probabilities <code class="reqn">\kappa_1,..,\kappa_m</code> during the concentrated sampling attempts. This function estimates the values of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> on each grid point, as well as the <code class="reqn">\rho_1,..,\rho_m</code> and <code class="reqn">\kappa_1,..,\kappa_m</code>, by maximizing the corresponding likelihood of the timetree. Special cases of this model (when rates are piecewise constant through time) are sometimes known as &ldquo;birth-death-skyline plots&rdquo; in the literature (Stadler 2013). In epidemiology, these models are often used to describe the phylogenies of viral strains sampled over the course of the epidemic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbds_model_on_grid( tree, 
                        root_age                = NULL,
                        oldest_age              = NULL,
                        age_grid                = NULL,
                        CSA_ages                = NULL,
                        min_lambda              = 0,
                        max_lambda              = +Inf,
                        min_mu                  = 0,
                        max_mu                  = +Inf,
                        min_psi                 = 0,
                        max_psi                 = +Inf,
                        min_kappa               = 0,
                        max_kappa               = 1,
                        min_CSA_probs           = 0,
                        max_CSA_probs           = 1,
                        min_CSA_kappas          = 0,
                        max_CSA_kappas          = 1,
                        guess_lambda            = NULL,
                        guess_mu                = NULL,
                        guess_psi               = NULL,
                        guess_kappa             = NULL,
                        guess_CSA_probs         = NULL,
                        guess_CSA_kappas        = NULL,
                        fixed_lambda            = NULL,
                        fixed_mu                = NULL,
                        fixed_psi               = NULL,
                        fixed_kappa             = NULL,
                        fixed_CSA_probs         = NULL,
                        fixed_CSA_kappas        = NULL,
                        fixed_age_grid          = NULL,
                        const_lambda            = FALSE,
                        const_mu                = FALSE,
                        const_psi               = FALSE,
                        const_kappa             = FALSE,
                        const_CSA_probs         = FALSE,
                        const_CSA_kappas        = FALSE,
                        splines_degree          = 1,
                        condition               = "auto",
                        ODE_relative_dt         = 0.001,
                        ODE_relative_dy         = 1e-3,
                        CSA_age_epsilon         = NULL,
                        Ntrials                 = 1,
                        max_start_attempts      = 1,
                        Nthreads                = 1,
                        max_model_runtime       = NULL,
                        Nbootstraps             = 0,
                        Ntrials_per_bootstrap   = NULL,
                        fit_control             = list(),
                        focal_param_values      = NULL,
                        verbose                 = FALSE,
                        diagnostics             = FALSE,
                        verbose_prefix          = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbds_model_on_grid_+3A_tree">tree</code></td>
<td>

<p>A timetree of class &quot;phylo&quot;, representing the time-calibrated reconstructed phylogeny of a set of extant and/or extinct species. Tips of the tree are interpreted as terminally sampled lineages, while monofurcating nodes are interpreted as non-terminally sampled lineages, i.e., lineages sampled at some past time point and with subsequently sampled descendants.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_root_age">root_age</code></td>
<td>

<p>Positive numeric, specifying the age of the tree's root. Can be used to define a time offset, e.g. if the last tip was not actually sampled at the present. If <code>NULL</code>, this will be calculated from the tree and it will be assumed that the last tip was sampled at the present.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is interpreted as the stem age.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBDS model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing ages in ascending order, on which <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are fitted and allowed to vary independently. This grid must cover at least the age range from the present (age 0) to <code>oldest_age</code>. If <code>NULL</code> or of length &lt;=1 (regardless of value), then <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_csa_ages">CSA_ages</code></td>
<td>

<p>Optional numeric vector, listing ages (in ascending order) at which concentrated sampling attempts (CSAs) occurred. If <code>NULL</code>, it is assumed that no concentrated sampling attempts took place and that all tips were sampled according to the continuous sampling rate <code>psi</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_lambda">min_lambda</code></td>
<td>

<p>Numeric vector of length Ngrid (=<code>max(1,length(age_grid))</code>), or a single numeric, specifying lower bounds for the fitted speciation rate <code class="reqn">\lambda</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_lambda">max_lambda</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted speciation rate <code class="reqn">\lambda</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_mu">min_mu</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying lower bounds for the fitted extinction rate <code class="reqn">\mu</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_mu">max_mu</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted extinction rate <code class="reqn">\mu</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_psi">min_psi</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying lower bounds for the fitted Poissonian sampling rate <code class="reqn">\psi</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_psi">max_psi</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted Poissonian sampling rate <code class="reqn">\psi</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_kappa">min_kappa</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying lower bounds for the fitted retention probability <code class="reqn">\kappa</code> at each point in the age grid. If a single numeric, the same lower bound applies at all ages.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_kappa">max_kappa</code></td>
<td>

<p>Numeric vector of length Ngrid, or a single numeric, specifying upper bounds for the fitted retention probability <code class="reqn">\kappa</code> at each point in the age grid. If a single numeric, the same upper bound applies at all ages. Use <code>+Inf</code> to omit upper bounds.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_csa_probs">min_CSA_probs</code></td>
<td>

<p>Numeric vector of length NCSA (=<code>length(CSA_ages)</code>), or a single numeric, specifying lower bounds for the fitted sampling probabilities <code class="reqn">\rho_1</code>,..,<code class="reqn">\rho_m</code> at each concentrated sampling attempt. If a single numeric, the same lower bound applies at all CSAs. Note that, since <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... are probabilities, <code>min_CSA_probs</code> should not be negative.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_csa_probs">max_CSA_probs</code></td>
<td>

<p>Numeric vector of length NCSA, or a single numeric, specifying upper bounds for the fitted sampling probabilities <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... at each concentrated sampling attempt. If a single numeric, the same upper bound applies at all CSAs. Note that, since <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... are probabilities, <code>max_CSA_probs</code> should not be greater than 1.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_min_csa_kappas">min_CSA_kappas</code></td>
<td>

<p>Numeric vector of length NCSA, or a single numeric, specifying lower bounds for the fitted retention probabilities <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... at each concentrated sampling attempt. If a single numeric, the same lower bound applies at all CSAs. Note that, since <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... are probabilities, <code>min_CSA_kappas</code> should not be negative.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_csa_kappas">max_CSA_kappas</code></td>
<td>

<p>Numeric vector of length NCSA, or a single numeric, specifying upper bounds for the fitted sampling probabilities <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... at each concentrated sampling attempt. If a single numeric, the same upper bound applies at all CSAs. Note that, since <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, .. are probabilities, <code>max_CSA_kappas</code> should not be greater than 1.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_lambda">guess_lambda</code></td>
<td>

<p>Initial guess for <code class="reqn">\lambda</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\lambda</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\lambda</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_mu">guess_mu</code></td>
<td>

<p>Initial guess for <code class="reqn">\mu</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\mu</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\mu</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_psi">guess_psi</code></td>
<td>

<p>Initial guess for <code class="reqn">\psi</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\psi</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\psi</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_kappa">guess_kappa</code></td>
<td>

<p>Initial guess for <code class="reqn">\kappa</code> at each age-grid point. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same <code class="reqn">\kappa</code> at all ages) or a numeric vector of size Ngrid specifying a separate guess for <code class="reqn">\kappa</code> at each age-grid point. To omit an initial guess for some but not all age-grid points, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_csa_probs">guess_CSA_probs</code></td>
<td>

<p>Initial guess for the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... at each concentrated sampling attempt. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same value at every CSA) or a numeric vector of size NCSA specifying a separate guess at each CSA. To omit an initial guess for some but not all CSAs, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_guess_csa_kappas">guess_CSA_kappas</code></td>
<td>

<p>Initial guess for the <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... at each concentrated sampling attempt. Either <code>NULL</code> (an initial guess will be computed automatically), or a single numeric (guessing the same value at every CSA) or a numeric vector of size NCSA specifying a separate guess at each CSA. To omit an initial guess for some but not all CSAs, set their guess values to <code>NA</code>. Guess values are ignored for non-fitted (i.e., fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_lambda">fixed_lambda</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\lambda</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\lambda</code> is not fixed anywhere), or a single numeric (<code class="reqn">\lambda</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (if <code>fixed_age_grid=NULL</code>; <code class="reqn">\lambda</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values) or a numeric vector of the same size as <code>fixed_age_grid</code> (if <code>fixed_age_grid!=NULL</code>, in which case all entries in <code>fixed_lambda</code> must be finite numbers).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_mu">fixed_mu</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\mu</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\mu</code> is not fixed anywhere), or a single numeric (<code class="reqn">\mu</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (if <code>fixed_age_grid=NULL</code>; <code class="reqn">\mu</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values) or a numeric vector of the same size as <code>fixed_age_grid</code> (if <code>fixed_age_grid!=NULL</code>, in which case all entries in <code>fixed_mu</code> must be finite numbers).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_psi">fixed_psi</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\psi</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\psi</code> is not fixed anywhere), or a single numeric (<code class="reqn">\psi</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (if <code>fixed_age_grid=NULL</code>; <code class="reqn">\psi</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values) or a numeric vector of the same size as <code>fixed_age_grid</code> (if <code>fixed_age_grid!=NULL</code>, in which case all entries in <code>fixed_psi</code> must be finite numbers).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_kappa">fixed_kappa</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\kappa</code> values on one or more age-grid points. Either <code>NULL</code> (<code class="reqn">\kappa</code> is not fixed anywhere), or a single numeric (<code class="reqn">\kappa</code> fixed to the same value at all grid points) or a numeric vector of size Ngrid (if <code>fixed_age_grid=NULL</code>; <code class="reqn">\kappa</code> fixed on one or more age-grid points, use <code>NA</code> for non-fixed values) or a numeric vector of the same size as <code>fixed_age_grid</code> (if <code>fixed_age_grid!=NULL</code>, in which case all entries in <code>fixed_kappa</code> must be finite numbers).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_csa_probs">fixed_CSA_probs</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... values on one or more age-grid points. Either <code>NULL</code> (none of the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>,... are fixed), or a single numeric (<code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>,... are fixed to the same value at all CSAs) or a numeric vector of size NCSA (one or more of the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... are fixed, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_csa_kappas">fixed_CSA_kappas</code></td>
<td>

<p>Optional fixed (i.e. non-fitted) <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... values on one or more age-grid points. Either <code>NULL</code> (none of the <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>,... are fixed), or a single numeric (<code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>,... are fixed to the same value at all CSAs) or a numeric vector of size NCSA (one or more of the <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... are fixed, use <code>NA</code> for non-fixed values).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fixed_age_grid">fixed_age_grid</code></td>
<td>

<p>Optional numeric vector, specifying an age grid on which <code>fixed_lambda</code>, <code>fixed_mu</code>, <code>fixed_psi</code> and <code>fixed_kappa</code> (whichever is provided) are defined instead of on the <code>age_grid</code>. If <code>fixed_age_grid</code> is provided, then each of <code>fixed_lambda</code>, <code>fixed_mu</code>, <code>fixed_psi</code> and <code>fixed_kappa</code> must be defined (i.e. have a finite non-negative value) on every point in <code>fixed_age_grid</code>. Entries in <code>fixed_age_grid</code> must be in ascending order and must cover at least the ages 0 to <code>oldest_age</code>.
</p>
<p>This option may be useful if you want to fit some parameters on a coarse grid, but want to specify (fix) some other parameters on a much finer grid. Also note that if <code>fixed_age_grid</code> is used, all parameters <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> are internally re-interpolated onto <code>fixed_age_grid</code> when evaluating the likelihood; hence, in general <code>fixed_age_grid</code> should be much finer than <code>age_grid</code>. In most situations you would probably want to keep the default <code>fixed_age_grid=NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_lambda">const_lambda</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\lambda</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_lambda=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If <code class="reqn">\lambda</code> is fixed on some grid points (i.e. via <code>fixed_lambda</code>), then only the non-fixed lambdas are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_mu">const_mu</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\mu</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_mu=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If <code class="reqn">\mu</code> is fixed on some grid points (i.e. via <code>fixed_mu</code>), then only the non-fixed mus are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_psi">const_psi</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\psi</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_psi=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If <code class="reqn">\psi</code> is fixed on some grid points (i.e. via <code>fixed_psi</code>), then only the non-fixed psis are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_kappa">const_kappa</code></td>
<td>

<p>Logical, specifying whether <code class="reqn">\kappa</code> should be assumed constant across the grid, i.e. time-independent. Setting <code>const_kappa=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If <code class="reqn">\kappa</code> is fixed on some grid points (i.e. via <code>fixed_kappa</code>), then only the non-fixed kappas are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_csa_probs">const_CSA_probs</code></td>
<td>

<p>Logical, specifying whether the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... should be the same across all CSAs. Setting <code>const_CSA_probs=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If some of the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, ... are fixed (i.e. via <code>fixed_CSA_probs</code>), then only the non-fixed CSA_probs are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_const_csa_kappas">const_CSA_kappas</code></td>
<td>

<p>Logical, specifying whether the <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... should be the same across all CSAs. Setting <code>const_CSA_kappas=TRUE</code> reduces the number of free (i.e., independently fitted) parameters. If some of the <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>, ... are fixed (i.e. via <code>fixed_CSA_kappas</code>), then only the non-fixed CSA_kappas are assumed to be identical to one another.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer between 0 and 3 (inclusive), specifying the polynomial degree of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> between age-grid points. If 0, then <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are considered piecewise constant, if 1 they are considered piecewise linear, if 2 or 3 they are considered to be splines of degree 2 or 3, respectively. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. A degree of 0 is generally not recommended. The case <code>splines_degree=0</code> is also known as &ldquo;skyline&rdquo; model.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;none&quot; or &quot;auto&quot;, specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage. Note that &quot;crown&quot; really only makes sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. &quot;none&quot; is generally not recommended. If &quot;auto&quot;, the condition is chosen according to the above recommendations.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_ode_relative_dt">ODE_relative_dt</code></td>
<td>

<p>Positive unitless number, specifying the default relative time step for the ordinary differential equation solvers. Typical values are 0.01-0.001.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_ode_relative_dy">ODE_relative_dy</code></td>
<td>

<p>Positive unitless number, specifying the relative difference between subsequent simulated and interpolated values, in internally used ODE solvers. Typical values are 1e-2 to 1e-5. A smaller <code>ODE_relative_dy</code> increases interpolation accuracy, but also increases memory requirements and adds runtime (scaling with the tree's age span, not with Ntips).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_csa_age_epsilon">CSA_age_epsilon</code></td>
<td>

<p>Non-negative numeric, in units of time, specfying the age radius around a concentrated sampling attempt, within which to assume that sampling events were due to that concentrated sampling attempt. If <code>NULL</code>, this is chosen automatically based on the anticipated scale of numerical rounding errors. Only relevant if concentrated sampling attempts are included.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly choosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_focal_param_values">focal_param_values</code></td>
<td>

<p>Optional list, listing combinations of parameter values of particular interest and for which the log-likelihoods should be returned. Every element of this list should itself be a named list, containing the elements <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> (each being a numeric vector of size NG) as well as the elements <code>CSA_probs</code> and <code>CSA_kappas</code> (each being a numeric vector of size NCSA). This may be used e.g. for diagnostic purposes, e.g. to examine the shape of the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_on_grid_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: In the absence of concentrated sampling attempts (NCSA=0), and without well-justified a priori constraints on either <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and/or <code class="reqn">\kappa</code>, it is generally impossible to reliably estimate <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> from timetrees alone. This routine (and any other software that claims to estimate <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> solely from timetrees) should thus be treated with great suspicion. Many epidemiological models make the (often reasonable assumption) that <code class="reqn">\kappa=0</code>; note that even in this case, one generally can't co-estimate <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\psi</code> from the timetree alone.
</p>
<p>It is advised to provide as much information to the function <code>fit_hbds_model_on_grid</code> as possible, including reasonable lower and upper bounds (<code>min_lambda</code>, <code>max_lambda</code>, <code>min_mu</code>, <code>max_mu</code>, <code>min_psi</code>, <code>max_psi</code>, <code>min_kappa</code>, <code>max_kappa</code>) and reasonable parameter guesses. It is also important that the <code>age_grid</code> is sufficiently fine to capture the expected major variations of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> over time, but keep in mind the serious risk of overfitting when <code>age_grid</code> is too fine and/or the tree is too small. The <code>age_grid</code> does not need to be uniform, i.e., you may want to use a finer grid in regions where there's more data (tips) available. If strong lower and upper bounds are not available and fitting takes a long time to run, consider using the option <code>max_model_runtime</code> to limit how much time the fitting allows for each evaluation of the likelihood.
</p>
<p>Note that here &quot;age&quot; refers to time before present, i.e., age increases from tips to root and age 0 is present-day. CSAs are enumerated in the order of increasing age, i.e., from the present to the past. Similarly, the age grid specifies time points from the present towards the past.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>guess_loglikelihood</code></td>
<td>

<p>The log-likelihood of the guessed model for the given timetree.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Named list, specifying the fixed and fitted model parameters. This list will contain the elements <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> (each being a numeric vector of size NG, listing <code class="reqn">\lambda</code>,<code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> at each age-grid point) as well as the elements <code>CSA_probs</code> and <code>CSA_kappas</code> (each being a numeric vector of size NCSA).
</p>
</td></tr>
<tr><td><code>param_guess</code></td>
<td>

<p>Named list, specifying the guessed model parameters. This list will contain the elements <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> (each being a numeric vector of size NG) as well as the elements <code>CSA_probs</code> and <code>CSA_kappas</code> (each being a numeric vector of size NCSA). Between grid points <code class="reqn">\lambda</code> should be interpreted as a piecewise polynomial function (natural spline) of degree <code>splines_degree</code>; to evaluate this function at arbitrary ages use the <code>castor</code> routine <code><a href="#topic+evaluate_spline">evaluate_spline</a></code>. The same also applies to <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code>.
</p>
</td></tr>
<tr><td><code>age_grid</code></td>
<td>

<p>Numeric vector of size NG, the age-grid on which <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are defined. This will be the same as the provided <code>age_grid</code>, unless the latter was <code>NULL</code> or of length &lt;=1.
</p>
</td></tr>
<tr><td><code>CSA_ages</code></td>
<td>

<p>Numeric vector of size NCSA, ting listhe ages at which concentrated sampling attempts occurred. This is the same as provided to the function.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of free (i.e., independently) fitted parameters. If none of the <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho</code> were fixed, and <code>const_lambda=FALSE</code> and <code>const_mu=FALSE</code>, then <code>NFP</code> will be equal to 2*Ngrid+1.
</p>
</td></tr>
<tr><td><code>Ndata</code></td>
<td>

<p>Integer, the number of data points (sampling and branching events) used for fitting.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of branching times), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>

<p>Character, specifying what conditioning was root for the likelihood (e.g. &quot;crown&quot; or &quot;stem&quot;).
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Named list specifying the standard errors of the parameters, based on parametric bootstrapping. This list will contain the elements <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> (each being a numeric vector of size NG) as well as the elements <code>CSA_probs</code> and <code>CSA_kappas</code> (each being a numeric vector of size NCSA). Only included if <code>Nbootstraps&gt;0</code>. Note that the standard errors of non-fitted (i.e., fixed) parameters will be zero.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Named list specifying the lower end of the 50% confidence interval (i.e. the 25% quantile) for each parameter, based on parametric bootstrapping. This list will contain the elements <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> (each being a numeric vector of size NG) as well as the elements <code>CSA_probs</code> and <code>CSA_kappas</code> (each being a numeric vector of size NCSA). Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Similar to <code>CI50lower</code>, but listing the upper end of the 50% confidence interval (i.e. the 75% quantile) for each parameter. For example, the confidence interval for <code class="reqn">\lambda</code> at age <code>age_grid[1]</code> will be between <code>CI50lower$lambda[1]</code> and <code>CI50upper$lambda[1]</code>. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Similar to <code>CI50lower</code>, but listing the lower end of the 95% confidence interval (i.e. the 2.5% quantile) for each parameter. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Similar to <code>CI50upper</code>, but listing the upper end of the 95% confidence interval (i.e. the 97.5% quantile) for each parameter. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. If <code class="reqn">L</code> denotes the loglikelihood of new data generated by the fitted model (under the same model) and <code class="reqn">M</code> denotes the expectation of <code class="reqn">L</code>, then <code>consistency</code> is the probability that <code class="reqn">|L-M|</code> will be greater or equal to <code class="reqn">|X-M|</code>, where <code class="reqn">X</code> is the loglikelihood of the original data under the fitted model. Only returned if <code>Nbootstraps&gt;0</code>. A low consistency (e.g., &lt;0.05) indicates that the fitted model is a poor description of the data. See Lindholm et al. (2019) for background.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler, D. Kuehnert, S. Bonhoeffer, A. J. Drummond (2013). Birth-death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV). PNAS. 110:228-233.
</p>
<p>A. Lindholm, D. Zachariah, P. Stoica, T. B. Schoen (2019). Data consistency approach to model validation. IEEE Access. 7:59788-59796.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>, 
<code><a href="#topic+fit_hbds_model_parametric">fit_hbds_model_parametric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# define lambda &amp; mu &amp; psi as functions of time
# Assuming an exponentially varying lambda &amp; mu, and a constant psi
time2lambda = function(times){ 2*exp(0.1*times) }
time2mu     = function(times){ 0.1*exp(0.09*times) }
time2psi    = function(times){ rep(0.2, times=length(times)) }

# define concentrated sampling attempts
CSA_times   = c(3,4)
CSA_probs   = c(0.1, 0.2)

# generate random tree based on lambda, mu &amp; psi
# assume that all sampled lineages are removed from the pool (i.e. kappa=0)
time_grid = seq(from=0, to=100, by=0.01)
simul = generate_tree_hbds( max_time    = 5,
                            time_grid   = time_grid,
                            lambda      = time2lambda(time_grid),
                            mu          = time2mu(time_grid),
                            psi         = time2psi(time_grid),
                            kappa       = 0,
                            CSA_times   = CSA_times,
                            CSA_probs   = CSA_probs,
                            CSA_kappas  = 0)
tree     = simul$tree
root_age = simul$root_age
cat(sprintf("Tree has %d tips\n",length(tree$tip.label)))

# Define an age grid on which lambda_function &amp; mu_function shall be fitted
fit_age_grid = seq(from=0,to=root_age,length.out=3)

# Fit an HBDS model on a grid
# Assume that psi is known and that sampled lineages are removed from the pool
# Hence, we only fit lambda &amp; mu &amp; CSA_probs
cat(sprintf("Fitting model to tree..\n"))
fit = fit_hbds_model_on_grid(tree, 
                             root_age           = root_age,
                             age_grid           = fit_age_grid,
                             CSA_ages           = rev(simul$final_time - CSA_times),
                             fixed_psi          = time2psi(simul$final_time-fit_age_grid),
                             fixed_kappa        = 0,
                             fixed_CSA_kappas   = 0,
                             Ntrials            = 4,
                             Nthreads           = 4,
                             Nbootstraps        = 0,
                             verbose            = TRUE,
                             verbose_prefix     = "  ")
if(!fit$success){
    cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
    # compare fitted lambda to true lambda
    plot(x=fit$age_grid, 
         y=fit$param_fitted$lambda, 
         type='l', 
         col='#000000', 
         xlim=c(root_age,0),
         xlab='age', 
         ylab='lambda')
    lines(x=simul$final_time-time_grid, 
          y=time2lambda(time_grid), 
          type='l', 
          col='#0000AA')
}


# compare true and fitted model in terms of their LTTs
LTT      = castor::count_lineages_through_time(tree, Ntimes=100, include_slopes=TRUE)
LTT$ages = root_age - LTT$times

cat(sprintf("Simulating deterministic HBDS (true model)..\n"))
age0 = 0.5 # reference age at which to equate LTTs
LTT0 = approx(x=LTT$ages, y=LTT$lineages, xout=age0)$y # tree LTT at age0
fsim = simulate_deterministic_hbds( age_grid        = fit$age_grid,
                                    lambda          = fit$param_fitted$lambda,
                                    mu              = fit$param_fitted$mu,
                                    psi             = fit$param_fitted$psi,
                                    kappa           = fit$param_fitted$kappa,
                                    CSA_ages        = fit$CSA_ages,
                                    CSA_probs       = fit$param_fitted$CSA_probs,
                                    CSA_kappas      = fit$param_fitted$CSA_kappas,
                                    requested_ages  = seq(0,root_age,length.out=200),
                                    age0            = age0,
                                    LTT0            = LTT0,
                                    splines_degree  = 1)
if(!fsim$success){
    cat(sprintf("ERROR: Could not simulate fitted model: %s\n",fsim$error))
    stop()
}
plot(x=LTT$ages, y=LTT$lineages, type='l', col='#0000AA', lwd=2, xlim=c(root_age,0))
lines(x=fsim$ages, y=fsim$LTT, type='l', col='#000000', lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_hbds_model_parametric'>
Fit a parametric homogenous birth-death-sampling model to a timetree.
</h2><span id='topic+fit_hbds_model_parametric'></span>

<h3>Description</h3>

<p>Given a timetree (potentially sampled through time and not necessarily ultrametric), fit a homogenous birth-death-sampling (HBDS) model in which speciation, extinction and lineage sampling occurs at some continuous (Poissonian) rates <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\psi</code>, which are given as parameterized functions of time before present. Sampled lineages are kept in the pool of extant lineages at some &ldquo;retention probability&rdquo; <code class="reqn">\kappa</code>, which may also depend on time. In addition, this model can include concentrated sampling attempts (CSAs) at a finite set of discrete time points <code class="reqn">t_1,..,t_m</code>. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction/sampling rates. Every HBDS model is thus defined based on the values that <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> take over time, as well as the sampling probabilities <code class="reqn">\rho_1,..,\rho_m</code> and retention probabilities <code class="reqn">\kappa_1,..,\kappa_m</code> during the concentrated sampling attempts; each of these parameters, in turn, is assumed to be determined by a finite set of parameters. This function estimates these parameters by maximizing the corresponding likelihood of the timetree. Special cases of this model are sometimes known as &ldquo;birth-death-skyline plots&rdquo; in the literature (Stadler 2013). In epidemiology, these models are often used to describe the phylogenies of viral strains sampled over the course of the epidemic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hbds_model_parametric(tree, 
                          param_values,
                          param_guess           = NULL,
                          param_min             = -Inf,
                          param_max             = +Inf,
                          param_scale           = NULL,
                          root_age              = NULL,
                          oldest_age            = NULL,
                          lambda                = 0,
                          mu                    = 0,
                          psi                   = 0,
                          kappa                 = 0,
                          age_grid              = NULL,
                          CSA_ages              = NULL,
                          CSA_probs             = NULL,
                          CSA_kappas            = 0,
                          condition             = "auto",
                          ODE_relative_dt       = 0.001,
                          ODE_relative_dy       = 1e-3,
                          CSA_age_epsilon       = NULL,
                          Ntrials               = 1,
                          max_start_attempts    = 1,
                          Nthreads              = 1,
                          max_model_runtime     = NULL,
                          Nbootstraps           = 0,
                          Ntrials_per_bootstrap = NULL,
                          fit_control           = list(),
                          focal_param_values    = NULL,
                          verbose               = FALSE,
                          diagnostics           = FALSE,
                          verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hbds_model_parametric_+3A_tree">tree</code></td>
<td>

<p>A timetree of class &quot;phylo&quot;, representing the time-calibrated reconstructed phylogeny of a set of extant and/or extinct species. Tips of the tree are interpreted as terminally sampled lineages, while monofurcating nodes are interpreted as non-terminally sampled lineages, i.e., lineages sampled at some past time point and with subsequently sampled descendants.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_param_values">param_values</code></td>
<td>

<p>Numeric vector, specifying fixed values for a some or all model parameters. For fitted (i.e., non-fixed) parameters, use <code>NaN</code> or <code>NA</code>. For example, the vector <code>c(1.5,NA,40)</code> specifies that the 1st and 3rd model parameters are fixed at the values 1.5 and 40, respectively, while the 2nd parameter is to be fitted. The length of this vector defines the total number of model parameters. If entries in this vector are named, the names are taken as parameter names. Names should be included if the functions <code>lambda</code>, <code>mu</code>, <code>psi</code>, <code>kappa</code>, <code>CSA_psi</code> and <code>CSA_kappa</code> query parameter values by name (as opposed to numeric index).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_param_guess">param_guess</code></td>
<td>

<p>Numeric vector of size NP, specifying a first guess for the value of each model parameter. For fixed parameters, guess values are ignored. Can be <code>NULL</code> only if all model parameters are fixed.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_param_min">param_min</code></td>
<td>

<p>Optional numeric vector of size NP, specifying lower bounds for model parameters. If of size 1, the same lower bound is applied to all parameters. Use <code>-Inf</code> to omit a lower bound for a parameter. If <code>NULL</code>, no lower bounds are applied. For fixed parameters, lower bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_param_max">param_max</code></td>
<td>

<p>Optional numeric vector of size NP, specifying upper bounds for model parameters. If of size 1, the same upper bound is applied to all parameters. Use <code>+Inf</code> to omit an upper bound for a parameter. If <code>NULL</code>, no upper bounds are applied. For fixed parameters, upper bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_param_scale">param_scale</code></td>
<td>

<p>Optional numeric vector of size NP, specifying typical scales for model parameters. If of size 1, the same scale is assumed for all parameters. If <code>NULL</code>, scales are determined automatically. For fixed parameters, scales are ignored. It is strongly advised to provide reasonable scales, as this facilitates the numeric optimization algorithm.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_root_age">root_age</code></td>
<td>

<p>Positive numeric, specifying the age of the tree's root. Can be used to define a time offset, e.g. if the last tip was not actually sampled at the present. If <code>NULL</code>, this will be calculated from the tree and it will be assumed that the last tip was sampled at the present.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is interpreted as the stem age.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBDS model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_lambda">lambda</code></td>
<td>

<p>Function specifying the speciation rate at any given age (time before present) and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with strictly positive entries. Can also be a single numeric (i.e., lambda is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_mu">mu</code></td>
<td>

<p>Function specifying the extinction rate at any given age and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with non-negative entries. Can also be a single numeric (i.e., mu is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_psi">psi</code></td>
<td>

<p>Function specifying the continuous (Poissonian) lineage sampling rate at any given age and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with non-negative entries. Can also be a single numeric (i.e., psi is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_kappa">kappa</code></td>
<td>

<p>Function specifying the retention probability for continuously sampled lineages, at any given age and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more ages) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument with non-negative entries. The retention probability is the probability of a sampled lineage remaining in the pool of extant lineages. Can also be a single numeric (i.e., kappa is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, specifying ages at which the <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> functionals should be evaluated. This age grid must be fine enough to capture the possible variation in <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> over time, within the permissible parameter range. Listed ages must be strictly increasing, and must cover at least the full considered age interval (from 0 to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_csa_ages">CSA_ages</code></td>
<td>

<p>Optional numeric vector, listing ages (in ascending order) at which concentrated sampling attempts occurred. If <code>NULL</code>, it is assumed that no concentrated sampling attempts took place and that all tips were sampled according to the continuous sampling rate <code>psi</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_csa_probs">CSA_probs</code></td>
<td>

<p>Function specifying the sampling probabilities during the various concentrated sampling attempts, depending on parameter values. Hence, for any choice of parameters, <code>CSA_probs</code> must return a numeric vector of the same size as <code>CSA_ages</code>. Can also be a single numeric (i.e., concentrated sampling probability is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_csa_kappas">CSA_kappas</code></td>
<td>

<p>Function specifying the retention probabilities during the various concentrated sampling attempts, depending on parameter values. Hence, for any choice of parameters, <code>CSA_kappas</code> must return a numeric vector of the same size as <code>CSA_ages</code>. Can also be a single numeric (i.e., retention probability during concentrated samplings is fixed).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;none&quot; or &quot;auto&quot;, specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage. Note that &quot;crown&quot; really only makes sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. &quot;none&quot; is usually not recommended. If &quot;auto&quot;, the condition is chosen according to the above recommendations.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_ode_relative_dt">ODE_relative_dt</code></td>
<td>

<p>Positive unitless number, specifying the default relative time step for the ordinary differential equation solvers. Typical values are 0.01-0.001.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_ode_relative_dy">ODE_relative_dy</code></td>
<td>

<p>Positive unitless number, specifying the relative difference between subsequent simulated and interpolated values, in internally used ODE solvers. Typical values are 1e-2 to 1e-5. A smaller <code>ODE_relative_dy</code> increases interpolation accuracy, but also increases memory requirements and adds runtime (scaling with the tree's age span, not with Ntips).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_csa_age_epsilon">CSA_age_epsilon</code></td>
<td>

<p>Non-negative numeric, in units of time, specfying the age radius around a concentrated sampling attempt, within which to assume that sampling events were due to that concentrated sampling attempt. If <code>NULL</code>, this is chosen automatically based on the anticipated scale of numerical rounding errors. Only relevant if concentrated sampling attempts are included.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly chosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional numeric, specifying the maximum number of seconds to allow for each evaluation of the likelihood function. Use this to abort fitting trials leading to parameter regions where the likelihood takes a long time to evaluate (these are often unlikely parameter regions).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated model parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_focal_param_values">focal_param_values</code></td>
<td>

<p>Optional numeric matrix having NP columns and an arbitrary number of rows, listing combinations of parameter values of particular interest and for which the log-likelihoods should be returned. This may be used for diagnostic purposes, e.g., to examine the shape of the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_hbds_model_parametric_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate a finite set of scalar parameters (<code class="reqn">p_1,..,p_n\in\R</code>) that determine the speciation rate <code class="reqn">\lambda</code>, the extinction rate <code class="reqn">\mu</code>, the sampling rate <code class="reqn">\psi</code>, the retention rate <code class="reqn">\kappa</code>, the concentrated sampling probabilities <code class="reqn">\rho_1,..,\rho_m</code> and the concentrated retention probabilities <code class="reqn">\kappa_1,..,\kappa_m</code>, by maximizing the likelihood of observing a given timetree under the HBDS model. Note that the ages (times before present) of the concentrated sampling attempts are assumed to be known and are not fitted.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_hbds_model_parametric</code> as possible, including reasonable lower and upper bounds (<code>param_min</code> and <code>param_max</code>), a reasonable parameter guess (<code>param_guess</code>) and reasonable parameter scales <code>param_scale</code>. If some model parameters can vary over multiple orders of magnitude, it is advised to transform them so that they vary across fewer orders of magnitude (e.g., via log-transformation). It is also important that the <code>age_grid</code> is sufficiently fine to capture the variation of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> over time, since the likelihood is calculated under the assumption that these functions vary linearly between grid points.
</p>
<p>Note that in this function age always refers to time before present, i.e., present day age is 0 and age increases from tips to root. The functions <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> should be functions of age, not forward time. Similarly, concentrated sampling attempts (CSAs) are enumerated in order of increasing age, i.e., starting with the youngest CSA and moving towards older CSAs.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;<code>error</code>&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given timetree.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Numeric vector of size NP (number of model parameters), listing all fitted or fixed model parameters in their standard order (see details above). If <code>param_names</code> was provided, elements in <code>fitted_params</code> will be named.
</p>
</td></tr>
<tr><td><code>param_guess</code></td>
<td>

<p>Numeric vector of size NP, listing guessed or fixed values for all model parameters in their standard order. If <code>param_names</code> was provided, elements in <code>param_guess</code> will be named.
</p>
</td></tr>
<tr><td><code>guess_loglikelihood</code></td>
<td>

<p>The loglikelihood of the data for the initial parameter guess (<code>param_guess</code>).
</p>
</td></tr>
<tr><td><code>focal_loglikelihoods</code></td>
<td>

<p>A numeric vector of the same size as <code>nrow(focal_param_values)</code>, listing loglikelihoods for each of the focal parameter conbinations listed in <code>focal_loglikelihoods</code>.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>Ndata</code></td>
<td>

<p>Number of data points used for fitting, i.e., the number of sampling and branching events that occurred between ages 0 and <code>oldest_age</code>.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (<code>Ndata</code>), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>

<p>Character, specifying what conditioning was root for the likelihood (e.g. &quot;crown&quot; or &quot;stem&quot;).
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size NP, estimated standard error of the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>Numeric vector of size NP, median the estimated parameters across parametric bootstraps. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 50% confidence interval (25-75% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 50% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 95% confidence interval (2.5-97.5% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 95% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model (Lindholm et al. 2019). See the documentation of <code><a href="#topic+fit_hbds_model_on_grid">fit_hbds_model_on_grid</a></code> for an explanation.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler, D. Kuehnert, S. Bonhoeffer, A. J. Drummond (2013). Birth-death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV). PNAS. 110:228-233.
</p>
<p>A. Lindholm, D. Zachariah, P. Stoica, T. B. Schoen (2019). Data consistency approach to model validation. IEEE Access. 7:59788-59796.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_tree_hbds">generate_tree_hbds</a></code>,
<code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a random tree with exponentially varying lambda &amp; mu and constant psi
# assume that all sampled lineages are removed from the pool (i.e. kappa=0)
time_grid = seq(from=0, to=100, by=0.01)
root_age  = 5
tree = generate_tree_hbds(max_time  = root_age,
                        time_grid   = time_grid,
                        lambda      = 2*exp(0.1*time_grid),
                        mu          = 0.1*exp(0.09*time_grid),
                        psi         = 0.1,
                        kappa       = 0)$tree
cat(sprintf("Tree has %d tips\n",length(tree$tip.label)))


# Define a parametric HBDS model, with exponentially varying lambda &amp; mu
# Assume that the sampling rate is constant but unknown
# The model thus has 5 parameters: lambda0, mu0, alpha, beta, psi
lambda_function = function(ages,params){
    return(params['lambda0']*exp(-params['alpha']*ages));
}
mu_function = function(ages,params){
    return(params['mu0']*exp(-params['beta']*ages));
}
psi_function = function(ages,params){
    return(rep(params['psi'],length(ages)))
}

# Define an age grid on which lambda_function &amp; mu_function shall be evaluated
# Should be sufficiently fine to capture the variation in lambda &amp; mu
age_grid = seq(from=0,to=root_age,by=0.01)

# Perform fitting
cat(sprintf("Fitting model to tree..\n"))
fit = fit_hbds_model_parametric(tree, 
                      root_age      = root_age,
                      param_values  = c(lambda0=NA, mu0=NA, alpha=NA, beta=NA, psi=NA),
                      param_guess   = c(1,1,0,0,0.5),
                      param_min     = c(0,0,-1,-1,0),
                      param_max     = c(10,10,1,1,10),
                      param_scale   = 1, # all params are in the order of 1
                      lambda        = lambda_function,
                      mu            = mu_function,
                      psi           = psi_function,
                      kappa         = 0,
                      age_grid      = age_grid,
                      Ntrials       = 4, # perform 4 fitting trials
                      Nthreads      = 2) # use 2 CPUs
if(!fit$success){
    cat(sprintf("ERROR: Fitting failed: %s\n",fit$error))
}else{
    cat(sprintf("Fitting succeeded:\nLoglikelihood=%g\n",fit$loglikelihood))
    # print fitted parameters
    print(fit$param_fitted)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_mk'>
Fit a Markov (Mk) model for discrete trait evolution.
</h2><span id='topic+fit_mk'></span>

<h3>Description</h3>

<p>Estimate the transition rate matrix of a continuous-time Markov model for discrete trait evolution (&quot;Mk model&quot;) via maximum-likelihood, based on one or more phylogenetic trees and its tips' states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mk( trees,
        Nstates,
        tip_states              = NULL,
        tip_priors              = NULL,
        rate_model              = "ER",
        root_prior              = "auto",
        oldest_ages             = NULL,
        guess_transition_matrix = NULL,
        Ntrials                 = 1,
        Nscouts                 = NULL,
        max_model_runtime       = NULL,
        optim_algorithm         = "nlminb",
        optim_max_iterations    = 200,
        optim_rel_tol           = 1e-8,
        check_input             = TRUE,
        Nthreads                = 1,
        Nbootstraps             = 0,	
        Ntrials_per_bootstrap   = NULL,
        verbose                 = FALSE,
        diagnostics             = FALSE,
        verbose_prefix          = "")
        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mk_+3A_trees">trees</code></td>
<td>

<p>Either a single phylogenetic tree of class &quot;phylo&quot;, or a list of phylogenetic trees. Edge lengths should correspond (or be analogous) to time. The trees don't need to be ultrametric.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_nstates">Nstates</code></td>
<td>

<p>Integer, specifying the number of possible discrete states that the trait can have.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_tip_states">tip_states</code></td>
<td>

<p>Either an integer vector of size Ntips (only permitted if trees[] is a single tree) or a list containing Ntrees such integer vectors (if trees[] is a list of trees), listing the state of each tip in each tree. Note that tip_states cannot include NAs or NaNs; if the states of some tips are uncertain, you should use the option <code>tip_priors</code> instead. Can also be <code>NULL</code>, in which case <code>tip_priors</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_tip_priors">tip_priors</code></td>
<td>

<p>Either a numeric matrix of size Ntips x Nstates (only permitted if trees[] is a single tree), or a list containing Ntrees such matrixes (if trees[] is a list of trees), listing the likelihood of each state at each tip in each tree. Can also be <code>NULL</code>, in which case <code>tip_states</code> must be provided. Hence, <code>tip_priors[t][i,s]</code> is the likelihood of the observed state of tip i in tree t, if the tip's true state was in state s. For example, if you know for certain that a tip is in state k, then set <code>tip_priors[t][i,s]=1</code> for s=k and <code>tip_priors[t][i,s]=0</code> for all other s.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_rate_model">rate_model</code></td>
<td>

<p>Rate model to be used for the transition rate matrix. Can be &quot;ER&quot; (all rates equal), &quot;SYM&quot; (transition rate i&ndash;&gt;j is equal to transition rate j&ndash;&gt;i), &quot;ARD&quot; (all rates can be different), &quot;SUEDE&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, all 'up' transitions are equal, all 'down' transitions are equal) or &quot;SRD&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, and each rate can be different). Can also be an index matrix that maps entries of the transition matrix to the corresponding independent rate parameter to be fitted. Diagonal entries should map to 0, since diagonal entries are not treated as independent rate parameters but are calculated from the remaining entries in the transition rate matrix. All other entries that map to 0 represent a transition rate of zero. The format of this index matrix is similar to the format used by the <code>ace</code> function in the <code>ape</code> package. <code>rate_model</code> is only relevant if <code>transition_matrix==NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_root_prior">root_prior</code></td>
<td>

<p>Prior probability distribution of the root's states, used to calculate the model's overall likelihood from the root's marginal ancestral state likelihoods. Can be &quot;<code>flat</code>&quot; (all states equal), &quot;<code>empirical</code>&quot; (empirical probability distribution of states across the tree's tips), &quot;<code>stationary</code>&quot; (stationary probability distribution of the transition matrix), &quot;<code>likelihoods</code>&quot; (use the root's state likelihoods as prior), &quot;<code>max_likelihood</code>&quot; (put all weight onto the state with maximum likelihood) or &ldquo;<code>auto</code>&rdquo; (will be chosen automatically based on some internal logic). If &quot;<code>stationary</code>&quot; and <code>transition_matrix==NULL</code>, then a transition matrix is first fitted using a flat root prior, and then used to calculate the stationary distribution. <code>root_prior</code> can also be a non-negative numeric vector of size Nstates and with total sum equal to 1.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_oldest_ages">oldest_ages</code></td>
<td>

<p>Optional numeric or numeric vector of size Ntrees, specifying the oldest age (time before present) for each tree to consider when fitting the Mk model. If <code>NULL</code>, the entire trees are considered from the present all the way to their root. If non-<code>NULL</code>, then each tree is &ldquo;cut&rdquo; at the corresponding oldest age, yielding multiple subtrees, each of which is assumed to be an independent realization of the Mk process. If <code>oldest_ages</code> is a single numeric, then all trees are cut at the same oldest age. This option may be useful if temporal variation is suspected in the Mk rates, and only data near the present are to be used for fitting to avoid violating the assumptions of a constant-rates Mk model.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_guess_transition_matrix">guess_transition_matrix</code></td>
<td>

<p>Optional 2D numeric matrix, specifying a reasonable first guess for the transition rate matrix. May contain <code>NA</code>. May also be <code>NULL</code>, in which case a reasonable first guess is automatically generated.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, number of trials (starting points) for fitting the transition rate matrix. A higher number may reduce the risk of landing in a local non-global optimum of the likelihood function, but will increase computation time during fitting.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_nscouts">Nscouts</code></td>
<td>

<p>Optional positive integer, number of randomly chosen starting points to consider for all fitting trials except the first one. Among all &quot;scouted&quot; starting points, the <code>Ntrials-1</code> most promising ones will be considered. A greater number of scouts increases the chances of finding a global likelihood maximum. Each scout costs only one evaluation of the loglikelihood function. If <code>NULL</code>, <code>Nscout</code> is automatically chosen based on the number of fitted parameters and <code>Ntrials</code>. Only relevant if <code>Ntrials&gt;1</code>, since the first trial always uses the default or provided parameter guess.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Optional positive numeric, specifying the maximum time (in seconds) allowed for a single evaluation of the likelihood function. If a specific Mk model takes longer than this threshold to evaluate, then its likelihood is set to -Inf. This option can be used to avoid badly parameterized models during fitting and can thus reduce fitting time. If NULL or &lt;=0, this option is ignored.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_optim_algorithm">optim_algorithm</code></td>
<td>

<p>Either &quot;optim&quot; or &quot;nlminb&quot;, specifying which optimization algorithm to use for maximum-likelihood estimation of the transition matrix.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_optim_max_iterations">optim_max_iterations</code></td>
<td>

<p>Maximum number of iterations (per fitting trial) allowed for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_optim_rel_tol">optim_rel_tol</code></td>
<td>

<p>Relative tolerance (stop criterion) for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_nthreads">Nthreads</code></td>
<td>

<p>Number of parallel threads to use for running multiple fitting trials simultaneously. This only makes sense if your computer has multiple cores/CPUs and if <code>Ntrials&gt;1</code>. This option is ignored on Windows, because Windows does not support forking.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated rate parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed diagnostic messages, mainly for debugging purposes.
</p>
</td></tr>
<tr><td><code id="fit_mk_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. The order of states (if relevant) should be reflected in their integer representation. For example, if your original states are &quot;small&quot;, &quot;medium&quot; and &quot;large&quot; and <code>rate_model=="SUEDE"</code>, it is advised to represent these states as integers 1,2,3. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>This function allows the specification of the precise tip states (if these are known) using the vector <code>tip_states</code>. Alternatively, if some tip states are not fully known, you can pass the state likelihoods using the matrix <code>tip_priors</code>. Note that exactly one of the two arguments, <code>tip_states</code> or <code>tip_priors</code>, must be non-<code>NULL</code>. 
</p>
<p>Tips must be represented in <code>tip_states</code> or <code>tip_priors</code> in the same order as in <code>tree$tip.label</code>. None of the input vectors or matrixes need include row or column names; if they do, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>The tree is either assumed to be complete (i.e. include all possible species), or to represent a random subset of species chosen independently of their states. If the tree is not complete and tips are not chosen independently of their states, then this method will not be valid.
</p>
<p><code>fit_Mk</code> uses maximum-likelihood to estimate each free parameter of the transition rate matrix. The number of free parameters depends on the <code>rate_model</code> considered; for example, <code>ER</code> implies a single free parameter, while <code>ARD</code> implies Nstates x (Nstates-1) free parameters. If multiple trees are provided as input, the likelihood is the product of likelihoods for each tree, i.e. as if each tree was an independent realization of the same Markov process.
</p>
<p>This function is similar to <code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, but focused solely on fitting the transition rate matrix (i.e., without estimating ancestral states) and with the ability to utilize multiple trees at once.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, an additional element <code>error</code> (of type character) is included containing an explanation of the error; in that case the value of any of the other elements is undetermined.
</p>
</td></tr>
<tr><td><code>Nstates</code></td>
<td>

<p>Integer, the number of states assumed for the model.
</p>
</td></tr>
<tr><td><code>transition_matrix</code></td>
<td>

<p>A matrix of size Nstates x Nstates, the fitted transition rate matrix of the model. The [r,c]-th entry is the transition rate from state r to state c.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Numeric, the log-likelihood of the observed tip states under the fitted model.
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, the number of iterations required to reach the maximum log-likelihood. Depending on the optimization algorithm used (see <code>optim_algorithm</code>), this may be <code>NA</code>.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, the number of evaluations of the likelihood function required to reach the maximum log-likelihood. Depending on the optimization algorithm used (see <code>optim_algorithm</code>), this may be <code>NA</code>.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, indicating whether the fitting algorithm converged. Note that <code>fit_Mk</code> may return successfully even if convergence was not achieved; if this happens, the fitted transition matrix may not be reasonable. In that case it is recommended to change the optimization options, for example increasing <code>optim_max_iterations</code>.
</p>
</td></tr>
<tr><td><code>guess_rate</code></td>
<td>

<p>Numeric, the initial guess used for the average transition rate, prior to fitting.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>Numeric, the Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of independent fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric matrix of size Nstates x Nstates, estimated standard error of the fitted transition rates, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric matrix of size Nstates x Nstates, lower bounds of the 50% confidence intervals (25-75% percentile) for the fitted transition rates, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric matrix of size Nstates x Nstates, upper bounds of the 50% confidence intervals for the fitted transition rates, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric matrix of size Nstates x Nstates, lower bounds of the 95% confidence intervals (2.5-97.5% percentile) for the fitted transition rates, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric matrix of size Nstates x Nstates, upper bounds of the 95% confidence intervals for the fitted transition rates, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Z. Yang, S. Kumar and M. Nei (1995). A new method for inference of ancestral nucleotide and amino acid sequences. Genetics. 141:1641-1650.
</p>
<p>M. Pagel (1994). Detecting correlated evolution on phylogenies: a general method for the comparative analysis of discrete characters. Proceedings of the Royal Society of London B: Biological Sciences. 255:37-45.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_mk_model">asr_mk_model</a></code>,
<code><a href="#topic+simulate_mk_model">simulate_mk_model</a></code>,
<code><a href="#topic+fit_musse">fit_musse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 1000
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# create random transition matrix
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER", max_rate=0.01)
cat(sprintf("Simulated ER transition rate=%g\n",Q[1,2]))

# simulate the trait's evolution
simulation = simulate_mk_model(tree, Q)
tip_states = simulation$tip_states

# fit Mk transition matrix
results = fit_mk(tree, Nstates, tip_states, rate_model="ER", Ntrials=2)

# print Mk model fitting summary
cat(sprintf("Mk model: log-likelihood=%g\n",results$loglikelihood))
cat(sprintf("Fitted ER transition rate=%g\n",results$transition_matrix[1,2]))

## End(Not run)</code></pre>

<hr>
<h2 id='fit_musse'>
Fit a discrete-state-dependent diversification model via maximum-likelihood.
</h2><span id='topic+fit_musse'></span>

<h3>Description</h3>

<p>The Binary State Speciation and Extinction (BiSSE) model (Maddison et al. 2007) and its extension to Multiple State Speciation Extinction (MuSSE) models (FitzJohn et al. 2009, 2012), Hidden State Speciation Extinction (HiSSE) models (Beaulieu and O'meara, 2016) or Several Examined and Concealed States-dependent Speciation and Extinction (SecSSE) models (van Els et al. 2018), describe a Poissonian cladogenic process whose birth/death (speciation/extinction) rates depend on the states of an evolving discrete trait. Specifically, extant tips either go extinct or split continuously in time at Poissonian rates, and birth/death rates at each extant tip depend on the current state of the tip; lineages tansition stochastically between states acccording to a continuous-time Markov process with fixed transition rates. At the end of the simulation (i.e., at &quot;present-day&quot;), extant lineages are sampled according to some state-dependent probability (&quot;sampling_fraction&quot;), which may depend on proxy state. Optionally, tips may also be sampled continuously over time according to some Poissonian rate (which may depend on proxy state), in which case the resulting tree may not be ultrametric.
</p>
<p>This function takes as main input a phylogenetic tree (ultrametric unless Poissonian sampling is included) and a list of tip proxy states, and fits the parameters of a BiSSE/MuSSE/HiSSE/SecSSE model to the data via maximum-likelihood. Tips can have missing (unknown) proxy states, and the function can account for biases in species sampling and biases in the identification of proxy states. The likelihood is calculated using a mathematically equivalent, but computationally more efficient variant, of the classical postorder-traversal BiSSE/MuSSE/HiSSE/SecSSE algorithm, as described by Louca (2019). This function has been optimized for large phylogenetic trees, with a relatively small number of states (i.e. Nstates&lt;&lt;Ntips); its time complexity scales roughly linearly with Ntips.
</p>
<p>If you use this function for your research please cite Louca and Pennell (2020), DOI:10.1093/sysbio/syz055.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_musse(tree, 
          Nstates,
          NPstates              = NULL,
          proxy_map             = NULL,
          state_names           = NULL,
          tip_pstates           = NULL,
          tip_priors            = NULL,
          sampling_fractions    = 1,
          reveal_fractions      = 1,
          sampling_rates        = 0,
          transition_rate_model	= "ARD",
          birth_rate_model      = "ARD",
          death_rate_model      = "ARD",
          transition_matrix     = NULL,
          birth_rates           = NULL,
          death_rates           = NULL,
          first_guess           = NULL,
          lower                 = NULL,
          upper                 = NULL,
          root_prior            = "auto",
          root_conditioning     = "auto",
          oldest_age            = NULL,
          Ntrials               = 1,
          Nscouts               = NULL,
          optim_algorithm       = "nlminb",
          optim_max_iterations  = 10000,
          optim_max_evaluations = NULL,
          optim_rel_tol         = 1e-6,
          check_input           = TRUE,
          include_ancestral_likelihoods = FALSE,
          Nthreads              = 1,
          Nbootstraps           = 0,
          Ntrials_per_bootstrap = NULL,
          max_condition_number  = 1e4,
          relative_ODE_step     = 0.1,
          E_value_step          = 1e-4,
          D_temporal_resolution = 100,
          max_model_runtime     = NULL,
          verbose               = TRUE,
          diagnostics           = FALSE,
          verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_musse_+3A_tree">tree</code></td>
<td>

<p>Phylogenetic tree of class &quot;phylo&quot;, representing the evolutionary relationships between sampled species/lineages. Unless Poissonian sampling is included in the model (option <code>sampling_rates</code>), this tree should be ultrametric.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_nstates">Nstates</code></td>
<td>

<p>Integer, specifying the number of possible discrete states a tip can have, influencing speciation/extinction rates. For example, if <code>Nstates==2</code> then this corresponds to the common Binary State Speciation and Extinction (BiSSE) model (Maddison et al., 2007). In the case of a HiSSE/SecSSE model, <code>Nstates</code> refers to the total number of diversification rate categories. For example, in the case of the HiSSE model described by Beaulieu and O'meara (2016), <code>Nstates=4</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_npstates">NPstates</code></td>
<td>

<p>Integer, optionally specifying a number of &quot;proxy-states&quot; that are observed instead of the underlying speciation/extinction-modulating states. To fit a HiSSE/SecSSE model, <code>NPstates</code> should be smaller than <code>Nstates</code>. Each state corresponds to a different proxy-state, as defined using the variable <code>proxy_map</code> (see below). For BiSSE/MuSSE with no hidden states, <code>NPstates</code> can be set to either <code>NULL</code> or equal to <code>Nstates</code>; in either case, <code>NPstates</code> will be considered equal to <code>Nstates</code>. For example, in the case of the HiSSE model described by Beaulieu and O'meara (2016), <code>NPstates=2</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_proxy_map">proxy_map</code></td>
<td>

<p>Integer vector of size <code>Nstates</code> and with values in 1,..<code>NPstates</code>, specifying the correspondence between states (i.e. diversification-rate categories) and proxy-states, in a HiSSE/SecSSE model. Specifically, <code>proxy_map[s]</code> indicates which proxy-state the state s is represented by. Each proxy-state can represent multiple states (i.e. proxies are ambiguous), but each state must be represented by exactly one proxy-state. For example, to setup the HiSSE model described by Beaulieu and O'meara (2016), use <code>proxy_map=c(1,2,1,2)</code>. For non-HiSSE models, set this to <code>NULL</code> or to <code>c(1:Nstates)</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_state_names">state_names</code></td>
<td>

<p>Optional character vector of size <code>Nstates</code>, specifying a name/description for each state. This does not influence any of the calculations. It is merely used to add human-readable row/column names (rather than integers) to the returned vectors/matrices. If <code>NULL</code>, no row/column names are added.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_tip_pstates">tip_pstates</code></td>
<td>

<p>Integer vector of size Ntips, listing the proxy state at each tip, in the same order as tips are indexed in the tree. The vector may (but need not) include names; if it does, these are checked for consistency with the tree (if <code>check_input==TRUE</code>). Values must range from 1 to <code>NPstates</code> (which is assumed equal to <code>Nstates</code> in the case of BiSSE/MuSSE). States may also be <code>NA</code>, corresponding to unknown tip proxy states (no information available).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_tip_priors">tip_priors</code></td>
<td>

<p>Numeric matrix of size Ntips x <code>Nstates</code> (or of size Ntips x <code>NPstates</code>), listing prior likelihoods of each state (or each proxy-state) at each tip. Can be provided as an alternative to <code>tip_pstates</code>. Thus, <code>tip_priors[i,s]</code> is the likelihood of observing the data (i.e., sampling tip i and observing the observed state) if the tip <code>i</code> was at state <code>s</code> (or proxy-state <code>s</code>). Hence, <code>tip_priors</code> should account for sampling fractions as well as reveal fractions. Either <code>tip_pstates</code> or <code>tip_priors</code> must be non-NULL, but not both.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_sampling_fractions">sampling_fractions</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, with values between 0 and 1, listing the sampling fractions of extant species depending on proxy-state. That is, <code>sampling_fractions[p]</code> is the probability that an extant species, having proxy state <code>p</code>, is included in the phylogeny at present-day. If all extant species are included in the tree with the same probability (i.e., independent of state), this can also be a single number. If <code>NULL</code> (default), all extant species are assumed to be included in the tree. Irrelevant if <code>tip_priors</code> is provided and valid for all tips.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_reveal_fractions">reveal_fractions</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, with values between 0 and 1, listing the probabilities of proxy-state identification depending on proxy-state. That is, <code>reveal_fractions[p]</code> is the probability that a species with proxy-state <code>p</code> will have a known (&quot;revealed&quot;) state, conditional upon being included in the tree. This can be used to incorporate reveal biases for tips, depending on their proxy state. Can also be <code>NULL</code> or a single number (in which case reveal fractions are assumed to be independent of proxy-state). Note that only the relative values in <code>reveal_fractions</code> matter, for example <code>c(1,2,1)</code> has the same effect as <code>c(0.5,1,0.5)</code>, because <code>reveal_fractions</code> is normalized internally anyway. Irrelevant if <code>tip_priors</code> is provided and valid for all tips.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_sampling_rates">sampling_rates</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, listing Poissonian per-lineage sampling rates over time. Hence, <code>sampling_rates[p]</code> is the rate at which lineages are sampled over time when they are in proxy state <code>p</code>. Can also be a single numeric, in which case sampling rates are the same for all proxy states. If <code>NULL</code>, Poissonian sampling is assumed to not occur. Note that earlier MuSSE/HiSSE models (e.g., by Beaulieu and O'Meara, 2016) do not include Poissonian sampling (i.e., all tips are assumed to have been sampled at present-day). Poissonian sampling through time is common in epidemiological models but uncommon in macroevolution models.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_transition_rate_model">transition_rate_model</code></td>
<td>

<p>Either a character or a 2D integer matrix of size Nstates x Nstates, specifying the model for the transition rates between states. This option controls the parametric complexity of the state transition model, i.e. the number of independent rates and the correspondence between independent and dependent rates. If a character, then it must be one of &quot;ER&quot;, &quot;SYM&quot;, &quot;ARD&quot;, &quot;SUEDE&quot; or &quot;SRD&quot;, as used for Mk models (see the function <code><a href="#topic+asr_mk_model">asr_mk_model</a></code> for details). For example, &quot;ARD&quot; (all rates different) specifies that all transition rates should be considered as independent parameters with potentially different values.
</p>
<p>If an integer matrix, then it defines a custom parametric structure for the transition rates, by mapping entries of the transition matrix to a set of independent transition-rate parameters (numbered 1,2, and so on), similarly to the option <code>rate_model</code> in the function <code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, and as returned for example by the function <code><a href="#topic+get_transition_index_matrix">get_transition_index_matrix</a></code>. Entries must be between 1 and Nstates, however 0 may also be used to denote a fixed value of zero. For example, if <code>transition_rate_model[1,2]=transition_rate_model[2,1]</code>, then the transition rates 1-&gt;2 and 2-&gt;1 are assumed to be equal.
Entries on the diagonal are ignored, since the diagonal elements are always adjusted to ensure a valid Markov transition matrix. To construct a custom matrix with the proper structure, it may be convenient to first generate an &quot;ARD&quot; matrix using <code><a href="#topic+get_transition_index_matrix">get_transition_index_matrix</a></code>, and then modify individual entries to reduce the number of independent rates.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_birth_rate_model">birth_rate_model</code></td>
<td>

<p>Either a character or an integer vector of length Nstates, specifying the model for the various birth (speciation) rates. This option controls the parametric complexity of the possible birth rates, i.e. the number of independent birth rates and the correspondence between independent and dependent birth rates. If a character, then it must be either &quot;ER&quot; (equal rates) or &quot;ARD&quot; (all rates different). If an integer vector, it must map each state to an indepedent birth-rate parameter (indexed 1,2,..). For example, the vector <code>c(1,2,1)</code> specifies that the birth-rates <code class="reqn">\lambda_1</code> and <code class="reqn">\lambda_3</code> must be the same, but <code class="reqn">\lambda_2</code> is independent.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_death_rate_model">death_rate_model</code></td>
<td>

<p>Either a character or an integer vector of length Nstates, specifying the model for the various death (extinction) rates. Similar to <code>birth_rate_model</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_transition_matrix">transition_matrix</code></td>
<td>

<p>Either <code>NULL</code> or a 2D matrix of size Nstates x Nstates, specifying known (and thus fixed) transition rates between states. For example, setting some elements to 0 specifies that these transitions cannot occur directly. May also contain <code>NA</code>, indicating rates that are to be fitted. If <code>NULL</code> or empty, all rates are considered unknown and are therefore fitted. Note that, unless <code>transition_rate_model=="ARD"</code>, values in <code>transition_matrix</code> are assumed to be consistent with the rate model, that is, rates specified to be equal under the transition rate model are expected to also have equal values in <code>transition_matrix</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_birth_rates">birth_rates</code></td>
<td>

<p>Either <code>NULL</code>, or a single number, or a numeric vector of length Nstates, specifying known (and thus fixed) birth rates for each state. May contain <code>NA</code>, indicating rates that are to be fitted. For example, the vector <code>c(5,0,NA)</code> specifies that <code class="reqn">\lambda_1=5</code>, <code class="reqn">\lambda_2=0</code> and that <code class="reqn">\lambda_3</code> is to be fitted. If <code>NULL</code> or empty, all birth rates are considered unknown and are therefore fitted. If a single number, all birth rates are considered fixed at that given value.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_death_rates">death_rates</code></td>
<td>

<p>Either <code>NULL</code>, or a single number, or a numeric vector of length Nstates, specifying known (and thus fixed) death rates for each state. Similar to <code>birth_rates</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_first_guess">first_guess</code></td>
<td>

<p>Either <code>NULL</code>, or a named list containing optional initial suggestions for various model parameters, i.e. start values for fitting. The list can contain any or all of the following elements:
</p>

<ul>
<li><p><code>transition_matrix</code>: A single number or a 2D numeric matrix of size Nstates x Nstates, specifying suggested start values for the transition rates. May contain NA, indicating rates that should be guessed automatically by the function. If a single number, then that value is used as a start value for all transition rates.
</p>
</li>
<li><p><code>birth_rates</code>: A single number or a numeric vector of size Nstates, specifying suggested start values for the birth rates. May contain NA, indicating rates that should be guessed automatically by the function (by fitting a simple birth-death model, see <code><a href="#topic+fit_tree_model">fit_tree_model</a></code>).
</p>
</li>
<li><p><code>death_rates</code>: A single number or a numeric vector of size Nstates, specifying suggested start values for the death rates. May contain NA, indicating rates that should be guessed automatically by the function (by fitting a simple birth-death model, see <code><a href="#topic+fit_tree_model">fit_tree_model</a></code>).
</p>
</li></ul>

<p>Start values are only relevant for fitted (i.e., non-fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_lower">lower</code></td>
<td>

<p>Either <code>NULL</code> or a named list containing optional lower bounds for various model parameters. The list can contain any or all of the elements <code>transition_matrix</code>, <code>birth_rates</code> and <code>death_rates</code>, structured similarly to <code>first_guess</code>. For example, <code>list(transition_matrix=0.1, birth_rates=c(5,NA,NA))</code> specifies that all transition rates between states must be 0.1 or greater, that the birth rate <code class="reqn">\lambda_1</code> must be 5 or greater, and that all other model parameters have unspecified lower bound. For parameters with unspecified lower bounds, zero is used as a lower bound. Lower bounds only apply to fitted (i.e., non-fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_upper">upper</code></td>
<td>

<p>Either <code>NULL</code> or a named list containing optional upper bounds for various model parameters. The list can contain any or all of the elements <code>transition_matrix</code>, <code>birth_rates</code> and <code>death_rates</code>, structured similarly to <code>upper</code>. For example, <code>list(transition_matrix=2, birth_rates=c(10,NA,NA))</code> specifies that all transition rates between states must be 2 or less, that the birth rate <code class="reqn">\lambda_1</code> must be 10 or less, and that all other model parameters have unspecified upper bound. For parameters with unspecified upper bounds, infinity is used as an upper bound. Upper bounds only apply to fitted (i.e., non-fixed) parameters.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_root_prior">root_prior</code></td>
<td>

<p>Either a character or a numeric vector of size Nstates, specifying the prior probabilities of states for the root, i.e. the weights for obtaining a single model likelihood by averaging the root's state likelihoods. If a character, then it must be one of &quot;flat&quot;, &quot;empirical&quot;, &quot;likelihoods&quot;, &quot;max_likelihood&quot; or &quot;auto&quot;. &quot;empirical&quot; means the root's prior is set to the proportions of (estimated) extant species in each state (correcting for sampling fractions and reveal fractions, if applicable). &quot;likelihoods&quot; means that the computed state-likelihoods of the root are used, after normalizing to obtain a probability distribution; this is the approach used in the package <code>hisse::hisse</code> v1.8.9 under the option <code>root.p=NULL</code>, and the approach in the package <code>diversitree::find.mle</code> v0.9-10 under the option <code>root=ROOT.OBS</code>. If &quot;max_likelihood&quot;, then the root's prior is set to a Dirac distribution, with full weight given to the maximum-likelihood state at the root (after applying the conditioning). If a numeric vector, <code>root_prior</code> specifies custom probabilities (weights) for each state. Note that if <code>root_conditioning</code> is &quot;<code>madfitz</code>&quot; or &quot;<code>herr_als</code>&quot; (see below), then the prior is set before the conditioning and not updated afterwards for consistency with other R packages.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_root_conditioning">root_conditioning</code></td>
<td>

<p>Character, specifying an optional modification to be applied to the root's state likelihoods prior to averaging. Can be &quot;none&quot; (no modification), &quot;madfitz&quot;, &quot;herr_als&quot;, &quot;crown&quot; or &quot;stem&quot;. &quot;madfitz&quot; and &quot;herr_als&quot; (after van Els, Etiene and Herrera-Alsina 2018) are the options implemented in the package <code>hisse</code> v1.8.9, conditioning the root's state-likelihoods based on the birth-rates and the computed extinction probability (after or before averaging, respectively). See van Els (2018) for a comparison between &quot;madfitz&quot; and &quot;herr_als&quot;. The option &quot;stem&quot; conditions the state likelihoods on the probability that the stem lineage would survive until the present. The option &quot;crown&quot; conditions the state likelihoods on the probability that a split occurred at <code>oldest_age</code> and that the two child lineages survived until the present; this option is only recommended if <code>oldest_age</code> is equal to the root age.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest age (time before present) to consider for fitting. If this is smaller than the tree's root age, then the tree is split into multiple subtrees at <code>oldest_age</code>, and each subtree is considered as an independent realization of the same diversification/evolution process whose parameters are to be estimated. The <code>root_conditioning</code> and <code>root_prior</code> are applied separately to each subtree, prior to calculating the joint (product) likelihood of all subtrees. This option can be used to restrict the fitting to a small (recent) time interval, during which the MuSSE/BiSSE assumptions (e.g., time-independent speciation/extinction/transition rates) are more likely to hold. If <code>oldest_age</code> is <code>NULL</code>, it is automatically set to the root age. In principle <code>oldest_age</code> may also be older than the root age.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_ntrials">Ntrials</code></td>
<td>

<p>Non-negative integer, specifying the number of trials for fitting the model, using alternative (randomized) starting parameters at each trial. A larger <code>Ntrials</code> reduces the risk of landing on a local non-global optimum of the likelihood function, and thus increases the chances of finding the truly best fit. If 0, then no fitting is performed, and only the first-guess (i.e., provided or guessed start params) is evaluated and returned. Hence, setting <code>Ntrials=0</code> can be used to obtain a reasonable set of start parameters for subsequent fitting or for Markov Chain Monte Carlo.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_nscouts">Nscouts</code></td>
<td>

<p>Optional positive integer, number of randomly chosen starting points to consider for all fitting trials except the first one. Among all &quot;scouted&quot; starting points, the <code>Ntrials-1</code> most promising ones will be considered. A greater number of scouts increases the chances of finding a global likelihood maximum. Each scout costs only one evaluation of the loglikelihood function. If <code>NULL</code>, <code>Nscout</code> is automatically chosen based on the number of fitted parameters and <code>Ntrials</code>. Only relevant if <code>Ntrials&gt;1</code>, since the first trial always uses the default or provided parameter guess.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_optim_algorithm">optim_algorithm</code></td>
<td>

<p>Character, specifying the optimization algorithm for fitting. Must be one of either &quot;optim&quot;, &quot;nlminb&quot; or &quot;subplex&quot; (requires the <code>nloptr</code> package).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_optim_max_iterations">optim_max_iterations</code></td>
<td>

<p>Integer, maximum number of iterations allowed for fitting. Only relevant for &quot;optim&quot; and &quot;nlminb&quot;.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_optim_max_evaluations">optim_max_evaluations</code></td>
<td>

<p>Integer, maximum number of function evaluations allowed for fitting. Only relevant for &quot;nlminb&quot; and &quot;subplex&quot; (requires the <code>nloptr</code> package).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_optim_rel_tol">optim_rel_tol</code></td>
<td>

<p>Numeric, relative tolerance for the fitted log-likelihood.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to check the validity of input variables. If you are certain that all input variables are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_include_ancestral_likelihoods">include_ancestral_likelihoods</code></td>
<td>

<p>Logical, specifying whether to include the state likelihoods for each node, in the returned variables. These are the &ldquo;D&rdquo; variables calculated as part of the likelihood based on the subtree descending from each node, and may be used for &quot;local&quot; ancestral state reconstructions.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of threads for running multiple fitting trials in parallel. Only relevant if <code>Ntrials&gt;1</code>. Should generally not exceed the number of CPU cores on a machine. Must be a least 1.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying an optional number of bootstrap samplings to perform, for estimating standard errors and confidence intervals of maximum-likelihood fitted parameters. If 0, no bootstrapping is performed. Typical values are 10-100. At each bootstrap sampling, a simulation of the fitted MuSSE/HiSSE model is performed, the parameters are estimated anew based on the simulation, and subsequently compared to the original fitted parameters. Each bootstrap sampling will thus use roughly as many computational resources as the original maximum-likelihood fit (e.g., same number of trials, same optimization parameters etc).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_max_condition_number">max_condition_number</code></td>
<td>

<p>Positive unitless number, specifying the maximum permissible condition number for the &quot;G&quot; matrix computed for the log-likelihood. A higher condition number leads to faster computation (roughly on a log-scale) especially for large trees, at the potential expense of lower accuracy. Typical values are 1e2-1e5. See Louca (2019) for further details on the condition number of the G matrix.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_relative_ode_step">relative_ODE_step</code></td>
<td>

<p>Positive unitless number, specifying the default relative time step for the ordinary differential equation solvers.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_e_value_step">E_value_step</code></td>
<td>

<p>Positive unitless number, specifying the relative difference between subsequent recorded and interpolated E-values, in the ODE solver for the extinction probabilities E (Louca 2019). Typical values are 1e-2 to 1e-5. A smaller <code>E_value_step</code> increases interpolation accuracy, but also increases memory requirements and adds runtime (scaling with the tree's age span, not Ntips).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_d_temporal_resolution">D_temporal_resolution</code></td>
<td>

<p>Positive unitless number, specifying the relative resolution for interpolating G-map over time (Louca 2019). This is relative to the typical time scales at which G-map varies. For example, a resolution of 10 means that within a typical time scale there will be 10 interpolation points. Typical values are 1-1000. A greater resolution increases interpolation accuracy, but also increases memory requirements and adds runtime (scaling with the tree's age span, not Ntips).
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Numeric, optional maximum number of seconds for evaluating the likelihood of a model, prior to cancelling the calculation and returning Inf. This may be useful if extreme model parameters (e.g., reached transiently during fitting) require excessive calculation time. Parameters for which the calculation of the likelihood exceed this threshold, will be considered invalid and thus avoided during fitting. For example, for trees with 1000 tips a time limit of 10 seconds may be reasonable.
If 0, no time limit is imposed.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. In any case, fatal errors are always reported.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Logical, specifying whether to print detailed information (such as model likelihoods) at every iteration of the fitting routine. For debugging purposes mainly.
</p>
</td></tr>
<tr><td><code id="fit_musse_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports, warnings and errors to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HiSSE/SecSSE models include two discrete traits, one trait that defines the rate categories of diversification rates (as in BiSSE/MuSSE), and one trait that does not itself influence diversification but whose states (here called &quot;proxy states&quot;) each represent one or more of the diversity-modulating states. HiSSE models (Beaulieu and O'meara, 2016) and SecSSE models (van Els et al., 2018) are closely related to BiSSE/MuSSE models, the main difference being the fact that the actual diversification-modulating states are not directly observed. In essence, a HiSSE/SecSSE model is a BiSSE/MuSSE model, where the final tip states are replaced by their proxy states, thus &quot;masking&quot; the underlying diversity-modulating trait. This function is able to fit HiSSE/SecSSE models with appropriate choice of the input variables <code>Nstates</code>, <code>NPstates</code> and <code>proxy_map</code>.
Note that the terminology and setup of HiSSE/SecSSE models followed here differs from their description in the original papers by Beaulieu and O'meara (2016) and van Els et al. (2018), in order to achieve what we think is a more intuitive unification of BiSSE/MuSSE/HiSSE/SecSSE. For ease of terminology, when considering a BiSSE/MuSSE model, here we use the terms &quot;states&quot; and &quot;proxy-states&quot; interchangeably, since under BiSSE/MuSSE the proxy trait can be considered identical to the diversification-modulating trait. A distinction between &quot;states&quot; and &quot;proxy-states&quot; is only relevant for HiSSE/SecSSE models.
</p>
<p>As an example of a HiSSE model, <code>Nstates=4</code>, <code>NPstates=2</code> and <code>proxy_map=c(1,2,1,2)</code> specifies that states 1 and 3 are represented by proxy-state 1, and states 2 and 4 are represented by proxy-state 2. This is the original case described by Beaulieu and O'Meara (2016); in their terminology, there would be 2 &quot;hidden&quot;&quot; states (&quot;0&quot; and &quot;1&quot;) and 2 &quot;observed&quot; states (&quot;A&quot; and &quot;B&quot;), and the 4 diversification rate categories (<code>Nstates=4</code>) would be called &quot;0A&quot;, &quot;1A&quot;, &quot;0B&quot; and &quot;1B&quot;. The somewhat different terminology used here allows for easier generalization to an arbitrary number of diversification-modulating states and an arbitrary number of proxy states. For example, if there are 6 diversification modulating states, represented by 3 proxy-states as 1-&gt;A, 2-&gt;A, 3-&gt;B, 4-&gt;C, 5-&gt;C, 6-&gt;C, then one would set <code>Nstates=6</code>, <code>NPstates=3</code> and <code>proxy_map=c(1,1,2,3,3,3)</code>.
</p>
<p>The run time of this function scales asymptotically linearly with tree size (Ntips), although run times can vary substantially depending on model parameters. As a rule of thumb, the higher the birth/death/transition rates are compared to the tree's overall time span, the slower the calculation becomes.
</p>
<p>The following arguments control the tradeoff between accuracy and computational efficiency:
</p>

<ul>
<li><p><code>max_condition_number</code>: A smaller value means greater accuracy, at longer runtime and more memory.
</p>
</li>
<li><p><code>relative_ODE_step</code>: A smaller value means greater accuracy, at longer runtime.
</p>
</li>
<li><p><code>E_value_step</code>: A smaller value means greater accuracy, at longer runtime and more memory.
</p>
</li>
<li><p><code>D_temporal_resolution</code>: A greater value means greater accuracy, at longer runtime and more memory.
</p>
</li></ul>

<p>Typically, the default values for these arguments should be fine. For smaller trees, where cladogenic and sampling stochasticity is the main source of uncertainty, these parameters can probably be made less stringent (i.e., leading to lower accuracy and faster computation), but then again for small trees computational efficiency may not be an issue anyway.
</p>
<p>Note that the old option <code>max_start_attempts</code> has been removed. Consider using <code>Nscouts</code> instead.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, an additional element <code>error</code> (of type character) is included containing an explanation of the error; in that case the value of any of the other elements is undetermined.
</p>
</td></tr>
<tr><td><code>Nstates</code></td>
<td>

<p>Integer, the number of states assumed for the model.
</p>
</td></tr>
<tr><td><code>NPstates</code></td>
<td>

<p>Integer, the number of proxy states assumed for the model. Note that in the case of a BiSSE/MuSSE model, this will be the same as <code>Nstates</code>.
</p>
</td></tr>
<tr><td><code>root_prior</code></td>
<td>

<p>Character, or numeric vector of length Nstates, specifying the root prior used.
</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>

<p>Named list containing the final maximum-likelihood fitted model parameters. If <code>Ntrials&gt;1</code>, then this contains the fitted parameters yielding the highest likelihood. Will contain the following elements:
</p>

<ul>
<li><p><code>transition_matrix</code>: 2D numeric matrix of size Nstates x Nstates, listing the fitted transition rates between states.
</p>
</li>
<li><p><code>birth_rates</code>: Numeric vector of length Nstates, listing the fitted state-dependent birth rates.
</p>
</li>
<li><p><code>death_rates</code>: Numeric vector of length Nstates, listing the fitted state-dependent death rates.
</p>
</li></ul>

</td></tr>
<tr><td><code>start_parameters</code></td>
<td>

<p>Named list containing the default start parameter values for the fitting. Structured similarly to <code>parameters</code>. Note that if <code>Ntrials&gt;1</code>, only the first trial will have used these start values, all other trials will have used randomized start values. Will be defined even if <code>Ntrials==0</code>, and can thus be used to obtain a reasonable guess for the start parameters without actually fitting the model.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Numeric, the maximized log-likelihood of the model, if fitting succeeded.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>Numeric, the Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>The number of iterations needed for the best fit. Only relevant if the optimization method was &quot;optim&quot; or &quot;nlminb&quot;.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, the number of function evaluations needed for the best fit. Only relevant if the optimization method was &quot;nlminb&quot; or &quot;subplex&quot;.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, indicating whether convergence was successful during fitting. If convergence was not achieved, and the fitting was stopped due to one of the stopping criteria <code>optim_max_iterations</code> or <code>optim_max_evaluations</code>, the final likelihood will still be returned, but the fitted parameters may not be reasonable.
</p>
</td></tr>
<tr><td><code>warnings</code></td>
<td>

<p>Character vector, listing any warnings encountered during evaluation of the likelihood function at the fitted parameter values. For example, this vector may contain warnings regarding the differential equation solvers or regarding the rank of the G-matrix (Louca, 2019).
</p>
</td></tr>
<tr><td><code>subroots</code></td>
<td>

<p>Integer vector, listing indices of tips/nodes in the tree that were considered as starting points of independent MuSSE processes. If <code>oldest_age</code> was equal to or greater than the root age, then <code>subroots</code> will simply list the tree's root.
</p>
</td></tr>
<tr><td><code>ML_subroot_states</code></td>
<td>

<p>Integer vector, with values between 1 and Nstates, giving the maximum-likelihood estimate of each subroot's state.
</p>
</td></tr>
<tr><td><code>ML_substem_states</code></td>
<td>

<p>Integer vector, with values between 1 and Nstates, giving the maximum-likelihood estimate of the state at each subroot's stem (i.e., exactly at <code>oldest_age</code>).
</p>
</td></tr>
<tr><td><code>trial_start_loglikelihoods</code></td>
<td>

<p>Numeric vector of length <code>Ntrials</code>, listing the initial loglikelihoods (i.e., at the starting parameter values) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_loglikelihoods</code></td>
<td>

<p>Numeric vector of length <code>Ntrials</code>, listing the maximized loglikelihoods for each fitting trial. These may be used for diagnosing the robustness of maximum-likelihood estimates and the assessing the needed for increasing <code>Ntrials</code>.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of length <code>Ntrials</code>, listing the number of iterations of each trial. Depending on the fitting algorithm used (option <code>optim_algorithm</code>), these may be <code>NA</code> (not available).
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of length <code>Ntrials</code>, listing the number of likelihood evaluations of each trial. Depending on the fitting algorithm used (option <code>optim_algorithm</code>), these may be <code>NA</code> (not available).
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Named list containing the elements &quot;transition_matrix&quot; (numeric matrix of size Nstates x Nstates), &quot;birth_rates&quot; (numeric vector of size Nstates) and &quot;death_rates&quot; (numeric vector of size Nstates), listing standard errors of all model parameters estimated using parametric bootstrapping. Only included if <code>Nbootstraps&gt;0</code>. Note that the standard errors of non-fitted (i.e., fixed) parameters will be zero.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Named list containing the elements &quot;transition_matrix&quot; (numeric matrix of size Nstates x Nstates), &quot;birth_rates&quot; (numeric vector of size Nstates) and &quot;death_rates&quot; (numeric vector of size Nstates), listing the lower end of the 50% confidence interval (i.e. the 25% quantile) for each model parameter, estimated using parametric bootstrapping. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Similar to <code>CI50lower</code>, but listing the upper end of the 50% confidence interval (i.e. the 75% quantile) for each model parameter. For example, the confidence interval for he birth-rate <code class="reqn">\lambda_1</code> will be between <code>CI50lower$birth_rates[1]</code> and <code>CI50upper$birth_rates[1]</code>. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Similar to <code>CI50lower</code>, but listing the lower end of the 95% confidence interval (i.e. the 2.5% quantile) for each model parameter. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Similar to <code>CI50upper</code>, but listing the upper end of the 95% confidence interval (i.e. the 97.5% quantile) for each model parameter. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>

<p>2D numeric matrix, listing maximum-likelihood estimates, standard errors and confidence intervals for all model parameters (one row per parameter, one column for ML-estimates, one column for standard errors, two columns per confidence interval). Standard errors and confidence intervals are as estimated using parametric bootstrapping. This matrix contains the same information as <code>parameters</code>, <code>standard_errors</code>, <code>CI50lower</code>, <code>CI50upper</code>, <code>CI95lower</code> and <code>CI95upper</code>, but in a more compact format. Only included if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>ancestral_likelihoods</code></td>
<td>

<p>2D matrix of size Nnodes x Nstates, listing the computed state-likelihoods for each node in the tree. These may be used for &quot;local&quot; ancestral state reconstructions, based on the information contained in the subtree descending from each node. Note that for each node the ancestral likelihoods have been normalized for numerical reasons, however they should not be interpreted as actual probabilities. For each node n and state s, <code>ancestral_likelihoods[n,s]</code> is proportional to the likelihood of observing the descending subtree and associated tip proxy states, if node n was at state s.
Only included if <code>include_ancestral_likelihoods==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>W. P. Maddison, P. E. Midford, S. P. Otto (2007). Estimating a binary character's effect on speciation and extinction. Systematic Biology. 56:701-710.
</p>
<p>R. G. FitzJohn, W. P. Maddison, S. P. Otto (2009). Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology. 58:595-611
</p>
<p>R. G. FitzJohn (2012). Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution. 3:1084-1092
</p>
<p>J. M. Beaulieu and B. C. O'Meara (2016). Detecting hidden diversification shifts in models of trait-dependent speciation and extinction. Systematic Biology. 65:583-601.
</p>
<p>D. Kuehnert, T. Stadler, T. G. Vaughan, A. J. Drummond (2016). Phylodynamics with migration: A computational framework to quantify population structure from genomic data. Molecular Biology and Evolution. 33:2102-2116.
</p>
<p>P. van Els, R. S. Etiene, L. Herrera-Alsina (2018). Detecting the dependence of diversification on multiple traits from phylogenetic trees and trait data. Systematic Biology. syy057.
</p>
<p>S. Louca and M. W. Pennell (2020). A general and efficient algorithm for the likelihood of diversification and discrete-trait evolutionary models. Systematic Biology. 69:545-556. DOI:10.1093/sysbio/syz055
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_dsse">simulate_dsse</a></code>,
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>,
<code><a href="#topic+fit_tree_model">fit_tree_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: BiSSE model
# - - - - - - - - - - - - - -
# Choose random BiSSE model parameters
Nstates = 2
Q = get_random_mk_transition_matrix(Nstates, rate_model="ARD", max_rate=0.1)
parameters = list(birth_rates       = runif(Nstates,5,10),
                  death_rates       = runif(Nstates,0,5),
                  transition_matrix = Q)
rarefaction = 0.5 # randomly omit half of the tips

# Simulate a tree under the BiSSE model
simulation = simulate_musse(Nstates, 
                            parameters         = parameters, 
                            max_tips           = 1000,
                            sampling_fractions = rarefaction)
tree       = simulation$tree
tip_states = simulation$tip_states

## Not run: 
# fit BiSSE model to tree &amp; tip data
fit = fit_musse(tree,
                Nstates            = Nstates,
                tip_pstates        = tip_states,
                sampling_fractions = rarefaction)
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed"))
}else{
  # compare fitted birth rates to true values
  errors = (fit$parameters$birth_rates - parameters$birth_rates)
  relative_errors = errors/parameters$birth_rates
  cat(sprintf("BiSSE relative birth-rate errors:\n"))
  print(relative_errors)
}

## End(Not run)


# EXAMPLE 2: HiSSE model, with bootstrapping
# - - - - - - - - - - - - - -
# Choose random HiSSE model parameters
Nstates  = 4
NPstates = 2
Q = get_random_mk_transition_matrix(Nstates, rate_model="ARD", max_rate=0.1)
rarefaction = 0.5 # randomly omit half of the tips
parameters = list(birth_rates       = runif(Nstates,5,10),
                  death_rates       = runif(Nstates,0,5),
                  transition_matrix = Q)
                  
# reveal the state of 30% &amp; 60% of tips (in state 1 &amp; 2, respectively)
reveal_fractions = c(0.3,0.6)

# use proxy map corresponding to Beaulieu and O'Meara (2016)
proxy_map = c(1,2,1,2)

# Simulate a tree under the HiSSE model
simulation = simulate_musse(Nstates, 
                            NPstates            = NPstates,
                            proxy_map           = proxy_map,
                            parameters          = parameters, 
                            max_tips            = 1000,
                            sampling_fractions  = rarefaction,
                            reveal_fractions    = reveal_fractions)
tree       = simulation$tree
tip_states = simulation$tip_proxy_states

## Not run: 
# fit HiSSE model to tree &amp; tip data
# run multiple trials to ensure global optimum
# also estimate confidence intervals via bootstrapping
fit = fit_musse(tree,
                Nstates            = Nstates,
                NPstates           = NPstates,
                proxy_map          = proxy_map,
                tip_pstates        = tip_states,
                sampling_fractions = rarefaction,
                reveal_fractions   = reveal_fractions,
                Ntrials            = 5,
                Nbootstraps        = 10,
                max_model_runtime  = 0.1)
if(!fit$success){
  cat(sprintf("ERROR: Fitting failed"))
}else{
  # compare fitted birth rates to true values
  errors = (fit$parameters$birth_rates - parameters$birth_rates)
  relative_errors = errors/parameters$birth_rates
  cat(sprintf("HiSSE relative birth-rate errors:\n"))
  print(relative_errors)
  
  # print 95%-confidence interval for first birth rate
  cat(sprintf("CI95 for lambda1: %g-%g",
              fit$CI95lower$birth_rates[1],
              fit$CI95upper$birth_rates[1]))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_sbm_const'>
Fit a phylogeographic Spherical Brownian Motion model.
</h2><span id='topic+fit_sbm_const'></span>

<h3>Description</h3>

<p>Given one or more rooted phylogenetic trees and geographic coordinates (latitudes &amp; longitudes) for the tips of each tree, this function estimates the diffusivity of a Spherical Brownian Motion (SBM) model for the evolution of geographic location along lineages (Perrin 1928; Brillinger 2012). Estimation is done via maximum-likelihood and using independent contrasts between sister lineages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sbm_const(trees, 
        tip_latitudes, 
        tip_longitudes, 
        radius,
        phylodistance_matrixes  = NULL,
        clade_states            = NULL,
        planar_approximation    = FALSE,
        only_basal_tip_pairs    = FALSE,
        only_distant_tip_pairs  = FALSE,
        min_MRCA_time           = 0,
        max_MRCA_age            = Inf,
        max_phylodistance       = Inf,
        no_state_transitions    = FALSE,
        only_state              = NULL,
        min_diffusivity         = NULL,
        max_diffusivity         = NULL,
        Nbootstraps             = 0, 
        NQQ                     = 0,
        SBM_PD_functor          = NULL,
        focal_diffusivities     = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sbm_const_+3A_trees">trees</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;. The root of each tree is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance. When multiple trees are provided, it is either assumed that their roots coincide in time (if <code>align_trees_at_root=TRUE</code>) or that each tree's youngest tip was sampled at present day (if <code>align_trees_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, or a list of vectors, listing latitudes of tips in decimal degrees (from -90 to 90). If <code>trees</code> is a list of trees, then <code>tip_latitudes</code> should be a list of vectors of the same length as <code>trees</code>, listing tip latitudes for each of the input trees.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, or a list of vectors, listing longitudes of tips in decimal degrees (from -180 to 180). If <code>trees</code> is a list of trees, then <code>tip_longitudes</code> should be a list of vectors of the same length as <code>trees</code>, listing tip longitudes for each of the input trees.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_phylodistance_matrixes">phylodistance_matrixes</code></td>
<td>

<p>Numeric matrix, or a list of numeric matrixes, listing phylogenetic distances between tips for each tree. If <code>trees</code> is a list of trees, then <code>phylodistance_matrixes</code> should be a list of the same length as <code>trees</code>, whose n-th element should be a numeric matrix comprising as many rows and columns as there are tips in the n-th tree; the entry <code>phylodistance_matrixes[[n]][i,j]</code> is the phylogenetic distance between tips i and j in tree n. If <code>trees</code> is a single tree, then <code>phylodistance_matrixes</code> can be a single numeric matrix. If <code>NULL</code> (default), phylogenetic distances between tips are calculated based on the provided trees, otherwise phylogenetic distances are taken from <code>phylodistance_matrixes</code>; in the latter case the trees are only used for the topology (determining tip pairs for independent contrasts), but not for calculating phylogenetic distances.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_clade_states">clade_states</code></td>
<td>

<p>Either NULL, or an integer vector of length Ntips+Nnodes, or a list of integer vectors, listing discrete states of every tip and node in the tree. If <code>trees</code> is a list of trees, then <code>clade_states</code> should be a list of vectors of the same length as <code>trees</code>, listing tip and node states for each of the input trees. For example, <code>clade_states[[2]][10]</code> specifies the state of the 10-th tip or node in the 2nd tree.
States may be, for example, geographic regions, sub-types, discrete traits etc, and can be used to restrict independent contrasts to tip pairs within the same state (see option <code>no_state_transitions</code>). 
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_planar_approximation">planar_approximation</code></td>
<td>

<p>Logical, specifying whether to estimate the diffusivity based on a planar approximation of the SBM model, i.e. by assuming that geographic distances between tips are as if tips are distributed on a 2D cartesian plane. This approximation is only accurate if geographical distances between tips are small compared to the sphere's radius.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time&lt;=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_no_state_transitions">no_state_transitions</code></td>
<td>

<p>Logical, specifying whether to omit independent contrasts between tips whose shortest connecting paths include state transitions. If <code>TRUE</code>, only tips within the same state and with no transitions between them (as specified in <code>clade_states</code>) are compared. If <code>TRUE</code>, then <code>clade_states</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_only_state">only_state</code></td>
<td>

<p>Optional integer, specifying the state in which tip pairs (and their connecting ancestral nodes) must be in order to be considered. If specified, then <code>clade_states</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_min_diffusivity">min_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the minimum possible diffusivity. If NULL, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_max_diffusivity">max_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the maximum possible diffusivity. If NULL, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Non-negative integer, specifying an optional number of parametric bootstraps to performs for estimating standard errors and confidence intervals.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_nqq">NQQ</code></td>
<td>

<p>Integer, optional number of simulations to perform for creating QQ plots of the theoretically expected distribution of geodistances vs. the empirical distribution of geodistances (across independent contrasts). The resolution of the returned QQ plot will be equal to the number of independent contrasts used for fitting. If &lt;=0, no QQ plots will be calculated.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes, and should be kept at its default value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_const_+3A_focal_diffusivities">focal_diffusivities</code></td>
<td>

<p>Optional numeric vector, listing diffusivities of particular interest and for which the log-likelihoods should be returned. This may be used e.g. for diagnostic purposes, e.g. to see how &quot;sharp&quot; the likelihood peak is at the maximum-likelihood estimate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For short expected transition distances this function uses the approximation formula by Ghosh et al. (2012). For longer expected transition distances the function uses a truncated approximation of the series representation of SBM transition densities (Perrin 1928). It is assumed that tips are sampled randomly without any biases for certain geographic regions. If you suspect strong geographic sampling biases, consider using the function <code><a href="#topic+fit_sbm_geobiased_const">fit_sbm_geobiased_const</a></code>.
</p>
<p>This function can use multiple trees to fit the diffusivity under the assumption that each tree is an independent realization of the same SBM process, i.e. all lineages in all trees dispersed with the same diffusivity.
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>diffusivity</code></td>
<td>

<p>Numeric, the estimated diffusivity, in units distance^2/time. Distance units are the same as used for the <code>radius</code>, and time units are the same as the tree's edge lengths. For example, if the <code>radius</code> was specified in km and edge lengths are in Myr, then the estimated diffusivity will be in km^2/Myr.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Numeric, the log-likelihood of the data at the estimated diffusivity.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts (i.e., tip pairs) used to estimate the diffusivity. This is the number of independent data points used.
</p>
</td></tr>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of length <code>Ncontrasts</code>, listing the phylogenetic distances of the independent contrasts used in the fitting.
</p>
</td></tr>
<tr><td><code>geodistances</code></td>
<td>

<p>Numeric vector of length <code>Ncontrasts</code>, listing the geographical distances of the independent contrasts used in the fitting.
</p>
</td></tr>
<tr><td><code>focal_loglikelihoods</code></td>
<td>

<p>Numeric vector of the same length as <code>focal_diffusivities</code>, listing the log-likelihoods for the diffusivities provided in <code>focal_diffusivities</code>.
</p>
</td></tr>
<tr><td><code>standard_error</code></td>
<td>

<p>Numeric, estimated standard error of the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric, lower bound of the 50% confidence interval for the estimated diffusivity (25-75% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric, upper bound of the 50% confidence interval for the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric, lower bound of the 95% confidence interval for the estimated diffusivity (2.5-97.5% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric, upper bound of the 95% confidence interval for the estimated diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. If <code class="reqn">L</code> denotes the loglikelihood of new data generated by the fitted model (under the same model) and <code class="reqn">M</code> denotes the expectation of <code class="reqn">L</code>, then <code>consistency</code> is the probability that <code class="reqn">|L-M|</code> will be greater or equal to <code class="reqn">|X-M|</code>, where <code class="reqn">X</code> is the loglikelihood of the original data under the fitted model.
Only returned if <code>Nbootstraps&gt;0</code>. A low consistency (e.g., &lt;0.05) indicates that the fitted model is a poor description of the data. See Lindholm et al. (2019) for background.
</p>
</td></tr>
<tr><td><code>QQplot</code></td>
<td>

<p>Numeric matrix of size Ncontrasts x 2, listing the computed QQ-plot. The first column lists quantiles of geodistances in the original dataset, the 2nd column lists quantiles of hypothetical geodistances simulated based on the fitted model.
</p>
</td></tr>
<tr><td><code>SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>A. Lindholm, D. Zachariah, P. Stoica, T. B. Schoen (2019). Data consistency approach to model validation. IEEE Access. 7:59788-59796.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_sbm_geobiased_const">fit_sbm_geobiased_const</a></code>,
<code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>,
<code><a href="#topic+fit_sbm_linear">fit_sbm_linear</a></code>,
<code><a href="#topic+fit_sbm_on_grid">fit_sbm_on_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=500)$tree

# simulate SBM on the tree
D = 1e4
simulation = simulate_sbm(tree, radius=6371, diffusivity=D)

# fit SBM on the tree
fit = fit_sbm_const(tree,simulation$tip_latitudes,simulation$tip_longitudes,radius=6371)
cat(sprintf('True D=%g, fitted D=%g\n',D,fit$diffusivity))

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_sbm_geobiased_const'>
Fit a phylogeographic Spherical Brownian Motion model with geographic sampling bias.
</h2><span id='topic+fit_sbm_geobiased_const'></span>

<h3>Description</h3>

<p>Given one or more rooted phylogenetic trees and geographic coordinates (latitudes &amp; longitudes) for the tips of each tree, this function estimates the diffusivity of a Spherical Brownian Motion (SBM) model for the evolution of geographic location along lineages (Perrin 1928; Brillinger 2012), while correcting for geographic sampling biases. Estimation is done via maximum-likelihood and using independent contrasts between sister lineages, while correction for geographic sampling bias is done through an iterative simulation+fitting process until convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sbm_geobiased_const(trees,
                        tip_latitudes,
                        tip_longitudes,
                        radius,
                        reference_latitudes    = NULL,
                        reference_longitudes   = NULL,
                        only_basal_tip_pairs   = FALSE,
                        only_distant_tip_pairs = FALSE,
                        min_MRCA_time          = 0,
                        max_MRCA_age           = Inf,
                        max_phylodistance      = Inf,
                        min_diffusivity        = NULL,
                        max_diffusivity        = NULL,
                        rarefaction            = 0.1,
                        Nsims                  = 100,
                        max_iterations         = 100,
                        Nbootstraps            = 0,
                        NQQ                    = 0,
                        Nthreads               = 1,
                        include_simulations    = FALSE,
                        SBM_PD_functor         = NULL,
                        verbose                = FALSE,
                        verbose_prefix         = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sbm_geobiased_const_+3A_trees">trees</code></td>
<td>

<p>Either a single rooted tree or a list of rooted trees, of class &quot;phylo&quot;. The root of each tree is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance. When multiple trees are provided, it is either assumed that their roots coincide in time (if <code>align_trees_at_root=TRUE</code>) or that each tree's youngest tip was sampled at present day (if <code>align_trees_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, or a list of vectors, listing latitudes of tips in decimal degrees (from -90 to 90). If <code>trees</code> is a list of trees, then <code>tip_latitudes</code> should be a list of vectors of the same length as <code>trees</code>, listing tip latitudes for each of the input trees.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, or a list of vectors, listing longitudes of tips in decimal degrees (from -180 to 180). If <code>trees</code> is a list of trees, then <code>tip_longitudes</code> should be a list of vectors of the same length as <code>trees</code>, listing tip longitudes for each of the input trees.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_reference_latitudes">reference_latitudes</code></td>
<td>

<p>Optional numeric vector, listing latitudes of reference coordinates based on which to calculate the geographic sampling density. If <code>NULL</code>, the geographic sampling density is estimated based on <code>tip_latitudes</code> and <code>tip_longitudes</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_reference_longitudes">reference_longitudes</code></td>
<td>

<p>Optional numeric vector of the same length as <code>reference_latitudes</code>, listing latitudes of reference coordinates based on which to calculate the geographic sampling density. If <code>NULL</code>, the geographic sampling density is estimated based on <code>tip_latitudes</code> and <code>tip_longitudes</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time&lt;=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_min_diffusivity">min_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the minimum possible diffusivity. If <code>NULL</code>, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_max_diffusivity">max_diffusivity</code></td>
<td>

<p>Non-negative numeric, specifying the maximum possible diffusivity. If <code>NULL</code>, this is automatically chosen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_rarefaction">rarefaction</code></td>
<td>

<p>Numeric, between 00 and 1, specifying the fraction of extant lineages to sample from the simulated trees. Should be strictly smaller than 1, in order for geographic bias correction to have an effect. Note that regardless of <code>rarefaction</code>, the simulated trees will have the same size as the original trees.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_nsims">Nsims</code></td>
<td>

<p>Integer, number of SBM simulatons to perform per iteration for assessing the effects of geographic bias. Smaller trees require larger <code>Nsims</code> (due to higher stochasticity). This must be at least 2, although values of 100-1000 are recommended.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_max_iterations">max_iterations</code></td>
<td>

<p>Integer, maximum number of iterations (correction steps) to perform before giving up.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Non-negative integer, specifying an optional number of parametric bootstraps to performs for estimating standard errors and confidence intervals.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_nqq">NQQ</code></td>
<td>

<p>Integer, optional number of simulations to perform for creating QQ plots of the theoretically expected distribution of geodistances vs. the empirical distribution of geodistances (across independent contrasts). The resolution of the returned QQ plot will be equal to the number of independent contrasts used for fitting. If &lt;=0, no QQ plots will be calculated.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, number of parallel threads to use. Ignored on Windows machines.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_include_simulations">include_simulations</code></td>
<td>

<p>Logical, whether to include the trees and tip coordinates simulated under the final fitted SBM model, in the returned results. May be useful e.g. for checking model adequacy.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes, and should be kept at its default value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_geobiased_const_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to estimate the true spherical diffusivity of an SBM model of geographic diffusive dispersal, while correcting for geographic sampling biases. This is done using an iterative refinement approach, by which trees and tip locations are repeatedly simulated under the current true diffusivity estimate and the diffusivity estimated from those simulated data are compared to the originally uncorrected diffusivity estimate. Trees are simulated according to a birth-death model with constant rates, fitted to the original input trees (a congruent birth-death model is chosen to match the requested <code>rarefaction</code>). Simulated trees are subsampled (rarefied) to match the original input tree sizes, with sampled lineages chosen randomly but in a geographically biased way that resembles the original geographic sampling density (e.g., as inferred from the <code>reference_latitudes</code> and <code>reference_longitudes</code>). Internally, this function repeatedly applies <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> and <code><a href="#topic+simulate_sbm">simulate_sbm</a></code>. If the true sampling fraction of the input trees is unknown, then it is advised to perform the analysis with a few alternative <code>rarefaction</code> values (e.g., 0.01 and 0.1) to verify the robustness of the estimates.
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>Nlat</code></td>
<td>

<p>Integer, number of latitude-tiles used for building a map of the geographic sampling biases.
</p>
</td></tr>
<tr><td><code>Nlon</code></td>
<td>

<p>Integer, number of longitude-tiles used for building a map of the geographic sampling biases.
</p>
</td></tr>
<tr><td><code>diffusivity</code></td>
<td>

<p>Numeric, the estimated true diffusivity, i.e. accounting for geographic sampling biases, in units distance^2/time. Distance units are the same as used for the <code>radius</code>, and time units are the same as the tree's edge lengths. For example, if the <code>radius</code> was specified in km and edge lengths are in Myr, then the estimated diffusivity will be in km^2/Myr.
</p>
</td></tr>
<tr><td><code>correction_factor</code></td>
<td>

<p>Numeric, estimated ratio between the true diffusivity and the original (uncorrected) diffusivity estimate.
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, the number of iterations performed until convergence.
</p>
</td></tr>
<tr><td><code>stopping_criterion</code></td>
<td>

<p>Character, a short description of the criterion by which the iteration was eventually halted.
</p>
</td></tr>
<tr><td><code>uncorrected_fit_diffusivity</code></td>
<td>

<p>Numeric, the originally estimated (uncorrected) diffusivity.
</p>
</td></tr>
<tr><td><code>last_sim_fit_diffusivity</code></td>
<td>

<p>Numeric, the mean uncorrected diffuvity estimated from the simulated data in the last iteration. Convergence means that <code>last_sim_fit_diffusivity</code> came close to <code>uncorrected_fit_diffusivity</code>.
</p>
</td></tr>
<tr><td><code>all_correction_factors</code></td>
<td>

<p>Numeric vector of length <code>Niterations</code>, listing the estimated correction factors in each iteration.
</p>
</td></tr>
<tr><td><code>all_diffusivity_estimates</code></td>
<td>

<p>Numeric vector of length <code>Niterations</code>, listing the mean uncorrected diffusivity estimated from the simulated data in each iteration.
</p>
</td></tr>
<tr><td><code>Ntrees</code></td>
<td>

<p>Integer, number of trees considered for the simulations. This might have smaller than <code>length(trees)</code>, if for some trees fitting a birth-death model was not possible.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>Numeric vector of length <code>Ntrees</code>, listing the birth rates used to simulate the trees.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>Numeric vector of length <code>Ntrees</code>, listing the death rates used to simulate the trees.
</p>
</td></tr>
<tr><td><code>rarefaction</code></td>
<td>

<p>Numeric vector of length <code>Ntrees</code>, listing the rarefactions (sampling fractions) used to simulate the trees. These will typically be equal to the <code>rarefaction</code> provided by the function caller, but may differ for example if the congruence class did not include a birth-death model with the requested rarefaction.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts (i.e., tip pairs) used to estimate the diffusivity. This is the number of independent data points used.
</p>
</td></tr>
<tr><td><code>standard_error</code></td>
<td>

<p>Numeric, estimated standard error of the estimated true diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric, lower bound of the 50% confidence interval for the estimated true diffusivity (25-75% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric, upper bound of the 50% confidence interval for the estimated true diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric, lower bound of the 95% confidence interval for the estimated true diffusivity (2.5-97.5% percentile), based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric, upper bound of the 95% confidence interval for the estimated true diffusivity, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>QQplot</code></td>
<td>

<p>Numeric matrix of size Ncontrasts x 2, listing the computed QQ-plot. The first column lists quantiles of geodistances in the original dataset, the 2nd column lists quantiles of hypothetical geodistances simulated based on the estimated true diffusivity.
</p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>

<p>List, containing the trees and tip coordinates simulated under the final fitted SBM model, accounting for geographic biases. Each entry is itself a named list, containing the simulations corresponding to a specific input tree. In particular, <code>simulations[[t]]$sims[[r]]</code> is the r-th simulation performed that corresponds to the t-th input tree. Each simulation is again a named list, containing the elements <code>success</code> (logical), <code>tree</code> (of class <code>phylo</code>), <code>latitudes</code> (numeric vector) and <code>longitudes</code> (numeric vector). This data structure may be useful for testing the adequacy of the fitted SBM model; only use this if you know what you are doing. Only returned if <code>include_simulations</code> was <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes. Most users can ignore this.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>
<p>S. Louca (in review as of 2021). The rates of global microbial dispersal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>,
<code><a href="#topic+fit_sbm_linear">fit_sbm_linear</a></code>,
<code><a href="#topic+fit_sbm_on_grid">fit_sbm_on_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
NFullTips   = 10000
diffusivity = 1
radius      = 6371

# generate tree and run SBM on it
cat(sprintf("Generating tree and simulating SBM (true D=%g)..\n",diffusivity))
tree = castor::generate_tree_hbd_reverse(Ntips  = NFullTips,
                                         lambda = 5e-7,
                                         mu     = 2e-7,
                                         rho    = 1)$trees[[1]]
SBMsim = simulate_sbm(tree = tree, radius = radius, diffusivity = diffusivity)

# select subset of tips only found in certain geographic regions
min_abs_lat = 30
max_abs_lat = 80
min_lon     = 0
max_lon     = 90
keep_tips   = which((abs(SBMsim$tip_latitudes)&lt;=max_abs_lat)
                    &amp; (abs(SBMsim$tip_latitudes)&gt;=min_abs_lat)
                    &amp; (SBMsim$tip_longitudes&lt;=max_lon)
                    &amp; (SBMsim$tip_longitudes&gt;=min_lon))
rarefaction     = castor::get_subtree_with_tips(tree, only_tips = keep_tips)
tree            = rarefaction$subtree
tip_latitudes   = SBMsim$tip_latitudes[rarefaction$new2old_tip]
tip_longitudes  = SBMsim$tip_longitudes[rarefaction$new2old_tip]
Ntips           = length(tree$tip.label)
rarefaction     = Ntips/NFullTips

# fit SBM while correcting for geographic sampling biases
fit = castor:::fit_sbm_geobiased_const(trees            = tree,
                                       tip_latitudes    = tip_latitudes,
                                       tip_longitudes   = tip_longitudes,
                                       radius           = radius,
                                       rarefaction      = Ntips/NFullTips,
                                       Nsims            = 10,
                                       Nthreads         = 4,
                                       verbose          = TRUE,
                                       verbose_prefix   = "  ")
if(!fit$success){
    cat(sprintf("ERROR: %s\n",fit$error))
}else{
    cat(sprintf("Estimated true D = %g\n",fit$diffusivity))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_sbm_linear'>
Fit a phylogeographic Spherical Brownian Motion model with linearly varying diffusivity.
</h2><span id='topic+fit_sbm_linear'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and geographic coordinates (latitudes &amp; longitudes) for its tips, this function estimates the diffusivity of a Spherical Brownian Motion (SBM) model for the evolution of geographic location along lineages (Perrin 1928; Brillinger 2012), assuming that the diffusivity varies linearly over time. Estimation is done via maximum-likelihood and using independent contrasts between sister lineages. This function is designed to estimate the diffusivity over time, by fitting two parameters defining the diffusivity as a linear function of time. For fitting more general functional forms see <code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sbm_linear(tree, 
              tip_latitudes,
              tip_longitudes,
              radius,
              clade_states          = NULL,
              planar_approximation  = FALSE,
              only_basal_tip_pairs  = FALSE,
              only_distant_tip_pairs= FALSE,
              min_MRCA_time         = 0,
              max_MRCA_age          = Inf,
              max_phylodistance     = Inf,
              no_state_transitions  = FALSE,
              only_state            = NULL,
              time1                 = 0,
              time2                 = NULL,
              Ntrials               = 1,
              Nthreads              = 1,
              Nbootstraps           = 0,
              Ntrials_per_bootstrap = NULL,
              Nsignificance         = 0,
              NQQ                   = 0,
              fit_control           = list(),
              SBM_PD_functor        = NULL,
              verbose               = FALSE,
              verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sbm_linear_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing latitudes of tips in decimal degrees (from -90 to 90). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing longitudes of tips in decimal degrees (from -180 to 180). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_clade_states">clade_states</code></td>
<td>

<p>Optional integer vector of length Ntips+Nnodes, listing discrete states of every tip and node in the tree. The order of entries must match the order of tips and nodes in the tree. States may be, for example, geographic regions, sub-types, discrete traits etc, and can be used to restrict independent contrasts to tip pairs within the same state (see option <code>no_state_transitions</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_planar_approximation">planar_approximation</code></td>
<td>

<p>Logical, specifying whether to estimate the diffusivity based on a planar approximation of the SBM model, i.e. by assuming that geographic distances between tips are as if tips are distributed on a 2D cartesian plane. This approximation is only accurate if geographical distances between tips are small compared to the sphere's radius.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_no_state_transitions">no_state_transitions</code></td>
<td>

<p>Logical, specifying whether to omit independent contrasts between tips whose shortest connecting paths include state transitions. If <code>TRUE</code>, only tips within the same state and with no transitions between them (as specified in <code>clade_states</code>) are compared.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_only_state">only_state</code></td>
<td>

<p>Optional integer, specifying the state in which tip pairs (and their connecting ancestral nodes) must be in order to be considered. If specified, then <code>clade_states</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_time1">time1</code></td>
<td>

<p>Optional numeric, specifying the first time point at which to estimate the diffusivity. By default this is set to root (i.e., time 0).
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_time2">time2</code></td>
<td>

<p>Optional numeric, specifying the first time point at which to estimate the diffusivity. By default this is set to the present day (i.e., the maximum distance of any tip from the root).
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated model parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_nsignificance">Nsignificance</code></td>
<td>

<p>Integer, specifying the number of simulations to perform under a const-diffusivity model for assessing the statistical significance of the fitted slope. Set to 0 to not calculate the significance of the slope.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_nqq">NQQ</code></td>
<td>

<p>Integer, optional number of simulations to perform for creating QQ plots of the theoretically expected distribution of geodistances vs. the empirical distribution of geodistances (across independent contrasts). The resolution of the returned QQ plot will be equal to the number of independent contrasts used for fitting. If &lt;=0, no QQ plots will be calculated.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes, and should be kept at its default value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen.
</p>
</td></tr>
<tr><td><code id="fit_sbm_linear_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper for the more general function <code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>, with the addition that it can estimate the statistical significance of the fitted linear slope. 
</p>
<p>The statistical significance of the slope is the probability that a constant-diffusivity SBM model would generate data that would yield a fitted linear slope equal to or greater than the one fitted to the original data; the significance is estimated by simulating <code>Nsignificance</code> constant-diffusivity models and then fitting a linear-diffusivity model. The constant diffusivity assumed in these simulations is the maximum-likelihood diffusivity fitted internally using <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>.
</p>
<p>Note that estimation of diffusivity at older times is only possible if the timetree includes extinct tips or tips sampled at older times (e.g., as is often the case in viral phylogenies). If tips are only sampled once at present-day, i.e. the timetree is ultrametric, reliable diffusivity estimates can only be achieved near present times.
</p>
<p>For short expected transition distances this function uses the approximation formula by Ghosh et al. (2012) to calculate the probability density of geographical transitions along edges. For longer expected transition distances the function uses a truncated approximation of the series representation of SBM transition densities (Perrin 1928).
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>times</code></td>
<td>

<p>Numeric vector of size 2, listing the two time points at which the diffusivity was estimated (<code>time1</code> and <code>time2</code>).
</p>
</td></tr>
<tr><td><code>diffusivities</code></td>
<td>

<p>Numeric vector of size 2, listing the fitted diffusivity at <code>time1</code> and <code>time2</code>. The fitted model assumes that the diffusivity varied linearly between those two time points.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted linear model for the given data.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters. Will always be 2.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts used for fitting.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of independent contrasts), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size 2, estimated standard error of the fitted diffusivity at the root and present, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size 2, lower bound of the 50% confidence interval (25-75% percentile) for the fitted diffusivity at the root and present, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size 2, upper bound of the 50% confidence interval for the fitted diffusivity at the root and present, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size 2, lower bound of the 95% confidence interval (2.5-97.5% percentile) for the fitted diffusivity at the root and present, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size 2, upper bound of the 95% confidence interval for the fitted diffusivity at the root and present, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. See the documentation of <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> for an explanation. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>significance</code></td>
<td>

<p>Numeric between 0 and 1, estimate statistical significance of the fitted linear slope. Only returned if <code>Nsignificance&gt;0</code>.
</p>
</td></tr>
<tr><td><code>QQplot</code></td>
<td>

<p>Numeric matrix of size Ncontrasts x 2, listing the computed QQ-plot. The first column lists quantiles of geodistances in the original dataset, the 2nd column lists quantiles of hypothetical geodistances simulated based on the fitted model.
</p>
</td></tr>
<tr><td><code>SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>,
<code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>,
<code><a href="#topic+fit_sbm_on_grid">fit_sbm_on_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree, keeping extinct lineages
tree_params = list(birth_rate_factor=1, death_rate_factor=0.95)
tree = generate_random_tree(tree_params,max_tips=1000,coalescent=FALSE)$tree

# calculate max distance of any tip from the root
max_time = get_tree_span(tree)$max_distance

# simulate time-dependent SBM on the tree
# we assume that diffusivity varies linearly with time
# in this example we measure distances in Earth radii
radius = 1
diffusivity_functor = function(times, params){
    return(params[1] + (times/max_time)*(params[2]-params[1]))
}
true_params = c(1, 2)
time_grid   = seq(0,max_time,length.out=2)
simulation  = simulate_sbm(tree,
                    radius = radius, 
                    diffusivity = diffusivity_functor(time_grid,true_params), 
                    time_grid = time_grid)

# fit time-independent SBM to get a rough estimate
fit_const = fit_sbm_const(tree,simulation$tip_latitudes,simulation$tip_longitudes,radius=radius)

# fit SBM model with linearly varying diffusivity
fit = fit_sbm_linear(tree,
            simulation$tip_latitudes,
            simulation$tip_longitudes,
            radius = radius,
            Ntrials = 10)
    
# compare fitted &amp; true params
print(true_params)
print(fit$diffusivities)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_sbm_on_grid'>
Fit a phylogeographic Spherical Brownian Motion model with piecewise-linear diffusivity.
</h2><span id='topic+fit_sbm_on_grid'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and geographic coordinates (latitudes &amp; longitudes) for its tips, this function estimates the diffusivity of a Spherical Brownian Motion (SBM) model with time-dependent diffusivity for the evolution of geographic location along lineages (Perrin 1928; Brillinger 2012). Estimation is done via maximum-likelihood and using independent contrasts between sister lineages. This function is designed to estimate the diffusivity over time, approximated as a piecewise linear profile, by fitting the diffusivity on a discrete set of time points. The user thus provides a set of time points (<code>time_grid</code>), and <code>fit_sbm_on_grid</code> estimates the diffusivity on each time point, while assuming that the diffusivity varies linearly between time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sbm_on_grid(tree, 
              tip_latitudes,
              tip_longitudes,
              radius,
              clade_states          = NULL,
              planar_approximation  = FALSE,
              only_basal_tip_pairs  = FALSE,
              only_distant_tip_pairs= FALSE,
              min_MRCA_time         = 0,
              max_MRCA_age          = Inf,
              max_phylodistance     = Inf,
              no_state_transitions  = FALSE,
              only_state            = NULL,
              time_grid             = 0,
              guess_diffusivity     = NULL,
              min_diffusivity       = NULL,
              max_diffusivity       = Inf,
              Ntrials               = 1,
              Nthreads              = 1,
              Nbootstraps           = 0,
              Ntrials_per_bootstrap = NULL,
              NQQ                   = 0,
              fit_control           = list(),
              SBM_PD_functor        = NULL,
              verbose               = FALSE,
              verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sbm_on_grid_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing latitudes of tips in decimal degrees (from -90 to 90). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing longitudes of tips in decimal degrees (from -180 to 180). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_clade_states">clade_states</code></td>
<td>

<p>Optional integer vector of length Ntips+Nnodes, listing discrete states of every tip and node in the tree. The order of entries must match the order of tips and nodes in the tree. States may be, for example, geographic regions, sub-types, discrete traits etc, and can be used to restrict independent contrasts to tip pairs within the same state (see option <code>no_state_transitions</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_planar_approximation">planar_approximation</code></td>
<td>

<p>Logical, specifying whether to estimate the diffusivity based on a planar approximation of the SBM model, i.e. by assuming that geographic distances between tips are as if tips are distributed on a 2D cartesian plane. This approximation is only accurate if geographical distances between tips are small compared to the sphere's radius.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_no_state_transitions">no_state_transitions</code></td>
<td>

<p>Logical, specifying whether to omit independent contrasts between tips whose shortest connecting paths include state transitions. If <code>TRUE</code>, only tips within the same state and with no transitions between them (as specified in <code>clade_states</code>) are compared.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_only_state">only_state</code></td>
<td>

<p>Optional integer, specifying the state in which tip pairs (and their connecting ancestral nodes) must be in order to be considered. If specified, then <code>clade_states</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_time_grid">time_grid</code></td>
<td>

<p>Numeric vector, specifying discrete time points (counted since the root) at which the <code>diffusivity</code> should be fitted; between these time points the diffusivity is assumed to vary linearly. This time grid should be fine enough to sufficiently capture the variation in the diffusivity over time, but must not be too big to avoid overfitting. If <code>NULL</code> or of size 1, then the diffusivity is assumed to be time-independent. Listed times must be strictly increasing, and should cover at least the full considered time interval (from 0 to the maximum distance of any tip from the root); otherwise, constant extrapolation is used to cover missing times. Note that time is measured in the same units as the tree's edge lengths.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_guess_diffusivity">guess_diffusivity</code></td>
<td>

<p>Optional numeric vector, specifying a first guess for the diffusivity. Either of size 1 (the same first guess for all time points), or of the same length as <code>time_grid</code> (different first guess for each time point, <code>NA</code> are replaced with an automatically chosen first guess). If <code>NULL</code>, the first guess is chosen automatically.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_min_diffusivity">min_diffusivity</code></td>
<td>

<p>Optional numeric vector, specifying lower bounds for the fitted diffusivity. Either of size 1 (the same lower bound is assumed for all time points), or of the same length as <code>time_grid</code> (different lower bound for each time point, <code>NA</code> are replaced with an automatically chosen lower bound). If <code>NULL</code>, lower bounds are chosen automatically. 
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_max_diffusivity">max_diffusivity</code></td>
<td>

<p>Optional numeric vector, specifying upper bounds for the fitted diffusivity. Either of size 1 (the same upper bound is assumed for all time points), or of the same length as <code>time_grid</code> (different upper bound for each time point, <code>NA</code> are replaced with infinity). If <code>NULL</code>, no upper bound is imposed.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated model parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_nqq">NQQ</code></td>
<td>

<p>Integer, optional number of simulations to perform for creating QQ plots of the theoretically expected distribution of geodistances vs. the empirical distribution of geodistances (across independent contrasts). The resolution of the returned QQ plot will be equal to the number of independent contrasts used for fitting. If &lt;=0, no QQ plots will be calculated.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes, and should be kept at its default value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_on_grid_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate the diffusivity profile over time, approximated by a piecewise linear function. Fitting is done by maximizing the likelihood of observing the given tip coordinates under the SBM model. Internally, this function uses <code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_sbm_on_grid</code> as possible, including reasonable lower and upper bounds (<code>min_diffusivity</code> and <code>max_diffusivity</code>). It is important that the <code>time_grid</code> is sufficiently fine to capture the variation of the true diffusivity over time, since the likelihood is calculated under the assumption that the diffusivity varies linearly between grid points. However, depending on the size of the tree, the grid size must not be too large, since otherwise overfitting becomes very likely. The <code>time_grid</code> does not need to be uniform, i.e., you may want to use a finer grid in regions where there's more data (tips) available.
</p>
<p>Note that estimation of diffusivity at older times is only possible if the timetree includes extinct tips or tips sampled at older times (e.g., as is often the case in viral phylogenies). If tips are only sampled once at present-day, i.e. the timetree is ultrametric, reliable diffusivity estimates can only be achieved near present times. If the tree is ultrametric, you should consider using <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> instead.
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>time_grid</code></td>
<td>

<p>Numeric vector, the time-grid on which the diffusivity was fitted.
</p>
</td></tr>
<tr><td><code>diffusivity</code></td>
<td>

<p>Numeric vector of size Ngrid (length of <code>time_grid</code>), listing the fitted diffusivities at the various time-grid points.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given data.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts used for fitting.
</p>
</td></tr>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing phylogenetic (patristic) distances of the independent contrasts.
</p>
</td></tr>
<tr><td><code>geodistances</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing geographic (great circle) distances of the independent contrasts.
</p>
</td></tr>
<tr><td><code>child_times1</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the first tip in each independent contrast.
</p>
</td></tr>
<tr><td><code>child_times2</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the second tip in each independent contrast.
</p>
</td></tr>
<tr><td><code>MRCA_times</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the MRCA of the two tips in each independent contrast.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of independent contrasts), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size NP, estimated standard error of the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>Numeric vector of size NP, median the estimated parameters across parametric bootstraps. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 50% confidence interval (25-75% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 50% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 95% confidence interval (2.5-97.5% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 95% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. See the documentation of <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> for an explanation.
</p>
</td></tr>
<tr><td><code>QQplot</code></td>
<td>

<p>Numeric matrix of size Ncontrasts x 2, listing the computed QQ-plot. The first column lists quantiles of geodistances in the original dataset, the 2nd column lists quantiles of hypothetical geodistances simulated based on the fitted model.
</p>
</td></tr>
<tr><td><code>SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>,
<code><a href="#topic+fit_sbm_parametric">fit_sbm_parametric</a></code>,
<code><a href="#topic+fit_sbm_linear">fit_sbm_linear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree, keeping extinct lineages
tree_params = list(birth_rate_factor=1, death_rate_factor=0.95)
tree = generate_random_tree(tree_params,max_tips=2000,coalescent=FALSE)$tree

# calculate max distance of any tip from the root
max_time = get_tree_span(tree)$max_distance

# simulate time-dependent SBM on the tree
# using a diffusivity that varies roughly exponentially with time
# In this example we measure distances in Earth radii
radius = 1
fine_time_grid = seq(from=0, to=max_time, length.out=10)
fine_D = 0.01 + 0.03*exp(-2*fine_time_grid/max_time)
simul = simulate_sbm(tree, 
                     radius     = radius, 
                     diffusivity= fine_D, 
                     time_grid  = fine_time_grid)

# fit time-dependent SBM on a time-grid of size 4
fit = fit_sbm_on_grid(tree,
            simul$tip_latitudes,
            simul$tip_longitudes,
            radius    = radius,
            time_grid = seq(from=0,to=max_time,length.out=4),
            Nthreads  = 3,  # use 3 CPUs
            Ntrials   = 30) # avoid local optima through multiple trials
    
# visually compare fitted &amp; true params
plot(x      = fine_time_grid,
     y      = fine_D,
     type   = 'l',
     col    = 'black',
     xlab   = 'time',
     ylab   = 'D',
     ylim   = c(0,max(fine_D)))
lines(x     = fit$time_grid,
      y     = fit$diffusivity,
      type  = 'l',
      col   = 'blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_sbm_parametric'>
Fit a time-dependent phylogeographic Spherical Brownian Motion model.
</h2><span id='topic+fit_sbm_parametric'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and geographic coordinates (latitudes &amp; longitudes) for its tips, this function estimates the diffusivity of a Spherical Brownian Motion (SBM) model with time-dependent diffusivity for the evolution of geographic location along lineages (Perrin 1928; Brillinger 2012). Estimation is done via maximum-likelihood and using independent contrasts between sister lineages. This function is designed to estimate the diffusivity over time, by fitting a finite number of parameters defining the diffusivity as a function of time. The user thus provides the general functional form of the diffusivity that depends on time and NP parameters, and <code>fit_sbm_parametric</code> estimates each of the free parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sbm_parametric(tree, 
              tip_latitudes,
              tip_longitudes,
              radius,
              param_values,
              param_guess,
              diffusivity,
              time_grid             = NULL,
              clade_states          = NULL,
              planar_approximation  = FALSE,
              only_basal_tip_pairs  = FALSE,
              only_distant_tip_pairs= FALSE,
              min_MRCA_time         = 0,
              max_MRCA_age          = Inf,
              max_phylodistance     = Inf,
              no_state_transitions  = FALSE,
              only_state            = NULL,
              param_min             = -Inf,
              param_max             = +Inf,
              param_scale           = NULL,
              Ntrials               = 1,
              max_start_attempts    = 1,
              Nthreads              = 1,
              Nbootstraps           = 0,
              Ntrials_per_bootstrap = NULL,
              NQQ                   = 0,
              fit_control           = list(),
              SBM_PD_functor        = NULL,
              focal_param_values    = NULL,
              verbose               = FALSE,
              verbose_prefix        = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sbm_parametric_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing latitudes of tips in decimal degrees (from -90 to 90). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing longitudes of tips in decimal degrees (from -180 to 180). The order of entries must correspond to the order of tips in the tree (i.e., as listed in <code>tree$tip.label</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_param_values">param_values</code></td>
<td>

<p>Numeric vector of length NP, specifying fixed values for a some or all model parameters. For fitted (i.e., non-fixed) parameters, use <code>NaN</code> or <code>NA</code>. For example, the vector <code>c(1.5,NA,40)</code> specifies that the 1st and 3rd model parameters are fixed at the values 1.5 and 40, respectively, while the 2nd parameter is to be fitted. The length of this vector defines the total number of model parameters. If entries in this vector are named, the names are taken as parameter names. Names should be included if you'd like returned parameter vectors to have named entries, or if the <code>diffusivity</code> function queries parameter values by name (as opposed to numeric index).
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_param_guess">param_guess</code></td>
<td>

<p>Numeric vector of size NP, specifying a first guess for the value of each model parameter. For fixed parameters, guess values are ignored. Can be <code>NULL</code> only if all model parameters are fixed.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_diffusivity">diffusivity</code></td>
<td>

<p>Function specifying the diffusivity at any given time (time since the root) and for any given parameter values. This function must take exactly two arguments, the 1st one being a numeric vector (one or more times) and the 2nd one being a numeric vector of size NP (parameter values), and return a numeric vector of the same size as the 1st argument.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_time_grid">time_grid</code></td>
<td>

<p>Numeric vector, specifying times (counted since the root) at which the <code>diffusivity</code> function should be evaluated. This time grid must be fine enough to capture the possible variation in the diffusivity over time, within the permissible parameter range. If of size 1, then the diffusivity is assumed to be time-independent.
Listed times must be strictly increasing, and should cover at least the full considered time interval (from 0 to the maximum distance of any tip from the root); otherwise, constant extrapolation is used to cover missing times. Can also be <code>NULL</code> or a vector of size 1, in which case the diffusivity is assumed to be time-independent. Note that time is measured in the same units as the tree's edge lengths.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_clade_states">clade_states</code></td>
<td>

<p>Optional integer vector of length Ntips+Nnodes, listing discrete states of every tip and node in the tree. The order of entries must match the order of tips and nodes in the tree. States may be, for example, geographic regions, sub-types, discrete traits etc, and can be used to restrict independent contrasts to tip pairs within the same state (see option <code>no_state_transitions</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_planar_approximation">planar_approximation</code></td>
<td>

<p>Logical, specifying whether to estimate the diffusivity based on a planar approximation of the SBM model, i.e. by assuming that geographic distances between tips are as if tips are distributed on a 2D cartesian plane. This approximation is only accurate if geographical distances between tips are small compared to the sphere's radius.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_only_basal_tip_pairs">only_basal_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare immediate sister tips, i.e., tips connected through a single parental node.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_only_distant_tip_pairs">only_distant_tip_pairs</code></td>
<td>

<p>Logical, specifying whether to only compare tips at distinct geographic locations.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_min_mrca_time">min_MRCA_time</code></td>
<td>

<p>Numeric, specifying the minimum allowed time (distance from root) of the most recent common ancestor (MRCA) of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at least this distance from the root. Set <code>min_MRCA_time=0</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_max_mrca_age">max_MRCA_age</code></td>
<td>

<p>Numeric, specifying the maximum allowed age (distance from youngest tip) of the MRCA of sister tips considered in the fitting. In other words, an independent contrast is only considered if the two sister tips' MRCA has at most this age (time to present). Set <code>max_MRCA_age=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, maximum allowed geodistance for an independent contrast to be included in the SBM fitting. Set <code>max_phylodistance=Inf</code> to disable this filter.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_no_state_transitions">no_state_transitions</code></td>
<td>

<p>Logical, specifying whether to omit independent contrasts between tips whose shortest connecting paths include state transitions. If <code>TRUE</code>, only tips within the same state and with no transitions between them (as specified in <code>clade_states</code>) are compared.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_only_state">only_state</code></td>
<td>

<p>Optional integer, specifying the state in which tip pairs (and their connecting ancestral nodes) must be in order to be considered. If specified, then <code>clade_states</code> must be provided.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_param_min">param_min</code></td>
<td>

<p>Optional numeric vector of size NP, specifying lower bounds for model parameters. If of size 1, the same lower bound is applied to all parameters. Use <code>-Inf</code> to omit a lower bound for a parameter. If <code>NULL</code>, no lower bounds are applied. For fixed parameters, lower bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_param_max">param_max</code></td>
<td>

<p>Optional numeric vector of size NP, specifying upper bounds for model parameters. If of size 1, the same upper bound is applied to all parameters. Use <code>+Inf</code> to omit an upper bound for a parameter. If <code>NULL</code>, no upper bounds are applied. For fixed parameters, upper bounds are ignored.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_param_scale">param_scale</code></td>
<td>

<p>Optional numeric vector of size NP, specifying typical scales for model parameters. If of size 1, the same scale is assumed for all parameters. If <code>NULL</code>, scales are determined automatically. For fixed parameters, scales are ignored. It is strongly advised to provide reasonable scales, as this facilitates the numeric optimization algorithm.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer, specifying the number of independent fitting trials to perform, each starting from a random choice of model parameters. Increasing <code>Ntrials</code> reduces the risk of reaching a non-global local maximum in the fitting objective.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_max_start_attempts">max_start_attempts</code></td>
<td>

<p>Integer, specifying the number of times to attempt finding a valid start point (per trial) before giving up on that trial. Randomly choosen extreme start parameters may occasionally result in Inf/undefined likelihoods, so this option allows the algorithm to keep looking for valid starting points.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, specifying the number of parallel threads to use for performing multiple fitting trials simultaneously. This should generally not exceed the number of available CPUs on your machine. Parallel computing is not available on the Windows platform.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, specifying the number of parametric bootstraps to perform for estimating standard errors and confidence intervals of estimated model parameters. Set to 0 for no bootstrapping.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_ntrials_per_bootstrap">Ntrials_per_bootstrap</code></td>
<td>

<p>Integer, specifying the number of fitting trials to perform for each bootstrap sampling. If <code>NULL</code>, this is set equal to <code>max(1,Ntrials)</code>. Decreasing <code>Ntrials_per_bootstrap</code> will reduce computation time, at the expense of potentially inflating the estimated confidence intervals; in some cases (e.g., for very large trees) this may be useful if fitting takes a long time and confidence intervals are very narrow anyway. Only relevant if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_nqq">NQQ</code></td>
<td>

<p>Integer, optional number of simulations to perform for creating QQ plots of the theoretically expected distribution of geodistances vs. the empirical distribution of geodistances (across independent contrasts). The resolution of the returned QQ plot will be equal to the number of independent contrasts used for fitting. If &lt;=0, no QQ plots will be calculated.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>nlminb</code> optimization routine, such as <code>iter.max</code>, <code>eval.max</code> or <code>rel.tol</code>. For a complete list of options and default values see the documentation of <code>nlminb</code> in the <code>stats</code> package.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_sbm_pd_functor">SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes, and should be kept at its default value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_focal_param_values">focal_param_values</code></td>
<td>

<p>Optional numeric matrix having NP columns and an arbitrary number of rows, listing combinations of parameter values of particular interest and for which the log-likelihoods should be returned. This may be used e.g. for diagnostic purposes, e.g. to examine the shape of the likelihood function.
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_verbose">verbose</code></td>
<td>

<p>Logical, specifying whether to print progress reports and warnings to the screen. Note that errors always cause a return of the function (see return values <code>success</code> and <code>error</code>).
</p>
</td></tr>
<tr><td><code id="fit_sbm_parametric_+3A_verbose_prefix">verbose_prefix</code></td>
<td>

<p>Character, specifying the line prefix for printing progress reports to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate a finite set of scalar parameters (<code class="reqn">p_1,..,p_n\in\R</code>) that determine the diffusivity over time, by maximizing the likelihood of observing the given tip coordinates under the SBM model. For example, the investigator may assume that the diffusivity exponentially over time, i.e. can be described by <code class="reqn">D(t)=A\cdot e^{-B t}</code> (where <code class="reqn">A</code> and <code class="reqn">B</code> are unknown coefficients and <code class="reqn">t</code> is time since the root). In this case the model has 2 free parameters, <code class="reqn">p_1=A</code> and <code class="reqn">p_2=B</code>, each of which may be fitted to the tree.
</p>
<p>It is generally advised to provide as much information to the function <code>fit_sbm_parametric</code> as possible, including reasonable lower and upper bounds (<code>param_min</code> and <code>param_max</code>), a reasonable parameter guess (<code>param_guess</code>) and reasonable parameter scales <code>param_scale</code>. If some model parameters can vary over multiple orders of magnitude, it is advised to transform them so that they vary across fewer orders of magnitude (e.g., via log-transformation). It is also important that the <code>time_grid</code> is sufficiently fine to capture the variation of the diffusivity over time, since the likelihood is calculated under the assumption that the diffusivity varies linearly between grid points.
</p>
<p>Estimation of diffusivity at older times is only possible if the timetree includes extinct tips or tips sampled at older times (e.g., as is often the case in viral phylogenies). If tips are only sampled once at present-day, i.e. the timetree is ultrametric, reliable diffusivity estimates can only be achieved near present times. If the tree is ultrametric, you should consider using <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> instead.
</p>
<p>For short expected transition distances this function uses the approximation formula by Ghosh et al. (2012) to calculate the probability density of geographical transitions along edges. For longer expected transition distances the function uses a truncated approximation of the series representation of SBM transition densities (Perrin 1928).
</p>
<p>If <code>edge.length</code> is missing from one of the input trees, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations, however multifurcations are internally expanded into bifurcations by adding dummy nodes.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>The maximized fitting objective. Currently, only maximum-likelihood estimation is implemented, and hence this will always be the maximized log-likelihood.
</p>
</td></tr>
<tr><td><code>objective_name</code></td>
<td>

<p>The name of the objective that was maximized during fitting. Currently, only maximum-likelihood estimation is implemented, and hence this will always be &ldquo;loglikelihood&rdquo;.
</p>
</td></tr>
<tr><td><code>param_fitted</code></td>
<td>

<p>Numeric vector of size NP (number of model parameters), listing all fitted or fixed model parameters in their standard order (see details above).
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>The log-likelihood of the fitted model for the given data.
</p>
</td></tr>
<tr><td><code>NFP</code></td>
<td>

<p>Integer, number of fitted (i.e., non-fixed) model parameters.
</p>
</td></tr>
<tr><td><code>Ncontrasts</code></td>
<td>

<p>Integer, number of independent contrasts used for fitting.
</p>
</td></tr>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing phylogenetic (patristic) distances of the independent contrasts.
</p>
</td></tr>
<tr><td><code>geodistances</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing geographic (great circle) distances of the independent contrasts.
</p>
</td></tr>
<tr><td><code>child_times1</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the first tip in each independent contrast.
</p>
</td></tr>
<tr><td><code>child_times2</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the second tip in each independent contrast.
</p>
</td></tr>
<tr><td><code>MRCA_times</code></td>
<td>

<p>Numeric vector of length Ncontrasts, listing the times (distance from root) of the MRCA of the two tips in each independent contrast.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>The Akaike Information Criterion for the fitted model, defined as <code class="reqn">2k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>

<p>The Bayesian information criterion for the fitted model, defined as <code class="reqn">\log(n)k-2\log(L)</code>, where <code class="reqn">k</code> is the number of fitted parameters, <code class="reqn">n</code> is the number of data points (number of independent contrasts), and <code class="reqn">L</code> is the maximized likelihood.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Logical, specifying whether the maximum likelihood was reached after convergence of the optimization algorithm. Note that in some cases the maximum likelihood may have been achieved by an optimization path that did not yet converge (in which case it's advisable to increase <code>iter.max</code> and/or <code>eval.max</code>).
</p>
</td></tr>
<tr><td><code>Niterations</code></td>
<td>

<p>Integer, specifying the number of iterations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>Nevaluations</code></td>
<td>

<p>Integer, specifying the number of likelihood evaluations performed during the optimization path that yielded the maximum likelihood.
</p>
</td></tr>
<tr><td><code>guess_loglikelihood</code></td>
<td>

<p>The loglikelihood of the data for the initial parameter guess (<code>param_guess</code>).
</p>
</td></tr>
<tr><td><code>focal_loglikelihoods</code></td>
<td>

<p>A numeric vector of the same size as <code>nrow(focal_param_values)</code>, listing loglikelihoods for each of the focal parameter conbinations listed in <code>focal_loglikelihoods</code>.
</p>
</td></tr>
<tr><td><code>trial_start_objectives</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the initial objective values (e.g., loglikelihoods) for each fitting trial, i.e. at the start parameter values.
</p>
</td></tr>
<tr><td><code>trial_objective_values</code></td>
<td>

<p>Numeric vector of size <code>Ntrials</code>, listing the final maximized objective values (e.g., loglikelihoods) for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nstart_attempts</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of start attempts for each fitting trial, until a starting point with valid likelihood was found.
</p>
</td></tr>
<tr><td><code>trial_Niterations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of iterations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>trial_Nevaluations</code></td>
<td>

<p>Integer vector of size <code>Ntrials</code>, listing the number of likelihood evaluations needed for each fitting trial.
</p>
</td></tr>
<tr><td><code>standard_errors</code></td>
<td>

<p>Numeric vector of size NP, estimated standard error of the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>Numeric vector of size NP, median the estimated parameters across parametric bootstraps. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 50% confidence interval (25-75% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 50% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size NP, lower bound of the 95% confidence interval (2.5-97.5% percentile) for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size NP, upper bound of the 95% confidence interval for the parameters, based on parametric bootstrapping. Only returned if <code>Nbootstraps&gt;0</code>.
</p>
</td></tr>
<tr><td><code>consistency</code></td>
<td>

<p>Numeric between 0 and 1, estimated consistency of the data with the fitted model. See the documentation of <code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code> for an explanation.
</p>
</td></tr>
<tr><td><code>QQplot</code></td>
<td>

<p>Numeric matrix of size Ncontrasts x 2, listing the computed QQ-plot. The first column lists quantiles of geodistances in the original dataset, the 2nd column lists quantiles of hypothetical geodistances simulated based on the fitted model.
</p>
</td></tr>
<tr><td><code>SBM_PD_functor</code></td>
<td>

<p>SBM probability density functor object. Used internally for efficiency and for debugging purposes.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sbm">simulate_sbm</a></code>,
<code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>,
<code><a href="#topic+fit_sbm_linear">fit_sbm_linear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree, keeping extinct lineages
tree_params = list(birth_rate_factor=1, death_rate_factor=0.95)
tree = generate_random_tree(tree_params,max_tips=1000,coalescent=FALSE)$tree

# calculate max distance of any tip from the root
max_time = get_tree_span(tree)$max_distance

# simulate time-dependent SBM on the tree
# we assume that diffusivity varies linearly with time
# in this example we measure distances in Earth radii
radius = 1
diffusivity_functor = function(times, params){
	return(params[1] + (times/max_time)*(params[2]-params[1]))
}
true_params = c(1, 2)
time_grid   = seq(0,max_time,length.out=2)
simulation  = simulate_sbm(tree,
                      radius      = radius, 
                      diffusivity = diffusivity_functor(time_grid,true_params), 
                      time_grid   = time_grid)

# fit time-independent SBM to get a rough estimate
fit_const = fit_sbm_const(tree,simulation$tip_latitudes,simulation$tip_longitudes,radius=radius)

# fit time-dependent SBM, i.e. fit the 2 parameters of the linear form
fit = fit_sbm_parametric(tree,
            simulation$tip_latitudes,
            simulation$tip_longitudes,
            radius = radius,
            param_values = c(NA,NA),
            param_guess = c(fit_const$diffusivity,fit_const$diffusivity),
            diffusivity = diffusivity_functor,
            time_grid = time_grid,
            Ntrials = 10)
    
# compare fitted &amp; true params
print(true_params)
print(fit$param_fitted)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_tree_model'>
Fit a cladogenic model to an existing tree.
</h2><span id='topic+fit_tree_model'></span>

<h3>Description</h3>

<p>Fit the parameters of a tree generation model to an existing phylogenetic tree; branch lengths are assumed to be in time units. The fitted model is a stochastic cladogenic process in which speciations (births) and extinctions (deaths) are Poisson processes, as simulated by the function <code><a href="#topic+generate_random_tree">generate_random_tree</a></code>. The birth and death rates of tips can each be constant or power-law functions of the number of extant tips. For example,
</p>
<p style="text-align: center;"><code class="reqn">
B = I + F\cdot N^E,
</code>
</p>

<p>where <code class="reqn">B</code> is the birth rate, <code class="reqn">I</code> is the intercept, <code class="reqn">F</code> is the power-law factor, <code class="reqn">N</code> is the current number of extant tips and <code class="reqn">E</code> is the power-law exponent. Each of the parameters I, F, E can be fixed or fitted. 
</p>
<p>Fitting can be performed via maximum-likelihood estimation, based on the waiting times between subsequent speciation and/or extinction events represented in the tree. Alternatively, fitting can be performed using least-squares estimation, based on the number of lineages represented in the tree over time (&quot;diversity-vs-time&quot; curve, a.k.a. &quot;lineages-through-time&quot;&quot; curve). Note that the birth and death rates are NOT per-capita rates, they are absolute rates of species appearance and disappearance per time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tree_model( tree, 
                parameters          = list(),
                first_guess         = list(),
                min_age             = 0,
                max_age             = 0,
                age_centile         = NULL,
                Ntrials             = 1,
                Nthreads            = 1,
                coalescent          = FALSE,
                discovery_fraction  = NULL,
                fit_control         = list(),
                min_R2              = -Inf,
                min_wR2             = -Inf,
                grid_size           = 100,
                max_model_runtime   = NULL,
                objective           = 'LL')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_tree_model_+3A_tree">tree</code></td>
<td>

<p>A phylogenetic tree, in which branch lengths are assumed to be in time units. The tree may be a coalescent tree (i.e. only include extant clades) or a tree including extinct clades; the tree type influences what type of models can be fitted with each method.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying fixed and/or unknown birth-death model parameters, with one or more of the following elements:
</p>

<ul>
<li><p><code>birth_rate_intercept</code>: Non-negative number. The intercept of the Poissonian rate at which new species (tips) are added. In units 1/time.
</p>
</li>
<li><p><code>birth_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which new species (tips) are added. In units 1/time.
</p>
</li>
<li><p><code>birth_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which new species (tips) are added. Unitless.
</p>
</li>
<li><p><code>death_rate_intercept</code>:
Non-negative number. The intercept of the Poissonian rate at which extant species (tips) go extinct. In units 1/time.
</p>
</li>
<li><p><code>death_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which extant species (tips) go extinct. In units 1/time.
</p>
</li>
<li><p><code>death_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which extant species (tips) go extinct. Unitless.
</p>
</li>
<li><p><code>resolution</code>:
Numeric. Resolution at which the tree was collapsed (i.e. every node of age smaller than this resolution replaced by a single tip). In units time. A resolution of 0 means the tree was not collapsed.
</p>
</li>
<li><p><code>rarefaction</code>:
Numeric. Species sampling fraction, i.e. fraction of extant species represented (as tips) in the tree. A rarefaction of 1, for example, implies that the tree is complete, i.e. includes all extant species. Rarefaction is assumed to have occurred after collapsing.
</p>
</li>
<li><p><code>extant_diversity</code>: The current total extant diversity, regardless of the rarefaction and resolution of the tree at hand. For example, if <code>resolution==0</code> and <code>rarefaction==0.5</code> and the tree has 1000 tips, then <code>extant_diversity</code> should be <code>2000</code>. If <code>resolution</code> is fixed at 0 and <code>rarefaction</code> is also fixed, this can be left <code>NULL</code> and will be inferred automatically by the function.
</p>
</li></ul>

<p>Each of the above elements can also be <code>NULL</code>, in which case the parameter is fitted. Elements can also be vectors of size 2 (specifying constraint intervals), in which case the parameters are fitted and constrained within the intervals specified. For example, to fit <code>death_rate_factor</code> while constraining it to the interval [1,2], set its value to <code>c(1,2)</code>.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_first_guess">first_guess</code></td>
<td>

<p>A named list (with entries named as in <code>parameters</code>) specifying starting values for any of the fitted model parameters. Note that if <code>Ntrials&gt;1</code>, then start values may be randomly modified in all but the first trial. For any parameters missing from <code>first_guess</code>, initial values are always randomly chosen. <code>first_guess</code> can also be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_min_age">min_age</code></td>
<td>

<p>Numeric. Minimum distance from the tree crown, for a node/tip to be considered in the fitting. If &lt;=0 or <code>NULL</code>, this constraint is ignored. Use this option to omit most recent nodes.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_max_age">max_age</code></td>
<td>

<p>Numeric. Maximum distance from the tree crown, for a node/tip to be considered in the fitting. If &lt;=0 or <code>NULL</code>, this constraint is ignored. Use this option to omit old nodes, e.g. with highly uncertain placements.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_age_centile">age_centile</code></td>
<td>

<p>Numeric within 0 and 1. Fraction of youngest nodes/tips to consider for the fitting. This can be used as an alternative to max_age. E.g. if set to 0.6, then the 60% youngest nodes/tips are considered. Either <code>age_centile</code> or <code>max_age</code> must be non-NULL, but not both.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_ntrials">Ntrials</code></td>
<td>

<p>Integer. Number of fitting attempts to perform, each time using randomly varied start values for fitted parameters. The returned fitted parameter values will be taken from the trial with greatest achieved fit objective. A larger number of trials will decrease the chance of hitting a local non-global optimum during fitting.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_nthreads">Nthreads</code></td>
<td>

<p>Number of threads to use for parallel execution of multiple fitting trials. On Windows, this option has no effect because Windows does not support forks.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, specifying whether the input tree is a coalescent tree (and thus the coalescent version of the model should be fitted). Only available if <code>objective=='R2'</code>.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_discovery_fraction">discovery_fraction</code></td>
<td>

<p>Function handle, mapping age to the fraction of discovered lineages in a tree. That is, <code>discovery_fraction(tau)</code> is the probability that a lineage at age <code>tau</code>, that has an extant descendant today, will be represented (discovered) in the coalescent tree. In particular, <code>discovery_fraction(0)</code> equals the fraction of extant lineages represented in the tree. If this is provided, then <code>parameters$rarefaction</code> is fixed to 1, and <code>discovery_fraction</code> is applied after simulation. Only relevant if <code>coalescent==TRUE</code>. Experimental, so leave this <code>NULL</code> if you don't know what it means.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_fit_control">fit_control</code></td>
<td>

<p>Named list containing options for the <code>stats::nlminb</code> optimization routine, such as <code>eval.max</code> (max number of evaluations), <code>iter.max</code> (max number of iterations) and <code>rel.tol</code> (relative tolerance for convergence).
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_min_r2">min_R2</code></td>
<td>

<p>Minimum coefficient of determination of the diversity curve (clade counts vs time) of the model when compared to the input tree, for a fitted model to be accepted. For example, if set to 0.5 then only fit trials achieving an R2 of at least 0.5 will be considered. Set this to <code>-Inf</code> to not filter fitted models based on the R2.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_min_wr2">min_wR2</code></td>
<td>

<p>Similar to <code>min_R2</code>, but applying to the weighted R2, where squared-error weights are proportional to the inverse squared diversities.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_grid_size">grid_size</code></td>
<td>

<p>Integer. Number of equidistant time points to consider when calculating the R2 of a model's diversity-vs-time curve.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Numeric. Maximum runtime (in seconds) allowed for each model evaluation during fitting. Use this to escape from badly parameterized models during fitting (this will likely cause the affected fitting trial to fail). If <code>NULL</code> or &lt;=0, this option is ignored.
</p>
</td></tr>
<tr><td><code id="fit_tree_model_+3A_objective">objective</code></td>
<td>

<p>Character. Objective function to optimize during fitting. Can be either &quot;LL&quot; (log-likelihood of waiting times between speciation events and between extinction events), &quot;R2&quot; (coefficient of determination of diversity-vs-time curve), &quot;wR2&quot; (weighted R2, where weights of squared errors are proportional to the inverse diversities observed in the tree) or &quot;lR2&quot; (logarithmic R2, i.e. R2 calculated for the logarithm of the diversity-vs-time curve). Note that &quot;wR2&quot; will weight errors at lower diversities more strongly than &quot;R2&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the fitting was successful.
</p>
</td></tr>
<tr><td><code>objective_value</code></td>
<td>

<p>Numeric. The achieved maximum value of the objective function (log-likelihood, R2 or weighted R2).
</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>

<p>A named list listing all model parameters (fixed and fitted).
</p>
</td></tr>
<tr><td><code>start_parameters</code></td>
<td>

<p>A named list listing the start values of all model parameters. In the case of multiple fitting trials, this will list the initial (non-randomized) guess.
</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>

<p>Numeric. The achieved coefficient of determination of the fitted model, based on the diversity-vs-time curve.
</p>
</td></tr>
<tr><td><code>wR2</code></td>
<td>

<p>Numeric. The achieved weighted coefficient of determination of the fitted model, based on the diversity-vs-time curve. Weights of squared errors are proportional to the inverse squared diversities observed in the tree.
</p>
</td></tr>
<tr><td><code>lR2</code></td>
<td>

<p>Numeric. The achieved coefficient of determination of the fitted model on a log axis, i.e. based on the logarithm of the diversity-vs-time curve.
</p>
</td></tr>
<tr><td><code>Nspeciations</code></td>
<td>

<p>Integer. Number of speciation events (=nodes) considered during fitting. This only includes speciations visible in the tree.
</p>
</td></tr>
<tr><td><code>Nextinctions</code></td>
<td>

<p>Integer. Number of extinction events (=non-crown tips) considered during fitting. This only includes extinctions visible in the tree, i.e. tips whose distance from the root is lower than the maximum.
</p>
</td></tr>
<tr><td><code>grid_times</code></td>
<td>

<p>Numeric vector. Time points considered for the diversity-vs-time curve. Times will be constrained between <code>min_age</code> and <code>max_age</code> if these were specified.
</p>
</td></tr>
<tr><td><code>tree_diversities</code></td>
<td>

<p>Number of lineages represented in the tree through time, calculated for each of <code>grid_times</code>.
</p>
</td></tr>
<tr><td><code>model_diversities</code></td>
<td>

<p>Number of lineages through time as predicted by the model (in the deterministic limit), calculated for each of <code>grid_times</code>. If <code>coalescent==TRUE</code> then these are the number of lineages expected to be represented in the coalescent tree (this may be lower than the actual number of extant clades at any given time point, if the model includes extinctions).
</p>
</td></tr>
<tr><td><code>fitted_parameter_names</code></td>
<td>

<p>Character vector, listing the names of fitted (i.e. non-fixed) parameters.
</p>
</td></tr>
<tr><td><code>locally_fitted_parameters</code></td>
<td>

<p>Named list of numeric vectors, listing the fitted values for each parameter and for each fitting trial. For example, if <code>birth_rate_factor</code> was fitted, then <code>locally_fitted_parameters$birth_rate_factor</code> will be a numeric vector of size <code>Ntrials</code> (or less, if some trials failed or omitted), listing the locally-optimized values of the parameter for each considered fitting trial. Mainly useful for diagnostic purposes.
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>Character. The name of the objective function used for fitting (&quot;LL&quot;, &quot;R2&quot; or &quot;wR2&quot;).
</p>
</td></tr>
<tr><td><code>Ntips</code></td>
<td>

<p>The number of tips in the input tree.
</p>
</td></tr>
<tr><td><code>Nnodes</code></td>
<td>

<p>The number of nodes in the input tree.
</p>
</td></tr>
<tr><td><code>min_age</code></td>
<td>

<p>The minimum age of nodes/tips considered during fitting.
</p>
</td></tr>
<tr><td><code>max_age</code></td>
<td>

<p>The maximum age of nodes/tips considered during fitting.
</p>
</td></tr>
<tr><td><code>age_centile</code></td>
<td>

<p>Numeric or <code>NULL</code>, equal to the <code>age_centile</code> specified as input to the function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+simulate_diversification_model">simulate_diversification_model</a></code>
<code><a href="#topic+reconstruct_past_diversification">reconstruct_past_diversification</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a tree using a simple speciation model
parameters = list(birth_rate_intercept  = 1, 
                  birth_rate_factor     = 0,
                  birth_rate_exponent   = 0,
                  death_rate_intercept  = 0,
                  death_rate_factor     = 0,
                  death_rate_exponent   = 0,
                  resolution            = 0,
                  rarefaction           = 1)
tree = generate_random_tree(parameters, max_tips=100)

# Fit model to the tree
fitting_parameters = parameters
fitting_parameters$birth_rate_intercept = NULL # fit only this parameter
fitting = fit_tree_model(tree,fitting_parameters)

# compare fitted to true value
T = parameters$birth_rate_intercept
F = fitting$parameters$birth_rate_intercept
cat(sprintf("birth_rate_intercept: true=%g, fitted=%g\n",T,F))
</code></pre>

<hr>
<h2 id='gamma_statistic'>
Calculate the gamma-statistic of a tree.
</h2><span id='topic+gamma_statistic'></span>

<h3>Description</h3>

<p>Given a rooted ultrametric phylogenetic tree, calculate the gamma-statistic (Pybus and Harevy, 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_statistic(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_statistic_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The tree is assumed to be ultrametric; any deviations from ultrametricity are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multifurcations and monofurcations. If edge lengths are missing (i.e. <code>edge.length=NULL</code>), then each edge is assumed to have length 1.
</p>
<p>This function is similar to the function <code>gammaStat</code> in the R package <code>ape</code> v5.3.
</p>


<h3>Value</h3>

<p>Numeric, the gamma-statistic of the tree.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>O. G. Pybus and P. H. Harvey (2000). Testing macro-evolutionary models using incomplete molecular phylogenies. Proceedings of the Royal Society of London. Series B: Biological Sciences. 267:2267-2272.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# calculate &amp; print gamma statistic
gammastat = gamma_statistic(tree)
cat(sprintf("Tree has gamma-statistic %g\n",gammastat))
</code></pre>

<hr>
<h2 id='generate_gene_tree_msc'>
Generate a gene tree based on the multi-species coalescent model.
</h2><span id='topic+generate_gene_tree_msc'></span>

<h3>Description</h3>

<p>Generate a random gene tree within a given species timetree, based on the multi-species coalescent (MSC) model. In this implementation of the MSC, every branch of the species tree has a specific effective population size (Ne) and a specific generation time (T), and gene alleles coalesce backward in time according to the Wright-Fisher model. This model does not account for gene duplication/loss, nor for hybridization or horizontal gene transfer. It is only meant to model &quot;incomplete lineage sorting&quot;, otherwise known as &quot;deep coalescence&quot;, which is one of the many mechanisms that can cause discordance between gene trees and species trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gene_tree_msc( species_tree,
                        allele_counts              = 1, 
                        population_sizes           = 1,
                        generation_times           = 1,
                        mutation_rates             = 1,
                        gene_edge_unit             = "time",
                        Nsites                     = 1,
                        bottleneck_at_speciation   = FALSE,
                        force_coalescence_at_root  = FALSE,
                        ploidy                     = 1,
                        gene_tip_labels            = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gene_tree_msc_+3A_species_tree">species_tree</code></td>
<td>

<p>Rooted timetree of class &quot;phylo&quot;. The tree can include multifurcations and monofurcations. The tree need not necessarily be ultrametric, i.e. it may include extinct species. Edge lengths are assumed to be in time units.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_allele_counts">allele_counts</code></td>
<td>

<p>Integer vector, listing the number of alleles sampled per species. Either <code>NULL</code> (1 allele per species), or a single integer (same number of alleles per species), or a vector of length Ntips listing the numbers of alleles sampled per species. In the latter case, the total number of tips in the returned gene tree will be equal to the sum of entries in <code>allele_counts</code>. Some entries in <code>allele_counts</code> may be zero (no alleles sampled from those species).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_population_sizes">population_sizes</code></td>
<td>

<p>Integer vector, listing the effective population size on the edge leading into each tip/node in the species tree. Either <code>NULL</code> (all population sizes are 1), or a single integer (same population sizes for all edges), or a vector of length Ntips+Nnodes, listing population sizes for each clade's incoming edge (including the root). The population size for the root's incoming edge corresponds to the population size at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_generation_times">generation_times</code></td>
<td>

<p>Numeric vector, listing the generation time along the edge leading into each clade. Either <code>NULL</code> (all generation times are 1), or a single integer (same generation time for all edges) or a vector of length Ntips+Nnodes, listing generation times for each clade's incoming edge (including the root). The generation time for the root's incoming edge corresponds to the generation time at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_mutation_rates">mutation_rates</code></td>
<td>

<p>Numeric vector, listing the mutation rate (per site and per generation) along the edge leading into each clade. Either <code>NULL</code> (all mutation rates are 1), or a single integer (same mutation rate for all edges) or a vector of length Ntips+Nnodes, listing mutation rates for each clade's incoming edge (including the root). The mutation rate for the root's incoming edge corresponds to the mutation rate at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>). The value of <code>mutation_rates</code> is only relevant if <code>gene_edge_unit</code> is &quot;mutations_expected&quot; or &quot;mutations_random&quot;. Mutation rates represent probabilities, and so they must be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_gene_edge_unit">gene_edge_unit</code></td>
<td>

<p>Character, either &quot;time&quot;, &quot;generations&quot;, &quot;mutations_expected&quot; (expected mean number of mutations per site), or &quot;mutations_random&quot; (randomly generated mean number of mutations per site), specifying how edge lengths in the gene tree should be measured. By default, gene-tree edges are measured in time, as is the case for the input species tree.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_nsites">Nsites</code></td>
<td>

<p>Integer, specifying the number of sites (nucleotides) in the gene. Only relevant when generating edge lengths in terms of random mutation counts, i.e. if <code>gene_edge_unit=="mutations_random"</code>.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_bottleneck_at_speciation">bottleneck_at_speciation</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then all but one children at each node are assumed to have emerged from a single mutant individual, and thus all gene lineages within these bottlenecked species lineages must coalesce at a younger or equal age as the speciation event. Only the first child at each node is excluded from this assumption, corresponding to the &quot;resident population&quot; during the speciation event. This option deviates from the classical MSC model, and is experimental.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_force_coalescence_at_root">force_coalescence_at_root</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all remaining orphan gene lineages that haven't coalesced before reaching the species-tree's root, will be combined at the root (via multiple adjacent bifurcations). If <code>FALSE</code>, coalescence events may extend beyond the species-tree's root into the stem lineage, as long as it takes until all gene lineages have coalesced.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_ploidy">ploidy</code></td>
<td>

<p>Integer, specifying the assumed genetic ploidy, i.e. number of gene copies per individual. Typically 1 for haploids, or 2 for diploids.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_+3A_gene_tip_labels">gene_tip_labels</code></td>
<td>

<p>Character vector specifying tip labels for the gene tree (i.e., for each of the sampled alleles) in the order of the corresponding species tips. Can also be <code>NULL</code>, in which case gene tips will be set to &lt;species_tip_label&gt;.&lt;allele index&gt;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that Kingman's coalescent assumption is met, i.e. that the effective population size is much larger than the number of allele lineages coalescing within any given branch.
</p>
<p>The function assumes that the species tree is a time tree, i.e. with edge lengths given in actual time units. To simulate gene trees in coalescence time units, choose <code>population_sizes</code> and <code>generation_times</code> accordingly (this only makes sense if the product of <code>population_sizes</code> <code class="reqn">\times</code> <code>generation_times</code> is the same everywhere). If <code>species_tree</code> is ultrametric and <code>gene_edge_unit=="time"</code>, then the gene tree will be ultrametric as well.
</p>
<p>If <code>gene_edge_unit</code> is &quot;mutations_random&quot;, then the number of generations elapsed along each time segment is translated into a randomly distributed number of accumulated mutations, according to a binomial distribution where the probability of success is equal to the mutation rate and the number of trials is equal to the number of generations multiplied by <code>Nsites</code>; this number of mutations is averaged across all sites, i.e. the edge lengths in the returned gene tree always refer to the mean number of mutations per site. In cases where the mutation rate varies across the species tree and a single gene edge spans multiple species edges, the gene edge length will be a sum of multiple binomially distributed mutation counts (again, divided by the number of sites), corresponding to the times spent in each species edge.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the gene tree was successfully generated. If <code>FALSE</code>, the only other value returned is <code>error</code>.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>The generated gene tree, of class &quot;phylo&quot;. This tree will be rooted and bifurcating. It is only guaranteed to be ultrametric if <code>species_tree</code> was ultrametric.
</p>
</td></tr>
<tr><td><code>gene_tip2species_tip</code></td>
<td>

<p>Integer vector of length NGtips (where NGtips is the number of tips in the gene tree), mapping gene-tree tips to species-tree tips.
</p>
</td></tr>
<tr><td><code>gene_node2species_edge</code></td>
<td>

<p>Integer vector of length NGnodes (where NGnodes is the number of internal nodes in the gene tree), mapping gene-tree nodes (=coalescence events) to the species-tree edges where the coalescences took place.
</p>
</td></tr>
<tr><td><code>gene_clade_times</code></td>
<td>

<p>Numeric vector of size NGtips+NGnodes, listing the time (total temporal distance from species root) of each tip and node in the gene tree. The units will be the same as the time units assumed for the species tree. Note that this may include negative values, if some gene lineages coalesce at a greater age than the root.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, containing an explanation of the error that occurred. Only included if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. H. Degnan, N. A. Rosenberg (2009). Gene tree discordance, phylogenetic inference and the multispecies coalescent. Trends in Ecology &amp; Evolution. 24:332-340.
</p>
<p>B. Rannala, Z. Yang (2003). Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci. Genetics. 164:1645-1656.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+generate_gene_tree_msc_hgt_dl">generate_gene_tree_msc_hgt_dl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a simple species tree
parameters   = list(birth_rate_factor=1)
Nspecies     = 10
species_tree = generate_random_tree(parameters,max_tips=Nspecies)$tree

# Simulate a haploid gene tree within the species tree
# Assume the same population size and generation time everywhere
# Assume the number of alleles samples per species is poisson-distributed
results = generate_gene_tree_msc(species_tree, 
                                 allele_counts      = rpois(Nspecies,3),
                                 population_sizes   = 1000,
                                 generation_times   = 1,
                                 ploidy             = 1);
if(!results$success){
    # simulation failed
    cat(sprintf("  ERROR: %s\n",results$error))
}else{
    # simulation succeeded
    gene_tree = results$tree
    cat(sprintf("  Gene tree has %d tips\n",length(gene_tree$tip.label)))
}
</code></pre>

<hr>
<h2 id='generate_gene_tree_msc_hgt_dl'>
Generate gene trees based on the multi-species coalescent, horizontal gene transfers and duplications/losses.
</h2><span id='topic+generate_gene_tree_msc_hgt_dl'></span>

<h3>Description</h3>

<p>Generate a random gene tree within a given species timetree, based on an extension of the multi-species coalescent (MSC) model that includes horizontal gene transfers (HGT, incorporation of non-homologous genes as new loci), gene duplication and gene loss. The simulation consists of two phases. In the first phase a random &quot;locus tree&quot; is generated in forward time, according to random HGT, duplication and loss events. In the 2nd phase, alleles picked randomly from each locus are coalesced in backward time according to the multispecies coalescent, an extension of the Wright-Fisher model to multiple species. This function does not account for hybridization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gene_tree_msc_hgt_dl( species_tree,
                        allele_counts               = 1, 
                        population_sizes            = 1,
                        generation_times            = 1,
                        mutation_rates              = 1,
                        HGT_rates                   = 0,
                        duplication_rates           = 0,
                        loss_rates                  = 0,
                        gene_edge_unit              = "time",
                        Nsites                      = 1,
                        bottleneck_at_speciation    = FALSE,
                        force_coalescence_at_root   = FALSE,
                        ploidy                      = 1,
                        HGT_source_by_locus         = FALSE,
                        HGT_only_to_empty_clades    = FALSE,
                        no_loss_before_time         = 0,
                        max_runtime                 = NULL,
                        include_event_times         = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_species_tree">species_tree</code></td>
<td>

<p>Rooted timetree of class &quot;phylo&quot;. The tree can include multifurcations and monofurcations. The tree need not necessarily be ultrametric, i.e. it may include extinct species. Edge lengths are assumed to be in time units.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_allele_counts">allele_counts</code></td>
<td>

<p>Integer vector, listing the number of alleles sampled per species and per locus. This can be interpreted as the number if individual organisms surveyed from each species, assuming that all loci are included once from each individual. The number of tips in the generated gene tree will be equal to the sum of allele counts across all species.
<code>allele_counts</code> can either be <code>NULL</code> (1 allele per species), or a single integer (same number of alleles per species), or a vector of length Ntips listing the numbers of alleles sampled per species. In the latter case, the total number of tips in the returned gene tree will be equal to the sum of entries in <code>allele_counts</code>. Some entries in <code>allele_counts</code> may be zero (no alleles sampled from those species).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_population_sizes">population_sizes</code></td>
<td>

<p>Integer vector, listing the effective population size on the edge leading into each tip/node in the species tree. Either <code>NULL</code> (all population sizes are 1), or a single integer (same population sizes for all edges), or a vector of length Ntips+Nnodes, listing population sizes for each clade's incoming edge (including the root). The population size for the root's incoming edge corresponds to the population size at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_generation_times">generation_times</code></td>
<td>

<p>Numeric vector, listing the generation time along the edge leading into each clade. Either <code>NULL</code> (all generation times are 1), or a single integer (same generation time for all edges) or a vector of length Ntips+Nnodes, listing generation times for each clade's incoming edge (including the root). The generation time for the root's incoming edge corresponds to the generation time at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_mutation_rates">mutation_rates</code></td>
<td>

<p>Numeric vector, listing the probability of mutation per site and per generation along the edge leading into each clade. Either <code>NULL</code> (all mutation rates are 1), or a single integer (same mutation rate for all edges) or a vector of length Ntips+Nnodes, listing mutation rates for each clade's incoming edge (including the root). The mutation rate for the root's incoming edge corresponds to the mutation rate at the tree's stem (only relevant if <code>force_coalescence_at_root=FALSE</code>). The value of <code>mutation_rates</code> is only relevant if <code>gene_edge_unit</code> is &quot;mutations_expected&quot; or &quot;mutations_random&quot;. Mutation rates represent probabilities, and so they must be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_hgt_rates">HGT_rates</code></td>
<td>

<p>Numeric vector, listing horizontal gene transfer rates per lineage per time, along the edge leading into each clade. Either <code>NULL</code> (all HGT rates are 0) or a single integer (same HGT rate for all edges) or a vector of length Ntips+Nnodes, listing HGT rates for each clade's incoming edge (including the root).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_duplication_rates">duplication_rates</code></td>
<td>

<p>Numeric vector, listing gene duplication rates per locus per lineage per time, along the edge leading into each clade. Either <code>NULL</code> (all duplication rates are 0) or a single integer (same duplication rate for all edges) or a vector of length Ntips+Nnodes listing duplication rates for each clade's incoming edge (including the root).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_loss_rates">loss_rates</code></td>
<td>

<p>Numeric vector, listing gene loss rates per locus per lineage per time, along the edge leading into each clade. Either <code>NULL</code> (all loss rates are 0) or a single integer (same loss rate for all edges) or a vector of length Ntips+Nnodes listing loss rates for each clade's incoming edge (including the root).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_gene_edge_unit">gene_edge_unit</code></td>
<td>

<p>Character, either &quot;time&quot;, &quot;generations&quot;, &quot;mutations_expected&quot; (expected mean number of mutations per site), or &quot;mutations_random&quot; (randomly generated mean number of mutations per site), specifying how edge lengths in the gene tree should be measured. By default, gene-tree edges are measured in time, as is the case for the input species tree.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_nsites">Nsites</code></td>
<td>

<p>Integer, specifying the number of sites (nucleotides) in the gene. Only relevant when generating edge lengths in terms of random mutation counts, i.e. if <code>gene_edge_unit=="mutations_random"</code>.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_bottleneck_at_speciation">bottleneck_at_speciation</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then all but one children at each node are assumed to have emerged from a single mutant individual, and thus all gene lineages within these bottlenecked species lineages must coalesce at a younger or equal age as the speciation event. Only the first child at each node is excluded from this assumption, corresponding to the &quot;resident population&quot; during the speciation event. This option deviates from the classical MSC model, and is experimental.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_force_coalescence_at_root">force_coalescence_at_root</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all remaining orphan gene lineages that haven't coalesced before reaching the species-tree's root, will be combined at the root (via multiple adjacent bifurcations). If <code>FALSE</code>, coalescence events may extend beyond the species-tree's root into the stem lineage, as long as it takes until all gene lineages have coalesced.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_ploidy">ploidy</code></td>
<td>

<p>Integer, specifying the assumed genetic ploidy, i.e. number of gene copies per individual. Typically 1 for haploids, or 2 for diploids.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_hgt_source_by_locus">HGT_source_by_locus</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then at any HGT event, every extant locus is chosen as source locus with the same probability (hence the probability of a lineage to be a source is proportional to the number of current loci in it). If <code>FALSE</code>, source lineages are chosen with the same probability (regardless of the number of current loci in them) and the source locus within the source lineage is chosen randomly.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_hgt_only_to_empty_clades">HGT_only_to_empty_clades</code></td>
<td>

<p>Logical, specifying whether HGT transfers only occur into clades with no current loci.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_no_loss_before_time">no_loss_before_time</code></td>
<td>

<p>Numeric, optional time since the root during which no gene losses shall occur (even if <code>loss_rate&gt;0</code>). This option can be used to reduce the probability of an early extinction of the entire gene tree, by giving the gene tree some &quot;startup time&quot; to spread into various species lineages. If zero, gene losses are possible right from the start of the simulation.
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_max_runtime">max_runtime</code></td>
<td>

<p>Numeric, optional maximum computation time (in seconds) to allow for the simulation. Use this to avoid occasional explosions of runtimes, for example due to very large generated trees. Aborted simulations will return with the flag <code>success=FALSE</code> (i.e., no tree is returned at all).
</p>
</td></tr>
<tr><td><code id="generate_gene_tree_msc_hgt_dl_+3A_include_event_times">include_event_times</code></td>
<td>

<p>Logical, specifying whether the times of HGT, duplication and loss events should be returned as well. If these are not needed, then set <code>include_event_times=FALSE</code> for efficiency.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the species tree is a time tree, i.e. with edge lengths given in actual time units. If <code>species_tree</code> is ultrametric and <code>gene_edge_unit=="time"</code>, then the gene tree (but not necessarily the locus tree) will be ultrametric as well. The root of the locus and gene tree coincides with the root of the species tree.
</p>
<p>The meaning of <code>gene_edge_unit</code> is the same as for the function <code><a href="#topic+generate_gene_tree_msc">generate_gene_tree_msc</a></code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the gene tree was successfully generated. If <code>FALSE</code>, the only other value returned is <code>error</code>.
</p>
</td></tr>
<tr><td><code>locus_tree</code></td>
<td>

<p>The generated locus timetree, of class &quot;phylo&quot;. The locus tree describes the genealogy of loci due to HGT, duplication and loss events. Each tip and node of the locus tree is embedded within a specific species edge. For example, tips of the locus tree either coincide with tips of the species tree (if the locus persisted until the species went extinct or until the present) or they correspond to gene loss events. In the absence of any HGT, duplication and loss events, the locus tree will resemble the species tree.
</p>
</td></tr>
<tr><td><code>locus_type</code></td>
<td>

<p>Character vector of length NLtips + NLnodes (where NLtips and NLnodes are the number of tips and nodes in the locus tree, respectively), specifying the type/origin of each tip and node in the locus tree. For nodes, type 'h' corresponds to an HGT event, type 'd' to a duplication event, and type 's' to a speciation event. For tips, type 'l' represents a loss event, and type 't' a terminal locus (i.e., coinciding with a species tip). For example, if the input species tree was an ultrametric tree representing only extant species, then the locus tree tips of type 't' are the loci that could potentially be sampled from those extant species.
</p>
</td></tr>
<tr><td><code>locus2clade</code></td>
<td>

<p>Integer vector of length NLtips + NLnodes, with values in NStips+NSnodes, specifying for every locus tip or node the correspondng &quot;host&quot; species tip or node.
</p>
</td></tr>
<tr><td><code>HGT_times</code></td>
<td>

<p>Numeric vector, listing HGT event times (counted since the root) in ascending order. Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>HGT_source_clades</code></td>
<td>

<p>Integer vector of the same length as <code>HGT_times</code> and with values in 1,..,Ntips+Nnodes, listing the &quot;source&quot; species tip/node of each HGT event (in order of occurrence). The source tip/node is the tip/node from whose incoming edge a locus originated at the time of the transfer. Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>HGT_target_clades</code></td>
<td>

<p>Integer vector of the same length as <code>HGT_times</code> and with values in 1,..,Ntips+Nnodes, listing the &quot;target&quot; species tip/node of each HGT event (in order of occurrence). The target (aka. recipient) tip/node is the tip/node within whose incoming edge a locus was created by the transfer. Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>duplication_times</code></td>
<td>

<p>Numeric vector, listing gene duplication event times (counted since the root) in ascending order. Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>duplication_clades</code></td>
<td>

<p>Integer vector of the same length as <code>duplication_times</code> and with values in 1,..,Ntips+Nnodes, listing the species tip/node in whose incoming edge each duplication event occurred (in order of occurrence). Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>loss_times</code></td>
<td>

<p>Numeric vector, listing gene loss event times (counted since the root) in ascending order. Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>loss_clades</code></td>
<td>

<p>Integer vector of the same length as <code>loss_times</code> and with values in 1,..,Ntips+Nnodes, listing the species tip/node in whose incoming edge each loss event occurred (in order of occurrence). Only included if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>gene_tree</code></td>
<td>

<p>The generated gene tree, of type &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code>gene_tip2species_tip</code></td>
<td>

<p>Integer vector of length NGtips (where NGtips is the number of tips in the gene tree) with values in 1,..,Ntips+Nnodes, mapping gene-tree tips to species-tree tips.
</p>
</td></tr>
<tr><td><code>gene_tip2locus_tip</code></td>
<td>

<p>Integer vector of length NGtips with values in 1,..,NLtips, mapping gene-tree tips to locus-tree tips.
</p>
</td></tr>
<tr><td><code>gene_node2locus_edge</code></td>
<td>

<p>Integer vector of length NGnodes with values in 1,..,NLedges, mapping gene-tree nodes to locus-tree edges.
</p>
</td></tr>
<tr><td><code>gene_clade_times</code></td>
<td>

<p>Numeric vector of size NGtips+NGnodes, listing the time (temporal distance from species root) of each tip and node in the gene tree. The units will be the same as the time units of the species tree. Note that this may include negative values, if some gene lineages coalesce at a greater age than the root.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, containing an explanation of the error that occurred. Only included if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. H. Degnan, N. A. Rosenberg (2009). Gene tree discordance, phylogenetic inference and the multispecies coalescent. Trends in Ecology &amp; Evolution. 24:332-340.
</p>
<p>B. Rannala, Z. Yang (2003). Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci. Genetics. 164:1645-1656.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+generate_gene_tree_msc">generate_gene_tree_msc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a simple species tree
parameters   = list(birth_rate_factor=1)
Nspecies     = 10
species_tree = generate_random_tree(parameters,max_tips=Nspecies)$tree

# Simulate a haploid gene tree within the species tree, including HGTs and gene loss
# Assume the same population size and generation time everywhere
# Assume the number of alleles samples per species is poisson-distributed
results = generate_gene_tree_msc_hgt_dl(species_tree, 
                                        allele_counts      = rpois(Nspecies,3),
                                        population_sizes   = 1000,
                                        generation_times   = 1,
                                        ploidy             = 1,
                                        HGT_rates          = 0.1,
                                        loss_rates         = 0.05);
if(!results$success){
    # simulation failed
    cat(sprintf("  ERROR: %s\n",results$error))
}else{
    # simulation succeeded
    gene_tree = results$gene_tree
    cat(sprintf("  Gene tree has %d tips\n",length(gene_tree$tip.label)))
}
</code></pre>

<hr>
<h2 id='generate_random_tree'>
Generate a tree using a Poissonian speciation/extinction model.
</h2><span id='topic+generate_random_tree'></span>

<h3>Description</h3>

<p>Generate a random timetree via simulation of a Poissonian speciation/extinction (birth/death) process. New species are added (born) by splitting of a randomly chosen extant tip. The tree-wide birth and death rates of tips can each be constant or power-law functions of the number of extant tips. For example,
</p>
<p style="text-align: center;"><code class="reqn">
B = I + F\cdot N^E,
</code>
</p>

<p>where <code class="reqn">B</code> is the tree-wide birth rate (species generation rate), <code class="reqn">I</code> is the intercept, <code class="reqn">F</code> is the power-law factor, <code class="reqn">N</code> is the current number of extant tips and <code class="reqn">E</code> is the power-law exponent. Optionally, the per-capita (tip-specific) birth and death rates can be extended by adding a custom time series provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_tree(parameters           = list(),
                     max_tips             = NULL, 
                     max_extant_tips      = NULL,
                     max_time             = NULL,
                     max_time_eq          = NULL,
                     coalescent           = TRUE,
                     as_generations       = FALSE,
                     no_full_extinction   = TRUE,
                     Nsplits              = 2,
                     added_rates_times    = NULL,
                     added_birth_rates_pc = NULL,
                     added_death_rates_pc = NULL,
                     added_periodic       = FALSE,
                     tip_basename         = "", 
                     node_basename        = NULL,
                     edge_basename        = NULL,
                     include_birth_times  = FALSE,
                     include_death_times  = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_tree_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying the birth-death model parameters, with one or more of the following entries:
</p>
<p><code>birth_rate_intercept</code>: Non-negative number. The intercept of the Poissonian rate at which new species (tips) are added. In units 1/time. By default this is 0.
</p>
<p><code>birth_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which new species (tips) are added. In units 1/time. By default this is 0.
</p>
<p><code>birth_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which new species (tips) are added. Unitless. By default this is 1.
</p>
<p><code>death_rate_intercept</code>:
Non-negative number. The intercept of the Poissonian rate at which extant species (tips) go extinct. In units 1/time. By default this is 0.
</p>
<p><code>death_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which extant species (tips) go extinct. In units 1/time. By default this is 0.
</p>
<p><code>death_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which extant species (tips) go extinct. Unitless. By default this is 1.
</p>
<p><code>resolution</code>:
Non-negative numeric, specifying the resolution (in time units) at which to collapse the final tree by combining closely related tips. Any node whose age is smaller than this threshold, will be represented by a single tip. Set <code>resolution=0</code> to not collapse tips (default).
</p>
<p><code>rarefaction</code>:
Numeric between 0 and 1. Rarefaction to be applied to the final tree (fraction of random tips kept in the tree). Note that if <code>coalescent==FALSE</code>, rarefaction may remove both extant as well as extinct clades. Set <code>rarefaction=1</code> to not perform any rarefaction (default).
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_max_tips">max_tips</code></td>
<td>

<p>Integer, maximum number of tips of the tree to be generated. If <code>coalescent=TRUE</code>, this refers to the number of extant tips. Otherwise, it refers to the number of extinct + extant tips. If <code>NULL</code> or &lt;=0, this halting condition is ignored.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_max_extant_tips">max_extant_tips</code></td>
<td>

<p>Integer, maximum number of extant lineages allowed at any moment during the simulation. If this number is reached, the simulation is halted. If <code>NULL</code> or &lt;=0, this halting condition is ignored.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_max_time">max_time</code></td>
<td>

<p>Numeric, maximum duration of the simulation. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_max_time_eq">max_time_eq</code></td>
<td>

<p>Maximum duration of the simulation, counting from the first point at which speciation/extinction equilibrium is reached, i.e. when (birth rate - death rate) changed sign for the first time. If <code>NULL</code> or &lt;0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, specifying whether only the coalescent tree (i.e. the tree spanning the extant tips) should be returned. If <code>coalescent==FALSE</code> and the death rate is non-zero, then the tree may include non-extant tips (i.e. tips whose distance from the root is less than the total time of evolution). In that case, the tree will not be ultrametric.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_as_generations">as_generations</code></td>
<td>

<p>Logical, specifying whether edge lengths should correspond to generations. If FALSE, then edge lengths correspond to time.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_no_full_extinction">no_full_extinction</code></td>
<td>

<p>Logical, specifying whether to prevent complete extinction of the tree. Full extinction is prevented by temporarily disabling extinctions whenever the number of extant tips is 1. Note that, strictly speaking, the trees generated do not exactly follow the proper probability distribution when <code>no_full_extinction</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_nsplits">Nsplits</code></td>
<td>

<p>Integer greater than 1. Number of child-tips to generate at each diversification event. If set to 2, the generated tree will be bifurcating. If &gt;2, the tree will be multifurcating.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_added_rates_times">added_rates_times</code></td>
<td>

<p>Numeric vector, listing time points (in ascending order) for the custom per-capita birth and/or death rates time series (see <code>added_birth_rates_pc</code> and <code>added_death_rates_pc</code> below). Can also be <code>NULL</code>, in which case the custom time series are ignored.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_added_birth_rates_pc">added_birth_rates_pc</code></td>
<td>

<p>Numeric vector of the same size as <code>added_rates_times</code>, listing per-capita birth rates to be added to the power law part. Can also be <code>NULL</code>, in which case this option is ignored and birth rates are purely described by the power law.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_added_death_rates_pc">added_death_rates_pc</code></td>
<td>

<p>Numeric vector of the same size as <code>added_rates_times</code>, listing per-capita death rates to be added to the power law part. Can also be <code>NULL</code>, in which case this option is ignored and death rates are purely described by the power law.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_added_periodic">added_periodic</code></td>
<td>

<p>Logical, indicating whether <code>added_birth_rates_pc</code> and <code>added_death_rates_pc</code> should be extended periodically if needed (i.e. if not defined for the entire simulation time). If <code>FALSE</code>, added birth &amp; death rates are extended with zeros.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_edge_basename">edge_basename</code></td>
<td>

<p>Character. Prefix to be used for edge labels (e.g. &quot;edge.&quot;). Edge labels (if included) are stored in the character vector <code>edge.label</code>. If <code>NULL</code>, no edge labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_include_birth_times">include_birth_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of speciation events (in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="generate_random_tree_+3A_include_death_times">include_death_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of extinction events (in order of occurrence) will also be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>max_time==NULL</code>, then the returned tree will always contain <code>max_tips</code> tips. In particular, if at any moment during the simulation the tree only includes a single extant tip, the death rate is temporarily set to zero to prevent the complete extinction of the tree. If <code>max_tips==NULL</code>, then the simulation is ran as long as specified by <code>max_time</code>. If neither <code>max_time</code> nor <code>max_tips</code> is <code>NULL</code>, then the simulation halts as soon as the time exceeds <code>max_time</code> or the number of tips (extant tips if <code>coalescent</code> is <code>TRUE</code>) exceeds <code>max_tips</code>. If <code>max_tips!=NULL</code> and <code>Nsplits&gt;2</code>, then the last diversification even may generate fewer than <code>Nsplits</code> children, in order to keep the total number of tips within the specified limit.
</p>
<p>If <code>rarefaction&lt;1</code> and <code>resolution&gt;0</code>, collapsing of closely related tips (at the resolution specified) takes place prior to rarefaction (i.e., subsampling applies to the already collapsed tips).
</p>
<p>Both the per-capita birth and death rates can be made into completely arbitrary functions of time, by setting all power-law coefficients to zero and providing custom time series <code>added_birth_rates_pc</code> and <code>added_death_rates_pc</code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the tree was successfully generated. If <code>FALSE</code>, the only other value returned is <code>error</code>.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted bifurcating (if <code>Nsplits==2</code>) or multifurcating (if <code>Nsplits&gt;2</code>) tree of class &quot;phylo&quot;, generated according to the specified birth/death model. If <code>coalescent==TRUE</code> or if all death rates are zero, and only if <code>as_generations==FALSE</code>, then the tree will be ultrametric. If <code>as_generations==TRUE</code> and <code>coalescent==FALSE</code>, all edges will have unit length.
</p>
</td></tr>
<tr><td><code>root_time</code></td>
<td>

<p>Numeric, giving the time at which the tree's root was first split during the simulation. Note that if <code>coalescent==TRUE</code>, this may be later than the first speciation event during the simulation.
</p>
</td></tr>
<tr><td><code>final_time</code></td>
<td>

<p>Numeric, giving the final time at the end of the simulation. Note that if <code>coalescent==TRUE</code>, then this may be greater than the total time span of the tree (since the root of the coalescent tree need not correspond to the first speciation event).
</p>
</td></tr>
<tr><td><code>root_age</code></td>
<td>

<p>Numeric, giving the age (time before present) at the tree's root. This is equal to <code>final_time</code>-<code>root_time</code>.
</p>
</td></tr>
<tr><td><code>equilibrium_time</code></td>
<td>

<p>Numeric, giving the first time where the sign of (death rate - birth rate) changed from the beginning of the simulation, i.e. when speciation/extinction equilibrium was reached. May be infinite if the simulation stoped before reaching this point.
</p>
</td></tr>
<tr><td><code>extant_tips</code></td>
<td>

<p>Integer vector, listing indices of extant tips in the tree. If <code>coalescent==TRUE</code>, all tips will be extant.
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Total number of birth events (speciations) that occurred during tree growth. This may be lower than the total number of tips in the tree if death rates were non-zero and <code>coalescent==TRUE</code>, or if <code>Nsplits&gt;2</code>.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Total number of deaths (extinctions) that occurred during tree growth.
</p>
</td></tr>
<tr><td><code>Ncollapsed</code></td>
<td>

<p>Number of tips removed from the tree while collapsing at the resolution specified.
</p>
</td></tr>
<tr><td><code>Nrarefied</code></td>
<td>

<p>Number of tips removed from the tree due to rarefaction.
</p>
</td></tr>
<tr><td><code>birth_times</code></td>
<td>

<p>Numeric vector, listing the times of speciation events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root.
</p>
</td></tr>
<tr><td><code>death_times</code></td>
<td>

<p>Numeric vector, listing the times of extinction events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, containing an explanation of ther error that occurred. Only included if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. J. Aldous (2001). Stochastic models and descriptive statistics for phylogenetic trees, from Yule to today. Statistical Science. 16:23-34.
</p>
<p>M. Steel and A. McKenzie (2001). Properties of phylogenetic trees generated by Yule-type speciation models. Mathematical Biosciences. 170:91-112.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple speciation model
parameters = list(birth_rate_intercept=1)
tree = generate_random_tree(parameters,max_tips=100)$tree

# Exponential growth rate model
parameters = list(birth_rate_factor=1)
tree = generate_random_tree(parameters,max_tips=100)$tree
</code></pre>

<hr>
<h2 id='generate_tree_hbd_reverse'>
Generate a tree from a birth-death model in reverse time.
</h2><span id='topic+generate_tree_hbd_reverse'></span>

<h3>Description</h3>

<p>Generate an ultrametric timetree (comprising only extant lineages) in reverse time (from present back to the root) based on the homogenous birth-death (HBD; Morlon et al., 2011) model, conditional on a specific number of extant species sampled and (optionally) conditional on the crown age or stem age. 
</p>
<p>The probability distribution of such trees only depends on the congruence class of birth-death models (e.g., as specified by the pulled speciation rate) but not on the precise model within a congruence class (Louca and Pennell, 2019). Hence, in addition to allowing specification of speciation and extinction rates, this function can alternatively simulate trees simply based on some pulled speciation rate (PSR), or based on some pulled diversification rate (PDR) and the product <code class="reqn">\rho\lambda_o</code> (present-day sampling fraction times present-day speciation rate). 
</p>
<p>This function can be used to generate bootstrap samples after fitting an HBD model or HBD congruence class to a real timetree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_tree_hbd_reverse( Ntips,
                           stem_age         = NULL,
                           crown_age        = NULL,
                           age_grid         = NULL,
                           lambda           = NULL,
                           mu               = NULL,
                           rho              = NULL,
                           PSR              = NULL,
                           PDR              = NULL,
                           rholambda0       = NULL,
                           force_max_age    = Inf,
                           splines_degree   = 1,
                           relative_dt      = 1e-3,
                           Ntrees           = 1,
                           tip_basename     = "",
                           node_basename    = NULL,
                           edge_basename    = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_tree_hbd_reverse_+3A_ntips">Ntips</code></td>
<td>

<p>Number of tips in the tree, i.e. number of extant species sampled at present day.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_stem_age">stem_age</code></td>
<td>

<p>Numeric, optional stem age on which to condition the tree. If NULL or &lt;=0, the tree is not conditioned on the stem age.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_crown_age">crown_age</code></td>
<td>

<p>Numeric, optional crown age (aka. root age or MRCA age) on which to condition the tree. If NULL or &lt;=0, the tree is not conditioned on the crown age. If both <code>stem_age</code> and <code>crown_age</code> are specified, only the crown age is used; in that case for consistency <code>crown_age</code> must not be greater than <code>stem_age</code>.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing discrete ages (time before present) on which the PSR is specified. Listed ages must be strictly increasing, and should cover at least the present day (age 0) as well as a sufficient duration into the past. If conditioning on the stem or crown age, that age must also be covered by <code>age_grid</code>. When not conditioning on crown nor stem age, and the generated tree ends up extending beyond the last time point in <code>age_grid</code>, the PSR will be extrapolated as a constant (with value equal to the last value in <code>PSR</code>) as necessary. <code>age_grid</code> also be <code>NULL</code> or a vector of size 1, in which case the PSR is assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing speciation rates (<code class="reqn">\lambda</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Speciation rates must be non-negative, and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be <code>NULL</code>, in which case either <code>PSR</code>, or <code>PDR</code> and <code>rholambda0</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing extinction rates (<code class="reqn">\mu</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Extinction rates must be non-negative, and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be <code>NULL</code>, in which case either <code>PSR</code>, or <code>PDR</code> and <code>rholambda0</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_rho">rho</code></td>
<td>

<p>Numeric, sampling fraction at present day (fraction of extant species included in the tree). Can also be <code>NULL</code>, in which case either <code>PSR</code>, or <code>PDR</code> and <code>rholambda0</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_psr">PSR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing pulled speciation rates (<code class="reqn">\lambda_p</code>, in units 1/time) at the ages listed in <code>age_grid</code>. The PSR must be non-negative (and strictly positive almost everywhere), and is assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be <code>NULL</code>, in which case either <code>lambda</code> and <code>mu</code> and <code>rho</code>, or <code>PDR</code> and <code>rholambda0</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_pdr">PDR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing pulled diversification rates (<code class="reqn">r_p</code>, in units 1/time) at the ages listed in <code>age_grid</code>. The PDR is assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Can also be <code>NULL</code>, in which case either <code>lambda</code> and <code>mu</code> and <code>rho</code>, or <code>PSR</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_rholambda0">rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the product <code class="reqn">\rho\lambda_o</code> (present-day species sampling fraction times present-day speciation rate). Can also be <code>NULL</code>, in which case <code>PSR</code> must be provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_force_max_age">force_max_age</code></td>
<td>

<p>Numeric, specifying an optional maximum allowed age for the tree's root. If the tree ends up expanding past that age, all remaining lineages are forced to coalesce at that age. This is not statistically consistent with the provided HBD model (in fact it corresponds to a modified HBD model with a spike in the PSR at that time). This argument merely provides a way to prevent excessively large trees if the PSR is close to zero at older ages and when not conditioning on the stem nor crown age, while still keeping the original statistical properties at younger ages. To disable this feature set <code>force_max_age</code> to <code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided rates <code>PSR</code>, <code>PDR</code>, <code>lambda</code>, <code>mu</code> and <code>rho</code> between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided rates are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> the rates are interpreted as quadratic splines; if <code>splines_degree==3</code> the rates are interpreted as cubic splines. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on. If your <code>age_grid</code> is fine enough, then <code>splines_degree=1</code> is usually sufficient.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_ntrees">Ntrees</code></td>
<td>

<p>Integer, number of trees to generate. The computation time per tree is lower if you generate multiple trees at once.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbd_reverse_+3A_edge_basename">edge_basename</code></td>
<td>

<p>Character. Prefix to be used for edge labels (e.g. &quot;edge.&quot;). Edge labels (if included) are stored in the character vector <code>edge.label</code>. If <code>NULL</code>, no edge labels will be included in the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires that the BD model, or the BD congruence class (Louca and Pennell, 2019), is specified using one of the following sets of arguments:
</p>

<ul>
<li><p> Using the speciation rate <code class="reqn">\lambda</code>, the extinctin rate <code class="reqn">\mu</code>, and the present-day sampling fraction <code class="reqn">\rho</code>.
</p>
</li>
<li><p> Using the pulled diversification rate (PDR) and the product <code class="reqn">\rho\lambda(0)</code>. The PDR is defined as <code class="reqn">r_p=\lambda-\mu+\frac{1}{\lambda}\frac{d\lambda}{d\tau}</code>, where <code class="reqn">\tau</code> is age (time before present), <code class="reqn">\lambda(\tau)</code> is the speciation rate at age <code class="reqn">\tau</code> and <code class="reqn">\mu(\tau)</code> is the extinction rate.
</p>
</li>
<li><p> Using the pulled speciation rate (PSR). The PSR (<code class="reqn">\lambda_p</code>) is defined as <code class="reqn">\lambda_p(\tau) = \lambda(\tau)\cdot\Phi(\tau)</code>, where and <code class="reqn">\Phi(\tau)</code> is the probability that a lineage extant at age <code class="reqn">\tau</code> will survive until the present and be represented in the tree. 
</p>
</li></ul>

<p>Concurrently using/combining more than one the above parameterization methods is not supported.
</p>
<p>Either the PSR, or the PDR and <code>rholambda0</code>, provide sufficient information to fully describe the probability distribution of the tree (Louca and Pennell, 2019).
For example, the probability distribution of generated trees only depends on the PSR, and not on the specific speciation rate <code class="reqn">\lambda</code> or extinction rate <code class="reqn">\mu</code> (various combinations of <code class="reqn">\lambda</code> and <code class="reqn">\mu</code> can yield the same PSR; Louca and Pennell, 2019). To calculate the PSR and PDR for any arbitrary <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho</code> you can use the function <code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>.
</p>
<p>When not conditioning on the crown age, the age of the root of the generated tree will be stochastic (i.e., non-fixed). This function then assumes a uniform prior distribution (in a sufficiently large time interval) for the origin of the forward HBD process that would have generated the tree, based on a generalization of the EBDP algorithm provided by (Stadler, 2011). When conditioning on stem or crown age, this function is based on the algorithm proposed by Hoehna (2013, Eq. 8).
</p>
<p>Note that HBD trees can also be generated using the function <code><a href="#topic+generate_random_tree">generate_random_tree</a></code>. That function, however, generates trees in forward time, and hence when conditioning on the final number of tips the total duration of the simulation is unpredictable; consequently, speciation and extinction rates cannot be specified as functions of &quot;age&quot; (time before present). The function presented here provides a means to generate trees with a fixed number of tips, while specifying <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\lambda_p</code> or <code class="reqn">r_p</code> as functions of age (time before present).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) providing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>trees</code></td>
<td>
<p>A list of length <code>Ntrees</code>, listing the generated trees. Each tree will be an ultrametric timetree of class &quot;phylo&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>T. Stadler (2011). Simulating trees with a fixed number of extant species. Systematic Biology. 60:676-684.
</p>
<p>S. Hoehna (2013). Fast simulation of reconstructed phylogenies under global time-dependent birth-death processes. Bioinformatics. 29:1367-1374.
</p>
<p>S. Louca and M. W. Pennell (in review as of 2019). Phylogenies of extant species are consistent with an infinite array of diversification histories.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>,
<code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>,
<code><a href="#topic+generate_random_tree">generate_random_tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: Generate trees based on some speciation and extinction rate
# In this example we assume an exponentially decreasing speciation rate
#   and a temporary mass extinction event

# define parameters
age_grid = seq(0,100,length.out=1000)
lambda   = 0.1 + exp(-0.5*age_grid)
mu       = 0.05 + exp(-(age_grid-5)^2)
rho      = 0.5 # species sampling fraction at present-day

# generate a tree with 100 tips and no specific crown or stem age
sim = generate_tree_hbd_reverse(Ntips       = 100, 
                                age_grid    = age_grid, 
                                lambda      = lambda,
                                mu          = mu,
                                rho         = rho)
if(!sim$success){
    cat(sprintf("Tree generation failed: %s\n",sim$error))
}else{
    cat(sprintf("Tree generation succeeded\n"))
    tree = sim$trees[[1]]
}


########################
# EXAMPLE 2: Generate trees based on the pulled speciation rate
# Here we condition the tree on some fixed crown (MRCA) age

# specify the PSR on a sufficiently fine and wide age grid
age_grid  = seq(0,1000,length.out=10000)
PSR       = 0.1+exp(-0.1*age_grid) # exponentially decreasing PSR

# generate a tree with 100 tips and MRCA age 10
sim = generate_tree_hbd_reverse(Ntips       = 100, 
                                age_grid    = age_grid, 
                                PSR         = PSR, 
                                crown_age   = 10)
if(!sim$success){
    cat(sprintf("Tree generation failed: %s\n",sim$error))
}else{
    cat(sprintf("Tree generation succeeded\n"))
    tree = sim$trees[[1]]
}
</code></pre>

<hr>
<h2 id='generate_tree_hbds'>
Generate a tree from a birth-death-sampling model in forward time.
</h2><span id='topic+generate_tree_hbds'></span>

<h3>Description</h3>

<p>Generate a random timetree according to a homogenous birth-death-sampling model with arbitrary time-varying speciation/extinction/sampling rates. Lineages split (speciate) or die (go extinct) at Poissonian rates and independently of each other. Lineages are sampled continuously (i.e., at Poissonian rates) in time and/or during concentrated sampling attempts (i.e., at specific time points). Sampled lineages are assumed to continue in the pool of extant lineages at some given &quot;retention probability&quot;. The final tree can be restricted to sampled lineages only, but may optionally include extant (non-sampled) as well as extinct lineages. Speciation, extinction and sampling rates as well as retention probabilities may depend on time. This function may be used to simulate trees commonly encountered in viral epidemiology, where sampled patients are assumed to exit the pool of infectious individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_tree_hbds( max_sampled_tips             = NULL, 
                    max_sampled_nodes            = NULL, 
                    max_extant_tips              = NULL,
                    max_extinct_tips             = NULL,
                    max_tips                     = NULL,
                    max_time                     = NULL,
                    include_extant               = FALSE,
                    include_extinct              = FALSE,
                    as_generations               = FALSE,
                    time_grid                    = NULL,
                    lambda                       = NULL,
                    mu                           = NULL,
                    psi                          = NULL,
                    kappa                        = NULL,
                    splines_degree               = 1,
                    CSA_times                    = NULL,
                    CSA_probs                    = NULL,
                    CSA_kappas                   = NULL,
                    no_full_extinction           = FALSE,
                    max_runtime                  = NULL,
                    tip_basename                 = "",
                    node_basename                = NULL,
                    edge_basename                = NULL,
                    include_birth_times          = FALSE,
                    include_death_times          = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_tree_hbds_+3A_max_sampled_tips">max_sampled_tips</code></td>
<td>

<p>Integer, maximum number of sampled tips. The simulation is halted once this number is reached. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_sampled_nodes">max_sampled_nodes</code></td>
<td>

<p>Integer, maximum number of sampled nodes, i.e., of lineages that were sampled but kept in the pool of extant lineages. The simulation is halted once this number is reached. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_extant_tips">max_extant_tips</code></td>
<td>

<p>Integer, maximum number of extant tips. The simulation is halted once the number of concurrently extant tips reaches this threshold. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_extinct_tips">max_extinct_tips</code></td>
<td>

<p>Integer, maximum number of extant tips. The simulation is halted once this number is reached. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_tips">max_tips</code></td>
<td>

<p>Integer, maximum number of tips (extant+extinct+sampled). The simulation is halted once this number is reached. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_time">max_time</code></td>
<td>

<p>Numeric, maximum duration of the simulation. If <code>NULL</code> or &lt;=0, this halting criterion is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_include_extant">include_extant</code></td>
<td>

<p>Logical, specifying whether to include extant tips (i.e., neither extinct nor sampled) in the final tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_include_extinct">include_extinct</code></td>
<td>

<p>Logical, specifying whether to include extant tips (i.e., neither extant nor sampled) in the final tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_as_generations">as_generations</code></td>
<td>

<p>Logical, specifying whether edge lengths should correspond to generations. If <code>FALSE</code>, then edge lengths correspond to time. If <code>TRUE</code>, then the time between two subsequent events (speciation, extinction, sampling) is counted as &quot;one generation&quot;.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_time_grid">time_grid</code></td>
<td>

<p>Numeric vector, specifying time points (in ascending order) on which the rates <code>lambda</code>, <code>mu</code> and <code>psi</code> are provided. Rates are interpolated polynomially between time grid points as needed (according to splines_degree).
The time grid should generally cover the maximum possible simulation time, otherwise it will be polynomially extrapolated as needed.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>time_grid</code> (or size 1 if <code>time_grid==NULL</code>), listing per-lineage speciation (birth) rates (<code class="reqn">\lambda</code>, in units 1/time) at the times listed in <code>time_grid</code>. Speciation rates must be non-negative, and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be a single numeric, in which case <code class="reqn">\lambda</code> is assumed to be constant over time.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>time_grid</code> (or size 1 if <code>time_grid==NULL</code>), listing per-lineage extinction (death) rates (<code class="reqn">\mu</code>, in units 1/time) at the times listed in <code>time_grid</code>. Extinction rates must be non-negative, and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be a single numeric, in which case <code class="reqn">\mu</code> is assumed to be constant over time. If omitted, the extinction rate is assumed to be zero.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_psi">psi</code></td>
<td>

<p>Numeric vector, of the same size as <code>time_grid</code> (or size 1 if <code>time_grid==NULL</code>), listing per-lineage sampling rates (<code class="reqn">\psi</code>, in units 1/time) at the times listed in <code>time_grid</code>. Sampling rates must be non-negative, and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be a single numeric, in which case <code class="reqn">\psi</code> is assumed to be constant over time. If omitted, the continuous sampling rate is assumed to be zero.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_kappa">kappa</code></td>
<td>

<p>Numeric vector, of the same size as <code>time_grid</code> (or size 1 if <code>time_grid==NULL</code>), listing retention probabilities (<code class="reqn">\kappa</code>, unitless) of continuously (Poissonian) sampled lineages at the times listed in <code>time_grid</code>. Retention probabilities must be true probabilities (i.e., between 0 and 1), and are assumed to vary as a spline between grid points (see argument <code>splines_degree</code>). Can also be a single numeric, in which case <code class="reqn">\kappa</code> is assumed to be constant over time. If omitted, the retention probability is assumed to be zero (a common assumption in epidemiology).
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided <code>lambda</code>, <code>mu</code> and <code>psi</code> between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided <code>lambda</code>, <code>mu</code> and <code>psi</code> are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> the <code>lambda</code>, <code>mu</code> and <code>psi</code> are interpreted as quadratic splines; if <code>splines_degree==3</code> the <code>lambda</code>, <code>mu</code> and <code>psi</code> is interpreted as cubic splines. If your <code>age_grid</code> is fine enough, then <code>splines_degree=1</code> is usually sufficient.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_csa_times">CSA_times</code></td>
<td>

<p>Optional numeric vector, listing times of concentrated sampling attempts, in ascending order. Concentrated sampling is performed in addition to any continuous (Poissonian) sampling specified by <code>psi</code>.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_csa_probs">CSA_probs</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_times</code>, listing sampling probabilities at each concentrated sampling time. Note that in contrast to the sampling rates <code>psi</code>, the <code>CSA_probs</code> are interpreted as probabilities and must thus be between 0 and 1. <code>CSA_probs</code> must be provided if and only if <code>CSA_times</code> is provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_csa_kappas">CSA_kappas</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_times</code>, listing sampling retention probabilities at each concentrated sampling time, i.e. the probability at which a sampled lineage is kept in the pool of extant lineages. Note that the <code>CSA_kappas</code> are probabilities and must thus be between 0 and 1. <code>CSA_kappas</code> must be provided if and only if <code>CSA_times</code> is provided.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_no_full_extinction">no_full_extinction</code></td>
<td>

<p>Logical, specifying whether to prevent complete extinction of the tree. Full extinction is prevented by temporarily disabling extinctions whenever the number of extant tips is 1. Note that, strictly speaking, the trees generated do not exactly follow the proper probability distribution when <code>no_full_extinction</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_max_runtime">max_runtime</code></td>
<td>

<p>Numeric, optional maximum computation time (in seconds) to allow for the simulation. Use this to avoid occasional explosions of runtimes, for example due to very large generated trees. Aborted simulations will return with the flag <code>success=FALSE</code> (i.e., no tree is returned at all).
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_edge_basename">edge_basename</code></td>
<td>

<p>Character. Prefix to be used for edge labels (e.g. &quot;edge.&quot;). Edge labels (if included) are stored in the character vector <code>edge.label</code>. If <code>NULL</code>, no edge labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_include_birth_times">include_birth_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of speciation events (in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="generate_tree_hbds_+3A_include_death_times">include_death_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of extinction events (in order of occurrence) will also be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation proceeds in forward time, starting with a single root. Speciation/extinction and continuous (Poissonian) sampling events are drawn at exponentially distributed time steps, according to the rates specified by <code>lambda</code>, <code>mu</code> and <code>psi</code>. Sampling also occurs at the optional <code>CSA_times</code>. Only extant lineages are sampled at any time point, and sampled lineages are removed from the pool of extant lineages at probability 1-<code>kappa</code>.
</p>
<p>The simulation halts as soon as one of the halting criteria are met, as specified by the options <code>max_sampled_tips</code>, <code>max_sampled_nodes</code>, <code>max_extant_tips</code>, <code>max_extinct_tips</code>, <code>max_tips</code> and <code>max_time</code>, or if no extant tips remain, whichever occurs first. Note that in some scenarios (e.g., if extinction rates are very high) the simulation may halt too early and the generated tree may only contain a single tip (i.e., the root lineage); in that case, the simulation will return an error (see return value <code>success</code>).
</p>
<p>The function returns a single generated tree, as well as supporting information such as which tips are extant, extinct or sampled.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) providing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>The generated timetree, of class &quot;phylo&quot;. Note that this tree need not be ultrametric, for example if sampling occurs at multiple time points.
</p>
</td></tr>
<tr><td><code>root_time</code></td>
<td>

<p>Numeric, giving the time at which the tree's root was first split during the simulation. Note that this may be greater than 0, i.e., if the tips of the final tree do not coalesce all the way back to the simulation's start.
</p>
</td></tr>
<tr><td><code>final_time</code></td>
<td>

<p>Numeric, giving the final time at the end of the simulation.
</p>
</td></tr>
<tr><td><code>root_age</code></td>
<td>

<p>Numeric, giving the age (time before present) at the tree's root. This is equal to <code>final_time</code>-<code>root_time</code>.
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Integer, the total number of speciation (birth) events that occured during the simulation.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Integer, the total number of extinction (death) events that occured during the simulation.
</p>
</td></tr>
<tr><td><code>Nsamplings</code></td>
<td>

<p>Integer, the total number of sampling events that occured during the simulation.
</p>
</td></tr>
<tr><td><code>Nretentions</code></td>
<td>

<p>Integer, the total number of sampling events that occured during the simulation and for which lineages were kept in the pool of extant lineages.
</p>
</td></tr>
<tr><td><code>sampled_clades</code></td>
<td>

<p>Integer vector, specifying indices (from 1 to Ntips+Nnodes) of sampled tips and nodes in the final tree (regardless of whether their lineages were subsequently retained or removed from the pool).
</p>
</td></tr>
<tr><td><code>retained_clades</code></td>
<td>

<p>Integer vector, specifying indices (from 1 to Ntips+Nnodes) of sampled tips and nodes in the final tree that were retained, i.e., not removed from the pool following sampling.
</p>
</td></tr>
<tr><td><code>extant_tips</code></td>
<td>

<p>Integer vector, specifying indices (from 1 to Ntips) of extant (non-sampled and non-extinct) tips in the final tree. Will be empty if <code>include_extant==FALSE</code>.
</p>
</td></tr>
<tr><td><code>extinct_tips</code></td>
<td>

<p>Integer vector, specifying indices (from 1 to Ntips) of extinct (non-sampled and non-extant) tips in the final tree. Will be empty if <code>include_extinct==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler (2010). Sampling-through-time in birth&ndash;death trees. Journal of Theoretical Biology. 267:396-404.
</p>
<p>T. Stadler et al. (2013). Birth&ndash;death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV). PNAS. 110:228-233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_tree_hbd_reverse">generate_tree_hbd_reverse</a></code>,
<code><a href="#topic+generate_gene_tree_msc">generate_gene_tree_msc</a></code>,
<code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+fit_hbds_model_parametric">fit_hbds_model_parametric</a></code>,
<code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define time grid on which lambda, mu and psi will be specified
time_grid = seq(0,100,length.out=1000)

# specify the time-dependent extinction rate mu on the time-grid
mu_grid = 0.5*time_grid/(10+time_grid)

# define additional concentrated sampling attempts
CSA_times  = c(5,7,9)
CSA_probs  = c(0.5, 0.5, 0.5)
CSA_kappas = c(0.2, 0.1, 0.1)

# generate tree with a constant speciation &amp; sampling rate,
# time-variable extinction rate and additional discrete sampling points
# assuming that all continuously sampled lineages are removed from the pool
simul = generate_tree_hbds( max_time        = 10,
                            include_extant  = FALSE,
                            include_extinct = FALSE,
                            time_grid       = time_grid,
                            lambda          = 1,
                            mu              = mu_grid,
                            psi             = 0.1,
                            kappa           = 0,
                            CSA_times       = CSA_times,
                            CSA_probs       = CSA_probs,
                            CSA_kappas      = CSA_kappas);
if(!simul$success){
    cat(sprintf("ERROR: Could not simulate tree: %s\n",simul$error))
}else{
    # simulation succeeded. print some basic info about the generated tree
    tree = simul$tree
    cat(sprintf("Generated tree has %d tips\n",length(tree$tip.label)))
}
</code></pre>

<hr>
<h2 id='generate_tree_with_evolving_rates'>
Generate a random tree with evolving speciation/extinction rates.
</h2><span id='topic+generate_tree_with_evolving_rates'></span>

<h3>Description</h3>

<p>Generate a random phylogenetic tree via simulation of a Poissonian speciation/extinction (birth/death) process. New species are added (born) by splitting of a randomly chosen extant tip. Per-capita birth and death rates (aka. speciation and extinction rates) evolve under some stochastic process (e.g. Brownian motion) along each edge. Thus, the probability rate of a tip splitting or going extinct depends on the tip, with closely related tips having more similar per-capita birth and death rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_tree_with_evolving_rates(parameters           = list(),
                                  rate_model           = 'BM',
                                  max_tips             = NULL, 
                                  max_time             = NULL,
                                  max_time_eq          = NULL,
                                  coalescent           = TRUE,
                                  as_generations       = FALSE,
                                  tip_basename         = "", 
                                  node_basename        = NULL,
                                  include_event_times  = FALSE,
                                  include_rates        = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying the model parameters for the evolving birth/death rates. The precise entries expected depend on the chosen <code>rate_model</code> (see details below).
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_rate_model">rate_model</code></td>
<td>

<p>Character, specifying the model for the evolving per-capita birth/death rates. Must be one of the following: 'BM' (Brownian motion constrained to a finite interval via reflection), 'Mk' (discrete-state continuous-time Markov chain with fixed transition rates).
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_max_tips">max_tips</code></td>
<td>

<p>Maximum number of tips of the tree to be generated. If <code>coalescent=TRUE</code>, this refers to the number of extant tips. Otherwise, it refers to the number of extinct + extant tips. If <code>NULL</code> or &lt;=0, the number of tips is unlimited (so be careful).
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_max_time">max_time</code></td>
<td>

<p>Maximum duration of the simulation. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_max_time_eq">max_time_eq</code></td>
<td>

<p>Maximum duration of the simulation, counting from the first point at which speciation/extinction equilibrium is reached, i.e. when (birth rate - death rate) changed sign for the first time. If <code>NULL</code> or &lt;0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, specifying whether only the coalescent tree (i.e. the tree spanning the extant tips) should be returned. If <code>coalescent==FALSE</code> and the death rate is non-zero, then the tree may include non-extant tips (i.e. tips whose distance from the root is less than the total time of evolution). In that case, the tree will not be ultrametric.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_as_generations">as_generations</code></td>
<td>

<p>Logical, specifying whether edge lengths should correspond to generations. If FALSE, then edge lengths correspond to time.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_include_event_times">include_event_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of speciation and extinction events (each in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="generate_tree_with_evolving_rates_+3A_include_rates">include_rates</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the bper-capita birth &amp; death rates of all tips and nodes will also be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>max_time==NULL</code>, then the returned tree will always contain <code>max_tips</code> tips. In particular, if at any moment during the simulation the tree only includes a single extant tip, the death rate is temporarily set to zero to prevent the complete extinction of the tree. If <code>max_tips==NULL</code>, then the simulation is ran as long as specified by <code>max_time</code>. If neither <code>max_time</code> nor <code>max_tips</code> is <code>NULL</code>, then the simulation halts as soon as the time exceeds <code>max_time</code> or the number of tips (extant tips if <code>coalescent</code> is <code>TRUE</code>) exceeds <code>max_tips</code>.
</p>
<p>If <code>rate_model=='BM'</code>, then per-capita birth rates (speciation rates) and per-capita death rates (extinction rates) evolve according to Brownian Motion, constrained to a finite interval via reflection. Note that speciation and extinction rates are only updated at branching points, i.e. during speciation events, while waiting times until speciation/extinction are based on rates at the previous branching point. The argument <code>parameters</code> should be a named list including one or more of the following elements:
</p>

<ul>
<li><p><code>birth_rate_diffusivity</code>: Non-negative number. Diffusivity constant for the Brownian motion model of the evolving per-capita birth rate. In units 1/time^3. See <code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code> for an explanation of the diffusivity parameter.
</p>
</li>
<li><p><code>min_birth_rate_pc</code>:
Non-negative number. The minimum allowed per-capita birth rate of a clade. In units 1/time. By default this is 0.
</p>
</li>
<li><p><code>max_birth_rate_pc</code>:
Non-negative number. The maximum allowed per-capita birth rate of a clade. In units 1/time. By default this is 1.
</p>
</li>
<li><p><code>death_rate_diffusivity</code>: Non-negative number. Diffusivity constant for the Brownian motion model of the evolving per-capita death rate. In units 1/time^3. See <code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code> for an explanation of the diffusivity parameter.
</p>
</li>
<li><p><code>min_death_rate_pc</code>:
Non-negative number. The minimum allowed per-capita death rate of a clade. In units 1/time. By default this is 0.
</p>
</li>
<li><p><code>max_death_rate_pc</code>:
Non-negative number. The maximum allowed per-capita death rate of a clade. In units 1/time. By default this is 1.
</p>
</li>
<li><p><code>root_birth_rate_pc</code>:
Non-negative number, between <code>min_birth_rate_pc</code> and <code>max_birth_rate_pc</code>, specifying the initial per-capita birth rate of the root. If left unspecified, this will be chosen randomly and uniformly within the allowed interval.
</p>
</li>
<li><p><code>root_death_rate_pc</code>:
Non-negative number, between <code>min_death_rate_pc</code> and <code>max_death_rate_pc</code>, specifying the initial per-capita death rate of the root. If left unspecified, this will be chosen randomly and uniformly within the allowed interval.
</p>
</li>
<li><p><code>rarefaction</code>:
Numeric between 0 and 1. Rarefaction to be applied at the end of the simulation (fraction of random tips kept in the tree). 
Note that if <code>coalescent==FALSE</code>, rarefaction may remove both extant as well as extinct clades. Set <code>rarefaction=1</code> to not perform any rarefaction.
</p>
</li></ul>

<p>If <code>rate_model=='Mk'</code>, then speciation/extinction rates are determined by a tip's current &quot;state&quot;, which evolves according to a continuous-time discrete-state Markov chain (Mk model) with constant transition rates. The argument <code>parameters</code> should be a named list including one or more of the following elements:
</p>

<ul>
<li><p><code>Nstates</code>: Number of possible discrete states a tip can have. For example, if <code>Nstates</code> then this corresponds to the common Binary State Speciation and Extinction (BiSSE) model (Maddison et al., 2007). By default this is 1.
</p>
</li>
<li><p><code>state_birth_rates</code>: Numeric vector of size Nstates, listing the per-capita birth rate (speciation rate) at each state. Can also be a single number (all states have the same birth rate).
</p>
</li>
<li><p><code>state_death_rates</code>: Numeric vector of size Nstates, listing the per-capita death rate (extinction rate) at each state. Can also be a single number (all states have the same death rate).
</p>
</li>
<li><p><code>transition_matrix</code>: 2D numeric matrix of size Nstates x Nstates. Transition rate matrix for the Markov chain model of birth/death rate evolution.
</p>
</li>
<li><p><code>start_state</code>:
Integer within 1,..,<code>Nstates</code>, specifying the initial state of the first created lineage. If left unspecified, this is chosen randomly and uniformly among all possible states.
</p>
</li>
<li><p><code>rarefaction</code>: Same as when <code>rate_model=='BM'</code>.
</p>
</li></ul>

<p>Note: The option <code>rate_model=='Mk'</code> is deprecated and included for backward compatibility purposes only. To generate a tree with Markov transitions between states (known as Multiple State Speciation and Extinction model), use the command <code>simulate_dsse</code> instead.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If <code>FALSE</code>, an additional element <code>error</code> (of type character) is included containing an explanation of the error; in that case the value of any of the other elements is undetermined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted bifurcating tree of class &quot;phylo&quot;, generated according to the specified birth/death model. 
</p>
<p>If <code>coalescent==TRUE</code> or if all death rates are zero, and only if <code>as_generations==FALSE</code>, then the tree will be ultrametric. If <code>as_generations==TRUE</code> and <code>coalescent==FALSE</code>, all edges will have unit length.
</p>
</td></tr>
<tr><td><code>root_time</code></td>
<td>

<p>Numeric, giving the time at which the tree's root was first split during the simulation. 
Note that if <code>coalescent==TRUE</code>, this may be later than the first speciation event during the simulation.
</p>
</td></tr>
<tr><td><code>final_time</code></td>
<td>

<p>Numeric, giving the final time at the end of the simulation. If <code>coalescent==TRUE</code>, then this may be greater than the total time span of the tree (since the root of the coalescent tree need not correspond to the first speciation event).
</p>
</td></tr>
<tr><td><code>equilibrium_time</code></td>
<td>

<p>Numeric, giving the first time where the sign of (death rate - birth rate) changed from the beginning of the simulation, i.e. when speciation/extinction equilibrium was reached. May be infinite if the simulation stoped before reaching this point.
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Total number of birth events (speciations) that occurred during tree growth. This may be lower than the total number of tips in the tree if death rates were non-zero and <code>coalescent==TRUE</code>.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Total number of deaths (extinctions) that occurred during tree growth.
</p>
</td></tr>
<tr><td><code>birth_times</code></td>
<td>

<p>Numeric vector, listing the times of speciation events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root. Only returned if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>death_times</code></td>
<td>

<p>Numeric vector, listing the times of extinction events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root. Only returned if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>birth_rates_pc</code></td>
<td>

<p>Numeric vector of length Ntips+Nnodes, listing the per-capita birth rate of each tip and node in the tree. The length of an edge in the tree was thus drawn from an exponential distribution with rate equal to the per-capita birth rate of the child tip or node.
</p>
</td></tr>
<tr><td><code>death_rates_pc</code></td>
<td>

<p>Numeric vector of length Ntips+Nnodes, listing the per-capita death rate of each tip and node in the tree.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Integer vector of size Ntips+Nnodes, listing the discrete state of each tip and node in the tree. Only included if <code>rate_model=="Mk"</code>.
</p>
</td></tr>
<tr><td><code>start_state</code></td>
<td>

<p>Integer, specifying the initial state of the first created lineage (either provided during the function call, or generated randomly). Only included if <code>rate_model=="Mk"</code>.
</p>
</td></tr>
<tr><td><code>root_birth_rate_pc</code></td>
<td>

<p>Numeric, specifying the initial per-capita birth rate of the root (either provided during the function call, or generated randomly). Only included if <code>rate_model=="BM"</code>.
</p>
</td></tr>
<tr><td><code>root_death_rate_pc</code></td>
<td>

<p>Numeric, specifying the initial per-capita death rate of the root (either provided during the function call, or generated randomly). Only included if <code>rate_model=="BM"</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. J. Aldous (2001). Stochastic models and descriptive statistics for phylogenetic trees, from Yule to today. Statistical Science. 16:23-34.
</p>
<p>W. P. Maddison, P. E. Midford, S. P. Otto (2007). Estimating a binary character's effect on speciation and extinction. Systematic Biology. 56:701-710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_dsse">simulate_dsse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Generate tree, with rates evolving under Brownian motion
parameters = list(birth_rate_diffusivity  = 1,
                  min_birth_rate_pc       = 1,
                  max_birth_rate_pc       = 2,
                  death_rate_diffusivity  = 0.5,
                  min_death_rate_pc       = 0,
                  max_death_rate_pc       = 1)
simulation = generate_tree_with_evolving_rates(parameters,
                                               rate_model='BM',
                                               max_tips=1000,
                                               include_rates=TRUE)
tree  = simulation$tree
Ntips = length(tree$tip.label)

# plot per-capita birth &amp; death rates of tips
plot( x=simulation$birth_rates_pc[1:Ntips], 
      y=simulation$death_rates_pc[1:Ntips], 
      type='p', 
      xlab="pc birth rate", 
      ylab="pc death rate", 
      main="Per-capita birth &amp; death rates across tips (BM model)",
      las=1)

      
######################
# Example 2
# Generate tree, with rates evolving under a binary-state model
Q = get_random_mk_transition_matrix(Nstates=2, rate_model="ER", max_rate=0.1)
parameters = list(Nstates = 2,
                  state_birth_rates = c(1,1.5),
                  state_death_rates = 0.5,
                  transition_matrix = Q)
simulation = generate_tree_with_evolving_rates(parameters,
                                               rate_model='Mk',
                                               max_tips=1000,
                                               include_rates=TRUE)
tree  = simulation$tree
Ntips = length(tree$tip.label)

# plot distribution of per-capita birth rates of tips
rates = simulation$birth_rates_pc[1:Ntips]
barplot(table(rates)/length(rates), 
        xlab="rate", 
        main="Distribution of pc birth rates across tips (Mk model)")
</code></pre>

<hr>
<h2 id='geographic_acf'>
Phylogenetic autocorrelation function of geographic locations.
</h2><span id='topic+geographic_acf'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and geographic coordinates (latitudes &amp; longitudes) of each tip, calculate the phylogenetic autocorrelation function (ACF) of the geographic locations. The ACF is a function of phylogenetic distance x, i.e., ACF(x) is the autocorrelation between two tip locations conditioned on the tips having phylogenetic (&quot;patristic&quot;) distance x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographic_acf( trees,
                tip_latitudes,
                tip_longitudes,
                Npairs              = 10000,
                Nbins               = NULL,
                min_phylodistance   = 0,
                max_phylodistance   = NULL,
                uniform_grid        = FALSE,
                phylodistance_grid  = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geographic_acf_+3A_trees">trees</code></td>
<td>

<p>Either a single rooted tree of class &quot;phylo&quot;, or a list of multiple such trees.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_tip_latitudes">tip_latitudes</code></td>
<td>

<p>Either a numeric vector of size Ntips (if <code>trees</code> was a single tree), specifying the latitudes (decimal degrees) of the tree's tips, or a list of such numeric vectors (if <code>trees</code> contained multiple trees) specifying the latitudes of each tree's tips. Note that <code>tip_latitudes[k][i]</code> must correspond to the i-th tip in the k-th input tree, i.e. as listed in <code>trees[[k]]$tip.label</code>. By convention, positive latitudes correspond to the northern hemisphere.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_tip_longitudes">tip_longitudes</code></td>
<td>

<p>Similar to <code>tip_latitudes</code>, but listing the latitudes (decimal degrees) of each tip in each input tree. By convention, positive longitudes correspond to the hemisphere East of the prime meridian.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_npairs">Npairs</code></td>
<td>

<p>Maximum number of random tip pairs to draw from each tree. A greater number of tip pairs will improve the accuracy of the estimated ACF within each distance bin. Tip pairs are drawn randomly with replacement, if <code>Npairs</code> is lower than the number of tip pairs in a tree. If <code>Npairs=Inf</code>, then every tip pair of every tree is included exactly once (for small and moderately sized trees this is recommended).
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_nbins">Nbins</code></td>
<td>

<p>Number of phylogenetic distance bins to consider. A greater number of bins will increase the resolution of the ACF as a function of phylogenetic distance, but will decrease the number of tip pairs falling within each bin (which reduces the accuracy of the estimated ACF). If <code>NULL</code>, then <code>Nbins</code> is automatically and somewhat reasonably chosen based on the size of the input trees.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_min_phylodistance">min_phylodistance</code></td>
<td>

<p>Numeric, minimum phylogenetic distance to conssider. Only relevant if <code>phylodistance_grid</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, optional maximum phylogenetic distance to consider. If <code>NULL</code>, this is automatically set to the maximum phylodistance between any two tips.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_uniform_grid">uniform_grid</code></td>
<td>

<p>Logical, specifying whether the phylodistance grid should be uniform, i.e., with equally sized phylodistance bins. If <code>FALSE</code>, then the grid is chosen non-uniformly (i.e., each bin has different size) such that each bin roughly contains the same number of tip pairs. Only relevant if <code>phylodistance_grid</code> is <code>NULL</code>. It is generally recommended to keep <code>uniform_grid=FALSE</code>, to avoid uneven estimation errors across bins.
</p>
</td></tr>
<tr><td><code id="geographic_acf_+3A_phylodistance_grid">phylodistance_grid</code></td>
<td>

<p>Numeric vector, optional explicitly specified phylodistance bins (left boundaries thereof) on which to evaluate the ACF. Must contain non-negative numbers in strictly ascending order. Hence, the first bin will range from <code>phylodistance_grid[1]</code> to <code>phylodistance_grid[2]</code>, while the last bin will range from <code>tail(phylodistance_grid,1)</code> to <code>max_phylodistance</code>. Can be used as an alternative to <code>Nbins</code>. If non-<code>NULL</code>, then <code>Nbins</code>, <code>min_phylodistance</code> and <code>uniform_grid</code> are irrelevant. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The autocorrelation between random geographic locations is defined as the expectation of <code class="reqn">&lt;X,Y&gt;</code>, where &lt;&gt; is the scalar product and <code class="reqn">X</code> and <code class="reqn">Y</code> are the unit vectors pointing towards the two random locations on the sphere. For comparison, for a spherical Brownian Motion model with constant diffusivity <code class="reqn">D</code> and radius <code class="reqn">r</code> the autocorrelation function is given by <code class="reqn">ACF(t)=e^{-2Dt/r^2}</code> (see e.g. <code><a href="#topic+simulate_sbm">simulate_sbm</a></code>). Note that this function assumes that Earth is a perfect sphere.
</p>
<p>The phylogenetic autocorrelation function (ACF) of the geographic distribution of species can give insight into the dispersal processes shaping species distributions over global scales. An ACF that decays slowly with increasing phylogenetic distance indicates a strong phylogenetic conservatism of the location and thus slow dispersal, whereas a  rapidly decaying ACF indicates weak phylogenetic conservatism and thus fast dispersal. Similarly, if the mean distance between two random tips increases with phylogenetic distance, this indicates a phylogenetic autocorrelation of species locations. Here, phylogenetic distance between tips refers to their patristic distance, i.e. the minimum cumulative edge length required to connect the two tips.
</p>
<p>Since the phylogenetic distances between all possible tip pairs do not cover a continuoum (as there is only a finite number of tips), this function randomly draws tip pairs from the tree, maps them onto a finite set of phylodistance bins and then estimates the ACF for the centroid of each bin based on tip pairs in that bin. In practice, as a next step one would usually plot the estimated ACF (returned vector <code>autocorrelations</code>) over the centroids of the phylodistance bins (returned vector <code>phylodistances</code>). When multiple trees are provided as input, then the ACF is first calculated separately for each tree, and then averaged across trees (weighted by the number of tip pairs included from each tree in each bin).
</p>
<p>Phylogenetic distance bins can be specified in two alternative ways: Either a set of bins (phylodistance grid) is automatically calculated based on the provided <code>Nbins</code>, <code>min_phylodistance</code>, <code>max_phylodistance</code> and <code>uniform_grid</code>, or a phylodistance grid is explicitly provided via <code>phylodistance_grid</code> and <code>max_phylodistance</code>.
</p>
<p>The trees may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). If edge lengths are missing from the trees, then every edge is assumed to have length 1. The input trees must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence the result.
</p>
<p>This function assumes that each tip is assigned exactly one geographic location. This might be problematic in situations where each tip covers multiple geographic locations, for example if tips are species and multiple individuals were sampled from each species. In that case, one might consider representing each individual as a separate tip in the tree, so that each tip has exactly one geographic location.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the calculation was successful. If <code>FALSE</code>, an additional element <code>error</code> (character) is returned that provides a brief description of the error that occurred; in that case all other return values may be undefined.
</p>
</td></tr>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the center of each phylodistance bin in increasing order. This is equal to <code>0.5*(left_phylodistances+right_phylodistances)</code>. Typically, you will want to plot <code>autocorrelations</code> over <code>phylodistances</code>.
</p>
</td></tr>
<tr><td><code>left_phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the left boundary of each phylodistance bin in increasing order.
</p>
</td></tr>
<tr><td><code>right_phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the right boundary of each phylodistance bin in increasing order.
</p>
</td></tr>
<tr><td><code>autocorrelations</code></td>
<td>

<p>Numeric vector of size Nbins, storing the estimated geographic autocorrelation for each phylodistance bin.
</p>
</td></tr>
<tr><td><code>std_autocorrelations</code></td>
<td>

<p>Numeric vector of size Nbins, storing the standard deviation of geographic autocorrelations encountered in each phylodistance bin. Note that this is not the standard error of the estimated ACF; it is a measure for how different the geographic locations are between tip pairs within each phylodistance bin.
</p>
</td></tr>
<tr><td><code>mean_geodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the mean geographic distance between tip pairs in each distance bin, in units of sphere radii. If you want geographic distances in km, you need to multiply these by Earth's mean radius in km (about 6371). If multiple input trees were provided, this is the average across all trees, weighted by the number of tip pairs included from each tree in each bin.
</p>
</td></tr>
<tr><td><code>std_geodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the standard deviation of geographic distances between tip pairs in each distance bin, in units of sphere radii.
</p>
</td></tr>
<tr><td><code>Npairs_per_distance</code></td>
<td>

<p>Integer vector of size Nbins, storing the number of random tip pairs associated with each distance bin.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlate_phylo_geodistances">correlate_phylo_geodistances</a></code>,
<code><a href="#topic+consentrait_depth">consentrait_depth</a></code>, 
<code><a href="#topic+get_trait_acf">get_trait_acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# simulate spherical Brownian Motion on the tree
simul = simulate_sbm(tree, radius=1, diffusivity=0.1)
tip_latitudes  = simul$tip_latitudes
tip_longitudes = simul$tip_longitudes

# calculate geographical autocorrelation function
ACF = geographic_acf(tree, 
                     tip_latitudes, 
                     tip_longitudes,
                     Nbins        = 10,
                     uniform_grid = TRUE)

# plot ACF (autocorrelation vs phylogenetic distance)
plot(ACF$phylodistances, ACF$autocorrelations, type="l", xlab="distance", ylab="ACF")
</code></pre>

<hr>
<h2 id='get_all_distances_to_root'>
Get distances of all tips and nodes to the root.
</h2><span id='topic+get_all_distances_to_root'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, calculate the phylogenetic distance (cumulative branch length) of the root to each tip and node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_distances_to_root(tree, as_edge_count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_distances_to_root_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_all_distances_to_root_+3A_as_edge_count">as_edge_count</code></td>
<td>

<p>Logical, specifying whether distances should be counted in number of edges, rather than cumulative edge length. This is the same as if all edges had length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree$edge.length</code> is missing, then every edge in the tree is assumed to be of length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
The asymptotic average time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A numeric vector of size Ntips+Nnodes, with the i-th element being the distance (cumulative branch length) of the i-th tip or node to the root. Tips are indexed 1,..,Ntips and nodes are indexed (Ntips+1),..,(Ntips+Nnodes).
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_distances">get_pairwise_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1, 
                            	 death_rate_intercept=0.5),
                            max_tips=Ntips)$tree

# calculate distances to root
all_distances = get_all_distances_to_root(tree)

# extract distances of nodes to root
node_distances = all_distances[(Ntips+1):(Ntips+tree$Nnode)]

# plot histogram of distances (across all nodes)
hist(node_distances, xlab="distance to root", ylab="# nodes", prob=FALSE);
</code></pre>

<hr>
<h2 id='get_all_distances_to_tip'>
Get distances of all tips/nodes to a focal tip.
</h2><span id='topic+get_all_distances_to_tip'></span>

<h3>Description</h3>

<p>Given a tree and a focal tip, calculate the phylogenetic (&quot;patristic&quot;) distances between the focal tip and all other tips &amp; nodes in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_distances_to_tip(tree, focal_tip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_distances_to_tip_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="get_all_distances_to_tip_+3A_focal_tip">focal_tip</code></td>
<td>

<p>Either a character, specifying the name of the focal tip, or an integer between 1 and Ntips, specifying the focal tip's index.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;patristic distance&quot; between two tips and/or nodes is the shortest cumulative branch length that must be traversed along the tree in order to reach one tip/node from the other. If <code>tree$edge.length</code> is missing, then each edge is assumed to be of length 1.
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence the result.
</p>


<h3>Value</h3>

<p>A numeric vector of length Ntips+Nnodes, specifying the distances of all tips (entries 1,..,Ntips) and all nodes (entries Ntips+1,..,Ntips+Nnodes) to the focal tip.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_pairwise_distances">get_all_pairwise_distances</a></code>,
<code><a href="#topic+get_pairwise_distances">get_pairwise_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree  = generate_random_tree(list(birth_rate_intercept=1),
                             max_tips = Ntips,
                             tip_basename="tip.")$tree

# calculate all distances to a focal tip
distances = get_all_distances_to_tip(tree, "tip.39")
print(distances)
</code></pre>

<hr>
<h2 id='get_all_node_depths'>
Get the phylogenetic depth of each node in a tree.
</h2><span id='topic+get_all_node_depths'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, calculate the phylogenetic depth of each node (mean distance to its descending tips).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_node_depths(tree, as_edge_count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_node_depths_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_all_node_depths_+3A_as_edge_count">as_edge_count</code></td>
<td>

<p>Logical, specifying whether distances should be counted in number of edges, rather than cumulative edge length. This is the same as if all edges had length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree$edge.length</code> is missing, then every edge in the tree is assumed to be of length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
The asymptotic average time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A numeric vector of size Nnodes, with the i-th element being the mean distance of the i-th node to all of its tips.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_distances_to_root">get_all_distances_to_root</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1, 
                            	 death_rate_intercept=0.5),
                            max_tips=Ntips)$tree

# calculate node phylogenetic depths
node_depths = get_all_node_depths(tree)

# plot histogram of node depths
hist(node_depths, xlab="phylogenetic depth", ylab="# nodes", prob=FALSE);
</code></pre>

<hr>
<h2 id='get_all_pairwise_distances'>
Get distances between all pairs of tips and/or nodes.
</h2><span id='topic+get_all_pairwise_distances'></span>

<h3>Description</h3>

<p>Calculate phylogenetic (&quot;patristic&quot;) distances between all pairs of tips or nodes in the tree, or among a subset of tips/nodes requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_pairwise_distances( tree,
                            only_clades     = NULL, 
                            as_edge_counts  = FALSE,
                            check_input     = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_pairwise_distances_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_all_pairwise_distances_+3A_only_clades">only_clades</code></td>
<td>

<p>Optional integer vector or character vector, listing tips and/or nodes to which to restrict pairwise distance calculations. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names. 
</p>
<p>For example, if <code>only_clades=c('apple','lemon','pear')</code>, then only the distance between &lsquo;apple&rsquo; and &lsquo;lemon&rsquo;, between &lsquo;apple&rsquo; and 'pear', and between &lsquo;lemon&rsquo; and &lsquo;pear&rsquo; are calculated. If <code>only_clades==NULL</code>, then this is equivalent to <code>only_clades=c(1:(Ntips+Nnodes))</code>.
</p>
</td></tr>
<tr><td><code id="get_all_pairwise_distances_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
<tr><td><code id="get_all_pairwise_distances_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether distances should be calculated in terms of edge counts, rather than cumulative edge lengths. This is the same as if all edges had length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;patristic distance&quot; between two tips and/or nodes is the shortest cumulative branch length that must be traversed along the tree in order to reach one tip/node from the other.This function returns a square distance matrix, containing the patristic distance between all possible pairs of tips/nodes in the tree (or among the ones provided in <code>only_clades</code>).
</p>
<p>If <code>tree$edge.length</code> is missing, then each edge is assumed to be of length 1; this is the same as setting <code>as_edge_counts=TRUE</code>. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence the result. If <code>only_clades</code> is a character vector, then <code>tree$tip.label</code> must exist. If node names are included in <code>only_clades</code>, then <code>tree$node.label</code> must also exist.
</p>
<p>The asymptotic average time complexity of this function for a balanced binary tree is O(NC*NC*Nanc + Ntips), where NC is the number of tips/nodes considered (e.g., the length of <code>only_clades</code>) and Nanc is the average number of ancestors per tip.
</p>


<h3>Value</h3>

<p>A 2D numeric matrix of size NC x NC, where NC is the number of tips/nodes considered, and with the entry in row r and column c listing the distance between the r-th and the c-th clade considered (e.g., between clades <code>only_clades[r]</code> and <code>only_clades[c]</code>). Note that if <code>only_clades</code> was specified, then the rows and columns in the returned distance matrix correspond to the entries in <code>only_clades</code> (i.e., in the same order). If <code>only_clades</code> was <code>NULL</code>, then the rows and columns in the returned distance matrix correspond to tips (1,..,Ntips) and nodes (Ntips+1,..,Ntips+Nnodes)
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_distances_to_root">get_all_distances_to_root</a></code>,
<code><a href="#topic+get_pairwise_distances">get_pairwise_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree  = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# calculate distances between all internal nodes
only_clades = c((Ntips+1):(Ntips+tree$Nnode))
distances = get_all_pairwise_distances(tree, only_clades)

# reroot at some other node
tree = root_at_node(tree, new_root_node=20, update_indices=FALSE)
new_distances = get_all_pairwise_distances(tree, only_clades)

# verify that distances remained unchanged
plot(distances,new_distances,type='p')
</code></pre>

<hr>
<h2 id='get_ancestral_nodes'>
Compute ancestral nodes.
</h2><span id='topic+get_ancestral_nodes'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a set of tips and/or nodes (&quot;descendants&quot;), determine their ancestral node indices, traveling a specific number of splits back in time (i.e., towards the root).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ancestral_nodes(tree, descendants, Nsplits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ancestral_nodes_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="get_ancestral_nodes_+3A_descendants">descendants</code></td>
<td>

<p>An integer vector or character vector, specifying the tips/nodes for each of which to determine the ancestral node. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes), where Ntips and Nnodes is the number of tips and nodes in the tree, respectively. If a character vector, it must list tip and/or node names. In this case <code>tree</code> must include <code>tip.label</code>, as well as <code>node.label</code> if nodes are included in <code>descendants</code>.
</p>
</td></tr>
<tr><td><code id="get_ancestral_nodes_+3A_nsplits">Nsplits</code></td>
<td>

<p>Either a single integer or an integer vector of the same length as <code>descendants</code>, with values &gt;=1, specifying how many splits to travel backward. For example, Nsplits=1 will yield the parent node of each tip/node in <code>descendants</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>


<h3>Value</h3>

<p>An integer vector of the same length as <code>descendants</code>, with values in 1,..,Nnodes, listing the node indices representing the ancestors of <code>descendants</code> traveling backward <code>Nsplits</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_mrcas">get_pairwise_mrcas</a></code>, <code><a href="#topic+get_mrca_of_set">get_mrca_of_set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),
                            max_tips = 50,
                            tip_basename = "tip.",
                            node_basename = "node.")$tree

# pick 3 tips
descendants=c("tip.5", "tip.7","tip.10")

# determine the immediate parent node of each tip
ancestors = castor::get_ancestral_nodes(tree, descendants, Nsplits=1)
print(tree$node.label[ancestors])
</code></pre>

<hr>
<h2 id='get_clade_list'>
Get a representation of a tree as a table listing tips/nodes.
</h2><span id='topic+get_clade_list'></span>

<h3>Description</h3>

<p>Given a tree in standard &quot;phylo&quot; format, calculate an alternative representation of the tree structure as a list of tips/nodes with basic information on parents, children and incoming edge lengths. This function is analogous to the function <code>read.tree.nodes</code> in the R package <code>phybase</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clade_list(tree, postorder=FALSE, missing_value=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clade_list_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;. If <code>postorder==TRUE</code>, then the tree must be rooted.
</p>
</td></tr>
<tr><td><code id="get_clade_list_+3A_postorder">postorder</code></td>
<td>

<p>Logical, specifying whether nodes should be ordered and indexed in postorder traversal, i.e. with the root node listed last. Note that regardless of the value of <code>postorder</code>, tips will always be listed first and indexed in the order in which they are listed in the input tree.
</p>
</td></tr>
<tr><td><code id="get_clade_list_+3A_missing_value">missing_value</code></td>
<td>

<p>Value to be used to denote missing information in the returned arrays, for example to denote the (non-existing) parent of the root node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is analogous to the function <code>read.tree.nodes</code> in the R package <code>phybase</code> v1.4, but becomes multiple orders of magnitude faster than the latter for large trees (i.e. with 1000-1000,000 tips). Specifically, calling <code>get_clade_list</code> with <code>postorder=TRUE</code> and <code>missing_value=-9</code> on a bifurcating tree yields a similar behavior as calling <code>read.tree.nodes</code> with the argument &ldquo;<code>name</code>&rdquo; set to the tree's tip labels.
</p>
<p>The input tree can include monofurcations, bifurcations and multifurcations.
The asymptotic average time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether model fitting succeeded. If <code>FALSE</code>, the returned list will include an additional &ldquo;error&rdquo; element (character) providing a description of the error; in that case all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>Nsplits</code></td>
<td>

<p>The maximum number of children of any node in the tree. For strictly bifurcating trees this will be 2.
</p>
</td></tr>
<tr><td><code>clades</code></td>
<td>

<p>2D integer matrix of size Nclades x (Nsplits+1), with every row representing a specific tip/node in the tree. If <code>postorder==FALSE</code>, then rows are in the same order as tips/nodes in the original tree, otherwise nodes (but not tips) will be re-ordered and re-indexed in postorder fashion, with the root being the last row. The first column lists the parent node index, the remaining columns list the child tip/node indices. For the root, the parent index will be set to <code>missing_value</code>; for the tips, the child indices will be set to <code>missing_value</code>. For nodes with fewer than Nsplits children, superfluous column entries will also be <code>missing_value</code>.
</p>
</td></tr>
<tr><td><code>lengths</code></td>
<td>

<p>Numeric vector of size Nclades, listing the lengths of the incoming edges at each tip/node in <code>clades</code>. For the root, the value will be <code>missing_value</code>. If the tree's <code>edge_length</code> was <code>NULL</code>, then <code>lengths</code> will be <code>NULL</code> as well.
</p>
</td></tr>
<tr><td><code>old2new_clade</code></td>
<td>

<p>Integer vector of size Nclades, mapping old tip/node indices to tip/node indices in the returned <code>clades</code> and <code>lengths</code> arrays. If <code>postorder==FALSE</code>, this will simply be <code>c(1:Nclades)</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random bifurcating tree
tree = generate_random_tree(list(birth_rate_intercept=1),
                            max_tips=100)$tree

# get tree structure as clade list
# then convert into a similar format as would be
# returned by phybase::read.tree.nodes v1.4
results = get_clade_list(tree,postorder=TRUE,missing_value=-9)
nodematrix = cbind( results$clades, 
                    results$lengths, 
                    matrix(-9,nrow=nrow(results$clades),ncol=3))
phybaseformat = list(   nodes = nodematrix, 
                        names = tree$tip.label, 
                        root  = TRUE)
</code></pre>

<hr>
<h2 id='get_independent_contrasts'>
Phylogenetic independent contrasts for continuous traits.
</h2><span id='topic+get_independent_contrasts'></span>

<h3>Description</h3>

<p>Calculate phylogenetic independent contrasts (PICs) for one or more continuous traits on a phylogenetic tree, as described by Felsenstein (1985). The trait states are assumed to be known for all tips of the tree. PICs are commonly used to calculate correlations between multiple traits, while accounting for shared evolutionary history at the tips. This function also returns an estimate for the state of the root or, equivalently, the phylogenetically weighted mean of the tip states (Garland et al., 1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_independent_contrasts(tree, 
                          tip_states,
                          scaled = TRUE, 
                          only_bifurcations = FALSE,
                          include_zero_phylodistances = FALSE,
                          check_input = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_independent_contrasts_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_independent_contrasts_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, or a 2D numeric matrix of size Ntips x Ntraits, specifying the numeric state of each trait at each tip in the tree.
</p>
</td></tr>
<tr><td><code id="get_independent_contrasts_+3A_scaled">scaled</code></td>
<td>

<p>Logical, specifying whether to divide (standardize) PICs by the square root of their expected variance, as recommended by Felsenstein (1985).
</p>
</td></tr>
<tr><td><code id="get_independent_contrasts_+3A_only_bifurcations">only_bifurcations</code></td>
<td>

<p>Logical, specifying whether to only calculate PICs for bifurcating nodes. If <code>FALSE</code>, then multifurcations are temporarily expanded to bifurcations, and an additional PIC is calculated for each created bifurcation. If <code>TRUE</code>, then multifurcations are not expanded and PICs will not be calculated for them.
</p>
</td></tr>
<tr><td><code id="get_independent_contrasts_+3A_include_zero_phylodistances">include_zero_phylodistances</code></td>
<td>

<p>Logical, specifying whether the returned PICs may include cases where the phylodistance is zero (this can only happen if the tree has edges with length 0). If <code>FALSE</code>, all returned PICs will have non-zero phylodistances.
</p>
</td></tr>
<tr><td><code id="get_independent_contrasts_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the tree is bifurcating, then one PIC is returned for each node. If multifurcations are present and <code>only_bifurcations==FALSE</code>, these are internally expanded to bifurcations and an additional PIC is returned for each such bifurcation. PICs are never returned for monofurcating nodes. Hence, in general the number of returned PICs is the number of bifurcations in the tree, potentially after multifurcations have been expanded to bifurcations (if <code>only_bifurcations==FALSE</code>).
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child). Edges with length 0 will be adjusted internally to some tiny length (chosen to be much smaller than the smallest non-zero length).
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>The function has asymptotic time complexity O(Nedges x Ntraits). It is more efficient to calculate PICs of multiple traits with the same function call, than to calculate PICs for each trait separately. For a single trait, this function is equivalent to the function <code>ape::pic</code>, with the difference that it can handle multifurcating trees.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>PICs</code></td>
<td>

<p>A numeric vector (if <code>tip_states</code> is a vector) or a numeric matrix (if <code>tip_states</code> is a matrix), listing the phylogenetic independent contrasts for each trait and for each bifurcating node (potentially after multifurcations have been expanded). If a matrix, then <code>PICs[:,T]</code> will list the PICs for the T-th trait.
Note that the order of elements in this vector (or rows, if <code>PICs</code> is a matrix) is not necesssarily the order of nodes in the tree, and that <code>PICs</code> may contain fewer or more elements (or rows) than there were nodes in the input tree.
</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>

<p>Numeric vector of the same size as <code>PICs</code>. The &ldquo;evolutionary distances&rdquo; (or time) corresponding to the PICs under a Brownian motion model of trait evolution. These roughly correspond to the cumulative edge lengths between sister nodes from which PICs were calculated; hence their units are the same as those of edge lengths. They do not take into account the actual trait values. See Felsenstein (1985) for details.
</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>

<p>Integer vector of the same size as <code>PICs</code>, listing the node indices for which PICs are returned. If <code>only_bifurcations==FALSE</code>, then this vector may contain <code>NA</code>s, corresponding to temporary nodes created during expansion of multifurcations.
</p>
<p>If <code>only_bifurcations==TRUE</code>, then this vector will only list nodes that were bifurcating in the input tree. In that case, <code>PICs[1]</code> will correspond to the node with name <code>tree$node.label[nodes[1]]</code>, whereas <code>PICs[2]</code> will correspond to the node with name <code>tree$node.label[nodes[2]]</code>, and so on.
</p>
</td></tr>
<tr><td><code>root_state</code></td>
<td>

<p>Numeric vector of size Ntraits, listing the globally estimated state for the root or, equivalently, the phylogenetically weighted mean of the tip states.
</p>
</td></tr>
<tr><td><code>root_standard_error</code></td>
<td>

<p>Numeric vector of size Ntraits, listing the phylogenetically estimated standard errors of the root state under a Brownian motion model. The standard errors have the same units as the traits and depend both on the tree topology as well as the tip states. Calculated according to the procedure described by Garland et al. (1999, page 377).
</p>
</td></tr>
<tr><td><code>root_CI95</code></td>
<td>

<p>Numeric vector of size Ntraits, listing the radius (half width) of the 95% confidence interval of the root state. Calculated according to the procedure described by Garland et al. (1999, page 377). Note that in contrast to the CI95 returned by the <code>ace</code> function in the <code>ape</code> package (v. 0.5-64), <code>root_CI95</code> has the same units as the traits and depends both on the tree topology as well as the tip states.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the Comparative Method. The American Naturalist. 125:1-15.
</p>
<p>T. Garland Jr., P. E. Midford, A. R. Ives (1999). An introduction to phylogenetically based statistical methods, with a new method for confidence intervals on ancestral values. American Zoologist. 39:374-388. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_independent_contrasts">asr_independent_contrasts</a></code>, <code><a href="#topic+get_independent_sister_tips">get_independent_sister_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# simulate a continuous trait
tip_states = simulate_bm_model(tree, diffusivity=0.1, include_nodes=FALSE)$tip_states;

# calculate PICs
results = get_independent_contrasts(tree, tip_states, scaled=TRUE, only_bifurcations=TRUE)

# assign PICs to the bifurcating nodes in the input tree
PIC_per_node = rep(NA, tree$Nnode)
valids = which(!is.na(results$nodes))
PIC_per_node[results$nodes[valids]] = results$PICs[valids]

</code></pre>

<hr>
<h2 id='get_independent_sister_tips'>
Extract disjoint tip pairs with independent relationships.
</h2><span id='topic+get_independent_sister_tips'></span>

<h3>Description</h3>

<p>Given a rooted tree, extract disjoint pairs of sister tips with disjoint connecting paths. These tip pairs can be used to compute independent contrasts of numerical traits evolving according to an arbitrary time-reversible process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_independent_sister_tips(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_independent_sister_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input tree only contains monofurcations and bifurcations (recommended), it is guaranteed that at most one unpaired tip will be left (i.e., if Ntips was odd).
</p>


<h3>Value</h3>

<p>An integer matrix of size NP x 2, where NP is the number of returned tip pairs. Each row in this matrix lists the indices (from 1 to Ntips) of a tip pair that can be used to compute a phylogenetic independent contrast.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the Comparative Method. The American Naturalist. 125:1-15.
</p>
<p>T. Garland Jr., P. E. Midford, A. R. Ives (1999). An introduction to phylogenetically based statistical methods, with a new method for confidence intervals on ancestral values. American Zoologist. 39:374-388. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_independent_contrasts">get_independent_contrasts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# simulate a continuous trait on the tree
tip_states = simulate_bm_model(tree, diffusivity=0.1, include_nodes=FALSE)$tip_states

# get independent tip pairs
tip_pairs = get_independent_sister_tips(tree)

# calculate non-scaled PICs for the trait using the independent tip pairs
PICs = tip_states[tip_pairs]
</code></pre>

<hr>
<h2 id='get_mrca_of_set'>
Most recent common ancestor of a set of tips/nodes.
</h2><span id='topic+get_mrca_of_set'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a set of tips and/or nodes (&quot;descendants&quot;), calculate the most recent common ancestor (MRCA) of those descendants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrca_of_set(tree, descendants)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrca_of_set_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_mrca_of_set_+3A_descendants">descendants</code></td>
<td>

<p>An integer vector or character vector, specifying the tips/nodes for which to find the MRCA. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes), where Ntips and Nnodes is the number of tips and nodes in the tree, respectively. If a character vector, it must list tip and/or node names. In this case <code>tree</code> must include <code>tip.label</code>, as well as <code>node.label</code> if nodes are included in <code>descendants</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).  Duplicate entries in <code>descendants</code> are ignored.
</p>


<h3>Value</h3>

<p>An integer in 1,..,(Ntips+Nnodes), representing the MRCA using the same index as in <code>tree$edge</code>. If the MRCA is a tip, then this index will be in 1,..,Ntips. If the MRCA is a node, then this index will be in (Ntips+1),..,(Ntips+Nnodes).
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_mrcas">get_pairwise_mrcas</a></code>, <code><a href="#topic+get_tips_for_mrcas">get_tips_for_mrcas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick 3 random tips or nodes
descendants = sample.int(n=(Ntips+tree$Nnode), size=3, replace=FALSE)

# calculate MRCA of picked descendants
mrca = get_mrca_of_set(tree, descendants)
</code></pre>

<hr>
<h2 id='get_pairwise_distances'>
Get distances between pairs of tips or nodes.
</h2><span id='topic+get_pairwise_distances'></span>

<h3>Description</h3>

<p>Calculate phylogenetic (&quot;patristic&quot;) distances between tips or nodes in some list A and tips or nodes in a second list B of the same size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pairwise_distances(tree, A, B, as_edge_counts=FALSE, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pairwise_distances_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_pairwise_distances_+3A_a">A</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the first of the two members of each pair for which to calculate the distance. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="get_pairwise_distances_+3A_b">B</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the second of the two members of each pair for which to calculate the distance. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="get_pairwise_distances_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
<tr><td><code id="get_pairwise_distances_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether distances should be calculated in terms of edge counts, rather than cumulative edge lengths. This is the same as if all edges had length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;patristic distance&quot; between two tips and/or nodes is the shortest cumulative branch length that must be traversed along the tree in order to reach one tip/node from the other. Given a list of tips and/or nodes A, and a 2nd list of tips and/or nodes B of the same size, this function will calculate patristic distance between each pair (A[i], B[i]), where i=1,2,..,Npairs. 
</p>
<p>If <code>tree$edge.length</code> is missing, then each edge is assumed to be of length 1; this is the same as setting <code>as_edge_counts=TRUE</code>. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence the result. If <code>A</code> and/or <code>B</code> is a character vector, then <code>tree$tip.label</code> must exist. If node names are included in <code>A</code> and/or <code>B</code>, then <code>tree$node.label</code> must also exist.
</p>
<p>The asymptotic average time complexity of this function for a balanced binary tree is O(Ntips+Npairs*log2(Ntips)).
</p>


<h3>Value</h3>

<p>A numeric vector of size Npairs, with the i-th element being the patristic distance between the tips/nodes A[i] and B[i].
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_distances_to_root">get_all_distances_to_root</a></code>,
<code><a href="#topic+get_all_pairwise_distances">get_all_pairwise_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick 3 random pairs of tips or nodes
Npairs = 3
A = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)
B = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)

# calculate distances
distances = get_pairwise_distances(tree, A, B)

# reroot at some other node
tree = root_at_node(tree, new_root_node=20, update_indices=FALSE)
new_distances = get_pairwise_distances(tree, A, B)

# verify that distances remained unchanged
print(distances)
print(new_distances)
</code></pre>

<hr>
<h2 id='get_pairwise_mrcas'>
Get most recent common ancestors of tip/node pairs.
</h2><span id='topic+get_pairwise_mrcas'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and one or more pairs of tips and/or nodes, for each pair of tips/nodes find the most recent common ancestor (MRCA). If one clade is descendant of the other clade, the latter will be returned as MRCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pairwise_mrcas(tree, A, B, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pairwise_mrcas_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_pairwise_mrcas_+3A_a">A</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the first of the two members of each pair of tips/nodes for which to find the MRCA. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="get_pairwise_mrcas_+3A_b">B</code></td>
<td>

<p>An integer vector or character vector of size Npairs, specifying the second of the two members of each pair of tips/nodes for which to find the MRCA. If an integer vector, it must list indices of tips (from 1 to Ntips) and/or nodes (from Ntips+1 to Ntips+Nnodes). If a character vector, it must list tip and/or node names.
</p>
</td></tr>
<tr><td><code id="get_pairwise_mrcas_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is missing, then each edge is assumed to be of length 1. Note that in some cases the MRCA of two tips may be a tip, namely when both tips are the same.
</p>
<p>If <code>A</code> and/or <code>B</code> is a character vector, then <code>tree$tip.label</code> must exist. If node names are included in <code>A</code> and/or <code>B</code>, then <code>tree$node.label</code> must also exist.
</p>
<p>The asymptotic average time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>An integer vector of size Npairs with values in 1,..,Ntips (tips) and/or in (Ntips+1),..,(Ntips+Nnodes) (nodes), with the i-th element being the index of the MRCA of tips/nodes <code>A[i]</code> and <code>B[i]</code>. 
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mrca_of_set">get_mrca_of_set</a></code>, <code><a href="#topic+get_tips_for_mrcas">get_tips_for_mrcas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick 3 random pairs of tips or nodes
Npairs = 3
A = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)
B = sample.int(n=(Ntips+tree$Nnode), size=Npairs, replace=FALSE)

# calculate MRCAs
MRCAs = get_pairwise_mrcas(tree, A, B)
</code></pre>

<hr>
<h2 id='get_random_diffusivity_matrix'>
Create a random diffusivity matrix for a Brownian motion model.
</h2><span id='topic+get_random_diffusivity_matrix'></span>

<h3>Description</h3>

<p>Create a random diffusivity matrix for a Brownian motion model of multi-trait evolution. This may be useful for testing purposes. The diffusivity matrix is drawn from the Wishart distribution of symmetric, nonnegative-definite matrixes: 
</p>
<p style="text-align: center;"><code class="reqn">D = X^T \cdot X,\quad X[i,j]\sim N(0,V),\quad i=1,..,n, j=1,..,p,</code>
</p>
 
<p>where n is the degrees of freedom, p is the number of traits and V is a scalar scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_diffusivity_matrix(Ntraits, degrees=NULL, V=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_diffusivity_matrix_+3A_ntraits">Ntraits</code></td>
<td>

<p>The number of traits modelled. Equal to the number of rows and the number of columns of the returned matrix.
</p>
</td></tr>
<tr><td><code id="get_random_diffusivity_matrix_+3A_degrees">degrees</code></td>
<td>

<p>Degrees of freedom for the Wishart distribution. Must be equal to or greater than <code>Ntraits</code>. Can also be <code>NULL</code>, which is the same as setting it equal to <code>Ntraits</code>.
</p>
</td></tr>
<tr><td><code id="get_random_diffusivity_matrix_+3A_v">V</code></td>
<td>

<p>Positive number. A scalar scaling for the Wishart distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real-valued quadratic symmetric non-negative definite matrix of size Ntraits x Ntraits. Almost surely (in the probabilistic sense), this matrix will be positive definite.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_random_mk_transition_matrix">get_random_mk_transition_matrix</a></code>, 
<code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 5x5 diffusivity matrix
D = get_random_diffusivity_matrix(Ntraits=5)

# check that it is indeed positive definite
if(all(eigen(D)$values&gt;0)){ 
  cat("Indeed positive definite\n");
}else{ 
  cat("Not positive definite\n"); 
}
</code></pre>

<hr>
<h2 id='get_random_mk_transition_matrix'>
Create a random transition matrix for an Mk model.
</h2><span id='topic+get_random_mk_transition_matrix'></span>

<h3>Description</h3>

<p>Create a random transition matrix for a fixed-rates continuous-time Markov model of discrete trait evolution (&quot;Mk model&quot;). This may be useful for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_mk_transition_matrix(Nstates, rate_model, min_rate=0, max_rate=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_mk_transition_matrix_+3A_nstates">Nstates</code></td>
<td>

<p>The number of distinct states represented in the transition matrix (number of rows &amp; columns).
</p>
</td></tr>
<tr><td><code id="get_random_mk_transition_matrix_+3A_rate_model">rate_model</code></td>
<td>

<p>Rate model that the transition matrix must satisfy. Can be &quot;ER&quot; (all rates equal), &quot;SYM&quot; (transition rate i&ndash;&gt;j is equal to transition rate j&ndash;&gt;i), &quot;ARD&quot; (all rates can be different) or &quot;SUEDE&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, all 'up' transitions are equal, all 'down' transitions are equal).
</p>
</td></tr>
<tr><td><code id="get_random_mk_transition_matrix_+3A_min_rate">min_rate</code></td>
<td>

<p>A non-negative number, specifying the minimum rate in off-diagonal entries of the transition matrix.
</p>
</td></tr>
<tr><td><code id="get_random_mk_transition_matrix_+3A_max_rate">max_rate</code></td>
<td>

<p>A non-negative number, specifying the maximum rate in off-diagonal entries of the transition matrix. Must not be smaller than <code>min_rate</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real-valued quadratic matrix of size Nstates x Nstates, representing a transition matrix for an Mk model. Each row will sum to 0. The [r,c]-th entry represents the transition rate r&ndash;&gt;c. The number of unique off-diagonal rates will depend on the <code>rate_model</code> chosen.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponentiate_matrix">exponentiate_matrix</a></code>, <code><a href="#topic+get_stationary_distribution">get_stationary_distribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 5x5 Markov transition rate matrix
Q = get_random_mk_transition_matrix(Nstates=5, rate_model="ARD")
</code></pre>

<hr>
<h2 id='get_reds'>
Calculate relative evolutionary divergences in a tree.
</h2><span id='topic+get_reds'></span>

<h3>Description</h3>

<p>Calculate the relative evolutionary divergence (RED) of each node in a rooted phylogenetic tree. The RED of a node is a measure of its relative placement between the root and the node's descending tips (Parks et al. 2018). The root's RED is always 0, the RED of each tip is 1, and the RED of each node is between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reds(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reds_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RED of a node measures its relative placement between the root and the node's descending tips (Parks et al. 2018). The root's RED is set to 0. Traversing from root to tips (preorder traversal), for each node the RED is set to <code class="reqn">P+(a/(a+b))\cdot(1-P)</code>, where <code class="reqn">P</code> is the RED of the node's parent, <code class="reqn">a</code> is the edge length connecting the node to its parent, and <code class="reqn">b</code> is the average distance from the node to its descending tips. The RED of a tip would always be 1.
</p>
<p>The RED may be useful for defining taxonomic ranks based on a molecular phylogeny (e.g. see Parks et al. 2018).
This function is similar to the PhyloRank v0.0.27 script published by Parks et al. (2018).
</p>
<p>The time complexity of this function is O(Nedges).
The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is <code>NULL</code>, then all edges in the input tree are assumed to have length 1.
</p>


<h3>Value</h3>

<p>A numeric vector of length Nnodes, listing the RED of each node in the tree. The REDs of tips are not included, since these would always be equal to 1.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. H. Parks, M. Chuvochina et al. (2018). A standardized bacterial taxonomy based on genome phylogeny substantially revises the tree of life. Nature Biotechnology. 36:996-1004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
params = list(birth_rate_intercept=1, death_rate_intercept=0.8)
tree = generate_random_tree(params, max_time=100, coalescent=FALSE)$tree

# calculate and print REDs
REDs = get_reds(tree)
print(REDs)
</code></pre>

<hr>
<h2 id='get_stationary_distribution'>
Stationary distribution of Markov transition matrix.
</h2><span id='topic+get_stationary_distribution'></span>

<h3>Description</h3>

<p>Calculate the stationary probability distribution vector p for a transition matrix Q of a continuous-time Markov chain. That is, calculate <code class="reqn">p\in[0,1]^n</code> such that <code>sum(p)==0</code> and <code class="reqn">p^TQ=0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stationary_distribution(Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stationary_distribution_+3A_q">Q</code></td>
<td>

<p>A valid transition rate matrix of size Nstates x Nstates, i.e. a quadratic matrix in which every row sums up to zero.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stationary distribution of a discrete-state continuous-time Markov chain is a probability distribution across states that remains constant over time, i.e. <code class="reqn">p^TQ=0</code>. Note that in some cases (i.e. if Q is not irreducible), there may be multiple distinct stationary distributions. In that case,which one is returned by this function is unpredictable. Internally, p is estimated by stepwise minimization of the norm of <code class="reqn">p^TQ</code>, starting with the vector p in which every entry equals 1/Nstates.
</p>


<h3>Value</h3>

<p>A numeric vector of size Nstates and with non-negative entries, satisfying the conditions <code>p%*%Q==0</code> and <code>sum(p)==1.0</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponentiate_matrix">exponentiate_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random 5x5 Markov transition matrix
Q = get_random_mk_transition_matrix(Nstates=5, rate_model="ARD")

# calculate stationary probability distribution
p = get_stationary_distribution(Q)
print(p)

# test correctness (p*Q should be 0, apart from rounding errors)
cat(sprintf("max(abs(p*Q)) = %g\n",max(abs(p %*% Q))))
</code></pre>

<hr>
<h2 id='get_subtree_at_node'>
Extract a subtree descending from a specific node.
</h2><span id='topic+get_subtree_at_node'></span>

<h3>Description</h3>

<p>Given a tree and a focal node, extract the subtree descending from the focal node and place the focal node as the root of the extracted subtree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subtree_at_node(tree, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subtree_at_node_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="get_subtree_at_node_+3A_node">node</code></td>
<td>

<p>Character or integer specifying the name or index, respectively, of the focal node at which to extract the subtree. If an integer, it must be between 1 and <code>tree$Nnode</code>. If a character, it must be a valid entry in <code>tree$node.label</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree need not be rooted, however &quot;descendance&quot; from the focal node is inferred based on the direction of edges in <code>tree$edge</code>. The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>subtree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing the subtree descending from the focal node. This tree will be rooted, with the new root being the focal node.
</p>
</td></tr>
<tr><td><code>new2old_tip</code></td>
<td>

<p>Integer vector of length Ntips_kept (=number of tips in the extracted subtree) with values in 1,..,Ntips, mapping tip indices of the subtree to tip indices in the original tree. In particular, <code>tree$tip.label[new2old_tip]</code> will be equal to <code>subtree$tip.label</code>.
</p>
</td></tr>
<tr><td><code>new2old_node</code></td>
<td>

<p>Integer vector of length Nnodes_kept (=number of nodes in the extracted subtree) with values in 1,..,Nnodes, mapping node indices of the subtree to node indices in the original tree. 
</p>
<p>For example, <code>new2old_node[1]</code> is the index that the first node of the subtree had within the original tree. In particular, <code>tree$node.label[new2old_node]</code> will be equal to <code>subtree$node.label</code> (if node labels are available).
</p>
</td></tr>
<tr><td><code>new2old_edge</code></td>
<td>

<p>Integer vector of length Nedges_kept (=number of edges in the extracted subtree), with values in 1,..,Nedges, mapping edge indices of the subtree to edge indices in the original tree. In particular, <code>tree$edge.length[new2old_edge]</code> will be equal to <code>subtree$edge.length</code> (if edge lengths are available).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_subtree_with_tips">get_subtree_with_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# extract subtree descending from a random node
node = sample.int(tree$Nnode,size=1)
subtree = get_subtree_at_node(tree, node)$subtree

# print summary of subtree
cat(sprintf("Subtree at %d-th node has %d tips\n",node,length(subtree$tip.label)))
</code></pre>

<hr>
<h2 id='get_subtree_with_tips'>
Extract a subtree spanning a specific subset of tips.
</h2><span id='topic+get_subtree_with_tips'></span>

<h3>Description</h3>

<p>Given a rooted tree and a subset of tips, extract the subtree containing only those tips. The root of the tree is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subtree_with_tips(tree, 
                      only_tips               = NULL, 
                      omit_tips               = NULL, 
                      collapse_monofurcations = TRUE, 
                      force_keep_root         = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subtree_with_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_subtree_with_tips_+3A_only_tips">only_tips</code></td>
<td>

<p>Either a character vector listing tip names to keep, or an integer vector listing tip indices to keep (between 1 and Ntips). Can also be <code>NULL</code>. Tips listed in <code>only_tips</code> not found in the tree will be silently ignored.
</p>
</td></tr>
<tr><td><code id="get_subtree_with_tips_+3A_omit_tips">omit_tips</code></td>
<td>

<p>Either a character vector listing tip names to omit, or an integer vector listing tip indices to omit (between 1 and Ntips). Can also be <code>NULL</code>. Tips listed in <code>omit_tips</code> not found in the tree will be silently ignored.
</p>
</td></tr>
<tr><td><code id="get_subtree_with_tips_+3A_collapse_monofurcations">collapse_monofurcations</code></td>
<td>

<p>A logical specifying whether nodes with a single outgoing edge remaining should be collapsed (removed). Incoming and outgoing edge of such nodes will be concatenated into a single edge, connecting the parent (or earlier) and child (or later) of the node. In that case, the returned tree will have edge lengths that reflect the concatenated edges.
</p>
</td></tr>
<tr><td><code id="get_subtree_with_tips_+3A_force_keep_root">force_keep_root</code></td>
<td>

<p>Logical, specifying whether to keep the root even if <code>collapse_monofurcations==TRUE</code> and the root of the subtree is left with a single child. If <code>FALSE</code>, and <code>collapse_monofurcations==TRUE</code>, the root may be removed and one of its descendants may become root.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>only_tips</code> and <code>omit_tips</code> are <code>NULL</code>, then all tips are kept and the tree remains unchanged. If both <code>only_tips</code> and <code>omit_tips</code> are non-<code>NULL</code>, then only tips listed in <code>only_tips</code> and not listed in <code>omit_tips</code> will be kept. If <code>only_tips</code> and/or <code>omit_tips</code> is a character vector listing tip names, then <code>tree$tip.label</code> must exist.
</p>
<p>If the input tree does not include <code>edge.length</code>, each edge in the input tree is assumed to have length 1. The root of the tree (which is always kept) is assumed to be the unique node with no incoming edge. The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time complexity of this function is O(Nnodes+Ntips), where Ntips is the number of tips and Nnodes the number of nodes in the input tree.
</p>
<p>When <code>only_tips==NULL</code>, <code>omit_tips!=NULL</code>, <code>collapse_monofurcations==TRUE</code> and <code>force_keep_root==FALSE</code>, this function is analogous to the function <code>drop.tip</code> in the <code>ape</code> package with option <code>trim_internal=TRUE</code> (v. 0.5-64).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>subtree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing only the tips specified by <code>tips_to_keep</code> and the nodes &amp; edges connecting those tips to the root. The returned tree will include <code>edge.lengh</code> as a member variable, listing the lengths of the remaining (possibly concatenated) edges. 
</p>
</td></tr>
<tr><td><code>root_shift</code></td>
<td>

<p>Numeric, indicating the phylogenetic distance between the old and the new root. Will always be non-negative.
</p>
</td></tr>
<tr><td><code>new2old_tip</code></td>
<td>

<p>Integer vector of length Ntips_kept (=number of tips in the extracted subtree) with values in 1,..,Ntips, mapping tip indices of the subtree to tip indices in the original tree. In particular, <code>tree$tip.label[new2old_tip]</code> will be equal to <code>subtree$tip.label</code>.
</p>
</td></tr>
<tr><td><code>new2old_node</code></td>
<td>

<p>Integer vector of length Nnodes_kept (=number of nodes in the extracted subtree) with values in 1,..,Nnodes, mapping node indices of the subtree to node indices in the original tree. 
</p>
<p>For example, <code>new2old_node[1]</code> is the index that the first node of the subtree had within the original tree. In particular, <code>tree$node.label[new2old_node]</code> will be equal to <code>subtree$node.label</code> (if node labels are available).
</p>
</td></tr>
<tr><td><code>old2new_tip</code></td>
<td>

<p>Integer vector of length Ntips, with values in 1,..,Ntips_kept, mapping tip indices of the original tree to tip indices in the subtree (a value of 0 is used whenever a tip is absent in the subtree). This is essentially the inverse of the mapping <code>new2old_tip</code>.
</p>
</td></tr>
<tr><td><code>old2new_node</code></td>
<td>

<p>Integer vector of length Nnodes, with values in 1,..,Nnodes_kept, mapping node indices of the original tree to node indices in the subtree (a value of 0 is used whenever a node is absent in the subtree). This is essentially the inverse of the mapping <code>new2old_node</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_subtree_at_node">get_subtree_at_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# choose a random subset of tips
tip_subset = sample.int(Ntips, size=as.integer(Ntips/10), replace=FALSE)

# extract subtree spanning the chosen tip subset
subtree = get_subtree_with_tips(tree, only_tips=tip_subset)$subtree

# print summary of subtree
cat(sprintf("Subtree has %d tips and %d nodes\n",length(subtree$tip.label),subtree$Nnode))
</code></pre>

<hr>
<h2 id='get_subtrees_at_nodes'>
Extract subtrees descending from specific nodes.
</h2><span id='topic+get_subtrees_at_nodes'></span>

<h3>Description</h3>

<p>Given a tree and a list of focal nodes, extract the subtrees descending from those focal nodes, with the focal nodes becoming the roots of the extracted subtrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subtrees_at_nodes(tree, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subtrees_at_nodes_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="get_subtrees_at_nodes_+3A_nodes">nodes</code></td>
<td>

<p>Character vector or integer vector specifying the names or indices, respectively, of the focal nodes at which to extract the subtrees. If an integer vector, entries must be between 1 and <code>tree$Nnode</code>. If a character vector, each entry must be a valid entry in <code>tree$node.label</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree need not be rooted, however &quot;descendance&quot; from a focal node is inferred based on the direction of edges in <code>tree$edge</code>. The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>subtrees</code></td>
<td>

<p>List of the same length as <code>nodes</code>, with each element being a new tree of class &quot;phylo&quot;, containing the subtrees descending from the focal nodes. Each subtree will be rooted at the corresponding focal node.
</p>
</td></tr>
<tr><td><code>new2old_tip</code></td>
<td>

<p>List of the same length as <code>nodes</code>, with the n-th element being an integer vector with values in 1,..,Ntips, mapping tip indices of the n-th subtree to tip indices in the original tree. In particular, <code>tree$tip.label[new2old_tip[[n]]]</code> will be equal to <code>subtrees[[n]]$tip.label</code>.
</p>
</td></tr>
<tr><td><code>new2old_node</code></td>
<td>

<p>List of the same length as <code>nodes</code>, with the n-th element being an integer vector with values in 1,..,Nnodes, mapping node indices of the n-th subtree to node indices in the original tree. 
</p>
<p>For example, <code>new2old_node[[2]][1]</code> is the index that the 1st node of the 2nd subtree had within the original tree. In particular, <code>tree$node.label[new2old_node[[n]]]</code> will be equal to <code>subtrees[[n]]$node.label</code> (if node labels are available).
</p>
</td></tr>
<tr><td><code>new2old_edge</code></td>
<td>

<p>List of the same length as <code>nodes</code>, with the n-th element being an integer vector with values in 1,..,Nedges, mapping edge indices of the n-th subtree to edge indices in the original tree. In particular, <code>tree$edge.length[new2old_edge[[n]]]</code> will be equal to <code>subtrees[[n]]$edge.length</code> (if edge lengths are available).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_subtree_at_node">get_subtree_at_node</a></code>,
</p>
<p><code><a href="#topic+get_subtree_with_tips">get_subtree_with_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# extract subtrees descending from random nodes
nodes = sample.int(tree$Nnode,size=10)
subtrees = get_subtrees_at_nodes(tree, nodes)$subtrees

# print summaries of extracted subtrees
for(n in length(nodes)){
  cat(sprintf("Subtree at %d-th node has %d tips\n",nodes[n],length(subtrees[[n]]$tip.label)))
}
</code></pre>

<hr>
<h2 id='get_tips_for_mrcas'>
Find tips with specific most recent common ancestors.
</h2><span id='topic+get_tips_for_mrcas'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a list of nodes (&quot;MRCA nodes&quot;), for each MRCA node find a set of descending tips (&quot;MRCA-defining tips&quot;) such that their most recent common ancestor (MRCA) is that node. This may be useful for cases where nodes need to be described as MRCAs of tip pairs for input to certain phylogenetics algorithms (e.g., for tree dating).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tips_for_mrcas(tree, mrca_nodes, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tips_for_mrcas_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_tips_for_mrcas_+3A_mrca_nodes">mrca_nodes</code></td>
<td>

<p>Either an integer vector or a character vector, listing the nodes for each of which an MRCA-defining set of tips is to be found. If an integer vector, it should list node indices (i.e. from 1 to Nnodes). If a character vector, it should list node names; in that case <code>tree$node.label</code> must exist.
</p>
</td></tr>
<tr><td><code id="get_tips_for_mrcas_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At most 2 MRCA-defining tips are assigned to each MRCA node.
This function assumes that each of the <code>mrca_nodes</code> has at least two children or has a child that is a tip (otherwise the problem is not well-defined). The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time complexity of this function is O(Ntips+Nnodes) + O(Nmrcas), where Ntips is the number of tips, Nnodes is the number of nodes in the tree and Nmrcas is equal to <code>length(mrca_nodes)</code>.
</p>


<h3>Value</h3>

<p>A list of the same size as <code>mrca_nodes</code>, whose n-th element is an integer vector of tip indices (i.e. with values in 1,..,Ntips) whose MRCA is the n-th node listed in <code>mrca_nodes</code>.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_mrcas">get_pairwise_mrcas</a></code>, <code><a href="#topic+get_mrca_of_set">get_mrca_of_set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# pick random nodes
focal_nodes = sample.int(n=tree$Nnode, size=3, replace=FALSE)

# get tips for mrcas
tips_per_focal_node = get_tips_for_mrcas(tree, focal_nodes);

# check correctness (i.e. calculate actual MRCAs of tips)
for(n in 1:length(focal_nodes)){
  mrca = get_mrca_of_set(tree, tips_per_focal_node[[n]])
  cat(sprintf("Focal node = %d, should match mrca of tips = %d\n",focal_nodes[n],mrca-Ntips))
}
</code></pre>

<hr>
<h2 id='get_trait_acf'>
Phylogenetic autocorrelation function of a numeric trait.
</h2><span id='topic+get_trait_acf'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a numeric (typically continuous) trait with known value (state) on each tip, calculate the phylogenetic autocorrelation function (ACF) of the trait. The ACF is a function of phylogenetic distance x, where ACF(x) is the Pearson autocorrelation of the trait between two tips, provided that the tips have phylogenetic (&quot;patristic&quot;) distance x. The function <code>get_trait_acf</code> also calculates the mean absolute difference and the mean relative difference of the trait between any two random tips at phylogenetic distance x (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trait_acf(tree, 
              tip_states,
              Npairs            = 10000,
              Nbins             = NULL,
              min_phylodistance = 0,
              max_phylodistance = NULL,
              uniform_grid      = FALSE,
              phylodistance_grid= NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trait_acf_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the value of the trait at each tip in the tree. Note that tip_states[i] (where i is an integer index) must correspond to the i-th tip in the tree.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_npairs">Npairs</code></td>
<td>

<p>Total number of random tip pairs to draw. A greater number of tip pairs will improve the accuracy of the estimated ACF within each distance bin. Tip pairs are drawn randomly with replacement. If <code>Npairs&lt;=0</code>, then every tip pair is included exactly once.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_nbins">Nbins</code></td>
<td>

<p>Number of distance bins to consider within the range of phylogenetic distances encountered between tip pairs in the tree. A greater number of bins will increase the resolution of the ACF as a function of phylogenetic distance, but will decrease the number of tip pairs falling within each bin (which reduces the accuracy of the estimated ACF). If <code>NULL</code>, then <code>Nbins</code> is automatically and somewhat reasonably chosen based on the size of the input trees.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_min_phylodistance">min_phylodistance</code></td>
<td>

<p>Numeric, minimum phylogenetic distance to conssider. Only relevant if <code>phylodistance_grid</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_max_phylodistance">max_phylodistance</code></td>
<td>

<p>Numeric, optional maximum phylogenetic distance to consider. If <code>NULL</code>, this is automatically set to the maximum phylodistance between any two tips.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_uniform_grid">uniform_grid</code></td>
<td>

<p>Logical, specifying whether the phylodistance grid should be uniform, i.e., with equally sized phylodistance bins. If <code>FALSE</code>, then the grid is chosen non-uniformly (i.e., each bin has different size) such that each bin roughly contains the same number of tip pairs. This helps equalize the estimation error across bins. Only relevant if <code>phylodistance_grid</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="get_trait_acf_+3A_phylodistance_grid">phylodistance_grid</code></td>
<td>

<p>Numeric vector, optional explicitly specified phylodistance bins (left boundaries thereof) on which to evaluate the ACF. Must contain non-negative numbers in strictly ascending order. Hence, the first bin will range from <code>phylodistance_grid[1]</code> to <code>phylodistance_grid[2]</code>, while the last bin will range from <code>tail(phylodistance_grid,1)</code> to <code>max_phylodistance</code>. Can be used as an alternative to <code>Nbins</code>. If non-<code>NULL</code>, then <code>Nbins</code>, <code>min_phylodistance</code> and <code>uniform_grid</code> are irrelevant. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The phylogenetic autocorrelation function (ACF) of a trait can give insight into the evolutionary processes shaping its distribution across clades. An ACF that decays slowly with increasing phylogenetic distance indicates a strong phylogenetic conservatism of the trait, whereas a  rapidly decaying ACF indicates weak phylogenetic conservatism. Similarly, if the mean absolute difference in trait value between two random tips increases with phylogenetic distance, this indicates a phylogenetic autocorrelation of the trait (Zaneveld et al. 2014). Here, phylogenetic distance between tips refers to their patristic distance, i.e. the minimum cumulative edge length required to connect the two tips.
</p>
<p>Since the phylogenetic distances between all possible tip pairs do not cover a continuoum (as there is only a finite number of tips), this function randomly draws tip pairs from the tree, maps them onto a finite set of equally-sized distance bins and then estimates the ACF for the centroid of each distance bin based on tip pairs in that bin. In practice, as a next step one would usually plot the estimated ACF (returned vector <code>autocorrelations</code>) over the centroids of the distance bins (returned vector <code>distances</code>).
</p>
<p>Phylogenetic distance bins can be specified in two alternative ways: Either a set of bins (phylodistance grid) is automatically calculated based on the provided <code>Nbins</code>, <code>min_phylodistance</code>, <code>max_phylodistance</code> and <code>uniform_grid</code>, or a phylodistance grid is explicitly provided via <code>phylodistance_grid</code> and <code>max_phylodistance</code>.
</p>
<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). If <code>tree$edge.length</code> is missing, then every edge is assumed to have length 1. The input tree must be rooted at some node for technical reasons (see function <code><a href="#topic+root_at_node">root_at_node</a></code>), but the choice of the root node does not influence the result.
</p>
<p>This function assumes that each tip is assigned exactly one trait value. This might be problematic in situations where each tip covers a range of trait values, for example if tips are species and multiple individuals were sampled from each species. In that case, one might consider representing each individual as a separate tip in the tree, so that each tip has exactly one trait value.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the center of each phylodistance bin in increasing order. This is equal to <code>0.5*(left_phylodistances+right_phylodistances)</code>. Typically, you will want to plot <code>autocorrelations</code> over <code>phylodistances</code>.
</p>
</td></tr>
<tr><td><code>left_phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the left boundary of each phylodistance bin in increasing order.
</p>
</td></tr>
<tr><td><code>right_phylodistances</code></td>
<td>

<p>Numeric vector of size Nbins, storing the right boundary of each phylodistance bin in increasing order.
</p>
</td></tr>
<tr><td><code>autocorrelations</code></td>
<td>

<p>Numeric vector of size Nbins, storing the estimated Pearson autocorrelation of the trait for each distance bin.
</p>
</td></tr>
<tr><td><code>mean_abs_differences</code></td>
<td>

<p>Numeric vector of size Nbins, storing the mean absolute difference of the trait between tip pairs in each distance bin.
</p>
</td></tr>
<tr><td><code>mean_rel_differences</code></td>
<td>

<p>Numeric vector of size Nbins, storing the mean relative difference of the trait between tip pairs in each distance bin. The relative difference between two values <code class="reqn">X</code> and <code class="reqn">Y</code> is 0 if <code class="reqn">X==Y</code>, and equal to 
</p>
<p style="text-align: center;"><code class="reqn">\frac{|X-Y|}{0.5\cdot (|X|+|Y|)}</code>
</p>

<p>otherwise.
</p>
</td></tr>
<tr><td><code>Npairs_per_distance</code></td>
<td>

<p>Integer vector of size Nbins, storing the number of random tip pairs associated with each phylodistance bin.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+consentrait_depth">consentrait_depth</a></code>, 
<code><a href="#topic+geographic_acf">geographic_acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_factor=0.1),max_tips=1000)$tree

# simulate continuous trait evolution on the tree
tip_states = simulate_ou_model(tree, 
                               stationary_mean  = 0,
                               stationary_std   = 1,
                               decay_rate       = 0.01)$tip_states

# calculate autocorrelation function
ACF = get_trait_acf(tree, tip_states, Nbins=10, uniform_grid=TRUE)

# plot ACF (autocorrelation vs phylogenetic distance)
plot(ACF$phylodistances, ACF$autocorrelations, type="l", xlab="distance", ylab="ACF")
</code></pre>

<hr>
<h2 id='get_trait_stats_over_time'>
Calculate mean &amp; standard deviation of a numeric trait on a dated tree over time.
</h2><span id='topic+get_trait_stats_over_time'></span>

<h3>Description</h3>

<p>Given a rooted and dated phylogenetic tree, and a scalar numeric trait with known value on each node and tip of the tree, calculate the mean and the variance of the trait's states across the tree at discrete time points. For example, if the trait represents &quot;body size&quot;, then this function calculates the mean body size of extant clades over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trait_stats_over_time(tree,
                          states, 
                          Ntimes            = NULL,
                          times             = NULL,
                          include_quantiles = TRUE,
                          check_input       = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trait_stats_over_time_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;, where edge lengths represent time intervals (or similar).
</p>
</td></tr>
<tr><td><code id="get_trait_stats_over_time_+3A_states">states</code></td>
<td>

<p>Numeric vector, specifying the trait's state at each tip and each node of the tree (in the order in which tips &amp; nodes are indexed). May include <code>NA</code> or <code>NaN</code> if values are missing for some tips/nodes.
</p>
</td></tr>
<tr><td><code id="get_trait_stats_over_time_+3A_ntimes">Ntimes</code></td>
<td>

<p>Integer, number of equidistant time points for which to calculade clade counts. Can also be <code>NULL</code>, in which case <code>times</code> must be provided.
</p>
</td></tr>
<tr><td><code id="get_trait_stats_over_time_+3A_times">times</code></td>
<td>

<p>Integer vector, listing time points (in ascending order) for which to calculate clade counts. Can also be <code>NULL</code>, in which case <code>Ntimes</code> must be provided.
</p>
</td></tr>
<tr><td><code id="get_trait_stats_over_time_+3A_include_quantiles">include_quantiles</code></td>
<td>

<p>Logical, specifying whether to include information on quantiles (e.g., median, CI95, CI50) of the trait over time, in addition to the means and standard deviations. This option increases computation time and memory needs for large trees, so if you only care about means and standard deviations you can set this to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="get_trait_stats_over_time_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree$edge.length</code> is missing, then every edge in the tree is assumed to be of length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child). The tree need not be ultrametric (e.g. may include extinct tips), although in general this function only makes sense if edge lengths correspond to time (or similar).
</p>
<p>Either <code>Ntimes</code> or <code>times</code> must be non-<code>NULL</code>, but not both. <code>states</code> need not include names; if it does, then these are checked to be in the same order as in the tree (if <code>check_input==TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Ntimes</code></td>
<td>

<p>Integer, indicating the number of returned time points. Equal to the provided <code>Ntimes</code> if applicable.
</p>
</td></tr>
<tr><td><code>times</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the considered time points in increasing order. If <code>times</code> was provided as an argument to the function, then this will be the same as provided.
</p>
</td></tr>
<tr><td><code>clade_counts</code></td>
<td>

<p>Integer vector of size Ntimes, listing the number of tips or nodes considered at each time point.
</p>
</td></tr>
<tr><td><code>means</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the arithmetic mean of trait states at each time point.
</p>
</td></tr>
<tr><td><code>stds</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the standard deviation of trait states at each time point.
</p>
</td></tr>
<tr><td><code>medians</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the median trait state at each time point. Only returned if <code>include_uantiles=TRUE</code>.
</p>
</td></tr>
<tr><td><code>CI50lower</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the lower end of the equal-tailed 50% range of trait states (i.e., the 25% percentile) at each time point. Only returned if <code>include_uantiles=TRUE</code>.
</p>
</td></tr>
<tr><td><code>CI50upper</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the upper end of the equal-tailed 50% range of trait states (i.e., the 75% percentile) at each time point. Only returned if <code>include_uantiles=TRUE</code>.
</p>
</td></tr>
<tr><td><code>CI95lower</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the lower end of the equal-tailed 95% range of trait states (i.e., the 2.5% percentile) at each time point. Only returned if <code>include_uantiles=TRUE</code>.
</p>
</td></tr>
<tr><td><code>CI95upper</code></td>
<td>

<p>Numeric vector of size Ntimes, listing the upper end of the equal-tailed 95% range of trait states (i.e., the 97.5% percentile) at each time point. Only returned if <code>include_uantiles=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1), max_tips=1000)$tree

# simulate a numeric trait under Brownian-motion
trait = simulate_bm_model(tree, diffusivity=1)
states = c(trait$tip_states,trait$node_states)

# calculate trait stats over time
results = get_trait_stats_over_time(tree, states, Ntimes=100)

# plot trait stats over time (mean +/- std)
M = results$means
S = results$stds
matplot(x=results$times, 
        y=matrix(c(M-S,M+S),ncol=2,byrow=FALSE),
        main = "Simulated BM trait over time",
        lty = 1, col="black",
        type="l", xlab="time", ylab="mean +/- std")
</code></pre>

<hr>
<h2 id='get_transition_index_matrix'>
Create an index matrix for a Markov transition model.
</h2><span id='topic+get_transition_index_matrix'></span>

<h3>Description</h3>

<p>Create an index matrix encoding the parametric structure of the transition rates in a discrete-state continuous-time Markov model (e.g., Mk model of trait evolution). Such an index matrix is required by certain functions for mapping independent rate parameters to transition rates. For example, an index matrix may encode the information that each rate i&ndash;&gt;j is equal to its reversed counterpart j&ndash;&gt;i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transition_index_matrix(Nstates, rate_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_transition_index_matrix_+3A_nstates">Nstates</code></td>
<td>

<p>Integer, the number of distinct states represented in the transition matrix (number of rows &amp; columns).
</p>
</td></tr>
<tr><td><code id="get_transition_index_matrix_+3A_rate_model">rate_model</code></td>
<td>

<p>Rate model that the transition matrix must satisfy. Can be &quot;ER&quot; (all rates equal), &quot;SYM&quot; (transition rate i&ndash;&gt;j is equal to transition rate j&ndash;&gt;i), &quot;ARD&quot; (all rates can be different) or &quot;SUEDE&quot; (only stepwise transitions i&ndash;&gt;i+1 and i&ndash;&gt;i-1 allowed, all 'up' transitions are equal, all 'down' transitions are equal).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned index matrix will include as many different positive integers as there are independent rate parameters in the requested rate model, plus potentially the value 0 (which has a special meaning, see below).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>index_matrix</code></td>
<td>

<p>Integer matrix of size Nstates x Nstates, with values between 0 and Nstates, assigning each entry in the transition matrix to an independent transition rate parameter. A value of 0 means that the corresponding rate is fixed to zero (if off-diagonal) or will be adjusted to ensure a valid Markov transition rate matrix (if on the diagonal).
</p>
</td></tr>
<tr><td><code>Nrates</code></td>
<td>

<p>Integer, the number of independent rate parameters in the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_random_mk_transition_matrix">get_random_mk_transition_matrix</a></code>
</p>

<hr>
<h2 id='get_tree_span'>
Get min and max distance of any tip to the root.
</h2><span id='topic+get_tree_span'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, calculate the minimum and maximum phylogenetic distance (cumulative branch length) of any tip from the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tree_span(tree, as_edge_count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tree_span_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_tree_span_+3A_as_edge_count">as_edge_count</code></td>
<td>

<p>Logical, specifying whether distances should be counted in number of edges, rather than cumulative edge length. This is the same as if all edges had length 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree$edge.length</code> is missing, then every edge in the tree is assumed to be of length 1. The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
The asymptotic average time complexity of this function is O(Nedges), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>min_distance</code></td>
<td>

<p>Minimum phylogenetic distance that any of the tips has to the root.
</p>
</td></tr>
<tr><td><code>max_distance</code></td>
<td>

<p>Maximum phylogenetic distance that any of the tips has to the root.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_pairwise_distances">get_pairwise_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips   = 1000
params  = list(birth_rate_intercept=1, death_rate_intercept=0.5)
tree    = generate_random_tree(params, max_tips=Ntips, coalescent=FALSE)$tree

# calculate min &amp; max tip distances from root
tree_span = get_tree_span(tree)
cat(sprintf("Tip min dist = %g, max dist = %g\n",
            tree_span$min_distance,
            tree_span$max_distance))
</code></pre>

<hr>
<h2 id='get_tree_traversal_root_to_tips'>
Traverse tree from root to tips.
</h2><span id='topic+get_tree_traversal_root_to_tips'></span>

<h3>Description</h3>

<p>Create data structures for traversing a tree from root to tips, and for efficient retrieval of a node's outgoing edges and children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tree_traversal_root_to_tips(tree, include_tips)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tree_traversal_root_to_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="get_tree_traversal_root_to_tips_+3A_include_tips">include_tips</code></td>
<td>

<p>Include tips in the tarversal queue. If FALSE, then only nodes are included in the queue.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many dynamic programming algorithms for phylogenetics involve traversing the tree in a certain direction (root to tips or tips to root), and efficient (O(1) complexity) access to a node's direct children can significantly speed up those algorithms. This function is meant to provide data structures that allow traversing the tree's nodes (and optionally tips) in such an order that each node is traversed prior to its descendants (root&ndash;&gt;tips) or such that each node is traversed after its descendants (tips&ndash;&gt;root). This function is mainly meant for use in other algorithms, and is probably of little relevance to the average user.
</p>
<p>The tree may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>The asymptotic time and memory complexity of this function is O(Ntips), where Ntips is the number of tips in the tree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>queue</code></td>
<td>

<p>An integer vector of size Nnodes (if <code>include_tips</code> was <code>FALSE</code>) or of size Nnodes+Ntips (if <code>include_tips</code> was <code>TRUE</code>), listing indices of nodes (and optionally tips) in the order root&ndash;&gt;tips described above. In particular, <code>queue[1]</code> will be the index of the tree's root (typically Ntips+1).
</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>

<p>An integer vector of size Nedges (<code>=nrow(tree$edge)</code>), listing indices of edges (corresponding to <code>tree$edge</code>) such that outgoing edges of the same node are listed in consequtive order.
</p>
</td></tr>
<tr><td><code>node2first_edge</code></td>
<td>

<p>An integer vector of size Nnodes listing the location of the first outgoing edge of each node in <code>edges</code>. That is, <code>edges[node2first_edge[n]]</code> points to the first outgoing edge of node n in <code>tree$edge</code>.
</p>
</td></tr>
<tr><td><code>node2last_edge</code></td>
<td>

<p>An integer vector of size Nnodes listing the location of the last outgoing edge of each node in <code>edges</code>. That is, <code>edges[node2last_edge[n]]</code> points to the last outgoing edge of node n in <code>tree$edge</code>. The total number of outgoing edges of a node is thus given by <code>1+node2last_edge[n]-node2first_edge[n]</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+reorder_tree_edges">reorder_tree_edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_factor=1), max_tips=100)$tree

# get tree traversal
traversal = get_tree_traversal_root_to_tips(tree, include_tips=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='hsp_binomial'>
Hidden state prediction for a binary trait based on the binomial distribution.
</h2><span id='topic+hsp_binomial'></span>

<h3>Description</h3>

<p>Estimate the state probabilities for a binary trait at ancestral nodes and tips with unknown (hidden) state, by fitting the probability parameter of a binomial distribution to empirical state frequencies. For each node, the states of its descending tips are assumed to be drawn randomly and independently according to some a priori unknown probability distribution. The probability P1 (probability of any random descending tip being in state 1) is estimated separately for each node based on the observed states in the descending tips via maximum likelihood. 
</p>
<p>This function can account for potential state-measurement errors, hidden states and reveal biases (i.e., tips in one particular state being more likely to be measured than in the other state). Only nodes with a number of non-hidden tips above a certain threshold are included in the ML-estimation phase. All other nodes and hidden tips are then assigned the probabilities estimated for the most closely related ancestral node with estimated probabilities. This function is a generalization of <code><a href="#topic+hsp_empirical_probabilities">hsp_empirical_probabilities</a></code> that can account for potential state-measurement errors and reveal biases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_binomial( tree, 
              tip_states,
              reveal_probs  = NULL,
              state1_probs  = NULL,
              min_revealed  = 1,
              max_STE       = Inf,
              check_input   = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_binomial_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_tip_states">tip_states</code></td>
<td>

<p>Integer vector of length Ntips, specifying the state of each tip in the tree (either 1 or 2). <code>tip_states</code> can include <code>NA</code> to indicate a hidden (non-measured) tip state.
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_reveal_probs">reveal_probs</code></td>
<td>

<p>2D numeric matrix of size Ntips x 2, listing tip-specific reveal probabilities at each tip conditional on the tip's true state. Hence <code>reveal_probs[n,s]</code> is the probability that tip <code>n</code> would have a measured (non-hidden) state if its true state was <code>s</code>.
May also be a vector of length 2 (same <code>reveal_probs</code> for all tips) or <code>NULL</code> (unbiased reveal probs).
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_state1_probs">state1_probs</code></td>
<td>

<p>2D numeric matrix of size Ntips x 2, listing the probability of measuring state 1 (potentially erroneously) at each tip conditional upon its true state and conditional upon its state having been measured (i.e., being non-hidden). For example, for an incompletely sequenced genome with completion level <code>C_n</code> and state 1 indicating presence and state 2 indicating absence of a gene, and assuming error-free detection of genes within the covered regions, one has <code>state1_probs[n,1] = C_n</code> and <code>state1_probs[n,2]=0</code>. <code>state1_probs</code> may also be a vector of length 2 (same probabilities for all tips) or <code>NULL</code>. If <code>NULL</code>, state measurements are assumed error-free, and hence this is the same as <code>c(1,0)</code>.
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_min_revealed">min_revealed</code></td>
<td>

<p>Non-negative integer, specifying the minimum number of tips with non-hidden state that must descend from a node for estimating its P1 via maximum likelihood. For nodes with too few descending tips with non-hidden state, the probability P1 will not be estimated via maximum likelihood, and instead will be set to the P1 estimated for the nearest possible ancestral node. It is advised to set this threshold greater than zero (typical values are 2&ndash;10).
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_max_ste">max_STE</code></td>
<td>

<p>Non-negative numeric, specifying the maximum acceptable estimated standard error (STE) for the estimated probability P1 for a node. If the STE for a node exceeds this threshold, the P1 for that node is set to the P1 of the nearest ancestor with STE below that threshold. Setting this to <code>Inf</code> disables this functionality. The STE is estimated based on the Observed Fisher Information Criterion (which, strictly speaking, only provides a lower bound for the STE).
</p>
</td></tr>
<tr><td><code id="hsp_binomial_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some additional time-consuming checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently only supports binary traits, and states must be represented by integers 1 or 2. Any <code>NA</code> entries in <code>tip_states</code> are interpreted as hidden (non-revealed) states.
</p>
<p>The algorithm proceeds in two phases (&quot;ASR&quot; phase and &quot;HSP&quot; phase). In the ASR phase the state probability P1 is estimated separately for every node and tip satisfying the thresholds <code>min_revealed</code> and <code>max_STE</code>, via maximum-likelihood. In the HSP phase, the P1 of nodes and tips not included in the ASR phase is set to the P1 of the nearest ancestral node with estimated P1, as described by Zaneveld and Thurber (2014).
</p>
<p>This function yields estimates for the state probabilities P1 (note that P2=1-P1). In order to obtain point estimates for tip states one needs to interpret these probabilities in a meaningful way, for example by choosing as point estimate for each tip the state with highest probability P1 or P2; the closest that probability is to 1, the more reliable the point estimate will be.
</p>
<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). This function has asymptotic time complexity O(Nedges x Nstates).
Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, an additional element <code>error</code> (character) will be returned describing the error, while all other return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>P1</code></td>
<td>

<p>Numeric vector of length Ntips+Nnodes, listing the estimated probability of being in state 1 for each tip and node. A value of P1[n]=0 or P1[n]=1 means that the n-th tip/node is in state 2 or state 1 with absolute certainty, respectively. Note that even tips with non-hidden state may have have a P1 that is neither 0 or 1, if state measurements are erroneous (i.e., if <code>state1_probs[n,]</code> differs from <code>(1,0)</code>). 
</p>
</td></tr>
<tr><td><code>STE</code></td>
<td>

<p>Numeric vector of length Ntips+Nnodes, listing the standard error of the estimated P1 at each tip and node, according to the Observed Fisher Information Criterion. Note that the latter strictly speaking only provides a lower bound on the standard error.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, with values in {1,2}, listing the maximum-likelihood estimate of the state in each tip &amp; node.
</p>
</td></tr>
<tr><td><code>reveal_counts</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, listing the number of tips with non-hidden state descending from each tip and node.
</p>
</td></tr>
<tr><td><code>inheritted</code></td>
<td>

<p>Logical vector of length Ntips+Nnodes, specifying for each tip or node whether its returned P1 was directly maximum-likelihood estimated duirng the ASR phase (<code>inheritted[n]==FALSE</code>) or set to the P1 estimated for an ancestral node during the HSP phase (<code>inheritted[n]==TRUE</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+hsp_empirical_probabilities">hsp_empirical_probabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips =50
tree = generate_random_tree(list(birth_rate_factor=1),max_tips=Ntips)$tree

# simulate a binary trait on the tips
Q = get_random_mk_transition_matrix(Nstates=2, rate_model="ER", min_rate=0.1, max_rate=0.5)
tip_states = simulate_mk_model(tree, Q)$tip_states

# print tip states
cat(sprintf("True tip states:\n"))
print(tip_states)

# hide some of the tip states
# include a reveal bias
reveal_probs = c(0.8, 0.3)
revealed = sapply(1:Ntips, FUN=function(n) rbinom(n=1,size=1,prob=reveal_probs[tip_states[n]]))
input_tip_states = tip_states
input_tip_states[!revealed] = NA

# predict state probabilities P1 and P2
hsp = hsp_binomial(tree, input_tip_states, reveal_probs=reveal_probs, max_STE=0.2)
probs = cbind(hsp$P1,1-hsp$P1)

# pick most likely state as a point estimate
# only accept point estimate if probability is sufficiently high
estimated_tip_states = max.col(probs[1:Ntips,])
estimated_tip_states[probs[cbind(1:Ntips,estimated_tip_states)]&lt;0.8] = NA
cat(sprintf("ML-predicted tip states:\n"))
print(estimated_tip_states)

# calculate fraction of correct predictions
predicted = which((!revealed) &amp; (!is.na(estimated_tip_states)))
if(length(predicted)&gt;0){
  Ncorrect  = sum(tip_states[predicted]==estimated_tip_states[predicted])
  cat(sprintf("%.2g%% of predictions are correct\n",(100.0*Ncorrect)/length(predicted)))
}else{
  cat(sprintf("None of the tip states could be reliably predicted\n"))
}

## End(Not run)</code></pre>

<hr>
<h2 id='hsp_empirical_probabilities'>
Hidden state prediction via empirical probabilities.
</h2><span id='topic+hsp_empirical_probabilities'></span>

<h3>Description</h3>

<p>Reconstruct ancestral discrete states of nodes and predict unknown (hidden) states of tips on a tree based on empirical state probabilities across tips. This is a very crude HSP method, and other more sophisticated methods should be preferred (e.g. <code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_empirical_probabilities(tree, tip_states, 
                            Nstates=NULL, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_empirical_probabilities_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_empirical_probabilities_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree as an integer from 1 to Nstates, where Nstates is the possible number of states (see below). <code>tip_states</code> can include <code>NA</code> to indicate an unknown tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_empirical_probabilities_+3A_nstates">Nstates</code></td>
<td>

<p>Either <code>NULL</code>, or an integer specifying the number of possible states of the trait. If <code>NULL</code>, then it will be computed based on the maximum non-<code>NA</code> value encountered in <code>tip_states</code>
</p>
</td></tr>
<tr><td><code id="hsp_empirical_probabilities_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown states. Prior to ancestral state reconstruction, the tree is temporarily prunned, keeping only tips with known state. The function then calculates the empirical state probabilities for each node in the pruned tree, based on the states across tips descending from each node. The state probabilities of tips with unknown state are set to those of the most recent ancestor with reconstructed states, as described by Zaneveld and Thurber (2014).
</p>
<p>The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). This function has asymptotic time complexity O(Nedges x Nstates).
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree as well as predicting the states of tips with an a priory unknown state. If the state of all tips is known and only ancestral state reconstruction is needed, consider using functions such as <code><a href="#topic+asr_empirical_probabilities">asr_empirical_probabilities</a></code> for improved efficiency.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, some return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>likelihoods</code></td>
<td>

<p>A 2D numeric matrix, listing the probability of each tip and node being in each state. This matrix will have (Ntips+Nnodes) rows and Nstates columns, where Nstates was either explicitly provided as an argument or inferred based on the number of unique values in <code>tip_states</code> (if <code>Nstates</code> was passed as NULL). In the latter case, the column names of this matrix will be the unique values found in <code>tip_states</code>. The rows in this matrix will be in the order in which tips and nodes are indexed in the tree, i.e. the rows 1,..,Ntips store the probabilities for tips, while rows (Ntips+1),..,(Ntips+Nnodes) store the probabilities for nodes. Each row in this matrix will sum up to 1. Note that the return value is named this way for compatibility with other HSP functions.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, with values in {1,..,Nstates}, specifying the maximum-likelihood estimate of the state of each tip &amp; node.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a discrete trait
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER", max_rate=0.1)
tip_states = simulate_mk_model(tree, Q)$tip_states

# print states of first 20 tips
print(tip_states[1:20])

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via MPR
likelihoods = hsp_empirical_probabilities(tree, tip_states, Nstates)$likelihoods
estimated_tip_states = max.col(likelihoods[1:Ntips,])

# print estimated states of first 20 tips
print(estimated_tip_states[1:20])

## End(Not run)</code></pre>

<hr>
<h2 id='hsp_independent_contrasts'>
Hidden state prediction via phylogenetic independent contrasts.
</h2><span id='topic+hsp_independent_contrasts'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states of a continuous (numeric) trait for nodes and predict unknown (hidden) states for tips on a tree using phylogenetic independent contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_independent_contrasts(tree, tip_states, weighted=TRUE, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_independent_contrasts_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_independent_contrasts_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the state of each tip in the tree. <code>tip_states</code> can include <code>NA</code> to indicate an unknown tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_independent_contrasts_+3A_weighted">weighted</code></td>
<td>

<p>Logical, specifying whether to weight transition costs by the inverted edge lengths during ancestral state reconstruction. This corresponds to the &quot;weighted squared-change parsimony&quot; reconstruction by Maddison (1991) for a Brownian motion model of trait evolution.
</p>
</td></tr>
<tr><td><code id="hsp_independent_contrasts_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown (hidden) states to be estimated. Prior to ancestral state reconstruction, the tree is temporarily prunned, keeping only tips with known state. The function then uses a postorder traversal algorithm to calculate the intermediate &quot;X&quot; variables (a state estimate for each node) introduced by Felsenstein (1985) in his phylogenetic independent contrasts method. Note that these are only local estimates, i.e. for each node the estimate is only based on the tip states in the subtree descending from that node (see discussion in Garland and Ives, 2000). The states of tips with hidden state are set to those of the most recent ancestor with reconstructed state, as described by Zaneveld and Thurber (2014).
</p>
<p>This function has asymptotic time complexity O(Nedges).
If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. This is the same as setting <code>weighted=FALSE</code>. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). 
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree as well as predicting the states of tips with an a priory unknown state. If the state of all tips is known and only ancestral state reconstruction is needed, consider using the function <code><a href="#topic+asr_independent_contrasts">asr_independent_contrasts</a></code> for improved efficiency.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, some return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>A numeric vector of size Ntips+Nnodes, listing the reconstructed state of each tip and node. The entries in this vector will be in the order in which tips and nodes are indexed in <code>tree$edge</code>.
</p>
</td></tr>
<tr><td><code>total_sum_of_squared_changes</code></td>
<td>

<p>The total sum of squared changes in tree, minimized by the (optionally weighted) squared-change parsimony algorithm. This is equation 7 in (Maddison, 1991). Note that for the root, phylogenetic independent contrasts is equivalent to Maddison's squared-change parsimony.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. Felsenstein (1985). Phylogenies and the comparative method. The American Naturalist. 125:1-15.
</p>
<p>T. Jr. Garland and A. R. Ives (2000). Using the past to predict the present: Confidence intervals for regression equations in phylogenetic comparative methods. The American Naturalist. 155:346-364.
</p>
<p>W. P. Maddison (1991). Squared-change parsimony reconstructions of ancestral states for continuous-valued characters on a phylogenetic tree. Systematic Zoology. 40:304-314.
</p>
<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>
<code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree, 
                               stationary_mean=0,
                               stationary_std=1,
                               decay_rate=0.001)$tip_states

# print tip states
print(as.vector(tip_states))

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via weighted PIC
estimated_states = hsp_independent_contrasts(tree, tip_states, weighted=TRUE)$states

# print estimated tip states
print(estimated_states[1:Ntips])
</code></pre>

<hr>
<h2 id='hsp_max_parsimony'>
Hidden state prediction via maximum parsimony.
</h2><span id='topic+hsp_max_parsimony'></span>

<h3>Description</h3>

<p>Reconstruct ancestral discrete states of nodes and predict unknown (hidden) states of tips on a tree using maximum parsimony. Transition costs can vary between transitions, and can optionally be weighted by edge length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_max_parsimony(tree, tip_states, Nstates=NULL, 
                  transition_costs="all_equal",
                  edge_exponent=0.0, weight_by_scenarios=TRUE, 
                  check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_max_parsimony_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree as an integer from 1 to Nstates, where Nstates is the possible number of states (see below). <code>tip_states</code> can include <code>NA</code> to indicate an unknown tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_nstates">Nstates</code></td>
<td>

<p>Either <code>NULL</code>, or an integer specifying the number of possible states of the trait. If <code>NULL</code>, then it will be computed based on the maximum non-<code>NA</code> value encountered in <code>tip_states</code>
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_transition_costs">transition_costs</code></td>
<td>

<p>Same as for the function <code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>.
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_edge_exponent">edge_exponent</code></td>
<td>

<p>Same as for the function <code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>.
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_weight_by_scenarios">weight_by_scenarios</code></td>
<td>

<p>Logical, indicating whether to weight each optimal state of a node by the number of optimal maximum-parsimony scenarios in which the node is in that state. If FALSE, then all possible states of a node are weighted equally (i.e. are assigned equal probabilities).
</p>
</td></tr>
<tr><td><code id="hsp_max_parsimony_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. The order of states (if relevant) should be reflected in their integer representation. For example, if your original states are &quot;small&quot;, &quot;medium&quot; and &quot;large&quot; and <code>transition_costs=="sequential"</code>, it is advised to represent these states as integers 1,2,3. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown states. Prior to ancestral state reconstruction, the tree is temporarily prunned, keeping only tips with known state. The function then applies Sankoff's (1975) dynamic programming algorithm for ancestral state reconstruction, which determines the smallest number (or least costly if transition costs are uneven) of state changes along edges needed to reproduce the known tip states. The state probabilities of tips with unknown state are set to those of the most recent ancestor with reconstructed states, as described by Zaneveld and Thurber (2014). This function has asymptotic time complexity O(Ntips+Nnodes x Nstates).
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. If <code>edge_exponent</code> is 0, then edge lengths do not influence the result. If <code>edge_exponent!=0</code>, then all edges must have non-zero length. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). 
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. None of the input vectors or matrixes need include row or column names; if they do, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree as well as predicting the states of tips with an a priory unknown state. If the state of all tips is known and only ancestral state reconstruction is needed, consider using the function <code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code> for improved efficiency.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, some return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>likelihoods</code></td>
<td>

<p>A 2D numeric matrix, listing the probability of each tip and node being in each state. This matrix will have (Ntips+Nnodes) rows and Nstates columns, where Nstates was either explicitly provided as an argument or inferred based on the number of unique values in <code>tip_states</code> (if <code>Nstates</code> was passed as NULL). In the latter case, the column names of this matrix will be the unique values found in <code>tip_states</code>. The rows in this matrix will be in the order in which tips and nodes are indexed in the tree, i.e. the rows 1,..,Ntips store the probabilities for tips, while rows (Ntips+1),..,(Ntips+Nnodes) store the probabilities for nodes. Each row in this matrix will sum up to 1. Note that the return value is named this way for compatibility with other HSP functions.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, with values in {1,..,Nstates}, specifying the maximum-likelihood estimate of the state of each tip &amp; node.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>D. Sankoff (1975). Minimal mutation trees of sequences. SIAM Journal of Applied Mathematics. 28:35-42.
</p>
<p>J. Felsenstein (2004). Inferring Phylogenies. Sinauer Associates, Sunderland, Massachusetts.
</p>
<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_max_parsimony">asr_max_parsimony</a></code>, 
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 10
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a discrete trait
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER")
tip_states = simulate_mk_model(tree, Q)$tip_states

# print tip states
print(tip_states)

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via MPR
likelihoods = hsp_max_parsimony(tree, tip_states, Nstates)$likelihoods
estimated_tip_states = max.col(likelihoods[1:Ntips,])

# print estimated tip states
print(estimated_tip_states)

## End(Not run)</code></pre>

<hr>
<h2 id='hsp_mk_model'>
Hidden state prediction with Mk models and rerooting
</h2><span id='topic+hsp_mk_model'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states of a discrete trait and predict unknown (hidden) states of tips using a fixed-rates continuous-time Markov model (a.k.a. &quot;Mk model&quot;). This function can fit the model (i.e. estimate the transition matrix) using maximum likelihood, or use a specified transition matrix. The function can optionally calculate marginal ancestral state likelihoods for each node in the tree, using the rerooting method by Yang et al. (1995). A subset of the tips may have completely unknown states; in this case the fitted Markov model is used to predict their state likelihoods based on their most recent reconstructed ancestor, as described by Zaneveld and Thurber (2014). The function can account for biases in which tips have known state (&ldquo;reveal bias&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_mk_model( tree, 
              tip_states, 
              Nstates = NULL, 
              reveal_fractions = NULL,
              tip_priors = NULL, 
              rate_model = "ER", 
              transition_matrix = NULL, 
              include_likelihoods = TRUE,
              root_prior = "empirical", 
              Ntrials = 1, 
              optim_algorithm = "nlminb",
              optim_max_iterations = 200,
              optim_rel_tol = 1e-8,
              store_exponentials = TRUE,
              check_input = TRUE, 
              Nthreads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_mk_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_tip_states">tip_states</code></td>
<td>

<p>An integer vector of size Ntips, specifying the state of each tip in the tree in terms of an integer from 1 to Nstates, where Nstates is the possible number of states (see below). Can also be <code>NULL</code>, in which case <code>tip_priors</code> must not be <code>NULL</code> (see below). <code>tip_states</code> can include <code>NA</code> to indicate an unknown (hidden) tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_nstates">Nstates</code></td>
<td>

<p>Either NULL, or an integer specifying the number of possible states of the trait. If <code>Nstates==NULL</code>, then it will be computed based on the maximum non-<code>NA</code> value encountered in <code>tip_states</code> or based on the number of columns in <code>tip_priors</code> (whichever is non-<code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_reveal_fractions">reveal_fractions</code></td>
<td>

<p>Either NULL, or a numeric vector of size Nstates, specifying the fraction of tips with revealed (i.e., non-hidden) state, depending on the tip state. That is, <code>reveal_fractions[s]</code> is the probability that a given tip at state <code>s</code> will have known (i.e., non-hidden) state, conditional upon being included in the tree. If the tree only contains a random subset of species (sampled independently of each species' state), then <code>reveal_fractions[s]</code> is the probability of knowing the state of a species (regardless of whether it is included in the tree), if its state is <code>s</code>. This variable can be used to account for biases in which tips have known state, depending on their state. Only the relative ratios among reveal fractions matter, i.e. multiplying <code>reveal_fractions</code> with a constant factor has no effect.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_tip_priors">tip_priors</code></td>
<td>

<p>A 2D numeric matrix of size Ntips x Nstates, where Nstates is the possible number of states for the character modelled. Can also be <code>NULL</code>. Each row of this matrix must be a probability vector, i.e. it must only contain non-negative entries and must sum up to 1. The [i,s]-th entry should be the prior probability of tip i being in state s. If you know for certain that tip i is in some state s, you can set the corresponding entry to 1 and all other entries in that row to 0. A row can include <code>NA</code> to indicate that neither the state nor the probability distribution of a state are known for that tip. If for all tips you either know the exact state or have no information at all, you can also use <code>tip_states</code> instead. If <code>tip_priors==NULL</code>, then <code>tip_states</code> must not be <code>NULL</code> (see above).
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_rate_model">rate_model</code></td>
<td>

<p>Rate model to be used for fitting the transition rate matrix. Similar to the <code>rate_model</code> option in the function <code><a href="#topic+asr_mk_model">asr_mk_model</a></code>. See the details of <code><a href="#topic+asr_mk_model">asr_mk_model</a></code> on the assumptions of each <code>rate_model</code>.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_transition_matrix">transition_matrix</code></td>
<td>

<p>Either a numeric quadratic matrix of size Nstates x Nstates containing fixed transition rates, or <code>NULL</code>. The [r,c]-th entry in this matrix should store the transition (probability) rate from the state r to state c. Each row in this matrix must have sum zero.
If <code>NULL</code>, then the transition rates will be estimated using maximum likelihood, based on the <code>rate_model</code> specified.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_include_likelihoods">include_likelihoods</code></td>
<td>

<p>Boolean, specifying whether to include the marginal state likelihoods for all tips and nodes, as returned variables. Setting this to <code>TRUE</code> can substantially increase computation time. If <code>FALSE</code>, the Mk model is merely fitted, but ancestral states and hidden tip states are not reconstructed.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_root_prior">root_prior</code></td>
<td>

<p>Prior probability distribution of the root's states. Similar to the <code>root_prior</code> option in the function <code><a href="#topic+asr_mk_model">asr_mk_model</a></code>.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_ntrials">Ntrials</code></td>
<td>

<p>Number of trials (starting points) for fitting the transition matrix. Only relevant if <code>transition_matrix=NULL</code>. A higher number may reduce the risk of landing in a local non-global optimum of the likelihood function, but will increase computation time during fitting.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_optim_algorithm">optim_algorithm</code></td>
<td>

<p>Either &quot;optim&quot; or &quot;nlminb&quot;, specifying which optimization algorithm to use for maximum-likelihood estimation of the transition matrix. Only relevant if <code>transition_matrix==NULL</code>.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_optim_max_iterations">optim_max_iterations</code></td>
<td>

<p>Maximum number of iterations (per fitting trial) allowed for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_optim_rel_tol">optim_rel_tol</code></td>
<td>

<p>Relative tolerance (stop criterion) for optimizing the likelihood function.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_store_exponentials">store_exponentials</code></td>
<td>

<p>Logical, specifying whether to pre-calculate and store exponentials of the transition matrix during calculation of ancestral likelihoods. This may reduce computation time because each exponential is only calculated once, but will use up more memory since all exponentials are stored. Only relevant if <code>include_ancestral_likelihoods</code> is <code>TRUE</code>, otherwise exponentials are never stored.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
<tr><td><code id="hsp_mk_model_+3A_nthreads">Nthreads</code></td>
<td>

<p>Number of parallel threads to use for running multiple fitting trials simultaneously. This only makes sense if your computer has multiple cores/CPUs and <code>Ntrials&gt;1</code>, and is only relevant if <code>transition_matrix==NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. Note that Nstates can be chosen to be larger than the number of states observed in the tips of the present tree, to account for potential states not yet observed. If the trait's states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. The order of states (if applicable) should be reflected in their integer representation. For example, if your original states are &quot;small&quot;, &quot;medium&quot; and &quot;large&quot; and <code>rate_model=="SUEDE"</code>, it is advised to represent these states as integers 1,2,3. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>This function allows the specification of the precise tip states (if these are known) using the vector <code>tip_states</code>. Alternatively, if some tip states are only known in terms of a probability distribution, you can pass these probability distributions using the matrix <code>tip_priors</code>. Note that exactly one of the two arguments, <code>tip_states</code> or <code>tip_priors</code>, must be non-<code>NULL</code>. In either case, the presence of <code>NA</code> in <code>tip_states</code> or in a row of <code>tip_priors</code> is interpreted as an absence of information about the tip's state (i.e. the tip has &quot;hidden state&quot;).
</p>
<p>Tips must be represented in <code>tip_states</code> or <code>tip_priors</code> in the same order as in <code>tree$tip.label</code>. None of the input vectors or matrixes need include row or column names; if they do, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This method assumes that the tree is either complete (i.e. includes all species), or that the tree's tips represent a random subset of species that have been sampled independent of their state. The function does not require that tip state knowledge is independent of tip state, provided that the associated biases are known (provided via <code>reveal_fractions</code>). The rerooting method by Yang et al (2015) is used to reconstruct the marginal ancestral state likelihoods for each node by treating the node as a root and calculating its conditional scaled likelihoods. The state likelihoods of tips with hidden states are calculated from those of the most recent ancestor with previously calculated state likelihoods, using the exponentiated transition matrix along the connecting edges (essentially using the rerooting method). Attention: The state likelihoods for tips with known states or with provided priors are not modified, i.e. they are as provided in the input. In other words, for those tips the returned state likelihoods should not be considered as posteriors in a Bayesian sense.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, some return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>Nstates</code></td>
<td>

<p>Integer, specifying the number of modeled trait states.
</p>
</td></tr>
<tr><td><code>transition_matrix</code></td>
<td>

<p>A numeric quadratic matrix of size Nstates x Nstates, containing the transition rates of the Markov model. The [r,c]-th entry is the transition rate from state r to state c. Will be the same as the input <code>transition_matrix</code>, if the latter was not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Log-likelihood of the Markov model. If <code>transition_matrix</code> was <code>NULL</code> in the input, then this will be the log-likelihood maximized during fitting.
</p>
</td></tr>
<tr><td><code>likelihoods</code></td>
<td>

<p>A 2D numeric matrix, listing the probability of each tip and node being in each state. Only included if <code>include_likelihoods</code> was <code>TRUE</code>. This matrix will have (Ntips+Nnodes) rows and Nstates columns, where Nstates was either explicitly provided as an argument, or inferred from <code>tip_states</code> or <code>tip_priors</code> (whichever was non-<code>NULL</code>). The rows in this matrix will be in the order in which tips and nodes are indexed in the tree, i.e. rows 1,..,Ntips store the probabilities for tips, while rows (Ntips+1),..,(Ntips+Nnodes) store the probabilities for nodes. For example, <code>likelihoods[1,3]</code> will store the probability that tip 1 is in state 3. Each row in this matrix will sum up to 1. Note that for tips with known state or fully provided prior, the likelihoods will be unchanged, i.e. these are not the posteriors in a Bayesian sense.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes, with values in {1,..,Nstates}, specifying the maximum-likelihood estimate of the state of each tip &amp; node. Only included if <code>include_likelihoods</code> was <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Z. Yang, S. Kumar and M. Nei (1995). A new method for inference of ancestral nucleotide and amino acid sequences. Genetics. 141:1641-1650.
</p>
<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_squared_change_parsimony">hsp_squared_change_parsimony</a></code>, 
<code><a href="#topic+asr_mk_model">asr_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 1000
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a discrete trait
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ER", max_rate=0.01)
tip_states = simulate_mk_model(tree, Q)$tip_states
cat(sprintf("Simulated ER transition rate=%g\n",Q[1,2]))

# print states for first 20 tips
print(tip_states[1:20])

# set half of the tips to unknown state
# chose tips randomly, regardless of their state (no biases)
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via Mk model max-likelihood
results = hsp_mk_model(tree, tip_states, Nstates, rate_model="ER", Ntrials=2, Nthreads=2)
estimated_tip_states = max.col(results$likelihoods[1:Ntips,])

# print Mk model fitting summary
cat(sprintf("Mk model: log-likelihood=%g\n",results$loglikelihood))
cat(sprintf("Universal (ER) transition rate=%g\n",results$transition_matrix[1,2]))

# print estimated states for first 20 tips
print(estimated_tip_states[1:20])

## End(Not run)</code></pre>

<hr>
<h2 id='hsp_nearest_neighbor'>
Hidden state prediction based on nearest neighbor.
</h2><span id='topic+hsp_nearest_neighbor'></span>

<h3>Description</h3>

<p>Predict unknown (hidden) character states of tips on a tree using nearest neighbor matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_nearest_neighbor(tree, tip_states, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_nearest_neighbor_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="hsp_nearest_neighbor_+3A_tip_states">tip_states</code></td>
<td>

<p>A vector of length Ntips, specifying the state of each tip in the tree. Tip states can be any valid data type (e.g., characters, integers, continuous numbers, and so on). <code>NA</code> values denote unknown (hidden) tip states to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_nearest_neighbor_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each tip with unknown state, this function seeks the closest tip with known state, in terms of patristic distance. The state of the closest tip is then used as a prediction of the unknown state. In the case of multiple equal matches, the precise outcome is unpredictable (this is unlikely to occur if edge lengths are continuous numbers, but may happen frequently if e.g. edge lengths are all of unit length). This algorithm is arguably one of the crudest methods for predicting character states, so use at your own discretion.
</p>
<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown states.
If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child). Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. <code>tip_states</code> need not include names; if names are included, however, they are checked for consistency with the tree's tip labels (if <code>check_input==TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful. If <code>FALSE</code>, some return values may be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>Vector of length Ntips, listing the known and predicted state for each tip.
</p>
</td></tr>
<tr><td><code>nearest_neighbors</code></td>
<td>

<p>Integer vector of length Ntips, listing for each tip the index of the nearest tip with known state. Hence, <code>nearest_neighbors[n]</code> specifies the tip from which the unknown state of tip n was inferred. If tip n had known state, <code>nearest_neighbors[n]</code> will be n.
</p>
</td></tr>
<tr><td><code>nearest_distances</code></td>
<td>

<p>Numeric vector of length Ntips, listing for each tip the patristic distance to the nearest tip with known state. For tips with known state, distances will be zero.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate random tree
Ntips = 20
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a binary trait
Q = get_random_mk_transition_matrix(2, rate_model="ER")
tip_states = simulate_mk_model(tree, Q)$tip_states

# print tip states
print(tip_states)

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via nearest neighbor
predicted_states = hsp_nearest_neighbor(tree, tip_states)$states

# print predicted tip states
print(predicted_states)

## End(Not run)</code></pre>

<hr>
<h2 id='hsp_squared_change_parsimony'>
Hidden state prediction via squared-change parsimony.
</h2><span id='topic+hsp_squared_change_parsimony'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states of a continuous (numeric) trait for nodes and predict unknown (hidden) states for tips on a tree using squared-change (or weighted squared-change) parsimony (Maddison 1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_squared_change_parsimony(tree, tip_states, weighted=TRUE, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_squared_change_parsimony_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_squared_change_parsimony_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the state of each tip in the tree. <code>tip_states</code> can include <code>NA</code> to indicate an unknown tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_squared_change_parsimony_+3A_weighted">weighted</code></td>
<td>

<p>Logical, specifying whether to weight transition costs by the inverted edge lengths during ancestral state reconstruction. This corresponds to the &quot;weighted squared-change parsimony&quot; reconstruction by Maddison (1991) for a Brownian motion model of trait evolution.
</p>
</td></tr>
<tr><td><code id="hsp_squared_change_parsimony_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown (hidden) states to be estimated. Prior to ancestral state reconstruction, the tree is temporarily prunned, keeping only tips with known state. The function then uses Maddison's squared-change parsimony algorithm to reconstruct the globally parsimonious state at each node (Maddison 1991). The states of tips with hidden state are set to those of the most recent ancestor with reconstructed state, as described by Zaneveld and Thurber (2014). This function has asymptotic time complexity O(Nedges).
If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. This is the same as setting <code>weighted=FALSE</code>. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). 
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree as well as predicting the states of tips with an a priory unknown state. If the state of all tips is known and only ancestral state reconstruction is needed, consider using the function <code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code> for improved efficiency.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>states</code></td>
<td>

<p>A numeric vector of size Ntips+Nnodes, listing the reconstructed state of each tip and node. The entries in this vector will be in the order in which tips and nodes are indexed in <code>tree$edge</code>.
</p>
</td></tr>
<tr><td><code>total_sum_of_squared_changes</code></td>
<td>

<p>The total sum of squared changes, minimized by the (optionally weighted) squared-change parsimony algorithm. This is equation 7 in (Maddison, 1991).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>W. P. Maddison (1991). Squared-change parsimony reconstructions of ancestral states for continuous-valued characters on a phylogenetic tree. Systematic Zoology. 40:304-314.
</p>
<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_squared_change_parsimony">asr_squared_change_parsimony</a></code>
<code><a href="#topic+hsp_max_parsimony">hsp_max_parsimony</a></code>, 
<code><a href="#topic+hsp_mk_model">hsp_mk_model</a></code>, 
<code><a href="#topic+map_to_state_space">map_to_state_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree, 
                               stationary_mean=0,
                               stationary_std=1,
                               decay_rate=0.001)$tip_states

# print tip states
print(tip_states)

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via weighted SCP
estimated_states = hsp_squared_change_parsimony(tree, tip_states, weighted=TRUE)$states

# print estimated tip states
print(estimated_states[1:Ntips])
</code></pre>

<hr>
<h2 id='hsp_subtree_averaging'>
Hidden state prediction via subtree averaging.
</h2><span id='topic+hsp_subtree_averaging'></span>

<h3>Description</h3>

<p>Reconstruct ancestral states of a continuous (numeric) trait for nodes and predict unknown (hidden) states for tips on a tree using subtree averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsp_subtree_averaging(tree, tip_states, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsp_subtree_averaging_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="hsp_subtree_averaging_+3A_tip_states">tip_states</code></td>
<td>

<p>A numeric vector of size Ntips, specifying the state of each tip in the tree. <code>tip_states</code> can include <code>NA</code> to indicate an unknown tip state that is to be predicted.
</p>
</td></tr>
<tr><td><code id="hsp_subtree_averaging_+3A_check_input">check_input</code></td>
<td>

<p>Logical, specifying whether to perform some basic checks on the validity of the input data. If you are certain that your input data are valid, you can set this to <code>FALSE</code> to reduce computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>NA</code> entries in <code>tip_states</code> are interpreted as unknown (hidden) states to be estimated. For each node the reconstructed state is set to the arithmetic average state of all tips with known state and descending from that node. For each tip with hidden state and each node whose descending tips all have hidden states, the state is set to the state of the closest ancestral node with known or reconstructed state, while traversing from root to tips (Zaneveld and Thurber 2014). Note that reconstructed node states are only local estimates, i.e. for each node the estimate is only based on the tip states in the subtree descending from that node.
</p>
<p>Tips must be represented in <code>tip_states</code> in the same order as in <code>tree$tip.label</code>. The vector <code>tip_states</code> need not include item names; if it does, however, they are checked for consistency (if <code>check_input==TRUE</code>). This function has asymptotic time complexity O(Nedges).
</p>
<p>This function is meant for reconstructing ancestral states in all nodes of a tree as well as predicting the states of tips with an a priory unknown state. If the state of all tips is known and only ancestral state reconstruction is needed, consider using the function <code><a href="#topic+asr_subtree_averaging">asr_subtree_averaging</a></code> for improved efficiency.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether HSP was successful.
</p>
</td></tr>
<tr><td><code>states</code></td>
<td>

<p>A numeric vector of size Ntips+Nnodes, listing the reconstructed state of each tip and node. The entries in this vector will be in the order in which tips and nodes are indexed in <code>tree$edge</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>J. R. Zaneveld and R. L. V. Thurber (2014). Hidden state prediction: A modification of classic ancestral state reconstruction algorithms helps unravel complex symbioses. Frontiers in Microbiology. 5:431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asr_subtree_averaging">asr_subtree_averaging</a></code>,
<code><a href="#topic+hsp_squared_change_parsimony">hsp_squared_change_parsimony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# simulate a continuous trait
tip_states = simulate_ou_model(tree,
                               stationary_mean=0,
                               stationary_std=1,
                               decay_rate=0.001)$tip_states

# print tip states
print(as.vector(tip_states))

# set half of the tips to unknown state
tip_states[sample.int(Ntips,size=as.integer(Ntips/2),replace=FALSE)] = NA

# reconstruct all tip states via subtree averaging
estimated_states = hsp_subtree_averaging(tree, tip_states)$states

# print estimated tip states
print(estimated_states[1:Ntips])
</code></pre>

<hr>
<h2 id='is_bifurcating'>
Determine if a tree is bifurcating.
</h2><span id='topic+is_bifurcating'></span>

<h3>Description</h3>

<p>This function determines if a tree is strictly bifurcating, i.e. each node has exactly 2 children. If a tree has monofurcations or multifurcations, this function returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bifurcating(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_bifurcating_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions accepts rooted and unrooted trees, that may include monofurcations, bifurcations and multifurcations.
</p>


<h3>Value</h3>

<p>A logical, indicating whether the input tree is strictly bifurcating.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 10
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# check if the tree is bifurcating (as expected)
is_bifurcating(tree)
</code></pre>

<hr>
<h2 id='is_monophyletic'>
Determine if a set of tips is monophyletic.
</h2><span id='topic+is_monophyletic'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a set of focal tips, this function determines whether the tips form a monophyletic group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_monophyletic(tree, focal_tips, check_input=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_monophyletic_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="is_monophyletic_+3A_focal_tips">focal_tips</code></td>
<td>

<p>Either an integer vector or a character vector, listing the tips to be checked for monophyly. If an integer vector, it should list tip indices (i.e. from 1 to Ntips). If a character vector, it should list tip names; in that case <code>tree$tip.label</code> must exist.
</p>
</td></tr>
<tr><td><code id="is_monophyletic_+3A_check_input">check_input</code></td>
<td>

<p>Logical, whether to perform basic validations of the input data. If you know for certain that your input is valid, you can set this to <code>FALSE</code> to reduce computation time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first finds the most recent common ancestor (MRCA) of the focal tips, and then checks if all tips descending from that MRCA fall within the focal tip set.
</p>


<h3>Value</h3>

<p>A logical, indicating whether the focal tips form a monophyletic set.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mrca_of_set">get_mrca_of_set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 100
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# pick a random subset of focal tips
focal_tips = which(sample.int(2,size=Ntips,replace=TRUE)==1)

# check if focal tips form a monophyletic group
is_monophyletic(tree, focal_tips)
</code></pre>

<hr>
<h2 id='join_rooted_trees'>
Join two rooted trees.
</h2><span id='topic+join_rooted_trees'></span>

<h3>Description</h3>

<p>Given two rooted phylogenetic trees, place one tree (tree2) onto an edge of the other tree (tree1), so that tree2 becomes a monophyletic group of the final joined tree. As a special case, this function can join two trees at their roots, i.e. so that both are disjoint monophyletic clades of the final tree, splitting at the new root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_rooted_trees(  tree1, 
                    tree2,
                    target_edge1,
                    target_edge_length1,
                    root_edge_length2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_rooted_trees_+3A_tree1">tree1</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="join_rooted_trees_+3A_tree2">tree2</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. This tree will become a monophyletic subclade of the final joined tree.
</p>
</td></tr>
<tr><td><code id="join_rooted_trees_+3A_target_edge1">target_edge1</code></td>
<td>

<p>Integer, edge index in <code>tree1</code> onto which <code>tree2</code> is to be joined. If &lt;=0, then this refers to the hypothetical edge leading into the root of <code>tree1</code>, in which case both trees will become disjoint monophyletic subclades of the final joined tree.
</p>
</td></tr>
<tr><td><code id="join_rooted_trees_+3A_target_edge_length1">target_edge_length1</code></td>
<td>

<p>Numeric, length of the edge segment in <code>tree1</code> from the joining-point to the next child node, i.e. how far from the child of <code>target_edge1</code> should the joining occur. If <code>target_edge1&lt;=0</code>, then <code>target_edge_length1</code> is the distance of the root of <code>tree1</code> from the final joined tree's root.
</p>
</td></tr>
<tr><td><code id="join_rooted_trees_+3A_root_edge_length2">root_edge_length2</code></td>
<td>

<p>Numeric, length of the edge leading into the root of <code>tree2</code>, i.e. the distance from the joining point to the root of <code>tree2</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input trees may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). If any of the input trees does not have edge lengths (i.e., <code>edge.length</code> is <code>NULL</code>), then its edge lengths are assumed to all be 1.
</p>
<p>The tips of the two input trees will become the tips of the final joined tree. The nodes of the two input trees will become nodes of the final joined tree, however one additional node will be added at the joining point. Tip labels and node labels (if available) of the joined tree are inheritted from the two input trees.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, representing the joined tree.
</p>
</td></tr>
<tr><td><code>clade1_to_clade</code></td>
<td>

<p>Integer vector of length Ntips1+Nnodes1, mapping tip/node indices of the input <code>tree1</code> to tip/node indices in the final joined tree.
</p>
</td></tr>
<tr><td><code>clade2_to_clade</code></td>
<td>

<p>Integer vector of length Ntips2+Nnodes2, mapping tip/node indices of the input <code>tree2</code> to tip/node indices in the final joined tree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_tree_at_height">split_tree_at_height</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate two random trees, include tip &amp; node names
tree1 = generate_random_tree(list(birth_rate_intercept=1),
                             max_tips=10,
                             tip_basename="tip1.",
                             node_basename="node1.")$tree
tree2 = generate_random_tree(list(birth_rate_intercept=1),
                             max_tips=5,
                             tip_basename="tip2.",
                             node_basename="node2.")$tree

# join trees at their roots
# each subtree's root should have distance 1 from the new root
joined_tree = join_rooted_trees(tree1, 
                                tree2,
                                target_edge1=0,
                                target_edge_length1=1,
                                root_edge_length2=1)$tree
</code></pre>

<hr>
<h2 id='loglikelihood_hbd'>
Galculate the log-likelihood of a homogenous birth-death model.
</h2><span id='topic+loglikelihood_hbd'></span>

<h3>Description</h3>

<p>Given a rooted ultrametric timetree, and a homogenous birth-death (HBD) model, i.e., with speciation rate <code class="reqn">\lambda</code>, extinction rate <code class="reqn">\mu</code> and sampling fraction <code class="reqn">\rho</code>, calculate the likelihood of the tree under the model. The speciation and extinction rates may be time-dependent. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates (in the literature this is sometimes referred to simply as &ldquo;birth-death model&rdquo;). Alternatively to <code class="reqn">\lambda</code> and <code class="reqn">\mu</code>, the likelihood may also be calculated based on the pulled diversification rate (PDR; Louca et al. 2018) and the product <code class="reqn">\rho(0)\cdot\lambda(0)</code>, or based on the pulled speciation rate (PSR). In either case, the time-profiles of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, the PDR or the PSR are specified as piecewise polynomially functions (splines), defined on a discrete grid of ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_hbd(tree, 
                  oldest_age        = NULL,
                  age0              = 0,
                  rho0              = NULL,
                  rholambda0        = NULL,
                  age_grid          = NULL,
                  lambda            = NULL,
                  mu                = NULL,
                  PDR               = NULL,
                  PSR               = NULL,
                  splines_degree    = 1,
                  condition         = "auto",
                  max_model_runtime = -1,
                  relative_dt       = 1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_hbd_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to consider when calculating the likelihood. If this is equal to or greater than the root age, then <code>oldest_age</code> is taken as the stem age, and the classical formula by Morlon et al. (2011) is used.  If <code>oldest_age</code> is less than the root age, the tree is split into multiple subtrees at that age by treating every edge crossing that age as the stem of a subtree, and each subtree is considered an independent realization of the HBD model stemming at that age. This can be useful for avoiding points in the tree close to the root, where estimation uncertainty is generally higher. If <code>oldest_age==NULL</code>, it is automatically set to the root age.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the youngest age (time before present) to consider for fitting, and with respect to which <code>rho</code> and <code>rholambda0</code> are defined. If <code>age0&gt;0</code>, then <code>rho</code> refers to the sampling fraction at age <code>age0</code>, and <code>rholambda0</code> to the product between <code>rho</code> and the speciation rate at age <code>age0</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_rho0">rho0</code></td>
<td>

<p>Numeric between 0 (exclusive) and 1 (inclusive), specifying the sampling fraction of the tree at <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are included in the tree. Note that if <code class="reqn">rho0&lt;1</code>, lineages extant at <code>age0</code> are assumed to have been sampled randomly at equal probabilities. Can also be <code>NULL</code>, in which case <code>rholambda0</code> and <code>PDR</code> (see below) must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_rholambda0">rholambda0</code></td>
<td>

<p>Strictly positive numeric, specifying the product of the sampling fraction and the speciation rateat <code>age0</code>, units 1/time. Can be <code>NULL</code>, in which case <code>rarefaction</code>, <code>lambda</code> and <code>mu</code> must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing discrete ages (time before present) on which either <code class="reqn">\lambda</code> and <code class="reqn">\mu</code>, or the PDR, are specified. Listed ages must be strictly increasing, and must cover at least the full considered age interval (from <code>age0</code> to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the speciation rate, extinction rate and PDR are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing speciation rates (in units 1/time) at the ages listed in <code>age_grid</code>. Speciation rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then either <code>PDR</code> and <code>rholambda0</code>, or <code>PSR</code> alone, must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing extinction rates (in units 1/time)at the ages listed in <code>age_grid</code>. Extinction rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then <code>PDR</code> and <code>rholambda0</code>, or <code>PSR</code> alone, must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_pdr">PDR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing pulled diversification rates (in units 1/time) at the ages listed in <code>age_grid</code>. PDRs can be negative or positive, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then either <code>lambda</code> and <code>mu</code>, or <code>PSR</code> alone, must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_psr">PSR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing pulled speciation rates (in units 1/time) at the ages listed in <code>age_grid</code>. PSRs should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then either <code>lambda</code> and <code>mu</code>, or <code>PDR</code> and <code>rholambda0</code>, must be provided.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided <code>lambda</code>, <code>mu</code>, <code>PDR</code> and <code>PSR</code> (whichever applicable) between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided <code>lambda</code>, <code>mu</code>, <code>PDR</code> and <code>PSR</code> are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> they are interpreted as quadratic splines; if <code>splines_degree==3</code> they are interpreted as cubic splines. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_condition">condition</code></td>
<td>

<p>Character, either &quot;crown&quot;, &quot;stem&quot;, &quot;auto&quot; or &quot;none&quot; (the last one is only available if <code>lambda</code> and <code>mu</code> are given), specifying on what to condition the likelihood. If &quot;crown&quot;, the likelihood is conditioned on the survival of the two daughter lineages branching off at the root. If &quot;stem&quot;, the likelihood is conditioned on the survival of the stem lineage. Note that &quot;crown&quot; really only makes sense when <code>oldest_age</code> is equal to the root age, while &quot;stem&quot; is recommended if <code>oldest_age</code> differs from the root age. &quot;none&quot; is usually not recommended and is only available when <code>lambda</code> and <code>mu</code> are provided. If &quot;auto&quot;, the condition is chosen according to the recommendations mentioned earlier.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Numeric, maximum allowed runtime (in seconds) for evaluating the likelihood. If the likelihood calculation takes longer than this (appoximate) threshold, it halts and returns with an error. If negative (default), this option is ignored.
</p>
</td></tr>
<tr><td><code id="loglikelihood_hbd_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>age0&gt;0</code>, the input tree is essentially trimmed at <code>age0</code> (omitting anything younger than <code>age0</code>), and the is likelihood calculated for the trimmed tree while shifting time appropriately. In that case, <code>rho0</code> is interpreted as the sampling fraction at <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are repreented in the tree. Similarly, <code>rholambda0</code> is the product of the sampling fraction and <code class="reqn">\lambda</code> at <code>age0</code>.
</p>
<p>This function supports three alternative parameterizations of HBD models, either using the speciation and extinction rates and sampling fraction (<code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho(\tau_o)</code> (for some arbitrary age <code class="reqn">\tau_o</code>), or using the pulled diversification rate (PDR) and the product <code class="reqn">\rho(\tau_o)\cdot\lambda(\tau_o</code> (sampling fraction times speciation rate at <code class="reqn">\tau_o</code>), or using the pulled speciation rate (PSR). The latter two options should be interpreted as a parameterization of congruence classes, i.e. sets of models that have the same likelihood, rather than specific models, since multiple combinations of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\rho(\tau_o)</code> can have identical PDRs, <code class="reqn">\rho(\tau_o)\cdot\lambda(\tau_o)</code> and PSRs (Louca and Pennell, in review).
</p>
<p>For large trees the asymptotic time complexity of this function is O(Nips). The tree may include monofurcations as well as multifurcations, and the likelihood formula accounts for those (i.e., as if monofurcations were omitted and multifurcations were expanded into bifurcations).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the calculation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) containing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>

<p>Numeric. If <code>success==TRUE</code>, this will be the natural logarithm of the likelihood of the tree under the given model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>
<p>S. Louca and M. W. Pennell (in review as of 2019)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>
</p>
<p><code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>
</p>
<p><code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree with constant rates
Ntips  = 100
params = list(birth_rate_factor=1, death_rate_factor=0.2, rarefaction=0.5)
tree   = generate_random_tree(params, max_tips=Ntips, coalescent=TRUE)$tree

# get the loglikelihood for an HBD model with the same parameters that generated the tree
# in particular, assuming time-independent speciation &amp; extinction rates
LL = loglikelihood_hbd( tree, 
                        rho0      = params$rarefaction, 
                        age_grid  = NULL, # assume time-independent rates
                        lambda    = params$birth_rate_factor,
                        mu        = params$death_rate_factor)
if(LL$success){
  cat(sprintf("Loglikelihood for constant-rates model = %g\n",LL$loglikelihood))
}

# get the likelihood for a model with exponentially decreasing (in forward time) lambda &amp; mu
beta      = 0.01 # exponential decay rate of lambda over time
age_grid  = seq(from=0, to=100, by=0.1) # choose a sufficiently fine age grid
lambda    = 1*exp(beta*age_grid) # define lambda on the age grid
mu        = 0.2*lambda # assume similarly shaped but smaller mu
LL = loglikelihood_hbd( tree, 
                        rho0      = params$rarefaction, 
                        age_grid  = age_grid,
                        lambda    = lambda,
                        mu        = mu)
if(LL$success){
  cat(sprintf("Loglikelihood for exponential-rates model = %g\n",LL$loglikelihood))
}
</code></pre>

<hr>
<h2 id='map_to_state_space'>
Map states of a discrete trait to integers.
</h2><span id='topic+map_to_state_space'></span>

<h3>Description</h3>

<p>Given a list of states (e.g., for each tip in a tree), map the unique states to integers 1,..,Nstates, where Nstates is the number of possible states. This function can be used to translate states that are originally represented by characters or factors, into integer states as required by ancestral state reconstruction and hidden state prediction functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_to_state_space(raw_states, fill_gaps=FALSE, 
                   sort_order="natural")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_to_state_space_+3A_raw_states">raw_states</code></td>
<td>

<p>A vector of values (states), each of which can be converted to a character. This vector can include the same value multiple times, for example if values represent the trait's states for tips in a tree. The vector may also include <code>NA</code>, for example if they represent unknown states for some tree tips. NAs are omitted from the state space.
</p>
</td></tr>
<tr><td><code id="map_to_state_space_+3A_fill_gaps">fill_gaps</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then states are converted to integers using <code>as.integer(as.character())</code>, and then all missing intermediate integer values are included as additional possible states. For example, if <code>raw_states</code> contained the values 2,4,6, then 3 and 5 are assumed to also be possible states.
</p>
</td></tr>
<tr><td><code id="map_to_state_space_+3A_sort_order">sort_order</code></td>
<td>

<p>Character, specifying the order in which raw_states should be mapped to ascending integers. Either &quot;natural&quot; or &quot;alphabetical&quot;. If &quot;natural&quot;, numerical parts of characters are sorted numerically, e.g. as in &quot;3&quot;&lt;&quot;a2&quot;&lt;&quot;a12&quot;&lt;&quot;b1&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several ancestral state reconstruction and hidden state prediction algorithms in the <code>castor</code> package (e.g., <code>asr_max_parsimony</code>) require that the focal trait's states are represented by integer indices within 1,..,Nstates. These indices are then associated, afor example, with column and row indices in the transition cost matrix (in the case of maximum parsimony reconstruction) or with column indices in the returned matrix containing marginal ancestral state probabilities (e.g., in <code><a href="#topic+asr_mk_model">asr_mk_model</a></code>). The function <code>map_to_state_space</code> can be used to conveniently convert a set of discrete states into integers, for use with the aforementioned algorithms.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Nstates</code></td>
<td>

<p>Integer. Number of possible states for the trait, based on the unique values encountered in <code>raw_states</code> (after conversion to characters). This may be larger than the number of unique values in <code>raw_states</code>, if <code>fill_gaps</code> was set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>state_names</code></td>
<td>

<p>Character vector of size Nstates, storing the original name (character version) of each unique state. For example, if <code>raw_states</code> was <code>c("b1","3","a12","a2","b1","a2", NA)</code> and <code>sort_order=="natural"</code>, then <code>Nstates</code> will be 4 and <code>state_names</code> will be <code>c("3","a2","a12","b1")</code>.
</p>
</td></tr>
<tr><td><code>state_values</code></td>
<td>

<p>A numeric vector of size <code>Nstates</code>, providing the numerical value for each unique state. For example, the states &quot;3&quot;,&quot;a2&quot;,&quot;4.5&quot; will be mapped to the numeric values 3, NA, 4.5. Note that this may not always be meaningful, depending on the biological interpretation of the states.
</p>
</td></tr>
<tr><td><code>mapped_states</code></td>
<td>

<p>Integer vector of size equal to <code>length(raw_states)</code>, listing the integer representation of each value in <code>raw_states</code>. May also include <code>NA</code>, at those locations where <code>raw_states</code> was <code>NA</code>.
</p>
</td></tr>
<tr><td><code>name2index</code></td>
<td>

<p>An integer vector of size Nstates, with <code>names(name2index)</code> set to <code>state_names</code>. This vector can be used to map any new list of states (in character format) to their integer representation. In particular, <code>name2index[as.character(raw_states)]</code> is equal to <code>mapped_states</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a sequence of random states
unique_states = c("b","c","a")
raw_states = unique_states[sample.int(3,size=10,replace=TRUE)]

# map to integer state space
mapping = map_to_state_space(raw_states)

cat(sprintf("Checking that original unique states is the same as the one inferred:\n"))
print(unique_states)
print(mapping$state_names)

cat(sprintf("Checking reversibility of mapping:\n"))
print(raw_states)
print(mapping$state_names[mapping$mapped_states])
</code></pre>

<hr>
<h2 id='mean_abs_change_scalar_ou'>
Compute the expected absolute change of an Ornstein-Uhlenbeck process.
</h2><span id='topic+mean_abs_change_scalar_ou'></span>

<h3>Description</h3>

<p>Given a scalar Ornstein-Uhlenbeck process at stationarity, compute the expected absolute net change over a specific time interval. In other words, if <code class="reqn">X(t)</code> is the process at time <code class="reqn">t</code>, compute the conditional expectation of <code class="reqn">|X(t)-X(0)|</code> given that <code class="reqn">X(0)</code> is randomly drawn from the stationary distribution. This quantity may be used as a measure for the speed at which a continuous trait evolves over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_abs_change_scalar_ou(stationary_mean,
                          stationary_std,
                          decay_rate,
                          delta,
                          rel_error = 0.001,
                          Nsamples = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_stationary_mean">stationary_mean</code></td>
<td>

<p>Numeric, the stationary mean of the OU process, i.e., its equilibrium (<code class="reqn">\mu</code>).
</p>
</td></tr>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_stationary_std">stationary_std</code></td>
<td>

<p>Positive numeric, the stationary standard deviation of the OU process. Note that this is <code class="reqn">\sigma/\sqrt{2\lambda}</code>, where <code class="reqn">\sigma</code> is the volatility.
</p>
</td></tr>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_decay_rate">decay_rate</code></td>
<td>

<p>Positive numeric, the decay rate or &quot;rubber band&quot; parameter of the OU process (<code class="reqn">\lambda</code>).
</p>
</td></tr>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_delta">delta</code></td>
<td>

<p>Positive numeric, the time step for which to compute the expected absolute change.
</p>
</td></tr>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_rel_error">rel_error</code></td>
<td>

<p>Positive numeric, the relative tolerable standard estimation error (relative to the true mean absolute displacement).
</p>
</td></tr>
<tr><td><code id="mean_abs_change_scalar_ou_+3A_nsamples">Nsamples</code></td>
<td>

<p>Integer, number of Monte Carlo samples to use for estimation. If <code>NULL</code>, this is determined automatically based on the desired accuracy (<code>rel_error</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scalar OU process is a continuous-time stochastic process that satisfies the following stochastic differential equation:
</p>
<p style="text-align: center;"><code class="reqn">
dX = \lambda\cdot(\mu-X)\ dt + \sigma\ dW,
</code>
</p>

<p>where <code class="reqn">W</code> is a Wiener process (aka. &quot;standard Brownian Motion&quot;), <code class="reqn">\mu</code> is the equilibrium, <code class="reqn">\sigma</code> is the volatility and <code class="reqn">\lambda</code> is the decay rate. The OU process is commonly used to model the evolution of a continuous trait over time. The decay rate <code class="reqn">\lambda</code> alone is not a proper measure for how fast a trait changes over time (despite being erroneously used for this purpose in some sudies), as it only measures how fast the trait tends to revert to <code class="reqn">\mu</code> when it is far away from <code class="reqn">\mu</code>. Similarly, the volatility <code class="reqn">\sigma</code> alone is not a proper measure of evolutionary rate, because it only describes how fast a trait changes when it is very close to the equilibrium <code class="reqn">\mu</code>, where the tendency to revert is negligible and the process behaves approximately as a Brownian Motion.
</p>
<p>This function uses Monte Carlo integration to estimate the expected absolute change, by repeatedly sampling start values <code class="reqn">X(0)</code> from the OU's stationary distribution, computing the conditional expected absolute change given the sampled start value, and then averaging those conditional expectations.
</p>


<h3>Value</h3>

<p>A non-negative numeric, specifying the expected absolute change of the OU process.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute the expected absolute change of an OU process after 10 time units
expected_abs_change = mean_abs_change_scalar_ou(stationary_mean=5, 
                                                stationary_std=1,
                                                decay_rate=0.1,
                                                delta=10)
</code></pre>

<hr>
<h2 id='merge_nodes_to_multifurcations'>
Merge specific nodes into multifurcations.
</h2><span id='topic+merge_nodes_to_multifurcations'></span>

<h3>Description</h3>

<p>Given a rooted tree, merge one or more nodes &ldquo;upwards&rdquo; into their parent nodes, thus effectively generating multifurcations. Multiple generations of nodes (i.e., successive branching points) can be merged into a single &quot;absorbing ancestor&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_nodes_to_multifurcations( tree, 
                                nodes_to_merge,
                                merge_with_parents  = FALSE,
                                keep_ancestral_ages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_nodes_to_multifurcations_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="merge_nodes_to_multifurcations_+3A_nodes_to_merge">nodes_to_merge</code></td>
<td>

<p>Integer vector or character vector, listing nodes in the tree that should be merged with their parents (if <code>merge_with_parents=TRUE</code>) or with their children (if <code>merge_with_parents=FALSE</code>). If an integer vector, it must contain values in 1,..,Nnodes. If a character vector, it must list node labels, and the tree itself must also include node labels.
</p>
</td></tr>
<tr><td><code id="merge_nodes_to_multifurcations_+3A_merge_with_parents">merge_with_parents</code></td>
<td>

<p>Logical, specifying whether the nodes listed in <code>nodes_to_merge</code> should be merged with their parents. If <code>FALSE</code>, the specified nodes will be merged with their children (whenever these are not tips).
</p>
</td></tr>
<tr><td><code id="merge_nodes_to_multifurcations_+3A_keep_ancestral_ages">keep_ancestral_ages</code></td>
<td>

<p>Logical, specifying whether the generated multifurcations should have the same age as the absorbing ancestor. If <code>FALSE</code>, then the age of a multifurcation will be the average of the absorbing ancestor's age and the ages of its merged child nodes (but constrained from below by the ages of non-merged descendants to avoid negative edge lengths). If <code>TRUE</code>, then the ages of multifurcations will be biased towards the root, since their age will be that of the absorbing ancestor.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All tips in the input tree are kept and retain their original indices, however the returned tree will include fewer nodes and edges. Edge and node indices may change. When a node is merged into its parent, the incoming edge is lost, and the parent's age remains unchanged. 
</p>
<p>Nodes are merged in order from root to tips. Hence, if a node B is merged into (&quot;absorbed by&quot;) its parent node A, and child node C is merged into node B, then effectively C ends up merged into node A (node A is the &quot;absorbing ancestor&quot;).
</p>
<p>If <code>tree$edge.length</code> is missing, then all edges in the input tree are assumed to have length 1.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;. The number of nodes in this tree, Nnodes_new, will generally be lower than of the input tree.
</p>
</td></tr>
<tr><td><code>new2old_node</code></td>
<td>

<p>Integer vector of length Nnodes_new, mapping node indices in the new tree to node indices in the old tree. Note that nodes merged with their parents are not represented in this list.
</p>
</td></tr>
<tr><td><code>old2new_node</code></td>
<td>

<p>Integer vector of length Nnodes, mapping node indices in the old tree to node indices in the new tree. Nodes merged with their parents (and thus missing from the new tree) will have value 0.
</p>
</td></tr>
<tr><td><code>Nnodes_removed</code></td>
<td>

<p>Integer. Number of nodes removed from the tree, due to being merged into their parents.
</p>
</td></tr>
<tr><td><code>Nedges_removed</code></td>
<td>

<p>Integer. Number of edges removed from the tree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+multifurcations_to_bifurcations">multifurcations_to_bifurcations</a></code>, 
<code><a href="#topic+collapse_monofurcations">collapse_monofurcations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1), max_tips=Ntips)$tree

# merge a few nodes with their parents,
# thus obtaining a multifurcating tree
nodes_to_merge = c(1,3,4)
new_tree = merge_nodes_to_multifurcations(tree, nodes_to_merge)$tree

# print summary of old and new tree
cat(sprintf("Old tree has %d nodes\n",tree$Nnode))
cat(sprintf("New tree has %d nodes\n",new_tree$Nnode))
</code></pre>

<hr>
<h2 id='merge_short_edges'>
Eliminate short edges in a tree by merging nodes into multifurcations.
</h2><span id='topic+merge_short_edges'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and an edge length threshold, merge nodes/tips into multifurcations when their incoming edges are shorter than the threshold. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_short_edges(tree, 
                  edge_length_epsilon	= 0,
                  force_keep_tips     = TRUE,
                  new_tip_prefix      = "ex.node.tip.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_short_edges_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="merge_short_edges_+3A_edge_length_epsilon">edge_length_epsilon</code></td>
<td>

<p>Non-negative numeric, specifying the maximum edge length for an edge to be considered &ldquo;short&rdquo; and thus to be eliminated. Typically 0 or some small positive number.
</p>
</td></tr>
<tr><td><code id="merge_short_edges_+3A_force_keep_tips">force_keep_tips</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then tips are always kept, even if their incoming edges are shorter than <code>edge_length_epsilon</code>. If <code>FALSE</code>, then tips with short incoming edges are removed from the tree; in that case some nodes may become tips.
</p>
</td></tr>
<tr><td><code id="merge_short_edges_+3A_new_tip_prefix">new_tip_prefix</code></td>
<td>

<p>Character or <code>NULL</code>, specifying the prefix to use for new tip labels stemming from nodes. Only relevant if <code>force_keep_tips==FALSE</code>. If <code>NULL</code>, then labels of tips stemming from nodes will be the node labels from the original tree (in this case the original tree should include node labels).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). Whenever a short edge is eliminated, the edges originating from its child are elongated according to the short edge's length. The corresponding grand-children become children of the short edge's parent. Short edges are eliminated in a depth-first-search manner, i.e. traversing from the root to the tips. 
</p>
<p>Note that existing monofurcations are retained. If <code>force_keep_tips==FALSE</code>, then new monofurcations may also be introduced due to tips being removed.
</p>
<p>This function is conceptually similar to the function <code>ape::di2multi</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, containing the (potentially multifurcating) tree.
</p>
</td></tr>
<tr><td><code>new2old_clade</code></td>
<td>

<p>Integer vector of length equal to the number of tips+nodes in the new tree, with values in 1,..,Ntips+Nnodes, mapping tip/node indices of the new tree to tip/node indices in the original tree.
</p>
</td></tr>
<tr><td><code>new2old_edge</code></td>
<td>

<p>Integer vector of length equal to the number of edges in the new tree, with values in 1,..,Nedges, mapping edge indices of the new tree to edge indices in the original tree.
</p>
</td></tr>
<tr><td><code>Nedges_removed</code></td>
<td>

<p>Integer. Number of edges that have been eliminated.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+multifurcations_to_bifurcations">multifurcations_to_bifurcations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_factor=1),max_tips=Ntips)$tree

# set some edge lengths to zero
tree$edge.length[sample.int(n=Ntips, size=10, replace=FALSE)] = 0

# print number of edges
cat(sprintf("Original tree has %d edges\n",nrow(tree$edge)))

# eliminate any edges of length zero
merged = merge_short_edges(tree, edge_length_epsilon=0)$tree

# print number of edges
cat(sprintf("New tree has %d edges\n",nrow(merged$edge)))
</code></pre>

<hr>
<h2 id='model_adequacy_hbd'>
Check if a birth-death model adequately explains a timetree.
</h2><span id='topic+model_adequacy_hbd'></span>

<h3>Description</h3>

<p>Given a rooted ultrametric timetree and a homogenous birth-death model, check if the model adequately explains various aspects of the tree, such as the branch length and node age distributions and other test statistics. The function uses bootstrapping to simulate multiple hypothetical trees according to the model and then compares the distribution of those trees to the original tree. This function may be used to quantify the &quot;goodness of fit&quot; of a birth-death model to a timetree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_adequacy_hbd( tree,
                    models,
                    splines_degree  = 1,
                    extrapolate     = FALSE,
                    Nbootstraps     = 1000,
                    Nthreads        = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_adequacy_hbd_+3A_tree">tree</code></td>
<td>

<p>A rooted ultrametric timetree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbd_+3A_models">models</code></td>
<td>

<p>Either a single HBD model or a list of HBD models, specifying the pool of models from which to randomly draw bootstraps. Every model should itself be a named list with some or all of the following elements: 
</p>
<ul>
<li> <p><code>ages</code>: Numeric vector, specifying discrete ages (times before present) in ascending order, on which the pulled speciation rate will be specified. Age increases from tips to root; the youngest tip in the input tree has age 0. The age grid must cover the present-day (age 0) and the root
</p>
</li>
<li> <p><code>PSR</code>: Numeric vector of size NG, listing the pulled speciation rate (PSR) of the HBD model at the corresponding <code>ages</code>. Between grid points, the PSR is assumed to either be constant (if <code>splines_degree=0</code>), or linearly (if <code>splines_degree=1</code>) or quadratically (if <code>splines_degree=2</code>) or cubically (if <code>splines_degree=3</code>). To calculate the PSR of an HBD model based on the speciation and extinction rate, see <code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="model_adequacy_hbd_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, one of 0, 1, 2 or 3, specifying the polynomial degree of the PSR between age-grid points. For example, <code>splines_degree=0</code> means piecewise constant, <code>splines_degree=1</code> means piecewise linear and so on.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbd_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Logical, specifying whether to extrapolate the model variables <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> (as constants) beyond the provided age grid all the way to <code>stem_age</code> and <code>end_age</code> if needed.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbd_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, the number of bootstraps (simulations) to perform for calculating statistical significances. A larger number will increase the accuracy of estimated statistical significances.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbd_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, number of parallel threads to use for bootstrapping. Note that on Windows machines this option is ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to model selection, the adequacy of any chosen model should also be assessed in absolute terms, i.e. not just relative to other competing models (after all, all considered models might be bad). This function essentially determines how probable it is for hypothetical trees generated by a candidate model to resemble the tree at hand, in terms of various test statistics (such as the historically popular &quot;gamma&quot; statistic, or the Colless tree imbalance). In particular, the function uses a Kolmogorov-Smirnov test to check whether the probability distributions of edge lengths and node ages in the tree resemble those expected under the model. All statistical significances are calculated using bootstrapping, i.e. by simulating trees from the provided model with the same number of tips and the same root age as the original tree.
</p>
<p>Note that even if an HBD model appears to adequately explain a given timetree, this does not mean that the model even approximately resembles the true diversification history (i.e., the true speciation and extinction rates) that generated the tree (Louca and Pennell 2020). Hence, it is generally more appropriate to say that a given model &quot;congruence class&quot; (or PSR) rather than a specific model (speciation rate, extinction rate, and sampling fraction) explains the tree.
</p>
<p>This function requires that the HBD model (or more precisely, its congruence class) be defined in terms of the PSR. If your model is defined in terms of speciation/extinction rates and a sampling fraction, or if your model's congruence class is defined in terms of the pulled diversification rate (PDR) and the product <code class="reqn">\rho\lambda_o</code>, then you can use <code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code> to first calculate the corresponding PSR.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the model evaluation was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined. Note that <code>success</code> does not say whether the model explains the tree, but rather whether the computation was performed without errors.
</p>
</td></tr>
<tr><td><code>Nbootstraps</code></td>
<td>

<p>Integer, the number of bootstraps used.
</p>
</td></tr>
<tr><td><code>tree_gamma</code></td>
<td>

<p>Numeric, gamma statistic (Pybus and Harvey 2000) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_gamma</code></td>
<td>

<p>Numeric, mean gamma statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>bootstrap_std_gamma</code></td>
<td>

<p>Numeric, standard deviation of the gamma statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>Pgamma</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's gamma statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_gamma-tree_gamma)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>RESgamma</code></td>
<td>

<p>Numeric, relative effect size of the tree's gamma statistic compared to the provided null model, i.e. <code>(tree_gamma-bootstrap_mean_gamma)/abs(bootstrap_mean_gamma)</code>.
</p>
</td></tr>
<tr><td><code>SESgamma</code></td>
<td>

<p>Numeric, standardized effect size of the tree's gamma statistic compared to the provided null model, i.e. <code>(tree_gamma-bootstrap_mean_gamma)/bootstrap_std_gamma</code>.
</p>
</td></tr>
<tr><td><code>tree_Colless</code></td>
<td>

<p>Numeric, Colless imbalance statistic (Shao and Sokal, 1990) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Colless</code></td>
<td>

<p>Numeric, mean Colless statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>bootstrap_std_Colless</code></td>
<td>

<p>Numeric, standard deviation of the Colless statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>PColless</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's Colless statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Colless-tree_Colless)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>RESColless</code></td>
<td>

<p>Numeric, relative effect size of the tree's Colless statistic compared to the provided null model, i.e. <code>(tree_Colless-bootstrap_mean_Colless)/abs(bootstrap_mean_Colless)</code>.
</p>
</td></tr>
<tr><td><code>SESColless</code></td>
<td>

<p>Numeric, standardized effect size of the tree's Colless statistic compared to the provided null model, i.e. <code>(tree_Colless-bootstrap_mean_Colless)/bootstrap_std_Colless</code>.
</p>
</td></tr>
<tr><td><code>tree_Sackin</code></td>
<td>

<p>Numeric, Sackin statistic (Sackin, 1972) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Sackin</code></td>
<td>

<p>Numeric, mean Sackin statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>bootstrap_std_Sackin</code></td>
<td>

<p>Numeric, standard deviation of the Sackin statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>PSackin</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's Sackin statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Sackin-tree_Sackin)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>RESSackin</code></td>
<td>

<p>Numeric, relative effect size of the tree's Sackin statistic compared to the provided null model, i.e. <code>(tree_Sackin-bootstrap_mean_Sackin)/abs(bootstrap_mean_Sackin)</code>.
</p>
</td></tr>
<tr><td><code>SESSackin</code></td>
<td>

<p>Numeric, standardized effect size of the tree's Sackin statistic compared to the provided null model, i.e. <code>(tree_Sackin-bootstrap_mean_Sackin)/bootstrap_std_Sackin</code>.
</p>
</td></tr>
<tr><td><code>tree_Blum</code></td>
<td>

<p>Numeric, Blum statistic (Blum and Francois, 2006) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Blum</code></td>
<td>

<p>Numeric, mean Blum statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>bootstrap_std_Blum</code></td>
<td>

<p>Numeric, standard deviation of the Blum statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>PBlum</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's Blum statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Blum-tree_Blum)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>RESBlum</code></td>
<td>

<p>Numeric, relative effect size of the tree's Blum statistic compared to the provided null model, i.e. <code>(tree_Blum-bootstrap_mean_Blum)/abs(bootstrap_mean_Blum)</code>.
</p>
</td></tr>
<tr><td><code>SESBlum</code></td>
<td>

<p>Numeric, standardized effect size of the tree's Blum statistic compared to the provided null model, i.e. <code>(tree_Blum-bootstrap_mean_Blum)/bootstrap_std_Blum</code>.
</p>
</td></tr>
<tr><td><code>tree_edgeKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's edge lengths, i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of edge lengths.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_edgeKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' edge lengths.
</p>
</td></tr>
<tr><td><code>bootstrap_std_edgeKS</code></td>
<td>

<p>Numeric, standard deviation of the KS statistic of the bootstrap trees' edge lengths.
</p>
</td></tr>
<tr><td><code>PedgeKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's edge-length KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of edge lengths in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>RESedgeKS</code></td>
<td>

<p>Numeric, relative effect size of the tree's edge-length KS statistic compared to the provided null model, i.e. <code>(tree_edgeKS-bootstrap_mean_edgeKS)/abs(bootstrap_mean_edgeKS)</code>.
</p>
</td></tr>
<tr><td><code>SESedgeKS</code></td>
<td>

<p>Numeric, standardized effect size of the tree's edge-length KS statistic compared to the provided null model, i.e. <code>(tree_edgeKS-bootstrap_mean_edgeKS)/bootstrap_std_edgeKS</code>.
</p>
</td></tr>
<tr><td><code>tree_nodeKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's node ages (divergence times), i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of node ages.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_nodeKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' node ages.
</p>
</td></tr>
<tr><td><code>bootstrap_std_nodeKS</code></td>
<td>

<p>Numeric, standard deviation of the KS statistic of the bootstrap trees' node ages.
</p>
</td></tr>
<tr><td><code>PnodeKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's node-age KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of node ages in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>RESnodeKS</code></td>
<td>

<p>Numeric, relative effect size of the tree's node-age KS statistic compared to the provided null model, i.e. <code>(tree_nodeKS-bootstrap_mean_nodeKS)/abs(bootstrap_mean_nodeKS)</code>.
</p>
</td></tr>
<tr><td><code>SESnodeKS</code></td>
<td>

<p>Numeric, standardized effect size of the tree's node-age KS statistic compared to the provided null model, i.e. <code>(tree_nodeKS-bootstrap_mean_nodeKS)/bootstrap_std_nodeKS</code>.
</p>
</td></tr>
<tr><td><code>tree_sizeKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's node sizes (number of descending tips per node), i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of node sizes.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_sizeKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' node sizes.
</p>
</td></tr>
<tr><td><code>bootstrap_std_sizeKS</code></td>
<td>

<p>Numeric, standard deviation of the KS statistic of the bootstrap trees' node sizes.
</p>
</td></tr>
<tr><td><code>PsizeKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's node-size KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of node sizes in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>RESsizeKS</code></td>
<td>

<p>Numeric, relative effect size of the tree's node-size KS statistic compared to the provided null model, i.e. <code>(tree_sizeKS-bootstrap_mean_sizeKS)/abs(bootstrap_mean_sizeKS)</code>.
</p>
</td></tr>
<tr><td><code>SESsizeKS</code></td>
<td>

<p>Numeric, standardized effect size of the tree's node-size KS statistic compared to the provided null model, i.e. <code>(tree_sizeKS-bootstrap_mean_sizeKS)/bootstrap_std_sizeKS</code>.
</p>
</td></tr>
<tr><td><code>statistical_tests</code></td>
<td>

<p>Data frame, listing the above statistical test results in a more compact format (one test statistic per row).
</p>
</td></tr>
<tr><td><code>LTT_ages</code></td>
<td>

<p>Numeric vector, listing ages (time before present) on which the tree's LTT will be defined.
</p>
</td></tr>
<tr><td><code>tree_LTT</code></td>
<td>

<p>Numeric vector of the same length as <code>LTT_ages</code>, listing the number of lineages in the tree at every age in <code>LTT_ages</code>.
</p>
</td></tr>
<tr><td><code>bootstrap_LTT_CI</code></td>
<td>

<p>Named list containing the elements <code>means</code>, <code>medians</code>, <code>CI50lower</code>, <code>CI50upper</code>, <code>CI95lower</code> and <code>CI95upper</code>. Each of these elements is a numeric vector of length equal to <code>LTT_ages</code>, listing the mean or a specific percentile of LTTs of bootstrap trees at every age in <code>LTT_ages</code>. For example, <code>bootstrap_LTT_CI$CI95lower[10]</code> and <code>bootstrap_LTT_CI$CI95upper[10]</code> define the lower and upper bound, respectively, of the 95% confidence interval of LTTs generated by the model at age <code>LTT_ages[10]</code>.
</p>
</td></tr>
<tr><td><code>fraction_LTT_in_CI95</code></td>
<td>

<p>Numeric, fraction of the tree's LTT contained within the equal-tailed 95%-confidence interval of the distribution of LTT values predicted by the model. For example, a value of 0.5 means that at half of the time points between the present-day and the root, the tree's LTT is contained with the 95%-CI of predicted LTTs.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>
<p>O. G. Pybus and P. H. Harvey (2000). Testing macro-evolutionary models using incomplete molecular phylogenies. Proceedings of the Royal Society of London. Series B: Biological Sciences. 267:2267-2272.
</p>
<p>M. J. Sackin (1972). &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology. 21:225-226.
</p>
<p>K.T. Shao, R. R. Sokal (1990). Tree Balance. Systematic Biology. 39:266-276.
</p>
<p>M. G. B. Blum and O. Francois (2006). Which random processes describe the Tree of Life? A large-scale study of phylogenetic tree imbalance. Systematic Biology. 55:685-691.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>,
<code><a href="#topic+model_adequacy_hbds">model_adequacy_hbds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a tree
tree = castor::generate_tree_hbd_reverse(Ntips  = 50,
                                         lambda = 1,
                                         mu     = 0.5,
                                         rho    = 1)$trees[[1]]
root_age = castor::get_tree_span(tree)$max_distance

# define &amp; simulate a somewhat different BD model
model = simulate_deterministic_hbd(LTT0         = 50,
                                   oldest_age   = root_age,
                                   lambda       = 1.5,
                                   mu           = 0.5,
                                   rho0         = 1)

# compare the tree to the model
adequacy = model_adequacy_hbd(tree, 
                              models        = model,
                              Nbootstraps   = 100,
                              Nthreads      = 2)
if(!adequacy$success){
    cat(sprintf("Adequacy test failed: %s\n",adequacy$error))
}else{
    print(adequacy$statistical_tests)
}
</code></pre>

<hr>
<h2 id='model_adequacy_hbds'>
Check if a birth-death-sampling model adequately explains a timetree.
</h2><span id='topic+model_adequacy_hbds'></span>

<h3>Description</h3>

<p>Given a rooted timetree and a homogenous birth-death-sampling model (e.g., as used in molecular epidemiology), check if the model adequately explains various aspects of the tree, such as the branch length and node age distributions and other test statistics. The function uses bootstrapping to simulate multiple hypothetical trees according to the model and then compares the distribution of those trees to the original tree. This function may be used to quantify the &quot;goodness of fit&quot; of a birth-death-sampling model to a timetree. For background on the HBDS model see the documentation for <code><a href="#topic+generate_tree_hbds">generate_tree_hbds</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_adequacy_hbds(tree,
                    models,
                    splines_degree      = 1,
                    extrapolate         = FALSE,
                    Nbootstraps         = 1000,
                    max_sim_attempts    = 1000,
                    Nthreads            = 1,
                    max_extant_tips     = NULL,
                    max_model_runtime   = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_adequacy_hbds_+3A_tree">tree</code></td>
<td>

<p>A rooted timetree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_models">models</code></td>
<td>

<p>Either a single HBDS model or a list of HBDS models, specifying the pool of models from which to randomly draw bootstraps. Every model should itself be a named list with some or all of the following elements: 
</p>
<ul>
<li> <p><code>stem_age</code>: Numeric, the age (time before present) at which the HBDS process started. If <code>NULL</code>, this is automatically set to the input tree's root age.
</p>
</li>
<li> <p><code>end_age</code> : Numeric, the age (time before present) at which the HBDS process halted. This will typically be 0 (i.e., at the tree's youngest tip), however it may also be negative if the process actually halted after the youngest tip was sampled.
</p>
</li>
<li> <p><code>ages</code>: Numeric vector, specifying discrete ages (times before present) in ascending order, on which all model variables (e.g., <code class="reqn">\lambda</code>, <code class="reqn">\mu</code> and <code class="reqn">\psi</code>) will be specified. Age increases from tips to root; the youngest tip in the input tree has age 0. The age grid must cover <code>stem_age</code> and <code>end_age</code>.
</p>
</li>
<li> <p><code>lambda</code>: Numeric vector of the same length as <code>ages</code>, listing the speciation rate (<code class="reqn">\lambda</code>) of the HBDS model at the corresponding <code>ages</code>. Between grid points, the speciation rate is assumed to either be constant (if <code>splines_degree=0</code>), or linearly (if <code>splines_degree=1</code>) or quadratically (if <code>splines_degree=2</code>) or cubically (if <code>splines_degree=3</code>).
</p>
</li>
<li> <p><code>mu</code>: Numeric vector of the same length as <code>ages</code>, listing the extinction rate (<code class="reqn">\mu</code>) of the HBDS model at the corresponding <code>ages</code>. Between grid points, the extinction rate is assumed to either be constant (if <code>splines_degree=0</code>), or linearly (if <code>splines_degree=1</code>) or quadratically (if <code>splines_degree=2</code>) or cubically (if <code>splines_degree=3</code>). Note that in epidemiological models <code class="reqn">\mu</code> usually corresponds to the recovery rate plus the death rate of infected hosts. If <code>mu</code> is not included, it is assumed to be zero.
</p>
</li>
<li> <p><code>psi</code>: Optional numeric vector of the same length as <code>ages</code>, listing the Poissonian sampling rate (<code class="reqn">\mu</code>) of the HBDS model at the corresponding <code>ages</code>. Between grid points, the sampling rate is assumed to either be constant (if <code>splines_degree=0</code>), or linearly (if <code>splines_degree=1</code>) or quadratically (if <code>splines_degree=2</code>) or cubically (if <code>splines_degree=3</code>). If <code>psi</code> is not included, it is assumed to be zero.
</p>
</li>
<li> <p><code>kappa</code>: Optional numeric vector of the same length as <code>ages</code>, listing the retention probability upon sampling (<code class="reqn">\kappa</code>) of the HBDS model at the corresponding <code>ages</code>. Between grid points, the retention probability is assumed to either be constant (if <code>splines_degree=0</code>), or linearly (if <code>splines_degree=1</code>) or quadratically (if <code>splines_degree=2</code>) or cubically (if <code>splines_degree=3</code>). Note that since <code>kappa</code> are actual probabilities, they must all be between 0 and 1. If <code>kappa</code> is not included, it is assumed to be zero.
</p>
</li>
<li> <p><code>CSA_ages</code>: Numeric vector listing the ages (time before present) of concentrated sampling attempts, in ascending order. If empty or <code>NULL</code>, no concentrated sampling attempts are included, i.e. all sampling is assumed to be done according to the Poissonian rate <code class="reqn">\psi</code>.
</p>
</li>
<li> <p><code>CSA_probs</code>: Optional numeric vector, of the same length as <code>CSA_ages</code>, specifying the sampling probabilities for each concentrated sampling attempt listed in <code>CSA_ages</code>. Hence, a lineage extant at age <code>CSA_ages[k]</code> has probability <code>CSA_probs[k]</code> of being sampled. Note that since <code>CSA_probs</code> are actual probabilities, they must all be between 0 and 1. <code>CSA_probs</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</li>
<li> <p><code>CSA_kappas</code>: Optional numeric vector, of the same length as <code>CSA_ages</code>, specifying the retention probability upon sampling for each concentrated sampling attempt listed in <code>CSA_ages</code>. Note that since <code>CSA_kappas</code> are actual probabilities, they must all be between 0 and 1. <code>CSA_kappas</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</li></ul>

<p>If you are assessing the adequacy of a single model with specific parameters, then <code>models</code> can be a single model. If you want to assess the adequacy of a distribution of models, such as sampled from the posterior distribution during a Bayesian analysis, <code>models</code> should list those posterior models.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, one of 0, 1, 2 or 3, specifying the polynomial degree of the model parameters <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> between age-grid points. For example, <code>splines_degree=0</code> means piecewise constant, <code>splines_degree=1</code> means piecewise linear and so on.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_extrapolate">extrapolate</code></td>
<td>

<p>Logical, specifying whether to extrapolate the model variables <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> (as constants) beyond the provided age grid all the way to <code>stem_age</code> and <code>end_age</code> if needed.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_nbootstraps">Nbootstraps</code></td>
<td>

<p>Integer, the number of bootstraps (simulations) to perform for calculating statistical significances. A larger number will increase the accuracy of estimated statistical significances.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_max_sim_attempts">max_sim_attempts</code></td>
<td>

<p>Integer, maximum number of simulation attempts per bootstrap, before giving up. Multiple attempts may be needed if the HBDS model has a high probability of leading to extinction early on.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, number of parallel threads to use for bootstrapping. Note that on Windows machines this option is ignored.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_max_extant_tips">max_extant_tips</code></td>
<td>

<p>Integer, optional maximum number of extant tips per simulation. A simulation is aborted (and that bootstrap iteration skipped) if the number of extant tips exceeds this threshold. Use this to avoid occasional explosions of runtimes, for example due to very large generated trees.
</p>
</td></tr>
<tr><td><code id="model_adequacy_hbds_+3A_max_model_runtime">max_model_runtime</code></td>
<td>

<p>Numeric, optional maximum computation time (in seconds) to allow for each HBDS model simulation (per bootstrap). Use this to avoid occasional explosions of runtimes, for example due to very large generated trees. Aborted simulations will be omitted from the bootstrap statistics. If <code>NULL</code> or &lt;=0, this option is ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to model selection, the adequacy of any chosen model should also be assessed in absolute terms, i.e. not just relative to other competing models (after all, all considered models might be bad). This function essentially determines how probable it is for hypothetical trees generated by a candidate model (or a distribution of candidate models) to resemble the tree at hand, in terms of various test statistics. In particular, the function uses a Kolmogorov-Smirnov test to check whether the probability distributions of edge lengths and node ages in the tree resemble those expected under the provided models. All statistical significances are calculated using bootstrapping, i.e. by simulating trees from the provided models. For every bootstrap, a model is randomly chosen from the provided <code>models</code> list.
</p>
<p>Note that even if an HBDS model appears to adequately explain a given timetree, this does not mean that the model even approximately resembles the true diversification history (i.e., the true speciation, extinction and sampling rates) that generated the tree (Louca and Pennell 2020). Hence, it is generally more appropriate to say that a given model &quot;congruence class&quot; rather than a specific model explains the tree.
</p>
<p>Note that here &quot;age&quot; refers to time before present, i.e. age increases from tips to roots and the youngest tip in the input tree has age 0. In some situations the process that generated the tree (or which is being compared to the tree) might have halted after the last tip was sampled, in which case <code>end_age</code> should be negative. Similarly, the process may have started prior to the tree's root (e.g., sampled tips coalesce at a later time than when the monitoring started), in which case <code>stem_age</code> should be greater than the root's age. 
</p>
<p>For convenience, it is possible to specify a model without providing an explicit age grid (i.e., omitting <code>ages</code>); in such a model <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are assumed to be time-independent, and hence <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> must be provided as single numerics (or not provided at all).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the model evaluation was successful. If <code>FALSE</code>, then an additional return variable, <code>error</code>, will contain a description of the error; in that case all other return variables may be undefined. Note that <code>success</code> does not say whether the model explains the tree, but rather whether the computation was performed without errors.
</p>
</td></tr>
<tr><td><code>Nbootstraps</code></td>
<td>

<p>Integer, the number of bootstraps used.
</p>
</td></tr>
<tr><td><code>tree_Ntips</code></td>
<td>

<p>Integer, the number of tips in the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Ntips</code></td>
<td>

<p>Numeric, mean number of tips in the bootstrap trees.
</p>
</td></tr>
<tr><td><code>PNtips</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's number of tips under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Ntips-tree_Ntips)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>tree_Colless</code></td>
<td>

<p>Numeric, Colless imbalance statistic (Shao and Sokal, 1990) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Colless</code></td>
<td>

<p>Numeric, mean Colless statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>PColless</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's Colless statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Colless-tree_Colless)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>tree_Sackin</code></td>
<td>

<p>Numeric, Sackin statistic (Sackin, 1972) of the original tree.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_Sackin</code></td>
<td>

<p>Numeric, median Sackin statistic across all bootstrap trees.
</p>
</td></tr>
<tr><td><code>PSackin</code></td>
<td>

<p>Numeric, two-sided statistical significance of the tree's Sackin statistic under the provided null model, i.e. the probability that <code>abs(bootstrap_mean_Sackin-tree_Sackin)</code> would be as large as observed.
</p>
</td></tr>
<tr><td><code>tree_edgeKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's edge lengths, i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of edge lengths.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_edgeKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' edge lengths.
</p>
</td></tr>
<tr><td><code>PedgeKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's edge-length KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of edge lengths in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>tree_tipKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's tip ages (sampling times before present), i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of tip ages.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_tipKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' tip ages.
</p>
</td></tr>
<tr><td><code>PtipKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's tip-age KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of tip ages in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>tree_nodeKS</code></td>
<td>

<p>Numeric, Kolmogorov-Smirnov (KS) statistic of the original tree's node ages (divergence times before present), i.e. the estimated maximum difference between the tree's and the model's (estimated) cumulative distribution function of node ages.
</p>
</td></tr>
<tr><td><code>bootstrap_mean_nodeKS</code></td>
<td>

<p>Numeric, mean KS statistic of the bootstrap trees' node ages.
</p>
</td></tr>
<tr><td><code>PnodeKS</code></td>
<td>

<p>Numeric, the one-sided statistical significance of the tree's node-age KS statistic, i.e. the probability that the KS statistic of any tree generated by the model would be larger than the original tree's KS statistic. A low value means that the probability distribution of node ages in the original tree differs strongly from that expected based on the model.
</p>
</td></tr>
<tr><td><code>statistical_tests</code></td>
<td>

<p>Data frame, listing the above statistical test results in a more compact format (one test statistic per row).
</p>
</td></tr>
<tr><td><code>LTT_ages</code></td>
<td>

<p>Numeric vector, listing ages (time before present) on which the tree's LTT will be defined.
</p>
</td></tr>
<tr><td><code>tree_LTT</code></td>
<td>

<p>Numeric vector of the same length as <code>LTT_ages</code>, listing the number of lineages in the tree at every age in <code>LTT_ages</code>.
</p>
</td></tr>
<tr><td><code>bootstrap_LTT_CI</code></td>
<td>

<p>Named list containing the elements <code>means</code>, <code>medians</code>, <code>CI50lower</code>, <code>CI50upper</code>, <code>CI95lower</code> and <code>CI95upper</code>. Each of these elements is a numeric vector of length equal to <code>LTT_ages</code>, listing the mean or a specific percentile of LTTs of bootstrap trees at every age in <code>LTT_ages</code>. For example, <code>bootstrap_LTT_CI$CI95lower[10]</code> and <code>bootstrap_LTT_CI$CI95upper[10]</code> define the lower and upper bound, respectively, of the 95% confidence interval of LTTs generated by the model at age <code>LTT_ages[10]</code>.
</p>
</td></tr>
<tr><td><code>fraction_LTT_in_CI95</code></td>
<td>

<p>Numeric, fraction of the tree's LTT contained within the equal-tailed 95%-confidence interval of the distribution of LTT values predicted by the model. For example, a value of 0.5 means that at half of the time points between the present-day and the root, the tree's LTT is contained with the 95%-CI of predicted LTTs.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>S. Louca and M. W. Pennell (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature. 580:502-505.
</p>
<p>O. G. Pybus and P. H. Harvey (2000). Testing macro-evolutionary models using incomplete molecular phylogenies. Proceedings of the Royal Society of London. Series B: Biological Sciences. 267:2267-2272.
</p>
<p>M. J. Sackin (1972). &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology. 21:225-226.
</p>
<p>K.T. Shao, R. R. Sokal (1990). Tree Balance. Systematic Biology. 39:266-276.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_deterministic_hbds">simulate_deterministic_hbds</a></code>,
<code><a href="#topic+generate_tree_hbds">generate_tree_hbds</a></code>,
<code><a href="#topic+model_adequacy_hbd">model_adequacy_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a tree based on a simple HBDS process
max_time = 10
gen = castor::generate_tree_hbds(max_time           = max_time,
                                 lambda             = 1,
                                 mu                 = 0.1,
                                 psi                = 0.1,
                                 no_full_extinction = TRUE)
if(!gen$success) stop(sprintf("Could not generate tree: %s",gen$error))
tree     = gen$tree
root_age = castor::get_tree_span(tree)$max_distance

# determine age of the stem, i.e. when the HBDS process started
stem_age = gen$root_time + root_age

# determine age at which the HBDS simulation was halted.
# This might be slightly negative, e.g. if the process
# halted after the last sampled tip
end_age = root_age - (gen$final_time-gen$root_time)

# compare the tree to a slightly different model
model = list(stem_age    = stem_age,
             end_age     = end_age,
             lambda      = 1.2,
             mu          = 0.1,
             psi         = 0.2)
adequacy = model_adequacy_hbds( tree, 
                                models = model,
                                Nbootstraps = 100)
if(!adequacy$success){
    cat(sprintf("Adequacy test failed: %s\n",adequacy$error))
}else{
    print(adequacy$statistical_tests)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='multifurcations_to_bifurcations'>
Expand multifurcations to bifurcations.
</h2><span id='topic+multifurcations_to_bifurcations'></span>

<h3>Description</h3>

<p>Eliminate multifurcations from a phylogenetic tree, by replacing each multifurcation with multiple bifurcations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multifurcations_to_bifurcations(tree, dummy_edge_length=0, 
                                new_node_basename="node.", 
                                new_node_start_index=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multifurcations_to_bifurcations_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="multifurcations_to_bifurcations_+3A_dummy_edge_length">dummy_edge_length</code></td>
<td>

<p>Non-negative numeric. Length to be used for new (dummy) edges when breaking multifurcations into bifurcations. Typically this will be 0, but can also be a positive number if zero edge lengths are not desired in the returned tree.
</p>
</td></tr>
<tr><td><code id="multifurcations_to_bifurcations_+3A_new_node_basename">new_node_basename</code></td>
<td>

<p>Character. Name prefix to be used for added nodes (e.g. &quot;node.&quot; or &quot;new.node.&quot;). Only relevant if the input tree included node labels.
</p>
</td></tr>
<tr><td><code id="multifurcations_to_bifurcations_+3A_new_node_start_index">new_node_start_index</code></td>
<td>

<p>Integer. First index for naming added nodes. Can also be <code>NULL</code>, in which case this is set to Nnodes+1, where Nnodes is the number of nodes in the input tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each multifurcating node (i.e. with more than 2 children), all children but one will be placed on new bifurcating nodes, connected to the original node through one or more dummy edges.
</p>
<p>The input tree need not be rooted, however descendance from each node is inferred based on the direction of edges in <code>tree$edge</code>. The input tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child). Monofurcations are kept in the returned tree. 
</p>
<p>All tips and nodes in the input tree retain their original indices, however the returned tree may include additional nodes and edges. Edge indices may change.
</p>
<p>If <code>tree$edge.length</code> is missing, then all edges in the input tree are assumed to have length 1. The returned tree will include <code>edge.length</code>, with all new edges having length equal to <code>dummy_edge_length</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new tree of class &quot;phylo&quot;, containing only bifurcations (and monofurcations, if these existed in the input tree). 
</p>
</td></tr>
<tr><td><code>old2new_edge</code></td>
<td>

<p>Integer vector of length Nedges, mapping edge indices in the old tree to edge indices in the new tree.
</p>
</td></tr>
<tr><td><code>Nnodes_added</code></td>
<td>

<p>Integer. Number of nodes added to the new tree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse_monofurcations">collapse_monofurcations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random multifurcating tree
Ntips = 1000
tree = generate_random_tree(list(birth_rate_intercept=1), Ntips, Nsplits=5)$tree

# expand multifurcations to bifurcations
new_tree = multifurcations_to_bifurcations(tree)$tree

# print summary of old and new tree
cat(sprintf("Old tree has %d nodes\n",tree$Nnode))
cat(sprintf("New tree has %d nodes\n",new_tree$Nnode))
</code></pre>

<hr>
<h2 id='pick_random_tips'>
Pick random subsets of tips on a tree.
</h2><span id='topic+pick_random_tips'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, this function picks random subsets of tips by traversing the tree from root to tips, choosing a random child at each node until reaching a tip. Multiple random independent subsets can be generated if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_random_tips( tree, 
                  size              = 1, 
                  Nsubsets          = 1, 
                  with_replacement  = TRUE, 
                  drop_dims         = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_random_tips_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="pick_random_tips_+3A_size">size</code></td>
<td>

<p>Integer. The size of each random subset of tips.
</p>
</td></tr>
<tr><td><code id="pick_random_tips_+3A_nsubsets">Nsubsets</code></td>
<td>

<p>Integer. Number of independent subsets to pick.
</p>
</td></tr>
<tr><td><code id="pick_random_tips_+3A_with_replacement">with_replacement</code></td>
<td>

<p>Logical. If <code>TRUE</code>, each tip can be picked multiple times within a subset (i.e. are &quot;replaced&quot; in the urn). If <code>FALSE</code>, tips are picked without replacement in each subset. In that case, <code>size</code> must not be greater than the number of tips in the tree.
</p>
</td></tr>
<tr><td><code id="pick_random_tips_+3A_drop_dims">drop_dims</code></td>
<td>

<p>Logical, specifying whether to return a vector (instead of a matrix) if <code>Nsubsets==1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>with_replacement==TRUE</code>, then each child of a node is equally probable to be traversed and each tip can be included multiple times in a subset. If <code>with_replacement==FALSE</code>, then only children with at least one descending tip not included in the subset remain available for traversal; each available child of a node has equal probability to be traversed. In any case, it is always possible for separate subsets to include the same tips.
</p>
<p>This random sampling algorithm differs from a uniform sampling of tips at equal probabilities; instead, this algorithm ensures that sister clades have equal probabilities to be picked (if <code>with_replacement==TRUE</code> or if <code>size</code>&lt;&lt;Ntips).
</p>
<p>The time required by this function per random subset decreases with the number of subsets requested.
</p>


<h3>Value</h3>

<p>A 2D integer matrix of size Nsubsets x size, with each row containing indices of randomly picked tips (i.e. in 1,..,Ntips) within a specific subset. If <code>drop_dims==TRUE</code> and <code>Nsubsets==1</code>, then a vector is returned instead of a matrix.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate random tree
Ntips = 1000
tree  = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# pick random tip subsets
Nsubsets = 100
size     = 50
subsets = pick_random_tips(tree, size, Nsubsets, with_replacement=FALSE)

# count the number of times each tip was picked in a subset ("popularity")
popularities = table(subsets)

# plot histogram of tip popularities
hist(popularities,breaks=20,xlab="popularity",ylab="# tips",main="tip popularities")
</code></pre>

<hr>
<h2 id='place_tips_taxonomically'>
Place queries on a tree based on taxonomic identities.
</h2><span id='topic+place_tips_taxonomically'></span>

<h3>Description</h3>

<p>Given a rooted tree with associated tip &amp; node taxonomies, as well as a list of query taxonomies, place the queries on nodes of the tree based on taxonomic identity. Each query is placed at the deepest possible node (furthest from the root in terms of splits) for which it is certain that the query is a descendant of.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>place_tips_taxonomically( tree,
                          query_labels,
                          query_taxonomies      = NULL,
                          tip_taxonomies        = NULL,
                          node_taxonomies       = NULL,
                          tree_taxon_delimiter  = ";",
                          query_taxon_delimiter = ";",
                          include_expanded_tree = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="place_tips_taxonomically_+3A_tree">tree</code></td>
<td>

<p>Rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_query_labels">query_labels</code></td>
<td>

<p>Character vector of length Nqueries, listing labels for the newly placed tips.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_query_taxonomies">query_taxonomies</code></td>
<td>

<p>Optional character vector of length Nqueries, listing the taxonomic paths of the queries. If <code>NULL</code>, it is assumed that <code>query_labels</code> are taxonomies.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_tip_taxonomies">tip_taxonomies</code></td>
<td>

<p>Optional character vector of length Ntips, listing taxonomic paths for the tree's tips. If <code>NULL</code>, then tip labels are assumed to be tip taxonomies.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_node_taxonomies">node_taxonomies</code></td>
<td>

<p>Optional character vector of length Nnodes, listing taxonomic paths for the tree's nodes. If <code>NULL</code>, then node labels are assumed to be node taxonomies.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_tree_taxon_delimiter">tree_taxon_delimiter</code></td>
<td>

<p>Character, the delimiter between taxonomic levels in the tree's tip &amp; node taxonomies (e.g., &quot;;&quot; for SILVA taxonomies).
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_query_taxon_delimiter">query_taxon_delimiter</code></td>
<td>

<p>Character, the delimiter between taxonomic levels in <code>query_taxonomies</code>.
</p>
</td></tr>
<tr><td><code id="place_tips_taxonomically_+3A_include_expanded_tree">include_expanded_tree</code></td>
<td>

<p>If <code>TRUE</code>, the expanded tree (i.e., including the placements) is returned as well, at some computational cost. If <code>FALSE</code>, only the placement info is returned, but no tree expansion is done. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the tip &amp; node taxonomies are somewhat consistent with each other and with the tree's topology.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>placement_nodes</code></td>
<td>

<p>Integer vector of length Nqueries, with values in 1,..,Nnodes, specifying for each query the node on which it was placed. For queries that could not be placed on the tree, the value 0 is used.
</p>
</td></tr>
</table>
<p>If <code>include_expanded_tree</code> was <code>TRUE</code>, the following additional elements are included:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>Object of class &quot;phylo&quot;, the extended tree constructed by adding the placements on the original tree.
</p>
</td></tr>
<tr><td><code>placed_tips</code></td>
<td>

<p>Integer vector of length Nqueries, specifying which tips in the returned tree correspond to placements. For queries that could not be placed on the tree, the value 0 is used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+expanded_tree_from_jplace">expanded_tree_from_jplace</a></code>
</p>

<hr>
<h2 id='read_tree'>
Load a tree from a string or file in Newick (parenthetic) format.
</h2><span id='topic+read_tree'></span>

<h3>Description</h3>

<p>Load a phylogenetic tree from a file or a string, in Newick (parenthetic) format. Any valid Newick format is acceptable. Extended variants including edge labels and edge numbers are also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tree(  string  = "", 
            file    = "", 
            edge_order              = "cladewise",
            include_edge_lengths    = TRUE, 
            look_for_edge_labels    = FALSE, 
            look_for_edge_numbers   = FALSE, 
            include_node_labels     = TRUE, 
            underscores_as_blanks   = FALSE, 
            check_label_uniqueness  = FALSE,
            interpret_quotes        = FALSE,
            trim_white              = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tree_+3A_string">string</code></td>
<td>

<p>A character containing a single tree in Newick format. Can be used alternatively to <code>file</code>.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_file">file</code></td>
<td>

<p>Character, a path to an input text file containing a single tree in Newick format. Can be used alternatively to <code>string</code>.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_edge_order">edge_order</code></td>
<td>

<p>Character, one of &ldquo;cladewise&rdquo; or &ldquo;pruningwise&rdquo;, specifying the order in which edges should be listed in the returned tree. This does not influence the topology of the tree or the tip/node labeling, it only affects the way edges are numbered internally.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_include_edge_lengths">include_edge_lengths</code></td>
<td>

<p>Logical, specifying whether edge lengths (if available) should be included in the returned tree.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_look_for_edge_labels">look_for_edge_labels</code></td>
<td>

<p>Logical, specifying whether edge labels may be present in the input tree. If edge labels are found, they are included in the returned tree as a character vector <code>edge.label</code>. Edge labels are sought inside square brackets, which are not part of the standard Newick format but used by some tree creation software (Matsen 2012). If <code>look_for_edge_labels==FALSE</code>, square brackets are read verbatim just like any other character.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_look_for_edge_numbers">look_for_edge_numbers</code></td>
<td>

<p>Logical, specifying whether edge numbers (non-negative integers) may be present in the input tree. If edge numbers are found, they are included in the returned tree as an integer vector <code>edge.number</code>. Edge numbers are sought inside curly braces, which are not part of the standard Newick format but used by some tree creation software (Matsen 2012). If <code>look_for_edge_numbers==FALSE</code>, curly braces are read verbatim just like any other character.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_include_node_labels">include_node_labels</code></td>
<td>

<p>Logical, specifying whether node labels (if available) should be included in the returned tree.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_underscores_as_blanks">underscores_as_blanks</code></td>
<td>

<p>Logical, specifying whether underscores (&quot;_&quot;) in tip and node labels should be replaced by spaces (&quot; &quot;). This is common behavior in other tree parsers. In any case, tip, node and edge labels (if available) are also allowed to contain explicit whitespace (except for newline characters).
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_check_label_uniqueness">check_label_uniqueness</code></td>
<td>

<p>Logical, specifying whether to check if all tip labels are unique.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_interpret_quotes">interpret_quotes</code></td>
<td>

<p>Logical, specifying whether to interpret quotes as delimiters of tip/node/edge labels. If <code>FALSE</code>, then quotes are read verbatim just like any other character.
</p>
</td></tr>
<tr><td><code id="read_tree_+3A_trim_white">trim_white</code></td>
<td>

<p>Logical, specifying whether to trim flanking whitespace from tip, node and edge labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is comparable to (but typically much faster than) the <code>ape</code> function <code>read.tree</code>. The function supports trees with monofurcations and multifurcations, trees with or without tip/node labels, and trees with or without edge lengths. The time complexity is linear in the number of edges in the tree.
</p>
<p>Either <code>file</code> or <code>string</code> must be specified, but not both. The tree may be arbitrarily split across multiple lines, but no other non-whitespace text is permitted in <code>string</code> or in the input file. Flanking whitespace (space, tab, newlines) is ignored.
</p>


<h3>Value</h3>

<p>A single rooted phylogenetic tree in &ldquo;phylo&rdquo; format.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Frederick A. Matsen et al. (2012). A format for  phylogenetic placements. PLOS One. 7:e31009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_tree">write_tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=100)$tree

# obtain a string representation of the tree in Newick format
Newick_string = write_tree(tree)

# re-parse tree from string
parsed_tree = read_tree(Newick_string)
</code></pre>

<hr>
<h2 id='reconstruct_past_diversification'>
Reconstruct past diversification dynamics from a diversity time series.
</h2><span id='topic+reconstruct_past_diversification'></span>

<h3>Description</h3>

<p>Given a time series of past diversities (coalescent or not), this function estimates instantaneous birth (speciation) and death (extinction) rates that would lead to the observed diversity time series. The function is based on a deterministic model (or the continuum limit of a stochastic cladogenic model), in which instantaneous birth and death rates lead to a predictable growth of a tree (one new species per birth event). The reconstruction is non-parametric, i.e. does not rely on fitting a parameterized model. The reconstruction is only accurate in the deterministic limit, i.e. for high diversities where the stochastic nature of the cladogenic process diminishes. Of particular importance is the case where the time series is coalescent, i.e. represents the diversity (lineages-through-time) that would be represented in a coalescent tree with extinctions. 
</p>
<p>Note: This function is included for legacy reasons mainly. In most cases users should instead use the functions <code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code> and <code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code> to fit birth-death models, or the functions <code><a href="#topic+fit_hbd_pdr_on_grid">fit_hbd_pdr_on_grid</a></code>, <code><a href="#topic+fit_hbd_pdr_parametric">fit_hbd_pdr_parametric</a></code> and <code><a href="#topic+fit_hbd_psr_on_grid">fit_hbd_psr_on_grid</a></code> to fit BD model congruence classes (aka. &ldquo;pulled variables&rdquo;) to a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_past_diversification( times,
                                  diversities,
                                  birth_rates_pc            = NULL,
                                  rarefaction               = NULL,
                                  discovery_fractions       = NULL,
                                  discovery_fraction_slopes = NULL,
                                  max_age                   = NULL,
                                  coalescent                = FALSE,
                                  smoothing_span            = 0,
                                  smoothing_order           = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_past_diversification_+3A_times">times</code></td>
<td>

<p>Numeric vector, listing the times at which diversities are given. Values must be in ascending order.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_diversities">diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing diversities (coalescent or not) at each time point.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_birth_rates_pc">birth_rates_pc</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing known or assumed per-capita birth rates (speciation rates). Can also be of size 1, in which case the same per-capita birth rate is assumed throughout. Alternatively if <code>coalescent==TRUE</code>, then this vector can also be empty, in which case a constant per-capita birth rate is assumed and estimated from the slope of the coalescent diversities at the last time point. The last alternative is not available when <code>coalescent==FALSE</code>.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_rarefaction">rarefaction</code></td>
<td>

<p>Numeric between 0 and 1.  Optional rarefaction fraction assumed for the diversities at the very end. Set to 1 to assume no rarefaction was performed.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_discovery_fractions">discovery_fractions</code></td>
<td>

<p>Numeric array of size Ntimes, listing the fractions of extant lineages represented in the tree over time. Hence, <code>discovery_fraction[t]</code> is the probability that a lineage at time <code>times[t]</code> with extant representatives will be represented in the tree. Can be used as an alternative to <code>rarefaction</code>, for example if discovery of extant species is non-random or phylogenetically biased. Experimental, so leave this <code>NULL</code> if you don't know what it means.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_discovery_fraction_slopes">discovery_fraction_slopes</code></td>
<td>

<p>Numeric array of size Ntimes, listing the 1st derivative of <code>discovery_fractions</code> (w.r.t. time) over time. If <code>NULL</code>, this will be estimated from <code>discovery_fractions</code> via basic finite differences if needed. Experimental, so leave this <code>NULL</code> if you don't know what it means.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_max_age">max_age</code></td>
<td>

<p>Numeric. Optional maximum distance from the end time to be considered. If <code>NULL</code> or &lt;=0 or <code>Inf</code>, all provided time points are considered.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, indicating whether the provided diversities are from a coalescent tree (only including clades with extant representatives) or total diversities (extant species at each time point).
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_smoothing_span">smoothing_span</code></td>
<td>

<p>Non-negative integer. Optional sliding window size (number of time points) for smoothening the diversities time series via Savitzky-Golay-filter. If &lt;=2, no smoothing is done. Smoothening the time series can reduce the effects of noise on the reconstructed diversity dynamics.
</p>
</td></tr>
<tr><td><code id="reconstruct_past_diversification_+3A_smoothing_order">smoothing_order</code></td>
<td>

<p>Integer between 1 and 4. Polynomial order of the Savitzky-Golay smoothing filter to be applied. Only relevant if <code>smoothing_span&gt;2</code>. A value of 1 or 2 is typically recommended.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to fit a birth-death model to a coalescent diversity time series <code class="reqn">N_c(\tau)</code> at various ages <code class="reqn">\tau</code>, also known as &ldquo;lineages-through-time&rdquo; curve. The reconstruction of the total diversity <code class="reqn">N(\tau)</code> is based on the following formulas:
</p>
<p style="text-align: center;"><code class="reqn">
E(\tau)=1+\frac{\nu(\tau)}{\beta(\tau)},\\
</code>
</p>

<p style="text-align: center;"><code class="reqn">
N(\tau)=\frac{N_c}{1-E(\tau)},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\nu(\tau)=\frac{1}{N_c(\tau)}\frac{dN_c(\tau)}{d\tau}
</code>
</p>

<p>where <code class="reqn">E(\tau)</code> is the probability that a clade of size 1 at age <code class="reqn">\tau</code> went extinct by the end of the time series and <code class="reqn">\beta</code> is the per-capita birth rate. If the per-capita birth rate is not explicitly provided for each time point (see argument <code>birth_rate_pc</code>), the function assumes that the per-capita birth rate (speciation rate) is constant at all times. If <code>birth_rates_pc==NULL</code> and <code>coalescent==TRUE</code>, the constant speciation rate is estimated as
</p>
<p style="text-align: center;"><code class="reqn">
\beta = -\frac{\nu(0)}{\rho},
</code>
</p>

<p>where <code class="reqn">\rho</code> is the fraction of species kept after rarefaction (see argument <code>rarefaction</code>). 
</p>
<p>Assuming a constant speciation rate may or may not result in accurate estimates of past total diversities and other quantities. If a time-varying speciation rate is suspected but not known, additional information on past diversification dynamics may be obtained using modified (&ldquo;pulled&rdquo;) quantities that partly resemble the classical extinction rate, diversification rate and total diversity. Such quantities are the &ldquo;pulled diversification rate&rdquo;:
</p>
<p style="text-align: center;"><code class="reqn">
\eta(\tau) = \delta(\tau) - \beta(\tau) + \frac{1}{\beta(\tau)}\frac{d\beta}{d\tau},
</code>
</p>

<p>the &ldquo;pulled extinction rate&rdquo;:
</p>
<p style="text-align: center;"><code class="reqn">
\delta_p(\tau) = \delta(\tau) + (\beta_o-\beta(\tau)) - \frac{1}{\beta(\tau)}\frac{d\beta}{d\tau},
</code>
</p>

<p>and the &ldquo;pulled total diversity&rdquo;:
</p>
<p style="text-align: center;"><code class="reqn">
N_p(\tau) = N(\tau)\cdot\frac{\beta_o}{\beta(\tau)},
</code>
</p>

<p>where <code class="reqn">\beta_o</code> is the provided or estimated (if not provided) speciation rate at the last time point. The advantage of these quantities is that they can be estimated from the coalescent diversities (lineages-through-time) without any assumptions on how <code class="reqn">\beta</code> and <code class="reqn">\delta</code> varied over time. The disadvantage is that they differ from their &ldquo;non-pulled&rdquo; quantities (<code class="reqn">\beta-\delta</code>, <code class="reqn">\delta</code> and <code class="reqn">N</code>), in cases where <code class="reqn">\beta</code> varied over time.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, specifying whether the reconstruction was successful. If <code>FALSE</code>, the remaining elements may not be defined.
</p>
</td></tr>
<tr><td><code>Ntimes</code></td>
<td>

<p>Integer. Number of time points for which reconstruction is returned.
</p>
</td></tr>
<tr><td><code>total_diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the total diversity at each time point (number of extant lineages at each time point). If <code>coalescent==FALSE</code>, then these are the same as the <code>diversities</code> passed to the function.
</p>
</td></tr>
<tr><td><code>coalescent_diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the coalescent diversities at each time point (number of species with at least one extant descendant at the last time point). If <code>coalescent==TRUE</code>, then these are the same as the <code>diversities</code> passed to the function.
</p>
</td></tr>
<tr><td><code>birth_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated birth rates (speciation events per time unit).
</p>
</td></tr>
<tr><td><code>death_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated death rates (extinction events per time unit).
</p>
</td></tr>
<tr><td><code>Psurvival</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated fraction of lineages at each time point that eventually survive. <code>Psurvival[i]</code> is the probability that a clade of size 1 at time <code>times[i]</code> will be extant by the end of the time series. May be <code>NULL</code> in some cases.
</p>
</td></tr>
<tr><td><code>Pdiscovery</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated fraction of lineages at each time point that are eventually discovered, provided that they survive. <code>Pdiscovery[i]</code> is the probability that a clade of size 1 at time <code>times[i]</code> that is extant by the end of the time series, will be discovered. May be <code>NULL</code> in some cases.
</p>
</td></tr>
<tr><td><code>Prepresentation</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated fraction of lineages at each time point that eventually survive and are discovered. <code>Prepresentation[i]</code> is the probability that a clade of size 1 at time <code>times[i]</code> will be extant by the end of the time series and visible in the coalescent tree after rarefaction. Note that Prepresentation = Psurvival * Pdiscovery. May be <code>NULL</code> in some cases.
</p>
</td></tr>
<tr><td><code>total_births</code></td>
<td>

<p>Numeric, giving the estimated total number of birth events that occurred between times <code>T-max_age</code> and <code>T</code>, where <code>T</code> is the last time point of the time series.
</p>
</td></tr>
<tr><td><code>total_deaths</code></td>
<td>

<p>Numeric, giving the estimated total number of death events that occurred between times <code>T-max_age</code> and <code>T</code>, where <code>T</code> is the last time point of the time series.
</p>
</td></tr>
<tr><td><code>last_birth_rate_pc</code></td>
<td>

<p>The provided or estimated (if not provided) speciation rate at the last time point. This corresponds to the birth rate divided by the estimated true diversity (prior to rarefaction) at the last time point.
</p>
</td></tr>
<tr><td><code>last_death_rate_pc</code></td>
<td>

<p>The estimated extinction rate at the last time point. This corresponds to the death rate divided by the estimated true diversity (prior to rarefaction) at the last time point.
</p>
</td></tr>
<tr><td><code>pulled_diversification_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated pulled diversification rates.
</p>
</td></tr>
<tr><td><code>pulled_extinction_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated pulled extinction rates.
</p>
</td></tr>
<tr><td><code>pulled_total_diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the estimated pulled total diversities.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Louca et al (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+fit_tree_model">fit_tree_model</a></code>,
<code><a href="#topic+count_lineages_through_time">count_lineages_through_time</a></code>,
<code><a href="#topic+fit_hbd_model_parametric">fit_hbd_model_parametric</a></code>,
<code><a href="#topic+fit_hbd_model_on_grid">fit_hbd_model_on_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################################
# EXAMPLE 1

# Generate a coalescent tree
params = list(birth_rate_intercept  = 0, 
              birth_rate_factor     = 1,
              birth_rate_exponent   = 1,
              death_rate_intercept  = 0,
              death_rate_factor     = 0.05,
              death_rate_exponent   = 1.3,
              rarefaction           = 1)
simulation = generate_random_tree(params,max_time_eq=1,coalescent=TRUE)
tree = simulation$tree
time_span = simulation$final_time - simulation$root_time
cat(sprintf("Generated tree has %d tips, spans %g time units\n",length(tree$tip.label),time_span))

# Calculate diversity time series from the tree
counter = count_lineages_through_time(tree, times=seq(0,0.99*time_span,length.out=100))

# print coalescent diversities
print(counter$lineages)

# reconstruct diversification dynamics based on diversity time series
results = reconstruct_past_diversification( counter$times,
                                            counter$lineages,
                                            coalescent      = TRUE,
                                            smoothing_span  = 3,
                                            smoothing_order = 1)
                                            
# print reconstructed total diversities
print(results$total_diversities)
                                                  
# plot coalescent and reconstructed true diversities
matplot(x     = counter$times, 
        y     = matrix(c(counter$lineages,results$total_diversities), ncol=2, byrow=FALSE),
        type  = "b", 
        xlab  = "time", 
        ylab  = "# clades",
        lty   = c(1,2), pch = c(1,0), col = c("red","blue"))
legend( "topleft", 
        legend  = c("coalescent (simulated)","true (reconstructed)"), 
        col     = c("red","blue"), lty = c(1,2), pch = c(1,0));
        
        
        
#####################################################
# EXAMPLE 2

# Generate a non-coalescent tree
params = list(birth_rate_intercept  = 0, 
              birth_rate_factor     = 1,
              birth_rate_exponent   = 1,
              death_rate_intercept  = 0,
              death_rate_factor     = 0.05,
              death_rate_exponent   = 1.3,
              rarefaction           = 1)
simulation = generate_random_tree(params,max_time_eq=1,coalescent=FALSE)
tree = simulation$tree
time_span = simulation$final_time - simulation$root_time
cat(sprintf("Generated tree has %d tips, spans %g time units\n",length(tree$tip.label),time_span))

# Calculate diversity time series from the tree
counter = count_lineages_through_time(tree, times=seq(0,0.99*time_span,length.out=100))

# print true diversities
print(counter$lineages)

# reconstruct diversification dynamics based on diversity time series
results = reconstruct_past_diversification( counter$times,
                                            counter$lineages,
                                            birth_rates_pc  = params$birth_rate_factor,
                                            coalescent      = FALSE,
                                            smoothing_span  = 3,
                                            smoothing_order = 1)
                                            
# print coalescent diversities
print(results$coalescent_diversities)
                                                  
# plot coalescent and reconstructed true diversities
matplot(x     = counter$times, 
        y     = matrix(c(results$coalescent_diversities,counter$lineages), ncol=2, byrow=FALSE),
        type  = "b", 
        xlab  = "time", 
        ylab  = "# clades",
        lty   = c(1,2), pch = c(1,0), col = c("red","blue"))
legend( "topleft", 
        legend  = c("coalescent (reconstructed)","true (simulated)"), 
        col     = c("red","blue"), lty = c(1,2), pch = c(1,0));
</code></pre>

<hr>
<h2 id='reorder_tree_edges'>
Reorder tree edges in preorder or postorder.
</h2><span id='topic+reorder_tree_edges'></span>

<h3>Description</h3>

<p>Given a rooted tree, this function reorders the rows in <code>tree$edge</code> so that they are listed in preorder (root&ndash;&gt;tips) or postorder (tips&ndash;&gt;root) traversal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_tree_edges(tree, root_to_tips=TRUE, 
                   depth_first_search=TRUE,
                   index_only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_tree_edges_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="reorder_tree_edges_+3A_root_to_tips">root_to_tips</code></td>
<td>

<p>Logical, specifying whether to sort edges in preorder traversal (root&ndash;&gt;tips), rather than in postorder traversal (tips&ndash;&gt;roots).
</p>
</td></tr>
<tr><td><code id="reorder_tree_edges_+3A_depth_first_search">depth_first_search</code></td>
<td>

<p>Logical, specifying whether the traversal (or the reversed traversal, if <code>root_to_tips</code> is <code>FALSE</code>) should be in depth-first-search format rather than breadth-first-search format.
</p>
</td></tr>
<tr><td><code id="reorder_tree_edges_+3A_index_only">index_only</code></td>
<td>

<p>Whether the function should only return a vector listing the reordered row indices of the edge matrix, rather than a modified tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not change the tree structure, nor does it affect tip/node indices and names. It merely changes the order in which edges are listed in the matrix <code>tree$edge</code>, so that edges are listed in preorder or postorder traversal. Preorder traversal guarantees that each edge is listed before any of its descending edges. Likewise, postorder guarantees that each edge is listed after any of its descending edges.
</p>
<p>With options <code>root_to_tips=TRUE</code> and <code>depth_first_search=TRUE</code>, this function is analogous to the function <code>reorder</code> in the <code>ape</code> package with option <code>order="cladewise"</code>.
</p>
<p>The tree can include multifurcations (nodes with more than 2 children) as well as monofurcations (nodes with 1 child).
This function has asymptotic time complexity O(Nedges).
</p>


<h3>Value</h3>

<p>If <code>index_only==FALSE</code>, a tree object of class &quot;phylo&quot;, with the rows in <code>edge</code> reordered such that they are listed in direction root&ndash;&gt;tips (if <code>root_to_tips==TRUE</code>) or tips&ndash;&gt;root. The vector <code>tree$edge.length</code> will also be updated in correspondence. Tip and node indices and names remain unchanged.
</p>
<p>If <code>index_only=TRUE</code>, an integer vector (X) of size Nedges, listing the reordered row indices of <code>tree$edge</code>, i.e. such that <code>tree$edge[X,]</code> would be the reordered edge matrix.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_tree_traversal_root_to_tips">get_tree_traversal_root_to_tips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_factor=1), max_tips=100)$tree

# get new tree with reordered edges
postorder_tree = reorder_tree_edges(tree, root_to_tips=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='root_at_midpoint'>
Root a tree at the midpoint node.
</h2><span id='topic+root_at_midpoint'></span>

<h3>Description</h3>

<p>Given a tree (rooted or unrooted), this function changes the direction of edges (<code>tree$edge</code>) such that the new root satisfies a &quot;midpoint&quot;&quot; criterion. The number of tips and the number of nodes remain unchanged. The root can either be placed on one of the existing nodes (this node will be the one whose maximum distance to any tip is minimized) or in the middle of one of the existing edges (chosen to be in the middle of the longest path between any two tips).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_at_midpoint( tree, 
                  split_edge      = TRUE,
                  update_indices  = TRUE,
                  as_edge_counts  = FALSE,
                  is_rooted       = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_at_midpoint_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted (but see option <code>is_rooted</code>).
</p>
</td></tr>
<tr><td><code id="root_at_midpoint_+3A_split_edge">split_edge</code></td>
<td>

<p>Logical, specifying whether to place the new root in the middle of an edge (in the middle of the longest path of any two tips), thereby creating a new node. If <code>FALSE</code>, then the root will be placed on one of the existing nodes; note that the resulting tree may no longer be bifurcating at the root.
</p>
</td></tr>
<tr><td><code id="root_at_midpoint_+3A_update_indices">update_indices</code></td>
<td>

<p>Logical, specifying whether to update the node indices such that the new root is the first node in the list, as is common convention. This will modify <code>tree$node.label</code> (if it exists) and also the node indices listed in <code>tree$edge</code>. Note that this option is only relevant if <code>split_edge=FALSE</code>; if <code>split_edge=TRUE</code> then <code>update_indices</code> will always be assumed <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="root_at_midpoint_+3A_as_edge_counts">as_edge_counts</code></td>
<td>

<p>Logical, specifying whether phylogenetic distances should be measured as cumulative edge counts. This is the same if all edges had length 1.
</p>
</td></tr>
<tr><td><code id="root_at_midpoint_+3A_is_rooted">is_rooted</code></td>
<td>

<p>Logical, specifying whether the input tree can be assumed to be rooted. If you are not certain that the tree is rooted, set this to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The midpoint rooting method performs best if the two most distant tips have been sampled at the same time (for example, at the present) and if all lineages in the tree diverged at the same evolutionary rate. If the two most distant tips are sampled at very different times, for example if one or both of them represent extinct species, then the midpoint method is not recommended.
</p>
<p>The input tree may include an arbitrary number of incoming and outgoing edges per node (but only one edge per tip), and the direction of these edges can be arbitrary. Of course, the undirected graph defined by all edges must still be a valid tree. Only set <code>is_rooted=TRUE</code> if you are sure that the input tree is rooted.
</p>
<p>If <code>update_indices==FALSE</code> and <code>split_edge=FALSE</code>, then node indices remain unchanged. If <code>update_indices==TRUE</code> (default) or <code>split_edge=TRUE</code>, then node indices are modified such that the new root is the first node (i.e. with index Ntips+1 in <code>edge</code> and with index 1 in <code>node.label</code>), as is common convention. Setting <code>update_indices=FALSE</code> (when <code>split_edge=FALSE</code>) reduces the computation required for rerooting. Tip indices always remain unchanged.
</p>
<p>The asymptotic time complexity of this function is O(Nedges).
</p>


<h3>Value</h3>

<p>A tree object of class &quot;phylo&quot;, with the <code>edge</code> element modified such that the maximum distance of the root to any tip is minimized. The elements <code>tip.label</code>, <code>edge.length</code> and <code>root.edge</code> (if they exist) are the same as for the input tree. If <code>update_indices==FALSE</code>, then the element <code>node.label</code> will also remain the same.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+root_via_outgroup">root_via_outgroup</a></code>,
<code><a href="#topic+root_at_node">root_at_node</a></code>,
<code><a href="#topic+root_in_edge">root_in_edge</a></code>,
<code><a href="#topic+root_via_rtt">root_via_rtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# reroot the tree at its midpoint node
tree = root_at_midpoint(tree)
</code></pre>

<hr>
<h2 id='root_at_node'>
Root a tree at a specific node.
</h2><span id='topic+root_at_node'></span>

<h3>Description</h3>

<p>Given a tree (rooted or unrooted) and a specific node, this function changes the direction of edges (<code>tree$edge</code>) such that the designated node becomes the root (i.e. has no incoming edges and all other tips and nodes descend from it). The number of tips and the number of nodes remain unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_at_node(tree, new_root_node, update_indices=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_at_node_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted.
</p>
</td></tr>
<tr><td><code id="root_at_node_+3A_new_root_node">new_root_node</code></td>
<td>

<p>Character or integer specifying the name or index, respectively, of the node to be turned into root. If an integer, it must be between 1 and <code>tree$Nnode</code>. If a character, it must be a valid entry in <code>tree$node.label</code>.
</p>
</td></tr>
<tr><td><code id="root_at_node_+3A_update_indices">update_indices</code></td>
<td>

<p>Logical, specifying whether to update the node indices such that the new root is the first node in the list (as is common convention). This will modify <code>tree$node.label</code> (if it exists) and also the node indices listed in <code>tree$edge</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include an arbitrary number of incoming and outgoing edges per node (but only one edge per tip), and the direction of these edges can be arbitrary. Of course, the undirected graph defined by all edges must still be a valid tree.
The asymptotic time complexity of this function is O(Nedges).
</p>
<p>If <code>update_indices==FALSE</code>, then node indices remain unchanged.
If <code>update_indices==TRUE</code> (default), then node indices are modified such that the new root is the first node (i.e. with index Ntips+1 in <code>edge</code> and with index 1 in <code>node.label</code>). This is common convention, but it may be undesirable if, for example, you are looping through all nodes in the tree and are only temporarily designating them as root. Setting <code>update_indices=FALSE</code> also reduces the computation required for rerooting. Tip indices always remain unchanged.
</p>


<h3>Value</h3>

<p>A tree object of class &quot;phylo&quot;, with the <code>edge</code> element modified such that the node <code>new_root_node</code> is root. The elements <code>tip.label</code>, <code>edge.length</code> and <code>root.edge</code> (if they exist) are the same as for the input tree. If <code>update_indices==FALSE</code>, then the element <code>node.label</code> will also remain the same.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+root_via_outgroup">root_via_outgroup</a></code>,
<code><a href="#topic+root_at_midpoint">root_at_midpoint</a></code>,
<code><a href="#topic+root_in_edge">root_in_edge</a></code>,
<code><a href="#topic+root_via_rtt">root_via_rtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# reroot the tree at the 20-th node
new_root_node = 20
tree = root_at_node(tree, new_root_node, update_indices=FALSE)

# find new root index and compare with expectation
cat(sprintf("New root is %d, expected at %d\n",find_root(tree),new_root_node+Ntips))
</code></pre>

<hr>
<h2 id='root_in_edge'>
Root a tree in the middle of an edge.
</h2><span id='topic+root_in_edge'></span>

<h3>Description</h3>

<p>Given a tree (rooted or unrooted), this function places the new root on some specified edge, effectively adding one more node, one more edge and changing the direction of edges as required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_in_edge( tree, 
              root_edge, 
              location                = 0.5,
              new_root_name           = "", 
              collapse_monofurcations = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_in_edge_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted.
</p>
</td></tr>
<tr><td><code id="root_in_edge_+3A_root_edge">root_edge</code></td>
<td>

<p>Integer, index of the edge into which the new root is to be placed. Must be between 1 and Nedges.
</p>
</td></tr>
<tr><td><code id="root_in_edge_+3A_location">location</code></td>
<td>

<p>Numeric, between 0 and 1, specifying the relative location along the <code>root_edge</code> at which to place the root (relative to the edge length, measured from the upstream node). For example, <code>location=0.5</code> means the root is placed in the middle of the edge, while <code>location=0.1</code> means that it will be place closer to the upstream node (i.e., closer to <code>tree$edge[root_edge,1]</code>).
</p>
</td></tr>
<tr><td><code id="root_in_edge_+3A_new_root_name">new_root_name</code></td>
<td>

<p>Character, specifying the node name to use for the new root. Only used if <code>tree$node.label</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="root_in_edge_+3A_collapse_monofurcations">collapse_monofurcations</code></td>
<td>

<p>Logical, specifying whether monofurcations in the rerooted tree (e.g. stemming from the old root) should be collapsed by connecting incoming edges with outgoing edges.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include an arbitrary number of incoming and outgoing edges per node (but only one edge per tip), and the direction of these edges can be arbitrary. Of course, the undirected graph defined by all edges must still be a valid tree.
</p>
<p>The number of tips in the rerooted tree remains unchanged, the number of nodes is increased by 1.
Node indices may be modified. Tip indices always remain unchanged.
</p>
<p>The asymptotic time complexity of this function is O(Nedges).
</p>


<h3>Value</h3>

<p>A tree object of class &quot;phylo&quot;, representing the (re-)rooted phylogenetic tree. The element <code>tip.label</code> is the same as for the input tree, but all other elements may have changed.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+root_via_outgroup">root_via_outgroup</a></code>,
<code><a href="#topic+root_at_node">root_at_node</a></code>,
<code><a href="#topic+root_at_midpoint">root_at_midpoint</a></code>,
<code><a href="#topic+root_via_rtt">root_via_rtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# reroot the tree inside some arbitrary edge
focal_edge = 120
tree = root_in_edge(tree, focal_edge)
</code></pre>

<hr>
<h2 id='root_via_outgroup'>
Root a tree based on an outgroup tip.
</h2><span id='topic+root_via_outgroup'></span>

<h3>Description</h3>

<p>Given a tree (rooted or unrooted) and a specific tip (&ldquo;outgroup&rdquo;), this function changes the direction of edges (<code>tree$edge</code>) such that the outgroup's parent node becomes the root. The number of tips and the number of nodes remain unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_via_outgroup(tree, outgroup, update_indices=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_via_outgroup_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted.
</p>
</td></tr>
<tr><td><code id="root_via_outgroup_+3A_outgroup">outgroup</code></td>
<td>

<p>Character or integer specifying the name or index, respectively, of the outgroup tip. If an integer, it must be between 1 and Ntips. If a character, it must be a valid entry in <code>tree$tip.label</code>.
</p>
</td></tr>
<tr><td><code id="root_via_outgroup_+3A_update_indices">update_indices</code></td>
<td>

<p>Logical, specifying whether to update the node indices such that the new root is the first node in the list (as is common convention). This will modify <code>tree$node.label</code> (if it exists) and also the node indices listed in <code>tree$edge</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include an arbitrary number of incoming and outgoing edges per node (but only one edge per tip), and the direction of these edges can be arbitrary. Of course, the undirected graph defined by all edges must still be a valid tree.
The asymptotic time complexity of this function is O(Nedges).
</p>
<p>If <code>update_indices==FALSE</code>, then node indices remain unchanged.
If <code>update_indices==TRUE</code> (default), then node indices are modified such that the new root is the first node (i.e. with index Ntips+1 in <code>edge</code> and with index 1 in <code>node.label</code>). This is common convention, but it may be undesirable in some cases. Setting <code>update_indices=FALSE</code> also reduces the computation required for rerooting. Tip indices always remain unchanged.
</p>


<h3>Value</h3>

<p>A tree object of class &quot;phylo&quot;, with the <code>edge</code> element modified such that the outgroup tip's parent node is root. The elements <code>tip.label</code>, <code>edge.length</code> and <code>root.edge</code> (if they exist) are the same as for the input tree. If <code>update_indices==FALSE</code>, then the element <code>node.label</code> will also remain the same.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+root_at_node">root_at_node</a></code>,
<code><a href="#topic+root_at_midpoint">root_at_midpoint</a></code>,
<code><a href="#topic+root_in_edge">root_in_edge</a></code>,
<code><a href="#topic+root_via_rtt">root_via_rtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# reroot the tree using the 1st tip as outgroup
outgroup = 1
tree = root_via_outgroup(tree, outgroup, update_indices=FALSE)

# find new root index
cat(sprintf("New root is %d\n",find_root(tree)))
</code></pre>

<hr>
<h2 id='root_via_rtt'>
Root a tree via root-to-tip regression.
</h2><span id='topic+root_via_rtt'></span>

<h3>Description</h3>

<p>Root a non-dated tree based on tip sampling times, by optimizing the goodness of fit of a linear root-to-tip (RTT) regression (regression of tip times vs phylogenetic distances from root). The precise objective optimized can be chosen by the user, typical choices being <code>R2</code> or <code>SSR</code> (sum of squared residuals). This method is only suitable for clades that are &quot;measurably evolving&quot;. The input tree's edge lengths should be measured in substitutions per site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>root_via_rtt(tree,
             tip_times,
             objective           = "R2",
             force_positive_rate = FALSE,
             Nthreads            = 1,
             optim_algorithm     = "nlminb",
             relative_error      = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="root_via_rtt_+3A_tree">tree</code></td>
<td>

<p>A tree object of class &quot;phylo&quot;. Can be unrooted or rooted (the root placement does not matter). Edge lengths should be measured in expected substitutions per site.
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_tip_times">tip_times</code></td>
<td>

<p>Numeric vector of length Ntips, listing the sampling times of all tips. Time is measured in forward direction, i.e., younger tips have a greater time value. Note that if you originally have tip sampling dates, you will first need to convert these to numeric values (for example decimal years or number of days since the start of the experiment).
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_objective">objective</code></td>
<td>

<p>Character, specifying the goodness-of-fit measure to consider for the root-to-tip regression. Must be one of <code>correlation</code>, <code>R2</code> (fraction of explained variance) or <code>SSR</code> (sum of squared residuals).
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_force_positive_rate">force_positive_rate</code></td>
<td>

<p>Logical, whether to force the mutation rate implied by the root placement to be positive (&gt;=0).
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_nthreads">Nthreads</code></td>
<td>

<p>Integer, number of parallel threads to use where applicable.
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_optim_algorithm">optim_algorithm</code></td>
<td>

<p>Character, the optimization algorithm to use. Must be either <code>nlminb</code> or <code>optimize</code>.
</p>
</td></tr>
<tr><td><code id="root_via_rtt_+3A_relative_error">relative_error</code></td>
<td>

<p>Positive numeric, specifying the acceptable relative error when optimizing the goodness of fit. The precise interpretation depends on the optimization algorithm used. Smaller values may increase accuracy but also computing time.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements (more may be added in the future):
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>The rooted tree. A tree object of class &quot;phylo&quot;, with the same tips as the original tree (not necessarily in the original order).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+root_via_outgroup">root_via_outgroup</a></code>,
<code><a href="#topic+root_at_node">root_at_node</a></code>,
<code><a href="#topic+root_in_edge">root_in_edge</a></code>
<code><a href="#topic+root_at_midpoint">root_at_midpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 10
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=Ntips)$tree

# construct a vector with hypothetical tip sampling times
tip_times = c(2010.5, 2010.7, 2011.3, 2008.7,
              2009.1, 2013.9, 2013.8, 2011.4,
              2011.7, 2005.2)

# reroot the tree via root-to-tip regression
tree = root_via_rtt(tree, tip_times=tip_times)
</code></pre>

<hr>
<h2 id='shift_clade_times'>
Shift the time of specific nodes &amp; tips.
</h2><span id='topic+shift_clade_times'></span>

<h3>Description</h3>

<p>Given a rooted tree, shift the times (distance from root) of specific tips &amp; nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_clade_times(  tree,
                    clades_to_shift,
                    time_shifts,
                    shift_descendants       = FALSE,
                    negative_edge_lengths   = "error")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_clade_times_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="shift_clade_times_+3A_clades_to_shift">clades_to_shift</code></td>
<td>

<p>Integer or character vector, listing the tips and/or nodes whose time is to be shifted. If an integer vector, values must correspond to indices and must be in the range 1,..,Ntips+Nnodes. If a character vector, values must correspond to tip and/or node labels in the tree; if node labels are listed, the tree must contain node labels (attribute <code>node.label</code>).
</p>
</td></tr>
<tr><td><code id="shift_clade_times_+3A_time_shifts">time_shifts</code></td>
<td>

<p>Numeric vector of the same length as <code>clades_to_shift</code>, specifying the time shifts to apply to every tip/node listed in <code>clades_to_shift</code>. Values can be negative (shift towards the root) or positive (shift away from the root).
</p>
</td></tr>
<tr><td><code id="shift_clade_times_+3A_shift_descendants">shift_descendants</code></td>
<td>

<p>Logical, specifying whether to shift the entire descending subclade when shifting a node. If <code>FALSE</code>, the descending tips &amp; nodes retain their original time (unless negative edges are created, see option <code>negative_edge_lengths</code>).
</p>
</td></tr>
<tr><td><code id="shift_clade_times_+3A_negative_edge_lengths">negative_edge_lengths</code></td>
<td>

<p>Character, specifying whether and how to fix negative edge lengths resulting from excessive shifting. Must be either &quot;<code>error</code>&quot;, &quot;<code>allow</code>&quot; (allow and don't fix negative edge lengths), &quot;<code>move_all_descendants</code>&quot; (move all descendants forward as needed, to make the edge non-negative), &quot;<code>move_all_ancestors</code>&quot; (move all ancestors backward as needed, to make the edge non-negative), &quot;<code>move_child</code>&quot; (only move children to younger ages as needed, traversing the tree root-&gt;tips) or &quot;<code>move_parent</code>&quot; (only move parents to older ages as needed, traversing the tree tips-&gt;root). Note that &quot;<code>move_child</code>&quot; could result in tips moving, if an ancestral node is shifted too much towards younger ages. Similarly, &quot;<code>move_parent</code>&quot; could result in the root moving towards an older age if some descendant was shifted too far towards the root.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The input tree does not need to be ultrametric, but edge lengths are interpreted as time. If edge lengths are missing from the tree, it is assumed that each edge has length 1.
</p>
<p>All tips, nodes and edges are kept and indexed as in the input tree; the only thing that changes are the edgen lengths.
</p>
<p>Note that excessive shifting can result in negative edge lengths, which can be corrected in a variety of alternative ways (see option <code>negative_edge_lengths</code>). However, to avoid changing the overall span of the tree (root age and tip times) in an effort to fix negative edge lengths, you should generally not shift a clade beyond the boundaries of the tree (i.e., resulting in a negative time or a time beyond its descending tips).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, specifying whether the operation was successful. If <code>FALSE</code>, an additional variable <code>error</code> is returned, briefly specifying the error, but all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, representing the tree with shifted clade times.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_all_distances_to_root">get_all_distances_to_root</a></code>,
<code><a href="#topic+trim_tree_at_height">trim_tree_at_height</a></code>,
<code><a href="#topic+get_tree_span">get_tree_span</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree, include node names
tree = generate_random_tree(list(birth_rate_intercept=1),
                            max_tips=20,
                            node_basename="node.")$tree

# shift a few nodes backward in time,
# changing as few of the remaining node timings as possible
clades_to_shift = c("node.2",   "node.5",   "node.6")
time_shifts     = c(-0.5,       -0.2,       -0.3)
new_tree        = shift_clade_times(tree, 
                                    clades_to_shift, 
                                    time_shifts,
                                    shift_descendants=FALSE,
                                    negative_edge_lengths="move_parent")$tree
</code></pre>

<hr>
<h2 id='simulate_bm_model'>
Simulate a Brownian motion model for multivariate trait co-evolution.
</h2><span id='topic+simulate_bm_model'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a Brownian motion (BM) model for the co-evolution of one or more continuous (numeric) unbounded traits, simulate random outcomes of the model on all nodes and/or tips of the tree. The function traverses nodes from root to tips and randomly assigns a multivariate state to each node or tip based on its parent's previously assigned state and the specified model parameters. The generated states have joint distributions consistent with the multivariate BM model. Optionally, multiple independent simulations can be performed using the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_bm_model(tree, diffusivity=NULL, sigma=NULL,
                  include_tips=TRUE, include_nodes=TRUE, 
                  root_states=NULL, Nsimulations=1, drop_dims=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_bm_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_diffusivity">diffusivity</code></td>
<td>

<p>Either NULL, or a single number, or a 2D quadratic positive definite symmetric matrix of size Ntraits x Ntraits. Diffusivity matrix (&quot;<code class="reqn">D</code>&quot;) of the multivariate Brownian motion model (in units trait^2/edge_length). The convention is that if the root's state is fixed, then the covariance matrix of a node's state at distance <code class="reqn">L</code> from the root will be <code class="reqn">2LD</code> (see mathematical details below).
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_sigma">sigma</code></td>
<td>

<p>Either NULL, or a single number, or a 2D matrix of size Ntraits x Ndegrees, where Ndegrees refers to the degrees of freedom of the model. Noise-amplitude coefficients of the multivariate Brownian motion model (in units trait/sqrt(edge_length)). This can be used as an alternative way to specify the Brownian motion model instead of through the diffusivity <code class="reqn">D</code>. Note that <code class="reqn">sigma\cdot\sigma^T=2D</code> (see mathematical details below).
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_include_tips">include_tips</code></td>
<td>

<p>Include random states for the tips. If <code>FALSE</code>, no states will be returned for tips.
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_include_nodes">include_nodes</code></td>
<td>

<p>Include random states for the nodes. If <code>FALSE</code>, no states will be returned for nodes.
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_root_states">root_states</code></td>
<td>

<p>Numeric matrix of size NR x Ntraits (where NR can be arbitrary), specifying the state of the root for each simulation. If NR is smaller than <code>Nsimulations</code>, values in <code>root_states</code> are recycled in rotation. If <code>root_states</code> is <code>NULL</code> or empty, then the root state is set to 0 for all traits in all simulations.
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_nsimulations">Nsimulations</code></td>
<td>

<p>Number of random independent simulations to perform. For each node and/or tip, there will be <code>Nsimulations</code> random states generated.
</p>
</td></tr>
<tr><td><code id="simulate_bm_model_+3A_drop_dims">drop_dims</code></td>
<td>

<p>Logical, specifying whether singleton dimensions should be dropped from <code>tip_states</code> and <code>node_states</code>, if <code>Nsimulations==1</code> and/or Ntraits==1. If <code>drop_dims==FALSE</code>, then <code>tip_states</code> and <code>tip_nodes</code> will always be 3D matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BM model for Ntraits co-evolving traits is defined by the stochastic differential equation
</p>
<p style="text-align: center;"><code class="reqn">
dX = \sigma \cdot dW
</code>
</p>

<p>where <code class="reqn">W</code> is a multidimensional Wiener process with Ndegrees independent components and <code class="reqn">\sigma</code> is a matrix of size Ntraits x Ndegrees. Alternatively, the same model can be defined as a Fokker-Planck equation for the probability density <code class="reqn">\rho</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{\partial \rho}{\partial t} = \sum_{i,j}D_{ij}\frac{\partial^2\rho}{\partial x_i\partial x_j}.
</code>
</p>

<p>The matrix <code class="reqn">D</code> is referred to as the diffusivity matrix (or diffusion tensor), and <code class="reqn">2D=\sigma\cdot\sigma^T</code>. Either <code>diffusivity</code> (<code class="reqn">D</code>) or <code>sigma</code> (<code class="reqn">\sigma</code>) may be used to specify the BM model, but not both.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The asymptotic time complexity of this function is O(Nedges*Nsimulations*Ntraits).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tip_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_tips==FALSE</code>), or a 3D numeric matrix of size Nsimulations x Ntips x Ntraits. The [r,c,i]-th entry of this matrix will be the state of trait i at tip c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code> and Ntraits==1, then <code>tip_states</code> will be a vector.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_nodes==FALSE</code>), or a 3D numeric matrix of size Nsimulations x Nnodes x Ntraits. The [r,c,i]-th entry of this matrix will be the state of trait i at node c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code> and Ntraits==1, then <code>node_states</code> will be a vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>, 
<code><a href="#topic+simulate_rou_model">simulate_rou_model</a></code>,
<code><a href="#topic+simulate_mk_model">simulate_mk_model</a></code>,
<code><a href="#topic+fit_bm_model">fit_bm_model</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=10000)$tree

# Example 1: Scalar case
# - - - - - - - - - - - - - - -
# simulate scalar continuous trait evolution on the tree
tip_states = simulate_bm_model(tree, diffusivity=1)$tip_states

# plot histogram of simulated tip states
hist(tip_states, breaks=20, xlab="state", main="Trait probability distribution", prob=TRUE)

# Example 2: Multivariate case
# - - - - - - - - - - - - - - -
# simulate co-evolution of 2 traits with 3 degrees of freedom
Ntraits  = 2
Ndegrees = 3
sigma    = matrix(stats::rnorm(n=Ntraits*Ndegrees, mean=0, sd=1), ncol=Ndegrees)
tip_states = simulate_bm_model(tree, sigma=sigma, drop_dims=TRUE)$tip_states

# generate scatterplot of traits across tips
plot(tip_states[,1],tip_states[,2],xlab="trait 1",ylab="trait 2",cex=0.5)
</code></pre>

<hr>
<h2 id='simulate_deterministic_hbd'>
Simulate a deterministic homogenous birth-death model.
</h2><span id='topic+simulate_deterministic_hbd'></span>

<h3>Description</h3>

<p>Given a homogenous birth-death (HBD) model, i.e., with speciation rate <code class="reqn">\lambda</code>, extinction rate <code class="reqn">\mu</code> and sampling fraction <code class="reqn">\rho</code>, calculate various deterministic features of the model backwards in time, such as the total diversity over time. The speciation and extinction rates may be time-dependent. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction rates (in the literature this is sometimes referred to simply as &ldquo;birth-death model&rdquo;; Morlon et al. 2011). &ldquo;Deterministic&rdquo; refers to the fact that all calculated properties are completely determined by the model's parameters (i.e. non-random), as if an infinitely large tree was generated (aka. &ldquo;continuum limit&rdquo;).
</p>
<p>Alternatively to <code class="reqn">\lambda</code>, one may provide the pulled diversification rate (PDR; Louca et al. 2018) and the speciation rate at some fixed age, <code class="reqn">\lambda(\tau_o)</code>. Similarly, alternatively to <code class="reqn">\mu</code>, one may provide the ratio of extinction over speciation rate, <code class="reqn">\mu/\lambda</code>. In either case, the time-profiles of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\mu/\lambda</code> or the PDR are specified as piecewise polynomial functions (splines), defined on a discrete grid of ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_deterministic_hbd(LTT0,
                           oldest_age,
                           age0           = 0,
                           rho0           = 1,
                           age_grid       = NULL,
                           lambda         = NULL,
                           mu             = NULL,
                           mu_over_lambda = NULL,
                           PDR            = NULL,
                           lambda0        = NULL,
                           splines_degree = 1,
                           relative_dt    = 1e-3,
                           allow_unreal   = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_deterministic_hbd_+3A_ltt0">LTT0</code></td>
<td>

<p>The assumed number of sampled extant lineages at <code>age0</code>, defining the necessary initial condition for the simulation. If the HBD model is supposed to describe a specific timetree, then <code>LTT0</code> should correspond to the number of lineages in the tree (&quot;lineages through time&quot;) at age <code>age0</code>.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_oldest_age">oldest_age</code></td>
<td>

<p>Strictly positive numeric, specifying the oldest time before present (&ldquo;age&rdquo;) to include in the simulation.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the age at which <code>LTT0</code>, <code>lambda0</code> and <code>rho</code> are given. Typically this will be 0, i.e., corresponding to the present.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_rho0">rho0</code></td>
<td>

<p>Numeric between 0 (exclusive) and 1 (inclusive), specifying the sampling fraction of the tree at <code>age0</code>, i.e. the fraction of lineages extant at <code>age0</code> that are included in the tree (aka. &quot;rarefaction&quot;). Note that if <code>rho0&lt;1</code>, lineages extant at <code>age0</code> are assumed to have been sampled randomly at equal probabilities. Can also be <code>NULL</code>, in which case <code>rho0=1</code> is assumed.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing discrete ages (time before present) on which either <code class="reqn">\lambda</code> and <code class="reqn">\mu</code>, or the PDR and <code class="reqn">\mu</code>, are specified. Listed ages must be strictly increasing, and must cover at least the full considered age interval (from <code>age0</code> to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the speciation rate, extinction rate and PDR are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing speciation rates (<code class="reqn">\lambda</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Speciation rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then <code>PDR</code> and <code>lambda0</code> must be provided.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing extinction rates (<code class="reqn">\mu</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Extinction rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Either <code>mu</code> or <code>mu_over_lambda</code> must be provided, but not both.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_mu_over_lambda">mu_over_lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing the ratio of extinction rates over speciation rates (<code class="reqn">\mu/\lambda</code>) at the ages listed in <code>age_grid</code>. These ratios should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). Either <code>mu</code> or <code>mu_over_lambda</code> must be provided, but not both.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_pdr">PDR</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing pulled diversification rates (in units 1/time) at the ages listed in <code>age_grid</code>. PDRs can be negative or positive, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). If <code>NULL</code>, then <code>lambda</code> must be provided.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_lambda0">lambda0</code></td>
<td>

<p>Non-negative numeric, specifying the speciation rate (in units 1/time) at <code>age0</code>. Either <code>lambda0</code> or <code>lambda</code> must be provided, but not both.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided <code>lambda</code>, <code>mu</code> and <code>PDR</code> between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided <code>lambda</code>, <code>mu</code> and <code>PDR</code> are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> they are interpreted as quadratic splines; if <code>splines_degree==3</code> they are interpreted as cubic splines. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_relative_dt">relative_dt</code></td>
<td>

<p>Strictly positive numeric (unitless), specifying the maximum relative time step allowed for integration over time. Smaller values increase integration accuracy but increase computation time. Typical values are 0.0001-0.001. The default is usually sufficient.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbd_+3A_allow_unreal">allow_unreal</code></td>
<td>

<p>Logical, specifying whether HBD models with unrealistic parameters (e.g., negative <code class="reqn">\mu</code>) should be supported. This may be desired for example when examining model congruence classes with negative <code class="reqn">\mu</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supports the following alternative parameterizations of HBD models:
</p>

<ul>
<li><p> Using the speciation rate <code class="reqn">\lambda</code> and extinction rate <code class="reqn">\mu</code>.
</p>
</li>
<li><p> Using the speciation rate <code class="reqn">\lambda</code> and the ratio <code class="reqn">\mu/\lambda</code>.
</p>
</li>
<li><p> Using the pulled diversification rate (PDR), the extinction rate and the speciation rate given at some fixed <code>age0</code> (i.e. <code>lambda0</code>).
</p>
</li>
<li><p> Using the PDR, the ratio <code class="reqn">\mu/\lambda</code> and the speciation rate at some fixed <code>age0</code>.
</p>
</li></ul>

<p>The PDR is defined as <code class="reqn">PDR = \lambda-\mu+\lambda^{-1}d\lambda/d\tau</code>, where <code class="reqn">\tau</code> is age (time before present). To avoid ambiguities, only one of the above parameterizations is accepted at a time. The sampling fraction at <code>age0</code> (i.e., <code>rho0</code>) should always be provided; setting it to <code>NULL</code> is equivalent to setting it to 1.
</p>
<p>Note that in the literature the sampling fraction usually refers to the fraction of lineages extant at present-day that have been sampled (included in the tree); this present-day sampling fraction is then used to parameterize birth-death cladogenic models. The sampling fraction can however be generalized to past times, by defining it as the probability that a lineage extant at any given time is included in the tree. The simulation function presented here allows for specifying this generalized sampling fraction at any age of choice, not just present-day.
</p>
<p>The simulated LTT refers to a hypothetical tree sampled at age <code>age_grid[1]</code>, i.e. LTT(t) will be the number of lineages extant at age t that survived until age <code>age_grid[1]</code> and have been sampled, given that the fraction of sampled extant lineages at <code>age0</code> is <code>rho0</code>. Similarly, the returned Pextinct(t) (see below) is the probability that a lineage extant at age t would not survive until <code>age_grid[1]</code>. The same convention is used for the returned variables <code>Pmissing</code>, <code>shadow_diversity</code>, <code>PER</code>, <code>PSR</code>, <code>SER</code> and <code>PND</code>.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the calculation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) providing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>
<p>Numerical vector of size NG, listing discrete ages (time before present) on which all returned time-curves are specified. Listed ages will be in ascending order, will cover exactly the range <code>age_grid[1]</code> - <code>oldest_age</code>, may be irregularly spaced, and may be finer than the original provided <code>age_grid</code>. Note that <code>ages[1]</code> corresponds to the latest time point (closer to the tips), while <code>ages[NG]</code> corresponds to the oldest time point (<code>oldest_age</code>).</p>
</td></tr>
<tr><td><code>total_diversity</code></td>
<td>
<p>Numerical vector of size NG, listing the predicted (deterministic) total diversity (number of extant species, denoted <code class="reqn">N</code>) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>shadow_diversity</code></td>
<td>
<p>Numerical vector of size NG, listing the predicted (deterministic) &ldquo;shadow diversity&rdquo; at the ages given in <code>ages[]</code>. The shadow diversity is defined as <code class="reqn">N_s=N\cdot \rho(\tau_o)\lambda(\tau_o)/\lambda</code>, where <code class="reqn">\tau_o</code> is <code>age0</code>.</p>
</td></tr>
<tr><td><code>Pmissing</code></td>
<td>
<p>Numeric vector of size NG, listing the probability that a lineage, extant at a given age, will be absent from the tree either due to extinction or due to incomplete sampling.</p>
</td></tr>
<tr><td><code>Pextinct</code></td>
<td>
<p>Numeric vector of size NG, listing the probability that a lineage, extant at a given age, will be fully extinct at present. Note that always <code>Pextinct&lt;=Pmissing</code>.</p>
</td></tr>
<tr><td><code>LTT</code></td>
<td>
<p>Numeric vector of size NG, listing the number of lineages represented in the tree at any given age, also known as &ldquo;lineages-through-time&rdquo; (LTT) curve. Note that <code>LTT</code> at <code>age0</code> will be equal to <code>LTT</code>, and that values in <code>LTT</code> will be non-increasing with age.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Numeric vector of size NG, listing the speciation rate (in units 1/time) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Numeric vector of size NG, listing the extinction rate (in units 1/time) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>diversification_rate</code></td>
<td>
<p>Numeric vector of size NG, listing the net diversification rate (<code class="reqn">\lambda-\mu</code>) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>PDR</code></td>
<td>
<p>Numeric vector of size NG, listing the pulled diversification rate (PDR, in units 1/time) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>PND</code></td>
<td>
<p>Numeric vector of size NG, listing the pulled normalized diversity (PND, in units 1/time) at the ages given in <code>ages[]</code>. The PND is defined as <code class="reqn">PND=(N/N(\tau_o))\cdot\lambda(\tau_o)/\lambda</code>.</p>
</td></tr>
<tr><td><code>SER</code></td>
<td>
<p>Numeric vector of size NG, listing the &ldquo;shadow extinction rate&rdquo; (SER, in units 1/time) at the ages given in <code>ages[]</code>. The SER is defined as <code class="reqn">SER=\rho(\tau_o)\lambda(\tau_o)-PDR</code>.</p>
</td></tr>
<tr><td><code>PER</code></td>
<td>
<p>Numeric vector of size NG, listing the &ldquo;pulled extinction rate&rdquo; (PER, in units 1/time) at the ages given in <code>ages[]</code>. The PER is defined as <code class="reqn">SER=\lambda(\tau_o)-PDR</code> (Louca et al. 2018).</p>
</td></tr>
<tr><td><code>PSR</code></td>
<td>
<p>Numeric vector of size NG, listing the &ldquo;pulled speciation rate&rdquo; (PSR, in units 1/time) at the ages given in <code>ages[]</code>. The PSR is defined as <code class="reqn">PSR=\lambda\cdot(1-Pmissing)</code>.</p>
</td></tr>
<tr><td><code>rholambda0</code></td>
<td>
<p>Non-negative numeric, specifying the product of the sampling fraction and the speciation rate at <code>age0</code>, <code class="reqn">\rho\cdot\lambda(\tau_o)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>H. Morlon, T. L. Parsons, J. B. Plotkin (2011). Reconciling molecular phylogenies with the fossil record. Proceedings of the National Academy of Sciences. 108:16327-16332.
</p>
<p>S. Louca et al. (2018). Bacterial diversification through geological time. Nature Ecology &amp; Evolution. 2:1458-1467.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood_hbd">loglikelihood_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an HBD model with exponentially decreasing speciation/extinction rates
Ntips     = 1000
beta      = 0.01 # exponential decay rate of lambda over time
oldest_age= 10
age_grid  = seq(from=0,to=oldest_age,by=0.1) # choose a sufficiently fine age grid
lambda    = 1*exp(beta*age_grid) # define lambda on the age grid
mu        = 0.2*lambda # assume similarly shaped but smaller mu

# simulate deterministic HBD model
simulation = simulate_deterministic_hbd(LTT0       = Ntips, 
                                        oldest_age = oldest_age, 
                                        rho0       = 0.5,
                                        age_grid   = age_grid,
                                        lambda     = lambda,
                                        mu         = mu)

# plot deterministic LTT
plot( x = simulation$ages, y = simulation$LTT, type='l',
      main='dLTT', xlab='age', ylab='lineages')
</code></pre>

<hr>
<h2 id='simulate_deterministic_hbds'>
Simulate a deterministic homogenous birth-death-sampling model.
</h2><span id='topic+simulate_deterministic_hbds'></span>

<h3>Description</h3>

<p>Given a homogenous birth-death-sampling (HBDS) model, i.e., with speciation rate <code class="reqn">\lambda</code>, extinction rate <code class="reqn">\mu</code>, continuous (Poissonian) sampling rate <code class="reqn">\psi</code> and retention probability <code class="reqn">\kappa</code>, calculate various deterministic features of the model backwards in time, such as the total population size and the LTT over time.
Continuously sampled lineages are kept in the pool of extant lineages at probability <code class="reqn">\kappa</code>. The variables <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> may depend on time.
In addition, the model can include concentrated sampling attempts at a finite set of discrete time points <code class="reqn">t_1,..,t_m</code>. &ldquo;Homogenous&rdquo; refers to the assumption that, at any given moment in time, all lineages exhibit the same speciation/extinction/sampling rates and retention proabbility. Every HBDS model is thus defined based on the values that <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> take over time, as well as the sampling probabilities <code class="reqn">\psi_1,..,\psi_m</code> and retention probabilities <code class="reqn">\kappa_1,..,\kappa_m</code> during the concentrated sampling attempts. Special cases of this model are sometimes known as &ldquo;birth-death-skyline plots&rdquo; in the literature (Stadler 2013). In epidemiology, these models are often used to describe the phylogenies of viral strains sampled over the course of the epidemic. A &ldquo;concentrated sampling attempt&rdquo; is a brief but intensified sampling period that lasted much less than the typical timescales of speciation/extinction. &ldquo;Deterministic&rdquo; refers to the fact that all calculated properties are completely determined by the model's parameters (i.e. non-random), as if an infinitely large tree was generated (aka. &ldquo;continuum limit&rdquo;).
The time-profiles of <code class="reqn">\lambda</code>, <code class="reqn">\mu</code>, <code class="reqn">\psi</code> and <code class="reqn">\kappa</code> are specified as piecewise polynomial curves (splines), defined on a discrete grid of ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_deterministic_hbds(age_grid                        = NULL,
                            lambda                          = NULL,
                            mu                              = NULL,
                            psi                             = NULL,
                            kappa                           = NULL,
                            splines_degree                  = 1,
                            CSA_ages                        = NULL,
                            CSA_probs                       = NULL,
                            CSA_kappas                      = NULL,
                            requested_ages                  = NULL,
                            age0                            = 0,
                            N0                              = NULL,
                            LTT0                            = NULL,
                            ODE_relative_dt                 = 0.001,
                            ODE_relative_dy                 = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_deterministic_hbds_+3A_age_grid">age_grid</code></td>
<td>

<p>Numeric vector, listing discrete ages (time before present) on which either <code class="reqn">\lambda</code> and <code class="reqn">\mu</code>, or the PDR and <code class="reqn">\mu</code>, are specified. Listed ages must be strictly increasing, and must cover at least the full considered age interval (from <code>age0</code> to <code>oldest_age</code>). Can also be <code>NULL</code> or a vector of size 1, in which case the speciation rate, extinction rate and PDR are assumed to be time-independent.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing speciation rates (<code class="reqn">\lambda</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Speciation rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>).
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_mu">mu</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing extinction rates (<code class="reqn">\mu</code>, in units 1/time) at the ages listed in <code>age_grid</code>. Extinction rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>).
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_psi">psi</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing the continuous (Poissonian) sampling rate at the ages listed in <code>age_grid</code>. Sampling rates should be non-negative, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>).
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_kappa">kappa</code></td>
<td>

<p>Numeric vector, of the same size as <code>age_grid</code> (or size 1 if <code>age_grid==NULL</code>), listing the retention probabilities following Poissonian sampling events, at the ages listed in <code>age_grid</code>. The listed values must be true probabilities, i.e. between 0 and 1, and are assumed to vary polynomially between grid points (see argument <code>splines_degree</code>). The retention probability is the probability that a continuously sampled lineage remains in the pool of extant lineages. Note that many epidemiological models assume kappa to be zero.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> between grid points in <code>age_grid</code>. For example, if <code>splines_degree==1</code>, then the provided <code>lambda</code>, <code>mu</code>, <code>psi</code> and <code>kappa</code> are interpreted as piecewise-linear curves; if <code>splines_degree==2</code> they are interpreted as quadratic splines; if <code>splines_degree==3</code> they are interpreted as cubic splines. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_csa_ages">CSA_ages</code></td>
<td>

<p>Optional numeric vector, listing the ages of concentrated sampling attempts, in ascending order. Concentrated sampling is performed in addition to any continuous (Poissonian) sampling specified by <code>psi</code>.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_csa_probs">CSA_probs</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_ages</code>, listing sampling probabilities at each concentrated sampling attempt. Note that in contrast to the sampling rates <code>psi</code>, the <code>CSA_probs</code> are interpreted as probabilities and must thus be between 0 and 1. <code>CSA_probs</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_csa_kappas">CSA_kappas</code></td>
<td>

<p>Optional numeric vector of the same size as <code>CSA_ages</code>, listing retention probabilities at each concentrated sampling event, i.e. the probability at which a sampled lineage is kept in the pool of extant lineages. Note that the <code>CSA_kappas</code> are probabilities and must thus be between 0 and 1. <code>CSA_kappas</code> must be provided if and only if <code>CSA_ages</code> is provided.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_requested_ages">requested_ages</code></td>
<td>

<p>Optional numeric vector, listing ages (in ascending order) at which the various model variables are requested. If <code>NULL</code>, it will be set to <code>age_grid</code>.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_age0">age0</code></td>
<td>

<p>Non-negative numeric, specifying the age at which <code>LTT0</code> and <code>pop_size0</code> are specified. Typically this will be 0, i.e., corresponding to the present.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_n0">N0</code></td>
<td>

<p>Positive numeric, specifying the number of extant species (sampled or not) at <code>age0</code>. Used to determine the &quot;scaling factor&quot; for the returned population sizes and LTT. Either <code>pop_size0</code> or <code>LTT0</code> must be provided, but not both.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_ltt0">LTT0</code></td>
<td>

<p>Positive numeric, specifying the number of lineages present in the tree at <code>age0</code>. Used to determine the &quot;scaling factor&quot; for the returned population sizes and LTT. Either <code>pop_size0</code> or <code>LTT0</code> must be provided, but not both.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_ode_relative_dt">ODE_relative_dt</code></td>
<td>

<p>Positive unitless number, specifying the default relative time step for internally used ordinary differential equation solvers. Typical values are 0.01-0.001.
</p>
</td></tr>
<tr><td><code id="simulate_deterministic_hbds_+3A_ode_relative_dy">ODE_relative_dy</code></td>
<td>

<p>Positive unitless number, specifying the relative difference between subsequent simulated and interpolated values, in internally used ODE solvers. Typical values are 1e-2 to 1e-5. A smaller <code>ODE_relative_dy</code> increases interpolation accuracy, but also increases memory requirements and adds runtime (scaling with the tree's age span, not with Ntips).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulated LTT refers to a hypothetical tree sampled at age 0, i.e. LTT(t) will be the number of lineages extant at age t that survived and were sampled until by the present day. Note that if a concentrated sampling attempt occurs at age <code class="reqn">\tau</code>, then LTT(<code class="reqn">\tau</code>) is the number of lineages in the tree right before the occurrence of the sampling attempt, i.e., in the limit where <code class="reqn">\tau</code> is approached from above.
</p>
<p>Note that in this function age always refers to time before present, i.e., present day age is 0, and age increases towards the root.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the calculation was successful. If <code>FALSE</code>, then the returned list includes an additional '<code>error</code>' element (character) providing a description of the error; all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>
<p>Numerical vector of size NG, listing discrete ages (time before present) on which all returned time-curves are specified. Will be equal to <code>requested_ages</code>, if the latter was provided.
</p>
</td></tr>
<tr><td><code>total_diversity</code></td>
<td>
<p>Numerical vector of size NG, listing the predicted (deterministic) total diversity (number of extant species, denoted <code class="reqn">N</code>) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>LTT</code></td>
<td>
<p>Numeric vector of size NG, listing the number of lineages represented in the tree at any given age, also known as &ldquo;lineages-through-time&rdquo; (LTT) curve. Note that <code>LTT</code> at <code>age0</code> will be equal to <code>LTT0</code> (if the latter was provided).
</p>
</td></tr>
<tr><td><code>nLTT</code></td>
<td>
<p>Numeric vector of size NG, listing values of the normalized LTT at ages <code>ages[]</code>. The nLTT is calculated by dividing the LTT by its area-under-the-curve (AUC). The AUC is calculated by integrating the LTT over the time spanned by <code>ages</code> and using the trapezoid rule. Hence, the exact value of the AUC and of the nLTT depends on the span and resolution of <code>ages[]</code>. If you want the AUC to accurately refer to the entire area under the curve (i.e. across the full real axis), you should specify a sufficiently wide and sufficiently fine age grid (e.g., via <code>requested_ages</code>).
</p>
</td></tr>
<tr><td><code>Pmissing</code></td>
<td>
<p>Numeric vector of size NG, listing the probability that a lineage, extant at a given age, will not be represented in the tree.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>Numeric vector of size NG, listing the speciation rates at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>Numeric vector of size NG, listing the extinctions rates at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>Numeric vector of size NG, listing the Poissonian sampling rates at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>

<p>Numeric vector of size NG, listing the retention probabilities (for continuously sampled lineages) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>PDR</code></td>
<td>
<p>Numeric vector of size NG, listing the pulled diversification rate (PDR, in units 1/time) at the ages given in <code>ages[]</code>.</p>
</td></tr>
<tr><td><code>IPRP</code></td>
<td>
<p>Numeric vector of size NG, listing the age-integrated pulled diversification rate at the ages given in <code>ages[]</code>, i.e. <code class="reqn">IPDR(t)=\int_0^t PDR(s)ds</code>.</p>
</td></tr>
<tr><td><code>PSR</code></td>
<td>
<p>Numeric vector of size NG, listing the &ldquo;pulled speciation rate&rdquo; (PSR, in units 1/time) at the ages given in <code>ages[]</code>. The PSR is defined as <code class="reqn">PSR=\lambda\cdot(1-Pmissing)</code>.</p>
</td></tr>
<tr><td><code>PRP</code></td>
<td>
<p>Numeric vector of size NG, listing the &ldquo;pulled retention probability&rdquo; (PRP) at the ages given in <code>ages[]</code>. The PRP is defined as <code class="reqn">PRP=\kappa\cdot(1-Pmissing)</code>.</p>
</td></tr>
<tr><td><code>diversification_rate</code></td>
<td>

<p>Numeric vector of size NG, listing the net diversification rate (in units 1/time) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>branching_density</code></td>
<td>

<p>Numeric vector of size NG, listing the deterministic branching density (PSR * nLTT, in units nodes/time) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>sampling_density</code></td>
<td>

<p>Numeric vector of size NG, listing the deterministic sampling density (<code class="reqn">\psi\cdot N/AUC</code>, in units tips/time, where AUC is the area-under-the-curve calculated for the LTT) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>lambda_psi</code></td>
<td>

<p>Numeric vector of size NG, listing the product of the speciation rate and Poissonian sampling rate (in units 1/time^2) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>kappa_psi</code></td>
<td>

<p>Numeric vector of size NG, listing the product of the continuous sampling rate and the continuous retention probability (in units 1/time) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>Reff</code></td>
<td>

<p>Numeric vector of size NG, listing the effective reproduction ratio (<code class="reqn">R_e=\lambda/(\mu+\psi(1-\kappa))</code>) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>removal_rate</code></td>
<td>

<p>Numeric vector of size NG, listing the total removal rate (<code class="reqn">\mu+\psi</code>), also known as &ldquo;become uninfectious rate&rdquo;, at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>sampling_proportion</code></td>
<td>

<p>Numeric vector of size NG, listing the instantaneous sampling proportion (<code class="reqn">\psi/(\mu+\psi)</code>) at the ages given in <code>ages[]</code>.
</p>
</td></tr>
<tr><td><code>CSA_pulled_probs</code></td>
<td>

<p>Numeric vector of size NG, listing the pulled concentrated sampling probabilities, <code class="reqn">\tilde{\rho}_k=\rho_k/(1-E)</code>.
</p>
</td></tr>
<tr><td><code>CSA_psis</code></td>
<td>

<p>Numeric vector of size NG, listing the continuous (Poissonian) sampling rates during the concentrated sampling attempts, <code class="reqn">\psi(t_1),..,\psi(t_m)</code>.
</p>
</td></tr>
<tr><td><code>CSA_PSRs</code></td>
<td>

<p>Numeric vector of size NG, listing the pulled speciation rates during the concentrated sampling attempts.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>T. Stadler, D. Kuehnert, S. Bonhoeffer, A. J. Drummond (2013). Birth-death skyline plot reveals temporal changes of epidemic spread in HIV and hepatitis C virus (HCV). PNAS. 110:228-233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_tree_hbds">generate_tree_hbds</a></code>,
<code><a href="#topic+fit_hbds_model_parametric">fit_hbds_model_parametric</a></code>,
<code><a href="#topic+simulate_deterministic_hbd">simulate_deterministic_hbd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an HBDS model with exponentially decreasing speciation/extinction rates
# and constant Poissonian sampling rate psi
oldest_age= 10
age_grid  = seq(from=0,to=oldest_age,by=0.1) # choose a sufficiently fine age grid
lambda    = 1*exp(0.01*age_grid) # define lambda on the age grid
mu        = 0.2*lambda # assume similarly shaped but smaller mu

# simulate deterministic HBD model
# scale LTT such that it is 100 at age 1
simulation = simulate_deterministic_hbds(age_grid   = age_grid,
                                         lambda     = lambda,
                                         mu         = mu,
                                         psi        = 0.1,
                                         age0       = 1,
                                         LTT0       = 100)
# plot deterministic LTT
plot( x = simulation$ages, y = simulation$LTT, type='l',
      main='dLTT', xlab='age', ylab='lineages', xlim=c(oldest_age,0))
</code></pre>

<hr>
<h2 id='simulate_diversification_model'>
Simulate a deterministic uniform speciation/extinction model.
</h2><span id='topic+simulate_diversification_model'></span>

<h3>Description</h3>

<p>Simulate a speciation/extinction cladogenic model for diversity over time, in the derministic limit. Speciation (birth) and extinction (death) rates can each be constant or power-law functions of the number of extant species. For example,
</p>
<p style="text-align: center;"><code class="reqn">
B = I + F\cdot N^E,
</code>
</p>

<p>where <code class="reqn">B</code> is the birth rate, <code class="reqn">I</code> is the intercept, <code class="reqn">F</code> is the power-law factor, <code class="reqn">N</code> is the current number of extant species and <code class="reqn">E</code> is the power-law exponent. Optionally, the model can account for incomplete taxon sampling (rarefaction of tips) and for the effects of collapsing a tree at a non-zero resolution (i.e. clustering closely related tips into a single tip).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_diversification_model( times,
                                parameters            = list(),
                                added_rates_times     = NULL,
                                added_birth_rates_pc  = NULL,
                                added_death_rates_pc  = NULL,
                                added_periodic        = FALSE,
                                start_time            = NULL,
                                final_time            = NULL,
                                start_diversity	      = 1,
                                final_diversity       = NULL,
                                reverse               = FALSE,
                                include_coalescent    = FALSE,
                                include_event_rates   = FALSE,
                                include_Nevents       = FALSE,
                                max_runtime           = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_diversification_model_+3A_times">times</code></td>
<td>

<p>Numeric vector, listing the times for which to calculate diversities, as predicted by the model. Values must be in ascending order.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying the birth-death model parameters, with one or more of the following entries:
</p>

<ul>
<li><p><code>birth_rate_intercept</code>: Non-negative number. The intercept of the Poissonian rate at which new species (tips) are added. In units 1/time.
</p>
</li>
<li><p><code>birth_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which new species (tips) are added. In units 1/time.
</p>
</li>
<li><p><code>birth_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which new species (tips) are added. Unitless.
</p>
</li>
<li><p><code>death_rate_intercept</code>:
Non-negative number. The intercept of the Poissonian rate at which extant species (tips) go extinct. In units 1/time.
</p>
</li>
<li><p><code>death_rate_factor</code>:
Non-negative number. The power-law factor of the Poissonian rate at which extant species (tips) go extinct. In units 1/time.
</p>
</li>
<li><p><code>death_rate_exponent</code>:
Numeric. The power-law exponent of the Poissonian rate at which extant species (tips) go extinct. Unitless.
</p>
</li>
<li><p><code>resolution</code>: Non-negative number. Time resolution at which the final tree is assumed to be collapsed. Units are time units. E.g. if this is 10, then all nodes of age 10 or less, are assumed to be collapsed into (represented by) a single tip. This can be used to model OTU trees, obtained after clustering strains by some similarity (=age) threshold. Set to 0 to disable collapsing. If left unspecified, this is set to 0.
</p>
</li>
<li><p><code>rarefaction</code>: Numeric between 0 and 1, specifying the fraction of tips kept in the final tree after random subsampling. Rarefaction is assumed to occur after collapsing at the specified resolution (if applicable). This can be used to model incomplete taxon sampling. If left unspecified, this is set to 1.
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_added_rates_times">added_rates_times</code></td>
<td>

<p>Numeric vector, listing time points (in ascending order) for a custom per-capita birth and/or death rates time series (see <code>added_birth_rates_pc</code> and <code>added_death_rates_pc</code> below). Can also be <code>NULL</code>, in which case the custom time series are ignored.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_added_birth_rates_pc">added_birth_rates_pc</code></td>
<td>

<p>Numeric vector of the same size as <code>added_rates_times</code>, listing per-capita birth rates to be added to the power law part. Added rates are interpolated linearly between time points in <code>added_rates_times</code>. Can also be <code>NULL</code>, in which case this option is ignored and birth rates are purely described by the power law.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_added_death_rates_pc">added_death_rates_pc</code></td>
<td>

<p>Numeric vector of the same size as <code>added_rates_times</code>, listing per-capita death rates to be added to the power law part. Added rates are interpolated linearly between time points in <code>added_rates_times</code>. Can also be <code>NULL</code>, in which case this option is ignored and death rates are purely described by the power law.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_added_periodic">added_periodic</code></td>
<td>

<p>Logical, indicating whether <code>added_birth_rates_pc</code> and <code>added_death_rates_pc</code> should be extended periodically if needed (i.e. if not defined for the entire simulation time). If <code>FALSE</code>, added birth &amp; death rates are extended with zeros.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_start_time">start_time</code></td>
<td>

<p>Numeric. Start time of the tree (&lt;=<code>times[1]</code>). Can also be <code>NULL</code>, in which case it is set to the first value in <code>times</code>.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_final_time">final_time</code></td>
<td>

<p>Numeric. Final (ending) time of the tree (&gt;=<code>max(times)</code>). Can also be <code>NULL</code>, in which case it is set to the last value in <code>times</code>.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_start_diversity">start_diversity</code></td>
<td>

<p>Numeric. Total diversity at <code>start_time</code>. Only relevant if <code>reverse==FALSE</code>.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_final_diversity">final_diversity</code></td>
<td>

<p>Numeric. Total diversity at <code>final_time</code>, i.e. the final diversity of the tree (total extant species at age 0). Only relevant if <code>reverse==TRUE</code>.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_reverse">reverse</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the tree model is simulated in backward time direction. In that case, <code>final_diversity</code> is interpreted as the known diversity at the last time point, and all diversities at previous time points are calculated based on the model. If <code>FALSE</code>, then the model is simulated in forward-time, with initial diversity given by <code>start_diversity</code>.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_include_coalescent">include_coalescent</code></td>
<td>

<p>Logical, specifying whether the diversity corresponding to a coalescent tree (i.e. the tree spanning only extant tips) should also be calculated. If <code>coalescent==TRUE</code> and the death rate is non-zero, then the coalescent diversities will generally be lower than the total diversities.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_include_event_rates">include_event_rates</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the birth (speciation) and death (extinction) rates (for each time point) are included as returned values. This comes at a moderate computational overhead.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_include_nevents">include_Nevents</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the cumulative birth (speciation) and death (extinction) events (for each time point) are included as returned values. This comes at a moderate computational overhead.
</p>
</td></tr>
<tr><td><code id="simulate_diversification_model_+3A_max_runtime">max_runtime</code></td>
<td>

<p>Numeric. Maximum runtime (in seconds) allowed for the simulation. If this time is surpassed, the simulation aborts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is deterministic, meaning that diversification is modeled using ordinary differential equations, not as a stochastic process. The simulation essentially computes the deterministic diversity over time, not an actual tree. For stochastic cladogenic simulations yielding a random tree, see <code><a href="#topic+generate_random_tree">generate_random_tree</a></code> and <code><a href="#topic+simulate_dsse">simulate_dsse</a></code>.
</p>
<p>In the special case where per-capita birth and death rates are constant (i.e. <code class="reqn">I=0</code> and <code class="reqn">E=1</code> for birth and death rates), this function uses an explicit analytical solution to the underlying differential equations, and is thus much faster than in the general case.
</p>
<p>If <code>rarefaction&lt;1</code> and <code>resolution&gt;0</code>, collapsing of closely related tips (at the resolution specified) is assumed to take place prior to rarefaction (i.e., subsampling applies to the already collapsed tips).
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If the simulation aborted due to runtime constraints (option <code>max_runtime</code>), <code>success</code> will be <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>total_diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the total diversity (extant at each the time) for each time point in <code>times</code>.
</p>
</td></tr>
<tr><td><code>coalescent_diversities</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the coalescent diversity (i.e. as seen in the coalescent tree spanning only extant species) for each time point in <code>times</code>. Only included if <code>include_coalescent==TRUE</code>.
</p>
</td></tr>
<tr><td><code>birth_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the speciation (birth) rate at each time point. Only included if <code>include_event_rates==TRUE</code>.
</p>
</td></tr>
<tr><td><code>death_rates</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the extinction (death) rate at each time point. Only included if <code>include_event_rates==TRUE</code>.
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the cumulative number of speciation (birth) events up to each time point. Only included if <code>include_Nevents==TRUE</code>.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Numeric vector of the same size as <code>times</code>, listing the cumulative number of extinction (death) events up to each time point. Only included if <code>include_Nevents==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_random_tree">generate_random_tree</a></code>,
<code><a href="#topic+count_lineages_through_time">count_lineages_through_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a tree
max_time = 100
parameters = list(birth_rate_intercept  = 10, 
                  birth_rate_factor     = 0,
                  birth_rate_exponent   = 0,
                  death_rate_intercept  = 0,
                  death_rate_factor     = 0,
                  death_rate_exponent   = 0,
                  resolution            = 20,
                  rarefaction           = 0.5)
generator = generate_random_tree(parameters,max_time=max_time)
tree = generator$tree
final_total_diversity = length(tree$tip.label)+generator$Nrarefied+generator$Ncollapsed

# Calculate diversity-vs-time curve for the tree
times = seq(from=0,to=0.99*max_time,length.out=50)
tree_diversities = count_lineages_through_time(tree, times=times)$lineages

# simulate diversity curve based on deterministic model
simulation = simulate_diversification_model(times,
                                            parameters,
                                            reverse=TRUE,
                                            final_diversity=final_total_diversity,
                                            include_coalescent=TRUE)
model_diversities = simulation$coalescent_diversities

# compare diversities in the tree to the simulated ones
plot(tree_diversities,model_diversities,xlab="tree diversities",ylab="simulated diversities")
abline(a=0,b=1,col="#A0A0A0") # show diagonal for reference
</code></pre>

<hr>
<h2 id='simulate_dsse'>
Simulate a Discrete-State Speciation and Extinction (dSSE) model.
</h2><span id='topic+simulate_dsse'></span><span id='topic+simulate_musse'></span>

<h3>Description</h3>

<p>Simulate a random phylogenetic tree in forward time based on a Poissonian speciation/extinction (birth/death) process, with optional Poissonian sampling over time, whereby birth/death/sampling rates are determined by a co-evolving discrete trait. New species are added (born) by splitting of a randomly chosen extant tip. The discrete trait, whose values determine birth/death/sampling rates over time, can evolve in two modes: (A) Anagenetically, i.e. according to a discrete-space continuous-time Markov process along each edge, with fixed transition rates between states, and/or (B) cladogenetically, i.e. according to fixed transition probabilities between states at each speciation event. Poissonian lineage sampling is assumed to lead to a removal of lineages from the pool of extant tips (as is common in epidemiology). 
</p>
<p>This model class includes the Multiple State Speciation and Extinction (MuSSE) model described by FitzJohn et al. (2009), as well as the Cladogenetic SSE (ClaSSE) model described by Goldberg and Igis (2012). Optionally, the model can be turned into a Hidden State Speciation and Extinction model (Beaulieu and O'meara, 2016), by replacing the simulated tip/node states with &quot;proxy&quot; states, thus hiding the original states actually influencing speciation/extinction rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dsse( Nstates,
               NPstates                 = NULL,
               proxy_map                = NULL,
               parameters               = list(),
               start_state              = NULL,
               max_tips                 = NULL, 
               max_extant_tips          = NULL,
               max_Psampled_tips        = NULL,
               max_time                 = NULL,
               max_time_eq              = NULL,
               max_events               = NULL,
               sampling_fractions       = NULL,
               reveal_fractions         = NULL,
               sampling_rates           = NULL,
               coalescent               = TRUE,
               as_generations           = FALSE,
               no_full_extinction       = TRUE,
               tip_basename             = "", 
               node_basename            = NULL,
               include_event_times      = FALSE,
               include_rates            = FALSE,
               include_labels           = TRUE)
               
simulate_musse(Nstates,  NPstates = NULL, proxy_map = NULL, 
            parameters = list(), start_state = NULL, 
            max_tips = NULL, max_extant_tips = NULL, max_Psampled_tips = NULL,
            max_time = NULL, max_time_eq = NULL, max_events = NULL, 
            sampling_fractions = NULL, reveal_fractions = NULL, sampling_rates = NULL,
            coalescent = TRUE, as_generations = FALSE, no_full_extinction = TRUE, 
            tip_basename = "", node_basename = NULL, 
            include_event_times = FALSE, include_rates = FALSE, include_labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_dsse_+3A_nstates">Nstates</code></td>
<td>

<p>Integer, specifying the number of possible discrete states a tip can have, influencing speciation/extinction rates. For example, if <code>Nstates==2</code> then this corresponds to the common Binary State Speciation and Extinction (BiSSE) model (Maddison et al., 2007). In the case of a HiSSE model, <code>Nstates</code> refers to the total number of diversification rate categories, as described by Beaulieu and O'meara (2016).
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_npstates">NPstates</code></td>
<td>

<p>Integer, optionally specifying a number of &quot;proxy-states&quot; that are observed instead of the underlying speciation/extinction-modulating states. To simulate a HiSSE model, this should be smaller than <code>Nstates</code>. Each state corresponds to a different proxy-state, as defined using the variable <code>proxy_map</code> (see below). For BiSSE/MuSSE with no hidden states, <code>NPstates</code> can be set to either <code>NULL</code> or equal to <code>Nstates</code>, and proxy-states are equivalent to states.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_proxy_map">proxy_map</code></td>
<td>

<p>Integer vector of size <code>Nstates</code> and with values in 1,..<code>NPstates</code>, specifying the correspondence between states (i.e. diversification-rate categories) and (observed) proxy-states, in a HiSSE model. Specifically, <code>proxy_map[s]</code> indicates which proxy-state the state s is represented by. Each proxy-state can represent multiple states (i.e. proxies are ambiguous), but each state must be represented by exactly one proxy-state. For non-HiSSE models, set this to <code>NULL</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying the dSSE model parameters, such as the anagenetic and/or cladogenetic transition rates between states and the state-dependent birth/death rates (see details below).
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_start_state">start_state</code></td>
<td>

<p>Integer within 1,..,<code>Nstates</code>, specifying the initial state, i.e. of the first lineage created. If left unspecified, this is chosen randomly and uniformly among all possible states.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_tips">max_tips</code></td>
<td>

<p>Integer, maximum number of tips (extant + Poissonian-sampled if <code>coalescent==TRUE</code>, or extant+extinct+Poissonian-sampled if <code>coalescent==FALSE</code>) in the generated tree, shortly before any present-day sampling. If <code>NULL</code> or &lt;=0, the number of tips is not limited, so you should use another stopping criterion such as <code>max_time</code> and/or <code>max_time_eq</code> and/or <code>max_events</code> to stop the simulation.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_extant_tips">max_extant_tips</code></td>
<td>

<p>Integer, maximum number of extant tips in the generated tree, shortly before to any present-day sampling. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_psampled_tips">max_Psampled_tips</code></td>
<td>

<p>Integer, maximum number of Poissonian-sampled tips in the generated tree. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_time">max_time</code></td>
<td>

<p>Numeric, maximum duration of the simulation. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_time_eq">max_time_eq</code></td>
<td>

<p>Numeric, maximum duration of the simulation, counting from the first point at which speciation/extinction equilibrium is reached, i.e. when (birth rate - death rate) changed sign for the first time. If <code>NULL</code> or &lt;0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_max_events">max_events</code></td>
<td>

<p>Integer, maximum number of speciation/extinction/transition events before halting the simulation. If <code>NULL</code>, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_sampling_fractions">sampling_fractions</code></td>
<td>

<p>A single number, or a numeric vector of size <code>NPstates</code>, listing the sampling fractions for extant tips at the end of the simulation (i.e., at &quot;present-day&quot;)&quot;, depending on proxy-state. <code>sampling_fractions[p]</code> is the probability of including an extant tip in the final tree, if its proxy-state is p. If a single number, all extant tips are sampled with the same probability, i.e. regardless of their proxy-state. If <code>NULL</code>, this is the same as setting <code>sampling_fractions</code> to 1, i.e., all extant tips are sampled at the end of the simulation.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_reveal_fractions">reveal_fractions</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, listing reveal fractions of tip proxy-states, depending on proxy state. <code>reveal_fractions[p]</code> is the probability of knowing a tip's proxy-state, if its proxy state is p. Can also be NULL, in which case all tip proxy states will be known.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_sampling_rates">sampling_rates</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, listing Poissonian sampling rates of lineages over time, depending on proxy state. Hence, <code>sampling_rates[p]</code> is the sampling rate of a lineage if its proxy state is p. Can also be a single numeric, thus applying the same sampling rate to all lineages regardless of proxy state. Can also be <code>NULL</code>, in which case Poissonian sampling is not included.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, specifying whether only the coalescent tree (i.e. the tree spanning the sampled tips) should be returned. If <code>coalescent==FALSE</code> and the death rate is non-zero, then the tree may include extinct tips.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_as_generations">as_generations</code></td>
<td>

<p>Logical, specifying whether edge lengths should correspond to generations. If FALSE, then edge lengths correspond to time.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_no_full_extinction">no_full_extinction</code></td>
<td>

<p>Logical, specifying whether to prevent complete extinction of the tree. Full extinction is prevented by temporarily disabling extinctions and Poissonian samplings whenever the number of extant tips is 1. if <code>no_full_extinction==FALSE</code> and death rates and/or Poissonian sampling rates are non-zero, the tree may go extinct during the simulation; if <code>coalescent==TRUE</code>, then the returned could end up empty, hence the function will return unsuccessfully (i.e. <code>success</code> will be <code>FALSE</code>). By default <code>no_full_extinction</code> is <code>TRUE</code>, however in some special cases it may be desirable to allow full extinctions to ensure that the generated trees are statistically distributed exactly according to the underlying cladogenetic model.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_include_event_times">include_event_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of speciation and extinction events (each in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_include_rates">include_rates</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the per-capita birth &amp; death rates of all tips and nodes will also be returned.
</p>
</td></tr>
<tr><td><code id="simulate_dsse_+3A_include_labels">include_labels</code></td>
<td>

<p>Logical, specifying whether to include tip-labels and node-labels (if available) as names in the returned state vectors (e.g. <code>tip_states</code> and <code>node_states</code>). In any case, returned states are always listed in the same order as tips and nodes in the tree. Setting this to <code>FALSE</code> may increase computational efficiency for situations where labels are not required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simulate_dsse</code> can be used to simulate a diversification + discrete-trait evolutionary process, in which birth/death (speciation/extinction) and Poissonian sampling rates at each tip are determined by a tip's current &quot;state&quot;. Lineages can transition between states anagenetically along each edge (according to fixed Markov transition rates) and/or cladogenetically at each speciation event (according to fixed transition probabilities). In addition to Poissonian sampling through time (commonly included in epidemiological models), extant tips can also be sampled at the end of the simulation (i.e. at &quot;present-day&quot;) according to some state-specific <code>sampling_fractions</code> (common in macroevolution).
</p>
<p>The function <code>simulate_musse</code> is a simplified variant meant to simulate MuSSE/HiSSE models in the absence of cladogenetic state transitions, and is included mainly for backward-compatibility reasons. The input arguments for <code>simulate_musse</code> are identical to <code>simulate_dsse</code>, with the exception that the <code>parameters</code> argument must include slightly different elements (explained below). Note that the standard MuSSE/HiSSE models published by FitzJohn et al. (2009) and Beaulieu and O'meara (2016) did not include Poissonian sampling through time, i.e. sampling of extant lineages was only done once at present-day.
</p>
<p>For <code>simulate_dsse</code>, the argument <code>parameters</code> should be a named list including one or more of the following elements:
</p>

<ul>
<li><p><code>birth_rates</code>: Numeric vector of size Nstates, listing the per-capita birth rate (speciation rate) at each state. Can also be a single number (all states have the same birth rate).
</p>
</li>
<li><p><code>death_rates</code>: Numeric vector of size Nstates, listing the per-capita death rate (extinction rate) at each state. Can also be a single number (all states have the same death rate).
</p>
</li>
<li><p><code>transition_matrix_A</code>: 2D numeric matrix of size Nstates x Nstates, listing anagenetic transition rates between states along an edge. Hence, <code>transition_matrix_A[r,c]</code> is the probability rate for transitioning from state <code>r</code> to state <code>c</code>. Non-diagonal entries must be non-negative, diagonal entries must be non-positive, and the sum of each row must be zero.
</p>
</li>
<li><p><code>transition_matrix_C</code>: 2D numeric matrix of size Nstates x Nstates, listing cladogenetic transition probabilities between states during a speciation event, seperately for each child. Hence, <code>transition_matrix_C[r,c]</code> is the probability that a child will have state <code>c</code>, conditional upon the occurrence of a speciation event, given that the parent had state <code>r</code>, and independently of all other children. Entries must be non-negative, and the sum of each row must be one.
</p>
</li></ul>

<p>For <code>simulate_musse</code>, the argument <code>parameters</code> should be a named list including one or more of the following elements:
</p>

<ul>
<li><p><code>birth_rates</code>: Same as for <code>simulate_dsse</code>.
</p>
</li>
<li><p><code>death_rates</code>: Same as for <code>simulate_dsse</code>.
</p>
</li>
<li><p><code>transition_matrix</code>: 2D numeric matrix of size Nstates x Nstates, listing anagenetic transition rates between states. This is equivalent to <code>transition_matrix_A</code> in <code>simulate_dsse</code>.
</p>
</li></ul>

<p>Note that this code generates trees in forward time, and halts as soon as one of the enabled halting conditions is met; the halting conditions chosen affects the precise probability distribution from which the generated trees are drawn (Stadler 2011).
If at any moment during the simulation the tree only includes a single extant tip, and if <code>no_full_extinction=TRUE</code>, the death and sampling rate are temporarily set to zero to prevent the complete extinction of the tree. The tree will be ultrametric if <code>coalescent==TRUE</code> (or death rates were zero) and Poissonian sampling was not included.
</p>
<p>HiSSE models (Beaulieu and O'meara, 2016) are closely related to BiSSE/MuSSE models, the main difference being the fact that the actual diversification-modulating states are not directly observed. Hence, this function is also able to simulate HiSSE models, with appropriate choice of the input variables <code>Nstates</code>, <code>NPstates</code> and <code>proxy_map</code>. For example, <code>Nstates=4</code>, <code>NPstates=2</code> and <code>proxy_map=c(1,2,1,2)</code> specifies that states 1 and 3 are represented by proxy-state 1, and states 2 and 4 are represented by proxy-state 2. This is the original case described by Beaulieu and O'meara (2016); in their terminology, there would be 2 &quot;hidden&quot;&quot; states (&quot;0&quot; and &quot;1&quot;) and 2 &quot;observed&quot; (proxy) states (&quot;A&quot; and &quot;B&quot;), and the 4 diversification rate categories (<code>Nstates=4</code>) would be called &quot;0A&quot;, &quot;1A&quot;, &quot;0B&quot; and &quot;1B&quot;, respectively. The somewhat different terminology used here allows for easier generalization to an arbitrary number of diversification-modulating states and an arbitrary number of proxy states. For example, if there are 6 diversification modulating states, represented by 3 proxy-states as 1-&gt;A, 2-&gt;A, 3-&gt;B, 4-&gt;C, 5-&gt;C, 6-&gt;C, then one would set <code>Nstates=6</code>, <code>NPstates=3</code> and <code>proxy_map=c(1,1,2,3,3,3)</code>.
</p>
<p>The parameter <code>transition_matrix_C</code> can be used to define ClaSSE models (Goldberg and Igic, 2012) or BiSSE-ness models (Magnuson-Ford and Otto, 2012), although care must be taken to properly define the transition probabilities. Here, cladogenetic transitions occur at probabilities that are defined conditionally upon a speciation event, whereas in other software they may be defined as probability rates.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If <code>FALSE</code>, an additional element <code>error</code> (of type character) is included containing an explanation of the error; in that case the value of any of the other elements is undetermined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted bifurcating tree of class &quot;phylo&quot;, generated according to the specified birth/death model. 
</p>
<p>If <code>coalescent==TRUE</code> or if all death rates are zero, and only if <code>as_generations==FALSE</code> and in the absence of Poissonian sampling, then the tree will be ultrametric. If <code>as_generations==TRUE</code> and <code>coalescent==FALSE</code>, all edges will have unit length.
</p>
</td></tr>
<tr><td><code>root_time</code></td>
<td>

<p>Numeric, giving the time at which the tree's root was first split during the simulation. 
Note that if <code>coalescent==TRUE</code>, this may be later than the first speciation event during the simulation.
</p>
</td></tr>
<tr><td><code>final_time</code></td>
<td>

<p>Numeric, giving the final time at the end of the simulation. If <code>coalescent==TRUE</code>, then this may be greater than the total time span of the tree (since the root of the coalescent tree need not correspond to the first speciation event).
</p>
</td></tr>
<tr><td><code>equilibrium_time</code></td>
<td>

<p>Numeric, giving the first time where the sign of (death rate - birth rate) changed from the beginning of the simulation, i.e. when speciation/extinction equilibrium was reached. May be infinite if the simulation stopped before reaching this point.
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Integer vector of size Nstates, listing the total number of birth events (speciations) that occurred at each state. The sum of all entries in <code>Nbirths</code> may be lower than the total number of tips in the tree if death rates were non-zero and <code>coalescent==TRUE</code>.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Integer vector of size Nstates, listing the total number of death events (extinctions) that occurred at each state.
</p>
</td></tr>
<tr><td><code>NPsamplings</code></td>
<td>

<p>Integer vector of size Nstates, listing the total number of Poissonian sampling events that occurred at each state.
</p>
</td></tr>
<tr><td><code>Ntransitions_A</code></td>
<td>

<p>2D numeric matrix of size Nstates x Nstates, listing the total number of anagenetic transition events that occurred between each pair of states. For example, <code>Ntransitions_A[1,2]</code> is the number of anagenetic transitions (i.e., within a species) that occured from state 1 to state 2.
</p>
</td></tr>
<tr><td><code>Ntransitions_C</code></td>
<td>

<p>2D numeric matrix of size Nstates x Nstates, listing the total number of cladogenetic transition events that occurred between each pair of states. For example, <code>Ntransitions_C[1,2]</code> is the number of cladogenetic transitions (i.e., from a parent to a child) that occured from state 1 to state 2 during some speciation event. Note that each speciation event will have caused 2 transitions (one per child), and that the emergence of a child with the same state as the parent is counted as a transition between the same state (diagonal entries in <code>Ntransitions_C</code>).
</p>
</td></tr>
<tr><td><code>NnonsampledExtant</code></td>
<td>

<p>Integer, specifying the number of extant tips not sampled at the end, i.e., omitted from the tree.
</p>
</td></tr>
<tr><td><code>tip_states</code></td>
<td>

<p>Integer vector of size Ntips and with values in 1,..,Nstates, listing the state of each tip in the tree.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Integer vector of size Nnodes and with values in 1,..,Nstates, listing the state of each node in the tree.
</p>
</td></tr>
<tr><td><code>tip_proxy_states</code></td>
<td>

<p>Integer vector of size Ntips and with values in 1,..,NPstates, listing the proxy state of each tip in the tree. Only included in the case of HiSSE models.
</p>
</td></tr>
<tr><td><code>node_proxy_states</code></td>
<td>

<p>Integer vector of size Nnodes and with values in 1,..,NPstates, listing the proxy state of each node in the tree. Only included in the case of HiSSE models.
</p>
</td></tr>
<tr><td><code>start_state</code></td>
<td>

<p>Integer, specifying the state of the first lineage (either provided during the function call, or generated randomly).
</p>
</td></tr>
<tr><td><code>extant_tips</code></td>
<td>

<p>Integer vector, listing the indices of any extant tips in the tree.
</p>
</td></tr>
<tr><td><code>extinct_tips</code></td>
<td>

<p>Integer vector, listing the indices of any extinct tips in the tree. Note that if <code>coalescent==TRUE</code>, this vector will be empty.
</p>
</td></tr>
<tr><td><code>Psampled_tips</code></td>
<td>

<p>Integer vector, listing the indices of any Poissonian-sampled tips in the tree.
</p>
</td></tr>
<tr><td><code>birth_times</code></td>
<td>

<p>Numeric vector, listing the times of speciation events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root. Only returned if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>death_times</code></td>
<td>

<p>Numeric vector, listing the times of extinction events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root. Only returned if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>Psampling_times</code></td>
<td>

<p>Numeric vector, listing the times of Poissonian sampling events during tree growth, in order of occurrence. Only returned if <code>include_event_times==TRUE</code>.
</p>
</td></tr>
<tr><td><code>clade_birth_rates</code></td>
<td>

<p>Numeric vector of size Ntips+Nnodes, listing the per-capita birth rate of each tip and node in the tree. Only included if <code>include_rates==TRUE</code>.
</p>
</td></tr>
<tr><td><code>clade_death_rates</code></td>
<td>

<p>Numeric vector of size Ntips+Nnodes, listing the per-capita death rate of each tip and node in the tree. Only included if <code>include_rates==TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>W. P. Maddison, P. E. Midford, S. P. Otto (2007). Estimating a binary character's effect on speciation and extinction. Systematic Biology. 56:701-710.
</p>
<p>R. G. FitzJohn, W. P. Maddison, S. P. Otto (2009). Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology. 58:595-611
</p>
<p>R. G. FitzJohn (2012). Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution. 3:1084-1092
</p>
<p>E. E. Goldberg, B. Igic (2012). Tempo and mode in plant breeding system evolution. Evolution. 66:3701-3709.
</p>
<p>K. Magnuson-Ford, S. P. Otto (2012). Linking the investigations of character evolution and species diversification. The American Naturalist. 180:225-245.
</p>
<p>J. M. Beaulieu and B. C. O'Meara (2016). Detecting hidden diversification shifts in models of trait-dependent speciation and extinction. Systematic Biology. 65:583-601.
</p>
<p>T. Stadler (2011). Simulating trees with a fixed number of extant species. Systematic Biology. 60:676-684.
</p>
<p>S. Louca and M. W. Pennell (2020). A general and efficient algorithm for the likelihood of diversification and discrete-trait evolutionary models. Systematic Biology. 69:545-556.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_tdsse">simulate_tdsse</a></code>, 
<code><a href="#topic+fit_musse">fit_musse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a tree under a classical BiSSE model
# I.e., anagenetic transitions between two states, no Poissonian sampling through time.
A = get_random_mk_transition_matrix(Nstates=2, rate_model="ER", max_rate=0.1)
parameters = list(birth_rates         = c(1,1.5),
                  death_rates         = 0.5,
                  transition_matrix_A = A)
simulation = simulate_dsse( Nstates         = 2, 
                            parameters      = parameters, 
                            max_extant_tips = 1000, 
                            include_rates   = TRUE)
tree       = simulation$tree
Ntips      = length(tree$tip.label)

# plot distribution of per-capita birth rates of tips
rates = simulation$clade_birth_rates[1:Ntips]
barplot(table(rates)/length(rates), 
        xlab="rate", 
        main="Distribution of pc birth rates across tips (BiSSE model)")
</code></pre>

<hr>
<h2 id='simulate_mk_model'>
Simulate an Mk model for discrete trait evolution.
</h2><span id='topic+simulate_mk_model'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, a fixed-rates continuous-time Markov model for the evolution of a discrete trait (&quot;Mk model&quot;, described by a transition matrix) and a probability vector for the root, simulate random outcomes of the model on all nodes and/or tips of the tree. The function traverses nodes from root to tips and randomly assigns a state to each node or tip based on its parent's previously assigned state and the specified transition rates between states. The generated states have joint distributions consistent with the Markov model. Optionally, multiple independent simulations can be performed using the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_mk_model(tree, Q, root_probabilities="stationary",
                  include_tips=TRUE, include_nodes=TRUE, 
                  Nsimulations=1, drop_dims=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_mk_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_q">Q</code></td>
<td>

<p>A numeric matrix of size Nstates x Nstates, storing the transition rates between states. In particular, every row must sum up to zero.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_root_probabilities">root_probabilities</code></td>
<td>

<p>Probabilities of the different states at the root.
Either a character vector with value &quot;stationary&quot; or &quot;flat&quot;, or a numeric vector of length Nstates, where Nstates is the number of possible states of the trait. In the later case, <code>root_probabilities</code> must be a valid probability vector, i.e. with non-negative values summing up to 1. &quot;stationary&quot; sets the probabilities at the root to the stationary distribution of <code>Q</code> (see <code><a href="#topic+get_stationary_distribution">get_stationary_distribution</a></code>), while &quot;flat&quot; means that each state is equally probable at the root.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_include_tips">include_tips</code></td>
<td>

<p>Include random states for the tips. If <code>FALSE</code>, no states will be returned for tips.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_include_nodes">include_nodes</code></td>
<td>

<p>Include random states for the nodes. If <code>FALSE</code>, no states will be returned for nodes.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_nsimulations">Nsimulations</code></td>
<td>

<p>Number of random independent simulations to perform. For each node and/or tip, there will be <code>Nsimulations</code> random states generated.
</p>
</td></tr>
<tr><td><code id="simulate_mk_model_+3A_drop_dims">drop_dims</code></td>
<td>

<p>Logical, specifying whether the returned <code>tip_states</code> and <code>node_states</code> (see below) should be vectors, if <code>Nsimulations==1</code>. If <code>drop_dims==FALSE</code>, then <code>tip_states</code> and <code>tip_nodes</code> will always be 2D matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, the trait's states must be represented by integers within 1,..,Nstates, where Nstates is the total number of possible states. If the states are originally in some other format (e.g. characters or factors), you should map them to a set of integers 1,..,Nstates. These integers should correspond to row &amp; column indices in the transition matrix <code>Q</code>. You can easily map any set of discrete states to integers using the function <code><a href="#topic+map_to_state_space">map_to_state_space</a></code>.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The time required per simulation decreases with the total number of requested simulations.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tip_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_tips==FALSE</code>), or a 2D integer matrix of size Nsimulations x Ntips with values in 1,..,Nstates, where Ntips is the number of tips in the tree and Nstates is the number of possible states of the trait. The [r,c]-th entry of this matrix will be the state of tip c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>tip_states</code> will be a vector.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_nodes==FALSE</code>), or a 2D integer matrix of size Nsimulations x Nnodes with values in 1,..,Nstates, where Nnodes is the number of nodes in the tree. The [r,c]-th entry of this matrix will be the state of node c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>node_states</code> will be a vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponentiate_matrix">exponentiate_matrix</a></code>, <code><a href="#topic+get_stationary_distribution">get_stationary_distribution</a></code>, 
<code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>, <code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>, <code><a href="#topic+simulate_rou_model">simulate_rou_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=1000)$tree

# simulate discrete trait evolution on the tree (5 states)
Nstates = 5
Q = get_random_mk_transition_matrix(Nstates, rate_model="ARD", max_rate=0.1)
tip_states = simulate_mk_model(tree, Q)$tip_states

# plot histogram of simulated tip states
barplot(table(tip_states)/length(tip_states), xlab="state")

## End(Not run)</code></pre>

<hr>
<h2 id='simulate_ou_model'>
Simulate an Ornstein-Uhlenbeck model for continuous trait evolution.
</h2><span id='topic+simulate_ou_model'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and an Ornstein-Uhlenbeck (OU) model for the evolution of a continuous (numeric) trait, simulate random outcomes of the model on all nodes and/or tips of the tree. The function traverses nodes from root to tips and randomly assigns a state to each node or tip based on its parent's previously assigned state and the specified model parameters. The generated states have joint distributions consistent with the OU model. Optionally, multiple independent simulations can be performed using the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_ou_model(tree, stationary_mean, stationary_std, decay_rate,
                  include_tips=TRUE, include_nodes=TRUE, 
                  Nsimulations=1, drop_dims=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_ou_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_stationary_mean">stationary_mean</code></td>
<td>

<p>Numeric. The mean (center) of the stationary distribution of the OU model.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_stationary_std">stationary_std</code></td>
<td>

<p>Positive numeric. The standard deviation of the stationary distribution of the OU model.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_decay_rate">decay_rate</code></td>
<td>

<p>Positive numeric. Exponential decay rate (stabilization rate) of the OU model (in units 1/edge_length_units).
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_include_tips">include_tips</code></td>
<td>

<p>Include random states for the tips. If <code>FALSE</code>, no states will be returned for tips.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_include_nodes">include_nodes</code></td>
<td>

<p>Include random states for the nodes. If <code>FALSE</code>, no states will be returned for nodes.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_nsimulations">Nsimulations</code></td>
<td>

<p>Number of random independent simulations to perform. For each node and/or tip, there will be <code>Nsimulations</code> random states generated.
</p>
</td></tr>
<tr><td><code id="simulate_ou_model_+3A_drop_dims">drop_dims</code></td>
<td>

<p>Logical, specifying whether the returned <code>tip_states</code> and <code>node_states</code> (see below) should be vectors, if <code>Nsimulations==1</code>. If <code>drop_dims==FALSE</code>, then <code>tip_states</code> and <code>tip_nodes</code> will always be 2D matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each simulation, the state of the root is picked randomly from the stationary distribution of the OU model, i.e. from a normal distribution with mean = <code>stationary_mean</code> and standard deviation = <code>stationary_std</code>.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The asymptotic time complexity of this function is O(Nedges*Nsimulations), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tip_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_tips==FALSE</code>), or a 2D numeric matrix of size Nsimulations x Ntips, where Ntips is the number of tips in the tree. The [r,c]-th entry of this matrix will be the state of tip c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>tip_states</code> will be a vector.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_nodes==FALSE</code>), or a 2D numeric matrix of size Nsimulations x Nnodes, where Nnodes is the number of nodes in the tree. The [r,c]-th entry of this matrix will be the state of node c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>node_states</code> will be a vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>, <code><a href="#topic+simulate_mk_model">simulate_mk_model</a></code>, <code><a href="#topic+simulate_rou_model">simulate_rou_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=10000)$tree

# simulate evolution of a continuous trait
tip_states = simulate_ou_model( tree, 
                                stationary_mean = 10, 
                                stationary_std = 1, 
                                decay_rate = 0.1)$tip_states

# plot histogram of simulated tip states
hist(tip_states, breaks=20, xlab="state", main="Trait probability distribution", prob=TRUE)
</code></pre>

<hr>
<h2 id='simulate_rou_model'>
Simulate a reflected Ornstein-Uhlenbeck model for continuous trait evolution.
</h2><span id='topic+simulate_rou_model'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a reflected Ornstein-Uhlenbeck (ROU) model for the evolution of a continuous (numeric) trait, simulate random outcomes of the model on all nodes and/or tips of the tree. The ROU process is similar to the Ornstein-Uhlenbeck process (see <code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>), with the difference that the ROU process cannot fall below a certain value (its &quot;reflection point&quot;), which (in this implementation) is also its deterministic equilibrium point (Hu et al. 2015). The function traverses nodes from root to tips and randomly assigns a state to each node or tip based on its parent's previously assigned state and the specified model parameters. The generated states have joint distributions consistent with the ROU model. Optionally, multiple independent simulations can be performed using the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_rou_model(tree, reflection_point, stationary_std, decay_rate,
                   include_tips=TRUE, include_nodes=TRUE, 
                   Nsimulations=1, drop_dims=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_rou_model_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_reflection_point">reflection_point</code></td>
<td>

<p>Numeric. The reflection point of the ROU model. In castor, this also happens to be the deterministic equilibrium of the ROU process (i.e. if the decay rate were infinite). For example, if a trait can only be positive (but arbitrarily small), then <code>reflection_point</code> may be set to 0.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_stationary_std">stationary_std</code></td>
<td>

<p>Positive numeric. The stationary standard deviation of the corresponding unreflected OU process.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_decay_rate">decay_rate</code></td>
<td>

<p>Positive numeric. Exponential decay rate (stabilization rate) of the ROU process (in units 1/edge_length_units).
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_include_tips">include_tips</code></td>
<td>

<p>Include random states for the tips. If <code>FALSE</code>, no states will be returned for tips.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_include_nodes">include_nodes</code></td>
<td>

<p>Include random states for the nodes. If <code>FALSE</code>, no states will be returned for nodes.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_nsimulations">Nsimulations</code></td>
<td>

<p>Number of random independent simulations to perform. For each node and/or tip, there will be <code>Nsimulations</code> random states generated.
</p>
</td></tr>
<tr><td><code id="simulate_rou_model_+3A_drop_dims">drop_dims</code></td>
<td>

<p>Logical, specifying whether the returned <code>tip_states</code> and <code>node_states</code> (see below) should be vectors, if <code>Nsimulations==1</code>. If <code>drop_dims==FALSE</code>, then <code>tip_states</code> and <code>tip_nodes</code> will always be 2D matrices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each simulation, the state of the root is picked randomly from the stationary distribution of the ROU model, i.e. from a one-sided normal distribution with mode = <code>reflection_point</code> and standard deviation = <code>stationary_std</code>.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child). The asymptotic time complexity of this function is O(Nedges*Nsimulations), where Nedges is the number of edges in the tree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tip_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_tips==FALSE</code>), or a 2D numeric matrix of size Nsimulations x Ntips, where Ntips is the number of tips in the tree. The [r,c]-th entry of this matrix will be the state of tip c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>tip_states</code> will be a vector.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Either <code>NULL</code> (if <code>include_nodes==FALSE</code>), or a 2D numeric matrix of size Nsimulations x Nnodes, where Nnodes is the number of nodes in the tree. The [r,c]-th entry of this matrix will be the state of node c generated by the r-th simulation. If <code>drop_dims==TRUE</code> and <code>Nsimulations==1</code>, then <code>node_states</code> will be a vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Y. Hu, C. Lee, M. H. Lee, J. Song (2015). Parameter estimation for reflected Ornstein-Uhlenbeck processes with discrete observations. Statistical Inference for Stochastic Processes. 18:279-291.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>, <code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>, <code><a href="#topic+simulate_mk_model">simulate_mk_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=10000)$tree

# simulate evolution of a continuous trait whose value is always &gt;=1
tip_states = simulate_rou_model(tree, 
                                reflection_point=1,
                                stationary_std=2, 
                                decay_rate=0.1)$tip_states

# plot histogram of simulated tip states
hist(tip_states, breaks=20, xlab="state", main="Trait probability distribution", prob=TRUE)
</code></pre>

<hr>
<h2 id='simulate_sbm'>
Simulate Spherical Brownian Motion on a tree.
</h2><span id='topic+simulate_sbm'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a Spherical Brownian Motion (SBM) model for the evolution of the geographical location of a lineage on a sphere, simulate random outcomes of the model on all nodes and/or tips of the tree. The function traverses nodes from root to tips and randomly assigns a geographical location to each node or tip based on its parent's previously assigned location and the specified model parameters. The generated states have joint distributions consistent with the SBM model (Perrin 1928; Brillinger 2012). This function generalizes the simple SBM model to support time-dependent diffusivities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sbm(tree, 
             radius, 
             diffusivity,
             time_grid      = NULL,
             splines_degree = 1,
             root_latitude  = NULL, 
             root_longitude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_sbm_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge. Edge lengths are assumed to represent time intervals or a similarly interpretable phylogenetic distance.
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_radius">radius</code></td>
<td>

<p>Strictly positive numeric, specifying the radius of the sphere. For Earth, the mean radius is 6371 km.
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_diffusivity">diffusivity</code></td>
<td>

<p>Either a single numeric, or a numeric vector of length equal to that of <code>time_grid</code>. Diffusivity (&quot;<code class="reqn">D</code>&quot;) of the SBM model (in units distance^2/time). If <code>time_grid</code> is <code>NULL</code>, then <code>diffusivity</code> should be a single number specifying the time-independent diffusivity. Otherwise <code>diffusivity</code> specifies the diffusivity at each time point listed in <code>time_grid</code>.
</p>
<p>Under a planar approximation the squared geographical distance of a node from the root will have expectation <code class="reqn">4LD</code>, where <code class="reqn">L</code> is the node's phylogenetic distance from the root. Note that distance is measured in the same units as the <code>radius</code> (e.g., km if the radius is given in km), and time is measured in the same units as the tree's edge lengths (e.g., Myr if edge lengths are given in Myr).
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_time_grid">time_grid</code></td>
<td>

<p>Numeric vector of the same length as <code>diffusivity</code> and listing times since the root in ascending order, or <code>NULL</code>. This can be used to specify a time-variable diffusivity (see details below). If <code>NULL</code>, the diffusivity is assumed to be constant over time and equal to <code>diffusivity</code> (which should be a single numeric). Time is measured in the same units as edge lengths, with root having time 0.
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0,1,2 or 3, specifying the polynomial degree of the provided <code>diffusivity</code> between grid points in <code>time_grid</code>. For example, if <code>splines_degree==1</code>, then the provided <code>diffusivity</code> is interpreted as a piecewise-linear curve; if <code>splines_degree==2</code> it is interpreted as a quadratic spline; if <code>splines_degree==3</code> it is interpreted as a cubic spline. The <code>splines_degree</code> influences the analytical properties of the curve, e.g. <code>splines_degree==1</code> guarantees a continuous curve, <code>splines_degree==2</code> guarantees a continuous curve and continuous derivative, and so on.
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_root_latitude">root_latitude</code></td>
<td>

<p>The latitude of the tree's root, in decimal degrees, between -90 and 90. If NULL, the root latitude is chosen randomly according to the stationary probability distribution of the SBM.
</p>
</td></tr>
<tr><td><code id="simulate_sbm_+3A_root_longitude">root_longitude</code></td>
<td>

<p>The longitude of the tree's root, in decimal degrees, between -180 and 180. If NULL, the root longitude is chosen randomly according to the stationary probability distribution of the SBM.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For short expected transition distances this function uses the approximation formula by Ghosh et al. (2012). For longer expected transition distances the function uses a truncated approximation of the series representation of SBM transition densities (Perrin 1928).
</p>
<p>The pair <code>time_grid</code> and <code>diffusivity</code> can be used to define a time-dependent diffusivity, with time counted from the root to the tips (i.e. root has time 0) in the same units as edge lengths. For example, to define a diffusivity that varies linearly with time, you only need to specify the diffusivity at two time points (one at 0, and one at the time of the youngest tip), i.e. <code>time_grid</code> and <code>diffusivity</code> would each have length 2. Note that <code>time_grid</code> should cover the full time range of the tree; otherwise, <code>diffusivity</code> will be extrapolated as a constant when needed.
</p>
<p>If <code>tree$edge.length</code> is missing, each edge in the tree is assumed to have length 1. The tree may include multifurcations as well as monofurcations.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, specifying whether the simulation was successful. If <code>FALSE</code>, then an additional return variable <code>error</code> will contain a brief description of the error that occurred, and all other return variables may be undefined.
</p>
</td></tr>
<tr><td><code>tip_latitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing simulated decimal latitudes for each tip in the tree.
</p>
</td></tr>
<tr><td><code>tip_longitudes</code></td>
<td>

<p>Numeric vector of length Ntips, listing simulated decimal longitudes for each tip in the tree.
</p>
</td></tr>
<tr><td><code>node_latitudes</code></td>
<td>

<p>Numeric vector of length Nnodes, listing simulated decimal latitudes for each internal node in the tree.
</p>
</td></tr>
<tr><td><code>node_longitudes</code></td>
<td>

<p>Numeric vector of length Nnodes, listing simulated decimal longitudes for each internal node in the tree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>F. Perrin (1928). Etude mathematique du mouvement Brownien de rotation. 45:1-51.
</p>
<p>D. R. Brillinger (2012). A particle migrating randomly on a sphere. in Selected Works of David Brillinger. Springer.
</p>
<p>A. Ghosh, J. Samuel, S. Sinha (2012). A Gaussian for diffusion on the sphere. Europhysics Letters. 98:30003.
</p>
<p>S. Louca (2021). Phylogeographic estimation and simulation of global diffusive dispersal. Systematic Biology. 70:340-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_ou_model">simulate_ou_model</a></code>, 
<code><a href="#topic+simulate_rou_model">simulate_rou_model</a></code>,
<code><a href="#topic+simulate_bm_model">simulate_bm_model</a></code>,
<code><a href="#topic+fit_sbm_const">fit_sbm_const</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=100)$tree

# simulate SBM on the tree
simulation = simulate_sbm(tree, radius=6371, diffusivity=1e4,
                          root_latitude=0, root_longitude=0)

# plot latitudes and longitudes of the tips
plot(simulation$tip_latitudes,simulation$tip_longitudes)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate_tdsse'>
Simulate a time-dependent Discrete-State Speciation and Extinction (tdSSE) model.
</h2><span id='topic+simulate_tdsse'></span>

<h3>Description</h3>

<p>Simulate a random phylogenetic tree in forward time based on a Poissonian speciation/extinction (birth/death) process, whereby birth and death rates are determined by a co-evolving discrete trait. New species are added (born) by splitting of a randomly chosen extant tip. The discrete trait, whose values determine birth/death rates, can evolve in two modes: (A) Anagenetically, i.e. according to a discrete-space continuous-time Markov process along each edge, with fixed or time-dependent transition rates between states, and/or (B) cladogenetically, i.e. according to fixed or time-dependent transition probabilities between states at each speciation event. This model class includes the Multiple State Speciation and Extinction (MuSSE) model described by FitzJohn et al. (2009), as well as the Cladogenetic SSE (ClaSSE) model described by Goldberg and Igis (2012). Optionally, the model can be turned into a Hidden State Speciation and Extinction model (Beaulieu and O'meara, 2016), by replacing the simulated tip/node states with &quot;proxy&quot; states, thus hiding the original states actually influencing speciation/extinction rates. This function is similar to <code><a href="#topic+simulate_dsse">simulate_dsse</a></code>, the main difference being that state-specific speciation/extinction rates as well as state transition rates can be time-dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_tdsse(Nstates,
               NPstates             = NULL,
               proxy_map            = NULL,
               time_grid            = NULL,
               parameters           = list(),
               splines_degree       = 1,
               start_state          = NULL,
               max_tips             = NULL, 
               max_time             = NULL,
               max_events           = NULL,
               sampling_fractions   = NULL,
               reveal_fractions     = NULL,
               coalescent           = TRUE,
               as_generations       = FALSE,
               no_full_extinction   = TRUE,
               Nsplits              = 2, 
               tip_basename         = "", 
               node_basename        = NULL,
               include_birth_times  = FALSE,
               include_death_times  = FALSE,
               include_labels       = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_tdsse_+3A_nstates">Nstates</code></td>
<td>

<p>Integer, specifying the number of possible discrete states a tip can have, influencing speciation/extinction rates. For example, if <code>Nstates==2</code> then this corresponds to the common Binary State Speciation and Extinction (BiSSE) model (Maddison et al., 2007). In the case of a HiSSE model, <code>Nstates</code> refers to the total number of diversification rate categories, as described by Beaulieu and O'meara (2016).
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_npstates">NPstates</code></td>
<td>

<p>Integer, optionally specifying a number of &quot;proxy-states&quot; that are observed instead of the underlying speciation/extinction-modulating states. To simulate a HiSSE model, this should be smaller than <code>Nstates</code>. Each state corresponds to a different proxy-state, as defined using the variable <code>proxy_map</code> (see below). For BiSSE/MuSSE with no hidden states, <code>NPstates</code> can be set to either <code>NULL</code> or equal to <code>Nstates</code>, and proxy-states are equivalent to states.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_proxy_map">proxy_map</code></td>
<td>

<p>Integer vector of size <code>Nstates</code> and with values in 1,..,<code>NPstates</code>, specifying the correspondence between states (i.e. diversification-rate categories) and (observed) proxy-states, in a HiSSE model. Specifically, <code>proxy_map[s]</code> indicates which proxy-state the state s is represented by. Each proxy-state can represent multiple states (i.e. proxies are ambiguous), but each state must be represented by exactly one proxy-state. For non-HiSSE models, set this to <code>NULL</code>. See below for more details.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_time_grid">time_grid</code></td>
<td>

<p>Numeric vector listing discrete times in ascending order, used to define the time-dependent rates of the model. The time grid should generally cover the maximum possible simulation time, otherwise it will be polynomially extrapolated (according to <code>splines_degree</code>).
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_parameters">parameters</code></td>
<td>

<p>A named list specifying the time-dependent model parameters, including optional anagenetic and/or cladogenetic transition rates between states, as well as the mandatory state-dependent birth/death rates (see details below).
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0, 1, 2 or 3, specifying the polynomial degree of time-dependent model parameters (birth_rates, death_rates, transition_rates) between time-grid points. For example, <code>splines_degree=1</code> means that rates are to be considered linear between adjacent grid points.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_start_state">start_state</code></td>
<td>

<p>Integer within 1,..,<code>Nstates</code>, specifying the initial state, i.e. of the first lineage created. If left unspecified, this is chosen randomly and uniformly among all possible states.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_max_tips">max_tips</code></td>
<td>

<p>Maximum number of tips in the generated tree, prior to any subsampling. If <code>coalescent=TRUE</code>, this refers to the number of extant tips, prior to subsampling. Otherwise, it refers to the number of extinct + extant tips, prior to subsampling. If <code>NULL</code> or &lt;=0, the number of tips is not limited, so you should use <code>max_time</code> and/or <code>max_time_eq</code> and/or <code>max_events</code> to stop the simulation.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_max_time">max_time</code></td>
<td>

<p>Numeric, maximum duration of the simulation. If <code>NULL</code> or &lt;=0, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_max_events">max_events</code></td>
<td>

<p>Integer, maximum number of speciation/extinction/transition events before halting the simulation. If <code>NULL</code>, this constraint is ignored.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_sampling_fractions">sampling_fractions</code></td>
<td>

<p>A single number, or a numeric vector of size <code>NPstates</code>, listing tip sub-sampling fractions, depending on proxy-state. <code>sampling_fractions[p]</code> is the probability of including a tip in the final tree, if its proxy-state is p. If <code>NULL</code>, all tips (or all extant tips, if <code>coalescent==TRUE</code>) are included in the tree. If a single number, all tips are included with the same probability, i.e. regardless of their proxy-state.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_reveal_fractions">reveal_fractions</code></td>
<td>

<p>Numeric vector of size <code>NPstates</code>, listing reveal fractions of tip proxy-states, depending on proxy state. <code>reveal_fractions[p]</code> is the probability of knowing a tip's proxy-state, if its proxy state is p. Can also be NULL, in which case all tip proxy states will be known.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_coalescent">coalescent</code></td>
<td>

<p>Logical, specifying whether only the coalescent tree (i.e. the tree spanning the extant tips) should be returned. If <code>coalescent==FALSE</code> and the death rate is non-zero, then the tree may include non-extant tips (i.e. tips whose distance from the root is less than the total time of evolution). In that case, the tree will not be ultrametric.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_as_generations">as_generations</code></td>
<td>

<p>Logical, specifying whether edge lengths should correspond to generations. If FALSE, then edge lengths correspond to time.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_no_full_extinction">no_full_extinction</code></td>
<td>

<p>Logical, specifying whether to prevent complete extinction of the tree. Full extinction is prevented by temporarily disabling extinctions whenever the number of extant tips is 1. if <code>no_full_extinction==FALSE</code> and death rates are non-zero, the tree may go extinct during the simulation; if <code>coalescent==TRUE</code>, then the returned tree would be empty, hence the function will return unsuccessfully (i.e. <code>success</code> will be <code>FALSE</code>). By default <code>no_full_extinction</code> is <code>TRUE</code>, however in some special cases it may be desirable to allow full extinctions to ensure that the generated trees are statistically distributed exactly according to the underlying cladogenetic model.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_nsplits">Nsplits</code></td>
<td>

<p>Integer greater than 1. Number of child-tips to generate at each diversification event. If set to 2, the generated tree will be bifurcating. If &gt;2, the tree will be multifurcating.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_include_birth_times">include_birth_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of speciation events (in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_include_death_times">include_death_times</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the times of extinction events (in order of occurrence) will also be returned.
</p>
</td></tr>
<tr><td><code id="simulate_tdsse_+3A_include_labels">include_labels</code></td>
<td>

<p>Logical, specifying whether to include tip-labels and node-labels (if available) as names in the returned state vectors (e.g. <code>tip_states</code> and <code>node_states</code>). In any case, returned states are always listed in the same order as tips and nodes in the tree. Setting this to <code>FALSE</code> may increase computational efficiency for situations where labels are not required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simulate_tdsse</code> can be used to simulate a diversification + discrete-trait evolutionary process, in which birth/death (speciation/extinction) rates at each tip are determined by a tip's current &quot;state&quot;. Lineages can transition between states anagenetically along each edge (according to some Markov transition rates) and/or cladogenetically at each speciation event (according to some transition probabilities). The speciation and extinction rates, as well as the transition rates, may be specified as time-dependent variables, defined as piecewise polynomial functions (natural splines) on a temporal grid.
</p>
<p>In the following, Ngrid refers to the length of the vector <code>time_grid</code>.
The argument <code>parameters</code> should be a named list including one or more of the following elements:
</p>

<ul>
<li><p><code>birth_rates</code>: Numeric 2D matrix of size Nstates x Ngrid, listing the per-capita birth rate (speciation rate) at each state and at each time-grid point. Can also be a single number (same birth rate for all states and at all times).
</p>
</li>
<li><p><code>death_rates</code>: Numeric 2D matrix of size Nstates x Ngrid, listing the per-capita death rate (extinction rate) at each state and at each time-grid point. Can also be a single number (same death rate for all states and at all times) or NULL (no deaths).
</p>
</li>
<li><p><code>transition_matrix_A</code>: Either a 3D numeric array of size Nstates x Nstates x Ngrid, or a 2D numeric matrix of size Nstates x Nstates, listing anagenetic transition rates between states along an edge. If a 3D array, then <code>transition_matrix_A[r,c,t]</code> is the infinitesimal rate for transitioning from state <code>r</code> to state <code>c</code> at time <code>time_grid[t]</code>. If a 2D matrix, <code>transition_matrix_A[r,c]</code> is the time-independent infintesimal rate for transitioning from state <code>r</code> to state <code>c</code>. At each time point (i.e., a fixed <code>t</code>), non-diagonal entries in <code>transition_matrix_A[,,t]</code> must be non-negative, diagonal entries must be non-positive, and the sum of each row must be zero.
</p>
</li>
<li><p><code>transition_matrix_C</code>: Either a 3D numeric array of size Nstates x Nstates x Ngrid, or a 2D numeric matrix of size Nstates x Nstates, listing cladogenetic transition probabilities between states during a speciation event, seperately for each child. If a 3D array, then <code>transition_matrix_C[r,c,t]</code> is the probability that a child emerging at time <code>time_grid[t]</code> will have state <code>c</code>, conditional upon the occurrence of a speciation event, given that the parent had state <code>r</code>, and independently of all other children. If a 2D matrix, then <code>transition_matrix_C[r,c]</code> is the (time-independent) probability that a child will have state <code>c</code>, conditional upon the occurrence of a speciation event, given that the parent had state <code>r</code>, and independently of all other children. Entries must be non-negative, and for any fixed <code>t</code> the sum of each row in <code>transition_matrix[,,t]</code> must be one.
</p>
</li></ul>

<p>If <code>max_time==NULL</code> and <code>max_events==NULL</code>, then the returned tree will always contain <code>max_tips</code> tips. If at any moment during the simulation the tree only includes a single extant tip, and if <code>no_full_extinction=TRUE</code> the death rate is temporarily set to zero to prevent the complete extinction of the tree. If <code>max_tips==NULL</code>, then the simulation is ran as long as specified by <code>max_time</code> and/or <code>max_events</code>. If neither <code>max_time</code>, <code>max_tips</code> nor <code>max_events</code> is <code>NULL</code>, then the simulation halts as soon as the time reaches <code>max_time</code>, or the number of tips (extant tips if <code>coalescent</code> is <code>TRUE</code>) reaches <code>max_tips</code>, or the number of speciation/extinction/transition events reaches <code>max_events</code> whichever occurs first. If <code>max_tips!=NULL</code> and <code>Nsplits&gt;2</code>, then the last diversification even may generate fewer than <code>Nsplits</code> children, in order to keep the total number of tips within the specified limit. Note that this code generates trees in forward time, and halts as soon as one of the halting conditions is met; the halting condition chosen affects the precise distribution from which the generated trees are drawn (Stadler 2011).
</p>
<p>For additional information on simulating HiSSE models see the related function <code><a href="#topic+simulate_dsse">simulate_dsse</a></code>.
</p>
<p>The parameter <code>transition_matrix_C</code> can be used to define ClaSSE models (Goldberg and Igic, 2012) or BiSSE-ness models (Magnuson-Ford and Otto, 2012), although care must be taken to properly define the transition probabilities. Here, cladogenetic transitions occur at probabilities that are defined conditionally upon a speciation event, whereas in other software they may be defined as probability rates.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the simulation was successful. If <code>FALSE</code>, an additional element <code>error</code> (of type character) is included containing an explanation of the error; in that case the value of any of the other elements is undetermined.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted bifurcating (if <code>Nsplits==2</code>) or multifurcating (if <code>Nsplits&gt;2</code>) tree of class &quot;phylo&quot;, generated according to the specified birth/death model. 
</p>
<p>If <code>coalescent==TRUE</code> or if all death rates are zero, and only if <code>as_generations==FALSE</code>, then the tree will be ultrametric. If <code>as_generations==TRUE</code> and <code>coalescent==FALSE</code>, all edges will have unit length.
</p>
</td></tr>
<tr><td><code>root_time</code></td>
<td>

<p>Numeric, giving the time at which the tree's root was first split during the simulation. 
Note that if <code>coalescent==TRUE</code>, this may be later than the first speciation event during the simulation.
</p>
</td></tr>
<tr><td><code>final_time</code></td>
<td>

<p>Numeric, giving the final time at the end of the simulation. If <code>coalescent==TRUE</code>, then this may be greater than the total time span of the tree (since the root of the coalescent tree need not correspond to the first speciation event).
</p>
</td></tr>
<tr><td><code>Nbirths</code></td>
<td>

<p>Numeric vector of size Nstates, listing the total number of birth events (speciations) that occurred at each state. The sum of all entries in <code>Nbirths</code> may be lower than the total number of tips in the tree if death rates were non-zero and <code>coalescent==TRUE</code>, or if <code>Nsplits&gt;2</code>.
</p>
</td></tr>
<tr><td><code>Ndeaths</code></td>
<td>

<p>Numeric vector of size Nstates, listing the total number of death events (extinctions) that occurred at each state.
</p>
</td></tr>
<tr><td><code>Ntransitions_A</code></td>
<td>

<p>2D numeric matrix of size Nstates x Nstates, listing the total number of anagenetic transition events that occurred between each pair of states. For example, <code>Ntransitions_A[1,2]</code> is the number of anagenetic transitions (i.e., within a species) that occured from state 1 to state 2.
</p>
</td></tr>
<tr><td><code>Ntransitions_C</code></td>
<td>

<p>2D numeric matrix of size Nstates x Nstates, listing the total number of cladogenetic transition events that occurred between each pair of states. For example, <code>Ntransitions_C[1,2]</code> is the number of cladogenetic transitions (i.e., from a parent to a child) that occured from state 1 to state 2 during some speciation event. Note that each speciation event will have caused <code>Nsplits</code> transitions, and that the emergence of a child with the same state as the parent is counted as a transition between the same state (diagonal entries in <code>Ntransitions_C</code>).
</p>
</td></tr>
<tr><td><code>tip_states</code></td>
<td>

<p>Integer vector of size Ntips and with values in 1,..,Nstates, listing the state of each tip in the tree.
</p>
</td></tr>
<tr><td><code>node_states</code></td>
<td>

<p>Integer vector of size Nnodes and with values in 1,..,Nstates, listing the state of each node in the tree.
</p>
</td></tr>
<tr><td><code>tip_proxy_states</code></td>
<td>

<p>Integer vector of size Ntips and with values in 1,..,NPstates, listing the proxy state of each tip in the tree. Only included in the case of HiSSE models.
</p>
</td></tr>
<tr><td><code>node_proxy_states</code></td>
<td>

<p>Integer vector of size Nnodes and with values in 1,..,NPstates, listing the proxy state of each node in the tree. Only included in the case of HiSSE models.
</p>
</td></tr>
<tr><td><code>start_state</code></td>
<td>

<p>Integer, specifying the state of the first lineage (either provided during the function call, or generated randomly).
</p>
</td></tr>
<tr><td><code>birth_times</code></td>
<td>

<p>Numeric vector, listing the times of speciation events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root.
</p>
</td></tr>
<tr><td><code>death_times</code></td>
<td>

<p>Numeric vector, listing the times of extinction events during tree growth, in order of occurrence. Note that if <code>coalescent==TRUE</code>, then <code>speciation_times</code> may be greater than the phylogenetic distance to the coalescent root.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>W. P. Maddison, P. E. Midford, S. P. Otto (2007). Estimating a binary character's effect on speciation and extinction. Systematic Biology. 56:701-710.
</p>
<p>R. G. FitzJohn, W. P. Maddison, S. P. Otto (2009). Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology. 58:595-611
</p>
<p>R. G. FitzJohn (2012). Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution. 3:1084-1092
</p>
<p>E. E. Goldberg, B. Igic (2012). Tempo and mode in plant breeding system evolution. Evolution. 66:3701-3709.
</p>
<p>K. Magnuson-Ford, S. P. Otto (2012). Linking the investigations of character evolution and species diversification. The American Naturalist. 180:225-245.
</p>
<p>J. M. Beaulieu and B. C. O'Meara (2016). Detecting hidden diversification shifts in models of trait-dependent speciation and extinction. Systematic Biology. 65:583-601.
</p>
<p>T. Stadler (2011). Simulating trees with a fixed number of extant species. Systematic Biology. 60:676-684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_dsse">simulate_dsse</a></code>,
<code><a href="#topic+simulate_musse">simulate_musse</a></code>,
<code><a href="#topic+fit_musse">fit_musse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# prepare params for time-dependent BiSSE model
# include time-dependent speciation &amp; extinction rates
# as well as time-dependent anagenetic transition rates
Nstates          = 2
reveal_fractions = c(1,0.5)
rarefaction      = 0.5 # species sampling fraction

time2lambda1 = function(times) rep(1,times=length(times))
time2lambda2 = function(times) rep(2,times=length(times))
time2mu1     = function(times) 0.5 + 2.5*exp(-((times-8)**2)/2)
time2mu2     = function(times) 1 + 2*exp(-((times-12)**2)/2)
time_grid    = seq(from=0, to=100, length.out=1000)

time2Q12    = function(times) 1*exp(0.1*times)
time2Q21    = function(times) 2*exp(-0.1*times)
QA          = array(0, dim=c(Nstates,Nstates,length(time_grid)))
QA[1,2,]    = time2Q12(time_grid)
QA[2,1,]    = time2Q21(time_grid)
QA[1,1,]    = -QA[1,2,]
QA[2,2,]    = -QA[2,1,]

parameters = list()
parameters$birth_rates = rbind(time2lambda1(time_grid), time2lambda2(time_grid))
parameters$death_rates = rbind(time2mu1(time_grid), time2mu2(time_grid))
parameters$transition_matrix_A = QA

# simulate time-dependent BiSSE model
cat(sprintf("Simulating tMuSSE model..\n"))
sim = castor::simulate_tdsse(Nstates            = Nstates,
                            time_grid           = time_grid,
                            parameters          = parameters, 
                            splines_degree      = 1,
                            max_tips            = 10000/rarefaction,
                            sampling_fractions  = rarefaction,
                            reveal_fractions    = reveal_fractions,
                            coalescent          = TRUE,
                            no_full_extinction  = TRUE)
if(!sim$success){
    cat(sprintf("ERROR: %s\n",sim$error))
}else{
    # print some summary info about the generated tree
    tree        = sim$tree
    Ntips       = length(tree$tip.label)
    root_age    = get_tree_span(tree)$max_distance
    root_time   = sim$final_time - root_age
    tip_states  = sim$tip_states
    Nknown_tips = sum(!is.na(tip_states))
    cat(sprintf("Note: Simulated tree has root_age = %g\n",root_age))
    cat(sprintf("Note: %d tips have known state\n", Nknown_tips));
}

## End(Not run)</code></pre>

<hr>
<h2 id='spline_coefficients'>
Get the polynomial coefficients of a spline.
</h2><span id='topic+spline_coefficients'></span>

<h3>Description</h3>

<p>Given a natural spline function <code class="reqn">Y:\R\to\R</code>, defined as a series of Y values on a discrete X grid, obtain its corresponding piecewise polynomial coefficients. Supported splines degrees are 0 (Y is piecewise constant), 1 (piecewise linear), 2 (piecewise quadratic) and 3 (piecewise cubic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_coefficients(Xgrid, 
                    Ygrid,
                    splines_degree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_coefficients_+3A_xgrid">Xgrid</code></td>
<td>

<p>Numeric vector, listing x-values in ascending order.
</p>
</td></tr>
<tr><td><code id="spline_coefficients_+3A_ygrid">Ygrid</code></td>
<td>

<p>Numeric vector of the same length as <code>Xgrid</code>, listing the values of Y on <code>Xgrid</code>.
</p>
</td></tr>
<tr><td><code id="spline_coefficients_+3A_splines_degree">splines_degree</code></td>
<td>

<p>Integer, either 0, 1, 2 or 3, specifying the polynomial degree of the spline curve Y between grid points. For example, 0 means Y is piecewise constant, 1 means Y is piecewise linear and so on.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline functions are returned by some of castor's fitting routines, so <code>spline_coefficients</code> is meant to aid with the further analysis of such functions. A spline function of degree <code class="reqn">D\geq1</code> has continuous derivatives up to degree <code class="reqn">D-1</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix of size NR x NC, where NR (number of rows) is equal to the length of <code>Xgrid</code> and NC (number of columns) is equal to <code>splines_degree+1</code>. The r-th row lists the polynomial coefficients (order 0, 1 etc) of the spline within the interval [Xgrid[r],Xgrid[r+1]]. For exampe, for a spline of order 2, the value at X=0.5*(Xgrid[1]+Xgrid[2]) will be equal to C[1,1]+C[1,2]*X+C[1,3]*X*X, where C is the matrix of coefficients.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_spline">evaluate_spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following code defines a quadratic spline on 20 grid points
# The curve's polynomial coefficients are then determined
# and used to evaluate the spline on a fine grid for plotting.
Xgrid = seq(0,10,length.out=20)
Ygrid = sin(Xgrid)
splines_degree = 2

Ycoeff = castor::spline_coefficients(Xgrid, Ygrid, splines_degree)

plot(Xgrid, Ygrid, type='p')

for(g in seq_len(length(Xgrid)-1)){
  Xtarget = seq(Xgrid[g], Xgrid[g+1], length.out=100)
  Ytarget = rep(Ycoeff[g,1], length(Xtarget))
  for(p in seq_len(splines_degree)){
    Ytarget = Ytarget + (Xtarget^p) * Ycoeff[g,p+1];
  }
  lines(Xtarget, Ytarget, type='l', col='red')
}
</code></pre>

<hr>
<h2 id='split_tree_at_height'>
Split a tree into subtrees at a specific height.
</h2><span id='topic+split_tree_at_height'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a specific distance from the root (&ldquo;height&rdquo;), split the tree into subtrees at the specific height. This corresponds to drawing the tree in rectangular layout and trimming everything below the specified phylogenetic distance from the root: What is obtained is a set of separated subtrees. The tips of the original tree are spread across those subtrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_tree_at_height(tree, height = 0, by_edge_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_tree_at_height_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="split_tree_at_height_+3A_height">height</code></td>
<td>

<p>Numeric, specifying the phylogenetic distance from the root at which to split the tree. If &lt;=0, the original tree is returned as the sole subtree.
</p>
</td></tr>
<tr><td><code id="split_tree_at_height_+3A_by_edge_count">by_edge_count</code></td>
<td>

<p>Logical. Instead of considering edge lengths, consider edge counts as phylogenetic distance. This is the same as if all edges had length equal to 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to generate multiple smaller trees from one large tree, with each subtree having a time span equal to or lower than a certain threshold. The input tree may include multifurcations (i.e. nodes with more than 2 children) as well as monofurcations (i.e. nodes with only one child).
</p>
<p>Note that while edges are cut exactly at the specified distance from the root, the cut point does not become the root node of the obtained subtree; rather, the first node encountered after the cut will become the subtree's root. The length of the remaining edge segment leading into this node will be used as <code>root.edge</code> in the returned subtree.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Nsubtrees</code></td>
<td>

<p>Integer, the number of subtrees obtained.
</p>
</td></tr>
<tr><td><code>subtrees</code></td>
<td>

<p>A list of length Nsubtrees, each element of which is a named list containing the following elements:
</p>

<ul>
<li> <p><code>tree</code>: A rooted tree of class &quot;phylo&quot;, representing a subtree obtained from the original tree.
</p>
</li>
<li> <p><code>new2old_clade</code>: An integer vector of length NStips+NSnodes (where NStips is the number of tips and NSnodes the number of nodes of the subtree), mapping subtree tip and node indices (i.e., 1,..,NStips+NSnodes) to tip and node indices in the original tree.
</p>
</li>
<li> <p><code>new2old_edge</code>: Integer vector of length NSedges (=number of edges in the subtree), mapping subtree edge indices (i.e., 1,..,NSedges) to edge indices in the original tree.
</p>
</li></ul>

</td></tr>
<tr><td><code>clade2subtree</code></td>
<td>

<p>Integer vector of length Ntips+Nnodes and containing values from 1 to Nsubtrees, mapping tip and node indices of the original tree to their assigned subtree.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim_tree_at_height">trim_tree_at_height</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),
                            max_tips=100)$tree

# split tree halfway towards the root
root_age = get_tree_span(tree)$max_distance
splitting = split_tree_at_height(tree, height=0.5*root_age)

# print number of subtrees obtained
cat(sprintf("Obtained %d subtrees\n",splitting$Nsubtrees))
</code></pre>

<hr>
<h2 id='tree_distance'>
Calculate the distance between two trees.
</h2><span id='topic+tree_distance'></span>

<h3>Description</h3>

<p>Given two rooted phylogenetic trees with identical tips, calculate their difference using a distance metric or pseudometric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_distance(  treeA, 
                treeB,
                tipsA2B       = NULL,
                metric        = "RFrooted",
                normalized    = FALSE,
                NLeigenvalues = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_distance_+3A_treea">treeA</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="tree_distance_+3A_treeb">treeB</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. Depending on the metric used, this tree may need to have the same number of tips as <code>treeA</code> (see details below).
</p>
</td></tr>
<tr><td><code id="tree_distance_+3A_tipsa2b">tipsA2B</code></td>
<td>

<p>Optional integer vector of size Ntips, mapping <code>treeA</code> tip indices to <code>treeB</code> tip indices (i.e. <code>tipsA2B[a]</code> is the tip index in <code>treeB</code> corresponding to tip index <code>a</code> in <code>treeA</code>). The mapping must be one-to-one. If left unspecified, it is determined by matching tip labels between the two trees (this assumes that the same tip labels are used in both trees). Only relevant if the metric requires tip matching (i.e., considers labeled trees).
</p>
</td></tr>
<tr><td><code id="tree_distance_+3A_metric">metric</code></td>
<td>

<p>Character, specifying the distance measure to be used. Currently the Robinson-Foulds metric for rooted trees (&quot;RFrooted&quot;), the mean-path-difference (&quot;MeanPathLengthDifference&quot;), &quot;WassersteinNodeAges&quot; and &quot;WassersteinLaplacianSpectrum&quot; are implemented. Note that these distances are not necessarily metrics in the strict mathematical sense; in particular, non-identical trees can sometimes have a zero distance.
</p>
<p>&quot;RFrooted&quot; counts the number of clusters (sets of tips descending from a node) in either of the trees but not shared by both trees (Robinson and Foulds, 1981; Day, 1985); this metric does not take into account branch lengths and depends on the position of the root. 
</p>
<p>&quot;MeanPathLengthDifference&quot; is the square root of the mean squared difference of patristic distances (shortest path lengths) between tip pairs, as described by Steel and Penny (1993); this metric takes into account path lengths and does not depend on the position of the root.
</p>
<p>&quot;WassersteinNodeAges&quot; calculates the first Wasserstein distance (Ramdas et al. 2017) between the distributions of node ages in the two trees. It depends on the branch lengths and the rooting, but does not depend on tip labeling nor topology (as long as node ages are the same). Hence, this is only a 'pseudometric' in the space of unlabeled trees - any two trees with identical node ages will have distance 0.
</p>
<p>&quot;WassersteinLaplacianSpectrum&quot; calculates the first Wasserstein distance between the spectra (sets of eigenvalues) of the modified graph Laplacians (Lewitus and Morlon, 2016). This distance depends on tree topology and branch lengths, but not on tip labeling nor on the rooting. Note that Lewitus and Morlon measured the distance between the Laplacian spectra in a different way than here. Also note that if <code>NLeigenvalues&gt;0</code>, only a subset of the eigenvalues may be considered.
</p>
</td></tr>
<tr><td><code id="tree_distance_+3A_normalized">normalized</code></td>
<td>

<p>Logical, specifying whether the calculated distance should be normalized to be between 0 and 1. For the Robinson-Foulds distance, the distance will be normalized by dividing it by the total number of nodes in the two trees. For <code>MeanPathLengthDifference</code>, normalization is done by dividing each path-length difference by the maximum of the two path-lengths considered. For <code>WassersteinNodeAges</code>, normalization is achieved by scaling all node ages relative to the oldest node age in any of the two trees (hence times are converted to relative times). Note that normalized distances may no longer satisfy the triangle inequality required for metrics, i.e. the resulting distance function may not be a metric in the mathematical sense.
</p>
</td></tr>
<tr><td><code id="tree_distance_+3A_nleigenvalues">NLeigenvalues</code></td>
<td>

<p>Integer, number of top eigenvalues (i.e., with largest magnitude) to consider from the Graph-Laplacian's spectrum (e.g., for the metric &quot;WassersteinLaplacianSpectrum&quot;). This option is mostly provided for computational efficiency reasons, because it is cheaper to compute a small subset of eigenvalues rather than the entire spectrum. If &lt;=0, all eigenvalues are considered, which can substantially increase computation time and memory for large trees.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For some metrics (&quot;RFrooted&quot;, &quot;MeanPathLengthDifference&quot;), the trees must have the same number of tips and their tips must be matched one-to-one.
If the trees differ in theis tips, they must be pruned down to their common set of tips. If tips have different labels in the two trees, but are nevertheless equivalent, the mapping between the two trees must be provided using <code>tipsA2B</code>. 
</p>
<p>The trees may include multi-furcations as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>Note that under some Robinson-Foulds variants the trees can be unrooted; in this present implementation trees must be rooted and the placement of the root influences the distance, following the definition by Day (1985).
</p>


<h3>Value</h3>

<p>A single non-negative number, representing the distance between the two trees.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Robinson, D. R., Foulds, L. R. (1981). Comparison of phylogenetic trees. Mathematical Biosciences. 53: 131-147.
</p>
<p>Day, W. H. E. (1985). Optimal algorithms for comparing trees with labeled leaves. Journal of Classification. 2:7-28.
</p>
<p>Steel, M. A., Penny D. (1993). Distributions of tree comparison metrics - Some new results. Systematic Biology. 42:126-141.
</p>
<p>Ramdas, A. et al. (2017). On Wasserstein two-sample testing and related families of nonparametric tests. Entropy. 19(2):47.
</p>
<p>Lewitus, E. and Morlon, H. (2016). Characterizing and comparing phylogenies from their laplacian spectrum. Systematic Biology. 65:495-507.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+congruent_divergence_times">congruent_divergence_times</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 1000
treeA = generate_random_tree(list(birth_rate_intercept=1),
                            max_tips=Ntips)$tree
                            
# create a second tree with slightly different topology
treeB = treeA
shuffled_tips = sample.int(Ntips, size=Ntips/10, replace=FALSE)
treeB$tip.label[shuffled_tips] = treeB$tip.label[sample(shuffled_tips)]

# calculate Robinson-Foulds distance between trees
distance = tree_distance(treeA, treeB, metric="RFrooted")
</code></pre>

<hr>
<h2 id='tree_from_branching_ages'>
Generate a random timetree with specific branching ages.
</h2><span id='topic+tree_from_branching_ages'></span>

<h3>Description</h3>

<p>Generate a random timetree based on specific branching ages (time before present), by randomly connecting tips and nodes. The tree's root will have the greatest age provided. The tree thus corresponds to a homogenous birth-death model, i.e. where at any given time point all lineages were equally likely to split or go extinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_from_branching_ages(   branching_ages,
                            tip_basename       = "",
                            node_basename      = NULL,
                            edge_basename      = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_from_branching_ages_+3A_branching_ages">branching_ages</code></td>
<td>

<p>Numeric vector of size Nnodes, listing branching ages (time before present) in ascending order. The last entry will be the root age.
</p>
</td></tr>
<tr><td><code id="tree_from_branching_ages_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="tree_from_branching_ages_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="tree_from_branching_ages_+3A_edge_basename">edge_basename</code></td>
<td>

<p>Character. Prefix to be used for edge labels (e.g. &quot;edge.&quot;). Edge labels (if included) are stored in the character vector <code>edge.label</code>. If <code>NULL</code>, no edge labels will be included in the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tips in the generated tree are guaranteed to be connected in random order, i.e. this function can also be used to connect a random set of labeled tips into a tree. Nodes will be indexed in chronological order (i.e. in order of decreasing age). In particular, node 0 will be the root.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the tree was successfully generated. If <code>FALSE</code>, the only other value returned is <code>error</code>.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted, ultrametric bifurcating tree of class &quot;phylo&quot;, with the requested branching ages.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, containing an explanation of the error that occurred. Only included if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_from_sampling_branching_ages">tree_from_sampling_branching_ages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Nnodes              = 100
branching_intervals = rexp(n=Nnodes, rate=1)
branching_ages      = cumsum(branching_intervals)
tree                = castor::tree_from_branching_ages(branching_ages)$tree
</code></pre>

<hr>
<h2 id='tree_from_sampling_branching_ages'>
Generate a random timetree with specific tip/sampling and node/branching ages.
</h2><span id='topic+tree_from_sampling_branching_ages'></span>

<h3>Description</h3>

<p>Generate a random bifurcating timetree based on specific sampling (tip) ages and branching (node) ages, by randomly connecting tips and nodes. Age refers to time before present, i.e., measured in reverse chronological direction. The tree's root will have the greatest age provided. The tree thus corresponds to a homogenous birth-death-sampling model, i.e. where at any given time point all lineages were equally likely to split, be sampled or go extinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_from_sampling_branching_ages(sampling_ages,
                                  branching_ages,
                                  tip_basename  = "",
                                  node_basename = NULL,
                                  edge_basename = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_from_sampling_branching_ages_+3A_sampling_ages">sampling_ages</code></td>
<td>

<p>Numeric vector of size Ntips, listing sampling ages (time before present) in ascending order.
</p>
</td></tr>
<tr><td><code id="tree_from_sampling_branching_ages_+3A_branching_ages">branching_ages</code></td>
<td>

<p>Numeric vector of size Nnodes, listing branching ages (time before present) in ascending order. The last entry will be the root age. Note that Nnodes must be equal to Ntips-1.
</p>
</td></tr>
<tr><td><code id="tree_from_sampling_branching_ages_+3A_tip_basename">tip_basename</code></td>
<td>

<p>Character. Prefix to be used for tip labels (e.g. &quot;tip.&quot;). If empty (&quot;&quot;), then tip labels will be integers &quot;1&quot;, &quot;2&quot; and so on.
</p>
</td></tr>
<tr><td><code id="tree_from_sampling_branching_ages_+3A_node_basename">node_basename</code></td>
<td>

<p>Character. Prefix to be used for node labels (e.g. &quot;node.&quot;). If <code>NULL</code>, no node labels will be included in the tree.
</p>
</td></tr>
<tr><td><code id="tree_from_sampling_branching_ages_+3A_edge_basename">edge_basename</code></td>
<td>

<p>Character. Prefix to be used for edge labels (e.g. &quot;edge.&quot;). Edge labels (if included) are stored in the character vector <code>edge.label</code>. If <code>NULL</code>, no edge labels will be included in the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tips and nodes will be indexed in chronological order (i.e. in order of decreasing age). In particular, node 0 will be the root. Note that not all choices of <code>sampling_ages</code> and <code>branching_ages</code> are permissible. Specifically, at any given age T, the number of sampling events with age equal or smaller than T must be greater than the number of branching events with age equal or smaller than T. If this requirement is not satisfied, the function will return with an error.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>
<table>
<tr><td><code>success</code></td>
<td>

<p>Logical, indicating whether the tree was successfully generated. If <code>FALSE</code>, the only other value returned is <code>error</code>.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>

<p>A rooted, ultrametric bifurcating tree of class &quot;phylo&quot;, with the requested tip and node ages.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Character, containing an explanation of the error that occurred. Only included if <code>success==FALSE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_from_branching_ages">tree_from_branching_ages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampling_ages   = c(0, 0.1, 0.15, 0.25, 0.9, 1.9, 3)
branching_ages  = c(0.3, 0.35, 0.4, 1.1, 2.5, 3.5)
tree = tree_from_sampling_branching_ages(sampling_ages, branching_ages)$tree
</code></pre>

<hr>
<h2 id='tree_imbalance'>
Calculate various imbalance statistics for a tree.
</h2><span id='topic+tree_imbalance'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree, calculate various &quot;imbalance&quot; statistics of the tree, such as Colless' Index or Sackin's Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_imbalance(tree, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_imbalance_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="tree_imbalance_+3A_type">type</code></td>
<td>

<p>Character, specifying the statistic to be calculated. Must be one of &quot;Colless&quot; (Shao 1990), &quot;Colless_normalized&quot; (Colless normalized by the maximum possible value in the case of a bifurcating tree), &quot;Sackin&quot; (Sackin 1972) or &quot;Blum&quot; (Blum and Francois 2006, Eq. 5).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree may include multifurcations and monofurcations. Note that the Colless Index is traditionally only defined for bifurcating trees. For non-bifurcating trees this function calculates a generalization of the index, by summing over all children pairs at each node.
</p>
<p>The Blum statistic is the sum of natural logarithms of the sizes (number of descending tips) of non-monofurcating nodes. 
</p>


<h3>Value</h3>

<p>Numeric, the requested imbalance statistic of the tree.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>M. J. Sackin (1972). &quot;Good&quot; and &quot;Bad&quot; Phenograms. Systematic Biology. 21:225-226.
</p>
<p>K.T. Shao, R. R. Sokal (1990). Tree Balance. Systematic Biology. 39:266-276.
</p>
<p>M. G. B. Blum and O. Francois (2006). Which random processes describe the Tree of Life? A large-scale study of phylogenetic tree imbalance. Systematic Biology. 55:685-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
Ntips = 100
tree = generate_random_tree(list(birth_rate_intercept=1),Ntips)$tree

# calculate Colless statistic
colless_index = tree_imbalance(tree, type="Colless")
</code></pre>

<hr>
<h2 id='trim_tree_at_height'>
Trim a rooted tree down to a specific height.
</h2><span id='topic+trim_tree_at_height'></span>

<h3>Description</h3>

<p>Given a rooted phylogenetic tree and a maximum allowed distance from the root (&ldquo;height&rdquo;), remove tips and nodes and shorten the remaining terminal edges so that the tree's height does not exceed the specified threshold. This corresponds to drawing the tree in rectangular layout and trimming everything beyond a specific phylogenetic distance from the root. Tips or nodes at the end of trimmed edges are kept, and the affected edges are shortened. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_tree_at_height(tree, height = Inf, by_edge_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_tree_at_height_+3A_tree">tree</code></td>
<td>

<p>A rooted tree of class &quot;phylo&quot;. The root is assumed to be the unique node with no incoming edge.
</p>
</td></tr>
<tr><td><code id="trim_tree_at_height_+3A_height">height</code></td>
<td>

<p>Numeric, specifying the phylogenetic distance from the root at which to trim.
</p>
</td></tr>
<tr><td><code id="trim_tree_at_height_+3A_by_edge_count">by_edge_count</code></td>
<td>

<p>Logical. Instead of considering edge lengths, consider edge counts as phylogenetic distance. This is the same as if all edges had length equal to 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tree may include multi-furcations (i.e. nodes with more than 2 children) as well as mono-furcations (i.e. nodes with only one child).
</p>
<p>Tip labels and uncollapsed node labels of the collapsed tree are inheritted from the original tree. Labels of tips that used to be nodes (i.e. of which all descendants have been removed) will be the node labels from the original tree. If the input tree has no node names, it is advised to first add node names to avoid <code>NA</code> in the resulting tip names.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>

<p>A new rooted tree of class &quot;phylo&quot;, representing the trimmed tree.
</p>
</td></tr>
<tr><td><code>Nedges_trimmed</code></td>
<td>

<p>Integer. Number of edges trimmed (shortened).
</p>
</td></tr>
<tr><td><code>Nedges_removed</code></td>
<td>

<p>Integer. Number of edges removed.
</p>
</td></tr>
<tr><td><code>new2old_clade</code></td>
<td>

<p>Integer vector of length equal to the number of tips+nodes in the trimmed tree, with values in 1,..,Ntips+Nnodes, mapping tip/node indices of the trimmed tree to tip/node indices in the original tree. In particular,
</p>
<p><code>c(tree$tip.label,tree$node.label)[new2old_clade]</code>
</p>
<p>will be equal to:
</p>
<p><code>c(trimmed_tree$tip.label,trimmed_tree$node.label)</code>.
</p>
</td></tr>
<tr><td><code>new2old_edge</code></td>
<td>

<p>Integer vector of length equal to the number of edges in the trimmed tree, with values in 1,..,Nedges, mapping edge indices of the trimmed tree to edge indices in the original tree. In particular, <code>tree$edge.length[new2old_edge]</code> will be equal to <code>trimmed_tree$edge.length</code> (if edge lengths are available).
</p>
</td></tr>
<tr><td><code>new_edges_trimmed</code></td>
<td>

<p>Integer vector, listing edge indices in the trimmed tree that we originally longer edges and have been trimmed. In other words, these are the edges that &quot;crossed&quot; the trimming height.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_tree_at_height">split_tree_at_height</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree, include node names
tree = generate_random_tree(list(birth_rate_intercept=1),
                            max_time=1000,
                            node_basename="node.")$tree

# print number of tips
cat(sprintf("Simulated tree has %d tips\n",length(tree$tip.label)))

# trim tree at height 500
trimmed = trim_tree_at_height(tree, height=500)$tree

# print number of tips in trimmed tree
cat(sprintf("Trimmed tree has %d tips\n",length(trimmed$tip.label)))
</code></pre>

<hr>
<h2 id='write_tree'>
Write a tree in Newick (parenthetic) format.
</h2><span id='topic+write_tree'></span>

<h3>Description</h3>

<p>Write a phylogenetic tree to a file or a string, in Newick (parenthetic) format. If the tree is unrooted, it is first rooted internally at the first node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_tree (tree, 
            file                 = "",
            append               = FALSE,
            digits               = 10,
            quoting              = 0,
            include_edge_labels  = FALSE,
            include_edge_numbers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_tree_+3A_tree">tree</code></td>
<td>

<p>A tree of class &quot;phylo&quot;.
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_file">file</code></td>
<td>

<p>An optional path to a file, to which the tree should be written. The file may be overwritten without warning. If left empty (default), then a string is returned representing the tree.
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_append">append</code></td>
<td>

<p>Logical, specifying whether the tree should be appended at the end of the file, rather than replacing the entire file (if it exists).
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_digits">digits</code></td>
<td>

<p>Integer, number of significant digits for writing edge lengths.
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_quoting">quoting</code></td>
<td>

<p>Integer, specifying whether and how to quote tip/node/edge names, as follows: 0:no quoting at all, 1:always use single quotes, 2:always use double quotes, -1:only quote when needed and prefer single quotes if possible, -2:only quote when needed and prefer double quotes if possible.
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_include_edge_labels">include_edge_labels</code></td>
<td>

<p>Logical, specifying whether to include edge labels (if available) in the output tree, inside square brackets. Note that this is an extension (Matsen et al. 2012) to the standard Newick format, as, and edge labels in square brackets may not be supported by all Newick readers.
</p>
</td></tr>
<tr><td><code id="write_tree_+3A_include_edge_numbers">include_edge_numbers</code></td>
<td>

<p>Logical, specifying whether to include edge numbers (if available) in the output tree, inside curly braces. Note that this is an extension (Matsen et al. 2012) to the standard Newick format, and edge numbers in curly braces may not be supported by all Newick readers.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your tip and/or node and/or edge labels contain special characters (round brackets, commas, colons or quotes) then you should set <code>quoting</code> to non-zero, as appropriate. 
</p>
<p>If the <code>tree</code> contains edge labels (as a character vector named <code>edge.label</code>) and <code>include_edge_labels==TRUE</code>, then edge labels are written in square brackets (Matsen et al. 2012). If <code>tree</code> contains edge numbers (as an integer vector named <code>edge.number</code>) and <code>include_edge_numbers==TRUE</code>, then edge numbers are written in curly braces (Matsen et al. 2012).
</p>
<p>This function is comparable to (but typically much faster than) the <code>ape</code> function <code>write.tree</code>.
</p>


<h3>Value</h3>

<p>If <code>file==""</code>, then a string is returned containing the Newick representation of the tree. Otherwise, the tree is directly written to the file and no value is returned.
</p>


<h3>Author(s)</h3>

<p>Stilianos Louca</p>


<h3>References</h3>

<p>Frederick A. Matsen et al. (2012). A format for  phylogenetic placements. PLOS One. 7:e31009
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_tree">read_tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random tree
tree = generate_random_tree(list(birth_rate_intercept=1),max_tips=100)$tree

# obtain a string representation of the tree in Newick format
Newick_string = write_tree(tree)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
