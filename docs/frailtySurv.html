<!DOCTYPE html><html lang="en"><head><title>Help for package frailtySurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frailtySurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frailtySurv'><p>General semiparametric shared frailty model</p></a></li>
<li><a href='#drs'><p>Diabetic Retinopathy Study (DRS)</p></a></li>
<li><a href='#fitfrail'><p>Fit a shared frailty model</p></a></li>
<li><a href='#fitfrail.control'>
<p>Control parameters for fitfrail</p></a></li>
<li><a href='#genfrail'>
<p>Generate survival data</p></a></li>
<li><a href='#genfrail.control'>
<p>Control parameters for genfrail</p></a></li>
<li><a href='#hdfail'>
<p>Hard drive failure dataset</p></a></li>
<li><a href='#plot.fitfrail'>
<p>Plot method for <code>fitfrail</code> objects</p></a></li>
<li><a href='#plot.simfrail'>
<p>Plot method for <code>simfrail</code> objects</p></a></li>
<li><a href='#simcoxph'>
<p>Simulate survival data and fit models</p></a></li>
<li><a href='#simfrail'>
<p>Simulate survival data and fit models</p></a></li>
<li><a href='#summary.fitfrail'>
<p>Summary of the survival curve</p></a></li>
<li><a href='#vcov.fitfrail'><p>Compute variance/covariance matrix for fitfrail model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>General Semiparametric Shared Frailty Model</td>
</tr>
<tr>
<td>Priority:</td>
<td>optional</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vinnie Monaco &lt;contact@vmonaco.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates and fits semiparametric shared frailty models under a
    wide range of frailty distributions using a consistent and
    asymptotically-normal estimator. Currently supports: gamma, power variance
    function, log-normal, and inverse Gaussian frailty models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vmonaco/frailtySurv/">https://github.com/vmonaco/frailtySurv/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vmonaco/frailtySurv/issues">https://github.com/vmonaco/frailtySurv/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, nleqslv, reshape2, ggplot2, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, parallel, gridExtra</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-13 16:22:08 UTC; vinnie</td>
</tr>
<tr>
<td>Author:</td>
<td>Vinnie Monaco [aut, cre],
  Malka Gorfine [aut],
  Li Hsu [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-13 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='frailtySurv'>General semiparametric shared frailty model</h2><span id='topic+frailtySurv'></span><span id='topic+frailtySurv-package'></span>

<h3>Description</h3>

<p><span class="pkg">frailtySurv</span> provides a suite of functions for generating clustered survival data, fitting multivariate shared frailty models under a wide range of frailty distributions, and visualizing the output. The semi-parametric estimators have better asymptotic properties than most existing implementations, including consistent and asymptotically-normal estimators. Moreover, this is the first package that implements semi-parametric estimators with inverse Gaussian and PVF frailty models.
</p>
<p>The <span class="pkg">frailtySurv</span> package provides functions
</p>

<ul>
<li><p><code><a href="#topic+genfrail">genfrail</a></code> for data generation
</p>
</li>
<li><p><code><a href="#topic+fitfrail">fitfrail</a></code> for model fitting
</p>
</li>
<li><p><code><a href="#topic+simfrail">simfrail</a></code> for survival simulation
</p>
</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
     Package: </td><td style="text-align: left;"> frailtySurv</td>
</tr>
<tr>
 <td style="text-align: left;">
     Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
     Version: </td><td style="text-align: left;"> 1.2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
     Date: </td><td style="text-align: left;"> August 2015</td>
</tr>
<tr>
 <td style="text-align: left;">
     License: </td><td style="text-align: left;"> LGPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
     LazyLoad: </td><td style="text-align: left;"> Yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>John V. Monaco, Malka Gorfine, and Li Hsu.
</p>


<h3>References</h3>

<p>Gorfine M, Zucker DM, Hsu L (2006)
Prospective survival analysis with a general semiparametric shared frailty model: A pseudo full likelihood approach.
<em>Biometrika</em>, <b>93</b>(3), 735-741.
</p>
<p>Zucker DM, Gorfine M, Hsu L (2008)
Pseudo-full likelihood estimation for prospective survival analysis with a general semiparametric shared frailty model: Asymptotic theory.
<em>Journal of Statistical Planning and Inference</em>, <b>138</b>(7), 1998-2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genfrail">genfrail</a></code>, <code><a href="#topic+fitfrail">fitfrail</a></code>, <code><a href="#topic+simfrail">simfrail</a></code>
</p>

<hr>
<h2 id='drs'>Diabetic Retinopathy Study (DRS)</h2><span id='topic+drs'></span>

<h3>Description</h3>

<p>The Diabetic Retinopathy Study (DRS) was performed to determine whether the
onset of blindness in 197 high-risk diabetic patients could be delayed by
laser treatment. The treatment was administered to one
randomly-selected eye in each patient, leaving the other eye untreated. Thus,
there are 394 observations, which are clustered by patient since the level of
risk will tend to vary between patients. A failure occurred when visual
acuity dropped to below 5/200. All patients had a visual acuity of at least
20/100 at the beginning of the study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("drs")
</code></pre>


<h3>Format</h3>

<p>A data frame with 394 rows and 8 columns. There are two rows for each
subject, one row for each eye:
</p>

<dl>
<dt>subject_id</dt><dd><p>unique identifier for each subject</p>
</dd>
<dt>eye</dt><dd><p>subject's eye, where 1=right and 2=left</p>
</dd>
<dt>time</dt><dd><p>the observed follow-up time</p>
</dd>
<dt>status</dt><dd><p>outcome at the end of the observation period, where
1=blindness and 0 indicates censorship</p>
</dd>
<dt>treated</dt><dd><p>a binary covariate, where 1=treated or 0=untreated</p>
</dd>
<dt>age_at_onset</dt><dd><p>age (in years) at the onset of diabetes</p>
</dd>
<dt>laser_type</dt><dd><p>type of laser used for treatment, where 1=xenon, 2=argon</p>
</dd>
<dt>diabetes_type</dt><dd><p>type of diabetes, where 1=juvenile (age at dx &lt; 20) and 2=adult</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://www.mayo.edu/research/documents/diabeteshtml/doc-10027460">https://www.mayo.edu/research/documents/diabeteshtml/doc-10027460</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(drs)

# Clustered by subject
fit.drs &lt;- fitfrail(Surv(time, status) ~ treated + cluster(subject_id), 
                    drs, frailty="gamma")

fit.drs

# Variance estimates
vcov(fit.drs)

# Plot the estimated cumulative baseline hazard
plot(fit.drs, type="cumhaz")

## End(Not run)
</code></pre>

<hr>
<h2 id='fitfrail'>Fit a shared frailty model</h2><span id='topic+fitfrail'></span>

<h3>Description</h3>

<p>Fit an extended Cox proportional hazards model with unobserved shared frailty variate and unspecified baseline hazard function, using a semiparametric estimation technique. See Gorfine et al.~(2006) and Zucker et al.~(2008) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitfrail(formula, dat, control, frailty, weights = NULL, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitfrail_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object, where the lhs is the response as a <code><a href="survival.html#topic+Surv">Surv</a></code> object and rhs contain the terms, including a <code>cluster</code> term for the cluster identifier</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_dat">dat</code></td>
<td>
<p>data.frame that provides context for the formula</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_control">control</code></td>
<td>
<p>control parameters in the form of a <code><a href="#topic+fitfrail.control">fitfrail.control</a></code> object</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_frailty">frailty</code></td>
<td>
<p>string name of the shared frailty distribution</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_weights">weights</code></td>
<td>
<p>vector of cluster weights</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_se">se</code></td>
<td>
<p>logical value, whether the standard errors of the regression coefficient and frailty distribution parameter estimates should be calculated. These are obtained using the <code>vcov.fitfrail</code> function</p>
</td></tr>
<tr><td><code id="fitfrail_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed to <code><a href="#topic+fitfrail.control">fitfrail.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitfrail object representing the shared frailty model.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>the estimated regression coefficients</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the estimated frailty distribution parameters</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>a <code>data.frame</code> with the estimated baseline hazard at each failure time</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>a <code>data.frame</code> with the estimated baseline hazard at all observed times</p>
</td></tr>
<tr><td><code>Lambda.fun</code></td>
<td>
<p>a function of time that returns the estimated baseline</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations performed</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>the parameter trace during estimation</p>
</td></tr>
</table>


<h3>Convergence</h3>

<p>The initial values of the regression coefficients are provided by <code>coxph</code>. Convergence is reached when either the relative reduction or absolute reduction in loglikelihood or score equations (depending on the fitmethod used) are below a threshold. If the maxit iterations are performed before convergence, then the algorithm terminates with a warning.
</p>


<h3>Author(s)</h3>

<p>The estimation method was developed by Malka Gorfine, Li Hsu, and David Zucker; implemented by John V. Monaco.
</p>


<h3>References</h3>

<p>Gorfine M, Zucker DM, Hsu L (2006)
Prospective survival analysis with a general semiparametric shared frailty model: A pseudo full likelihood approach.
<em>Biometrika</em>, <b>93</b>(3), 735-741.
</p>
<p>Monaco JV, Gorfine M, Hsu L (2018)
General Semiparametric Shared Frailty Model: Estimation and Simulation with frailtySurv
<em>Journal of Statistical Software</em>, <b>86</b>(4), 1-42
</p>
<p>Zucker DM, Gorfine M, Hsu L (2008)
Pseudo-full likelihood estimation for prospective survival analysis with a general semiparametric shared frailty model: Asymptotic theory.
<em>Journal of Statistical Planning and Inference</em>, <b>138</b>(7), 1998-2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.fitfrail">vcov.fitfrail</a></code>, <code><a href="#topic+genfrail">genfrail</a></code>, <code><a href="#topic+simfrail">simfrail</a></code>,
<code><a href="survival.html#topic+survfit">survfit</a></code>, <code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 
# Generate synthetic survival data with regression coefficients 
# beta = c(log(2),log(3)) and theta = 2, where the shared frailty 
# values from a gamma distribution with expectation 1 and variance theta.
# 
dat &lt;- genfrail(N=300, K=2, beta=c(log(2),log(3)), 
                frailty="gamma", theta=2,
                censor.rate=0.35,
                Lambda_0=function(t, tau=4.6, C=0.01) (C*t)^tau)

# Fit a shared frailty model
fit &lt;- fitfrail(Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                dat, frailty="gamma")
fit

# The Lambda.fun function can give the estimated cumulative baseline hazard at
# any time
fit$Lambda.fun(seq(0, 100, by=10))

# Fit the DRS data, clustered on patient
data(drs)
fit.drs &lt;- fitfrail(Surv(time, status) ~ treated + cluster(subject_id), 
                    drs, frailty="gamma")
fit.drs

## End(Not run)

# 
# A small example with c(log(2),log(3)) coefficients, Gamma(2) frailty, and
# 0.10 censorship.
# 
dat &lt;- genfrail(N=30, K=2, beta=c(log(2),log(3)), 
                frailty="gamma", theta=2,
                censor.rate=0.10,
                Lambda_0=function(t, tau=4.6, C=0.01) (C*t)^tau)

# Fit a shared frailty model
fit &lt;- fitfrail(Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                dat, frailty="gamma", se=TRUE)
fit

# Summarize the survival curve
head(summary(fit))
</code></pre>

<hr>
<h2 id='fitfrail.control'>
Control parameters for fitfrail
</h2><span id='topic+fitfrail.control'></span>

<h3>Description</h3>

<p>This function creates a list of control parameters needed by fitfrail. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitfrail.control(fitmethod = "loglik", 
                 abstol = 0, reltol = 1e-6, maxit = 100,
                 int.abstol = 0, int.reltol = 1, int.maxit = 1000, 
                 init.beta="coxph", init.theta=NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitfrail.control_+3A_fitmethod">fitmethod</code></td>
<td>
<p>string indicating which fit method should be used: &quot;loglik&quot; or &quot;score&quot;. If &quot;loglik&quot;, then the loglikelihood is maximized directily using optim (L-BFGS-B algorithm). If &quot;score&quot;, then the system of normalized score equations is solved using nleqslv (Newton algorithm).
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_abstol">abstol</code></td>
<td>
<p>numeric absolute tolerance for convergence. If fitmethod is &quot;loglik&quot;, convergence is reached when the absolute reduction in loglikelihood is less than abstol. If fitmethod is &quot;score&quot;, convergence is reached when the absolute value of each normalized score equation is less then abstol.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_reltol">reltol</code></td>
<td>
<p>numeric relative tolerance for convergence. If fitmethod is &quot;loglik&quot;, convergence is reached when the relative reduction in loglikelihood is less than reltol. If fitmethod is &quot;score&quot;, convergence is reached when the relative reduction of each estimated parameter is less than reltol.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_maxit">maxit</code></td>
<td>
<p>integer, maximum number of iterations to perform
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_int.abstol">int.abstol</code></td>
<td>
<p>numeric absolute tolerence for convergence of the numeric integration. Only applicable for frailty distributions that require numerical integration. If 0, then ignore. Default is 0.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_int.reltol">int.reltol</code></td>
<td>
<p>numeric relative tolerence for convergence of the numeric integration. Only applicable for frailty distributions that require numerical integration. If 0, then ignore. Default is 1.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_int.maxit">int.maxit</code></td>
<td>
<p>integer, maximum number of numeric integration function evaluations. Only applicable for frailty distributions that require numerical integration. If 0, then no limit. Default is 100.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_init.beta">init.beta</code></td>
<td>
<p>initial regression coefficients paramater estimates, can be numeric, string, or NULL. If NULL, then a zero vector is used. If &quot;coxph&quot; is passed, then regression coefficients are initialized to the estimates given by coxph (with or without frailty, depending on the init.theta parameter, see below). If numeric, then the initial regression coefficients are specified explicitly.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_init.theta">init.theta</code></td>
<td>
<p>initial frailty distribution parameter estimates, can be numeric, string, or NULL. If NULL, then a sensible starting value is chosen for the specified frailty distribution. If &quot;coxph&quot;, then hat.theta is initialized such that the initial frailty distribution has the same rank correlation as the estimated gamma frailty distribution. This is achieved by assuming gamma frailty and estimating theta using coxph. This estimate is then transferred to the appropriate frailty distribution through Kendall's tau. This method only works well for weak cluster dependence, i.e., small Kendall's tau. If numeric, then the initial frailty distribution parameters are specified explicitly.
</p>
</td></tr>
<tr><td><code id="fitfrail.control_+3A_verbose">verbose</code></td>
<td>
<p>logical value, whether to print a trace of the parameter estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of control parameters.
</p>


<h3>Author(s)</h3>

<p>John V. Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitfrail">fitfrail</a></code></p>

<hr>
<h2 id='genfrail'>
Generate survival data
</h2><span id='topic+genfrail'></span>

<h3>Description</h3>

<p>Generate clustered survival data from a shared frailty model, with hazard function given by
</p>
<p style="text-align: center;"><code class="reqn">S(t)=\exp [-\Lambda_0(t) \omega_i \exp (\beta Z_{ij})]</code>
</p>

<p>where <code class="reqn">\Lambda_0</code> is the cumulative baseline hazard, <code class="reqn">\omega_i</code> is the frailty value of cluster <code class="reqn">i</code>, <code class="reqn">\beta</code> is the regression coefficient vector, and <code class="reqn">Z_ij</code> is the covariate vector for individual <code class="reqn">i</code> in cluster <code class="reqn">j</code>.
</p>
<p>The baseline hazard can be specified by the inverse cumualative baseline hazard, cumulative baseline hazard, or simply the baseline hazard. Frailty values can be sampled from gamma, power variance function (PVF), log-normal, inverse Gaussian, and positive stable distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genfrail(N = 300, K = 2, K.param = c(2, 0), beta = c(log(2)),
         frailty = "gamma", theta = c(2), 
         covar.distr = "normal", covar.param = c(0, 1), covar.matrix = NULL,
         censor.distr = "normal", censor.param = c(130, 15), 
         censor.rate = NULL, censor.time = NULL,
         lambda_0 = NULL, Lambda_0 = NULL, Lambda_0_inv = NULL, 
         round.base = NULL, control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genfrail_+3A_n">N</code></td>
<td>
<p>integer; number of clusters</p>
</td></tr>
<tr><td><code id="genfrail_+3A_k">K</code></td>
<td>
<p>integer, string, or vector; If an integer, the number of members in each cluster. If a string, the name of the distribution to sample the cluster sizes from. This can be one of: &quot;poisson&quot;, &quot;pareto&quot;, or &quot;uniform&quot;. The <code>K.param</code> argument specifies the distribution parameters. If a vector, must be of length N and contains the integer size of each cluster.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_k.param">K.param</code></td>
<td>
<p>vector of the cluster size distribution parameters if <code>K</code> is a string. If &quot;possion&quot;, the vector should contain the rate and truncated value (see <code>rtpois</code>). If &quot;pareto&quot;, the exponent, lower, and upper bounds (see <code>rtzeta</code>). If &quot;uniform&quot;, the lower (noninclusive) and upper (inclusive) bounds.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_beta">beta</code></td>
<td>
<p>vector of regression coefficients.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_frailty">frailty</code></td>
<td>
<p>string name of the frailty distribution. Can be one of: &quot;gamma&quot;, &quot;pvf&quot;, &quot;lognormal&quot;, &quot;invgauss&quot;, &quot;posstab&quot;, or &quot;none&quot;. See <code>dgamma_r</code>,<code>dpvf_r</code>, <code>dlognormal_r</code>, <code>dinvgauss_r</code>, <code>posstab_r</code> for the respective density functions. (Also see the *_c for C implementations of the respective density functions.) </p>
</td></tr>
<tr><td><code id="genfrail_+3A_theta">theta</code></td>
<td>
<p>vector the frailty distribution parameters</p>
</td></tr>
<tr><td><code id="genfrail_+3A_covar.distr">covar.distr</code></td>
<td>
<p>string distribution to sample covariates from. Can be one of: &quot;normal&quot;, &quot;uniform&quot;, &quot;zero&quot;</p>
</td></tr>
<tr><td><code id="genfrail_+3A_covar.param">covar.param</code></td>
<td>
<p>vector covariate distribution parameters.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_covar.matrix">covar.matrix</code></td>
<td>
<p>matrix with dimensions <code>c(NK, length(beta))</code> that contains the desired covariates. If not NULL, this overrides <code>covar.distr</code> and <code>covar.param</code>.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_censor.distr">censor.distr</code></td>
<td>
<p>string censoring distribution to use. Followup times are sampled from the censoring distribution to simulate non-informative right censorship. The censoring distribution can be one of: &quot;normal&quot;, &quot;lognormal&quot;, &quot;uniform&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_censor.param">censor.param</code></td>
<td>
<p>vector of censoring distribution parameters. For normal and lognormal censorship, this should be c(mu,sigma) where mu is the mean and sigma is the standard deviation (Note: this is still the mean and standard deviation for lognormal). For uniform censorship, the vector <code>c(lower, upper)</code> should specify the lower and upper bounds.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_censor.rate">censor.rate</code></td>
<td>
<p>numeric value between 0 and 1 to specify the empirical censoring rate. The mean specified in the <code>censor.param</code> parameter is adjusted to achieve a desired censoring rate if <code>censor.rate</code> is given. Note that the standard deviation (the second parameter in <code>censor.param</code>) must still be specified so that the problem is identifiable. For uniform censorship, the interval given by <code>c(lower, upper)</code> is adjusted to achieve the desired censorship, while keeping the variance fixed (i.e., upper - lower does not change).</p>
</td></tr>
<tr><td><code id="genfrail_+3A_censor.time">censor.time</code></td>
<td>
<p>vector of right-censorship times. This must have length N*K and specifies the right-censoring times of each observation. Note that this overrides all other censor.* params and cannot be used with variable cluster sizes.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_lambda_0">lambda_0</code></td>
<td>
<p>function baseline hazard. Only one of <code>lambda_0</code>, <code>Lambda_0</code>, and <code>Lambda_0_inv</code> need to be specified. Passing the baseline hazard (<code>lambda_0</code>) is the most computationally expensive since this requires numerical integration inside a root-finding algorithm.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_lambda_0">Lambda_0</code></td>
<td>
<p>function cumulative baseline hazard. This overrides <code>lambda_0</code>.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_lambda_0_inv">Lambda_0_inv</code></td>
<td>
<p>function inverse cumulative baseline hazard. This overrides both <code>lambda_0</code> and <code>Lambda_0</code>.</p>
</td></tr>
<tr><td><code id="genfrail_+3A_round.base">round.base</code></td>
<td>
<p>numeric if specified, round the followup times to the nearest <code>round.base</code></p>
</td></tr>
<tr><td><code id="genfrail_+3A_control">control</code></td>
<td>
<p>control parameters in the form of a <code><a href="#topic+genfrail.control">genfrail.control</a></code> object</p>
</td></tr>
<tr><td><code id="genfrail_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed to <code><a href="#topic+genfrail.control">genfrail.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with row-observations is returned.
</p>
<table role = "presentation">
<tr><td><code>family</code></td>
<td>
<p>the cluster</p>
</td></tr>
<tr><td><code>rep</code></td>
<td>
<p>the member within each cluster</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>observed followup time</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>failure indicator</p>
</td></tr>
<tr><td><code>Z1...</code></td>
<td>
<p>covariates, where there are <code>length(beta)</code> Z columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John V. Monaco, Malka Gorfine, and Li Hsu.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitfrail">fitfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the same dataset 3 different ways

# Using the baseline hazard (least efficient)
set.seed(1234)
dat.1 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2,
                  lambda_0=function(t, tau=4.6, C=0.01) (tau*(C*t)^tau)/t)

# Using the cumulative baseline hazard
set.seed(1234)
dat.2 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  Lambda_0 = function(t, tau=4.6, C=0.01) (C*t)^tau)

# Using the inverse cumulative baseline hazard (most efficient)
set.seed(1234)
dat.3 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  Lambda_0_inv=function(t, tau=4.6, C=0.01) (t^(1/tau))/C)

# Generate data with PVF frailty, truncated Poisson cluster sizes, normal
# covariates, and 0.35 censorship from a lognormal distribution
set.seed(1234)
dat.4 &lt;- genfrail(N = 100, K = "poisson", K.param=c(5, 1), 
                  beta = c(log(2),log(3)),
                  frailty = "pvf", theta = 0.3, 
                  covar.distr = "lognormal", 
                  censor.rate = 0.35) # Use the default baseline hazard

# Cluster sizes have size &gt;= 2, summarized by
summary(dat.4)

# An oscillating baseline hazard
set.seed(1234)
dat.5 &lt;- genfrail(lambda_0=function(t, tau=4.6, C=0.01, A=2, f=0.1) 
                              A^sin(f*pi*t) * (tau*(C*t)^tau)/t)

# Uniform censorship with 0.25 censoring rate
set.seed(1234)
dat.6 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  censor.distr = "uniform", 
                  censor.param = c(50, 150), 
                  censor.rate = 0.25,
                  Lambda_0_inv=function(t, tau=4.6, C=0.01) (t^(1/tau))/C)
</code></pre>

<hr>
<h2 id='genfrail.control'>
Control parameters for genfrail
</h2><span id='topic+genfrail.control'></span>

<h3>Description</h3>

<p>This function creates a list of control parameters needed by genfrail. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genfrail.control(censor.reltol = 1e-4,
                 censor.subdivisions = 1000L,
                 crowther.reltol = 1e-4,
                 crowther.subdivisions = 1000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genfrail.control_+3A_censor.reltol">censor.reltol</code></td>
<td>
<p>numeric relative tolerence for convergence of the censorship numerical integration. Default is 0.001.
</p>
</td></tr>
<tr><td><code id="genfrail.control_+3A_censor.subdivisions">censor.subdivisions</code></td>
<td>
<p>integer, maximum number of censorship numerical integration subdivisions. Default is 1000.
</p>
</td></tr>
<tr><td><code id="genfrail.control_+3A_crowther.reltol">crowther.reltol</code></td>
<td>
<p>numeric relative tolerence for convergence of the numerical integration in Crowther's formula. Default is 0.001.
</p>
</td></tr>
<tr><td><code id="genfrail.control_+3A_crowther.subdivisions">crowther.subdivisions</code></td>
<td>
<p>integer, maximum number of numerical integration subdivisions in Crowther's formula. Default is 1000.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of control parameters.
</p>


<h3>Author(s)</h3>

<p>John V. Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genfrail">genfrail</a></code></p>

<hr>
<h2 id='hdfail'>
Hard drive failure dataset
</h2><span id='topic+hdfail'></span>

<h3>Description</h3>

<p>This dataset contains the observed follow-up times and SMART statistics of 52k unique hard drives.
</p>
<p>Daily snapshots of a large backup storage provider over 2 years were made publicly available. On each day, the Self-Monitoring, Analysis, and Reporting Technology (SMART) statistics of operational drives are recorded. When a hard drive is no longer operational, it is marked as a failure and removed from the subsequent daily snapshots. New hard drives are also continuously added to the population. In total, there are over 52k unique hard drives over approximately 2 years and 2885 (5.5%) failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("hdfail")</code></pre>


<h3>Format</h3>

<p>A data frame with 52422 observations on the following 8 variables.
</p>

<dl>
<dt><code>serial</code></dt><dd><p>unique serial number of the hard drive</p>
</dd>
<dt><code>model</code></dt><dd><p>hard drive model</p>
</dd>
<dt><code>time</code></dt><dd><p>the observed followup time</p>
</dd>
<dt><code>status</code></dt><dd><p>failure indicator</p>
</dd>
<dt><code>temp</code></dt><dd><p>temperature in Celsius</p>
</dd>
<dt><code>rsc</code></dt><dd><p>binary covariate, where 1 indicates sectors that encountered read, write, or verification errors</p>
</dd>
<dt><code>rer</code></dt><dd><p>binary covariate, where 1 indicates a non-zero rate of errors that occur in hardware when reading from data from disk.</p>
</dd>
<dt><code>psc</code></dt><dd><p>binary covariate, where 1 indicates there were sectors waiting to be remapped due to an unrecoverable error.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.backblaze.com/cloud-storage/resources/hard-drive-test-data">https://www.backblaze.com/cloud-storage/resources/hard-drive-test-data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hdfail)

# Select only Western Digital hard drives
dat &lt;- subset(hdfail, grepl("WDC", model))

fit.hd &lt;- fitfrail(Surv(time, status) ~ temp + rer + rsc 
                                      + psc + cluster(model), 
                   dat, frailty="gamma", fitmethod="score")

fit.hd

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fitfrail'>
Plot method for <code>fitfrail</code> objects
</h2><span id='topic+plot.fitfrail'></span>

<h3>Description</h3>

<p>Plot the cumulative baseline hazard estimates or the parameter trace from model estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitfrail'
plot(x, type = c("cumhaz", "trace"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fitfrail_+3A_x">x</code></td>
<td>
<p>a <code>fitfrail</code> object</p>
</td></tr>
<tr><td><code id="plot.fitfrail_+3A_type">type</code></td>
<td>
<p>string, the type of plot. Can be either &quot;cumhaz&quot; to plot the mean estimated cumulative hazard or &quot;trace&quot; to plot the paramater and log-likelihood trace.</p>
</td></tr>
<tr><td><code id="plot.fitfrail_+3A_...">...</code></td>
<td>
<p>extra arguments include:
</p>
<p><code>CI</code> for <code>type="cumhaz"</code>, numeric confidence interval between 0 and 1. If <code>CI=0</code>, no confidence interval is displayed. Otherwise, the bootstrapped confidence interval is calculated and displayed.
</p>
<p><code>end</code> for <code>type="cumhaz"</code>, numeric x-axis limit (plot up to time <code>end</code>)
</p>
<p><code>show.loglik</code> for <code>type="trace"</code>, logical whether to show the log-likelihood trace.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object.
</p>


<h3>Author(s)</h3>

<p>John. V Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitfrail">fitfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(drs)
fit.drs &lt;- fitfrail(Surv(time, status) ~ treated + cluster(subject_id), 
                    drs, frailty="gamma")

# Plot the parameter and log-likelihood trace
plot(fit.drs, type="trace") 

# This may take a while to run. 
# Use parameter B to specify the number of repetitions in the weighted bootstrap
plot(fit.drs, type="cumhaz", CI=0.95)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.simfrail'>
Plot method for <code>simfrail</code> objects
</h2><span id='topic+plot.simfrail'></span>

<h3>Description</h3>

<p>Plot the estimated parameter residuals or the mean estimated cumulative baseline hazard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simfrail'
plot(x, type = c("residuals", "cumhaz"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simfrail_+3A_x">x</code></td>
<td>
<p>a <code>fitfrail</code> object</p>
</td></tr>
<tr><td><code id="plot.simfrail_+3A_type">type</code></td>
<td>
<p>string, the type of plot. Can be either &quot;residuals&quot; or &quot;cumhaz&quot;. If <code>type="residuals"</code>, a boxplot of the estimated parameter residuals is created. If <code>type="cumhaz"</code>, the mean estimated and true cumulative baseline hazard are plotted.</p>
</td></tr>
<tr><td><code id="plot.simfrail_+3A_...">...</code></td>
<td>
<p>extra arguments include: 
</p>
<p><code>CI</code> for <code>type="cumhaz"</code>, the confidence interval for the empirical cumulative baseline hazard.
</p>
<p><code>n.Lambda</code> for <code>type="residuals"</code>, the number of time points to show the cumulative baseline hazard residuals for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object.
</p>


<h3>Author(s)</h3>

<p>John. V Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simfrail">simfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(2015)
sim &lt;- simfrail(1000,
    genfrail.args=alist(beta=c(log(2),log(3)), frailty="gamma", 
                        censor.rate=0.30, N=300, K=2, theta=2,
                        covar.distr="uniform", covar.param=c(0, 1),
                        Lambda_0=function(t, tau=4.6, C=0.01) (C*t)^tau), 
    fitfrail.args=alist(formula=Surv(time, status) ~ Z1 + Z2 
                                                   + cluster(family), 
                        frailty="gamma"),
    Lambda.times=1:120)

# Make a boxplot of residuals
plot(sim, type="residuals")

# Plot the mean estimated cumulative baseline hazard and empirical 0.95 CI
plot(sim, type="cumhaz")

## End(Not run)
</code></pre>

<hr>
<h2 id='simcoxph'>
Simulate survival data and fit models
</h2><span id='topic+simcoxph'></span>

<h3>Description</h3>

<p>Generates simulated clustered survival data by repeatedly generating data, using a shared frailty model, and fitting the models. Respective arguments are passed to genfrail and coxph, and the resulting parameter estimates are aggregated and summarized.
</p>
<p>This function is similar to <code><a href="#topic+simfrail">simfrail</a></code>, except models are fitted using the <code><a href="survival.html#topic+coxph">coxph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcoxph(reps, genfrail.args, coxph.args, Lambda.times, cores = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simcoxph_+3A_reps">reps</code></td>
<td>
<p>number of times to repeat the simulation</p>
</td></tr>
<tr><td><code id="simcoxph_+3A_genfrail.args">genfrail.args</code></td>
<td>
<p>list of arguments to pass to <code>genfrail</code></p>
</td></tr>
<tr><td><code id="simcoxph_+3A_coxph.args">coxph.args</code></td>
<td>
<p>list of arguments to pass to <code>coxph</code></p>
</td></tr>
<tr><td><code id="simcoxph_+3A_lambda.times">Lambda.times</code></td>
<td>
<p>vector of time points to obtain baseline hazard estimates at</p>
</td></tr>
<tr><td><code id="simcoxph_+3A_cores">cores</code></td>
<td>
<p>integer; if &gt; 0, the number of cores to use; if &lt; 0, the number of cores not to use; if 0, use all available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>simcoxph</code> object that is essentially a <code>data.frame</code> of the resulting parameter estimates. Each row is a single run, and columns are as follows.
</p>
<table role = "presentation">
<tr><td><code>seed</code></td>
<td>
<p>the seed used for the run</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>the time it took to fit the model</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code>mean.K</code></td>
<td>
<p>average cluster size</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>empirical censorship</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>true regression coefficients</p>
</td></tr>
<tr><td><code>hat.beta</code></td>
<td>
<p>estimated regression coefficients</p>
</td></tr>
<tr><td><code>se.beta</code></td>
<td>
<p>standard error of each regression coefficient</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>true frailty distribution parameters</p>
</td></tr>
<tr><td><code>hat.theta</code></td>
<td>
<p>estimated frailty distribution parameters</p>
</td></tr>
<tr><td><code>se.theta</code></td>
<td>
<p>standard error of each frailty distribution parameter (NA since coxph does not currently provide this.)</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>true cumulative baseline hazard at each Lambda.times point</p>
</td></tr>
<tr><td><code>hat.Lambda</code></td>
<td>
<p>estimated cumulative baseline hazard at each Lambda.times point</p>
</td></tr>
<tr><td><code>se.Lambda</code></td>
<td>
<p>standard error at each Lambda.times point (NA since coxph does not currently provide this)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John. V Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+genfrail">genfrail</a></code>, <code><a href="#topic+simfrail">simfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- simcoxph(reps=100,
                genfrail.args=alist(
                  N=50, K=2,
                  beta=c(log(2),log(3)), 
                  frailty="gamma", theta=2,
                  Lambda_0 = function(t, tau=4.6, C=0.01) (C*t)^tau), 
                coxph.args=alist(
                  formula=Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                  frailty="gamma"),
                Lambda.times=1:120, cores = 0)

# Summarize the results
summary(sim)

# Plot the residuals
plot(sim, "residuals")

## End(Not run)
</code></pre>

<hr>
<h2 id='simfrail'>
Simulate survival data and fit models
</h2><span id='topic+simfrail'></span>

<h3>Description</h3>

<p>Generates simulated clustered survival data by repeatedly generating data, using a shared frailty model, and fitting the models. Respective arguments are passed to genfrail and fitfrail, and the resulting parameter estimates are aggregated and summarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simfrail(reps, genfrail.args, fitfrail.args, Lambda.times, 
         vcov.args = list(), cores = 0, skip.SE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simfrail_+3A_reps">reps</code></td>
<td>
<p>number of times to repeat the simulation</p>
</td></tr>
<tr><td><code id="simfrail_+3A_genfrail.args">genfrail.args</code></td>
<td>
<p>list of arguments to pass to <code>genfrail</code></p>
</td></tr>
<tr><td><code id="simfrail_+3A_fitfrail.args">fitfrail.args</code></td>
<td>
<p>list of arguments to pass to <code>fitfrail</code></p>
</td></tr>
<tr><td><code id="simfrail_+3A_lambda.times">Lambda.times</code></td>
<td>
<p>vector of time points to obtain baseline hazard estimates at</p>
</td></tr>
<tr><td><code id="simfrail_+3A_vcov.args">vcov.args</code></td>
<td>
<p>list of arguments to pass to vcov.fitfrail for variance estimates. This is mainly used to specify whether bootstrap or estimated variances should be obtained.</p>
</td></tr>
<tr><td><code id="simfrail_+3A_cores">cores</code></td>
<td>
<p>integer; if &gt; 0, the number of cores to use; if &lt; 0, the number of cores not to use; if 0, use all available cores</p>
</td></tr>
<tr><td><code id="simfrail_+3A_skip.se">skip.SE</code></td>
<td>
<p>logical value, whether to skip the standard error estimates (saves time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>simfrail</code> object that is essentially a <code>data.frame</code> of the resulting parameter estimates. Each row is a single run, and columns are as follows.
</p>
<table role = "presentation">
<tr><td><code>seed</code></td>
<td>
<p>the seed used for the run</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>the time it took to fit the model</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code>mean.K</code></td>
<td>
<p>average cluster size</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>empirical censorship</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>true regression coefficients</p>
</td></tr>
<tr><td><code>hat.beta</code></td>
<td>
<p>estimated regression coefficients</p>
</td></tr>
<tr><td><code>se.beta</code></td>
<td>
<p>standard error of each regression coefficient</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>true frailty distribution parameters</p>
</td></tr>
<tr><td><code>hat.theta</code></td>
<td>
<p>estimated frailty distribution parameters</p>
</td></tr>
<tr><td><code>se.theta</code></td>
<td>
<p>standard error of each frailty distribution parameter</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>true cumulative baseline hazard at each Lambda.times point</p>
</td></tr>
<tr><td><code>hat.Lambda</code></td>
<td>
<p>estimated cumulative baseline hazard at each Lambda.times point</p>
</td></tr>
<tr><td><code>se.Lambda</code></td>
<td>
<p>standard error at each Lambda.times point</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John. V Monaco, Malka Gorfine, Li Hsu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genfrail">genfrail</a></code>, <code><a href="#topic+fitfrail">fitfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- simfrail(reps=100,
                genfrail.args=alist(
                  N=50, K=2,
                  beta=c(log(2),log(3)), 
                  frailty="gamma", theta=2,
                  Lambda_0 = function(t, tau=4.6, C=0.01) (C*t)^tau), 
                fitfrail.args=alist(
                  formula=Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                  frailty="gamma"),
                Lambda.times=1:120, cores = 0)

# Summarize the results
summary(sim)

# Plot the residuals
plot(sim, "residuals")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.fitfrail'>
Summary of the survival curve
</h2><span id='topic+summary.fitfrail'></span>

<h3>Description</h3>

<p>Returns a <code>data.frame</code> summarizing the survival curve of the fitted model. If specified, this function uses a weighted bootstrap procedure to calculate SE of the survival curve estimates. Subsequente calls with the same arguments will use the cached SE and avoid performing the weighted bootstrap again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitfrail'
summary(object, type = "survival", Lambda.times = NULL, 
                           censored = FALSE, se = FALSE, CI = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fitfrail_+3A_object">object</code></td>
<td>
<p>a <code>fitfrail</code> object</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_type">type</code></td>
<td>
<p>string indicating the type of summary: either &quot;survival&quot; for a summary of the survival curve, or &quot;cumhaz&quot; for a summary of the cumulative baseline hazard.</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_lambda.times">Lambda.times</code></td>
<td>
<p>vector of times where the curve should be evaluated. The resulting <code>data.frame</code> will have 1 row for each time. If NULL and censored=TRUE, all observed times are used by default. If NULL and censored=FALSE, only the failure times are including in the results.
</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_censored">censored</code></td>
<td>
<p>logical value, whether the survival curve should contain the censored times. Ignored if <code>Lambda.times</code> is not NULL.</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_se">se</code></td>
<td>
<p>logical value, whether the survival SE should be included with the results. If se=TRUE, a weighted bootstrap procedure is used to determine estimated survival SE.
</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_ci">CI</code></td>
<td>
<p>numeric, the confidence interval to evaluate upper and lower limits for the survival estimate at each time point</p>
</td></tr>
<tr><td><code id="summary.fitfrail_+3A_...">...</code></td>
<td>
<p>extra arguments will be passed to <code>vcov.fitfrail</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> summarizing the survival curve with the following columns.
</p>
<table role = "presentation">
<tr><td><code>time</code></td>
<td>
<p>the time points</p>
</td></tr>
<tr><td><code>surv/cumhaz</code></td>
<td>
<p>survival/cumulative hazard estimate at time t+</p>
</td></tr>
<tr><td><code>n.risk</code></td>
<td>
<p>number of subjects at risk at time t-</p>
</td></tr>
<tr><td><code>n.event</code></td>
<td>
<p>the number of failures that occured from the last time point to time t+</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>the SE of the survival estimate</p>
</td></tr>
<tr><td><code>lower.ci</code></td>
<td>
<p>lower bound on the specified confidence interval</p>
</td></tr>
<tr><td><code>upper.ci</code></td>
<td>
<p>upper bound on the specified confidence interval</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Similar to <code>summary.survfit</code> function in the <code>survival</code> package. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitfrail">fitfrail</a></code>, <code><a href="#topic+vcov.fitfrail">vcov.fitfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- genfrail(N=200, K=2, beta=c(log(2),log(3)), 
                frailty="gamma", theta=2,
                censor.rate=0.35,
                Lambda_0=function(t, tau=4.6, C=0.01) (C*t)^tau)

fit &lt;- fitfrail(Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                dat, frailty="gamma")

surv &lt;- summary(fitfrail, B=50, se=TRUE, CI=0.95)
head(surv)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcov.fitfrail'>Compute variance/covariance matrix for fitfrail model</h2><span id='topic+vcov.fitfrail'></span>

<h3>Description</h3>

<p>Compute the variance/covariance matrix for fitfrail estimated parameters. This can be performed by a an asymptotically-normal and consistent variance estimator or a weighted bootstrap. The resulting covariance matrix is cached in the fitted object and later retrieved if the same arguments to <code>vcov.fitfrail</code> are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitfrail'
vcov(object, boot=FALSE, B=100, Lambda.times=NULL, cores=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.fitfrail_+3A_object">object</code></td>
<td>
<p>a <code>fitfrail</code> object</p>
</td></tr>
<tr><td><code id="vcov.fitfrail_+3A_boot">boot</code></td>
<td>
<p>logical value, whether to use a weighted bootstrap. If boot == FALSE, a consistent
estimator is used and the cumulative baseline hazard variance will not be estimated.</p>
</td></tr>
<tr><td><code id="vcov.fitfrail_+3A_b">B</code></td>
<td>
<p>number of repetitions in the weighted bootstrap.</p>
</td></tr>
<tr><td><code id="vcov.fitfrail_+3A_lambda.times">Lambda.times</code></td>
<td>
<p>time points where the variance/covariance should be evaluated. If Lambda.times == NULL, then the points where the cumulative baseline hazard increases (where failures occur) are used.</p>
</td></tr>
<tr><td><code id="vcov.fitfrail_+3A_cores">cores</code></td>
<td>
<p>number of cores to use when computing the covariance matrix in parallel</p>
</td></tr>
<tr><td><code id="vcov.fitfrail_+3A_...">...</code></td>
<td>
<p>extra arguments are not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance/covariance matrix for the fitfrail model parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitfrail">fitfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- genfrail(N=200, K=2, beta=c(log(2),log(3)), 
                frailty="gamma", theta=2,
                censor.rate=0.35,
                Lambda_0=function(t, tau=4.6, C=0.01) (C*t)^tau)

fit &lt;- fitfrail(Surv(time, status) ~ Z1 + Z2 + cluster(family), 
                dat, frailty="gamma")

# boot=TRUE will give the weighted bootstrap variance estimates
COV &lt;- vcov(fit, boot=FALSE)
COV

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
