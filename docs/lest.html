<!DOCTYPE html><html><head><title>Help for package lest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lest-package'><p>lest: Vectorised Nested if-else Statements Similar to CASE WHEN</p>
in 'SQL'</a></li>
<li><a href='#case_when'><p>A general vectorised if</p></a></li>
<li><a href='#cumall'><p>Cumulative all and any</p></a></li>
<li><a href='#exceeds_tumbling_sum'><p>Check When the Tumbling Sum of a Vector Exceeds a Threshold</p></a></li>
<li><a href='#if_else'><p>Vectorised if</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vectorised Nested if-else Statements Similar to CASE WHEN in
'SQL'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Fleck &lt;stefan.b.fleck@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for vectorised conditional recoding of
    variables. case_when() enables you to vectorise multiple if and else
    statements (like 'CASE WHEN' in 'SQL'). if_else() is a stricter and
    more predictable version of ifelse() in 'base' that preserves
    attributes. These functions are forked from 'dplyr' with all package
    dependencies removed and behave identically to the originals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.1.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-29 07:23:52 UTC; fleck</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Fleck <a href="https://orcid.org/0000-0003-3344-9851"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Romain François <a href="https://orcid.org/0000-0002-2444-4226"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lionel Henry [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-29 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lest-package'>lest: Vectorised Nested if-else Statements Similar to CASE WHEN
in 'SQL'</h2><span id='topic+lest'></span><span id='topic+lest-package'></span>

<h3>Description</h3>

<p>Functions for vectorised conditional recoding of
variables. case_when() enables you to vectorise multiple if and else
statements (like 'CASE WHEN' in 'SQL'). if_else() is a stricter and
more predictable version of ifelse() in 'base' that preserves
attributes. These functions are forked from 'dplyr' with all package
dependencies removed and behave identically to the originals.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stefan Fleck <a href="mailto:stefan.b.fleck@gmail.com">stefan.b.fleck@gmail.com</a> (<a href="https://orcid.org/0000-0003-3344-9851">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
</li>
<li><p> Romain François (<a href="https://orcid.org/0000-0002-2444-4226">ORCID</a>)
</p>
</li>
<li><p> Lionel Henry
</p>
</li>
<li><p> Kirill Müller (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='case_when'>A general vectorised if</h2><span id='topic+case_when'></span>

<h3>Description</h3>

<p>This function allows you to vectorise multiple <code>if</code> and <code style="white-space: pre;">&#8288;else if&#8288;</code>
statements. It is an R equivalent of the SQL <code style="white-space: pre;">&#8288;CASE WHEN&#8288;</code> statement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_when(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_when_+3A_...">...</code></td>
<td>
<p>A sequence of two-sided formulas. The left hand side (LHS)
determines which values match this case. The right hand side (RHS)
provides the replacement value.
</p>
<p>The LHS must evaluate to a logical vector. The RHS does not need to be
logical, but all RHSs must evaluate to the same type of vector.
</p>
<p>Both LHS and RHS may have the same length of either 1 or <code>n</code>. The
value of <code>n</code> must be consistent across all cases. The case of
<code>n == 0</code> is treated as a variant of <code>n != 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 1 or <code>n</code>, matching the length of the logical
input or output vectors, with the type (and attributes) of the first
RHS. Inconsistent lengths or types will generate an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:50
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)

# Like an if statement, the arguments are evaluated in order, so you must
# proceed from the most specific to the most general. This won't work:
case_when(
  TRUE ~ as.character(x),
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz"
)

# All RHS values need to be of the same type. Inconsistent types will throw an error.
# This applies also to NA values used in RHS: NA is logical, use
# typed values like NA_real_, NA_complex, NA_character_, NA_integer_ as appropriate.
case_when(
  x %% 35 == 0 ~ NA_character_,
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA_real_
)
# This throws an error as NA is logical not numeric
try({
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA
)
})
dat &lt;- iris[1:5, ]
dat$size &lt;- case_when(
  dat$Sepal.Length &lt; 5.0 ~ "small",
  TRUE ~ "big"
)
dat
</code></pre>

<hr>
<h2 id='cumall'>Cumulative all and any</h2><span id='topic+cumall'></span><span id='topic+cumany'></span>

<h3>Description</h3>

<p>Cumulative all and any
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumall(x)

cumany(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumall_+3A_x">x</code></td>
<td>
<p>a <code>logical</code> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>logical</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumall(c(TRUE, TRUE, NA, TRUE, FALSE))
cumany(c(FALSE, FALSE, NA, TRUE, FALSE))
</code></pre>

<hr>
<h2 id='exceeds_tumbling_sum'>Check When the Tumbling Sum of a Vector Exceeds a Threshold</h2><span id='topic+exceeds_tumbling_sum'></span>

<h3>Description</h3>

<p>The tumbling sum is calculated as the partial cumulative sum of a vector
until a threshold is exceeded. Once this happens, the tumbling sum is
calculated from zero again. <code>exceeds_tumbling_sum()</code> returns <code>TRUE</code> whenever
this threshold is hit/exceeded and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceeds_tumbling_sum(x, threshold, inclusive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exceeds_tumbling_sum_+3A_x">x</code></td>
<td>
<p>a <code>numeric</code> vector</p>
</td></tr>
<tr><td><code id="exceeds_tumbling_sum_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code> scalar</p>
</td></tr>
<tr><td><code id="exceeds_tumbling_sum_+3A_inclusive">inclusive</code></td>
<td>
<p>a <code>logical</code> scalar. If <code>TRUE</code> inclusive bounds are used
(i.e. the threshold is checked with <code>&gt;=</code>), otherwise exclusive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is for example useful if you have high frequency GPS positions
and want to keep only points that are at least <code>x</code> seconds apart.
</p>


<h3>Value</h3>

<p>a <code>logical</code> vector of the same length as <code>x</code> that is <code>TRUE</code> whenever
<code>threshold</code> was exceeded and <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code><a href="MESS.html#topic+cumsumbinning">MESS::cumsumbinning()</a></code> does something very similar, but returns
group indices instead of a logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exceeds_tumbling_sum(c(1, 3, 3, 3), 4)
</code></pre>

<hr>
<h2 id='if_else'>Vectorised if</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p>Compared to the base <code><a href="base.html#topic+ifelse">ifelse()</a></code>, this function is more strict.
It checks that <code>true</code> and <code>false</code> are the same type. This
strictness makes the output type more predictable, and makes it somewhat
faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(condition, true, false, missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_+3A_condition">condition</code></td>
<td>
<p>Logical vector</p>
</td></tr>
<tr><td><code id="if_else_+3A_true">true</code>, <code id="if_else_+3A_false">false</code></td>
<td>
<p>Values to use for <code>TRUE</code> and <code>FALSE</code> values of
<code>condition</code>. They must be either the same length as <code>condition</code>,
or length 1. They must also be the same type: <code>if_else()</code> checks that
they have the same type and same class. All other attributes are
taken from <code>true</code>.</p>
</td></tr>
<tr><td><code id="if_else_+3A_missing">missing</code></td>
<td>
<p>If not <code>NULL</code>, will be used to replace missing
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Where <code>condition</code> is <code>TRUE</code>, the matching value from
<code>true</code>, where it's <code>FALSE</code>, the matching value from <code>false</code>,
otherwise <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-5:5, NA)
if_else(x &lt; 0, NA_integer_, x)
if_else(x &lt; 0, "negative", "positive", "missing")

# Unlike ifelse, if_else preserves types
x &lt;- factor(sample(letters[1:5], 10, replace = TRUE))
ifelse(x %in% c("a", "b", "c"), x, factor(NA))
if_else(x %in% c("a", "b", "c"), x, factor(NA))
# Attributes are taken from the `true` vector,
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
