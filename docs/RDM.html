<!DOCTYPE html><html><head><title>Help for package RDM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RDM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkerboardDensity'><p>Estimate the checkerboard mass density</p></a></li>
<li><a href='#checkerboardDensityIndex'><p>Estimate a single entry of the checkerboard mass density</p></a></li>
<li><a href='#computeBandwidth'><p>Compute bandwidth via cross-validation</p></a></li>
<li><a href='#computeCBMeasure'><p>Dependence measures for the checkerboard copula</p></a></li>
<li><a href='#rdm'><p>Rearranged dependence measure</p></a></li>
<li><a href='#sortDSMatrix'><p>Sort a (possibly non-square) doubly stochastic matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantify Dependence using Rearranged Dependence Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates the rearranged dependence measure ('RDM') of two continuous random variables for different underlying measures. 
  Furthermore, it provides a method to estimate the (SI)-rearrangement copula using empirical checkerboard copulas.
  It is based on the theoretical results presented in Strothmann et al. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2201.03329">doi:10.48550/arXiv.2201.03329</a>&gt; and Strothmann (2021) &lt;<a href="https://doi.org/10.17877%2FDE290R-22733">doi:10.17877/DE290R-22733</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ChristopherStrothmann/RDM">https://github.com/ChristopherStrothmann/RDM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ChristopherStrothmann/RDM/issues">https://github.com/ChristopherStrothmann/RDM/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rfast (&ge; 2.0.0), Rcpp (&ge; 1.0.8.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), copula (&ge; 1.0.0), qad (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-24 15:45:39 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Holger Dette <a href="https://orcid.org/0000-0001-7048-474X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Karl Friedrich Siburg [aut],
  Christopher Strothmann
    <a href="https://orcid.org/0000-0002-3537-5019"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  qad contributors [cph] (Authors of the modified code.cpp of the
    R-package 'qad' listed in inst/qad-authors.txt (GPL-2))</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Strothmann &lt;rdmpackage@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-24 19:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkerboardDensity'>Estimate the checkerboard mass density</h2><span id='topic+checkerboardDensity'></span>

<h3>Description</h3>

<p>Estimate a non-square checkerboard mass density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkerboardDensity(X, Y, resolution1, resolution2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkerboardDensity_+3A_x">X</code></td>
<td>
<p>First coordinate of the observations.</p>
</td></tr>
<tr><td><code id="checkerboardDensity_+3A_y">Y</code></td>
<td>
<p>Second coordinate of the observations.</p>
</td></tr>
<tr><td><code id="checkerboardDensity_+3A_resolution1">resolution1</code></td>
<td>
<p>A natural number specifying the resolution of the first component.</p>
</td></tr>
<tr><td><code id="checkerboardDensity_+3A_resolution2">resolution2</code></td>
<td>
<p>A natural number specifying the resolution of the second component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation modifies the code of build_checkerboard_weights() published in 'qad', version 1.0.4, available at <a href="https://CRAN.R-project.org/package=qad">https://CRAN.R-project.org/package=qad</a>,
to allow for non-square checkerboard mass densities.
For more details on the implementation see <code><a href="qad.html#topic+ECBC">ECBC</a></code> and for more information on the implemented changes, see the file 'src/code.cpp'.
</p>


<h3>Value</h3>

<p>The estimated checkerboard mass density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkerboardDensity(runif(20), runif(20), 3, 3)
</code></pre>

<hr>
<h2 id='checkerboardDensityIndex'>Estimate a single entry of the checkerboard mass density</h2><span id='topic+checkerboardDensityIndex'></span>

<h3>Description</h3>

<p>Estimate the value <code class="reqn">A_{kl}</code> of the non-square checkerboard mass density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkerboardDensityIndex(X, Y, k, l, resolution1, resolution2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkerboardDensityIndex_+3A_x">X</code></td>
<td>
<p>First coordinate of the observations.</p>
</td></tr>
<tr><td><code id="checkerboardDensityIndex_+3A_y">Y</code></td>
<td>
<p>Second coordinate of the observations.</p>
</td></tr>
<tr><td><code id="checkerboardDensityIndex_+3A_k">k</code></td>
<td>
<p>Index of the first component.</p>
</td></tr>
<tr><td><code id="checkerboardDensityIndex_+3A_l">l</code></td>
<td>
<p>Index of the second component.</p>
</td></tr>
<tr><td><code id="checkerboardDensityIndex_+3A_resolution1">resolution1</code></td>
<td>
<p>A natural number specifying the resolution of the first component.</p>
</td></tr>
<tr><td><code id="checkerboardDensityIndex_+3A_resolution2">resolution2</code></td>
<td>
<p>A natural number specifying the resolution of the second component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation modifies the code of build_checkerboard_weights() published in 'qad', version 1.0.4, available at <a href="https://CRAN.R-project.org/package=qad">https://CRAN.R-project.org/package=qad</a>,
to allow for the evaluation of a single index of the non-square checkerboard mass densities.
For more details on the implementation see <code><a href="qad.html#topic+ECBC">ECBC</a></code> and for more information on the implemented changes, see the file 'src/code.cpp'.
</p>


<h3>Value</h3>

<p>The estimated checkerboard mass density <code class="reqn">A_{kl}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- runif(20)
V &lt;- runif(20)
checkerboardDensity(U, V, 3, 3)
checkerboardDensityIndex(U, V, 1, 2, 3, 3)
</code></pre>

<hr>
<h2 id='computeBandwidth'>Compute bandwidth via cross-validation</h2><span id='topic+computeBandwidth'></span>

<h3>Description</h3>

<p>An implementation of the cross-validation principle for the bandwidth selection as presented in Strothmann, Dette and Siburg (2022) &lt;arXiv:2201.03329&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeBandwidth(X, sL, sU, method = c("cvsym", "cvasym"), reduce = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeBandwidth_+3A_x">X</code></td>
<td>
<p>A bivariate data.frame containing the observations. Each row contains one observation.</p>
</td></tr>
<tr><td><code id="computeBandwidth_+3A_sl">sL</code></td>
<td>
<p>Lower bound <code class="reqn">N^{sL}</code> for the possible bandwidth parameters (where <code class="reqn">N</code> is the number of observations).</p>
</td></tr>
<tr><td><code id="computeBandwidth_+3A_su">sU</code></td>
<td>
<p>Upper bound <code class="reqn">N^{sU}</code> for the possible bandwidth parameters (where <code class="reqn">N</code> is the number of observations).</p>
</td></tr>
<tr><td><code id="computeBandwidth_+3A_method">method</code></td>
<td>
<p>&quot;cvsym&quot; uses either a symmetric cross-validation principle (N_1 = N_2) and &quot;cvasym&quot; uses an asymmetric cross-validation principle (i.e. <code class="reqn">N_1</code> and <code class="reqn">N_2</code> may attain different values).</p>
</td></tr>
<tr><td><code id="computeBandwidth_+3A_reduce">reduce</code></td>
<td>
<p>In case reduce is set to TRUE, the parameter is chosen from N, N+2, ... instead of N, N+1, N+2, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the optimal bandwidth given the bivariate observations <code class="reqn">X</code> of length <code class="reqn">N</code>.
Currently, there are two different algorithms implemented:
</p>

<ul>
<li><p> &quot;cvsym&quot; - Computes the optimal bandwidth choice for a square checkerboard mass density according to the cross-validation principle. The bandwidth is a natural number between <code class="reqn">N^{sL}, ..., N^{sU}</code>
</p>
</li>
<li><p> &quot;cvasym&quot; - Computes the optimal bandwidth choice <code class="reqn">(N_1, N_2)</code> for a non-square checkerboard mass density according to the cross-validation principle.
The bandwidths <code class="reqn">N_1, N_2</code> are natural numbers between <code class="reqn">N^{sL}, ..., N^{sU}</code> and may possibly attain different values.
</p>
</li></ul>



<h3>Value</h3>

<p>The chosen bandwidth depending on the data.frame X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
X &lt;- cbind(runif(n), runif(n))
computeBandwidth(X, sL = 0.25, sU = 0.5, method="cvsym", reduce=TRUE)
</code></pre>

<hr>
<h2 id='computeCBMeasure'>Dependence measures for the checkerboard copula</h2><span id='topic+computeCBMeasure'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">\mu(C^{\#}(A))</code> for some underlying measure for the checkerboard copula <code class="reqn">C^{\#}(A)</code>.
This measure depends only on the input matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCBMeasure(A, method = c("spearman", "kendall", "bkr", "dss", "zeta1"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCBMeasure_+3A_a">A</code></td>
<td>
<p>A (possibly non-square) checkerboard mass density.</p>
</td></tr>
<tr><td><code id="computeCBMeasure_+3A_method">method</code></td>
<td>
<p>Determines the underlying dependence measure. Options include &quot;spearman&quot;, &quot;kendall&quot;, &quot;bkr&quot;, &quot;dss&quot;, &quot;chatterjee&quot; and &quot;zeta1&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes <code class="reqn">\mu(C^{\#}(A))</code> for one of several underlying measures for a given checkerboard copula <code class="reqn">C^{\#}(A)</code>.
Most importantly, the value only depends on the (possibly non-square) matrix <code class="reqn">A</code> and implicitly assumes the form of <code class="reqn">C^{\#}(A)</code> given in Strothmann, Dette and Siburg (2022) &lt;arXiv:2201.03329&gt;.
Currently, the following underlying measures are implemented:
</p>

<ul>
<li><p>&quot;spearman&quot; Implements the concordance measure Spearman's <code class="reqn">\rho</code>,
</p>
</li>
<li><p>&quot;kendall&quot; Implements the concordance measure Kendall's <code class="reqn">\tau</code>,
</p>
</li>
<li><p>&quot;bkr&quot; Implements the Blum–Kiefer–Rosenblatt <code class="reqn">R</code>, also known as the <code class="reqn">L^2</code>-Schweizer-Wolff-measure &lt;doi:10.1214/aos/1176345528&gt;,
</p>
</li>
<li><p>&quot;dss&quot; Implements the Dette-Siburg-Stoimenov measure of complete dependence &lt;doi:10.1111/j.1467-9469.2011.00767.x&gt;, also known as Chatterjee's <code class="reqn">\xi</code> &lt;doi:10.1080/01621459.2020.1758115&gt;,
</p>
</li>
<li><p>&quot;zeta1&quot; Implements the <code class="reqn">\zeta_1</code>-measure of complete dependence established by W. Trutschnig &lt;doi:10.1016/j.jmaa.2011.06.013&gt;.
</p>
</li></ul>



<h3>Value</h3>

<p>The value of <code class="reqn">\mu(C^{\#}(A))</code>. For a sorted A, this corresponds to the rearranged dependence measure <code class="reqn">R_{\mu}(C^{\#}(A))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
A &lt;- diag(n)/n
computeCBMeasure(A, method="spearman")
</code></pre>

<hr>
<h2 id='rdm'>Rearranged dependence measure</h2><span id='topic+rdm'></span>

<h3>Description</h3>

<p>This function estimates the asymmetric dependence between <code class="reqn">X</code> and <code class="reqn">Y</code> using the rearranged dependence measure <code class="reqn">R_\mu(X, Y)</code> for different possible underlying measures <code class="reqn">\mu</code>.
A value of 0 characterizes independence of <code class="reqn">X</code> and <code class="reqn">Y</code>, while a value of 1 characterizes a functional relationship between <code class="reqn">X</code> and <code class="reqn">Y</code>, i.e. <code class="reqn">Y = f(X)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdm(
  X,
  method = c("spearman", "kendall", "dss", "zeta1", "bkr", "all"),
  bandwidth_method = c("fixed", "cv", "cvsym"),
  bandwidth_parameter = 0.5,
  permutation = FALSE,
  npermutation = 1000,
  checkInput = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdm_+3A_x">X</code></td>
<td>
<p>A bivariate data.frame containing the observations. Each row contains one bivariate observation.</p>
</td></tr>
<tr><td><code id="rdm_+3A_method">method</code></td>
<td>
<p>Options include &quot;spearman&quot;, &quot;kendall&quot;, &quot;bkr&quot;, &quot;dss&quot;, &quot;chatterjee&quot; and &quot;zeta1&quot;.The option &quot;all&quot; returns the value for all aforementioned methods.</p>
</td></tr>
<tr><td><code id="rdm_+3A_bandwidth_method">bandwidth_method</code></td>
<td>
<p>A character string indicating the use of either a cross-validation principle (square or non-square) or a fixed bandwidth (oftentimes called resolution).</p>
</td></tr>
<tr><td><code id="rdm_+3A_bandwidth_parameter">bandwidth_parameter</code></td>
<td>
<p>A numerical vector which contains the necessary optional parameters for the exponent of the chosen bandwidth method.
In case of N observations, the bandwidth_parameter <code class="reqn">(s_1, s_2)</code> determines a lower bound <code class="reqn">N^{s_1}</code> and upper bound <code class="reqn">N^{s_2}</code> for the cross-validation methods
or a single number s for the fixed bandwidth method resulting in <code class="reqn">N^s</code>.
The parameters have to lie in <code class="reqn">(0, 1/2)</code> and fulfil <code class="reqn">s_1 &lt; s_2</code>.</p>
</td></tr>
<tr><td><code id="rdm_+3A_permutation">permutation</code></td>
<td>
<p>Whether or not to perform a permutation test</p>
</td></tr>
<tr><td><code id="rdm_+3A_npermutation">npermutation</code></td>
<td>
<p>Number of repetitions of the permutation test</p>
</td></tr>
<tr><td><code id="rdm_+3A_checkinput">checkInput</code></td>
<td>
<p>Whether or not to perform validity checks of the input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates <code class="reqn">R_\mu(X, Y)</code> using the empirical checkerboard mass density <code class="reqn">A</code>.
To arrive at <code class="reqn">R_\mu(X, Y)</code>, <code class="reqn">A</code> is appropriately sorted and then evaluated for the underlying measure.
The estimated <code class="reqn">R_\mu</code> always takes values between 0 and 1 with
</p>

<ul>
<li> <p><code class="reqn">R_\mu(X, Y) = 0</code> if and only if <code class="reqn">X</code> and <code class="reqn">Y</code> are independent.
</p>
</li>
<li> <p><code class="reqn">R_\mu(X, Y) = 1</code> if and only if <code class="reqn">Y = f(X)</code> for some measurable function <code class="reqn">f</code>.
</p>
</li></ul>

<p>Currently, the following underlying measures are implemented:
</p>

<ul>
<li><p>&quot;spearman&quot; Implements the concordance measure Spearman's <code class="reqn">\rho</code> (which is identical to the <code class="reqn">L_1</code>-Schweizer-Wolff-measure),
</p>
</li>
<li><p>&quot;kendall&quot; Implements the concordance measure Kendall's <code class="reqn">\tau</code>,
</p>
</li>
<li><p>&quot;bkr&quot; Implements the Blum–Kiefer–Rosenblatt <code class="reqn">R</code>, also known as the <code class="reqn">L^2</code>-Schweizer-Wolff-measure &lt;doi:10.1214/aos/1176345528&gt;,
</p>
</li>
<li><p>&quot;dss&quot; Implements the Dette-Siburg-Stoimenov measure of complete dependence &lt;doi:10.1111/j.1467-9469.2011.00767.x&gt;, also known as Chatterjee's <code class="reqn">\xi</code> &lt;doi:10.1080/01621459.2020.1758115&gt;,
</p>
</li>
<li><p>&quot;zeta1&quot; Implements the <code class="reqn">\zeta_1</code>-measure of complete dependence established by W. Trutschnig &lt;doi:10.1016/j.jmaa.2011.06.013&gt;.
</p>
</li></ul>

<p>The estimation of the checkerboard mass density <code class="reqn">A</code> depends on the choice of the bandwidth for the checkerboard copula.
For a detailed discussion of &quot;cv&quot; and &quot;cvsym&quot;, see <code><a href="#topic+computeBandwidth">computeBandwidth</a></code>.
</p>


<h3>Value</h3>

<p>The estimated value of the rearranged dependence measure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
X &lt;- cbind(runif(n), runif(n))
rdm(X, method="spearman", bandwidth_method="fixed", bandwidth_parameter=.3)
n &lt;- 20
U &lt;- runif(n)
rdm(cbind(U, U), method="spearman", bandwidth_method="cv", bandwidth_parameter=c(0.25, 0.5))
</code></pre>

<hr>
<h2 id='sortDSMatrix'>Sort a (possibly non-square) doubly stochastic matrix</h2><span id='topic+sortDSMatrix'></span>

<h3>Description</h3>

<p>Sorts an arbitrary doubly stochastic <code class="reqn">N_1 \times N_2</code> matrix A into the matrix <code class="reqn">A^\uparrow</code> such that the induced checkerboard copula <code class="reqn">C(A^\uparrow)</code> is stochastically increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortDSMatrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortDSMatrix_+3A_a">A</code></td>
<td>
<p>A (possibly non-square) doubly stochastic matrix or (possibly non-square) checkerboard mass density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm to sort a doubly stochastic matrix <code class="reqn">A</code> is given in Strothmann, Dette and Siburg (2022) &lt;arXiv:2201.03329&gt;.
Since this implementation does not depend on the appropriate scaling of the matrix <code class="reqn">A</code>, both doubly stochastic matrices and checkerboard mass densities are admissible inputs.
</p>


<h3>Value</h3>

<p>The sorted version <code class="reqn">A^\uparrow</code> of the matrix <code class="reqn">A</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 4
A &lt;- diag(n)[n:1, ]
print(A)
sortDSMatrix(A)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
