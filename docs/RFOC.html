<!DOCTYPE html><html><head><title>Help for package RFOC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RFOC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addmecpoints'><p>Add points to Focal Mech</p></a></li>
<li><a href='#addPT'><p>Add P-T Axis to focal plot</p></a></li>
<li><a href='#addPTarrows'><p>Add fancy 3D arrows</p></a></li>
<li><a href='#addsmallcirc'><p>Small Circle on Stereonet</p></a></li>
<li><a href='#AlongGreat'><p>Get Points Along Great Circle</p></a></li>
<li><a href='#alpha95'><p>95 percent confidence for Spherical Distribution</p></a></li>
<li><a href='#AXpoint'><p>Extract Axis pole on Stereonet</p></a></li>
<li><a href='#bang'><p>Angle between two 2D normalized vectors</p></a></li>
<li><a href='#Beachfoc'><p>Plot a BeachBall Focal Mechanism</p></a></li>
<li><a href='#Bfocvec'><p>Angles for Ternary plot</p></a></li>
<li><a href='#BOXarrows3D'><p>Create a 3D Arrow structure</p></a></li>
<li><a href='#circtics'><p>Draw circular ticmarks</p></a></li>
<li><a href='#CONVERTSDR'><p>Convert Strike-Dip-Rake to MEC structure</p></a></li>
<li><a href='#cross.prod'><p>Vector Cross Product</p></a></li>
<li><a href='#CROSSL'><p>Vector Cross Product</p></a></li>
<li><a href='#doNonDouble'><p>Plot Non-double Couple Moment</p></a></li>
<li><a href='#EApoint'><p>Equal-area point stereonet</p></a></li>
<li><a href='#egl'><p>Tungurahua Cartesian Moment Tensors</p></a></li>
<li><a href='#fancyarrows'><p>Make fancy arrows</p></a></li>
<li><a href='#faultplane'><p>fault plane projection on focal sphere</p></a></li>
<li><a href='#FixDip'><p>Fix Dip Angle</p></a></li>
<li><a href='#flipnodal'><p>Flip Nodal Fault Plane</p></a></li>
<li><a href='#foc.color'><p>Get color of Focal Mechansim</p></a></li>
<li><a href='#foc.icolor'><p>Get Fault Style</p></a></li>
<li><a href='#FOCangles'><p>Angles for focal planes</p></a></li>
<li><a href='#focleg'><p>Fault style descriptor</p></a></li>
<li><a href='#focpoint'><p>add point on focal sphere</p></a></li>
<li><a href='#forcerighthand'><p>Force Right-Hand System</p></a></li>
<li><a href='#getCMT'><p>Read CMT</p></a></li>
<li><a href='#GetRake'><p>Calculate Rake angles</p></a></li>
<li><a href='#GetRakeSense'><p>Get Rake Sense</p></a></li>
<li><a href='#getUWfocs'><p>Get UW focals</p></a></li>
<li><a href='#HAMMERprojXY'><p>Hammer Projection</p></a></li>
<li><a href='#hudson.net'><p>Hudson Net Plot</p></a></li>
<li><a href='#hudson.plot'><p>Hudson Source Type Plot</p></a></li>
<li><a href='#imageP'><p>P-wave radiation pattern</p></a></li>
<li><a href='#imageSCALE'><p>add scale on sice of image</p></a></li>
<li><a href='#imageSH'><p>P-wave radiation pattern</p></a></li>
<li><a href='#imageSV'><p>P-wave radiation pattern</p></a></li>
<li><a href='#inverseTAPE'><p>Inverse Moment Tensor</p></a></li>
<li><a href='#jimbo'><p>Moment Tensors from the Harvard CMT</p></a></li>
<li><a href='#JMAT'><p>Vertical Rotation matrix</p></a></li>
<li><a href='#justfocXY'><p>Plot focal mechanism</p></a></li>
<li><a href='#KAMCORN'><p>SDR data from the Harvard CMT catalog</p></a></li>
<li><a href='#lowplane'><p>Plot one Fault plane on stereonet</p></a></li>
<li><a href='#m2tk'><p>Moment tensor to T-k</p></a></li>
<li><a href='#makeblock3D'><p>Make a 3D block Structure</p></a></li>
<li><a href='#makenet'><p>Equal-Angle Stereonet</p></a></li>
<li><a href='#MapNonDouble'><p>Map moment tensors</p></a></li>
<li><a href='#mc2cart'><p>Convert azimuth, dip to Cartesian Coordinates</p></a></li>
<li><a href='#mijsdr'><p>Moment Tensor to Strike-Dip-Rake</p></a></li>
<li><a href='#MomentDist'><p>Distance Between Moment Tensors</p></a></li>
<li><a href='#MRake'><p>Rake Calculation</p></a></li>
<li><a href='#net'><p>EqualArea Stereonet</p></a></li>
<li><a href='#nipXY'><p>Fault-Slip vector plot</p></a></li>
<li><a href='#nodalLines'><p>Nodal Lines</p></a></li>
<li><a href='#normal.fault'><p>Normal Fault Cartoon</p></a></li>
<li><a href='#pcirc'><p>Circle Plot</p></a></li>
<li><a href='#pglyph3D'><p>Plot a 3D body on an existing graphic</p></a></li>
<li><a href='#phong3D'><p>Phong shading for a 3D body</p></a></li>
<li><a href='#PKAM'><p>P and T-axes data from the Harvard CMT catalog</p></a></li>
<li><a href='#plotfoc'><p>Plot Focal Radiation Patterns</p></a></li>
<li><a href='#plotmanyfoc'><p>Plot Many Focals</p></a></li>
<li><a href='#plotMEC'><p>Plot a Focal Mechanism</p></a></li>
<li><a href='#PlotPlanes'><p>Plot Fault an Auxilliary Planes</p></a></li>
<li><a href='#PlotPTsmooth'><p>Plot Smooth PT-axes</p></a></li>
<li><a href='#PlotTernfoc'><p>Ternary Distribution of focal mechanisms</p></a></li>
<li><a href='#PLTcirc'><p>Circle Plot with Cross Hairs</p></a></li>
<li><a href='#pnet'><p>plot stereonet</p></a></li>
<li><a href='#polyfoc'><p>Polt the focal mechanism polygon</p></a></li>
<li><a href='#Pradfoc'><p>Plot P-wave radiation</p></a></li>
<li><a href='#Preflect'><p>Reflect a pole through to the lower hemisphere</p></a></li>
<li><a href='#prepFOCS'><p>Prepare Focals</p></a></li>
<li><a href='#printMEC'><p>Print focal mechanism</p></a></li>
<li><a href='#PROJ3D'><p>Project 3D</p></a></li>
<li><a href='#PTaxes'><p>Plot P-T axis on CLVD</p></a></li>
<li><a href='#PTXY2'><p>Plot P-T Axes</p></a></li>
<li><a href='#qpoint'><p>Point on Stereonet</p></a></li>
<li><a href='#radiateP'><p>Plot radiation pattern for P-waves</p></a></li>
<li><a href='#radiateSH'><p>Plot radiation pattern for SH-waves</p></a></li>
<li><a href='#radiateSV'><p>Plot radiation pattern for SV-waves</p></a></li>
<li><a href='#radP'><p>Radiation pattern for P waves</p></a></li>
<li><a href='#radSH'><p>Radiation pattern for SH waves</p></a></li>
<li><a href='#radSV'><p>Radiation pattern for SV waves</p></a></li>
<li><a href='#rakelegend'><p>Focal Legend based on rake</p></a></li>
<li><a href='#readCMT'><p>Read Harvard  CMT moment</p></a></li>
<li><a href='#RectDense'><p>Divide a region into rectangles based on density</p></a></li>
<li><a href='#REFLECT'><p>reflect pole</p></a></li>
<li><a href='#RFOC-package'>
<p>Calculates and plot Earthquake Focal Mechanisms</p></a></li>
<li><a href='#rotateFoc'><p>Rotate Focal Mechanism</p></a></li>
<li><a href='#Rotfocphi'><p>Rotate Focal Mechanism</p></a></li>
<li><a href='#RotTP'><p>Rotate T-P axes</p></a></li>
<li><a href='#ROTX'><p>X-axis Rotation Matrix</p></a></li>
<li><a href='#rotx3'><p>Rotate about the x axis</p></a></li>
<li><a href='#ROTY'><p>Y-axis Rotation Matrix</p></a></li>
<li><a href='#roty3'><p>Rotate about the y axis</p></a></li>
<li><a href='#ROTZ'><p>Z-axis Rotation Matrix</p></a></li>
<li><a href='#rotz3'><p>Rotate about the z axis</p></a></li>
<li><a href='#SDRfoc'><p>Plot a Focal Mechanism from SDR</p></a></li>
<li><a href='#ShadowCLVD'><p>Plot CLVD focal mechanism</p></a></li>
<li><a href='#SHradfoc'><p>Plot SH-wave radiation</p></a></li>
<li><a href='#SourceType'><p>Moment Tensor Source Type</p></a></li>
<li><a href='#spherefocgeo'><p>SphereFocGeo</p></a></li>
<li><a href='#spline.arrow'><p>Spline Arrow</p></a></li>
<li><a href='#StrikeDip'><p>Plot Strike Dip Lines</p></a></li>
<li><a href='#strikeslip.fault'><p>Strikeslip Fault Cartoon</p></a></li>
<li><a href='#SVradfoc'><p>Plot SV-wave radiation</p></a></li>
<li><a href='#TapeBase'><p>Tape Base Lines</p></a></li>
<li><a href='#TapePlot'><p>Tape style Lune Plot</p></a></li>
<li><a href='#TEACHFOC'><p>Graphical Plot of Focal Mechanism</p></a></li>
<li><a href='#ternfoc.point'><p>Plot Ternary Point</p></a></li>
<li><a href='#ternfocgeo'><p>Ternary Focals</p></a></li>
<li><a href='#testrightHAND'><p>Test Right Hand of tensor</p></a></li>
<li><a href='#thrust.fault'><p>Thrust Fault Cartoon</p></a></li>
<li><a href='#tk2uv'><p>Tk2uv</p></a></li>
<li><a href='#to.spherical'><p>Convert Cartesian to Spherical</p></a></li>
<li><a href='#TOCART.DIP'><p>Convert to Cartesian</p></a></li>
<li><a href='#tocartL'><p>Convert to cartesian coordinate</p></a></li>
<li><a href='#TOSPHERE'><p>Convert to Spherical Coordinates</p></a></li>
<li><a href='#TOSPHERE.DIP'><p>convert to spherical coordinates</p></a></li>
<li><a href='#tosphereL'><p>convert to spherical coordinates</p></a></li>
<li><a href='#TP2XYZ'><p>Trend - Dip to XYZ</p></a></li>
<li><a href='#TRANmat'><p>Translation Matrix</p></a></li>
<li><a href='#Vmoments'><p>Cartesian Moment Tensors</p></a></li>
<li><a href='#widdenMoments'><p>Cartesian Moment Tensors</p></a></li>
<li><a href='#Wnet'><p>Wulff Stereonet</p></a></li>
<li><a href='#Wpoint'><p>Plot points on Wulff Stereonet</p></a></li>
<li><a href='#xsecmanyfoc'><p>Plot Focal Mechs at X-Y position on cross sections</p></a></li>
<li><a href='#Z3Darrow'><p>Make a 3D arrow</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphics for Spherical Distributions and Earthquake Focal
Mechanisms</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RPMG, GEOmap, RSEIS, MASS, fields</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M. Lees [aut, cre],
  Keehoon Kim [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graphics for statistics on a sphere, as applied to geological fault data, crystallography, earthquake focal mechanisms, radiation patterns, ternary plots and geographical/geological maps.  Non-double couple plotting of focal spheres and source type maps are included for statistical analysis of moment tensors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 14:39:47 UTC; lees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 21:52:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='addmecpoints'>Add points to Focal Mech</h2><span id='topic+addmecpoints'></span>

<h3>Description</h3>

<p>Add a standard set of points to a Focal Mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addmecpoints(MEC, pch = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addmecpoints_+3A_mec">MEC</code></td>
<td>
<p>MEC structure list</p>
</td></tr>
<tr><td><code id="addmecpoints_+3A_pch">pch</code></td>
<td>
<p>plotting character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>SDRfoc, focpoint</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MEC= SDRfoc(12,34,-120)
addmecpoints(MEC)


</code></pre>

<hr>
<h2 id='addPT'>Add P-T Axis to focal plot</h2><span id='topic+addPT'></span>

<h3>Description</h3>

<p>Add Pressure and tension Axes to focal mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPT(MEC, pch = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPT_+3A_mec">MEC</code></td>
<td>
<p> MEC structure </p>
</td></tr>
<tr><td><code id="addPT_+3A_pch">pch</code></td>
<td>
<p>plotting character </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>addPTarrows</p>


<h3>Examples</h3>

<pre><code class='language-R'>

MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
Beachfoc(MEC)
addPT(MEC, pch = 5)

</code></pre>

<hr>
<h2 id='addPTarrows'>Add fancy 3D arrows</h2><span id='topic+addPTarrows'></span>

<h3>Description</h3>

<p>Illustrate Pressure and Tension axis on Focal Plot using
3D arrows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPTarrows(MEC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPTarrows_+3A_mec">MEC</code></td>
<td>
<p>Mechanism Structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Note</h3>

<p>This function looks better when plotting the upper hemisphere</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>focpoint, BOXarrows3D,Z3Darrow</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 MEC = SDRfoc(65,25,13, u=TRUE, ALIM=c(-1,-1, +1, +1), PLOT=TRUE)
  
addPTarrows(MEC)


</code></pre>

<hr>
<h2 id='addsmallcirc'>Small Circle on Stereonet</h2><span id='topic+addsmallcirc'></span>

<h3>Description</h3>

<p>Calculate and plot small circle on Stereo net
at arbitrary azimuth, orientation and conical angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addsmallcirc(az, iang, alphadeg, BALL.radius = 1, N = 100, add = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addsmallcirc_+3A_az">az</code></td>
<td>
<p>Azimuth of axis</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_iang">iang</code></td>
<td>
<p>angle of dip, degrees</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_alphadeg">alphadeg</code></td>
<td>
<p>width of cone in degrees</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_ball.radius">BALL.radius</code></td>
<td>
<p>size of sphere</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_n">N</code></td>
<td>
<p>NUmber of points to calculate</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to existing plot</p>
</td></tr>
<tr><td><code id="addsmallcirc_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the azimuth and dip of a vector, plot the small circle around
the pole with conical angle alphadeg
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
</table>


<h3>Note</h3>

<p>alphadeg is the radius of the conic projection
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>net</p>


<h3>Examples</h3>

<pre><code class='language-R'>net()
addsmallcirc(65, 13, 20, BALL.radius = 1, N = 100, add = TRUE)
addsmallcirc(165, 73, 5.6, BALL.radius = 1, N = 100, add = TRUE)



</code></pre>

<hr>
<h2 id='AlongGreat'>Get Points Along Great Circle</h2><span id='topic+AlongGreat'></span>

<h3>Description</h3>

<p>Using a Starting LAT-LON, return points along an azimuth 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlongGreat(LON1, LAT1, km1, ang,  EARTHRAD= 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlongGreat_+3A_lon1">LON1</code></td>
<td>
<p>Longitude, point</p>
</td></tr>
<tr><td><code id="AlongGreat_+3A_lat1">LAT1</code></td>
<td>
<p>Latitude, point  </p>
</td></tr>
<tr><td><code id="AlongGreat_+3A_km1">km1</code></td>
<td>
<p>Kilometers in direction ang</p>
</td></tr>
<tr><td><code id="AlongGreat_+3A_ang">ang</code></td>
<td>
<p>Direction from North</p>
</td></tr>
<tr><td><code id="AlongGreat_+3A_earthrad">EARTHRAD</code></td>
<td>
<p>optional earth radius,  default  = 6371</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns LAT-LON points along a great circle, so many kilometers away
in a specified direction
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>lat</code></td>
<td>
<p>Latitude, destination point</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>Longitude, destination point</p>
</td></tr>
<tr><td><code>distdeg</code></td>
<td>
<p>distance in degrees</p>
</td></tr>
<tr><td><code>distkm</code></td>
<td>
<p>distance in km</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>london = c(51.53333, -0.08333333)

AlongGreat(london[2], london[1], 450, 56)


</code></pre>

<hr>
<h2 id='alpha95'>95 percent confidence for Spherical Distribution</h2><span id='topic+alpha95'></span>

<h3>Description</h3>

<p>Calculates conical projection angle for 95%
confidence bounds for mean of spherically distributed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha95(az, iang)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha95_+3A_az">az</code></td>
<td>
<p>vector of azimuths, degrees</p>
</td></tr>
<tr><td><code id="alpha95_+3A_iang">iang</code></td>
<td>
<p>vector of dips, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program calculates the cartesian coordinates
of all poles, sums and returns the resultant vector, its azimuth and
length (R).
For N points, statistics include:
</p>
<p style="text-align: center;"><code class="reqn">
   K = \frac {N-1} { N-R}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
   S = \frac{81^{\circ} }{\sqrt{K}}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
   \kappa = \frac{log( \frac{\epsilon_1}{\epsilon_2}  )}{log(\frac{\epsilon_2}{\epsilon_3} )}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
   \alpha_{95} = cos^{-1} \left[ 1 - \frac {N-R}{R} \left(
   20^{\frac{1}{N-1}} - 1  \right)  \right]
 </code>
</p>

<p>where <code class="reqn">\epsilon</code>'s are the relevant eigenvalues of matrix MAT and
angles are in degrees.
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>Ir</code></td>
<td>
<p>resultant inclination, degrees</p>
</td></tr>
<tr><td><code>Dr</code></td>
<td>
<p>resultant declination, degrees</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>resultant sum of vectors, normalized</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>K-dispersion value</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>spherical variance</p>
</td></tr>
<tr><td><code>Alph95</code></td>
<td>
<p>95% confidence angle, degrees</p>
</td></tr>
<tr><td><code>Kappa</code></td>
<td>
<p>log ratio of eignevectors</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Eigenvactors </p>
</td></tr>
<tr><td><code>MAT</code></td>
<td>
<p>matrix of cartesian vectors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Davis, John C., 2002, Statistics and data analysis in geology, Wiley, New York, 637p.</p>


<h3>See Also</h3>

<p>addsmallcirc</p>


<h3>Examples</h3>

<pre><code class='language-R'>

paz = rnorm(100, mean=297, sd=10)
pdip = rnorm(100, mean=52, sd=8)
ALPH = alpha95(paz, pdip)

#########  draw stereonet
net()
############  add points
focpoint(paz, pdip, col='red',  pch=3, lab="", UP=FALSE)
###############  add 95 percent confidence bounds
addsmallcirc(ALPH$Dr, ALPH$Ir, ALPH$Alph95, BALL.radius = 1, N = 25,
add = TRUE, lwd=1, col='blue')

############  second example:
paz = rnorm(100, mean=297, sd=100)
pdip = rnorm(100, mean=52, sd=20)
ALPH = alpha95(paz, pdip)

net()
focpoint(paz, pdip, col='red',  pch=3, lab="", UP=FALSE)

addsmallcirc(ALPH$Dr, 90-ALPH$Ir, ALPH$Alph95, BALL.radius = 1, N = 25,
add = TRUE, lwd=1, col='blue')




</code></pre>

<hr>
<h2 id='AXpoint'>Extract Axis pole on Stereonet</h2><span id='topic+AXpoint'></span>

<h3>Description</h3>

<p>Interactive extract axis point on Stereonet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AXpoint(UP = TRUE, col=2, n=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AXpoint_+3A_up">UP</code></td>
<td>
<p>logical, TRUE=upper hemisphere </p>
</td></tr>
<tr><td><code id="AXpoint_+3A_col">col</code></td>
<td>
<p>plotting color </p>
</td></tr>
<tr><td><code id="AXpoint_+3A_n">n</code></td>
<td>
<p>maximum number to locate, default=unlimited </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program uses locator to create a vector of poles.  Points outside the
focal sphere (r&gt;1) are ignored.  If n is missing, locator continues
until stopped (middle mouse in linux, stop in windows).
</p>


<h3>Value</h3>

<table>
<tr><td><code>phiang</code></td>
<td>
<p>azimuth angle, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip angle, degrees</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate of cartesian vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate of cartesian vector</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate of cartesian vector</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>x-coordinate of prjection</p>
</td></tr>
<tr><td><code>gy</code></td>
<td>
<p>y-coordinate of prjection</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>locator, qpoint, EApoint</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################  this is interactive
## Not run: 
net()
Z = AXpoint(UP = TRUE)
##  click in steronet
Z

## End(Not run)

</code></pre>

<hr>
<h2 id='bang'>Angle between two 2D normalized vectors</h2><span id='topic+bang'></span>

<h3>Description</h3>

<p>Calculates the angle between two 2D normalized vectors using dot and
cross product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bang(x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bang_+3A_x1">x1</code></td>
<td>
<p> x coordinate of first normalized vector </p>
</td></tr>
<tr><td><code id="bang_+3A_y1">y1</code></td>
<td>
<p> y coordinate of first normalized vector </p>
</td></tr>
<tr><td><code id="bang_+3A_x2">x2</code></td>
<td>
<p> x coordinate of second normalized vector </p>
</td></tr>
<tr><td><code id="bang_+3A_y2">y2</code></td>
<td>
<p> y coordinate of second normalized vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sign of angle is determined by the sign of the cross product of the two
vectors.  
</p>


<h3>Value</h3>

<p>angle in radians
</p>


<h3>Note</h3>

<p>Vectors must be normalized prior to calling this routine.  Used mainly
for vectors on the unit sphere.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 = c(5,3)
v2 = c(6,1)

a1 = c(5,3)/sqrt(v1[1]^2+v1[2]^2)
a2 = c(6,1)/sqrt(v2[1]^2+v2[2]^2)

plot(c(0, v1[1],v2[1] ) , c(0, v1[2],v2[2]), type='n', xlab="x", ylab="y" )
text(c(v1[1],v2[1]) , c(v1[2],v2[2]), labels=c("v1", "v2"), pos=3, xpd=TRUE)

arrows(0, 0, c(v1[1],v2[1] ), c(v1[2],v2[2]))

B  = 180*bang(a1[1], a1[2], a2[1], a2[2])/pi
title(paste(sep=" ", "Angle from V1 to V2=",format(B, digits=2)) )



</code></pre>

<hr>
<h2 id='Beachfoc'>Plot a BeachBall Focal Mechanism</h2><span id='topic+Beachfoc'></span>

<h3>Description</h3>

<p>Plots a focal mechanism in beachball style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Beachfoc(MEC, fcol = gray(0.9), fcolback = "white", ALIM = c(-1, -1, +1, +1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Beachfoc_+3A_mec">MEC</code></td>
<td>
<p>Mechanism Structure</p>
</td></tr>
<tr><td><code id="Beachfoc_+3A_fcol">fcol</code></td>
<td>
<p>color for the filled portion of the beachball</p>
</td></tr>
<tr><td><code id="Beachfoc_+3A_fcolback">fcolback</code></td>
<td>
<p>color for the background portion of the beachball, default='white'</p>
</td></tr>
<tr><td><code id="Beachfoc_+3A_alim">ALIM</code></td>
<td>
<p>Bounding box for beachball, default=c(-1, -1, +1, +1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beachfoc is run after MEC is set using SDRfoc.
Options for plotting the beachball in various modes are controlled by
flags set in MEC
</p>


<h3>Value</h3>

<p>Used for its graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K. Aki and P. G. Richards. <em>Quantitative seismology</em>.
University Science Books, Sausalito, Calif., 2nd
edition, 2002. Keiiti Aki, Paul G. Richards. ill. ; 26 cm.
</p>


<h3>See Also</h3>

<p>CONVERTSDR, SDRfoc, justfocXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MEC = SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=TRUE)

Beachfoc(MEC, fcol=MEC$fcol, fcolback="white")

</code></pre>

<hr>
<h2 id='Bfocvec'>Angles for Ternary plot</h2><span id='topic+Bfocvec'></span>

<h3>Description</h3>

<p>Calculates Angles for determining ternary distribution of faults based
on P-T axis orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bfocvec(Paz, Pdip, Taz, Tdip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bfocvec_+3A_paz">Paz</code></td>
<td>
<p>vector of azimuths, degrees</p>
</td></tr>
<tr><td><code id="Bfocvec_+3A_pdip">Pdip</code></td>
<td>
<p>vector of dips, degrees</p>
</td></tr>
<tr><td><code id="Bfocvec_+3A_taz">Taz</code></td>
<td>
<p>vector of azimuths, degrees</p>
</td></tr>
<tr><td><code id="Bfocvec_+3A_tdip">Tdip</code></td>
<td>
<p>vector of dips, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculation is based on Froelich's paper.
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>Bdip</code></td>
<td>
<p>azimuths, degrees</p>
</td></tr>
<tr><td><code>Baz</code></td>
<td>
<p> dips, degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>C. Frohlich.   Triangle   diagrams:   ternary  graphs   to display  similarity and   diversity  of earthquake    focal mechanisms.    Physics  of the Earth  and Planetary Interiors,  75:193-198,   1992.</p>


<h3>See Also</h3>

<p>ternfoc.point</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Msdr = CONVERTSDR(55.01, 165.65,  29.2   )
 MEC = MRake(Msdr$M)
  MEC$UP = FALSE 
   az1 = Msdr$M$az1
  dip1 = Msdr$M$d1
  az2 = Msdr$M$az2
  dip2 = Msdr$M$d2
  BBB = Bfocvec(az1, dip1,  az2,  dip2)
  V = ternfoc.point(BBB$Bdip, Msdr$M$pd, Msdr$M$td )

</code></pre>

<hr>
<h2 id='BOXarrows3D'>Create a 3D Arrow structure</h2><span id='topic+BOXarrows3D'></span>

<h3>Description</h3>

<p>Create and project and plot 3D arrows with viewing Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BOXarrows3D(x1, y1, z1, x2, y2, z2, aglyph = NULL, Rview = ROTX(0),
col = grey(0.5), border = "black", len = 0.7, basethick = 0.05,
headlen = 0.3, headlip = 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BOXarrows3D_+3A_x1">x1</code></td>
<td>
<p>x-coordinates of base of arrows </p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_y1">y1</code></td>
<td>
<p>y-coordinates of base of arrows </p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_z1">z1</code></td>
<td>
<p>z-coordinates of base of arrows</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_x2">x2</code></td>
<td>
<p>x-coordinates of head of arrows</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_y2">y2</code></td>
<td>
<p>y-coordinates of head of arrows</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_z2">z2</code></td>
<td>
<p>z-coordinates of head of arrows</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_aglyph">aglyph</code></td>
<td>
<p>glyph structure, default is Z3Darrow</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_rview">Rview</code></td>
<td>
<p>Viewing matrix</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_col">col</code></td>
<td>
<p>fill color</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_border">border</code></td>
<td>
<p>Border color</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_len">len</code></td>
<td>
<p>Length</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_basethick">basethick</code></td>
<td>
<p>thickness of the base</p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_headlen">headlen</code></td>
<td>
<p>thickness of the head </p>
</td></tr>
<tr><td><code id="BOXarrows3D_+3A_headlip">headlip</code></td>
<td>
<p>width of the overhanging lip</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arrows point from base to head.
</p>


<h3>Value</h3>

<p>Used for graphical side effects.
</p>


<h3>Note</h3>

<p> Any 3D glyph strucutre can be used
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Z3Darrow</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### animate 10 random arrow vectors


 L   = list(x1 = runif(10, min=-2, max=2),
    y1 = runif(10, min=-2, max=2),
    z1=runif(10, min=-4, max=4),
    x2 = runif(10, min=-2, max=2),
    y2 = runif(10, min=-2, max=2),
    z2=runif(10, min=-4, max=4)
    )
  headlen = .3
  len = .7
  basethick = 0.05
  headlip = .02
  aglyph = Z3Darrow(len = len , basethick =basethick , headlen =headlen , headlip=headlip )

  r1 = 8
  theta = seq(from=0, to=2*360, length=200)
  mex = r1*cos(theta*pi/180)
  mey = r1*sin(theta*pi/180)
  mez = seq(from=r1, to =0 , length=length(mex))
  ##  mez=rep(r1, length=length(mex))
  
  angz = atan2(mey, mex)*180/pi
  angx = atan2(sqrt(mex^2+mey^2), mez)*180/pi
  pal=c("red", "blue", "green")

##  aglyph = gblock

  for(j in 1:length(angz))
    {
      Rview  =    ROTZ(angz[j])
      plot(c(-4,4), c(-4,4), type='n', asp=1); grid()
      
      BOXarrows3D(L$x1,L$y1,L$z1, L$x2,L$y2,L$z2,  aglyph=aglyph,  Rview=Rview, col=pal)
      
      Sys.sleep(.1)
    }

## End(Not run)


</code></pre>

<hr>
<h2 id='circtics'>Draw circular ticmarks</h2><span id='topic+circtics'></span>

<h3>Description</h3>

<p>Draw circular ticmarks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circtics(r = 1, dr = 0.02, dang = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circtics_+3A_r">r</code></td>
<td>
<p>radius</p>
</td></tr>
<tr><td><code id="circtics_+3A_dr">dr</code></td>
<td>
<p>length of tics</p>
</td></tr>
<tr><td><code id="circtics_+3A_dang">dang</code></td>
<td>
<p>angle between tics </p>
</td></tr>
<tr><td><code id="circtics_+3A_...">...</code></td>
<td>
<p>graphical parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 phi = seq(from =0, to = 2 * pi, length=360)
    x = cos(phi)
    y = sin(phi)
    plot(x, y, col = 'blue', asp=1, type='l')
   circtics(r = 1, dr = 0.02, dang = 10, col='red')




</code></pre>

<hr>
<h2 id='CONVERTSDR'>Convert Strike-Dip-Rake to MEC structure</h2><span id='topic+CONVERTSDR'></span>

<h3>Description</h3>

<p>Takes Strike-Dip-Rake and creates planes and pole locations for MEC structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CONVERTSDR(strike, dip, rake)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CONVERTSDR_+3A_strike">strike</code></td>
<td>
<p>angle, degrees,  strike of  down dip directin</p>
</td></tr>
<tr><td><code id="CONVERTSDR_+3A_dip">dip</code></td>
<td>
<p>angle, degrees, dip is measured from the horizontal NOT from the  NADIR</p>
</td></tr>
<tr><td><code id="CONVERTSDR_+3A_rake">rake</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input is strike dip and rake in degrees
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>strike</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code>dipdir</code></td>
<td>
<p>dip</p>
</td></tr>
<tr><td><code>rake</code></td>
<td>
<p>rake</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>list(az, dip) of F-pole</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>list(az, dip) of G-pole</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>list(az, dip) of U-pole</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>list(az, dip) of V-pole</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>list(az, dip) of P-pole</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>list(az, dip) of T-pole</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>list( az1=0, d1=0,  az2=0, d2=0, uaz=0, ud=0, vaz=0, vd=0, paz=0, pd =0, taz=0, td=0)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>BeachFoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s=65
d=25
r=13

  mc = CONVERTSDR(s,d,r )
</code></pre>

<hr>
<h2 id='cross.prod'>Vector Cross Product</h2><span id='topic+cross.prod'></span>

<h3>Description</h3>

<p>Vector Cross Product with list as arguments and list as values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross.prod(B, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross.prod_+3A_b">B</code></td>
<td>
<p>list of x,y,z </p>
</td></tr>
<tr><td><code id="cross.prod_+3A_a">A</code></td>
<td>
<p>list of x,y,z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>vector of cross product</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>RSEIS::xprod</p>


<h3>Examples</h3>

<pre><code class='language-R'>B1 = list(x=4, y=9, z=2)
B2 = list(x=2,y=-5,z=4)

cross.prod(B1, B2)


</code></pre>

<hr>
<h2 id='CROSSL'>Vector Cross Product</h2><span id='topic+CROSSL'></span>

<h3>Description</h3>

<p>returns cross product of two vectors in list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CROSSL(A1, A2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CROSSL_+3A_a1">A1</code></td>
<td>
<p>list x,y,z</p>
</td></tr>
<tr><td><code id="CROSSL_+3A_a2">A2</code></td>
<td>
<p>list x,y,z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip, degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>RSEIS::xprod</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A1 = list(x=1,y=2, z=3)
A2 = list(x=12,y=-2, z=-5)

N = CROSSL(A1, A2)

</code></pre>

<hr>
<h2 id='doNonDouble'>Plot Non-double Couple Moment
</h2><span id='topic+doNonDouble'></span>

<h3>Description</h3>

<p>Plot Non-double Couple Moment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doNonDouble(moments, sel = 1, col=rgb(1, .75, .75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doNonDouble_+3A_moments">moments</code></td>
<td>
<p>list of moments: seven elements. See details.
</p>
</td></tr>
<tr><td><code id="doNonDouble_+3A_sel">sel</code></td>
<td>
<p>integer vector, index of moments to plot
</p>
</td></tr>
<tr><td><code id="doNonDouble_+3A_col">col</code></td>
<td>
<p>color, either a single color, rgb, or a color palette
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot, sequentially the
moments using the CLVD (non-double couple component.
The first element of the list is the integer index of the event.
The next six elements are the moments in
the following order, c(Mxx, Myy, Mzz, Mzy, Mxz, Mxy) .
</p>
<p>If the data is in spherical coordinates, one must switch the
sign of the Mrp and Mtp components, so:
<code style="white-space: pre;">&#8288;
    Mrr = Mzz
    Mtt = Mxx
    Mpp = Myy
    Mrt = Mxz
    Mrp = -Myz
    Mtp = -Mxy
&#8288;</code>
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Note</h3>

<p>If events are read in using spherical rather than cartesian
coordinates
need a conversion:
<code style="white-space: pre;">&#8288;
    Mrr = Mzz
    Mtt = Mxx
    Mpp = Myy
    Mrt = Mxz
    Mrp = -Myz
    Mtp = -Mxy
&#8288;</code>
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Ekstrom, G.; Nettles, M. and  DziewoDski, A.
The Global CMT Project 2004-2010: centroid-moment tensors for 13,017
earthquakes Physics of the Earth and Planetary Interiors, 2012.
</p>


<h3>See Also</h3>

<p>MapNonDouble, ShadowCLVD, angles, nodalLines, PTaxes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mo = list(n=1, m1=1.035675e+017, m2=-1.985852e+016,
m3=-6.198052e+014, m4=1.177936e+017, m5=-7.600627e+016,
m6=-3.461405e+017)

moments = cbind(mo$n, mo$m1, mo$m2, mo$m3, mo$m4, mo$m5, mo$m6)

doNonDouble(moments)



</code></pre>

<hr>
<h2 id='EApoint'>Equal-area point stereonet</h2><span id='topic+EApoint'></span>

<h3>Description</h3>

<p>Interactive locator to
calculate x,y orientation, dip
coordinates and plots on an equalarea stereonet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EApoint()
</code></pre>


<h3>Details</h3>

<p>Used for returning a set of strike/dip angles on Equal-area stereonet
plot.  
</p>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>orientation, degrees</p>
</td></tr>
<tr><td><code>iang</code></td>
<td>
<p>angle of dip, degrees</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>qpoint, focpoint</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####################  this is interactive

###  collect points with locator()
## Not run: 
net()
eps = EApoint()

###  plot results
net()
qpoint(eps$phi , eps$iang)

## End(Not run)

</code></pre>

<hr>
<h2 id='egl'>Tungurahua Cartesian Moment Tensors</h2><span id='topic+egl'></span>

<h3>Description</h3>

<p>Cartesian  moment tensors from Tungurahua Volcano, Ecuador
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(egl)
</code></pre>


<h3>Format</h3>

<p>A list of 84 moment tensors, each elelment consists of:
lam1, lam2, lam3, vec1, vec2,vec3, ratio, force.
</p>


<h3>Source</h3>

<p>See below
</p>


<h3>References</h3>

<p>Kim, K., Lees, J.M. and Ruiz, M., (2014) Source mechanism of Vulcanian eruption at Tungurahua Volcano, Ecuador, derived from seismic moment tensor inversions, <em>J. Geophys. Res.</em>, February, 2014. Vol. 119(2): pp. 1145-1164.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(egl)

typl1=c(2,4,7,12,13,16,17,18,19,20,24,25,26,27,
28,29,30,31,33,34,35,36,37,38,40,43,50,
59,62,73,74,77,8,79,80,81,83,84)
typl2=c(5,6,8,9,10,11,14,15,22,42,46,47,48,49,
51,52,53,54,55,56,57,58,60,61,63,72,82)

evtns=1:84

par(mfrow=c(1,2))
T1 = TapeBase()
TapePlot(T1)


for(i in 1:length(egl))
{
i1 = egl[[i]]

E1 = list(values=c(i1$lam1, i1$lam2, i1$lam3),
vectors = cbind(i1$vec1, i1$vec2, i1$vec3))

testrightHAND(E1$vectors)

E1$vectors = forcerighthand(E1$vectors)

mo=sort(E1$values,decreasing=TRUE)
# M=sum(mo)/3
# Md=mo-M
h = SourceType(mo)
h$dip = 90-h$phi

h1 = HAMMERprojXY(h$dip*pi/180, h$lam*pi/180)

if(i %in% typl1) { col="red" }else{col="blue" }
points(h1$x, h1$y,  pch=21, bg=col )

}

par(mai=c(0,0,0,0))
hudson.net()
for(i in 1:length(typl1))
{
egv=egl[[typl1[i]]]
m=c(egv$lam1,egv$lam2,egv$lam3)
col='red'
hudson.plot(m=m,col=col)
}

for(i in 1:length(typl2))
{
egv=egl[[typl2[i]]]
m=c(egv$lam1,egv$lam2,egv$lam3)
col='blue'
hudson.plot(m=m,col=col,lwd=2)
}


</code></pre>

<hr>
<h2 id='fancyarrows'>Make fancy arrows</h2><span id='topic+fancyarrows'></span>

<h3>Description</h3>

<p>Create and plot fancy arrows. Aspect ratio must be set to 1-1
for these arrows to plot correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fancyarrows(x1, y1, x2, y2, thick = 0.08,
     headlength = 0.4, headthick = 0.2, col = grey(0.5),
     border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fancyarrows_+3A_x1">x1</code></td>
<td>
<p>x  tail coordinate</p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_y1">y1</code></td>
<td>
<p>y  tail coordinate</p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_x2">x2</code></td>
<td>
<p>x  head coordinate </p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_y2">y2</code></td>
<td>
<p>y  head coordinate </p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_thick">thick</code></td>
<td>
<p>thickness of arrow </p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_headlength">headlength</code></td>
<td>
<p>length of head </p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_headthick">headthick</code></td>
<td>
<p>thickness of head</p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_col">col</code></td>
<td>
<p>fill color </p>
</td></tr>
<tr><td><code id="fancyarrows_+3A_border">border</code></td>
<td>
<p>color of border</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical side effects.
</p>


<h3>Note</h3>

<p>fancyarrows only work if te aspect ratio is set to 1. See example below.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>TEACHFOC</p>


<h3>Examples</h3>

<pre><code class='language-R'>   thick = 0.01; headlength = 0.2; headthick = 0.1

x = runif(10, -1, 1)
y = runif(10, -1, 1)

############   MUST set asp=1 here
plot(x,y, asp=1)

fancyarrows(rep(0, 10) , rep(0, 10) ,x, y,
thick =thick , headlength =  headlength,
headthick =headthick)

</code></pre>

<hr>
<h2 id='faultplane'>fault plane projection on focal sphere</h2><span id='topic+faultplane'></span>

<h3>Description</h3>

<p>given azimuth and dip of fault mechanism, calculate and plot the
fault plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultplane(az, dip, col = par("col"), PLOT = TRUE, UP = FALSE,lwd=2, lty=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultplane_+3A_az">az</code></td>
<td>
<p>degrees, strike of the plane (NOT down dip azimuth)</p>
</td></tr>
<tr><td><code id="faultplane_+3A_dip">dip</code></td>
<td>
<p>degrees,  dip from horizontal</p>
</td></tr>
<tr><td><code id="faultplane_+3A_col">col</code></td>
<td>
<p>color for line</p>
</td></tr>
<tr><td><code id="faultplane_+3A_plot">PLOT</code></td>
<td>
<p>option for adding to plot</p>
</td></tr>
<tr><td><code id="faultplane_+3A_up">UP</code></td>
<td>
<p>upper or lower hemisphere</p>
</td></tr>
<tr><td><code id="faultplane_+3A_lwd">lwd</code></td>
<td>
<p>Line Width</p>
</td></tr>
<tr><td><code id="faultplane_+3A_lty">lty</code></td>
<td>
<p>Line Type</p>
</td></tr>
<tr><td><code id="faultplane_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Azimuth is the strike in degrees, not the down dip azimuth as
described in other routines. 
</p>


<h3>Value</h3>

<p>list of points along fault plane
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>coordinates on focal sphere</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>coordinates on focal sphere</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Beachfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gcol='black'
border='black'
ndiv=36
phi = seq(0,2*pi, by=2*pi/ndiv);
  x = cos(phi);
  y = sin(phi);

plot(x,y, type='n', asp=1)
  lines(x,y, col=border)
  lines(c(-1,1), c(0,0), col=gcol)
  lines(c(0,0), c(-1,1), col=gcol)

faultplane(65, 34)


</code></pre>

<hr>
<h2 id='FixDip'>Fix Dip Angle</h2><span id='topic+FixDip'></span>

<h3>Description</h3>

<p>Fix az, dip angles so they fall in correct quadrant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixDip(A)
</code></pre>


<h3>Arguments</h3>

<p>List:
</p>
<table>
<tr><td><code id="FixDip_+3A_a">A</code></td>
<td>


<dl>
<dt>az</dt><dd><p>azimuthm angle, degrees</p>
</dd>
<dt>dip</dt><dd><p>dip angle, degrees</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>Quadrants are determined by the sine and cosine of the dip angle:
<code>co = cos(dip) </code>
<code>si = sin(dip) </code>
<code>quad[co&gt;=0 &amp; si&gt;=0] = 1 </code>
<code>quad[co&lt;0 &amp; si&gt;=0] = 2 </code>
<code>quad[co&lt;0 &amp; si&lt;0] = 3 </code>
<code>quad[co&gt;=0 &amp; si&lt;0] = 4 </code>
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>az</code></td>
<td>
<p>azimuthm angle, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip angle, degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>RPMG::fmod</p>


<h3>Examples</h3>

<pre><code class='language-R'>
B = list(az=231, dip = -65)

FixDip(B)


</code></pre>

<hr>
<h2 id='flipnodal'>Flip Nodal Fault Plane
</h2><span id='topic+flipnodal'></span>

<h3>Description</h3>

<p>Switch a focal mechanism
so the auxilliary plane is the nodal plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipnodal(s1, d1, r1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipnodal_+3A_s1">s1</code></td>
<td>
<p>Strike
</p>
</td></tr>
<tr><td><code id="flipnodal_+3A_d1">d1</code></td>
<td>
<p>Dip
</p>
</td></tr>
<tr><td><code id="flipnodal_+3A_r1">r1</code></td>
<td>
<p>Rake
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fuunction is used for
orienting a  set of fault planes
to line up according to a geologic interpretation.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>s1</code></td>
<td>
<p>Strike
</p>
</td></tr>
<tr><td><code>d1</code></td>
<td>
<p>Dip
</p>
</td></tr>
<tr><td><code>r1</code></td>
<td>
<p>Rake
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

s=65
d=25
r=13

  mc = CONVERTSDR(s,d,r )

  mc2 = flipnodal(s, d, r)

</code></pre>

<hr>
<h2 id='foc.color'>Get color of Focal Mechansim</h2><span id='topic+foc.color'></span>

<h3>Description</h3>

<p>Based on the rake angle, focal styles are assigned
an index and assigned a color by foc.color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foc.color(i, pal = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foc.color_+3A_i">i</code></td>
<td>
<p>index to list of focal rupture styles</p>
</td></tr>
<tr><td><code id="foc.color_+3A_pal">pal</code></td>
<td>
<p>vector of colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the colors used by focal programs are arbitrary,
this routines allows one to change the coloring scheme
easily.
</p>
<p>foc.icolor returns an index that is used to get the color
associated with that style of faulting
</p>


<h3>Value</h3>

<p>Color for plotting, either a name or HEX RGB
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>foc.icolor</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 fcolors=c("DarkSeaGreen", "cyan1","SkyBlue1" , "RoyalBlue" ,"GreenYellow","orange","red")
      foc.color(3, fcolors)
</code></pre>

<hr>
<h2 id='foc.icolor'>Get Fault Style</h2><span id='topic+foc.icolor'></span>

<h3>Description</h3>

<p>Use Rake Angle to determine style of faulting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foc.icolor(rake)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foc.icolor_+3A_rake">rake</code></td>
<td>
<p>degrees, rake angle of fault plane</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The styles are determined by the rake angle
</p>
<p>strikeslip  abs(rake) &lt;= 15.0 or   abs((180.0 - abs(rake))) &lt;= 15.0
</p>
<p>rev-obl strk-slp   (rake &gt;= 15.0 and rake &lt; 45) or (rake &gt;= 135 and rake
&lt; 165)
</p>
<p>oblique reverse  (rake &gt;= 45.0 and rake &lt; 75) or (rake &gt;= 105 and rake &lt;
135)
</p>
<p>reverse   rake &gt;= 75.0 and rake &lt; 105.0
</p>
<p>norm-oblq strkslp  (rake &lt; -15.0 and rake &gt;= -45) or (rake &lt; -135 and
rake &gt;= -165)
</p>
<p>oblq norm   (rake &lt; -45.0 and rake &gt;= -75) or (rake &lt; -105 and rake &gt;=
-135)
</p>
<p>normal rake &lt; -75.0 and rake &gt;= -105
</p>


<h3>Value</h3>

<p>index (1-6)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>foc.color </p>


<h3>Examples</h3>

<pre><code class='language-R'>foc.icolor(25)


</code></pre>

<hr>
<h2 id='FOCangles'>Angles for focal planes
</h2><span id='topic+FOCangles'></span>

<h3>Description</h3>

<p>Angles for focal planes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOCangles(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FOCangles_+3A_m">m</code></td>
<td>
<p>moment tensor
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in MapNonDouble and doNonDouble
</p>


<h3>Value</h3>

<p>vector of 6 angles, 3 for each plane
</p>


<h3>Note</h3>

<p>Lower Hemisphere.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p> MapNonDouble, doNonDouble, PTaxes, nodalLines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mo = list(n=1, m1=1.035675e+017, m2=-1.985852e+016,
  m3=-6.198052e+014, m4=1.177936e+017,
  m5=-7.600627e+016, m6=-3.461405e+017)


moments = cbind(mo$n, mo$m1, mo$m2, mo$m3, mo$m4, mo$m5, mo$m6)

 di = dim(moments)
    number.of.events = di[1]
moment_11 = moments[,2]
moment_22 = moments[,3]
moment_33 = moments[,4]
moment_23 = moments[,5]
moment_13 = moments[,6]
moment_12 = moments[,7]


i = 1
m=matrix( c(moment_11[i],moment_12[i],moment_13[i],
       moment_12[i],moment_22[i],moment_23[i],
       moment_13[i],moment_23[i],moment_33[i]), ncol=3, byrow=TRUE)

   angles.all = FOCangles(m)
print(angles.all)




</code></pre>

<hr>
<h2 id='focleg'>Fault style descriptor</h2><span id='topic+focleg'></span>

<h3>Description</h3>

<p>Get character string describing type of fault from its style index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focleg(i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focleg_+3A_i">i</code></td>
<td>
<p> index to vector of focal styles </p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string used for setting text on plots 
</p>


<h3>Note</h3>

 
<p>String of characters:
</p>

<dl>
<dt>STRIKESLIP</dt><dd><p>Strike slip fault</p>
</dd>
<dt>REV-OBL STRK-SLP</dt><dd><p>Reverse Oblique strike-slip fault</p>
</dd>
<dt>REVERSE</dt><dd><p>Reverse fault</p>
</dd>
<dt>NORM-OBLQ STRKSLP</dt><dd><p>Normal Oblique strike-slip fault</p>
</dd>
<dt>OBLQ NORM</dt><dd><p>Oblique Normal fault</p>
</dd>
<dt>NORMAL</dt><dd><p>Formal fault</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>foc.icolor, foc.color</p>


<h3>Examples</h3>

<pre><code class='language-R'>focleg(2)
</code></pre>

<hr>
<h2 id='focpoint'>add point on focal sphere</h2><span id='topic+focpoint'></span>

<h3>Description</h3>

<p>Add points on equal-area focal plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focpoint(az1, dip1, col = 2, pch = 5, lab = "", cex=1,  UP = FALSE, PLOT = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focpoint_+3A_az1">az1</code></td>
<td>
<p>degrees, azimuth angle </p>
</td></tr>
<tr><td><code id="focpoint_+3A_dip1">dip1</code></td>
<td>
<p>degrees, dip angle </p>
</td></tr>
<tr><td><code id="focpoint_+3A_col">col</code></td>
<td>
<p>color  </p>
</td></tr>
<tr><td><code id="focpoint_+3A_pch">pch</code></td>
<td>
<p>plot character for point </p>
</td></tr>
<tr><td><code id="focpoint_+3A_lab">lab</code></td>
<td>
<p>text lable for point </p>
</td></tr>
<tr><td><code id="focpoint_+3A_cex">cex</code></td>
<td>
<p>Character Size </p>
</td></tr>
<tr><td><code id="focpoint_+3A_up">UP</code></td>
<td>
<p>upper or lower hemisphere  </p>
</td></tr>
<tr><td><code id="focpoint_+3A_plot">PLOT</code></td>
<td>
<p>logical, PLOT=TRUE add points to current plot </p>
</td></tr>
<tr><td><code id="focpoint_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of x,y coordinates on the plot
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Beachfoc, addmecpoints</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  create focal mech
ALIM=c(-1,-1, +1, +1)
s=65
d=25
r=13
mc = CONVERTSDR(s,d,r )
  MEC = MRake(mc$M)
  MEC$UP = FALSE
  MEC$icol =  foc.icolor(MEC$rake1)
  MEC$ileg =  focleg(MEC$icol)
  MEC$fcol =   foc.color(MEC$icol)
  MEC$CNVRG = NA
  MEC$LIM = ALIM

###  plot focal mech
Beachfoc(MEC, fcol=MEC$fcol, fcolback="white")

###  now add the F anf G axes
focpoint(MEC$F$az, MEC$F$dip, pch=5, lab="F", UP=MEC$UP)
    focpoint(MEC$G$az, MEC$G$dip, pch=5, lab="G", UP=MEC$UP)


</code></pre>

<hr>
<h2 id='forcerighthand'>Force Right-Hand System
</h2><span id='topic+forcerighthand'></span>

<h3>Description</h3>

<p>Force Right-Hand System
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forcerighthand(U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forcerighthand_+3A_u">U</code></td>
<td>
<p>3 by 3 matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Flip vectors so they
form a right handed system
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>testrightHAND
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Mtens = c(-0.412, 0.084, 0.328 ,0.398, -1.239, 1.058)
M1 = matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4], Mtens[2],
Mtens[6], Mtens[5],Mtens[6], Mtens[3]), ncol=3, nrow=3, byrow=TRUE)
E1 = eigen(M1)
testrightHAND(E1$vectors) 

E1$vectors = forcerighthand(E1$vectors) 

testrightHAND(E1$vectors) 


</code></pre>

<hr>
<h2 id='getCMT'>Read CMT 
</h2><span id='topic+getCMT'></span>

<h3>Description</h3>

<p>Read and reformat CMT solutions downloaded from the web.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCMT(fn, skip=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCMT_+3A_fn">fn</code></td>
<td>
<p>character file name
</p>
</td></tr>
<tr><td><code id="getCMT_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip (e.g. header)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data can be extracted from web site:
http://www.globalcmt.org/CMTsearch.html
</p>
<p>The file must be cleaned prior to scanning -
on download from the web site there are extra
lines on top and bottom of file.
Delete these.
Leave one line on the top that describesthe columns.
Data is separated by blanks.
The files have a mixture of
dates - some with 7 component dates (YYMMDD and others with 14
components YYYYMODDHHMM these are read in separately.
Missing hours and minutes areset to zero.
</p>


<h3>Value</h3>

<p>list of CMT solution data:
</p>
<table>
<tr><td><code>lon</code></td>
<td>
<p>lon of epicenter</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>lat of epicenter</p>
</td></tr>
<tr><td><code>str1</code></td>
<td>
<p>strike of fault plane</p>
</td></tr>
<tr><td><code>dip1</code></td>
<td>
<p>dip of fault plane</p>
</td></tr>
<tr><td><code>rake1</code></td>
<td>
<p>rake  of fault plane</p>
</td></tr>
<tr><td><code>str2</code></td>
<td>
<p>strike of auxilliary plane</p>
</td></tr>
<tr><td><code>dip2</code></td>
<td>
<p>dip  of auxilliary plane</p>
</td></tr>
<tr><td><code>rake2</code></td>
<td>
<p>rake of auxilliary plane </p>
</td></tr>
<tr><td><code>sc</code></td>
<td>
<p>scale?</p>
</td></tr>
<tr><td><code>iexp</code></td>
<td>
<p>exponent?</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>name, includes the date</p>
</td></tr>
<tr><td><code>Elat</code></td>
<td>
<p>exploding latitude, set to lat initially</p>
</td></tr>
<tr><td><code>Elon</code></td>
<td>
<p>exploding longitude, set to lon initially</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>julian day</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>day of month</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use ExplodeSymbols or explode to get new locations
for expanding the plotting points.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://www.globalcmt.org/CMTsearch.html
</p>
<p>G. Ekstrom. Rapid earthquake analysis utilizes the internet. 
Computers in Physics,   8:632-638,  1994.
</p>


<h3>See Also</h3>

<p>ExplodeSymbols, spherefocgeo, ternfocgeo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


g = getCMT("/home/lees/aleut.cmt")

pg = prepFOCS(g)


plot(range(pg$LONS), range(pg$LATS), type = "n", xlab = "LON",
    ylab = "LAT", asp = 1)


 for (i in 1:length(pg$LATS)) {
    mc = CONVERTSDR(g$str1[i], g$dip1[i], g$rake1[i])
     MEC &lt;- MRake(mc$M)
MEC$UP = FALSE
     Fcol &lt;- foc.color(foc.icolor(MEC$rake1), pal = 1)
     justfocXY(MEC, x = pg$LONS[i], y = pg$LATS[i], focsiz = 0.4,
     fcol = Fcol, xpd = FALSE)
 }




## End(Not run)




</code></pre>

<hr>
<h2 id='GetRake'>Calculate Rake angles</h2><span id='topic+GetRake'></span>

<h3>Description</h3>

<p>Calculates rake angles for fault and auxilliary planes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRake(az1, dip1, az2, dip2, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRake_+3A_az1">az1</code></td>
<td>
<p>azimuth in degrees of fault plane 1</p>
</td></tr>
<tr><td><code id="GetRake_+3A_dip1">dip1</code></td>
<td>
<p>dip in degrees of fault plane 1</p>
</td></tr>
<tr><td><code id="GetRake_+3A_az2">az2</code></td>
<td>
<p>azimuth in degrees of auxilliary plane 2</p>
</td></tr>
<tr><td><code id="GetRake_+3A_dip2">dip2</code></td>
<td>
<p>dip in degrees of auxilliary plane 2</p>
</td></tr>
<tr><td><code id="GetRake_+3A_dir">dir</code></td>
<td>
<p>polarity </p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses output of CONVERTSDR or MEC structure
</p>


<h3>Value</h3>

<p>list of angles for fault plane and auxiallary plane
</p>
<table>
<tr><td><code>az1</code>, <code>dip1</code>, <code>rake1</code>, <code>dipaz1</code></td>
<td>
<p>strike, dip rake and downdip direction
for plane 1</p>
</td></tr>
<tr><td><code>az2</code>, <code>dip2</code>, <code>rake2</code>, <code>dipaz2</code></td>
<td>
<p>strike, dip rake and downdip direction
for plane 2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GetRakeSense, CONVERTSDR, Beachfoc, justfocXY </p>


<h3>Examples</h3>

<pre><code class='language-R'>
GetRake(345.000000, 25.000000, 122.000000, 71.000000, 1)

</code></pre>

<hr>
<h2 id='GetRakeSense'>Get Rake Sense </h2><span id='topic+GetRakeSense'></span>

<h3>Description</h3>

<p>Get the sense of the focal mechanism rake, from the U, V, P, T vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRakeSense(uaz, upl, vaz, vpl, paz, ppl, taz, tpl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRakeSense_+3A_uaz">uaz</code></td>
<td>
<p>Azimuth of U vector</p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_upl">upl</code></td>
<td>
<p>dip of U vector</p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_vaz">vaz</code></td>
<td>
<p>Azimuth of V vector </p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_vpl">vpl</code></td>
<td>
<p>dip of V vector</p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_paz">paz</code></td>
<td>
<p>Azimuth of P vector</p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_ppl">ppl</code></td>
<td>
<p>dip of P vector </p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_taz">taz</code></td>
<td>
<p>Azimuth of T vector</p>
</td></tr>
<tr><td><code id="GetRakeSense_+3A_tpl">tpl</code></td>
<td>
<p>dip of T vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1, 0 to make sure the region of the T-axis is shaded and the P-axis
is blank.
</p>


<h3>Note</h3>

<p>The convention is for the T-axis to be shaded,
so this subroutine determines the order of the polygons to be plotted
so that the appropriate regins are filled.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GetRake</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mc =CONVERTSDR(65,25,13)


angsense = GetRakeSense(mc$U$az, mc$U$dip, mc$V$az, mc$V$dip,mc$P$az, mc$P$dip,mc$T$az, mc$T$dip)


</code></pre>

<hr>
<h2 id='getUWfocs'>Get UW focals
</h2><span id='topic+getUWfocs'></span>

<h3>Description</h3>

<p>Get UW focal mechansims from a file.
These are often called A and M cards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUWfocs(amfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUWfocs_+3A_amfile">amfile</code></td>
<td>
<p>character, file name
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>UW focal mechanisms are stored as A and M cards.
The A card described the hypocenter the M card describes the
focal mechanism.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>lon</code></td>
<td>
<p>numeric, longitude</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>numeric, latitude</p>
</td></tr>
<tr><td><code>str1</code></td>
<td>
<p>numeric, strike of plane 1</p>
</td></tr>
<tr><td><code>dip1</code></td>
<td>
<p>numeric, dip of plane 1</p>
</td></tr>
<tr><td><code>rake1</code></td>
<td>
<p>numeric, rake of plane 1</p>
</td></tr>
<tr><td><code>str2</code></td>
<td>
<p>numeric, strike of plane 2 </p>
</td></tr>
<tr><td><code>dip2</code></td>
<td>
<p>numeric, dip of plane 2 </p>
</td></tr>
<tr><td><code>rake2</code></td>
<td>
<p>numeric, rake of plane 2</p>
</td></tr>
<tr><td><code>sc</code></td>
<td>
<p>character, some GMT info for scale</p>
</td></tr>
<tr><td><code>iexp</code></td>
<td>
<p>character, some GMT info for scale</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>character, name</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>numeric, year</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>numeric, month</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>numeric, day of month</p>
</td></tr>
<tr><td><code>jd</code></td>
<td>
<p>numeric, julian day</p>
</td></tr>
<tr><td><code>hr</code></td>
<td>
<p>numeric, hour</p>
</td></tr>
<tr><td><code>mi</code></td>
<td>
<p>numeric, minute</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>numeric, second</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>numeric, depth</p>
</td></tr>
<tr><td><code>mag</code></td>
<td>
<p>numeric, magnitude</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Uses UW2 format, so full 4 digit year is required
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://www.unc.edu/~leesj/XM_DOC/xm_hypo.doc.html
</p>


<h3>See Also</h3>

<p>getCMT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#####  uwpickfile is an ascii format file from University of Washington
G1 = getUWfocs(uwpickfile)

plot(G1$lon, G1$lat)

 MEKS = list(lon=G1$lon, lat=G1$lat, str1=G1$str1,
dip1=G1$dip1, rake1=G1$rake1, dep=G1$z, name=G1$name)

##   utm projection
 PROJ = GEOmap::setPROJ(type=2, LAT0=mean(G1$lat) , LON0=mean(G1$lon) )   

     XY = GEOmap::GLOB.XY(G1$lat, G1$lon, PROJ)

     plot(range(XY$x), range(XY$y), type='n', asp=1)

     plotmanyfoc(MEKS, PROJ, focsiz=0.05)




## End(Not run)



</code></pre>

<hr>
<h2 id='HAMMERprojXY'>Hammer Projection
</h2><span id='topic+HAMMERprojXY'></span>

<h3>Description</h3>

<p>Hammer Equal Area projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HAMMERprojXY(phi, lam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HAMMERprojXY_+3A_phi">phi</code></td>
<td>
<p>Latitude, radians
</p>
</td></tr>
<tr><td><code id="HAMMERprojXY_+3A_lam">lam</code></td>
<td>
<p>Longitude, radians
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>coordinate for plotting</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>coordinate for plotting</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
HAMMERprojXY(-25*pi/180, -16*pi/180)

</code></pre>

<hr>
<h2 id='hudson.net'>Hudson Net Plot
</h2><span id='topic+hudson.net'></span>

<h3>Description</h3>

<p>Plot a Hudson plot as preparation for plotting
T-k values for focal mechanisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudson.net(add = FALSE, POINTS = TRUE, TEXT = TRUE,
     colint = "grey", colext = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hudson.net_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to existing plot
</p>
</td></tr>
<tr><td><code id="hudson.net_+3A_points">POINTS</code></td>
<td>
<p>logical, TRUE=add points
</p>
</td></tr>
<tr><td><code id="hudson.net_+3A_text">TEXT</code></td>
<td>
<p>logical, TRUE=add points
</p>
</td></tr>
<tr><td><code id="hudson.net_+3A_colint">colint</code></td>
<td>
<p>color for interior lines
</p>
</td></tr>
<tr><td><code id="hudson.net_+3A_colext">colext</code></td>
<td>
<p>color for exterior lines
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a T-k plot for moment tensors
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Hudson, J.A., Pearce, R.G. and Rogers, R.M., 1989. Source time plot for inversion of the moment tensor, J. Geophys. Res., 94(B1), 765-774.
</p>


<h3>See Also</h3>

<p>hudson.plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudson.net()

Mtens &lt;- c(-0.412, 0.084, 0.328 ,0.398, -1.239, 1.058)

M1 &lt;-  matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4],
Mtens[2], Mtens[6], Mtens[5],Mtens[6], Mtens[3]), ncol=3, nrow=3,
byrow=TRUE)

E1 &lt;-  eigen(M1)

hudson.plot(E1$values)



</code></pre>

<hr>
<h2 id='hudson.plot'>Hudson Source Type Plot
</h2><span id='topic+hudson.plot'></span>

<h3>Description</h3>

<p>Hudson Source Type Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudson.plot(m, col = "red", pch = 21, lwd = 2, cex = 1, bg="white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hudson.plot_+3A_m">m</code></td>
<td>
<p>vector of eigen values, sorted
</p>
</td></tr>
<tr><td><code id="hudson.plot_+3A_col">col</code></td>
<td>
<p>color
</p>
</td></tr>
<tr><td><code id="hudson.plot_+3A_pch">pch</code></td>
<td>
<p>plotting char
</p>
</td></tr>
<tr><td><code id="hudson.plot_+3A_lwd">lwd</code></td>
<td>
<p>line width
</p>
</td></tr>
<tr><td><code id="hudson.plot_+3A_cex">cex</code></td>
<td>
<p>character expansion
</p>
</td></tr>
<tr><td><code id="hudson.plot_+3A_bg">bg</code></td>
<td>
<p>background color for filled symbols
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add to existing Hudson net
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Hudson, J.A., Pearce, R.G. and Rogers, R.M., 1989. Source time plot for inversion of the moment tensor, J. Geophys. Res., 94(B1), 765-774.
</p>


<h3>See Also</h3>

<p>hudson.net
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudson.net()

Mtens &lt;- c(-0.412, 0.084, 0.328 ,0.398, -1.239, 1.058)

M1 &lt;- matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4],
Mtens[2], Mtens[6], Mtens[5],Mtens[6],
Mtens[3]), ncol=3, nrow=3, byrow=TRUE)

E1 &lt;-  eigen(M1)

hudson.plot(E1$values)


</code></pre>

<hr>
<h2 id='imageP'>P-wave radiation pattern</h2><span id='topic+imageP'></span>

<h3>Description</h3>

<p>Amplitude of P-wave radiation pattern from Double-Couple earthquake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageP(phiS, del, lam, SCALE = FALSE, UP = FALSE, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageP_+3A_phis">phiS</code></td>
<td>
<p>strike </p>
</td></tr>
<tr><td><code id="imageP_+3A_del">del</code></td>
<td>
<p>dip </p>
</td></tr>
<tr><td><code id="imageP_+3A_lam">lam</code></td>
<td>
<p>lambda</p>
</td></tr>
<tr><td><code id="imageP_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale on side of plot </p>
</td></tr>
<tr><td><code id="imageP_+3A_up">UP</code></td>
<td>
<p>upper/lower hemisphere </p>
</td></tr>
<tr><td><code id="imageP_+3A_col">col</code></td>
<td>
<p>color </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program calls radP to calculate the radiation pattern and it plots
the result using the standard image function
</p>


<h3>Value</h3>

<p>Used for the graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.
</p>


<h3>See Also</h3>

<p>radP, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
imageP(MEC$az1, MEC$dip1, MEC$rake1, SCALE=TRUE, UP=MEC$UP, col=rainbow(100) )

</code></pre>

<hr>
<h2 id='imageSCALE'>add scale on sice of image</h2><span id='topic+imageSCALE'></span>

<h3>Description</h3>

<p>add scale to side of an image plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageSCALE(z, col, x, y = NULL, size = NULL, digits = 2,
labels = c("breaks", "ranges"), nlab = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageSCALE_+3A_z">z</code></td>
<td>
<p>elevation matrix </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_col">col</code></td>
<td>
<p>palette for plotting </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_x">x</code></td>
<td>
<p>x location on plot </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_y">y</code></td>
<td>
<p>y location on plot </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_size">size</code></td>
<td>
<p>length of scale </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_digits">digits</code></td>
<td>
<p>digits on labels </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_labels">labels</code></td>
<td>
<p>breaks to be plotted </p>
</td></tr>
<tr><td><code id="imageSCALE_+3A_nlab">nlab</code></td>
<td>
<p> number of breaks to be plotted </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
image(volcano, col=rainbow(100) )

imageSCALE(volcano, rainbow(100), 1.015983, y = 0.874668,
size = .01, digits =
2, labels = "breaks", nlab = 20)




</code></pre>

<hr>
<h2 id='imageSH'>P-wave radiation pattern</h2><span id='topic+imageSH'></span>

<h3>Description</h3>

<p>Amplitude of SH-wave radiation pattern from Double-Couple earthquake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageSH(phiS, del, lam, SCALE = FALSE, UP = FALSE, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageSH_+3A_phis">phiS</code></td>
<td>
<p>strike </p>
</td></tr>
<tr><td><code id="imageSH_+3A_del">del</code></td>
<td>
<p>dip </p>
</td></tr>
<tr><td><code id="imageSH_+3A_lam">lam</code></td>
<td>
<p>lambda</p>
</td></tr>
<tr><td><code id="imageSH_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale on side of plot </p>
</td></tr>
<tr><td><code id="imageSH_+3A_up">UP</code></td>
<td>
<p>upper/lower hemisphere </p>
</td></tr>
<tr><td><code id="imageSH_+3A_col">col</code></td>
<td>
<p>color </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program calls radP to calculate the radiation pattern and it plots
the result using the standard image function
</p>


<h3>Value</h3>

<p>Used for the graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.
</p>


<h3>See Also</h3>

<p>radSH, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
imageSH(MEC$az1, MEC$dip1, MEC$rake1, SCALE=TRUE, UP=MEC$UP, col=rainbow(100) )

</code></pre>

<hr>
<h2 id='imageSV'>P-wave radiation pattern</h2><span id='topic+imageSV'></span>

<h3>Description</h3>

<p>Amplitude of SV-wave radiation pattern from Double-Couple earthquake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageSV(phiS, del, lam, SCALE = FALSE, UP = FALSE, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageSV_+3A_phis">phiS</code></td>
<td>
<p>strike </p>
</td></tr>
<tr><td><code id="imageSV_+3A_del">del</code></td>
<td>
<p>dip </p>
</td></tr>
<tr><td><code id="imageSV_+3A_lam">lam</code></td>
<td>
<p>lambda</p>
</td></tr>
<tr><td><code id="imageSV_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale on side of plot </p>
</td></tr>
<tr><td><code id="imageSV_+3A_up">UP</code></td>
<td>
<p>upper/lower hemisphere </p>
</td></tr>
<tr><td><code id="imageSV_+3A_col">col</code></td>
<td>
<p>color </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program calls radP to calculate the radiation pattern and it plots
the result using the standard image function
</p>


<h3>Value</h3>

<p>Used for the graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.
</p>


<h3>See Also</h3>

<p>radSV, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
imageSV(MEC$az1, MEC$dip1, MEC$rake1, SCALE=TRUE, UP=MEC$UP, col=rainbow(100) )

</code></pre>

<hr>
<h2 id='inverseTAPE'>Inverse Moment Tensor
</h2><span id='topic+inverseTAPE'></span>

<h3>Description</h3>

<p>Inverse moment tensor from
Tape angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseTAPE(GAMMA, BETA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseTAPE_+3A_gamma">GAMMA</code></td>
<td>
<p>Longitude, degrees
</p>
</td></tr>
<tr><td><code id="inverseTAPE_+3A_beta">BETA</code></td>
<td>
<p>CoLatitude, degrees 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Tape and Tape lune angles
to estimate the moment tensor.  This function
is the inverse of the SourceType calculation.
There are two solutions to the
systems of equations.
</p>
<p>Vectors are scaled by the maximum value.
</p>


<h3>Value</h3>

<p>Moment tensor list:
</p>
<table>
<tr><td><code>Va</code></td>
<td>
<p>vector, First solution</p>
</td></tr>
<tr><td><code>Vb</code></td>
<td>
<p>vector, First solution</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The latitude is the CoLatitude.
</p>
<p>Either vector can be used as a solution.
</p>
<p>Orientation of moment tensor is not preserved int he lune plots.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Tape, W.,and C.Tape(2012), A geometric comparison of source-type plots for moment tensors, Geophys. J. Int., 190, 499-510.
</p>


<h3>See Also</h3>

<p>SourceType
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lats = seq(from = -80, to = 80, by=10)
    lons = seq(from=-30, to=30, by=10)

i = 3
j = 3
 u =  inverseTAPE( lons[i], 90-lats[j] ) 



</code></pre>

<hr>
<h2 id='jimbo'>Moment Tensors from the Harvard CMT</h2><span id='topic+jimbo'></span>

<h3>Description</h3>

<p>Moment Tensors from the Harvard CMT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jimbo)
</code></pre>


<h3>Format</h3>

<p>A list of 9 moment tensors from the Kamchatka region.
</p>


<h3>Source</h3>

<p>http://www.globalcmt.org/CMTsearch.html
</p>


<h3>References</h3>

<p>Ekstrom, G.; Nettles, M. &amp; DziewoDski, A.
The Global CMT Project 2004-2010: centroid-moment tensors for 13,017
earthquakes Physics of the Earth and Planetary Interiors, 2012.
</p>

<hr>
<h2 id='JMAT'>Vertical Rotation matrix
</h2><span id='topic+JMAT'></span>

<h3>Description</h3>

<p>Vertical Rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMAT(phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMAT_+3A_phi">phi</code></td>
<td>
<p>angle, degrees
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First rotate to plan, then within plane
rotate to view angle.
</p>


<h3>Value</h3>

<p>3 by 3 matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ROTX, ROTZ, ROTY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
phi = 18

MAT = JMAT(phi)

v1 = c(1,1,0)

v2 = MAT 



</code></pre>

<hr>
<h2 id='justfocXY'>Plot focal mechanism </h2><span id='topic+justfocXY'></span>

<h3>Description</h3>

<p>Add simple focal mechanisms to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>justfocXY(MEC, x = x, y = y, focsiz=1 , fcol = gray(0.9),
          fcolback = "white", xpd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="justfocXY_+3A_mec">MEC</code></td>
<td>
<p>MEC structure</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_x">x</code></td>
<td>
<p>x-coordinate of center</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_y">y</code></td>
<td>
<p>y-coordinate of center</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_focsiz">focsiz</code></td>
<td>
<p>size of focal sphere in inches</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_fcol">fcol</code></td>
<td>
<p>color of shaded region</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_fcolback">fcolback</code></td>
<td>
<p>color of background region</p>
</td></tr>
<tr><td><code id="justfocXY_+3A_xpd">xpd</code></td>
<td>
<p>logical, whether to extend the plot beyond, or to clip</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine can be used to add focal mechanisms on geographic map
or other plot.
</p>


<h3>Value</h3>

<p>Used for graphical side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>SDRfoc, foc.color</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### read in some data:


Z1 = c(159.33,51.6,206,18,78,
161.89,54.5,257,27,133,
170.03,53.57,-44,13,171,
154.99,50.16,-83,19,-40,
151.09,47.15,123,23,-170,
176.31,51.41,-81,22,122,
153.71,46.63,205,28,59,
178.39,51.21,-77,16,126,
178.27,51.1,-86,15,115,
177.95,51.14,-83,25,126,
178.25,51.18,215,16,27
)

MZ = matrix(Z1, ncol=5, byrow=TRUE)

plot(MZ[,1], MZ[,2], type='n', xlab="LON", ylab="LAT", asp=1)

for(i in 1:length(MZ[,1]))
{
paste(MZ[i,3], MZ[i,4], MZ[i,5])


MEC =  SDRfoc(MZ[i,3], MZ[i,4], MZ[i,5], u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
fcol =  foc.color(foc.icolor(MEC$rake1), pal=1)
justfocXY(MEC, x=MZ[i,1], y =MZ[i,2] , focsiz=.5, fcol =fcol , fcolback = "white", xpd = TRUE)


}

</code></pre>

<hr>
<h2 id='KAMCORN'>SDR data from the Harvard CMT catalog</h2><span id='topic+KAMCORN'></span>

<h3>Description</h3>

<p>Strike-Dip-Rake and Locations of Harvard CMT catalog for the
intersection of the Kamchataka and Aleutian arcs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KAMCORN)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;KAMCORN&quot;
</p>


<h3>Details</h3>

<p>The data is selected fromt eh CMT catalog.  Parameters are
extracted from the normal distribution.  Format of the list
of data save in KAMCORN is:
list(LAT=0  , LON =0  ,   DEPTH=0  ,  STRIKE=0  , DIP=0  ,    RAKE=0  )
</p>


<h3>Source</h3>

<p>http://www.globalcmt.org/CMTsearch.html
</p>


<h3>References</h3>

<p>G. Ekstrom.     Rapid    earthquake   analysis  utilizes the internet.  Computers     in Physics,   8:632-638,  1994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KAMCORN)
plot(KAMCORN$LON, KAMCORN$LAT, xlab="LON", ylab="LAT" ,
          main="Kamchatka-Aleutian Inersection", asp=1)
######  
Paz =vector()
Pdip =vector()
Taz =vector()
Tdip =vector()
h = vector()
v = vector()

IFcol = vector()
Fcol = vector()

for(i in 1:10)
  {
    Msdr = CONVERTSDR(KAMCORN$STRIKE[i],
          KAMCORN$DIP[i], KAMCORN$RAKE[i]   )
  MEC = MRake(Msdr$M)
  MEC$UP = FALSE
  IFcol[i] = foc.icolor(MEC$rake1)
    Fcol[i] = foc.color(IFcol[i], 1)

      az1 = Msdr$M$az1
  dip1 = Msdr$M$d1
  az2 = Msdr$M$az2
  dip2 = Msdr$M$d2
  BBB = Bfocvec(az1, dip1,  az2,  dip2)
  V = ternfoc.point(BBB$Bdip, Msdr$M$pd, Msdr$M$td )
 Paz[i] = Msdr$M$paz
  Pdip[i] = Msdr$M$pd
  Taz[i] = Msdr$M$taz
  Tdip[i] = Msdr$M$td
  h[i] = V$h
  v[i] = V$v

     justfocXY( MEC, fcol = Fcol[i], KAMCORN$LON[i],
          KAMCORN$LAT[i] , focsiz = 0.4 )
  }
</code></pre>

<hr>
<h2 id='lowplane'>Plot one Fault plane on stereonet</h2><span id='topic+lowplane'></span>

<h3>Description</h3>

<p>takes azimuth and dip and projects the greaat circle on the focla sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowplane(az, dip, col = par("col"), UP = FALSE, PLOT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowplane_+3A_az">az</code></td>
<td>
<p>degrees, azimuth of strike of plane</p>
</td></tr>
<tr><td><code id="lowplane_+3A_dip">dip</code></td>
<td>
<p> degrees, dip</p>
</td></tr>
<tr><td><code id="lowplane_+3A_col">col</code></td>
<td>
<p>color of plane</p>
</td></tr>
<tr><td><code id="lowplane_+3A_up">UP</code></td>
<td>
<p>upper/lower hemisphere</p>
</td></tr>
<tr><td><code id="lowplane_+3A_plot">PLOT</code></td>
<td>
<p>add to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here azimuth is measured from North, and represents the actual strike
of the fault line.
</p>


<h3>Value</h3>

<p>list of x,y coordinates of plane
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>net</p>


<h3>Examples</h3>

<pre><code class='language-R'>net()
lowplane(65,23)

</code></pre>

<hr>
<h2 id='m2tk'>Moment tensor to T-k
</h2><span id='topic+m2tk'></span>

<h3>Description</h3>

<p>Moment tensor to T-k
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2tk(m0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2tk_+3A_m0">m0</code></td>
<td>
<p>moment tensor eigenvalues, sorted decending
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert 3 eigen values of a moment tensor to
T-k coordinates
</p>


<h3>Value</h3>

<p>list(t, k)
</p>


<h3>Author(s)</h3>

<p>Keehoon Kim&lt;keehoon@live.unc.edu&gt;
Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Hudson
</p>


<h3>See Also</h3>

<p>tk2uv, hudson.net, hudson.plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(2,-1,-1)
m2tk(v)
</code></pre>

<hr>
<h2 id='makeblock3D'>Make a 3D block Structure</h2><span id='topic+makeblock3D'></span>

<h3>Description</h3>

<p>Given vertices of a 3D block,
create a glyph structure (faces and normals)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeblock3D(block1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeblock3D_+3A_block1">block1</code></td>
<td>
<p>matrix of vertices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>glyph structure list
</p>
<table>
<tr><td><code>aglyph</code></td>
<td>
<p>list of faces (x,y,z)</p>
</td></tr>
<tr><td><code>anorm</code></td>
<td>
<p>Normals to faces</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>ROTZ, ROTY, ROTX, BOXarrows3D, Z3Darrow, TRANmat</p>


<h3>Examples</h3>

<pre><code class='language-R'>  block1 = matrix(c(0,0,0,
      1,0,0,
      1,0.5,0,
      0,0.5,0,
      0,0,-2,
      1,0,-2,
      1,0.5,-2,
      0,0.5,-2), byrow=TRUE, ncol=3)

    Bblock1 = makeblock3D(block1)

</code></pre>

<hr>
<h2 id='makenet'>Equal-Angle Stereonet</h2><span id='topic+makenet'></span>

<h3>Description</h3>

<p>Creates but does not plot an Equal-Angle (Schmidt) Stereonet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makenet()
</code></pre>


<h3>Value</h3>

<p>list of x,y, values for drawing lines
</p>
<table>
<tr><td><code>x1</code></td>
<td>
<p>x-coordinate start of lines</p>
</td></tr>
<tr><td><code>y1</code></td>
<td>
<p>y-coordinate start of lines</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>x-coordinate end of lines</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>y-coordinate end of lines</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., 1987,  Map Projections-a working manual, USGS-Professional Paper, 383p.  pages 185-186</p>


<h3>See Also</h3>

<p>net, pnet</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MN = makenet()

  pnet(MN)

</code></pre>

<hr>
<h2 id='MapNonDouble'>Map moment tensors
</h2><span id='topic+MapNonDouble'></span>

<h3>Description</h3>

<p>Plot moment tensors on map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapNonDouble(Locs, moments, sel = 1, siz = 0.2,
col=rgb(1, .75, .75), PLANES = TRUE, add = FALSE, LEG=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MapNonDouble_+3A_locs">Locs</code></td>
<td>
<p>Locations, x,y
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_moments">moments</code></td>
<td>
<p>list of moments: seven elements. See details.
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_sel">sel</code></td>
<td>
<p>integer, index of which to plot
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_siz">siz</code></td>
<td>
<p>size to plot, inches
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_col">col</code></td>
<td>
<p>color, either a single color, rgb, or a color palette.
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_planes">PLANES</code></td>
<td>
<p>logical, whether to add nodal planes, default=TRUE
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_add">add</code></td>
<td>
<p>logical, whether to add to plot, default=FALSE
</p>
</td></tr>
<tr><td><code id="MapNonDouble_+3A_leg">LEG</code></td>
<td>
<p>logical, whether to add focal mech legend based on color
coding,
default=FALSE
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Moment tensors are added to an existing plot.
The first element of the list is the integer index of the event.
The next six elements are the moments in
the following order, c(Mxx, Myy, Mzz, Mzy, Mxz, Mxy) .
</p>
<p>If the data is in spherical coordinates, one must switch the
sign of the Mrp and Mtp components, so:
<code style="white-space: pre;">&#8288;
    Mrr = Mzz
    Mtt = Mxx
    Mpp = Myy
    Mrt = Mxz
    Mrp = -Myz
    Mtp = -Mxy
&#8288;</code>
</p>
<p>A color palette can be provided for some
details of the radiation patterns, e.g.  col=rainbow(12).
If col is NULL, the colors will be chosen according to
focal.color from RFOC, based on rake of first nodal plane.
</p>
<p>If col is NULL, then the colors are set by foc.color
and it is appropriate to add a legend.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>FOC</code></td>
<td>
<p>matrix, focal mechanism angles (strike, dip rake)</p>
</td></tr>
<tr><td><code>LAB</code></td>
<td>
<p>matrix, x-y location for labels</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If events are read in using spherical rather than cartesian
coordinates
need a conversion:
<code style="white-space: pre;">&#8288;
    Mrr = Mzz
    Mtt = Mxx
    Mpp = Myy
    Mrt = Mxz
    Mrp = -Myz
    Mtp = -Mxy
&#8288;</code>
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Ekstrom, G.; Nettles, M. &amp; DziewoDski, A.
The Global CMT Project 2004-2010: centroid-moment tensors for 13,017
earthquakes Physics of the Earth and Planetary Interiors, 2012.
</p>


<h3>See Also</h3>

<p>doNonDouble, ShadowCLVD, angles, nodalLines, PTaxes,
focal.color,  foc.icolor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(maps)
library(GEOmap)

##########  load the data
data(widdenMoments)

#################   to read in the data from a file,
##   GG = scan("widdenMoments.txt",sep=" ",
## what=list(ID=0,Event="",Lat=0,Long=0,Depth=0,Mw=0,ML=0,DC=0,
## CLVD=0,ISO=0,VR=0,nsta=0,Mxx=0,Mxy=0,Mxz=0,
##  Myy=0,Myz=0,Mzz=0,Mo=0,Ftest=0) )



GG = widdenMoments
Locs = list(y=GG$Lat,x=GG$Long)


ef = 1e20
moments = cbind(GG$ID, ef*GG$Mxx, ef*GG$Myy,
ef*GG$Mzz, ef*GG$Myz, ef*GG$Mxz,ef*GG$Mxy)




UTAH =  map('state', region = c('utah'), plot=FALSE )

mlon = mean(UTAH$x, na.rm=TRUE)
mlat = mean(UTAH$y, na.rm=TRUE)


Gutah   = maps2GEOmap(UTAH)


############   for mercator projection
PROJ =  GEOmap::setPROJ(type = 1, LAT0 = mlat , LON0 = mlon)
Glocs = GEOmap::GLOB.XY(Locs$y, Locs$x, PROJ       )
############   for UTM projection
PROJ =  GEOmap::setPROJ(type = 2, LAT0 = mlat , LON0 = mlon)
Glocs = GEOmap::GLOB.XY(Locs$y, Locs$x, PROJ       )

LIMlat = expandbound(Gutah$POINTS$lat)
LIMlon = expandbound(Gutah$POINTS$lon)

PLAT =  pretty(LIMlat)
 PLON  = pretty(LIMlon)

###############  plot the map

########  Utah is a little rectangular
dev.new(width=9, height=12)

plotGEOmapXY(Gutah,
LIM = c(min(PLON), min(PLAT) , max(PLON) , max(PLAT)) ,
             PROJ=PROJ, axes=FALSE, xlab="", ylab="" )


### add tic marks
kbox = GEOmap::GLOB.XY(PLAT,PLON, PROJ)

      sqrTICXY(kbox , PROJ, side=c(1,2,3,4), LLgrid=TRUE, col=grey(.7) )

########  add focal mechs
siz = 0.2

MapNonDouble(Glocs, moments,col=NULL,  add=TRUE, LEG=TRUE)

  up = par("usr")
    ui = par("pin")
    ratx = (up[2] - up[1])/ui[1]
    raty = (up[4] - up[3])/ui[2]
usizx = siz * ratx

AXY = NoOverlap(Glocs$x,Glocs$y, usizx )

 MapNonDouble(AXY, moments,col=NULL,  add=TRUE, LEG=TRUE)

####  MapNonDouble(NXY, moments,col=NULL,  add=TRUE, LEG=TRUE)




## End(Not run)

</code></pre>

<hr>
<h2 id='mc2cart'>Convert azimuth, dip to Cartesian Coordinates</h2><span id='topic+mc2cart'></span>

<h3>Description</h3>

<p>takes the pole information from a steroplot and returns the cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc2cart(az, dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc2cart_+3A_az">az</code></td>
<td>
<p>degrees, orientation angle, from North</p>
</td></tr>
<tr><td><code id="mc2cart_+3A_dip">dip</code></td>
<td>
<p>degrees, dip of pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of x,y,z values
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1  = mc2cart(65,32)
v2  = mc2cart(135,74)


</code></pre>

<hr>
<h2 id='mijsdr'>Moment Tensor to Strike-Dip-Rake
</h2><span id='topic+mijsdr'></span>

<h3>Description</h3>

<p>Convert a normalized
moment tensor from the CMT catalog
to Strike-Dip-Rake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mijsdr(mxx, myy, mzz, mxy, mxz, myz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mijsdr_+3A_mxx">mxx</code></td>
<td>
<p>moment tensor 1,1
</p>
</td></tr>
<tr><td><code id="mijsdr_+3A_myy">myy</code></td>
<td>
<p>moment tensor 2,2
</p>
</td></tr>
<tr><td><code id="mijsdr_+3A_mzz">mzz</code></td>
<td>
<p>moment tensor 3,3
</p>
</td></tr>
<tr><td><code id="mijsdr_+3A_mxy">mxy</code></td>
<td>
<p>moment tensor 1,2
</p>
</td></tr>
<tr><td><code id="mijsdr_+3A_mxz">mxz</code></td>
<td>
<p>moment tensor 1,3
</p>
</td></tr>
<tr><td><code id="mijsdr_+3A_myz">myz</code></td>
<td>
<p>moment tensor 2,3
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the coordinate system is
modified to represent a system centered on the
source.
</p>


<h3>Value</h3>

<p>Focal Mechanism list
</p>


<h3>Note</h3>

<p>This code will convert the output of
the website, 
http://www.globalcmt.org/CMTsearch.html
when dumped in the
psmeca (GMT v&gt;3.3) format.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://www.globalcmt.org/CMTsearch.html
</p>


<h3>See Also</h3>

<p>getCMT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mijsdr(-1.96, 1.07, 0.89, 0.51, 0.08, -0.68)


</code></pre>

<hr>
<h2 id='MomentDist'>Distance Between Moment Tensors
</h2><span id='topic+MomentDist'></span>

<h3>Description</h3>

<p>Calculate the distance between moment tensors
based on quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MomentDist(E1, E2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MomentDist_+3A_e1">E1</code></td>
<td>
<p>Moment tensor
</p>
</td></tr>
<tr><td><code id="MomentDist_+3A_e2">E2</code></td>
<td>
<p>Moment tensor
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Moment tensors should be right handed.
</p>


<h3>Value</h3>

<p>angle in degrees
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Tape and Tape, 2012
</p>


<h3>See Also</h3>

<p>forcerighthand, testrightHAND
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Mtens = c(-0.412, 0.084, 0.328 ,0.398, -1.239, 1.058)
M1 = matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4], Mtens[2],
Mtens[6], Mtens[5],Mtens[6], Mtens[3]), ncol=3, nrow=3, byrow=TRUE)



Mtens = c(5.054, -2.235, -2.819, -0.476, 5.420, 5.594)
M2 = matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4], Mtens[2],
Mtens[6], Mtens[5],Mtens[6], Mtens[3]), ncol=3, nrow=3, byrow=TRUE)

E1 = eigen(M1)

###  make sure these are a right handed system,
###   ie x1 cross x2 = x3


E2 = eigen(M2)

###  make sure these are a right handed system,
###   ie x1 cross x2 = x3
testrightHAND(E1$vectors) 
testrightHAND(E2$vectors) 

E1$vectors = forcerighthand(E1$vectors)

E2$vectors = forcerighthand(E2$vectors)


testrightHAND(E1$vectors) 
testrightHAND(E2$vectors) 

MomentDist(E1, E2)


</code></pre>

<hr>
<h2 id='MRake'>Rake Calculation</h2><span id='topic+MRake'></span>

<h3>Description</h3>

<p>Calculate various parameters associated with the
Rake or Slip of an earthquake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRake(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRake_+3A_m">M</code></td>
<td>
<p>list(uaz, ud, vaz, vd, paz, pd, taz, td) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine takes the four poles U, V, P, T,
and returns a MEC structure.
(uaz, ud ) = U pole azimuth and dip
( vaz, vd)= V pole azimuth and dip
(paz, pd)= P pole azimuth and dip
(taz, td)= T pole azimuth and dip
</p>


<h3>Value</h3>

<p>returns a MEC structure
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>CONVERTSDR, GetRakeSense,  GetRake </p>


<h3>Examples</h3>

<pre><code class='language-R'> mc = CONVERTSDR(329, 8, 110 )
    MEC = MRake(mc$M)
</code></pre>

<hr>
<h2 id='net'>EqualArea Stereonet</h2><span id='topic+net'></span>

<h3>Description</h3>

<p>Plot  Equal Area Stereo-Net.
Lambert azimuthal Equal-Area (Schmidt) from Snyder p. 185-186
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net(add = FALSE, col = gray(0.7), border = "black", lwd = 1, LIM = c(-1, -1, +1, +1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to existing plot </p>
</td></tr>
<tr><td><code id="net_+3A_col">col</code></td>
<td>
<p>color of lines</p>
</td></tr>
<tr><td><code id="net_+3A_border">border</code></td>
<td>
<p>color of outer rim of stereonet</p>
</td></tr>
<tr><td><code id="net_+3A_lwd">lwd</code></td>
<td>
<p>linewidth of lines</p>
</td></tr>
<tr><td><code id="net_+3A_lim">LIM</code></td>
<td>
<p>bounding area for a new plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., 1987,  Map Projections-a working manual, USGS-Professional Paper, 383p.  pages 185-186</p>


<h3>See Also</h3>

<p>pcirc</p>


<h3>Examples</h3>

<pre><code class='language-R'>net(FALSE, col=rgb(.8,.7,.7) ,border='blue' )

</code></pre>

<hr>
<h2 id='nipXY'>Fault-Slip vector plot</h2><span id='topic+nipXY'></span>

<h3>Description</h3>

<p>Plots a fault plane and the slip vector.  Used for geographic
representation of numerous focal spheres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nipXY(MEC, x = x, y = y, focsiz=1, fcol = gray(0.9), nipcol = "black", cex = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nipXY_+3A_mec">MEC</code></td>
<td>
<p>MEC structure</p>
</td></tr>
<tr><td><code id="nipXY_+3A_x">x</code></td>
<td>
<p>coordinate on plot </p>
</td></tr>
<tr><td><code id="nipXY_+3A_y">y</code></td>
<td>
<p> coordinate on plot </p>
</td></tr>
<tr><td><code id="nipXY_+3A_focsiz">focsiz</code></td>
<td>
<p>size in inches</p>
</td></tr>
<tr><td><code id="nipXY_+3A_fcol">fcol</code></td>
<td>
<p>color for plotting</p>
</td></tr>
<tr><td><code id="nipXY_+3A_nipcol">nipcol</code></td>
<td>
<p>color of slip point</p>
</td></tr>
<tr><td><code id="nipXY_+3A_cex">cex</code></td>
<td>
<p>character expansion for slip point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slip vector is the cross product of the poles to the
fault plane and auxilliary planes.  
</p>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>Q</code></td>
<td>
<p>output of qpoint</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>slip vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>qpoint, CROSSL, lowplane,  TOCART  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2015)
N = 20
lon=runif(20, 268.1563 , 305)
lat=runif(20, 7.593004,  25.926045)
str1=runif(20,50,100)
dip1=runif(20,10, 80)
rake1=runif(20,5, 180)

dep=runif(20,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)

 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)

PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm

XY = GEOmap::GLOB.XY(lat, lon, PROJ)

plot(range(XY$x), range(XY$y), type='n', asp=1, xlab='km', ylab='km' )
for(i in 1:length(XY$x))
{
  Msdr = CONVERTSDR(MEKS$str1[i], MEKS$dip1[i],MEKS$rake1[i])
     MEC = MRake(Msdr$M)
       MEC$UP = FALSE

         jcol =  foc.color(foc.icolor(MEC$rake1), pal=1)



nipXY(MEC, x = XY$x[i], y = XY$y[i], focsiz=0.5, fcol = jcol, nipcol = 'black' , cex = 1)
}



</code></pre>

<hr>
<h2 id='nodalLines'>Nodal Lines
</h2><span id='topic+nodalLines'></span>

<h3>Description</h3>

<p>Add nodal planes to focal mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodalLines(strike, dip, rake, PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodalLines_+3A_strike">strike</code></td>
<td>
<p>numeric, strike of fault
</p>
</td></tr>
<tr><td><code id="nodalLines_+3A_dip">dip</code></td>
<td>
<p>numeric, dip of fault
</p>
</td></tr>
<tr><td><code id="nodalLines_+3A_rake">rake</code></td>
<td>
<p>numeric, rake  of fault
</p>
</td></tr>
<tr><td><code id="nodalLines_+3A_plot">PLOT</code></td>
<td>
<p>logical, add lines to plot, default=TRUE
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lower Hemisphere focal plane.
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Note</h3>

<p>Lower Hemisphere based on FOCangles.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>doNonDouble, MapNonDouble, FOCangles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mo &lt;- list(n=1, m1=1.035675e+017,
   m2=-1.985852e+016, m3=-6.198052e+014,
   m4=1.177936e+017, m5=-7.600627e+016, m6=-3.461405e+017)
moments &lt;- cbind(mo$n, mo$m1, mo$m2, mo$m3, mo$m4, mo$m5, mo$m6)
doNonDouble(moments)


</code></pre>

<hr>
<h2 id='normal.fault'>Normal Fault Cartoon</h2><span id='topic+normal.fault'></span>

<h3>Description</h3>

<p>Illustrate a normal fault using animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal.fault(ANG = (45), anim = seq(from = 0, to = 1, by = 0.1),
            KAPPA = 4, Light = c(45, 45))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal.fault_+3A_ang">ANG</code></td>
<td>
<p>Angle of dip</p>
</td></tr>
<tr><td><code id="normal.fault_+3A_anim">anim</code></td>
<td>
<p>animation vector </p>
</td></tr>
<tr><td><code id="normal.fault_+3A_kappa">KAPPA</code></td>
<td>
<p>Phong parameter for lighting</p>
</td></tr>
<tr><td><code id="normal.fault_+3A_light">Light</code></td>
<td>
<p>lighting point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program will animate a normal fault for educational purposes.
Animation must be stopped by  halting execution.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>strikeslip.fault, thrust.fault</p>


<h3>Examples</h3>

<pre><code class='language-R'>
normal.fault(45, anim=0, KAPPA=4, Light=c(-20, 80))

## Not run: 
#### execute a stop command to stop this animation
anim= seq(from=0, to=1, by=.1) 

 normal.fault(45, anim=anim, KAPPA=4, Light=c(-20, 80))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='pcirc'>Circle Plot</h2><span id='topic+pcirc'></span>

<h3>Description</h3>

<p>Add a circle to a plot, with cross-hairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcirc(gcol = "black", border = "black", ndiv = 36)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcirc_+3A_gcol">gcol</code></td>
<td>
<p>color of crosshairs</p>
</td></tr>
<tr><td><code id="pcirc_+3A_border">border</code></td>
<td>
<p> border color </p>
</td></tr>
<tr><td><code id="pcirc_+3A_ndiv">ndiv</code></td>
<td>
<p> number of divisions for the circle </p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return values, used for side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>net </p>


<h3>Examples</h3>

<pre><code class='language-R'>net()
pcirc(gcol = "green", border = "purple", ndiv = 36)

</code></pre>

<hr>
<h2 id='pglyph3D'>Plot a 3D body on an existing graphic</h2><span id='topic+pglyph3D'></span>

<h3>Description</h3>

<p>rotates a body in 3D and plots projection on existing plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglyph3D(aglyph, M = diag(1, nrow = 4), M2 = diag(1, nrow = 4),
         anorms = list(), zee = c(0, 0, 1), col = "white", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglyph3D_+3A_aglyph">aglyph</code></td>
<td>
<p>glyph structure describing the vertices  and normal
vectors of a 3D body </p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_m">M</code></td>
<td>
<p>rotation matrix 1 </p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_m2">M2</code></td>
<td>
<p>rotation matrix 2 </p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_anorms">anorms</code></td>
<td>
<p>up vector</p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_zee">zee</code></td>
<td>
<p>up vector </p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_col">col</code></td>
<td>
<p>coor of body</p>
</td></tr>
<tr><td><code id="pglyph3D_+3A_border">border</code></td>
<td>
<p>color of border </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hidden sides are removed and phong shading is introduced to create 3D
effect.
</p>
<p>The input consists of an object defined by
a list structure,
list(aglyph, anorm)
where aglyph is list of 3D polygons (faces) and anorm are outward normals to
these faces.
</p>


<h3>Value</h3>

<p>Used for side effect on plots
</p>


<h3>Note</h3>

<p> For unusual rotations or bizarre bodies, this routine may produce strange looking shapes.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Rogers and Adams, 1990, Mathematical Elements for Computer
Graphics, McGraw-Hill, 611p.</p>


<h3>See Also</h3>

<p>Z3Darrow, ROTX, ROTY, ROTZ</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create the 3D object
len = .7
basethick=.05
headlip=.02
headlen=.3

####  create a 3D glyph structure
aglyph = Z3Darrow(len = len , basethick =basethick , headlen =headlen ,
headlip=headlip )

#### define the up vector 
myzee = matrix(c(0,0,1, 1), nrow=1, ncol=4)

##### set rotation angles:
gamma =12
beta =39
alpha = 62

########  set up rotation matrix
R3 = ROTZ(gamma)

R2 = ROTY(beta)

R1 = ROTZ(alpha)

###  create rotation matrix
M =      R1  

M2 =       R1  


plot(c(-1,1), c(-1,1))

 pglyph3D(aglyph$aglyph, anorms=aglyph$anorm  , M=M, M2=M2, zee=myzee ,
col=rgb(.7, 0,0) )



</code></pre>

<hr>
<h2 id='phong3D'>Phong shading for a 3D body</h2><span id='topic+phong3D'></span>

<h3>Description</h3>

<p>Create phong shading for faces showing on the 3D block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phong3D(aglyph, M = diag(1, nrow = 4), M2 = diag(1, nrow = 4),
          Light = c(45, 45), anorms = list(), zee = c(0, 0, 1),
         col = "white", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phong3D_+3A_aglyph">aglyph</code></td>
<td>
<p>3-D body list of faces and normals</p>
</td></tr>
<tr><td><code id="phong3D_+3A_m">M</code></td>
<td>
<p>Rotation Matrix </p>
</td></tr>
<tr><td><code id="phong3D_+3A_m2">M2</code></td>
<td>
<p>Viewing Matrix</p>
</td></tr>
<tr><td><code id="phong3D_+3A_light">Light</code></td>
<td>
<p> light source direction </p>
</td></tr>
<tr><td><code id="phong3D_+3A_anorms">anorms</code></td>
<td>
<p> normals to faces</p>
</td></tr>
<tr><td><code id="phong3D_+3A_zee">zee</code></td>
<td>
<p>Up vector for Body</p>
</td></tr>
<tr><td><code id="phong3D_+3A_col">col</code></td>
<td>
<p>color for faces</p>
</td></tr>
<tr><td><code id="phong3D_+3A_border">border</code></td>
<td>
<p>border color for sides</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a standard phong shading model based ont eh dot product of the
face normal vector and direction of incoming light.
</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Watt, Alan. Fundamentals of Three-dimensional Computer
Graphics, Addison-Wesley, 1989, 430p.</p>


<h3>See Also</h3>

<p>makeblock3D, BOXarrows3D, PROJ3D, Z3Darrow, pglyph3D</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###########  create a block and rotation matrix, then color it
ANG=(45)
DEGRAD = pi/180

y1 = 1.5

  y2 = y1 - 1/tan((ANG)*DEGRAD)


  z1 = 1
  x1 = 1


Ablock1 = matrix(c(0,0,0,
    1,0,0,
    1,y1,0,
    0,y1,0,
    0,0,-1,
    1,0,-1,
    1,y2,-1,
    0,y2,-1), byrow=TRUE, ncol=3)


Nblock1 = makeblock3D(Ablock1)
Light=c(45,45)
angz = -45
angx = -45

R1 = ROTZ(angz)
R2 = ROTX(angx)

   M =    R1 

Z2 = PROJ3D(Nblock1$aglyph, M=M,  anorms=Nblock1$anorm ,  zee=c(0,0,1))
RangesX = range(attr(Z2, "RangesX"))

  RangesY = range(attr(Z2, "RangesY"))


plot( RangesX, RangesY, type='n', asp=1, ann=FALSE, axes=FALSE)

phong3D(Nblock1$aglyph, M=M,  anorms=Nblock1$anorm , Light = Light,
zee=c(0,0,1), col=rgb(.7,.5, .5)  , border="black")



</code></pre>

<hr>
<h2 id='PKAM'>P and T-axes data from the Harvard CMT catalog</h2><span id='topic+PKAM'></span>

<h3>Description</h3>

<p>P and T-axes  and Locations of Harvard CMT catalog for the
intersection of the Kamchataka and Aleutian arcs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PKAM)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;PKAM&quot;
</p>


<h3>Details</h3>

<p>The data is selected from the CMT catalog.  Parameters are
extracted from the standard web distribution.  Format of the list
of data save in PKAM is:
</p>
 
<p>itemPazP-axis azimuth angle
itemPdipP-axis dip angle
itemTazT-axis  azimuth angle
itemTdipT-axis dip angle
itemhhorizontal point to plot on ternary plot 
itemvvertical point to plot on ternary plot 
itemfcolscolors, not used
itemLATSLatitude
itemLONSLongitude
itemIFcolinteger pointer to internal color
itemyryear, not used
itemJDHMJulian Day, hour, minute, not used
itemJDHMSJulian Day, hour, minute, seconds

</p>


<h3>Source</h3>

<p>http://www.globalcmt.org/CMTsearch.html
</p>


<h3>References</h3>

<p>G. Ekstrom. Rapid earthquake analysis utilizes the internet.  Computers in Physics,   8:632-638,  1994.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PKAM)
## 

######  plot the locations:
plot( RPMG::fmod(PKAM$LONS, 360), PKAM$LATS)
######  

  PlotTernfoc(PKAM$h,PKAM$v,x=0, y=0, siz=1, fcols='black', add=FALSE,
LAB=TRUE)

######  change the colors for the plot

acols = rainbow(7)
fcols = acols[PKAM$IFcol]

######  


 PlotTernfoc(PKAM$h,PKAM$v,x=0, y=0, siz=1, fcols=fcols, add=FALSE,
LAB=TRUE)





</code></pre>

<hr>
<h2 id='plotfoc'>Plot Focal Radiation Patterns</h2><span id='topic+plotfoc'></span>

<h3>Description</h3>

<p>Takes a MEC structure and plots all three radiation patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfoc(MEC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotfoc_+3A_mec">MEC</code></td>
<td>
<p>MEC list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot makes three figures after calling par(mfrow=c(3,1)).
</p>


<h3>Value</h3>

<p>Graphical Side Effects.
</p>


<h3>Note</h3>

<p>Basic MEC List Structure
</p>

<table>
<tr>
 <td style="text-align: left;">
  az1 </td><td style="text-align: left;"> azimuth angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dip1 </td><td style="text-align: left;"> dip angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  az2 </td><td style="text-align: left;"> azimuth angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dip2 </td><td style="text-align: left;"> dip angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dir </td><td style="text-align: left;"> 0,1 to determine which section of focal sphere is shaded</td>
</tr>
<tr>
 <td style="text-align: left;">
  rake1 </td><td style="text-align: left;"> rake angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dipaz1 </td><td style="text-align: left;"> dip azimuth angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  rake2 </td><td style="text-align: left;"> rake angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dipaz2 </td><td style="text-align: left;"> dip azimuth angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  P </td><td style="text-align: left;"> pole list(az, dip) P-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  T </td><td style="text-align: left;"> pole list(az, dip) T-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  U </td><td style="text-align: left;"> pole list(az, dip) U-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  V </td><td style="text-align: left;"> pole list(az, dip) V-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  F </td><td style="text-align: left;"> pole list(az, dip) F-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  G </td><td style="text-align: left;"> pole list(az, dip) G-axis </td>
</tr>
<tr>
 <td style="text-align: left;">
  sense </td><td style="text-align: left;"> 0,1 to determine which section of focal sphere is shaded</td>
</tr>
<tr>
 <td style="text-align: left;">
  M </td><td style="text-align: left;"> list of focal parameters used in some calculations</td>
</tr>
<tr>
 <td style="text-align: left;">
  UP </td><td style="text-align: left;"> logical, TRUE=upper hemisphere</td>
</tr>
<tr>
 <td style="text-align: left;">
  icol </td><td style="text-align: left;"> index to suite of colors for focal mechanism</td>
</tr>
<tr>
 <td style="text-align: left;">
  ileg </td><td style="text-align: left;"> Kind of fault</td>
</tr>
<tr>
 <td style="text-align: left;">
  fcol </td><td style="text-align: left;"> color of focal mechanism</td>
</tr>
<tr>
 <td style="text-align: left;">
  CNVRG </td><td style="text-align: left;"> Character, note on convergence of solution</td>
</tr>
<tr>
 <td style="text-align: left;">
  LIM </td><td style="text-align: left;"> vector plotting region (x1, y1, x2, y2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>SDRfoc, Mrake, Pradfoc,   radiateSH,  radP,   radSV,     SVradfoc,
radiateP,  radiateSV,  radSH,  SHradfoc, imageP, imageSH, imageSV
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M = SDRfoc(-25, 34, 16,u = FALSE, ALIM = c(-1, -1, +1, +1), PLOT=FALSE)
plotfoc(M)


</code></pre>

<hr>
<h2 id='plotmanyfoc'>Plot Many Focals
</h2><span id='topic+plotmanyfoc'></span>

<h3>Description</h3>

<p>Plot a long list of focal mechanisms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmanyfoc(MEK, PROJ, focsiz = 0.5, foccol = NULL,
UP=TRUE, focstyle=1, PMAT = NULL, LEG = FALSE, DOBAR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmanyfoc_+3A_mek">MEK</code></td>
<td>
<p>List of Focal Mechanisms, see details
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_proj">PROJ</code></td>
<td>
<p>Projection
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_focsiz">focsiz</code></td>
<td>
<p>focal size, inches
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_foccol">foccol</code></td>
<td>
<p>focal color
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_up">UP</code></td>
<td>
<p>logical, UP=TRUE means plot upper hemisphere (DEFAULT=TRUE) 
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_focstyle">focstyle</code></td>
<td>
<p>integer, 1=beach ball, 2=nipplot, 3=strike-slip, 4=P-T, 5=P, 6=T </p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_pmat">PMAT</code></td>
<td>
<p>Projection Matrix from persp
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_leg">LEG</code></td>
<td>
<p>logical, TRUE= add focal legend for color codes
</p>
</td></tr>
<tr><td><code id="plotmanyfoc_+3A_dobar">DOBAR</code></td>
<td>
<p>add strike dip bar at epicenter
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input MEK list contains
</p>
<p>MEKS = list(lon=0, lat=0, str1=0, dip1=0, rake1=0, dep=0, name=&quot;&quot;, Elat=0, Elon=0)
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M., Geotouch: Software for Three and Four Dimensional GIS in the Earth Sciences, Computers &amp; Geosciences, 26, 7, 751-761, 2000.
</p>


<h3>See Also</h3>

<p>justfocXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2015)
N = 20
lon=runif(20, 268.1563 , 305)
lat=runif(20, 7.593004,  25.926045)
str1=runif(20,50,100)
dip1=runif(20,10, 80)
rake1=runif(20,5, 180)

dep=runif(20,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)

 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)

PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm

XY = GEOmap::GLOB.XY(lat, lon, PROJ)

plot(range(XY$x), range(XY$y), type='n', asp=1)

plotmanyfoc(MEKS, PROJ, focsiz=0.5)





</code></pre>

<hr>
<h2 id='plotMEC'>Plot a Focal Mechanism</h2><span id='topic+plotMEC'></span>

<h3>Description</h3>

<p>Plot a Focal Mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMEC(x, detail = 0, up = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMEC_+3A_x">x</code></td>
<td>
<p>Mechanism list</p>
</td></tr>
<tr><td><code id="plotMEC_+3A_detail">detail</code></td>
<td>
<p>level of detail</p>
</td></tr>
<tr><td><code id="plotMEC_+3A_up">up</code></td>
<td>
<p>logical, Upper or lower hemisphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 mc = CONVERTSDR(65, 32, -34 )
plotMEC(mc, detail=2, up=FALSE)

</code></pre>

<hr>
<h2 id='PlotPlanes'>Plot Fault an Auxilliary Planes</h2><span id='topic+PlotPlanes'></span>

<h3>Description</h3>

<p>Plot both fault and auxilliary planes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPlanes(MEC, col1 = 1, col2 = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPlanes_+3A_mec">MEC</code></td>
<td>
<p> MEC structure </p>
</td></tr>
<tr><td><code id="PlotPlanes_+3A_col1">col1</code></td>
<td>
<p>color for plane 1 </p>
</td></tr>
<tr><td><code id="PlotPlanes_+3A_col2">col2</code></td>
<td>
<p>color for plane 2 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given MEC structure and focal mechanism plot both planes.
This code adds to existing plot, so net() should be called.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>net, lowplane</p>


<h3>Examples</h3>

<pre><code class='language-R'>net()

MFOC1 = SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
PlotPlanes(MFOC1, 'green', 'red' )


</code></pre>

<hr>
<h2 id='PlotPTsmooth'>Plot Smooth PT-axes</h2><span id='topic+PlotPTsmooth'></span>

<h3>Description</h3>

<p>Project PT axes on the sphere and smooth the image.  This function
requires function kde2d, from the MASS library.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPTsmooth(paz, pdip, x = 0, y = 0, siz = 1, bcol = "white", border ="black",
        IMAGE = TRUE, CONT = TRUE, cont.col = "black",
         pal = terrain.colors(100), LABS = FALSE, add = FALSE, NCP=50, NIP=200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPTsmooth_+3A_paz">paz</code></td>
<td>
<p>vector of Axis azimuths, degrees</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_pdip">pdip</code></td>
<td>
<p>vector of dip angles, degrees</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_x">x</code></td>
<td>
<p>x-location of plot center in user coordinates</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_y">y</code></td>
<td>
<p>y-location of plot center in user coordinates</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_siz">siz</code></td>
<td>
<p>siz of plot in user coordinates</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_bcol">bcol</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_border">border</code></td>
<td>
<p>border color</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_image">IMAGE</code></td>
<td>
<p>logical, TRUE=create an image plot</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_cont">CONT</code></td>
<td>
<p>logical, TRUE=add contour lines</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_cont.col">cont.col</code></td>
<td>
<p>color of contour lines</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_pal">pal</code></td>
<td>
<p>pallete for image plot</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_labs">LABS</code></td>
<td>
<p>text Label for image</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to plot</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_ncp">NCP</code></td>
<td>
<p>integer, Number of points to use for calculating smoothed
contours, default=50</p>
</td></tr>
<tr><td><code id="PlotPTsmooth_+3A_nip">NIP</code></td>
<td>
<p>integer, Number of points to use for calculating smoothed
image, default=200</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program requires MASS libary for 2D smoothing routine kde2d.
</p>
<p>For calculating contours the kde2d program creates a
smoothed 2D image using NCP points per side.
For the images, NIP points are used.  To reduce the size of
plots, or, if the subplots are very small, reduce NIP to a smaller
value for faster plotting.
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Note</h3>

<p>Points that fall on the
opposite hemisphere are reflected through the origin.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>kde2d</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(-1,1), c(-1,1), asp=1, type='n')

paz = rnorm(100, mean=297, sd=10)
 pdip = rnorm(100, mean=52, sd=8)

PlotPTsmooth(paz, pdip, x=0.5, y=.5, siz=.3, border=NA, bcol='white' ,
LABS=FALSE, add=FALSE, IMAGE=TRUE, CONT=FALSE)

taz = rnorm(100, mean=138, sd=10)
 tdip = rnorm(100, mean=12, sd=8)

 PlotPTsmooth(taz, tdip, x=-.5, y=.4, siz=.3, border=NA, bcol='white' ,
LABS=FALSE, add=FALSE, IMAGE=TRUE, CONT=TRUE)

###########  put them together
plot(c(-1,1), c(-1,1), asp=1, type='n')
PlotPTsmooth(paz, pdip, x=0, y=, siz=1, border=NA, bcol='white' ,
LABS=FALSE, add=FALSE, IMAGE=TRUE, CONT=FALSE)
PlotPTsmooth(taz, tdip, x=0, y=, siz=1, border=NA, bcol='white' ,
LABS=FALSE, add=TRUE, IMAGE=FALSE, CONT=TRUE)




</code></pre>

<hr>
<h2 id='PlotTernfoc'>Ternary Distribution of focal mechanisms </h2><span id='topic+PlotTernfoc'></span>

<h3>Description</h3>

<p>Create and plot a ternary diagram using rake angle
to distribute focal mechanisms on a ternary diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotTernfoc(h, v, x = 0, y = 0, siz = 1, fcols = "black", LABS = FALSE, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotTernfoc_+3A_h">h</code></td>
<td>
<p>x-coordinate on ternary plot</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_v">v</code></td>
<td>
<p>y-coordinate of ternary plot</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_x">x</code></td>
<td>
<p>x Location of center of Ternary plot</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_y">y</code></td>
<td>
<p>y Location of center of Ternary plot</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_siz">siz</code></td>
<td>
<p>size of plot in user coordinates</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_fcols">fcols</code></td>
<td>
<p>vector of colors associated with each focal mechanism</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_labs">LABS</code></td>
<td>
<p>logical, TRUE=add labels at vertices of Ternary plot</p>
</td></tr>
<tr><td><code id="PlotTernfoc_+3A_add">add</code></td>
<td>
<p>logical, add to plot=TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for graphical side effect.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>J. M.  Lees.  Geotouch: Software for three  and four dimensional  gis in the earth sciences.   Computers  &amp;  Geosciences,  26(7):751&ndash;761, 2000</p>


<h3>See Also</h3>

<p>ternfoc.point, Bfocvec</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z1 = c(159.33,51.6,206,18,78,
161.89,54.5,257,27,133,
170.03,53.57,-44,13,171,
154.99,50.16,-83,19,-40,
151.09,47.15,123,23,-170,
176.31,51.41,-81,22,122,
153.71,46.63,205,28,59,
178.39,51.21,-77,16,126,
178.27,51.1,-86,15,115,
177.95,51.14,-83,25,126,
178.25,51.18,215,16,27
)

MZ = matrix(Z1, ncol=5, byrow=TRUE)

h = vector()
v = vector()
Fcol = vector()
for(i in 1:length(MZ[,3]))
  {
    Msdr = CONVERTSDR(MZ[i,3], MZ[i,4], MZ[i,5])
MEC = MRake(Msdr$M)
  MEC$UP = FALSE

 az1 = Msdr$M$az1
  dip1 = Msdr$M$d1
  az2 = Msdr$M$az2
  dip2 = Msdr$M$d2
  BBB = Bfocvec(az1, dip1,  az2,  dip2)
  V = ternfoc.point(BBB$Bdip, Msdr$M$pd, Msdr$M$td )

  h[i] = V$h
  v[i] = V$v
Fcol[i] = foc.color(foc.icolor(MEC$rake1), pal=1)

}


PlotTernfoc(h,v,x=0, y=0, siz=1, fcols=Fcol, add=FALSE, LAB=TRUE)

MFOC1 = SDRfoc(65,90,1, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
    Fcol1 = foc.color(foc.icolor(MFOC1$rake1), pal=1)
 MFOC2 = SDRfoc(135,45,-90, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
    Fcol2 = foc.color(foc.icolor(MFOC2$rake1), pal=1)
 MFOC3 = SDRfoc(135,45,90, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
    Fcol3 = foc.color(foc.icolor(MFOC3$rake1), pal=1)

justfocXY( MFOC3, fcol = Fcol3, 1.2, -0.9, focsiz = 0.4 )
justfocXY( MFOC2, fcol = Fcol2, -1.2, -0.9,  focsiz = 0.4  )
justfocXY( MFOC1, fcol = Fcol1, 0, 1.414443+.2,  focsiz = 0.4  )


</code></pre>

<hr>
<h2 id='PLTcirc'>Circle Plot with Cross Hairs</h2><span id='topic+PLTcirc'></span>

<h3>Description</h3>

<p>Plot an arc of a circle  with cross-hairs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLTcirc(gcol = "black", border = "black", ndiv = 36,
         angs = c(-pi, pi), PLOT = TRUE, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLTcirc_+3A_gcol">gcol</code></td>
<td>
<p> cross hairs color   </p>
</td></tr>
<tr><td><code id="PLTcirc_+3A_border">border</code></td>
<td>
<p>border color </p>
</td></tr>
<tr><td><code id="PLTcirc_+3A_ndiv">ndiv</code></td>
<td>
<p>number of divisions </p>
</td></tr>
<tr><td><code id="PLTcirc_+3A_angs">angs</code></td>
<td>
<p>vector from angs[1] to angs[2] in radians </p>
</td></tr>
<tr><td><code id="PLTcirc_+3A_plot">PLOT</code></td>
<td>
<p> logical, if TRUE plot </p>
</td></tr>
<tr><td><code id="PLTcirc_+3A_add">add</code></td>
<td>
<p>  logical, if TRUE add to existing plot </p>
</td></tr>
</table>


<h3>Value</h3>

<p>list used for plotting:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>angles, radians </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PLTcirc(gcol = "purple", border = "black", ndiv = 36, angs = c(-pi, pi), PLOT = TRUE, add = FALSE)

PLTcirc(gcol = NULL, border = "green" , ndiv = 36, angs = c(-pi/4, pi/4), PLOT = TRUE, add = TRUE)



</code></pre>

<hr>
<h2 id='pnet'>plot stereonet</h2><span id='topic+pnet'></span>

<h3>Description</h3>

<p>Plots stereonet created by makenet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnet(MN, add = FALSE, col = gray(0.7), border = "black", lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnet_+3A_mn">MN</code></td>
<td>
<p>Net strucutre created by makenet</p>
</td></tr>
<tr><td><code id="pnet_+3A_add">add</code></td>
<td>
<p>TRUE= add to existing plot</p>
</td></tr>
<tr><td><code id="pnet_+3A_col">col</code></td>
<td>
<p> color of lines </p>
</td></tr>
<tr><td><code id="pnet_+3A_border">border</code></td>
<td>
<p>color for outside border</p>
</td></tr>
<tr><td><code id="pnet_+3A_lwd">lwd</code></td>
<td>
<p>line width </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used Graphical Side Effects.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., 1987,  Map Projections-a working manual, USGS-Professional Paper, 383p.  pages 185-186</p>


<h3>See Also</h3>

<p>net, pnet</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MN = makenet()

  pnet(MN)

</code></pre>

<hr>
<h2 id='polyfoc'>Polt the focal mechanism polygon </h2><span id='topic+polyfoc'></span>

<h3>Description</h3>

<p>Calculate the projection of the focal mechanism polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyfoc(strike1, dip1, strike2, dip2, PLOT = FALSE, UP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyfoc_+3A_strike1">strike1</code></td>
<td>
<p>strike of plane 1, degrees</p>
</td></tr>
<tr><td><code id="polyfoc_+3A_dip1">dip1</code></td>
<td>
<p>dip of plane 1, degrees</p>
</td></tr>
<tr><td><code id="polyfoc_+3A_strike2">strike2</code></td>
<td>
<p>strike of plane 1, degrees </p>
</td></tr>
<tr><td><code id="polyfoc_+3A_dip2">dip2</code></td>
<td>
<p>dip of plane 2, degrees </p>
</td></tr>
<tr><td><code id="polyfoc_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE = add to plot</p>
</td></tr>
<tr><td><code id="polyfoc_+3A_up">UP</code></td>
<td>
<p>upper/lower hemisphere </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of coordinates of polygon
</p>
<table>
<tr><td><code>Px</code></td>
<td>
<p>x-coordinates of polygon</p>
</td></tr>
<tr><td><code>Py</code></td>
<td>
<p>y-coordinates of polygon</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>faultplane</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC = SDRfoc(13,59,125, PLOT=FALSE)

net()
ply = polyfoc(MEC$az1, MEC$dip1, MEC$az2, MEC$dip2, PLOT = TRUE, UP = TRUE)

</code></pre>

<hr>
<h2 id='Pradfoc'>Plot P-wave radiation</h2><span id='topic+Pradfoc'></span>

<h3>Description</h3>

<p>Plot P-wave radiation with information from the pickfile and
waveform data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pradfoc(A, MEC, GU, pscale, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pradfoc_+3A_a">A</code></td>
<td>
<p>Pickfile structure</p>
</td></tr>
<tr><td><code id="Pradfoc_+3A_mec">MEC</code></td>
<td>
<p>MEC structure</p>
</td></tr>
<tr><td><code id="Pradfoc_+3A_gu">GU</code></td>
<td>
<p>Waveform Event Structure</p>
</td></tr>
<tr><td><code id="Pradfoc_+3A_pscale">pscale</code></td>
<td>
<p>logical (not used)</p>
</td></tr>
<tr><td><code id="Pradfoc_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image plot of the P radiation pattern
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>imageP</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC = SDRfoc(65, 32, -34, u=TRUE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)

Pradfoc(NULL, MEC , NULL, TRUE, rainbow(100) )



</code></pre>

<hr>
<h2 id='Preflect'>Reflect a pole through to the lower hemisphere</h2><span id='topic+Preflect'></span>

<h3>Description</h3>

<p>Takes a vector to a pole and reflects it to the lower hemisphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Preflect(az, dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Preflect_+3A_az">az</code></td>
<td>
<p>azimuth angle, degrees </p>
</td></tr>
<tr><td><code id="Preflect_+3A_dip">dip</code></td>
<td>
<p>dip in degrees </p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>az</code></td>
<td>
<p>azimuth angle, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip in degrees</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>REFLECT</p>


<h3>Examples</h3>

<pre><code class='language-R'>

z = Preflect(65, -23)
z = Preflect(265, -23)


</code></pre>

<hr>
<h2 id='prepFOCS'>Prepare Focals
</h2><span id='topic+prepFOCS'></span>

<h3>Description</h3>

<p>Prepare Focals for plotting.  Program
cycles through data and prepares a
relevant data for further plotting and
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepFOCS(CMTSOL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepFOCS_+3A_cmtsol">CMTSOL</code></td>
<td>

<p>see getCMT for the format for the input here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally in spherefocgeo and ternfocgeo.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>Paz</code></td>
<td>
<p>P-axis azimuth</p>
</td></tr>
<tr><td><code>Pdip</code></td>
<td>
<p>P-axis dip</p>
</td></tr>
<tr><td><code>Taz</code></td>
<td>
<p>T-axis azimuth</p>
</td></tr>
<tr><td><code>Tdip</code></td>
<td>
<p>T-axis dip</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>horizontal distance on ternary plot</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>vertical distance on ternary plot</p>
</td></tr>
<tr><td><code>fcols</code></td>
<td>
<p>focal color</p>
</td></tr>
<tr><td><code>LATS</code></td>
<td>
<p>latitudes</p>
</td></tr>
<tr><td><code>LONS</code></td>
<td>
<p>longitudes</p>
</td></tr>
<tr><td><code>IFcol</code></td>
<td>
<p>index of color</p>
</td></tr>
<tr><td><code>yr</code></td>
<td>
<p>year</p>
</td></tr>
<tr><td><code>JDHM</code></td>
<td>
<p>character  identification</p>
</td></tr>
<tr><td><code>JDHMS</code></td>
<td>
<p>character identification</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>getCMT, spherefocgeo, ternfocgeo
</p>

<hr>
<h2 id='printMEC'>Print focal mechanism</h2><span id='topic+printMEC'></span>

<h3>Description</h3>

<p>Print focal mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printMEC(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printMEC_+3A_x">x</code></td>
<td>
<p>Mechanism list</p>
</td></tr>
<tr><td><code id="printMEC_+3A_digits">digits</code></td>
<td>
<p>digits for numeric information</p>
</td></tr>
<tr><td><code id="printMEC_+3A_...">...</code></td>
<td>
<p>standard printing parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'> mc = CONVERTSDR(65, 32, -34 )

printMEC(mc)

</code></pre>

<hr>
<h2 id='PROJ3D'>Project 3D</h2><span id='topic+PROJ3D'></span>

<h3>Description</h3>

<p>Project a 3D body after rotation and translation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PROJ3D(aglyph, M = diag(1, nrow = 4), M2 = diag(1, nrow = 4),
             anorms = list(), zee = c(0, 0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PROJ3D_+3A_aglyph">aglyph</code></td>
<td>
<p>glyph structure</p>
</td></tr>
<tr><td><code id="PROJ3D_+3A_m">M</code></td>
<td>
<p>rotation matrix</p>
</td></tr>
<tr><td><code id="PROJ3D_+3A_m2">M2</code></td>
<td>
<p>rotation matrix</p>
</td></tr>
<tr><td><code id="PROJ3D_+3A_anorms">anorms</code></td>
<td>
<p>normals to structure</p>
</td></tr>
<tr><td><code id="PROJ3D_+3A_zee">zee</code></td>
<td>
<p>Up direction of body</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a 3D body, rotates it and
projects it for plotting. An example glyph is found in
Z3Darrow.
</p>


<h3>Value</h3>

<p>Glyph structure
</p>
<table>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>coordinates of rotated body faces</p>
</td></tr>
<tr><td><code>xp</code></td>
<td>
<p>rotated normal vectors</p>
</td></tr>
<tr><td><code>zd</code></td>
<td>
<p>depth mean value of each face</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>makeblock3D, ROTZ, ROTY, ROTX, BOXarrows3D, Z3Darrow, TRANmat</p>


<h3>Examples</h3>

<pre><code class='language-R'>  block1 = matrix(c(0,0,0,
      1,0,0,
      1,0.5,0,
      0,0.5,0,
      0,0,-2,
      1,0,-2,
      1,0.5,-2,
      0,0.5,-2), byrow=TRUE, ncol=3)

    Bblock1 = makeblock3D(block1)

    R3 = ROTX(-40)
    R2 = ROTY(0)
    R1 = ROTZ(20)
    T =  TRANmat(.1, 0, 0 )
    M =     R1  %*% R2  %*%  R3  %*% T

    T2 =  TRANmat(1, 0.5, 0 )
    MT =       T2 %*%   R1  %*% R2  %*%   R3 %*% T

    Z1 =  PROJ3D(Bblock1$aglyph, M=MT,  anorms=Bblock1$anorm , zee=c(0,0,1))


</code></pre>

<hr>
<h2 id='PTaxes'>Plot P-T axis on CLVD
</h2><span id='topic+PTaxes'></span>

<h3>Description</h3>

<p>Plot P-T axis on CLVD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PTaxes(strike, dip, rake)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTaxes_+3A_strike">strike</code></td>
<td>
<p>strike
</p>
</td></tr>
<tr><td><code id="PTaxes_+3A_dip">dip</code></td>
<td>
<p>dip
</p>
</td></tr>
<tr><td><code id="PTaxes_+3A_rake">rake</code></td>
<td>
<p>rake
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lower Hemisphere. 
Add PT axes on a moment tensor plot
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>doNonDouble, MapNonDouble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mo = list(n=1, m1=1.035675e+017, m2=-1.985852e+016,
m3=-6.198052e+014, m4=1.177936e+017, m5=-7.600627e+016, m6=-3.461405e+017)
moments = cbind(mo$n, mo$m1, mo$m2, mo$m3, mo$m4, mo$m5, mo$m6)
doNonDouble(moments)


</code></pre>

<hr>
<h2 id='PTXY2'>Plot P-T Axes
</h2><span id='topic+PTXY2'></span>

<h3>Description</h3>

<p>given a focal mechanism, add P-T lines to a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PTXY2(x = x, y = y, MEC, focsiz, pt = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTXY2_+3A_x">x</code></td>
<td>
<p>x-location on plot
</p>
</td></tr>
<tr><td><code id="PTXY2_+3A_y">y</code></td>
<td>
<p>y-location on plot
</p>
</td></tr>
<tr><td><code id="PTXY2_+3A_mec">MEC</code></td>
<td>
<p>Focal Mechanism list from SDRFOC
</p>
</td></tr>
<tr><td><code id="PTXY2_+3A_focsiz">focsiz</code></td>
<td>
<p>size of mechanism, inches
</p>
</td></tr>
<tr><td><code id="PTXY2_+3A_pt">pt</code></td>
<td>
<p>pt = 0(plot both), 1=only P axes, 2=only T axes, default=0
</p>
</td></tr>
<tr><td><code id="PTXY2_+3A_...">...</code></td>
<td>
<p>graphical parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a summary plot to be used instead of Beach Balls.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M., Geotouch: Software for Three and Four Dimensional GIS in the Earth Sciences, Computers &amp; Geosciences, 26, 7, 751-761, 2000.
</p>


<h3>See Also</h3>

<p>nipXY, justfocXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  HAiti Earthquake Jan, 2010
MEC &lt;-  SDRfoc(71, 64, 25 , u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
plot(c(0, 1), c(0,1), type='n', asp=1)
u &lt;- par("usr")

justfocXY(MEC, x=.5,  y= .5,  focsiz=0.5,
fcol ='brown' , fcolback = "white", xpd = TRUE)

 PTXY2(1.0, .5 , MEC  ,0.5, col="purple", lwd=3 )
 
nipXY(MEC, x = 0.25, y = .5, focsiz=0.5,
fcol ='purple', nipcol = "black", cex = 0.4)
#####  or
set.seed(2015)
N = 20
lon=runif(20, 268.1563 , 305)
lat=runif(20, 7.593004,  25.926045)
str1=runif(20,50,100)
dip1=runif(20,10, 80)
rake1=runif(20,5, 180)

dep=runif(20,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)

 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)

PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm

XY = GEOmap::GLOB.XY(lat, lon, PROJ)

plot(range(XY$x), range(XY$y), type='n', asp=1)

for(i in 1:length(XY$x))
{
  Msdr = CONVERTSDR(MEKS$str1[i], MEKS$dip1[i],MEKS$rake1[i])
     MEC = MRake(Msdr$M)
       MEC$UP = FALSE

         jcol =  foc.color(foc.icolor(MEC$rake1), pal=1)

PTXY2(XY$x[i], XY$y[i] , MEC  ,focsiz=0.5, col=jcol, lwd=3)

}




</code></pre>

<hr>
<h2 id='qpoint'>Point on Stereonet</h2><span id='topic+qpoint'></span>

<h3>Description</h3>

<p>Plot a set of (azimuths, takeoff) angles on a stereonet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpoint(az, iang, col = 2, pch = 5, lab = "", POS = 4, UP = FALSE, PLOT = FALSE, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpoint_+3A_az">az</code></td>
<td>
<p>vector of azimuths, degrees</p>
</td></tr>
<tr><td><code id="qpoint_+3A_iang">iang</code></td>
<td>
<p>vector of incident angles, degrees</p>
</td></tr>
<tr><td><code id="qpoint_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="qpoint_+3A_pch">pch</code></td>
<td>
<p>plotting character</p>
</td></tr>
<tr><td><code id="qpoint_+3A_lab">lab</code></td>
<td>
<p>text labels</p>
</td></tr>
<tr><td><code id="qpoint_+3A_pos">POS</code></td>
<td>
<p>position for labels</p>
</td></tr>
<tr><td><code id="qpoint_+3A_up">UP</code></td>
<td>
<p> logical, TRUE=upper </p>
</td></tr>
<tr><td><code id="qpoint_+3A_plot">PLOT</code></td>
<td>
<p>logical,  add to existing plot </p>
</td></tr>
<tr><td><code id="qpoint_+3A_cex">cex</code></td>
<td>
<p>character expansion of labels </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iang argument represents the takeoff angle, and
is measured from the nadir (z-axis pointing down).
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>coordinate on plot</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>coordinate on plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>FixDip, focpoint</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d = runif(10, 0, 90)
a = runif(10, 0,360)
net()
qpoint(a, d)


</code></pre>

<hr>
<h2 id='radiateP'>Plot radiation pattern for P-waves</h2><span id='topic+radiateP'></span>

<h3>Description</h3>

<p>Plots focal mechanism and makes radiation plot with mark up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiateP(MEC, SCALE = FALSE, col = col, TIT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiateP_+3A_mec">MEC</code></td>
<td>
<p>focal mechanism structure</p>
</td></tr>
<tr><td><code id="radiateP_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale</p>
</td></tr>
<tr><td><code id="radiateP_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="radiateP_+3A_tit">TIT</code></td>
<td>
<p>title for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side graphical effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>radP, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
radiateP(MEC, SCALE = FALSE, col = rainbow(100) , TIT = FALSE)

</code></pre>

<hr>
<h2 id='radiateSH'>Plot radiation pattern for SH-waves</h2><span id='topic+radiateSH'></span>

<h3>Description</h3>

<p>Plots focal mechanism and makes radiation plot with mark up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiateSH(MEC, SCALE = FALSE, col = col, TIT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiateSH_+3A_mec">MEC</code></td>
<td>
<p>focal mechanism structure</p>
</td></tr>
<tr><td><code id="radiateSH_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale</p>
</td></tr>
<tr><td><code id="radiateSH_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="radiateSH_+3A_tit">TIT</code></td>
<td>
<p>title for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side graphical effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>radSH, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
radiateSH(MEC, SCALE = FALSE, col = rainbow(100) , TIT = FALSE)

</code></pre>

<hr>
<h2 id='radiateSV'>Plot radiation pattern for SV-waves</h2><span id='topic+radiateSV'></span>

<h3>Description</h3>

<p>Plots focal mechanism and makes radiation plot with mark up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiateSV(MEC, SCALE = FALSE, col = col, TIT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiateSV_+3A_mec">MEC</code></td>
<td>
<p>focal mechanism structure</p>
</td></tr>
<tr><td><code id="radiateSV_+3A_scale">SCALE</code></td>
<td>
<p>logical, TRUE=add scale</p>
</td></tr>
<tr><td><code id="radiateSV_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="radiateSV_+3A_tit">TIT</code></td>
<td>
<p>title for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side graphical effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>radSV, SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC =SDRfoc(65,25,13, u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
radiateSV(MEC, SCALE = FALSE, col = rainbow(100) , TIT = FALSE)

</code></pre>

<hr>
<h2 id='radP'>Radiation pattern for P waves</h2><span id='topic+radP'></span>

<h3>Description</h3>

<p>calculate the radiation patterns for P waves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radP(del, phiS, lam, ichi, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radP_+3A_del">del</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radP_+3A_phis">phiS</code></td>
<td>
<p>degrees,angle </p>
</td></tr>
<tr><td><code id="radP_+3A_lam">lam</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radP_+3A_ichi">ichi</code></td>
<td>
<p>degrees, take off angle</p>
</td></tr>
<tr><td><code id="radP_+3A_phi">phi</code></td>
<td>
<p>degrees, take off azimuth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a focal mechanism strike-dip-rake
and a given incident angle (take-off angle)
and azimuth, return the P amplitude
</p>


<h3>Value</h3>

<p>Amplitude of the P wave
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.</p>


<h3>See Also</h3>

<p>radP, radSV, imageP</p>


<h3>Examples</h3>

<pre><code class='language-R'>phiS=65
del=25
lam=13
x = seq(-1, 1, 0.01)
y = x

X = matrix(rep(x, length(y)), nrow= length(x))
Y = t(X)
RAD2DEG = 180/pi
p = RAD2DEG*(pi/2 -atan2(Y, X))
p[p&lt;0] = p[p&lt;0] + 360

R = sqrt(X^2+Y^2)
R[R&gt;1] = NaN
dip =RAD2DEG*2*asin(R/sqrt(2))

###  Calculate the radiation pattern
G = radP(del, phiS, lam, dip, p)

###  plot values
image(x,y,G, asp=1)

</code></pre>

<hr>
<h2 id='radSH'>Radiation pattern for SH waves</h2><span id='topic+radSH'></span>

<h3>Description</h3>

<p>calculate the radiation patterns for SH waves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radSH(del, phiS, lam, ichi, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radSH_+3A_del">del</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radSH_+3A_phis">phiS</code></td>
<td>
<p>degrees,angle </p>
</td></tr>
<tr><td><code id="radSH_+3A_lam">lam</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radSH_+3A_ichi">ichi</code></td>
<td>
<p>degrees, take off angle</p>
</td></tr>
<tr><td><code id="radSH_+3A_phi">phi</code></td>
<td>
<p>degrees, take off azimuth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a focal mechanism strike-dip-rake
and a given incident angle (take-off angle)
and azimuth, return the SH amplitude
</p>


<h3>Value</h3>

<p>Amplitude of the SH wave
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.</p>


<h3>See Also</h3>

<p>radP, radSV, imageSH</p>


<h3>Examples</h3>

<pre><code class='language-R'>phiS=65
del=25
lam=13
x = seq(-1, 1, 0.01)
y = x

X = matrix(rep(x, length(y)), nrow= length(x))
Y = t(X)
RAD2DEG = 180/pi
p = RAD2DEG*(pi/2 -atan2(Y, X))
p[p&lt;0] = p[p&lt;0] + 360

R = sqrt(X^2+Y^2)
R[R&gt;1] = NaN
dip =RAD2DEG*2*asin(R/sqrt(2))

###  Calculate the radiation pattern
G = radSH(del, phiS, lam, dip, p)

###  plot values
image(x,y,G, asp=1)

</code></pre>

<hr>
<h2 id='radSV'>Radiation pattern for SV waves</h2><span id='topic+radSV'></span>

<h3>Description</h3>

<p>calculate the radiation patterns for SV waves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radSV(del, phiS, lam, ichi, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radSV_+3A_del">del</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radSV_+3A_phis">phiS</code></td>
<td>
<p>degrees,angle </p>
</td></tr>
<tr><td><code id="radSV_+3A_lam">lam</code></td>
<td>
<p>degrees, angle </p>
</td></tr>
<tr><td><code id="radSV_+3A_ichi">ichi</code></td>
<td>
<p>degrees, take off angle</p>
</td></tr>
<tr><td><code id="radSV_+3A_phi">phi</code></td>
<td>
<p>degrees, take off azimuth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a focal mechanism strike-dip-rake
and a given incident angle (take-off angle)
and azimuth, return the SV amplitude
</p>


<h3>Value</h3>

<p>Amplitude of the SV wave
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University Science Books, Sausalito, Calif., 2nd edition, 2002.</p>


<h3>See Also</h3>

<p>radP, radSH, imageSV</p>


<h3>Examples</h3>

<pre><code class='language-R'>phiS=65
del=25
lam=13
x = seq(-1, 1, 0.01)
y = x

X = matrix(rep(x, length(y)), nrow= length(x))
Y = t(X)
RAD2DEG = 180/pi
p = RAD2DEG*(pi/2 -atan2(Y, X))
p[p&lt;0] = p[p&lt;0] + 360

R = sqrt(X^2+Y^2)
R[R&gt;1] = NaN
dip =RAD2DEG*2*asin(R/sqrt(2))

###  Calculate the radiation pattern
G = radSV(del, phiS, lam, dip, p)

###  plot values
image(x,y,G, asp=1)

</code></pre>

<hr>
<h2 id='rakelegend'>Focal Legend based on rake
</h2><span id='topic+rakelegend'></span>

<h3>Description</h3>

<p>Focal Legend based on rake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rakelegend(corn="topright", pal=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rakelegend_+3A_corn">corn</code></td>
<td>
<p>position of legend, default=&quot;topright&quot;
</p>
</td></tr>
<tr><td><code id="rakelegend_+3A_pal">pal</code></td>
<td>
<p>palette number, default=1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors are based on earlier publication
of Geotouch program.
</p>
<p>For pal = 1,   colors are ,
DarkSeaGreen, cyan1, SkyBlue1, RoyalBlue,
GreenYellow, orange, red.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M., (1999) Geotouch: Software for Three
and Four-Dimensional GIS in the Earth Sciences,
Computers and Geosciences, 26(7) 751-761. 
</p>


<h3>See Also</h3>

<p>foc.color,focleg 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(0,1), c(0,1), type='n')

rakelegend(corn="topleft", pal=1)

</code></pre>

<hr>
<h2 id='readCMT'>Read Harvard  CMT moment
</h2><span id='topic+readCMT'></span>

<h3>Description</h3>

<p>Read and plot a CMT solution copied from the
Harvard CMT website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCMT(filename, PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCMT_+3A_filename">filename</code></td>
<td>
<p>character, file name
</p>
</td></tr>
<tr><td><code id="readCMT_+3A_plot">PLOT</code></td>
<td>
<p>Logical, TRUE=plot mechanisms sequentially
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the standard output format.
</p>


<h3>Value</h3>

<p>List of mechanisms and graphical Side effects.
Each element in the list consists of a list
including:
FIRST,yr,mo,dom,hr,mi,sec,name,tshift,half,lat,lon,z,Mrr,Mtt,Mpp,Mrt,Mrp,Mtp.
The FIRST element is simply a duplicate of the PDE solution card.
</p>


<h3>Note</h3>

<p>Other formats are available.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Ekstrom, G.; Nettles, M. and  DziewoDski, A.
The Global CMT Project 2004-2010: centroid-moment tensors for 13,017
earthquakes Physics of the Earth and Planetary Interiors, 2012.
</p>


<h3>See Also</h3>

<p>doNonDouble, MapNonDouble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
Hcmt = readCMT("CMT_FULL_FORMAT.txt")

########  or,

Hcmt = readCMT("CMT_FULL_FORMAT.txt", PLOT=FALSE)

 moments = matrix(ncol=7, nrow=length(Hcmt))
Locs = list(y=vector(length=length(Hcmt)) ,x=vector(length=length(Hcmt)))


for(i in 1:length(Hcmt))
{
P1 = Hcmt[[i]]
#########  Note the change of sign for cartesian coordinates
 moments[i,] = cbind(i, P1$Mtt, P1$Mpp, P1$Mrr,
        -P1$Mrp, P1$Mrt ,-P1$Mtp)
Locs$y[i] = P1$lat
Locs$x[i] = P1$lon

}


mlon = mean(Locs$x, na.rm=TRUE)
mlat = mean(Locs$y, na.rm=TRUE)


PROJ =  GEOmap::setPROJ(type = 1, LAT0 = mlat , LON0 = mlon)
Glocs = GEOmap::GLOB.XY(Locs$y, Locs$x, PROJ       )


LIMlat = expandbound(Locs$y)
LIMlon = expandbound(Locs$x)

PLAT =  pretty(LIMlat)
 PLON  = pretty(LIMlon)

data(worldmap)
par(xpd=FALSE)

plotGEOmapXY(worldmap, LIM = c(LIMlon[1],LIMlat[1] ,LIMlon[2],LIMlat[2]) ,
             PROJ=PROJ, axes=FALSE, xlab="", ylab="" )

### add tic marks
kbox = GEOmap::GLOB.XY(PLAT,PLON, PROJ)

      sqrTICXY(kbox , PROJ, side=c(1,2,3,4), LLgrid=TRUE, col=grey(.7) )

########  add focal mechs

MapNonDouble(Glocs, moments, col=NULL, add=TRUE)




## End(Not run)

</code></pre>

<hr>
<h2 id='RectDense'>Divide a region into rectangles based on density </h2><span id='topic+RectDense'></span>

<h3>Description</h3>

<p>Given a set of (x,y) points, partition the field into
rectangles each containing a minimum number of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RectDense(INx, INy, icut = 1, u = par("usr"), ndivs = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RectDense_+3A_inx">INx</code></td>
<td>
<p>x-coordinates </p>
</td></tr>
<tr><td><code id="RectDense_+3A_iny">INy</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="RectDense_+3A_icut">icut</code></td>
<td>
<p>cut off for number of points</p>
</td></tr>
<tr><td><code id="RectDense_+3A_u">u</code></td>
<td>
<p>user coordinates</p>
</td></tr>
<tr><td><code id="RectDense_+3A_ndivs">ndivs</code></td>
<td>
<p>number of divisions in x-coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the user coordinates as returned from par('usr').
Each rectangular region is tested for the number of
points that fall within icut or greater.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>icorns</code></td>
<td>
<p>matrix of corners that passed test</p>
</td></tr>
<tr><td><code>ilens</code></td>
<td>
<p>vector,number of points in each icorns box</p>
</td></tr>
<tr><td><code>ipass</code></td>
<td>
<p>vector, index of the corners that passed icut</p>
</td></tr>
<tr><td><code>corners</code></td>
<td>
<p>matrix of all corners</p>
</td></tr>
<tr><td><code>lens</code></td>
<td>
<p>vector,number of points for each box</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rnorm(100)
y = rnorm(100)

plot(x,y)
u = par('usr')
RI = RectDense(x, y, icut=3, u=u, ndivs=10)

 rect(RI$icorns[,1],RI$icorns[,2],RI$icorns[,3],RI$icorns[,4], col=NA, border='blue')


</code></pre>

<hr>
<h2 id='REFLECT'>reflect pole</h2><span id='topic+REFLECT'></span>

<h3>Description</h3>

<p>Reflect pole to lower hemisphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REFLECT(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REFLECT_+3A_a">A</code></td>
<td>
<p>structure of azimuth and Dips in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of:cartesian coordinates of reflected pole
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr> 
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr> 
<tr><td><code>z</code></td>
<td>
<p>z-coordinate</p>
</td></tr> 
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr> 
<tr><td><code>dip</code></td>
<td>
<p>dip, degrees</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Preflect</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = list(az=231, dip = -65)
REFLECT(A)


</code></pre>

<hr>
<h2 id='RFOC-package'>
Calculates and plot Earthquake Focal Mechanisms
</h2><span id='topic+RFOC-package'></span><span id='topic+RFOC'></span>

<h3>Description</h3>

<p>Graphics for statistics on a sphere, as applied to
geological fault data, crystallography,
earthquake focal mechanisms,
radiation patterns,
ternary plots and geographical/geological maps.
Given strike-dip-rake or a set of fault planes, 
focal planes, RFOC creates structures for manipulating
and plotting
earthquake focal mechanisms
as individual plots or distributed spatially maps.
</p>
<p>RFOC can be used for analysis of plane orientation,
geologic structure, distribution of stress and strain
analyses.
</p>


<h3>Details</h3>

<p>Visualize focal mechanisms in a
number of modes, including: beachball plots, radiation plots,
fault planes and ternary diagrams.  Shows spatial distribution of
spherically distributed data.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees
Maintainer: Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>J. M.  Lees.  Geotouch: Software for three and four dimensional
GIS in the earth sciences.   <em>Computers  and  Geosciences</em> ,
26(7):751&ndash;761, 2000.
</p>
<p>K.~Aki and P.~G. Richards.<em>Quantitative seismology</em>. University
Science Books, Sausalito, Calif., 2nd edition, 2002.
</p>
<p>Snyder, John P., 1987,  Map Projections-a working manual,
USGS-Professional Paper, 383p.
</p>
<p>C. Frohlich.   Triangle   diagrams:   ternary  graphs   to display
similarity and   diversity  of earthquake    focal
mechanisms.   <em>Physics  of the Earth  and Planetary Interiors</em>,
75:193-198,   1992.
</p>


<h3>See Also</h3>

<p>RSEIS, GEOmap, zoeppritz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#############  plot one focal mechanism:
M = SDRfoc(-25, 34, 16,u = FALSE, ALIM = c(-1, -1, +1, +1), PLOT=TRUE)


#############  plot many P-axes:
paz = rnorm(100, mean=297, sd=100)
pdip = rnorm(100, mean=52, sd=20)
net()
focpoint(paz, pdip, col='red',  pch=3, lab="", UP=FALSE)

#############

#### Show many Focal mechanisms on a plot:

Z1 = c(159.33,51.6,206,18,78,
161.89,54.5,257,27,133,
170.03,53.57,-44,13,171,
154.99,50.16,-83,19,-40,
151.09,47.15,123,23,-170,
176.31,51.41,-81,22,122,
153.71,46.63,205,28,59,
178.39,51.21,-77,16,126,
178.27,51.1,-86,15,115,
177.95,51.14,-83,25,126,
178.25,51.18,215,16,27
)

MZ = matrix(Z1, ncol=5, byrow=TRUE)

plot(MZ[,1], MZ[,2], type='n', xlab="LON", ylab="LAT", asp=1)

for(i in 1:length(MZ[,1]))
{
paste(MZ[i,3], MZ[i,4], MZ[i,5])


MEC =  SDRfoc(MZ[i,3], MZ[i,4], MZ[i,5], u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
fcol =  foc.color(foc.icolor(MEC$rake1), pal=1)
justfocXY(MEC, x=MZ[i,1], y =MZ[i,2] , focsiz=0.5, fcol =fcol , fcolback = "white", xpd = TRUE)


}



</code></pre>

<hr>
<h2 id='rotateFoc'>Rotate Focal Mechanism 
</h2><span id='topic+rotateFoc'></span>

<h3>Description</h3>

<p>Rotate mechanism to vertical plan at specified angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateFoc(MEX, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateFoc_+3A_mex">MEX</code></td>
<td>
<p>Focal Mechanism list
</p>
</td></tr>
<tr><td><code id="rotateFoc_+3A_phi">phi</code></td>
<td>
<p>angle in degrees
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumed vertical plane, outer hemisphere
</p>


<h3>Value</h3>

<p>Focal Mechanism
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotfoc, SDRfoc,Beachfoc,  TEACHFOC, plotmanyfoc, getUWfocs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

a1 = SDRfoc(90, 90, 90, u = TRUE , PLOT = TRUE)


par(mfrow=c(2,2))

SDRfoc(a1$az1, a1$dip1, a1$rake1, u = TRUE, PLOT = TRUE)
ra1 = rotateFoc(a1, -90)

SDRfoc(ra1$az1, ra1$dip1, ra1$rake1, u = TRUE , PLOT = TRUE)

ra1 = rotateFoc(a1, 0)


SDRfoc(a1$az1, a1$dip1, a1$rake1, u = TRUE, PLOT = TRUE)

SDRfoc(ra1$az1, ra1$dip1, ra1$rake1, u = TRUE , PLOT = TRUE)





</code></pre>

<hr>
<h2 id='Rotfocphi'>Rotate Focal Mechanism
</h2><span id='topic+Rotfocphi'></span>

<h3>Description</h3>

<p>Rotate Focal Mechanism into the vertical plane
by a certain number of degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotfocphi(phi, urot, udip, vrot, vdip, az1, d1, az2, d2, prot, pdip, trot, tdip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rotfocphi_+3A_phi">phi</code></td>
<td>
<p>degrees in plane to rotate
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_urot">urot</code></td>
<td>
<p>U-vector azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_udip">udip</code></td>
<td>
<p>U-vector dip
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_vrot">vrot</code></td>
<td>
<p>V-vector azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_vdip">vdip</code></td>
<td>
<p>V-vector dip
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_az1">az1</code></td>
<td>
<p>First plane - azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_d1">d1</code></td>
<td>
<p>First plane -  dip
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_az2">az2</code></td>
<td>
<p>Second plane - azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_d2">d2</code></td>
<td>
<p>Second  plane -  dip
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_prot">prot</code></td>
<td>
<p>P-axis azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_pdip">pdip</code></td>
<td>
<p>P-axis dip
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_trot">trot</code></td>
<td>
<p>T-axis azimuth
</p>
</td></tr>
<tr><td><code id="Rotfocphi_+3A_tdip">tdip</code></td>
<td>
<p>T-axis dip
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotate the focal mech by phi degrees
</p>


<h3>Value</h3>

<p>list:
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>xsecmanyfoc, rotateFoc
</p>

<hr>
<h2 id='RotTP'>Rotate T-P axes
</h2><span id='topic+RotTP'></span>

<h3>Description</h3>

<p>Rotate T-P axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotTP(rotmat, strk1, dip1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotTP_+3A_rotmat">rotmat</code></td>
<td>
<p>rotation matrix, 3 by 3 
</p>
</td></tr>
<tr><td><code id="RotTP_+3A_strk1">strk1</code></td>
<td>
<p>strike angle
</p>
</td></tr>
<tr><td><code id="RotTP_+3A_dip1">dip1</code></td>
<td>
<p>dip angle
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are used as functions auxiallry to rotateFoc.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>strk</code></td>
<td>
<p>strike angle</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip angle</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Rotfocphi, TP2XYZ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
phi = 18

MAT = JMAT(phi)

RotTP(MAT, 30, 40)

</code></pre>

<hr>
<h2 id='ROTX'>X-axis Rotation Matrix</h2><span id='topic+ROTX'></span>

<h3>Description</h3>

<p>Matrix rotation about the X-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROTX(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROTX_+3A_deg">deg</code></td>
<td>
<p>Angle in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4 by 4 matrix for rotation and translation for 3-D transformation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Rogers and Adams, 1990, Mathematical Elements for Computer
Graphics, McGraw-Hill, 611p.</p>


<h3>See Also</h3>

<p>ROTY, ROTZ</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(1,4,5)
A = ROTX(23)
vp = c(v, 1)  

</code></pre>

<hr>
<h2 id='rotx3'>Rotate about the x axis</h2><span id='topic+rotx3'></span>

<h3>Description</h3>

<p>3x3 Rotation  about the x axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotx3(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotx3_+3A_deg">deg</code></td>
<td>
<p> angle, degrees </p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns a 3 by 3 rotation matrix
</p>


<h3>Value</h3>

<p>matrix, 3 by 3
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>roty3, rotz3, ROTX, ROTZ, ROTY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = 45
rotx3(a)


</code></pre>

<hr>
<h2 id='ROTY'>Y-axis Rotation Matrix</h2><span id='topic+ROTY'></span>

<h3>Description</h3>

<p>Matrix rotation about the Y-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROTY(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROTY_+3A_deg">deg</code></td>
<td>
<p>Angle in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4 by 4 matrix for rotation and translation for 3-D transformation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Rogers and Adams, 1990, Mathematical Elements for Computer
Graphics, McGraw-Hill, 611p.</p>


<h3>See Also</h3>

<p>ROTX, ROTZ</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(1,4,5)
A = ROTY(23)
vp = c(v, 1)  

</code></pre>

<hr>
<h2 id='roty3'>Rotate about the y axis</h2><span id='topic+roty3'></span>

<h3>Description</h3>

<p>3x3 Rotation  about the y axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roty3(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roty3_+3A_deg">deg</code></td>
<td>
<p> angle, degrees </p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns a 3 by 3 rotation matrix
</p>


<h3>Value</h3>

<p>matrix, 3 by 3
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>rotz3, rotx3, ROTX, ROTZ, ROTY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = 45
roty3(a)


</code></pre>

<hr>
<h2 id='ROTZ'>Z-axis Rotation Matrix</h2><span id='topic+ROTZ'></span>

<h3>Description</h3>

<p>Matrix rotation about the Z-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROTZ(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROTZ_+3A_deg">deg</code></td>
<td>
<p>Angle in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4 by 4 matrix for rotation and translation for 3-D transformation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Rogers and Adams, 1990, Mathematical Elements for Computer
Graphics, McGraw-Hill, 611p.</p>


<h3>See Also</h3>

<p>ROTX, ROTY</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(1,4,5)
A = ROTZ(23)
vp = c(v, 1)  


</code></pre>

<hr>
<h2 id='rotz3'>Rotate about the z axis</h2><span id='topic+rotz3'></span>

<h3>Description</h3>

<p>3x3 Rotation  about the z axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotz3(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotz3_+3A_deg">deg</code></td>
<td>
<p> angle, degrees </p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns a 3 by 3 rotation matrix
</p>


<h3>Value</h3>

<p>matrix, 3 by 3
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>roty3, rotx3, ROTX, ROTZ, ROTY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = 45
rotz3(a)


</code></pre>

<hr>
<h2 id='SDRfoc'>Plot a Focal Mechanism from SDR</h2><span id='topic+SDRfoc'></span>

<h3>Description</h3>

<p>Given Strike-Dip-Rake plot a focal mechanism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDRfoc(s, d, r, u = FALSE, ALIM = c(-1, -1, +1, +1), PLOT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SDRfoc_+3A_s">s</code></td>
<td>
<p>strike, degrees</p>
</td></tr>
<tr><td><code id="SDRfoc_+3A_d">d</code></td>
<td>
<p>dip, degrees</p>
</td></tr>
<tr><td><code id="SDRfoc_+3A_r">r</code></td>
<td>
<p>rake, degrees</p>
</td></tr>
<tr><td><code id="SDRfoc_+3A_u">u</code></td>
<td>
<p>logical, TRUE=upper hemisphere</p>
</td></tr>
<tr><td><code id="SDRfoc_+3A_alim">ALIM</code></td>
<td>
<p>bounding box on plot </p>
</td></tr>
<tr><td><code id="SDRfoc_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=add to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ALIM vector allows one to zoom into portions of the focal
mechanism for details when points are tightly clustered.
</p>


<h3>Value</h3>

<p>MEC structure
</p>


<h3>Note</h3>

<p>Basic MEC List Structure
</p>

<table>
<tr>
 <td style="text-align: left;">
  az1 </td><td style="text-align: left;"> azimuth angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dip1 </td><td style="text-align: left;"> dip angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  az2 </td><td style="text-align: left;"> azimuth angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dip2 </td><td style="text-align: left;"> dip angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dir </td><td style="text-align: left;"> 0,1 to determine which section of focal sphere is shaded</td>
</tr>
<tr>
 <td style="text-align: left;">
  rake1 </td><td style="text-align: left;"> rake angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dipaz1 </td><td style="text-align: left;"> dip azimuth angle plane 1, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  rake2 </td><td style="text-align: left;"> rake angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  dipaz2 </td><td style="text-align: left;"> dip azimuth angle plane 2, degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
  P </td><td style="text-align: left;"> pole list(az, dip) P-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  T </td><td style="text-align: left;"> pole list(az, dip) T-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  U </td><td style="text-align: left;"> pole list(az, dip) U-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  V </td><td style="text-align: left;"> pole list(az, dip) V-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  F </td><td style="text-align: left;"> pole list(az, dip) F-axis</td>
</tr>
<tr>
 <td style="text-align: left;">
  G </td><td style="text-align: left;"> pole list(az, dip) G-axis </td>
</tr>
<tr>
 <td style="text-align: left;">
  sense </td><td style="text-align: left;"> 0,1 to determine which section of focal sphere is shaded</td>
</tr>
<tr>
 <td style="text-align: left;">
  M </td><td style="text-align: left;"> list of focal parameters used in some calculations</td>
</tr>
<tr>
 <td style="text-align: left;">
  UP </td><td style="text-align: left;"> logical, TRUE=upper hemisphere</td>
</tr>
<tr>
 <td style="text-align: left;">
  icol </td><td style="text-align: left;"> index to suite of colors for focal mechanism</td>
</tr>
<tr>
 <td style="text-align: left;">
  ileg </td><td style="text-align: left;"> Kind of fault</td>
</tr>
<tr>
 <td style="text-align: left;">
  fcol </td><td style="text-align: left;"> color of focal mechanism</td>
</tr>
<tr>
 <td style="text-align: left;">
  CNVRG </td><td style="text-align: left;"> Character, note on convergence of solution</td>
</tr>
<tr>
 <td style="text-align: left;">
  LIM </td><td style="text-align: left;"> vector plotting region (x1, y1, x2, y2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>CONVERTSDR</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M = SDRfoc(-25, 34, 16,u = FALSE, ALIM = c(-1, -1, +1, +1), PLOT=TRUE)


</code></pre>

<hr>
<h2 id='ShadowCLVD'>Plot CLVD focal mechanism
</h2><span id='topic+ShadowCLVD'></span>

<h3>Description</h3>

<p>Plot non-double couple part of the focal mechanism
provided in the moment tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShadowCLVD(m, PLOT = TRUE, col=rgb(1, .75, .75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShadowCLVD_+3A_m">m</code></td>
<td>
<p>moment tensor
</p>
</td></tr>
<tr><td><code id="ShadowCLVD_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE means plot
</p>
</td></tr>
<tr><td><code id="ShadowCLVD_+3A_col">col</code></td>
<td>
<p>color, either a single color, rgb, or a color palette
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is meant to be used with 
doNonDouble or MapNonDouble functions for plotting
the non-double couple components
of the moment tensor.
A color palette can be provided for some
details of the radiation patterns, e.g.  col=rainbow(12).
</p>


<h3>Value</h3>

<p>Side effects and image list
</p>


<h3>Note</h3>

<p>Lower Hemisphere.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>doNonDouble, MapNonDouble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############  moment tensor from Harvard CMT catalog
sponent = 26
ef = 1*10^(sponent)
Mrr =  2.375*ef
Mtt = -2.777*ef
Mpp = 0.403*ef
Mrt = 2.800*ef
Mrp = 1.190*ef
Mtp = -0.539*ef

############  convert to cartesian coordinates
Mzz=Mrr
Mxx= Mtt
Myy= Mpp
Mxz= Mrt
Myz= -Mrp 
Mxy= -Mtp


m=matrix( c(Mxx,Mxy,Mxz,
      Mxy,Myy,Myz,
       Mxz,Myz,Mzz), ncol=3, byrow=TRUE)

Fi=seq(from=0, by=0.1, to=361)
  ###  dev.new()
    plot(cos(Fi*pi/180.0),sin(Fi*pi/180.0),type='l', asp=1 , ann=FALSE, axes=FALSE)
  
  ShadowCLVD(m, col='red')



</code></pre>

<hr>
<h2 id='SHradfoc'>Plot SH-wave radiation</h2><span id='topic+SHradfoc'></span>

<h3>Description</h3>

<p>Plot SH-wave radiation with information from the pickfile and
waveform data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SHradfoc(A, MEC, GU, pscale, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SHradfoc_+3A_a">A</code></td>
<td>
<p>Pickfile structure</p>
</td></tr>
<tr><td><code id="SHradfoc_+3A_mec">MEC</code></td>
<td>
<p>MEC structure</p>
</td></tr>
<tr><td><code id="SHradfoc_+3A_gu">GU</code></td>
<td>
<p>Waveform Event Structure</p>
</td></tr>
<tr><td><code id="SHradfoc_+3A_pscale">pscale</code></td>
<td>
<p>logical (not used)</p>
</td></tr>
<tr><td><code id="SHradfoc_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image plot of the SH radiation pattern
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>imageSH</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC = SDRfoc(65, 32, -34, u=TRUE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)

SHradfoc(NULL, MEC , NULL, TRUE, rainbow(100) )



</code></pre>

<hr>
<h2 id='SourceType'>Moment Tensor Source Type
</h2><span id='topic+SourceType'></span>

<h3>Description</h3>

<p>Given a vector of EigenValues,
extract the source type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SourceType(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SourceType_+3A_v">v</code></td>
<td>
<p>vector of decreasing eigenvalues</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotting for -30 to 30 degree quadrant.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>latitude angle in degrees</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>longitude angle in degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Tape, W.,and C.Tape(2012), A geometric comparison of source-type plots for moment tensors, Geophys. J. Int., 190, 499-510.</p>


<h3>See Also</h3>

<p> HAMMERprojXY, TapeBase, TapePlot</p>


<h3>Examples</h3>

<pre><code class='language-R'>SourceType(c(1,-1,1) )

T1 = TapeBase()

m1 = list(Mxx=1.543,  Mxy=0.786,  Myy=0.336, Mxz=-2.441,  Myz=0.353,  Mzz=0.961)

i = 1
M1=matrix( c(m1$Mxx[i],m1$Mxy[i],m1$Mxz[i],
      m1$Mxy[i],m1$Myy[i],m1$Myz[i],
       m1$Mxz[i],m1$Myz[i],m1$Mzz[i]), ncol=3, byrow=TRUE)

 E1 = eigen(M1)
           h = SourceType( sort(E1$values, decreasing=TRUE) )
           h$dip = 90-h$phi
           ##  cat(paste(h$dip, h$lam, sep=" "), sep="\n")
           h1 = HAMMERprojXY(h$dip*pi/180, h$lam*pi/180)



TapePlot(T1)
           points(h1$x, h1$y,  pch=21, bg="red" )





</code></pre>

<hr>
<h2 id='spherefocgeo'>SphereFocGeo
</h2><span id='topic+spherefocgeo'></span>

<h3>Description</h3>

<p>Spherical Projections of PT axes
distributed geographically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherefocgeo(CMTSOL, PROJ = NULL, icut = 5,
ndivs = 10,  bbox=c(0,1, 0, 1), PLOT = TRUE,
 add = FALSE, RECT = FALSE, pal = terrain.colors(100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spherefocgeo_+3A_cmtsol">CMTSOL</code></td>
<td>
<p>see output of getCMT for list input
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_proj">PROJ</code></td>
<td>
<p>Map projection
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_icut">icut</code></td>
<td>
<p>cut off for number of points in box, default=5
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_ndivs">ndivs</code></td>
<td>
<p>divisions of map area, default=10
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_bbox">bbox</code></td>
<td>
<p>bounding box for dividing the area,
given as minX, maxX, minY, maxY;
default=usr
coordinates from par()
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_plot">PLOT</code></td>
<td>
<p>logical, default=TRUE
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_add">add</code></td>
<td>
<p>logical, add to existing plot
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_rect">RECT</code></td>
<td>
<p>logical, TRUE=plot rectangles
</p>
</td></tr>
<tr><td><code id="spherefocgeo_+3A_pal">pal</code></td>
<td>
<p>palette fo rimages in each box
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program divides the area into blocks, tests each one
for minimum number per block and projects
the P and T axes onto an equal area  stereonet.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>PlotPTsmooth, ternfocgeo, prepFOCS, RectDense
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

N = 100
LATS = c(7.593004,  25.926045)
LONS = c(268.1563 , 305)
lon=rnorm(N, mean=mean(LONS), sd=diff(LONS)/2 )
lat=rnorm(N, mean=mean(LATS), sd=diff(LATS)/2)

str1=runif(N,50,100)
dip1=runif(N,10, 80)
rake1=runif(N,5, 180)


dep=runif(N,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)


 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
 rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)
 
PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm
XY = GEOmap::GLOB.XY(lat, lon, PROJ)
plot(range(XY$x), range(XY$y), type='n', asp=1)

  points(XY$x, XY$y)
spherefocgeo(MEKS, PROJ, PLOT=TRUE, icut = 3, ndivs = 4,
 add=TRUE, pal=terrain.colors(100), RECT=TRUE )







## Not run: 

plot(x=range(IZ$x), y=range(IZ$y), type='n', asp=1, axes=FALSE, ann=FALSE)

image(x=IZ$x, y=IZ$y, z=(UZ), col=blues, add=TRUE)

image(x=IZ$x, y=IZ$y, z=(AZ), col=terrain.colors(100) , add=TRUE)


 plotGEOmapXY(haiti.map,
              LIM = c(Lon.range[1],Lat.range[1] ,
Lon.range[2] ,Lat.range[2]),
              PROJ =PROJ, MAPstyle = 2,
 MAPcol = 'black' , add=TRUE  )

H = rectPERIM(JMAT$xo, JMAT$yo)


antipolygon(H$x ,H$y,   col=grey(.85)  , corner=1, pct=.4)

sqrTICXY(H , PROJ, side=c(1,2,3,4),   LLgrid=TRUE, col=grey(.7) )


spherefocgeo(OLDCMT, PROJ, PLOT=TRUE, add=TRUE, pal=topo.colors(100) )




## End(Not run)





</code></pre>

<hr>
<h2 id='spline.arrow'>Spline Arrow
</h2><span id='topic+spline.arrow'></span>

<h3>Description</h3>

<p>Given a set of points, draw a spline and
affix an arrow at the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline.arrow(x, y = 0, kdiv = 20, arrow = 1,
 length = 0.2, col = "black", thick = 0.01,
headlength = 0.2, headthick = 0.1, code = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline.arrow_+3A_x">x</code></td>
<td>
<p>vector, x-coordinates
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_y">y</code></td>
<td>
<p>vector, y-coordinates
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_kdiv">kdiv</code></td>
<td>
<p>Number of divisions
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_arrow">arrow</code></td>
<td>
<p>style of arrow, 1=simple arrow, 2=fancy arrow
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_length">length</code></td>
<td>
<p>length of head
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_col">col</code></td>
<td>
<p>color of arrow
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_thick">thick</code></td>
<td>
<p>thickness of arrow stem
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_headlength">headlength</code></td>
<td>
<p>length of arrow head
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_headthick">headthick</code></td>
<td>
<p>thickness of arrow head
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_code">code</code></td>
<td>
<p>code, 1=arrow on end of spline, 3=arrow on beginning.
</p>
</td></tr>
<tr><td><code id="spline.arrow_+3A_...">...</code></td>
<td>
<p>graphical parameters for the line
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can use either simple arrows
or fancy arrows.
</p>


<h3>Value</h3>

<p>list of x,y coordinates
of the spline and Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>fancyarrows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(0,1), c(0,1), type='n')


G=list()
G$x=c(0.1644,0.1227,0.0659,0.0893,0.2346,
0.3514,0.5518,0.7104,0.6887,0.6903,0.8422)
G$y=c(0.8816,0.8305,0.7209,0.6086,0.5372,
0.6061,0.6545,0.6367,0.4352,0.3025,0.0475)



spline.arrow(G$x, G$y)



</code></pre>

<hr>
<h2 id='StrikeDip'>Plot Strike Dip Lines
</h2><span id='topic+StrikeDip'></span>

<h3>Description</h3>

<p>Given a focal mechanism, add Strike Dip lines to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrikeDip(x = x, y = y, MEC, focsiz, addDIP = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StrikeDip_+3A_x">x</code></td>
<td>
<p>x-location on plot
</p>
</td></tr>
<tr><td><code id="StrikeDip_+3A_y">y</code></td>
<td>
<p>y-location on plot
</p>
</td></tr>
<tr><td><code id="StrikeDip_+3A_mec">MEC</code></td>
<td>
<p>Focal Mechanism list from SDRFOC
</p>
</td></tr>
<tr><td><code id="StrikeDip_+3A_focsiz">focsiz</code></td>
<td>
<p>size of mechanism, inches
</p>
</td></tr>
<tr><td><code id="StrikeDip_+3A_adddip">addDIP</code></td>
<td>
<p>Logical, TRUE = add dip line perpendicular to strike
</p>
</td></tr>
<tr><td><code id="StrikeDip_+3A_...">...</code></td>
<td>
<p>graphical parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a summary plot to be used instead of Beach Balls.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M., Geotouch: Software for Three and Four Dimensional GIS in the Earth Sciences, Computers &amp; Geosciences, 26, 7, 751-761, 2000.
</p>


<h3>See Also</h3>

<p>nipXY, justfocXY, plotmanyfoc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  HAiti Earthquake Jan, 2010
MEC &lt;-  SDRfoc(71, 64, 25 , u=FALSE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)
plot(c(0, 1), c(0,1), type='n', asp=1)
u &lt;- par("usr")
focsiz &lt;-  0.5
justfocXY(MEC, x=.5,  y= .5,  focsiz=0.5,
fcol ='brown' , fcolback = "white", xpd = TRUE)
 StrikeDip(1.0, .5 , MEC  ,focsiz, col="purple", lwd=3 )
nipXY(MEC, x = 0.25, y = .5,  focsiz=0.5,
fcol ='purple', nipcol = "black", cex = 1)


#####  or
set.seed(2015)
N = 20
lon=runif(20, 268.1563 , 305)
lat=runif(20, 7.593004,  25.926045)
str1=runif(20,50,100)
dip1=runif(20,10, 80)
rake1=runif(20,5, 180)

dep=runif(20,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)

 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)

PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm

XY = GEOmap::GLOB.XY(lat, lon, PROJ)

plot(range(XY$x), range(XY$y), type='n', asp=1)

for(i in 1:length(XY$x))
{
  Msdr = CONVERTSDR(MEKS$str1[i], MEKS$dip1[i],MEKS$rake1[i])
     MEC = MRake(Msdr$M)
       MEC$UP = FALSE

         jcol =  foc.color(foc.icolor(MEC$rake1), pal=1)


StrikeDip(XY$x[i], XY$y[i] , MEC  ,focsiz, col=jcol, lwd=3 )

}

</code></pre>

<hr>
<h2 id='strikeslip.fault'>Strikeslip Fault Cartoon</h2><span id='topic+strikeslip.fault'></span>

<h3>Description</h3>

<p>Illustrate a strikeslip fault using animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strikeslip.fault(anim = seq(from = 0, to = 1, by = 0.1), KAPPA = 2,
                 Light = c(45, 45))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strikeslip.fault_+3A_anim">anim</code></td>
<td>
<p>animation vector </p>
</td></tr>
<tr><td><code id="strikeslip.fault_+3A_kappa">KAPPA</code></td>
<td>
<p>Phong parameter for lighting</p>
</td></tr>
<tr><td><code id="strikeslip.fault_+3A_light">Light</code></td>
<td>
<p>lighting point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program will animate a strikeslip fault for educational purposes.
Animation must be stopped by  halting execution.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>normal.fault, thrust.fault</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strikeslip.fault(anim=0, Light=c(45,90) )

## Not run: 
#### execute a stop command to stop this animation
anim= seq(from=0, to=1, by=.1) 
 strikeslip.fault(anim=anim, Light=c(45,90) )
 
## End(Not run)
</code></pre>

<hr>
<h2 id='SVradfoc'>Plot SV-wave radiation</h2><span id='topic+SVradfoc'></span>

<h3>Description</h3>

<p>Plot SV-wave radiation with information from the pickfile and
waveform data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVradfoc(A, MEC, GU, pscale, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVradfoc_+3A_a">A</code></td>
<td>
<p>Pickfile structure</p>
</td></tr>
<tr><td><code id="SVradfoc_+3A_mec">MEC</code></td>
<td>
<p>MEC structure</p>
</td></tr>
<tr><td><code id="SVradfoc_+3A_gu">GU</code></td>
<td>
<p>Waveform Event Structure</p>
</td></tr>
<tr><td><code id="SVradfoc_+3A_pscale">pscale</code></td>
<td>
<p>logical (not used)</p>
</td></tr>
<tr><td><code id="SVradfoc_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image plot of the SV radiation pattern
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>imageSV</p>


<h3>Examples</h3>

<pre><code class='language-R'>MEC = SDRfoc(65, 32, -34, u=TRUE, ALIM=c(-1,-1, +1, +1), PLOT=FALSE)

SVradfoc(NULL, MEC , NULL, TRUE, rainbow(100) )



</code></pre>

<hr>
<h2 id='TapeBase'>Tape Base Lines
</h2><span id='topic+TapeBase'></span>

<h3>Description</h3>

<p>Create a structure of Tape Base lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TapeBase()
</code></pre>


<h3>Details</h3>

<p>Program returns the lines and points
for plotting a Tape plot.  Based on the Hammer projection.
</p>


<h3>Value</h3>

<p>List
</p>


<h3>Note</h3>

<p>The list includes points and other information
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Tape, W., and C. Tape (2012), A geometric comparison of source-type plots for moment tensors, Geophys. J. Int., 190, 499-510.
</p>


<h3>See Also</h3>

<p>TapePlot, HAMMERprojXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
T1 =TapeBase()
TapePlot(T1)

</code></pre>

<hr>
<h2 id='TapePlot'>Tape style Lune Plot
</h2><span id='topic+TapePlot'></span>

<h3>Description</h3>

<p>Tape style Lune Plot using Hammer projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TapePlot(TapeList = list(), add = FALSE, ann = TRUE,
pcol = c(grey(0), grey(0.85), grey(0.95)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TapePlot_+3A_tapelist">TapeList</code></td>
<td>
<p>List of strokes from TapeBase
</p>
</td></tr>
<tr><td><code id="TapePlot_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to existing plot
</p>
</td></tr>
<tr><td><code id="TapePlot_+3A_ann">ann</code></td>
<td>
<p>logical, TRUE=annotape
</p>
</td></tr>
<tr><td><code id="TapePlot_+3A_pcol">pcol</code></td>
<td>
<p>3-vector of colors: inner lines, upper polygon, lower polygon
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot an Tape net from the TapeBase function.  
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Tape, W., and C. Tape (2012), A geometric comparison of source-type plots for moment tensors, Geophys. J. Int., 190, 499-510. https://doi.org/10.1111/j.1365-246X.2012.05490.x
</p>


<h3>See Also</h3>

<p>TapeBase, HAMMERprojXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
T1 = TapeBase()
TapePlot(T1)

 data(widdenMoments)
WM = widdenMoments
        
         par(mfrow=c(1,1), mai=c(0,0,0,0))
         T1 = TapeBase()
         TapePlot(T1)

         for(i in 1:length(WM$Mxx))
         {
           M1=matrix( c(WM$Mxx[i],WM$Mxy[i],WM$Mxz[i],
      WM$Mxy[i],WM$Myy[i],WM$Myz[i],
       WM$Mxz[i],WM$Myz[i],WM$Mzz[i]), ncol=3, byrow=TRUE)

           E1 = eigen(M1)
           h = SourceType( sort(E1$values, decreasing=TRUE) )
           h$dip = 90-h$phi
           ##  cat(paste(h$dip, h$lam, sep=" "), sep="\n")
           h1 = HAMMERprojXY(h$dip*pi/180, h$lam*pi/180)
           
           points(h1$x, h1$y,  pch=21, bg="orange" )

         }





</code></pre>

<hr>
<h2 id='TEACHFOC'>Graphical Plot of Focal Mechanism</h2><span id='topic+TEACHFOC'></span>

<h3>Description</h3>

<p>Plots Beachball figure with numerous vectors and
points added and labeled. Useful for teaching about focal mechanisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEACHFOC(s, d, r, up = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TEACHFOC_+3A_s">s</code></td>
<td>
<p> strike </p>
</td></tr>
<tr><td><code id="TEACHFOC_+3A_d">d</code></td>
<td>
<p> dip </p>
</td></tr>
<tr><td><code id="TEACHFOC_+3A_r">r</code></td>
<td>
<p>rake </p>
</td></tr>
<tr><td><code id="TEACHFOC_+3A_up">up</code></td>
<td>
<p> logical, TRUE = upper </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>CONVERTSDR, MRake,foc.icolor,focleg, foc.color, focpoint,
PlotPlanes, nipXY , fancyarrows </p>


<h3>Examples</h3>

<pre><code class='language-R'>TEACHFOC(65, 32, -34, up=TRUE)

</code></pre>

<hr>
<h2 id='ternfoc.point'>Plot Ternary Point</h2><span id='topic+ternfoc.point'></span>

<h3>Description</h3>

<p>Add a point to a ternary plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternfoc.point(deltaB, deltaP, deltaT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ternfoc.point_+3A_deltab">deltaB</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
<tr><td><code id="ternfoc.point_+3A_deltap">deltaP</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
<tr><td><code id="ternfoc.point_+3A_deltat">deltaT</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot point on a Ternary diagram using Froelich's algorithm.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>vector of x coordinates</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>vector of y coordinates</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use Bfocvec(az1, dip1,  az2,  dip2) to get the deltaB angle.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>C. Frohlich.   Triangle   diagrams:   ternary  graphs   to display  similarity and   diversity  of earthquake
focal mechanisms.    Physics  of the Earth  and Planetary Interiors,  75:193-198,   1992.</p>


<h3>See Also</h3>

<p>Bfocvec</p>


<h3>Examples</h3>

<pre><code class='language-R'>Msdr = CONVERTSDR(55.01, 165.65,  29.2   )
 MEC = MRake(Msdr$M)
  MEC$UP = FALSE
   az1 = Msdr$M$az1
  dip1 = Msdr$M$d1
  az2 = Msdr$M$az2
  dip2 = Msdr$M$d2
  BBB = Bfocvec(az1, dip1,  az2,  dip2)
  V = ternfoc.point(BBB$Bdip, Msdr$M$pd, Msdr$M$td )


</code></pre>

<hr>
<h2 id='ternfocgeo'>Ternary Focals
</h2><span id='topic+ternfocgeo'></span>

<h3>Description</h3>

<p>Ternary plots of rake categories (strike-slip, normal, thrust)
distributed geographically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternfocgeo(CMTSOL, PROJ = NULL, icut = 5, ndivs = 10,
 bbox=c(0,1, 0, 1), PLOT = TRUE, add = FALSE, RECT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ternfocgeo_+3A_cmtsol">CMTSOL</code></td>
<td>
<p>see output of getCMT for list input
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_proj">PROJ</code></td>
<td>
<p>Map projection
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_icut">icut</code></td>
<td>
<p>cut off for number of points in box, default=5
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_ndivs">ndivs</code></td>
<td>
<p>divisions of map area, default=10
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_bbox">bbox</code></td>
<td>
<p>bounding box for dividing the area,
given as minX, maxX, minY, maxY;
default=usr
coordinates from par()
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_plot">PLOT</code></td>
<td>
<p>logical, default=TRUE
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_add">add</code></td>
<td>
<p>logical, add to existing plot
</p>
</td></tr>
<tr><td><code id="ternfocgeo_+3A_rect">RECT</code></td>
<td>
<p>logical, TRUE=plot rectangles
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program divides the area into blocks, tests each one
for minimum number per block and plots a ternary plot
for each block.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>PlotTernfoc, spherefocgeo, prepFOCS, RectDense
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 100
LATS = c(7.593004,  25.926045)
LONS = c(268.1563 , 305)
lon=rnorm(N, mean=mean(LONS), sd=diff(LONS)/2 )
lat=rnorm(N, mean=mean(LATS), sd=diff(LATS)/2)

str1=runif(N,50,100)
dip1=runif(N,10, 80)
rake1=runif(N,5, 180)


dep=runif(N,1,15)
name=seq(from=1, to=length(lon), by=1)
Elat=NULL
Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)


 MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)
PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm
XY = GEOmap::GLOB.XY(lat, lon, PROJ)
plot(range(XY$x), range(XY$y), type='n', asp=1)

##  points(XY$x, XY$y)

ternfocgeo(MEKS , PROJ, PLOT=TRUE, icut = 3,
ndivs = 4, add=TRUE, RECT=TRUE)

points(XY$x, XY$y, pch=8, col="purple" )

#################  next restrict the boxes to a specific region
plot(range(XY$x), range(XY$y), type='n', asp=1)
points(XY$x, XY$y)

ternfocgeo(MEKS , PROJ, PLOT=TRUE, icut = 3, ndivs = 5,
 bbox=c(-2000,2000,-2000,2000) , add=TRUE, RECT=TRUE)


## Not run: 

#####   this example shows a real application with a map
plot(x=range(IZ$x), y=range(IZ$y), type='n', asp=1, axes=FALSE, ann=FALSE)

image(x=IZ$x, y=IZ$y, z=(UZ), col=blues, add=TRUE)

image(x=IZ$x, y=IZ$y, z=(AZ), col=terrain.colors(100) , add=TRUE)


 plotGEOmapXY(haiti.map,
              LIM = c(Lon.range[1],Lat.range[1] ,
Lon.range[2] ,Lat.range[2]),
              PROJ =PROJ, MAPstyle = 2,
MAPcol = 'black' , add=TRUE  )

H = rectPERIM(JMAT$xo, JMAT$yo)


antipolygon(H$x ,H$y,   col=grey(.85)  , corner=1, pct=.4)

sqrTICXY(H , PROJ, side=c(1,2,3,4),   LLgrid=TRUE, col=grey(.7) )

ternfocgeo(OLDCMT, PROJ, PLOT=TRUE, add=TRUE)




## End(Not run)




  </code></pre>

<hr>
<h2 id='testrightHAND'>Test Right Hand of tensor
</h2><span id='topic+testrightHAND'></span>

<h3>Description</h3>

<p>Test Right Hand of tensor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testrightHAND(U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testrightHAND_+3A_u">U</code></td>
<td>
<p>3 by 3 matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fuction eigen does not
always produce a right-handed eigenvector
matrix.  The code tests each cross product
to see if it creates a right-hand system.
</p>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>forcerighthand
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mtens &lt;- c(-0.412, 0.084, 0.328 ,0.398, -1.239, 1.058)

M1 &lt;-  matrix(c(Mtens[1], Mtens[4], Mtens[5], Mtens[4],
Mtens[2], Mtens[6], Mtens[5],Mtens[6],
Mtens[3]), ncol=3, nrow=3, byrow=TRUE)

E1 &lt;-  eigen(M1)
testrightHAND(E1$vectors) 

</code></pre>

<hr>
<h2 id='thrust.fault'>Thrust Fault Cartoon</h2><span id='topic+thrust.fault'></span>

<h3>Description</h3>

<p>Illustrate a thrust fault using animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thrust.fault(anim = seq(from = 0, to = 1, by = 0.1), KAPPA = 2,
             Light = c(45, 45))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thrust.fault_+3A_anim">anim</code></td>
<td>
<p>animation vector </p>
</td></tr>
<tr><td><code id="thrust.fault_+3A_kappa">KAPPA</code></td>
<td>
<p>Phong parameter for lighting</p>
</td></tr>
<tr><td><code id="thrust.fault_+3A_light">Light</code></td>
<td>
<p>lighting point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program will animate a thrust fault for educational purposes.
Animation must be stopped by  halting execution.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>strikeslip.fault, thrust.fault</p>


<h3>Examples</h3>

<pre><code class='language-R'>

thrust.fault(anim=0, KAPPA=4, Light=c(-20, 80))

## Not run: 
#### execute a stop command to stop this animation
anim= seq(from=0, to=1, by=.1) 
thrust.fault(anim=anim, KAPPA=4, Light=c(-20, 80))

## End(Not run)

</code></pre>

<hr>
<h2 id='tk2uv'>Tk2uv
</h2><span id='topic+tk2uv'></span>

<h3>Description</h3>

<p>Tk plot to u-v coordinate transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk2uv(T, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk2uv_+3A_t">T</code></td>
<td>
<p>T-value
</p>
</td></tr>
<tr><td><code id="tk2uv_+3A_k">k</code></td>
<td>
<p>k-value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>T and k come from moment tensor
analysis.
</p>


<h3>Value</h3>

<p>List: u and v
</p>


<h3>Author(s)</h3>

<p>Keehoon Kim&lt;keehoon@live.unc.edu&gt;
Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Hudson
</p>


<h3>See Also</h3>

<p>m2tk, hudson.net, hudson.plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(2,-1,-1)
m = m2tk(v)
tk2uv(m$T, m$k)

</code></pre>

<hr>
<h2 id='to.spherical'>Convert Cartesian to Spherical</h2><span id='topic+to.spherical'></span>

<h3>Description</h3>

<p>Convert cartesian coordinates to strike and dip
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.spherical(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.spherical_+3A_x">x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code id="to.spherical_+3A_y">y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code id="to.spherical_+3A_z">z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>az</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>angle, degrees</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>SDRfoc</p>


<h3>Examples</h3>

<pre><code class='language-R'>to.spherical(3, 4, 5)
</code></pre>

<hr>
<h2 id='TOCART.DIP'>Convert to Cartesian</h2><span id='topic+TOCART.DIP'></span>

<h3>Description</h3>

<p>Convert azimuth and dip to cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOCART.DIP(az, dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOCART.DIP_+3A_az">az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code id="TOCART.DIP_+3A_dip">dip</code></td>
<td>
<p>dip, degrees </p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip, degrees </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>to.spherical</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOCART.DIP(134, 32)
</code></pre>

<hr>
<h2 id='tocartL'>Convert to cartesian coordinate</h2><span id='topic+tocartL'></span>

<h3>Description</h3>

<p>Convert azimuth-dip to cartesian coordinates with list as argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tocartL(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tocartL_+3A_a">A</code></td>
<td>


<dl>
<dt>az</dt><dd><p>degrees, azimuth</p>
</dd>
<dt>dip</dt><dd><p>degrees, dip</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
</table>


<h3>Note</h3>

<p>x positive north, y positive east, z positive downward
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>TOCART.DIP, RSEIS::TOCART, tosphereL, to.spherical</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = list(az=23, dip=84)
tocartL(A)
  
</code></pre>

<hr>
<h2 id='TOSPHERE'>Convert to Spherical Coordinates</h2><span id='topic+TOSPHERE'></span>

<h3>Description</h3>

<p>Get Azimuth and Dip from Cartesian vector on a sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOSPHERE(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOSPHERE_+3A_x">x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code id="TOSPHERE_+3A_y">y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
<tr><td><code id="TOSPHERE_+3A_z">z</code></td>
<td>
<p>z-coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>az</code></td>
<td>
<p>azimuth angle, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>dip, degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>TOSPHERE.DIP, tosphereL,  to.spherical</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOSPHERE(3, 4, 5)


</code></pre>

<hr>
<h2 id='TOSPHERE.DIP'>convert to spherical coordinates</h2><span id='topic+TOSPHERE.DIP'></span>

<h3>Description</h3>

<p>convert to spherical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOSPHERE.DIP(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOSPHERE.DIP_+3A_x">x</code></td>
<td>
<p>x-coordinate </p>
</td></tr>
<tr><td><code id="TOSPHERE.DIP_+3A_y">y</code></td>
<td>
<p>y-coordinate  </p>
</td></tr>
<tr><td><code id="TOSPHERE.DIP_+3A_z">z</code></td>
<td>
<p>z-coordinate </p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes three components and returns azimuth and dip
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>Dip, degrees</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate  </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>to.spherical</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOSPHERE.DIP(3, 4, 5)

</code></pre>

<hr>
<h2 id='tosphereL'>convert to spherical coordinates</h2><span id='topic+tosphereL'></span>

<h3>Description</h3>

<p>convert to spherical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tosphereL(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tosphereL_+3A_a">A</code></td>
<td>
<p>list (x,y,z)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes list of three components and returns azimuth and dip
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code>dip</code></td>
<td>
<p>Dip, degrees</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate  </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-coordinate </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>TOSPHERE</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A = list(x=12 ,y=2, z=-3 )
tosphereL(A)

</code></pre>

<hr>
<h2 id='TP2XYZ'>Trend - Dip to XYZ
</h2><span id='topic+TP2XYZ'></span>

<h3>Description</h3>

<p>Convert trend and dip to cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TP2XYZ(trend, dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TP2XYZ_+3A_trend">trend</code></td>
<td>
<p>trend angle, degrees
</p>
</td></tr>
<tr><td><code id="TP2XYZ_+3A_dip">dip</code></td>
<td>
<p>dip angle, degrees
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are used as functions auxiallry to rotateFoc.
</p>


<h3>Value</h3>

<p>vector: x, y, z
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RotTP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TP2XYZ(34, 40)

</code></pre>

<hr>
<h2 id='TRANmat'>Translation Matrix </h2><span id='topic+TRANmat'></span>

<h3>Description</h3>

<p>Create a 4 by 4 translation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRANmat(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRANmat_+3A_x">x</code></td>
<td>
<p>x-translation</p>
</td></tr>
<tr><td><code id="TRANmat_+3A_y">y</code></td>
<td>
<p>y-translation</p>
</td></tr>
<tr><td><code id="TRANmat_+3A_z">z</code></td>
<td>
<p>z-translation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix suitaqble for translating a 3D body.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Rogers and Adams, 1990, Mathematical Elements for Computer
Graphics, McGraw-Hill, 611p.</p>


<h3>See Also</h3>

<p>ROTX, ROTZ, ROTY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zT = TRANmat(5, 4, 2)
</code></pre>

<hr>
<h2 id='Vmoments'>Cartesian Moment Tensors</h2><span id='topic+Vmoments'></span>

<h3>Description</h3>

<p>Cartesian  Moment Tensors from  Varvryuk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Vmoments)
</code></pre>


<h3>Format</h3>

<p>A list of 9 moment tensors from Vaclav Varvryuk
</p>


<h3>Source</h3>

<p>http://www.ig.cas.cz/en/research-&amp;-teaching/software-download/
</p>


<h3>References</h3>

<p>http://www.ig.cas.cz/en/research-&amp;-teaching/software-download/
</p>

<hr>
<h2 id='widdenMoments'>Cartesian Moment Tensors</h2><span id='topic+widdenMoments'></span>

<h3>Description</h3>

<p>Cartesian  Moment Tensors from  Widden Paper in Utah
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(widdenMoments)
</code></pre>


<h3>Format</h3>

<p>A list of 48 moment tensors from Utah
</p>


<h3>Source</h3>

<p>SRL paper
</p>


<h3>References</h3>

<p>Seismological Research Letters
</p>

<hr>
<h2 id='Wnet'>Wulff Stereonet</h2><span id='topic+Wnet'></span>

<h3>Description</h3>

<p>plot a Wulff Stereonet (Equal-Angle)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wnet(add = FALSE, col = gray(0.7), border = "black", lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wnet_+3A_add">add</code></td>
<td>
<p>Logical, TRUE=add to existing plot</p>
</td></tr>
<tr><td><code id="Wnet_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="Wnet_+3A_border">border</code></td>
<td>
<p>border color</p>
</td></tr>
<tr><td><code id="Wnet_+3A_lwd">lwd</code></td>
<td>
<p>line width </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots equal-angle stereonet as opposed to equal-area.
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>net, pnet</p>


<h3>Examples</h3>

<pre><code class='language-R'>Wnet()

</code></pre>

<hr>
<h2 id='Wpoint'>Plot points on Wulff Stereonet</h2><span id='topic+Wpoint'></span>

<h3>Description</h3>

<p>Adds points to Wulff Equal-Angle Stereonet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wpoint(az1, dip1, col = 2, pch = 5, lab = "", UP = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wpoint_+3A_az1">az1</code></td>
<td>
<p>azimuth angle, degrees</p>
</td></tr>
<tr><td><code id="Wpoint_+3A_dip1">dip1</code></td>
<td>
<p>dip angle, degrees </p>
</td></tr>
<tr><td><code id="Wpoint_+3A_col">col</code></td>
<td>
<p>color  </p>
</td></tr>
<tr><td><code id="Wpoint_+3A_pch">pch</code></td>
<td>
<p>plotting character  </p>
</td></tr>
<tr><td><code id="Wpoint_+3A_lab">lab</code></td>
<td>
<p>label for point  </p>
</td></tr>
<tr><td><code id="Wpoint_+3A_up">UP</code></td>
<td>
<p>logical, TRUE=Upperhemisphere </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wulff net point is added to existing plot.
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p> Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Wnet</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Wnet()
Wpoint(23, 34)

</code></pre>

<hr>
<h2 id='xsecmanyfoc'>Plot Focal Mechs at X-Y position on cross sections
</h2><span id='topic+xsecmanyfoc'></span>

<h3>Description</h3>

<p>Plot Focal Mechs at X-Y positions on cross sectionsor other plots
that do not have geographic coordinates and projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsecmanyfoc(MEK,  theta=NULL, focsiz = 0.5, 
 foccol = NULL, UP=TRUE, focstyle=1, LEG = FALSE, DOBAR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsecmanyfoc_+3A_mek">MEK</code></td>
<td>
<p>List of Focal Mechanisms, see details
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_focsiz">focsiz</code></td>
<td>
<p>focal size, inches
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_theta">theta</code></td>
<td>
<p>degrees, angle from north  for projecting the focal mechs
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_foccol">foccol</code></td>
<td>
<p>focal color, default is to calculate based on rake
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_up">UP</code></td>
<td>
<p>logical, UP=TRUE means plot upper hemisphere (DEFAULT=TRUE) 
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_focstyle">focstyle</code></td>
<td>
<p>integer, 1=beach ball, 2=nipplot </p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_leg">LEG</code></td>
<td>
<p>logical, TRUE= add focal legend for color codes
</p>
</td></tr>
<tr><td><code id="xsecmanyfoc_+3A_dobar">DOBAR</code></td>
<td>
<p>add strike dip bar at epicenter
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input MEK list contains
</p>
<p>MEKS = list(lon=0, lat=0, str1=0, dip1=0, rake1=0, dep=0, name=&quot;&quot;,
Elat=0, Elon=0, x=0, y=0)
</p>
<p>The x, y coordinates of the input list are
location where the focals will be plotted.
For cross sections x=distance along the
section and y would be depth.  The focal mechs are
added to the current plot.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Note</h3>

<p>If theta is NULL focals are plotted as if they were
on a plan view.
If theta is provided, however, the mechs are plotted
with view from the vertical cross section.
The cross section is taken at two points.
Theta should be determined by viewing  the cross section with the first
point on the left and the second on the right.  The
view angle is through the section measured in degrees from north.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M., Geotouch: Software for Three and Four Dimensional GIS
in the Earth Sciences, Computers &amp; Geosciences, 26, 7, 751-761,
2000.
</p>


<h3>See Also</h3>

<p>justfocXY, plotmanyfoc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############# create and  plot the mechs in plan view:
N = 20
lon=runif(20, 235, 243)
     lat=runif(20, 45.4, 49)
     str1=runif(20,50,100)
     dip1=runif(20,10, 80)
     rake1=runif(20,5, 180)

     dep=runif(20,1,15)
     name=seq(from=1, to=length(lon), by=1)
     Elat=NULL
     Elon=NULL
yr = rep(2017, times=N)
jd = runif(N, min=1, max=365)

      MEKS = list(lon=lon, lat=lat, str1=str1, dip1=dip1,
 rake1=rake1, dep=dep, name=name, yr=yr, jd = jd)

     PROJ = GEOmap::setPROJ(type=2, LAT0=mean(lat) , LON0=mean(lon) )   ##   utm

     XY = GEOmap::GLOB.XY(lat, lon, PROJ)

     plot(range(XY$x), range(XY$y), type='n', asp=1)

     plotmanyfoc(MEKS, PROJ, focsiz=0.5)

ex = range(XY$x)
why = range(XY$y)


JJ = list(x=ex, y=why)


SWA = GEOmap::eqswath(XY$x, XY$y, MEKS$dep, JJ, width = diff(why) , PROJ = PROJ)


MEKS$x = rep(NA, length(XY$x))
MEKS$y = rep(NA, length(XY$y))


MEKS$x[SWA$flag] = SWA$r
MEKS$y[SWA$flag] = -SWA$depth
bigR = sqrt(  (JJ$x[2]-JJ$x[1])^2 + (JJ$y[2]-JJ$y[1])^2)

plot(c(0,bigR)   , c(0, min(-SWA$depth)) , type='n',
 xlab="Distance, KM", ylab="Depth")
points(SWA$r, -SWA$depth)

xsecmanyfoc(MEKS, focsiz=0.5,  LEG = TRUE, DOBAR=FALSE)
title("cross section: focals are plotted as if in plan view")


ang1 = atan2( JJ$y[2]-JJ$y[1] , JJ$x[2]-JJ$x[1])

 degang =  ang1*180/pi


xsecmanyfoc(MEKS, focsiz=0.5, theta=degang, LEG = TRUE, DOBAR=FALSE)
title("cross section: focals are view from the side projection (outer hemisphere)")





</code></pre>

<hr>
<h2 id='Z3Darrow'>Make a 3D arrow</h2><span id='topic+Z3Darrow'></span>

<h3>Description</h3>

<p>Create the list structure for a 3D arrow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z3Darrow(len = 1, basethick = 0.1, headlen = 0.6, headlip = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Z3Darrow_+3A_len">len</code></td>
<td>
<p>Length in user coordinates</p>
</td></tr>
<tr><td><code id="Z3Darrow_+3A_basethick">basethick</code></td>
<td>
<p>Thickness of the base </p>
</td></tr>
<tr><td><code id="Z3Darrow_+3A_headlen">headlen</code></td>
<td>
<p>Length of the head</p>
</td></tr>
<tr><td><code id="Z3Darrow_+3A_headlip">headlip</code></td>
<td>
<p>Width of the overhang lip </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a strucutre suitable for plotting rotated and translated 3D arrows.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>aglyph</code></td>
<td>
<p>List of vertices of the faces</p>
</td></tr>
<tr><td><code>anorm</code></td>
<td>
<p>Outward facing normal vectors to faces</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>PROJ3D, pglyph3D, phong3D</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ZA = Z3Darrow(len = 1, basethick = 0.1, headlen = 0.6, headlip = 0.1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
