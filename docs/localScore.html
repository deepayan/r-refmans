<!DOCTYPE html><html lang="en"><head><title>Help for package localScore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {localScore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#localScore-package'><p>localScore: Package for Sequence Analysis by Local Score</p></a></li>
<li><a href='#Aeso'><p>Congenital oesophageal atresia data</p></a></li>
<li><a href='#aeso.data'><p>Deprecated</p></a></li>
<li><a href='#automatic_analysis'><p>Automatic analysis</p></a></li>
<li><a href='#CharSequence2ScoreSequence'><p>Convert a character sequence into a score sequence</p></a></li>
<li><a href='#CharSequences2ScoreSequences'><p>Convert several character sequences into score sequences</p></a></li>
<li><a href='#daudin'><p>Daudin [p-value] [iid]</p></a></li>
<li><a href='#exact_mc'><p>Exact method for p-value [Markov chains]</p></a></li>
<li><a href='#HydroScore'><p>Dictionary</p></a></li>
<li><a href='#karlin'><p>Karlin [p-value] [iid]</p></a></li>
<li><a href='#karlinMonteCarlo'><p>Monte Carlo - Karlin [p-value]</p></a></li>
<li><a href='#lindley'><p>Lindley process</p></a></li>
<li><a href='#loadMatrixFromFile'><p>Loads matrix from csv-File</p></a></li>
<li><a href='#loadScoreFromFile'><p>Load score from file</p></a></li>
<li><a href='#localScoreC'><p>Local score</p></a></li>
<li><a href='#MarkovParameters'><p>Functions parameters global description</p></a></li>
<li><a href='#maxPartialSumd'><p>Maximum of the partial sum [probability] [iid]</p></a></li>
<li><a href='#mcc'><p>MCC [p-value] [iid]</p></a></li>
<li><a href='#monteCarlo'><p>Monte Carlo method [p-value]</p></a></li>
<li><a href='#proba_theoretical_first_excursion_iid'><p>Probability <code class="reqn">P(Q(1)\geq a)</code> that the height of the first excursion is greater or equal to <code>a</code> given a i.i.d. model on the letters sequence</p></a></li>
<li><a href='#proba_theoretical_ith_excursion_iid'><p>Probability <code class="reqn">P(Q(i)\geq a)</code> that the height of the ith excursion (sequential order) is greater or equal to <code>a</code> given a i.i.d. model on the letters sequence</p></a></li>
<li><a href='#proba_theoretical_ith_excursion_markov'><p>theoretical probability of reaching the threshold score a on the i-th excursion (sequential order) of a markov's score sequence</p></a></li>
<li><a href='#RealScores2IntegerScores'><p>Convert a real scores vector into an integer scores vector</p></a></li>
<li><a href='#recordTimes'><p>Calculate the record times of a sequence</p></a></li>
<li><a href='#scoreSequences2probabilityVector'><p>Empirical distribution from sequences</p></a></li>
<li><a href='#Seq1093'><p>Long protein sequence</p></a></li>
<li><a href='#Seq219'><p>Protein sequence</p></a></li>
<li><a href='#Seq31'><p>Short protein sequence</p></a></li>
<li><a href='#SeqListSCOPe'><p>Several sequences</p></a></li>
<li><a href='#sequences2transmatrix'><p>Transition matrix from sequence(s)</p></a></li>
<li><a href='#SJSyndrome'><p>Stevens-Johnson syndrome data</p></a></li>
<li><a href='#stationary_distribution'><p>Stationary distribution [Markov chains]</p></a></li>
<li><a href='#transmatrix2sequence'><p>Sampling function for Markov chains</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Package for Sequence Analysis by Local Score</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-24</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS for various embedded Eigen library
copyright details</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Robelin &lt;david.robelin@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionalities for calculating the local score and calculating statistical relevance (p-value) to find a local Score in a sequence of given distribution (S. Mercier and J.-J. Daudin (2001) <a href="https://hal.science/hal-00714174/">https://hal.science/hal-00714174/</a>) ; S. Karlin and S. Altschul (1990) <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC53667/">https://pmc.ncbi.nlm.nih.gov/articles/PMC53667/</a>  ; S. Mercier, D. Cellier and F. Charlot (2003) <a href="https://hal.science/hal-00937529v1/">https://hal.science/hal-00937529v1/</a> ; A. Lagnoux, S. Mercier and P. Valois (2017) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtw699">doi:10.1093/bioinformatics/btw699</a>&gt; ).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.16), utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 10:24:55 UTC; drobelin</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Simon [aut],
  Chris Verschelden [aut],
  Charly Marty [aut],
  David Robelin [aut, cre],
  Sabine Mercier [aut],
  Sebastien Dejean [aut],
  The authors of Eigen the library for the included version of Eigen
    [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='localScore-package'>localScore: Package for Sequence Analysis by Local Score</h2><span id='topic+localScore'></span><span id='topic+localScore-package'></span>

<h3>Description</h3>

<p>Provides functionalities for:
</p>

<ul>
<li><p> calculating the local score
</p>
</li>
<li><p> calculating statistical relevance (p-value) to find a local Score in a sequence of given distribution
</p>
</li></ul>

<p>Given a sequence of numerical score <code class="reqn">X_1,\dots,X_n</code>, the local score is defined : <code class="reqn">H_n = \max_{1 \leq i \leq j \leq n} \sum_{l = i}^j X_l</code>
This package find the value local score and the associated sub-sequence, and also sub-optimal local scores and segments. The complexity is linear with <code class="reqn">n</code>. It can be viewed as a generalization of a sliding window method, considering all windows size. In order to be pertinent, the expectation of the scores <code class="reqn">X_i</code> should be negative. Most of the methods concerning statistical relevance implemented in this package only applied on integer scores.
</p>


<h3>Details</h3>

<p>Please refer to the vignette of this package or the manual for details on how to use this package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Robelin <a href="mailto:david.robelin@inrae.fr">david.robelin@inrae.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Simon
</p>
</li>
<li><p> Chris Verschelden
</p>
</li>
<li><p> Charly Marty
</p>
</li>
<li><p> Sabine Mercier <a href="mailto:sabine.mercier@univ-tlse2.fr">sabine.mercier@univ-tlse2.fr</a>
</p>
</li>
<li><p> Sebastien Dejean <a href="mailto:sebastien.dejean@math.univ-toulouse.fr">sebastien.dejean@math.univ-toulouse.fr</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> The authors of Eigen the library for the included version of Eigen [copyright holder]
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> An Improved Approximation For Assessing The Statistical Significance of molecular Sequence Features, Mercier and al 2003
</p>
</li>
<li><p> Exact distribution for the local score of one i.i.d. random sequence, Sabine Mercier and JJ Daudin, 2001
</p>
</li>
<li><p> Limit Distributions of Maximal Segmental Score among Markov-Dependent Partial Sums, Karlin and Dembo 1992
</p>
</li>
<li><p> Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes, Karlin and al 1990
</p>
</li>
<li><p> Detection de courts segments inverses dans les genomes: methodes et applications, David Robelin 2005
</p>
</li>
<li><p> A Linear Time Algorithm for Finding All Maximal Scoring Subsequences, Constable and Bates 1985
</p>
</li></ul>


<hr>
<h2 id='Aeso'>Congenital oesophageal atresia data</h2><span id='topic+Aeso'></span>

<h3>Description</h3>

<p>The data consists of individual dates of birth over n=35 cases of the birth defects oesophageal and tracheo-oesophagean fistula
observed in a hospital in Birmingham, U.K., over 2191 days from 1950 through 1955, with Day one set as 1 January 1950
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Aeso)
</code></pre>


<h3>Format</h3>

<p>A matrix of 2191 lines and 2 columns. Each line is a day on the first column, and associated to a case (0/1) on the second column.
</p>


<h3>Source</h3>

<p>Dolk H. Secular pattern of congenital oesophageal atresia&ndash;George Knox, 1959. J Epidemiol Community Health. 1997;51(2):114-115. &lt;doi:10.1136/jech.51.2.114&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Aeso)
head(Aeso)
p &lt;- sum(Aeso[,2]) / dim(Aeso)[1]
print(p)
</code></pre>

<hr>
<h2 id='aeso.data'>Deprecated</h2><span id='topic+aeso.data'></span><span id='topic+SJSyndrome.data'></span><span id='topic+MySeqList'></span><span id='topic+dico'></span><span id='topic+LongSeq'></span><span id='topic+MidSeq'></span><span id='topic+ShortSeq'></span>

<h3>Description</h3>

<p>Some datasets are deprecated and will be removed in next version of the package.
Please use instead:
</p>

<ul>
<li><p> data(aeso.data) -&gt; data(Aeso)
</p>
</li>
<li><p> data(SJSyndrome.data) -&gt; data(SJSyndrome)
</p>
</li>
<li><p> data(MySeqList) -&gt; data(SeqListSCOPe)
</p>
</li>
<li><p> data(dico) -&gt; data(HydroScore)
</p>
</li>
<li><p> data(LongSeq) -&gt; data(Seq1093)
</p>
</li>
<li><p> data(MidSeq) -&gt; data(Seq219)
</p>
</li>
<li><p> data(ShortSeq) -&gt; data(Seq31)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(Aeso) ; data(SJSyndrome) ;
       data(SeqListSCOPe) ; data(HydroScore) ;
       data(Seq1093) ; data(Seq219) ; data(Seq31)
</code></pre>


<h3>Format</h3>

<p>Refers to the &quot;See also&quot; links below to obtain a description of each dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Aeso">Aeso</a></code> <code><a href="#topic+SJSyndrome">SJSyndrome</a></code> <code><a href="#topic+SeqListSCOPe">SeqListSCOPe</a></code> 
<code><a href="#topic+HydroScore">HydroScore</a></code> <code><a href="#topic+Seq1093">Seq1093</a></code> <code><a href="#topic+Seq219">Seq219</a></code> <code><a href="#topic+Seq31">Seq31</a></code>
</p>

<hr>
<h2 id='automatic_analysis'>Automatic analysis</h2><span id='topic+automatic_analysis'></span>

<h3>Description</h3>

<p>Calculates local score and p-value for sequence(s) with integer scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>automatic_analysis(
  sequences,
  model,
  scores,
  transition_matrix,
  distribution,
  method_limit = 2000,
  score_extremes,
  modelFunc,
  simulated_sequence_length = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="automatic_analysis_+3A_sequences">sequences</code></td>
<td>
<p>sequences to be analyzed (named list)</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_model">model</code></td>
<td>
<p>the underlying model of the sequence (either &quot;iid&quot; for identically independently distributed variable or &quot;markov&quot; for Markov chains)</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_scores">scores</code></td>
<td>
<p>vector of minimum and maximum score range</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>if the sequences are markov chains, this is their transition matrix</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_distribution">distribution</code></td>
<td>
<p>vector of probabilities in ascending score order (iid sequences). Note that names of the vector must be the associated scores.</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_method_limit">method_limit</code></td>
<td>
<p>limit length from which on computation-intensive exact calculation methods for p-value are replaced by approximative methods</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_score_extremes">score_extremes</code></td>
<td>
<p>a vector with two elements: minimal score value, maximal score value</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_modelfunc">modelFunc</code></td>
<td>
<p>function to create similar sequences. In this case, Monte Carlo is used to calculate p-value</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_simulated_sequence_length">simulated_sequence_length</code></td>
<td>
<p>if a modelFunc is provided and the sequence happens to be longer than method_limit, the method karlinMonteCarlo
is used. This method requires the length of the sequences that will be created by the modelFunc for estimation of Gumble parameters.</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_...">...</code></td>
<td>
<p>parameters for modelFunc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method picks the adequate p-value method for your input.<br /> 
If no sequences are passed to this function, it will let you pick a FASTA file.<br /> 
If this is the case, and if you haven't provided any score system 
(as you can do by passing a named list with the appropriate scores for each character),
the second file dialog which will pop up is for choosing a file containing the score 
(and if you provide an extra column for the probabilities, they will be used, too - see
section File Formats in the vignette for details).<br /> 
The function then either uses empirical distribution based on your input - or if you provided
a distribution, then yours - to calculate the p-value based on the length of each of the sequences
given as input. <br /> 
You can influence the choice of the method by providing the modelFunc argument. In this case, the
function uses exclusively simulation methods (monteCarlo, karlinMonteCarlo).  <br /> 
By setting the method_limit you can further decide to which extent computation-intensive methods (daudin, exact_mc)
should be used to calculate the p-value.
Remark that the warnings of the localScoreC() function have be deleted when called by automatic_analysis() function
</p>


<h3>Value</h3>

<p>A list object containing
</p>
<table role = "presentation">
<tr><td><code>Local score</code></td>
<td>
<p>local score...</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>
<p>p-value ...</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>the method used for the calculus of the p-value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal example
l = list()
seq1 = sample(-2:1, size = 3000, replace = TRUE)
seq2 = sample(-3:1, size = 150, replace = TRUE)
l[["hello"]] = seq1
l[["world"]] = seq2
automatic_analysis(l, "iid")
# Example with a given distribution 
automatic_analysis(l,"iid",scores=-3:1,distribution=c(0.3,0.3,0.1,0.1,0.2))
#Equivalent call
automatic_analysis(l,"iid",score_extremes=c(-3,1),distribution=c(0.3,0.3,0.1,0.1,0.2))
# forcing the exact method for the longest sequence
aa1=automatic_analysis(l,"iid")
aa1$hello$`method applied`
aa1$hello$`p-value`
aa2=automatic_analysis(l,"iid",method_limit=3000)
aa2$hello$`method applied`
aa2$hello$`p-value`
# Markovian example 
MyTransMat &lt;-
matrix(c(0.3,0.1,0.1,0.1,0.4, 0.3,0.2,0.2,0.2,0.1, 0.3,0.4,0.1,0.1,0.1, 0.3,0.3,0.3,0.0,0.1, 
        0.1,0.3,0.2,0.3,0.1), ncol = 5, byrow=TRUE)
MySeq.CM=transmatrix2sequence(matrix = MyTransMat,length=150, score =-2:2)
MySeq.CM2=transmatrix2sequence(matrix = MyTransMat,length=110, score =-2:2)
automatic_analysis(sequences = list("x1" = MySeq.CM, "x2" = MySeq.CM2), model = "markov")
</code></pre>

<hr>
<h2 id='CharSequence2ScoreSequence'>Convert a character sequence into a score sequence</h2><span id='topic+CharSequence2ScoreSequence'></span>

<h3>Description</h3>

<p>Convert a character sequence into a score sequence. See CharSequences2ScoreSequences() function for several sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharSequence2ScoreSequence(charseq, dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CharSequence2ScoreSequence_+3A_charseq">charseq</code></td>
<td>
<p>a character sequence, given as a string</p>
</td></tr>
<tr><td><code id="CharSequence2ScoreSequence_+3A_dictionary">dictionary</code></td>
<td>
<p>a data.frame with rownames containing letters, first column containing associated scores, optional second column containing associated probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of a score sequence
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CharSequences2ScoreSequences">CharSequences2ScoreSequences</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq31)
Seq31
data(HydroScore)
CharSequence2ScoreSequence(Seq31,HydroScore)
</code></pre>

<hr>
<h2 id='CharSequences2ScoreSequences'>Convert several character sequences into score sequences</h2><span id='topic+CharSequences2ScoreSequences'></span>

<h3>Description</h3>

<p>Convert several character sequence into score sequences. For only one sequence see CharSequence2ScoreSequence() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharSequences2ScoreSequences(sequences, dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CharSequences2ScoreSequences_+3A_sequences">sequences</code></td>
<td>
<p>a list of character sequences given as string</p>
</td></tr>
<tr><td><code id="CharSequences2ScoreSequences_+3A_dictionary">dictionary</code></td>
<td>
<p>a data.frame with rownames containing letters, first column containing associated scores, optional second column containing associated probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of score sequences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CharSequence2ScoreSequence">CharSequence2ScoreSequence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq31)
Seq31
data(Seq219)
Seq219
data(HydroScore)
MySequences=list("A1"=Seq31,"A2"=Seq219)
CharSequences2ScoreSequences(MySequences,HydroScore)
</code></pre>

<hr>
<h2 id='daudin'>Daudin [p-value] [iid]</h2><span id='topic+daudin'></span>

<h3>Description</h3>

<p>Calculates the exact p-value in the identically and independently distributed of a given local score, a sequence length that 'must not be too large' and for a given score distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daudin(
  local_score,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daudin_+3A_local_score">local_score</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code id="daudin_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each score from lowest to greatest</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small in this context depends heavily on your machine. On a 3,7GHZ machine this means for daudin(1000, 5000, c(0.2, 0.2, 0.2, 0.1, 0.2, 0.1), -2, 3)
an execution time of ~2 seconds. This is due to the calculation method using matrix exponentiation which takes times. The size of the matrix of the exponentiation is equal to a+1 with a the local score value. The matrix must be put at the power n, with n the sequence length.
Moreover, it is known that the local score value is expected to be in mean of order log(n).
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>See Also</h3>

<p><code><a href="#topic+karlin">karlin</a></code>, <code><a href="#topic+mcc">mcc</a></code>, <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code>, <code><a href="#topic+monteCarlo">monteCarlo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daudin(local_score = 4, sequence_length = 50, 
score_probabilities = c(0.2, 0.3, 0.1, 0.2, 0.1, 0.1), sequence_min = -3, sequence_max = 2)
</code></pre>

<hr>
<h2 id='exact_mc'>Exact method for p-value [Markov chains]</h2><span id='topic+exact_mc'></span>

<h3>Description</h3>

<p>Calculates the exact p-value for short numerical Markov chains. Memory usage and time computation can be too large for a high local score value and high score range (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_mc(local_score, m, sequence_length, score_values = NULL, prob0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exact_mc_+3A_local_score">local_score</code></td>
<td>
<p>Integer local score for which the p-value should be calculated</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_m">m</code></td>
<td>
<p>Transition matrix [matrix object]. Optionality, rownames can be corresponding score values. m should be a transition matrix of an ergodic Markov chain.</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_sequence_length">sequence_length</code></td>
<td>
<p>Length of the sequence</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_score_values">score_values</code></td>
<td>
<p>A integer vector of sequence score values (optional). If not set, the rownames of m are used if they are numeric and set.</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_prob0">prob0</code></td>
<td>
<p>Vector of probability distribution of the first score of the sequence (optional). If not set, the stationnary distribution of m is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computation needs to allocate a square matrix of size local_score^(range(score_values)). This matrix is then exponentiated to sequence_length.
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monteCarlo">monteCarlo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mTransition &lt;- matrix(c(0.2, 0.3, 0.5, 0.3, 0.4, 0.3, 0.2, 0.4, 0.4), byrow = TRUE, ncol = 3)
scoreValues &lt;- -1:1
initialProb &lt;- stationary_distribution(mTransition)
exact_mc(local_score = 12, m = mTransition, sequence_length = 100, 
        score_values = scoreValues, prob0 = initialProb)
exact_mc(local_score = 150, m = mTransition, sequence_length = 1000, 
         score_values = scoreValues, prob0 = initialProb)
rownames(mTransition) &lt;- scoreValues
exact_mc(local_score = 12, m = mTransition, sequence_length = 100, prob0 = initialProb)
# Minimal specification
exact_mc(local_score = 12, m = mTransition, sequence_length = 100)
# Score valeus with "holes"
scoreValues &lt;- c(-2, -1, 2)
mTransition &lt;- matrix(c(0.2, 0.3, 0.5, 0.3, 0.4, 0.3, 0.2, 0.4, 0.4), byrow = TRUE, ncol = 3)
initialProb &lt;- stationary_distribution(mTransition)
exact_mc(local_score = 50, m = mTransition, sequence_length = 100, 
        score_values = scoreValues, prob0 = initialProb)
</code></pre>

<hr>
<h2 id='HydroScore'>Dictionary</h2><span id='topic+HydroScore'></span>

<h3>Description</h3>

<p>Provides integer scores related to an hydrophobicity level of each amino acid. This score function is inspired by the Kyte and Doolittle (1982) scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HydroScore)
</code></pre>


<h3>Format</h3>

<p>A score function for the 20 amino acid
</p>


<h3>Source</h3>

<p>Kyte &amp; Doolittle (1982) J. Mol. Biol. 157, 105-132
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HydroScore)
HydroScore
data(Seq219)
Seq219
seqScore &lt;- CharSequence2ScoreSequence(Seq219,HydroScore)
seqScore[1:30]
localScoreC(seqScore)$localScore
</code></pre>

<hr>
<h2 id='karlin'>Karlin [p-value] [iid]</h2><span id='topic+karlin'></span><span id='topic+karlin_parameters'></span>

<h3>Description</h3>

<p><code>karlin</code> Calculates an approximated p-value of a given local score value and a long sequence length in the identically and independently distributed model for the sequence. See also <code><a href="#topic+mcc">mcc</a></code> function for another approximated method in the i.i.d. model that improved the one given by <code><a href="#topic+karlin">karlin</a></code> or <code><a href="#topic+daudin">daudin</a></code> for exact calculation. <br />
<code>karlin_parameters</code> is a annex function returning the parameters <code class="reqn">\lambda</code>, <code class="reqn">K^+</code> and <code class="reqn">K^*</code> defined in Karlin and Dembo (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlin(
  local_score,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)

karlin_parameters(score_probabilities, sequence_min, sequence_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="karlin_+3A_local_score">local_score</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence (at least several hundreds)</p>
</td></tr>
<tr><td><code id="karlin_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method works the better the longer the sequence is. Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistent. In such case, you could try to change your score scheme (in case of discretization)
or use the function <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code> .
This function implements the formulae given in Karlin and Dembo (1992), page 115-6. As the score is discrete here (lattice score function),
there is no limit distribution of the local score with the size of the sequence, but an inferior and a superior bound
are given. The output of this function is conservative as it gives the upper bound for the p-value.
Notice the lower bound can easily be found as it is the same call of function with parameter value local_score+1.
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcc">mcc</a></code>, <code><a href="#topic+daudin">daudin</a></code>, <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code>, <code><a href="#topic+monteCarlo">monteCarlo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>karlin(150, 10000, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -5, 5)
</code></pre>

<hr>
<h2 id='karlinMonteCarlo'>Monte Carlo - Karlin [p-value]</h2><span id='topic+karlinMonteCarlo'></span><span id='topic+karlinMonteCarlo_double'></span>

<h3>Description</h3>

<p>Estimates p-value of the local score based on a Monte Carlo
estimation of Gumble parameters from simulations of smaller sequences with
same distribution. Appropriate for great sequences with length &gt; 10^3, for
i.i.d and markovian sequence models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlinMonteCarlo(
  local_score,
  sequence_length,
  simulated_sequence_length,
  FUN,
  ...,
  numSim = 1000,
  plot = TRUE,
  keepSimu = FALSE
)

karlinMonteCarlo_double(
  local_score,
  sequence_length,
  simulated_sequence_length,
  FUN,
  ...,
  numSim = 1000,
  plot = TRUE,
  keepSimu = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="karlinMonteCarlo_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a sequence.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_simulated_sequence_length">simulated_sequence_length</code></td>
<td>
<p>length of simulated sequences produced by</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to create for estimation
FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_plot">plot</code></td>
<td>
<p>boolean value if to display plots for cumulated function, density
and linearization of cumulative density function</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_keepsimu">keepSimu</code></td>
<td>
<p>Boolean, default to FALSE. If TRUE, the simulated local
scores are returned as the localScores element of the output list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the simulated sequences is an argument specific to the
function provided for simulation. Thus, it has to be provided also in the
parameter <code>simulated_sequence_length</code> in the arguments of the &quot;Monte
Carlo - Karlin&quot; function. It is a crucial detail as it influences precision
and computation time of the result. Note that to get an appropriate
estimation, the given average score must be non-positive. Be careful that
the parameters names of the function <code>FUN</code> should differ from those of
<code>karlinMonteCarlo</code> function. <br /> Methods - Parameters <code class="reqn">K^\star</code>
and <code class="reqn">\lambda</code> of Karlin and Dembo (1990) are estimated by a linear
regression on the log(-log(cumulative distribution function of the local
scores)) on shorter sequences (size <code>simulated_sequence_length</code>). The
formula used are : <code class="reqn">\hat{\lambda} = -\hat{b}</code> and <code class="reqn">\hat{K^\star} =
  exp(\hat{a})/simulated\_sequence\_length</code> where <code class="reqn">\hat{a}</code> is the
intercept of the regression and <code class="reqn">\hat{b}</code> is the slope of the
regression. Then p-value is given by <code class="reqn">p = exp(-K^\star * exp(-\lambda*x
  ))</code> where <code class="reqn">x = local\_score - \log(sequence\_length)/\lambda</code>. <br /> The
density plot produced by <code>plot == TRUE</code> depends on the type of the
simulated local scores: if they are integer, a barplot of relative
frequency is used, else <code>plot(density(...))</code> is used. <br /> This
function calls <code><a href="#topic+localScoreC">localScoreC</a></code> which type of the output depends
on the type of the input. To be efficient, be aware to use a simulating
function <code>FUN</code> that return a vector of adequate type (&quot;integer&quot; or
&quot;numeric&quot;). Warning: in R, <code>typeof(c(1,3,4,10)) == "double"</code>. You can
set a type of a vector with <code>mode()</code> or <code>as.integer()</code> functions
for example. <br /> <code>karlinMonteCarlo_double()</code> is deprecated. At this
point, it is just a call to <code>karlinMonteCarlo()</code> function.
</p>


<h3>Value</h3>

<p>If <code>keepSimu</code> is FALSE, returns a list containing:</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>p_value</code> </td><td style="text-align: left;"> Probability to obtain a local score with a value
  greater or equal to the parameter <code>local_score</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>K*</code>
  </td><td style="text-align: left;"> Parameter <code class="reqn">K^*</code> defined in Karlin and Dembo (1990) </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
  </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>lambda</code> </td><td style="text-align: left;"> Parameter <code class="reqn">\lambda</code> defined in Karlin and
  Dembo (1990) </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>If <code>keepSimu</code> is TRUE, returns a list containing:</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>p_value</code> </td><td style="text-align: left;"> Probability to obtain a local score with a value greater or equal to the parameter <code>local_score</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>K*</code> </td><td style="text-align: left;"> Parameter <code class="reqn">K^*</code> defined in Karlin and Dembo (1990) </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lambda</code> </td><td style="text-align: left;"> Parameter <code class="reqn">\lambda</code> defined in Karlin and Dembo (1990) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>localScores</code> </td><td style="text-align: left;"> Vector of size <code>numSim</code> containing the simulated local scores for sequence size of <code>simulated_sequence_length</code>
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+monteCarlo">monteCarlo</a></code> <code><a href="#topic+localScoreC">localScoreC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mySeq &lt;- sample(-7:6, replace = TRUE, size = 100000)
#MonteCarlo taking random sample from the input sequence itself
karlinMonteCarlo(local_score = 160, sequence_length = 100000,
               simulated_sequence_length = 1000,
               FUN = function(x, sim_length) {
                        return(sample(x = x,
                               size = sim_length,
                               replace = TRUE))
                     },
               x = mySeq,
               sim_length = 1000,
               numSim = 1000)


#Markovian example (longer computation)
MyTransMat_reels &lt;-  matrix(c(0.3, 0.1, 0.1, 0.1, 0.4,
                              0.2, 0.2, 0.1, 0.2, 0.3,
                              0.3, 0.4, 0.1, 0.1, 0.1,
                              0.3, 0.3, 0.1, 0.2, 0.1,
                              0.2, 0.1, 0.2, 0.4, 0.1),
                              ncol = 5, byrow=TRUE)
karlinMonteCarlo(local_score = 18.5, sequence_length = 200000,
                 simulated_sequence_length = 1500,
                 FUN = transmatrix2sequence,
                 matrix = MyTransMat_reels,
                 score =c(-1.5,-0.5,0,0.5,1), length = 1500,
                 plot=TRUE, numSim = 1500)

</code></pre>

<hr>
<h2 id='lindley'>Lindley process</h2><span id='topic+lindley'></span>

<h3>Description</h3>

<p>Creates a sequence of a Lindley process, also called CUSUM process, on a given sequence.  For a sequence (X_k)k, the Lindley process is defined as follows: W_0:=0 and W_(k+1)=max(0,W_k+X_(k+1)). It defines positive excursions above 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lindley(sequence)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lindley_+3A_sequence">sequence</code></td>
<td>
<p>numeric sequence of a Lindley process, eg service time per customer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the Lindley process steps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MySeq &lt;- c(1,2,3,-4,1,-3,-1,2,3,-4,1)
lindley(MySeq)
plot(1:length(MySeq),lindley(MySeq),type='b')
</code></pre>

<hr>
<h2 id='loadMatrixFromFile'>Loads matrix from csv-File</h2><span id='topic+loadMatrixFromFile'></span>

<h3>Description</h3>

<p>Reads a csv file without header and returns the matrix. For file formats please see section &quot;File Formats&quot; in vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMatrixFromFile(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadMatrixFromFile_+3A_filepath">filepath</code></td>
<td>
<p>optional: Location of file on disk. If not provided, a file picker dialog will be opened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Matrix Object
</p>

<hr>
<h2 id='loadScoreFromFile'>Load score from file</h2><span id='topic+loadScoreFromFile'></span>

<h3>Description</h3>

<p>Reads a csv file containing an alphabet, the associated scores, and eventually the associated probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadScoreFromFile(filepath, header = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadScoreFromFile_+3A_filepath">filepath</code></td>
<td>
<p>optional: location of file on disk. If not provided, a file picker dialogue box will be opened.</p>
</td></tr>
<tr><td><code id="loadScoreFromFile_+3A_header">header</code></td>
<td>
<p>does the file contain a header line (defaut to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="loadScoreFromFile_+3A_...">...</code></td>
<td>
<p>optional: use arguments from read.csv</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file should contains a header and 2 or 3 columns : first column the letters, second column the associated scores, optional third column associated probabilities. Letters should be unique and probabilities should sum to 1.
</p>


<h3>Value</h3>

<p>A data.frame. Rownames correspond to the first column, usually Letters. Associated numerical scores are in the second column. If probabilities are provided, 
they will be loaded too and presumed to be in the third column
</p>

<hr>
<h2 id='localScoreC'>Local score</h2><span id='topic+localScoreC'></span><span id='topic+localScoreC_double'></span><span id='topic+localScoreC_int'></span>

<h3>Description</h3>

<p>Calculates the local score for a sequence of scores, the sub-optimal segments, and the associated record times. The local score is the maximal sum of values contained in a segment among all possible segments of the sequence. In other word, it generalizes a sliding window approach, considering of all possible windows size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localScoreC(v, suppressWarnings = FALSE)

localScoreC_double(v, suppressWarnings = FALSE)

localScoreC_int(v, suppressWarnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localScoreC_+3A_v">v</code></td>
<td>
<p>a sequence of numerical values as vector (integer or double).</p>
</td></tr>
<tr><td><code id="localScoreC_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>(optional) if warnings should not be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>localScoreC</code> function is implemented in a templated C function. Be aware that the type of the output (<code>integer</code> or <code>double</code>) depends on the type of the input. The function <code>localScoreC_double</code> <code>localScoreC_int</code> explicitly use the corresponding type (with an eventual conversion in case of integer). Warning: in R, <code>typeof(c(1,3,4,10)) == "double"</code>. You can set a type of a vector with <code>mode()</code> or <code>as.integer()</code> functions for example. <br />
<code>localScoreC_int</code> is just a call to <code>as.integer()</code> before calling <code>localScoreC</code>. <code>localScore_double</code> is just a call to <code>localScoreC</code>, and as such is deprecated.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>localScore</code></td>
<td>
<p>the local score value and the begin and end index of the segment realizing this optimal score;</p>
</td></tr>
<tr><td><code>suboptimalSegmentScores</code></td>
<td>
<p>An array containing sub-optimal local scores, that is all the local maxima of the Lindley rocess (non negative excursion) and their begin and end index;</p>
</td></tr>
<tr><td><code>RecordTime</code></td>
<td>
<p>The record times of the Lindley process as defined in Karlin and Dembo (1990).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lindley">lindley</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>localScoreC(c(1.2,-2.1,3.5,1.7,-1.1,2.3))
# one segment realizing the local score value
seq.OneSegment &lt;- c(1,-2,3,1,-1,2)
localScoreC(seq.OneSegment) 
seq.TwoSegments &lt;- c(1,-2,3,1,2,-2,-2,-1,1,-2,3,1,2,-1,-2,-2,-1,1)
# two segments realizing the local score value
localScoreC(seq.TwoSegments) 
# only the first realization
localScoreC(seq.TwoSegments)$localScore 
# all the realization of the local together with the suboptimal ones
localScoreC(seq.TwoSegments)$suboptimalSegmentScores 
# for small sequences, you can also use lindley() function to check if 
# several segments achieve the local Score
lindley(seq.TwoSegments) 
plot(1:length(seq.TwoSegments),lindley(seq.TwoSegments),type='b')
seq.TwoSegments.InSameExcursion &lt;- c(1,-2,3,2,-1,0,1,-2,-2,-4,1)
localScoreC(seq.TwoSegments.InSameExcursion)
# lindley() shows two realizations in the same excursion (no 0 value between the two LS values)
lindley(seq.TwoSegments.InSameExcursion) 
# same beginning index but two possible ending indexes
# only one excursion realizes the local score even in there is two possible lengths of segment
localScoreC(seq.TwoSegments.InSameExcursion)$suboptimalSegmentScores 
plot(1:length(seq.TwoSegments.InSameExcursion),lindley(seq.TwoSegments.InSameExcursion),type='b')
# Technical note about type correspondance
seq.OneSegment &lt;- c(1,-2,3,1,-1,2)
seq.OneSegmentI &lt;- as.integer(seq.OneSegment)
typeof(seq.OneSegment)  # "double" (beware)
typeof(seq.OneSegmentI) # "integer"
LS1 &lt;- localScoreC(seq.OneSegment, suppressWarnings = TRUE)
LS1I &lt;- localScoreC(seq.OneSegmentI, suppressWarnings = TRUE)
typeof(LS1$localScore)  # "double"
typeof(LS1I$localScore) # "integer"
typeof(LS1$suboptimalSegmentScores$value)  # "double"
typeof(LS1I$suboptimalSegmentScores$value) # "integer"
# Force to use integer values (trunk values if necessary)
seq2 &lt;- seq.OneSegment + 0.5
localScoreC(seq2, suppressWarnings = TRUE)
localScoreC_int(seq.OneSegment, suppressWarnings = TRUE)
</code></pre>

<hr>
<h2 id='MarkovParameters'>Functions parameters global description</h2><span id='topic+MarkovParameters'></span>

<h3>Description</h3>

<p>Functions parameters global description
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MarkovParameters_+3A_theta">theta</code></td>
<td>
<p>alphabet used (vector of character)</p>
</td></tr>
<tr><td><code id="MarkovParameters_+3A_lambda">lambda</code></td>
<td>
<p>transition probability matrix of size, theta x theta</p>
</td></tr>
<tr><td><code id="MarkovParameters_+3A_score_function">score_function</code></td>
<td>
<p>vector containing the scores of each letters of the alphabet (must be in the same order as theta)</p>
</td></tr>
<tr><td><code id="MarkovParameters_+3A_a">a</code></td>
<td>
<p>score strictly positive</p>
</td></tr>
<tr><td><code id="MarkovParameters_+3A_prob0">prob0</code></td>
<td>
<p>Distribution of the first element of the Markov chain. Default to stationary distribution of lambda</p>
</td></tr>
</table>

<hr>
<h2 id='maxPartialSumd'>Maximum of the partial sum [probability] [iid]</h2><span id='topic+maxPartialSumd'></span>

<h3>Description</h3>

<p>Calculates the distribution of the maximum of the partial sum process for a given value in the identically and independently distributed model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxPartialSumd(k, score_probabilities, sequence_min, sequence_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxPartialSumd_+3A_k">k</code></td>
<td>
<p>value at which calculates the probability</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implement the formula (4) of the article Mercier, S., Cellier, D., &amp; Charlot, D. (2003). An improved approximation for assessing the statistical significance of molecular sequence features. Journal of Applied Probability, 40(2), 427-441. doi:10.1239/jap/1053003554 <br />
Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistency.
</p>


<h3>Value</h3>

<p>A double representing the probability of the maximum of the partial sum process equal to k
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maxPartialSumd(10, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
</code></pre>

<hr>
<h2 id='mcc'>MCC [p-value] [iid]</h2><span id='topic+mcc'></span>

<h3>Description</h3>

<p>Calculates an approximated p-value for a given local score value and a medium to long sequence length in the identically and independently distributed model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcc(
  local_score,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcc_+3A_local_score">local_score</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence (up to one hundred)</p>
</td></tr>
<tr><td><code id="mcc_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This methods is actually an improved method of Karlin and produces more precise results. It should be privileged whenever possible. <br />
As with karlin, the method works the better the longer the sequence. Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistency. In such case, you could try to change your score scheme (in case of discretization)
or use the function <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code> .
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>See Also</h3>

<p><code><a href="#topic+karlin">karlin</a></code>, <code><a href="#topic+daudin">daudin</a></code>, <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code>, <code><a href="#topic+monteCarlo">monteCarlo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcc(40, 100, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
mcc(40, 10000, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
</code></pre>

<hr>
<h2 id='monteCarlo'>Monte Carlo method [p-value]</h2><span id='topic+monteCarlo'></span><span id='topic+monteCarlo_double'></span>

<h3>Description</h3>

<p>Calculates an empirical p-value based on Monte Carlo simulations.
Perfect for small sequences (both markov chains and identically and independently distributed) with length ~ 10^3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monteCarlo(local_score, FUN, ..., plot = TRUE, numSim = 1000, keepSimu = FALSE)

monteCarlo_double(
  local_score,
  FUN,
  ...,
  plot = TRUE,
  numSim = 1000,
  keepSimu = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monteCarlo_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a segment.</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_plot">plot</code></td>
<td>
<p>boolean value if to display plots for cumulated function and density</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to generate during simulation</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_keepsimu">keepSimu</code></td>
<td>
<p>Boolean, default to FALSE. If TRUE, the simulated local scores are returned as the localScores element of the output list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful that the parameters names of the function FUN should differ from those of monteCarlo function.<br />
The density plot produced by <code>plot == TRUE</code> depends on the type of the simulated local scores: 
if they are integer, a barplot of relative frequency is used, else <code>plot(density(...))</code> is used. <br />
This function calls <code><a href="#topic+localScoreC">localScoreC</a></code> which type of the output depends on the type of the input. 
To be efficient, be aware to use a simulating function <code>FUN</code> that return a vector of adequate type (&quot;integer&quot; or &quot;numeric&quot;). Warning: in R, <code>typeof(c(1,3,4,10)) == "double"</code>. You can set a type of a vector with <code>mode()</code> or <code>as.integer()</code> functions for example. <br /> 
<code>monteCarlo_double()</code> is deprecated. At this point, it is just a call to <code>monteCarlo()</code> function.
</p>


<h3>Value</h3>

<p>If <code>keepSimu</code> is FALSE, returns a numeric value corresponding to the probability to obtain a local score with value greater or equal to the parameter <code>local_score</code>. <br />
If <code>keepSimu</code> is TRUE, returns a list containing:</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>p_value</code> </td><td style="text-align: left;"> Floating value corresponding to the probability to obtain a local score with a value greater or equal to the parameter <code>local_score</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>localScores</code> </td><td style="text-align: left;"> Vector of size <code>numSim</code> containing the simulated local scores
</td>
</tr>

</table>



<h3>Functions</h3>


<ul>
<li> <p><code>monteCarlo_double()</code>: Monte-Carlo function for double [deprecated]
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code> <code><a href="#topic+localScoreC">localScoreC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
monteCarlo(120, FUN = rbinom, n = 100, size = 5, prob=0.2)


mySeq &lt;- sample(-7:3, replace = TRUE, size = 1000)
monteCarlo(local_score = 18, FUN = function(x) {return(sample(x = x, 
           size = length(x), replace = TRUE))}, x = mySeq)


#Examples of non integer score function
mySeq2 &lt;- sample(-7:6 - 0.5, replace = TRUE, size = 1000)
monteCarlo(local_score = 50.5, FUN = function(x) {return(sample(x = x, 
           size = length(x), replace = TRUE))}, x = mySeq2)


#Examinating simulated local scores
mySeq2 &lt;- sample(-7:6, replace = TRUE, size = 1000)
simu &lt;- monteCarlo(local_score = 50.5, FUN = function(x) {return(sample(x = x, 
           size = length(x), replace = TRUE))}, x = mySeq2, keepSimu = TRUE)
hist(simu$localScores)


# Markovian example
MyTransMat &lt;-
    matrix(c(0.3,0.1,0.1,0.1,0.4, 0.2,0.2,0.1,0.2,0.3, 0.3,0.4,0.1,0.1,0.1, 0.3,0.3,0.1,0.0,0.3,
             0.1,0.1,0.2,0.3,0.3), ncol = 5, byrow=TRUE)
monteCarlo(local_score = 50,
          FUN = transmatrix2sequence, matrix = MyTransMat,
          length=150, score = c(-2,-1,0,2,3), plot=FALSE, numSim = 5000)

</code></pre>

<hr>
<h2 id='proba_theoretical_first_excursion_iid'>Probability <code class="reqn">P(Q(1)\geq a)</code> that the height of the first excursion is greater or equal to <code>a</code> given a i.i.d. model on the letters sequence</h2><span id='topic+proba_theoretical_first_excursion_iid'></span>

<h3>Description</h3>

<p>Mathematical definition of an excursion of the Lindley process is based on the record times of the partial
sum sequence associated to the score sequence (see Karlin and Altschul 1990, Karlin and Dembo 1992) and
define the successive times where the partial sums are strictly decreasing. There must be distinguished
from the visual excursions of the Lindley sequence. The number <code>i</code> is the number of excursion in sequential order. Detailed definitions are given in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proba_theoretical_first_excursion_iid(
  a,
  theta,
  theta_distribution,
  score_function
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proba_theoretical_first_excursion_iid_+3A_a">a</code></td>
<td>
<p>score strictly positive</p>
</td></tr>
<tr><td><code id="proba_theoretical_first_excursion_iid_+3A_theta">theta</code></td>
<td>
<p>vector containing the alphabet used</p>
</td></tr>
<tr><td><code id="proba_theoretical_first_excursion_iid_+3A_theta_distribution">theta_distribution</code></td>
<td>
<p>distribution vector of theta</p>
</td></tr>
<tr><td><code id="proba_theoretical_first_excursion_iid_+3A_score_function">score_function</code></td>
<td>
<p>vector containing the scores of each letters of the alphabet (must be in the same order as theta)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beware that a sequence beginning with a negative score gives a &quot;flat&quot; excursion, with score 0 are considered.
</p>


<h3>Value</h3>

<p>theoretical probability of reaching a score of a on the first excursion supposing an  i.i.d model on the letters sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proba_theoretical_first_excursion_iid(3, c("a","b","c","d"), 
                                      c(a=0.1,b=0.2,c=0.4,d=0.3), c(a=-3,b=-1,c=1,d=2))
</code></pre>

<hr>
<h2 id='proba_theoretical_ith_excursion_iid'>Probability <code class="reqn">P(Q(i)\geq a)</code> that the height of the ith excursion (sequential order) is greater or equal to <code>a</code> given a i.i.d. model on the letters sequence</h2><span id='topic+proba_theoretical_ith_excursion_iid'></span>

<h3>Description</h3>

<p>Mathematical definition of an excursion of the Lindley process is based on the record times of the partial
sum sequence associated to the score sequence (see Karlin and Altschul 1990, Karlin and Dembo 1992) and
define the successive times where the partial sums are strictly decreasing. There must be distinguished
from the visual excursions of the Lindley sequence. The number <code>i</code> is the number of excursion in sequential order. Detailed definitions are given in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proba_theoretical_ith_excursion_iid(
  a,
  theta,
  theta_distribution,
  score_function,
  i = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proba_theoretical_ith_excursion_iid_+3A_a">a</code></td>
<td>
<p>score strictly positive</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_iid_+3A_theta">theta</code></td>
<td>
<p>vector containing the alphabet used</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_iid_+3A_theta_distribution">theta_distribution</code></td>
<td>
<p>distribution vector of theta</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_iid_+3A_score_function">score_function</code></td>
<td>
<p>vector containing the scores of each letters of the alphabet (must be in the same order as theta)</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_iid_+3A_i">i</code></td>
<td>
<p>Number of excursion in sequential order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the i.i.d., the distribution of the ith excursion is the same as the first excursion. This function is just for convenience, and the result is the same as <code>proba_theoretical_first_excursion_iid</code>. Beware that a sequence beginning with a negative score gives a &quot;flat&quot; excursion, with score 0 are considered.
</p>


<h3>Value</h3>

<p>theoretical probability of reaching a score of a on the ith excursion supposing an  i.i.d model on the letters sequence
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proba_theoretical_first_excursion_iid">proba_theoretical_first_excursion_iid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- proba_theoretical_ith_excursion_iid(3, c("a","b","c","d"), 
                                      c(a=0.1,b=0.2,c=0.4,d=0.3), c(a=-3,b=-1,c=1,d=2), i = 10)
p2 &lt;- proba_theoretical_first_excursion_iid(3, c("a","b","c","d"), 
                                      c(a=0.1,b=0.2,c=0.4,d=0.3), c(a=-3,b=-1,c=1,d=2))
p1 == p2  #TRUE
</code></pre>

<hr>
<h2 id='proba_theoretical_ith_excursion_markov'>theoretical probability of reaching the threshold score a on the i-th excursion (sequential order) of a markov's score sequence</h2><span id='topic+proba_theoretical_ith_excursion_markov'></span>

<h3>Description</h3>

<p>This function implements the results of the paper: &quot;Exact distribution of excursion heights of the Lindley process in a Markovian model&quot;, this is an
exact method. 
Scores of score function have to be integers, the expectancy of the score have to be negative, the score function have to contains at least
one positive integer, i have to be &gt;0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proba_theoretical_ith_excursion_markov(
  a,
  theta,
  lambda,
  score_function,
  i,
  prob0 = NULL,
  epsilon = 1e-16
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_a">a</code></td>
<td>
<p>threshold score</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_theta">theta</code></td>
<td>
<p>vector containing the alphabet used</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_lambda">lambda</code></td>
<td>
<p>transition probability matrix of the markov chain, square, same size and order as theta</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_score_function">score_function</code></td>
<td>
<p>vector containing the scores of each letters of the alphabet (must be in the same order as theta)</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_i">i</code></td>
<td>
<p>number of wanted excursion (sequential order)</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_prob0">prob0</code></td>
<td>
<p>probability distribution of the first letter of the sequence (stationary distribution of lambda if the parameter is NULL),
used only for computation of proba_q_i_geq_a</p>
</td></tr>
<tr><td><code id="proba_theoretical_ith_excursion_markov_+3A_epsilon">epsilon</code></td>
<td>
<p>threshold for the computation of matrix M: to calculate the probabilities, this function need to compute the matrix M (transition probability matrix of the beginning of excursions, as in the paper)
with a recurrence, this recurrence stop at a certain number of iterations or when the maximal absolute value of the difference between an iteration and the next one is &lt; epsilon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful: the computational time is exponential in function of the maximum score of the score function.
The computational time also increase with the rise of the threshold score a and with the lowering of the minimum of the score function and have a cubic complexity in function of the size of theta.
Lowering epsilon can also decrease the execution time of the function but it can have an impact on the accuracy of the probabilities.
</p>


<h3>Value</h3>

<p>a list containing:</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>proba_q_i_geq_a</code> </td><td style="text-align: left;"> reel number between 0 and 1 representing the theoretical probability that the i-th excursion is greater or equal a </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>P_alpha</code> </td><td style="text-align: left;"> vector containing the probabilities (of reaching the threshold score on the i-th excursion) depending on the first letter of the sequence (alpha) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>## In this example: the probability to reach a score of a in the third excursion is: 0.04237269
## The conditional probabilities to reach a score of a in the third excursion if the first
## letter of the sequence is K, L or M are respectively: 0.04239004, 0.04247805 and 0.04222251
proba_theoretical_ith_excursion_markov(a = 5,
               theta = c("K","L","M"),
               lambda = matrix(c(0.5, 0.3, 0.2,
                                 0.4, 0.2, 0.4,
                                 0.4, 0.4, 0.2), 
                               ncol = 3, byrow = TRUE),
               score_function = c(-2,-1,2),
               i = 3,
               prob0 = c(0.4444444, 0.2962963, 0.2592593))
### This example implements the numerical application of the paper,
###    the global probability is 0.2095639
proba_theoretical_ith_excursion_markov(a = 6,
            theta = c("a","b","c","d","e"),
            lambda = matrix(c(0.1, 0.7, 0.05, 0.05, 0.1,
                              0.3, 0.3, 0.2, 0.15, 0.05,
                              0.1, 0.4, 0.15, 0.2, 0.15,
                              0.5, 0.05, 0.25, 0.1, 0.1,
                              0.25, 0.05, 0.5, 0.15, 0.05),
                              ncol = 5,nrow=5, byrow = TRUE),
            score_function = c(-3,-2,-1,6,7),
            i = 3)
</code></pre>

<hr>
<h2 id='RealScores2IntegerScores'>Convert a real scores vector into an integer scores vector</h2><span id='topic+RealScores2IntegerScores'></span>

<h3>Description</h3>

<p>Convert real scores into integer scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RealScores2IntegerScores(RealScore, ProbRealScore, coef = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RealScores2IntegerScores_+3A_realscore">RealScore</code></td>
<td>
<p>vector of real scores</p>
</td></tr>
<tr><td><code id="RealScores2IntegerScores_+3A_probrealscore">ProbRealScore</code></td>
<td>
<p>vector of probability</p>
</td></tr>
<tr><td><code id="RealScores2IntegerScores_+3A_coef">coef</code></td>
<td>
<p>coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert real scores into integer scores by multiplying real
scores by a coefficient (default 10) and then assigning probability to corresponding
extended (from the minimum to the maximum) integer scores
</p>


<h3>Value</h3>

<p>list containing ExtendedIntegerScore and ProbExtendedIntegerScore
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score &lt;- c(-1,-0.5,0,0.5,1)
prob.score &lt;- c(0.2,0,0.4,0.1,0.3)
(res1 &lt;- RealScores2IntegerScores(score, prob.score, coef=10))
prob.score.err &lt;- c(0.1,0,0.4,0.1,0.3)
(res2 &lt;- RealScores2IntegerScores(score, prob.score.err, coef=10))
# When coef=1, the function can handle integer scores
ex.integer.score &lt;- c(-3,-1,0,1, 5)
(res3 &lt;- RealScores2IntegerScores(ex.integer.score, prob.score, coef=1))
</code></pre>

<hr>
<h2 id='recordTimes'>Calculate the record times of a sequence</h2><span id='topic+recordTimes'></span>

<h3>Description</h3>

<p>For a given sequence of real numbers, this function returns the
index of the values where Lindley/CUSUM process are &lt;0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recordTimes(sequence)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recordTimes_+3A_sequence">sequence</code></td>
<td>
<p>numeric sequence of a Lindley process, eg service time per
customer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the first record times which is always 0 is not included
in the returned vector
</p>


<h3>Value</h3>

<p>a vector with the record times. If no record time are found, return
empty vector <code>integer(0)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####This example should return this vector: c(1,3,4,5,10)
seq1 &lt;- c(-1,2,-2.00001,-4,-1,3,-1,-2,3,-4,2)
recordTimes(seq1)
####This example should return integer(0) because there is no record times in this sequence
seq2 &lt;- c(4,1,0,-1,-2,5,-5,0,4)
recordTimes(seq2)
</code></pre>

<hr>
<h2 id='scoreSequences2probabilityVector'>Empirical distribution from sequences</h2><span id='topic+scoreSequences2probabilityVector'></span>

<h3>Description</h3>

<p>Builds empirical distribution from a list of numerical sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreSequences2probabilityVector(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreSequences2probabilityVector_+3A_sequences">sequences</code></td>
<td>
<p>list of numerical sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By determining the extreme scores in the sequences, this function creates a vector of probabilities
including values that do not occur at all. In this it differs from table(). For example, two sequences containing
values from 1:2 and 5:6 will produce a vector of size 6.
</p>


<h3>Value</h3>

<p>empirical distribution from minimum score to maximum score as a vector of floating numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq1 = sample(7:8, size = 10, replace = TRUE)
seq2 = sample(2:3, size = 15, replace = TRUE)
l = list(seq1, seq2)
scoreSequences2probabilityVector(l)
</code></pre>

<hr>
<h2 id='Seq1093'>Long protein sequence</h2><span id='topic+Seq1093'></span>

<h3>Description</h3>

<p>A long protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Seq1093)
</code></pre>


<h3>Format</h3>

<p>A character string with 1093 characters corresponding to Q60519.fasta in UniProt Data base.
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq1093)
Seq1093
nchar(Seq1093)
data(HydroScore)
seqScore &lt;- CharSequence2ScoreSequence(Seq1093,HydroScore)
seqScore[1:50]
localScoreC(seqScore)$localScore
LS &lt;- localScoreC(seqScore)$localScore[1]
prob1 &lt;- scoreSequences2probabilityVector(list(seqScore))
daudin(local_score = LS, sequence_length = nchar(Seq1093),
       score_probabilities = prob1,
       sequence_min = min(seqScore),
       sequence_max = max(seqScore))
karlin(local_score = LS, sequence_length = nchar(Seq1093),
       score_probabilities = prob1,
       sequence_min = min(seqScore),
       sequence_max = max(seqScore))
</code></pre>

<hr>
<h2 id='Seq219'>Protein sequence</h2><span id='topic+Seq219'></span>

<h3>Description</h3>

<p>A protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Seq219)
</code></pre>


<h3>Format</h3>

<p>A character string with 219 characters corresponding to P49755.fasta query in UniProt Data base.
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq219)
Seq219
nchar(Seq219)
data(HydroScore)
seqScore=CharSequence2ScoreSequence(Seq219,HydroScore)
seqScore[1:30]
localScoreC(seqScore)$localScore
prob1 &lt;- scoreSequences2probabilityVector(list(seqScore))
daudin(local_score = 52, sequence_length = nchar(Seq219),
               score_probabilities = prob1,
               sequence_min = min(seqScore),
               sequence_max = max(seqScore))
score &lt;- -5:5
prob2 &lt;- c(0.15,0.15,0.1,0.1,0.0,0.05,0.15,0.05,0.2,0.0,0.05)
daudin(local_score = 52, sequence_length = nchar(Seq219),
       score_probabilities = prob2,
       sequence_min = min(seqScore),
       sequence_max = max(seqScore))
</code></pre>

<hr>
<h2 id='Seq31'>Short protein sequence</h2><span id='topic+Seq31'></span>

<h3>Description</h3>

<p>A short protein sequence of 31 amino acids corresponding to Q09FU3.fasta query in UniProt Data base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Seq31)
</code></pre>


<h3>Format</h3>

<p>A character string with 31 characters &quot;MLTITSYFGFLLAALTITSVLFIGLNKIRLI&quot;
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq31)
Seq31
nchar(Seq31)
data(HydroScore) 
SeqScore &lt;- CharSequence2ScoreSequence(Seq31,HydroScore)
SeqScore
localScoreC(SeqScore)$localScore
LS &lt;- localScoreC(SeqScore)$localScore[1]
prob1 &lt;- scoreSequences2probabilityVector(list(SeqScore))
daudin(local_score = LS, sequence_length = nchar(Seq31),
               score_probabilities = prob1,
               sequence_min = min(SeqScore),
               sequence_max = max(SeqScore))
score &lt;- -5:5
prob2 &lt;- c(0.15,0.15,0.1,0.1,0.0,0.05,0.15,0.05,0.2,0.0,0.05)
sum(prob2*score)
karlin(local_score = LS, sequence_length = nchar(Seq31),
       score_probabilities = prob2,
       sequence_min = min(SeqScore),
       sequence_max = max(SeqScore))
</code></pre>

<hr>
<h2 id='SeqListSCOPe'>Several sequences</h2><span id='topic+SeqListSCOPe'></span>

<h3>Description</h3>

<p>A vector of character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SeqListSCOPe)
</code></pre>


<h3>Format</h3>

<p>A list of 285 character strings with their entry codes as names
</p>


<h3>Source</h3>

<p>Structural Classification Of Proteins database (SCOP). More precisely this data contain the 285 protein sequences of the data called &quot;CF_scop2dom_20140205aa&quot; with length from 31 to 404.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SeqListSCOPe)
head(SeqListSCOPe)
SeqListSCOPe[1]
nchar(SeqListSCOPe[1])
summary(sapply(SeqListSCOPe, nchar))
data(HydroScore)
MySeqScoreList &lt;- lapply(SeqListSCOPe, FUN=CharSequence2ScoreSequence, HydroScore)
head(MySeqScoreList)
AA &lt;- automatic_analysis(sequences=MySeqScoreList, model='iid')
AA[[1]]
# the p-value of the first 10 sequences 
sapply(AA, function(x){x$`p-value`})[1:10]
# the 20th smallest p-values
sort(sapply(AA, function(x){x$`p-value`}))[1:20]
which(sapply(AA, function(x){x$`p-value`})&lt;0.05)
table(sapply(AA, function(x){x$`method`}))
# The maximum sequence length equals 404 so it here normal that the exact method is used for
# all the 606 sequences of the data base 
# Score distribution learned on the data set
scoreSequences2probabilityVector(MySeqScoreList)
</code></pre>

<hr>
<h2 id='sequences2transmatrix'>Transition matrix from sequence(s)</h2><span id='topic+sequences2transmatrix'></span>

<h3>Description</h3>

<p>Calculates the transition matrix by counting occurrences of tuples in given vector list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequences2transmatrix(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequences2transmatrix_+3A_sequences">sequences</code></td>
<td>
<p>Sequences to be analyzed, can be a list of vectors, or a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In output, score_value is coerced as integer if possible. Else, it is a character vector containing the states
of the Markov chain.
</p>


<h3>Value</h3>

<p>A list object containing
</p>
<table role = "presentation">
<tr><td><code>transition_matrix</code></td>
<td>
<p>Transition Matrix with row names and column names are the associated score/state</p>
</td></tr>
<tr><td><code>score_value</code></td>
<td>
<p>a vector containing the score/state, ordered in the same way as the matrix columns and rows</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myseq &lt;- sample(LETTERS[1:2], size=20,replace=TRUE)
sequences2transmatrix(myseq)
</code></pre>

<hr>
<h2 id='SJSyndrome'>Stevens-Johnson syndrome data</h2><span id='topic+SJSyndrome'></span>

<h3>Description</h3>

<p>The Stevens-Johnson syndrome is an acute and serious dermatological disease due to a drug allergy. 
The syndrome appearance is life-threatening emergency. They are very rare, around 2 cases per million people per year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SJSyndrome.data)
</code></pre>


<h3>Format</h3>

<p>A data.frame of 824 lines, each describing a syndrome appearance described by 15 covariates:
Case ID,
Initial FDA Received Date,
days since last fda,
Event Date,
Latest FDA Received Date,
Suspect Product Names,
Suspect Product Active Ingredients,
Reason for Use,
Reactions,
Serious,
Outcomes,
Sex,
Patient Age,
Sender,
Concomitant Product Names
The third column correspond to the number of days between two adverse events.
</p>


<h3>Source</h3>

<p>FDA open data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SJSyndrome)
summary(SJSyndrome)

</code></pre>

<hr>
<h2 id='stationary_distribution'>Stationary distribution [Markov chains]</h2><span id='topic+stationary_distribution'></span>

<h3>Description</h3>

<p>Calculates stationary distribution of markov transition matrix by use of eigenvectors of length 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_distribution(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_distribution_+3A_m">m</code></td>
<td>
<p>Transition Matrix [matrix object]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = t(matrix (c(0.2, 0.8, 0.4, 0.6), nrow = 2))
stationary_distribution(B)
</code></pre>

<hr>
<h2 id='transmatrix2sequence'>Sampling function for Markov chains</h2><span id='topic+transmatrix2sequence'></span>

<h3>Description</h3>

<p>Creates Markov chains based on a transition matrix. Can be used as parameter for the Monte Carlo function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmatrix2sequence(matrix, length, initialIndex, score)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transmatrix2sequence_+3A_matrix">matrix</code></td>
<td>
<p>transition matrix of Markov process</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_length">length</code></td>
<td>
<p>length of sequence to be sampled</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_initialindex">initialIndex</code></td>
<td>
<p>(optional) index of matrix which should be initial value of sequence. If none supplied, a value from the stationary distribution is sampled as initial value.</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_score">score</code></td>
<td>
<p>(optional) a vector representing the scores (in ascending order) of the matrix index. If supplied, the result will be a vector of these values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition matrix is considered representing the transition from one score to another such that the score in the first row is the lowest 
and the last row are the transitions from the highest score to another. The matrix must be stochastic (no rows filled up with only '0' values).
</p>
<p>It is possible to have the same score for different states of the markov chain. 
If no score supplied, the function returns a markov chain with state in 1:ncol(matrix)
</p>


<h3>Value</h3>

<p>a Markov chain sampled from the transition matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;-  matrix (c(0.2, 0.8, 0.4, 0.6), nrow = 2, byrow = TRUE)
transmatrix2sequence(B, length = 10)
transmatrix2sequence(B, length = 10, score = c(-2,1))
transmatrix2sequence(B, length = 10, score = c("A","B"))
MyTransMat &lt;-
   matrix(c(0.3,0.1,0.1,0.1,0.4,
            0.2,0.2,0.1,0.2,0.3,
            0.3,0.4,0.1,0.1,0.1,
            0.3,0.3,0.1,0.0,0.3,
            0.1,0.1,0.2,0.3,0.3),
            ncol = 5, byrow=TRUE)
MySeq.CM &lt;- transmatrix2sequence(matrix = MyTransMat,length=90, score =c(-2,-1,0,2,3))
MySeq.CM
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
