<!DOCTYPE html><html><head><title>Help for package localScore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {localScore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Aeso'><p>Congenital oesophageal atresia data</p></a></li>
<li><a href='#aeso.data'><p>Deprecated. Use 'Aeso' instead.</p></a></li>
<li><a href='#automatic_analysis'><p>Automatic analysis</p></a></li>
<li><a href='#CharSequence2ScoreSequence'><p>Convert a character sequence into a score sequence</p></a></li>
<li><a href='#CharSequences2ScoreSequences'><p>Convert several character sequences into score sequences</p></a></li>
<li><a href='#daudin'><p>Daudin [p-value] [iid]</p></a></li>
<li><a href='#dico'><p>Deprecated. Use 'HydroScore' instead.</p></a></li>
<li><a href='#exact_mc'><p>Exact method for p-value [Markov chains]</p></a></li>
<li><a href='#HydroScore'><p>Dictionnaire</p></a></li>
<li><a href='#karlin'><p>Karlin [p-value] [iid]</p></a></li>
<li><a href='#karlinMonteCarlo'><p>Monte Carlo - Karlin [p-value]</p></a></li>
<li><a href='#karlinMonteCarlo_double'><p>Monte Carlo - Karlin for real scores[p-value]</p></a></li>
<li><a href='#lindley'><p>Lindley process</p></a></li>
<li><a href='#loadMatrixFromFile'><p>Loads matrix from csv-File</p></a></li>
<li><a href='#loadScoreFromFile'><p>Load score from file</p></a></li>
<li><a href='#localScore-package'>
<p>Package for sequence analysis by local score</p></a></li>
<li><a href='#localScoreC'><p>Local score</p></a></li>
<li><a href='#localScoreC_double'><p>Local score for sequences of floating values</p></a></li>
<li><a href='#LongSeq'><p>Deprecated. Use 'Seq1093' instead.</p></a></li>
<li><a href='#maxPartialSumd'><p>Maximum of the partial sum [probability] [iid]</p></a></li>
<li><a href='#mcc'><p>MCC [p-value] [iid]</p></a></li>
<li><a href='#MidSeq'><p>Deprecated. Use 'Seq219' instead.</p></a></li>
<li><a href='#monteCarlo'><p>Monte Carlo method [p-value]</p></a></li>
<li><a href='#monteCarlo_double'><p>Monte Carlo method for real score case [p-value]</p></a></li>
<li><a href='#MySeqList'><p>Deprecated. Use 'SeqListSCOPe' instead.</p></a></li>
<li><a href='#RealScores2IntegerScores'><p>Convert a real scores vector into an integer scores vector</p></a></li>
<li><a href='#scoreDictionnary2probabilityVector'><p>Check for missing scores values in the score distribution</p></a></li>
<li><a href='#scoreSequences2probabilityVector'><p>Empirical distribution from sequences</p></a></li>
<li><a href='#Seq1093'><p>Long protein sequence</p></a></li>
<li><a href='#Seq219'><p>Protein sequence</p></a></li>
<li><a href='#Seq31'><p>Short protein sequence</p></a></li>
<li><a href='#SeqListSCOPe'><p>Several sequences</p></a></li>
<li><a href='#sequences2transmatrix'><p>Transition matrix from sequence(s)</p></a></li>
<li><a href='#ShortSeq'><p>Deprecated. Use 'Seq31' instead.</p></a></li>
<li><a href='#SJSyndrome.data'><p>Stevens-Johnson syndrome data</p></a></li>
<li><a href='#stationary_distribution'><p>Stationary distribution [Markov chains]</p></a></li>
<li><a href='#transmatrix2sequence'><p>Sampling function for Markov chains</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Package for Sequence Analysis by Local Score</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-02</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS for various embedded Eigen library
copyright details</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Robelin &lt;david.robelin@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionalities for calculating the local score and calculating statistical relevance (p-value) to find a local Score in a sequence of given distribution (S. Mercier and J.-J. Daudin (2001) <a href="https://hal.science/hal-00714174/">https://hal.science/hal-00714174/</a>) ; S. Karlin and S. Altschul (1990) <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC53667/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC53667/</a>  ; S. Mercier, D. Cellier and F. Charlot (2003) <a href="https://hal.science/hal-00937529v1/">https://hal.science/hal-00937529v1/</a> ; A. Lagnoux, S. Mercier and P. Valois (2017) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtw699">doi:10.1093/bioinformatics/btw699</a>&gt; ).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.16), utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 15:18:06 UTC; drobelin</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Simon [aut],
  David Robelin [aut, cre],
  Sabine Mercier [aut],
  Sebastien Dejean [aut],
  The authors of Eigen the library for the included version of Eigen
    [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 22:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='Aeso'>Congenital oesophageal atresia data</h2><span id='topic+Aeso'></span>

<h3>Description</h3>

<p>The data consists of individual dates of birth over n=35 cases of the birth defects oesophageal and tracheo-oesophagean fistula
observed in a hospital in Birmingham, U.K., over 2191 days from 1950 through 1955, with Day one set as 1 January 1950
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aeso
</code></pre>


<h3>Format</h3>

<p>A matrix of 2191 lines and 2 columns. Each line is a day on the first column, and associated to a case (0/1) on the second column.
</p>


<h3>Source</h3>

<p>Dolk H. Secular pattern of congenital oesophageal atresia&ndash;George Knox, 1959. J Epidemiol Community Health. 1997;51(2):114-115. &lt;doi:10.1136/jech.51.2.114&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Aeso)
head(Aeso)
p &lt;- sum(Aeso[,2]) / dim(Aeso)[1]
print(p)
</code></pre>

<hr>
<h2 id='aeso.data'>Deprecated. Use 'Aeso' instead.</h2><span id='topic+aeso.data'></span>

<h3>Description</h3>

<p>Deprecated. Use 'Aeso' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeso.data
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'Aeso' instead.
</p>

<hr>
<h2 id='automatic_analysis'>Automatic analysis</h2><span id='topic+automatic_analysis'></span>

<h3>Description</h3>

<p>Calculates local score and p-value for sequence(s) with integer scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>automatic_analysis(
  sequences,
  model,
  scores,
  transition_matrix,
  distribution,
  method_limit = 2000,
  score_extremes,
  modelFunc,
  simulated_sequence_length = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="automatic_analysis_+3A_sequences">sequences</code></td>
<td>
<p>sequences to be analysed (named list)</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_model">model</code></td>
<td>
<p>the underlying model of the sequence (either &quot;iid&quot; for identically independently distributed variable or &quot;markov&quot; for Markov chains)</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_scores">scores</code></td>
<td>
<p>vector of minimum and maximum score range</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>if the sequences are markov chains, this is their transition matrix</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_distribution">distribution</code></td>
<td>
<p>vector of probabilities in ascending score order (iid sequences). Note that names of the vector must be the associated scores.</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_method_limit">method_limit</code></td>
<td>
<p>limit length from which on computation-intensive exact calculation methods for p-value are replaced by approximative methods</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_score_extremes">score_extremes</code></td>
<td>
<p>a vector with two elements: minimal score value, maximal score value</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_modelfunc">modelFunc</code></td>
<td>
<p>function to create similar sequences. In this case, Monte Carlo is used to calculate p-value</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_simulated_sequence_length">simulated_sequence_length</code></td>
<td>
<p>if a modelFunc is provided and the sequence happens to be longer than method_limit, the method karlinMonteCarlo
is used. This method requires the length of the sequences that will be created by the modelFunc for estimation of Gumble parameters.</p>
</td></tr>
<tr><td><code id="automatic_analysis_+3A_...">...</code></td>
<td>
<p>parameters for modelFunc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method picks the adequate p-value method for your input.<br /> 
If no sequences are passed to this function, it will let you pick a FASTA file.<br /> 
If this is the case, and if you haven't provided any score system 
(as you can do by passing a named list with the appropriate scores for each character),
the second file dialog which will pop up is for choosing a file containing the score 
(and if you provide an extra column for the probabilities, they will be used, too - see
section File Formats in the vignette for details).<br /> 
The function then either uses empirical distribution based on your input - or if you provided
a distribution, then yours - to calculate the p-value based on the length of each of the sequences
given as input. <br /> 
You can influence the choice of the method by providing the modelFunc argument. In this case, the
function uses exclusively simulation methods (monteCarlo, karlinMonteCarlo).  <br /> 
By setting the method_limit you can further decide to which extent computation-intensive methods (daudin, exact_mc)
should be used to calculate the p-value.
Remark that the warnings of the localScoreC() function have be deleted when called by automatic_analysis() function
</p>


<h3>Value</h3>

<p>A list object containing
</p>
<table>
<tr><td><code>Local score</code></td>
<td>
<p>local score...</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>
<p>p-value ...</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>the method used for the calculus of the p-value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal example
l = list()
seq1 = sample(-2:1, size = 3000, replace = TRUE)
seq2 = sample(-3:1, size = 150, replace = TRUE)
l[["hello"]] = seq1
l[["world"]] = seq2
automatic_analysis(l, "iid")
# Example with a given distribution 
automatic_analysis(l,"iid",scores=c(-3,1),distribution=c(0.3,0.3,0.1,0.1,0.2))
# forcing the exact method for the longest sequence
aa1=automatic_analysis(l,"iid")
aa1$hello$`method applied`
aa1$hello$`p-value`
aa2=automatic_analysis(l,"iid",method_limit=3000)
aa2$hello$`method applied`
aa2$hello$`p-value`
# Markovian example 
MyTransMat &lt;-
matrix(c(0.3,0.1,0.1,0.1,0.4, 0.3,0.2,0.2,0.2,0.1, 0.3,0.4,0.1,0.1,0.1, 0.3,0.3,0.3,0.0,0.1, 
        0.1,0.3,0.2,0.3,0.1), ncol = 5, byrow=TRUE)
MySeq.CM=transmatrix2sequence(matrix = MyTransMat,length=150, score =-2:2)
MySeq.CM2=transmatrix2sequence(matrix = MyTransMat,length=110, score =-2:2)
automatic_analysis(sequences = list("x1" = MySeq.CM, "x2" = MySeq.CM2), model = "markov")
</code></pre>

<hr>
<h2 id='CharSequence2ScoreSequence'>Convert a character sequence into a score sequence</h2><span id='topic+CharSequence2ScoreSequence'></span>

<h3>Description</h3>

<p>Convert a character sequence into a score sequence. See CharSequences2ScoreSequences() fonction for several sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharSequence2ScoreSequence(sequence, dictionary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CharSequence2ScoreSequence_+3A_sequence">sequence</code></td>
<td>
<p>a character sequence</p>
</td></tr>
<tr><td><code id="CharSequence2ScoreSequence_+3A_dictionary">dictionary</code></td>
<td>
<p>a dictionary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of a score sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ShortSeq)
ShortSeq
data(dico)
CharSequence2ScoreSequence(ShortSeq,dico)
</code></pre>

<hr>
<h2 id='CharSequences2ScoreSequences'>Convert several character sequences into score sequences</h2><span id='topic+CharSequences2ScoreSequences'></span>

<h3>Description</h3>

<p>Convert several character sequence into score sequences. For only one sequence see CharSequence2ScoreSequence() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharSequences2ScoreSequences(sequences, dictionary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CharSequences2ScoreSequences_+3A_sequences">sequences</code></td>
<td>
<p>a list of character sequences</p>
</td></tr>
<tr><td><code id="CharSequences2ScoreSequences_+3A_dictionary">dictionary</code></td>
<td>
<p>a dictionary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of score sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ShortSeq)
ShortSeq
data(MidSeq)
MidSeq
data(dico)
MySequences=list("A1"=ShortSeq,"A2"=MidSeq)
CharSequences2ScoreSequences(MySequences,dico)
</code></pre>

<hr>
<h2 id='daudin'>Daudin [p-value] [iid]</h2><span id='topic+daudin'></span>

<h3>Description</h3>

<p>Calculates the exact p-value in the identically and independantly distributed of a given local score, a sequence length that 'must not be too large' and for a given score distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daudin(
  localScore,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daudin_+3A_localscore">localScore</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code id="daudin_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each score from lowest to greatest</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="daudin_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small in this context depends heavily on your machine. On a 3,7GHZ machine this means for daudin(1000, 5000, c(0.2, 0.2, 0.2, 0.1, 0.2, 0.1), -2, 3)
an execution time of ~2 seconds. This is due to the calculation method using matrix exponentation which becomes very fast very slow. The size of the matrix of the exponentiation is equal to a+1 with a the local score value. The matrix must be put at the power n, with n the sequence length.
Moreover, it is known that the local score value is expected to be in mean of order log(n).
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daudin(localScore = 4, sequence_length = 50, 
score_probabilities = c(0.2, 0.3, 0.1, 0.2, 0.1, 0.1), sequence_min = -3, sequence_max = 2)
</code></pre>

<hr>
<h2 id='dico'>Deprecated. Use 'HydroScore' instead.</h2><span id='topic+dico'></span>

<h3>Description</h3>

<p>Deprecated. Use 'HydroScore' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dico
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'HydroScore' instead.
</p>

<hr>
<h2 id='exact_mc'>Exact method for p-value [Markov chains]</h2><span id='topic+exact_mc'></span>

<h3>Description</h3>

<p>Calculates the exact p-value for short numerical Markov chains. Memory usage and time computation can be too large for a high local score value and high score range (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_mc(localScore, m, sequence_length, score_values = NULL, prob0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact_mc_+3A_localscore">localScore</code></td>
<td>
<p>Integer local score for which the p-value should be calculated</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_m">m</code></td>
<td>
<p>Transition matrix [matrix object]. Optionnaly, rownames can be corresponding score values. m should be a transition matrix of an ergodic Markov chain.</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_sequence_length">sequence_length</code></td>
<td>
<p>Length of the sequence</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_score_values">score_values</code></td>
<td>
<p>A integer vector of sequence score values (optional). If not set, the rownames of m are used if they are numeric and set.</p>
</td></tr>
<tr><td><code id="exact_mc_+3A_prob0">prob0</code></td>
<td>
<p>Vector of probability distribution of the first score of the sequence (optional). If not set, the stationnary distribution of m is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computation needs to allocate a square matrix of size localScore^(range(score_values)). This matrix is then exponentiated to sequence_length.
</p>


<h3>Value</h3>

<p>A double representing the probability of a localScore as high as the one given as argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mTransition &lt;- t(matrix(c(0.2, 0.3, 0.5, 0.3, 0.4, 0.3, 0.2, 0.4, 0.4), nrow = 3))
scoreValues &lt;- -1:1
initialProb &lt;- stationary_distribution(mTransition)
exact_mc(localScore = 12, m = mTransition, sequence_length = 100, 
        score_values = scoreValues, prob0 = initialProb)
exact_mc(localScore = 150, m = mTransition, sequence_length = 1000, 
         score_values = scoreValues, prob0 = initialProb)
rownames(mTransition) &lt;- scoreValues
exact_mc(localScore = 12, m = mTransition, sequence_length = 100, prob0 = initialProb)
# Minimal specification
exact_mc(localScore = 12, m = mTransition, sequence_length = 100)
</code></pre>

<hr>
<h2 id='HydroScore'>Dictionnaire</h2><span id='topic+HydroScore'></span>

<h3>Description</h3>

<p>Provides integer scores related to an hydrophobicity level of each amino acid. This score function is inspired by the Kyte and Doolittle (1982) scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HydroScore
</code></pre>


<h3>Format</h3>

<p>A score function for the 20 amino acid
</p>


<h3>Source</h3>

<p>Kyte &amp; Doolittle (1982) J. Mol. Biol. 157, 105-132
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HydroScore)
HydroScore
data(Seq219)
Seq219
seqScore=CharSequence2ScoreSequence(Seq219,HydroScore)
seqScore[1:30]
localScoreC(seqScore)$localScore
</code></pre>

<hr>
<h2 id='karlin'>Karlin [p-value] [iid]</h2><span id='topic+karlin'></span>

<h3>Description</h3>

<p>Calculates an approximated p-value of a given local score value and a long sequence length in the identically and independantly distributed model for the sequence. See also mcc() function for another approximated method in the i.i.d. model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlin(
  localScore,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karlin_+3A_localscore">localScore</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence (at least several hundreds)</p>
</td></tr>
<tr><td><code id="karlin_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="karlin_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method works the better the longer the sequence is. Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistent. In such case, you could try to change your score scheme (in case of discretization)
or use the function <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code> .
</p>


<h3>Value</h3>

<p>A double representing the probability of a localScore as high as the one given as argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>karlin(150, 10000, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -5, 5)
</code></pre>

<hr>
<h2 id='karlinMonteCarlo'>Monte Carlo - Karlin [p-value]</h2><span id='topic+karlinMonteCarlo'></span>

<h3>Description</h3>

<p>Estimates p-value, for integer scores, based on a Monte Carlo estimation of Gumble
parameters from simulations of smaller sequences with same distribution. 
Appropriate for great sequences with length &gt; 10^3, for i.i.d and markovian sequence models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlinMonteCarlo(
  local_score,
  sequence_length,
  simulated_sequence_length,
  FUN,
  ...,
  numSim = 1000,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karlinMonteCarlo_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a segment.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_simulated_sequence_length">simulated_sequence_length</code></td>
<td>
<p>length of simulated sequences produced by FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to create for estimation</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_+3A_plot">plot</code></td>
<td>
<p>boolean value if to display plots for cumulated function and density</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the simulated sequences is an argument specific to the function provided for simulation. Thus, it has to be
provided also in the parameter simulated_sequence_length in the arguments of the &quot;Monte Carlo - Karlin&quot; function. 
It is a crucial detail as it influences precision and computation time of the result. Note that to get an appropriate 
estimation, the given average score must be non-positive.
</p>


<h3>Value</h3>

<p>Floating value corresponding to the probability to obtain a local score with a value greater or equal to the parameter local_score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new = sample(-7:6, replace = TRUE, size = 1000) 
#MonteCarlo taking random sample from the input sequence itself

karlinMonteCarlo(local_score = 66, sequence_length = 1000,  
               FUN = function(x, simulated_sequence_length) {return(sample(x = x, 
               size = simulated_sequence_length, replace = TRUE))}, 
               x=new, simulated_sequence_length = 1000,  numSim = 1000)

               
</code></pre>

<hr>
<h2 id='karlinMonteCarlo_double'>Monte Carlo - Karlin for real scores[p-value]</h2><span id='topic+karlinMonteCarlo_double'></span>

<h3>Description</h3>

<p>Estimates p-value, for integer scores, based on a Monte Carlo estimation of Gumble
parameters from simulations of smaller sequences with same distribution. 
Appropriate for great sequences with length &gt; 10^3, for i.i.d and markovian sequence models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlinMonteCarlo_double(
  local_score,
  sequence_length,
  simulated_sequence_length,
  FUN,
  ...,
  numSim = 1000,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karlinMonteCarlo_double_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a segment.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_simulated_sequence_length">simulated_sequence_length</code></td>
<td>
<p>length of simulated sequences produced by FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to create for estimation</p>
</td></tr>
<tr><td><code id="karlinMonteCarlo_double_+3A_plot">plot</code></td>
<td>
<p>boolean value if to display plots for cumulated function and density</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the simulated sequences is an argument specific to the function provided for simulation. Thus, it has to be
provided also in the parameter simulated_sequence_length in the arguments of the &quot;Monte Carlo - Karlin&quot; function. 
It is a crucial detail as it influences precision and computation time of the result. Note that to get an appropriate 
estimation, the given average score must be non-positive.
</p>


<h3>Value</h3>

<p>Floating value corresponding to the probability to obtain a local score with value greater or equal the parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new = sample(-7:6, replace = TRUE, size = 1000) 
#MonteCarlo taking random sample from the input sequence itself

karlinMonteCarlo_double(local_score = 66, sequence_length = 1000,  
               FUN = function(x, simulated_sequence_length) {return(sample(x = x, 
               size = simulated_sequence_length, replace = TRUE))}, 
               x=new, simulated_sequence_length = 1000,  numSim = 1000)
      
 #Markovian example (longer computation)
 MyTransMat_reels &lt;-  matrix(c(0.3,0.1,0.1,0.1,0.4, 0.2,0.2,0.1,0.2,0.3, 0.3,0.4,0.1,0.1,0.1, 
0.3,0.3,0.1,0.2,0.1, 0.2,0.1,0.2,0.4,0.1),ncol = 5, byrow=TRUE)

karlinMonteCarlo(local_score = 10.5,sequence_length=200,FUN = transmatrix2sequence, 
matrix = MyTransMat_reels, score =c(-1,-0.5,0,0.5,1),length=1500, 
plot=FALSE, numSim = 1500, simulated_sequence_length =1500)

</code></pre>

<hr>
<h2 id='lindley'>Lindley process</h2><span id='topic+lindley'></span>

<h3>Description</h3>

<p>Creates a sequence of a Lindley process, also called CUSUM process, on a given sequence.  For a sequence (X_k)k, the Lindley process is defined as follows: W_0:=0 and W_(k+1)=max(0,W_k+X_(k+1)). It defines positive excursions above 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lindley(sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lindley_+3A_sequence">sequence</code></td>
<td>
<p>numeric sequence of a Lindley process, eg service time per customer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the Lindley process steps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq=c(1,2,3,-4,1,-3,-1,2,3,-4,1)
lindley(seq)
plot(1:length(seq),lindley(seq),type='b')
</code></pre>

<hr>
<h2 id='loadMatrixFromFile'>Loads matrix from csv-File</h2><span id='topic+loadMatrixFromFile'></span>

<h3>Description</h3>

<p>Reads a csv file without header and returns the matrix. For file formats please see section &quot;File Formats&quot; in vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMatrixFromFile(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadMatrixFromFile_+3A_filepath">filepath</code></td>
<td>
<p>optional: Location of file on disk. If not provided, a file picker dialog will be opened.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Matrix Object
</p>

<hr>
<h2 id='loadScoreFromFile'>Load score from file</h2><span id='topic+loadScoreFromFile'></span>

<h3>Description</h3>

<p>Reads a csv file with 2-3 columns and returns it as a list object of vectors, with names corresponding to the first column of the file. For details view section &quot;File Formats&quot; in vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadScoreFromFile(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadScoreFromFile_+3A_filepath">filepath</code></td>
<td>
<p>optional: location of file on disk. If not provided, a file picker dialog will be opened.</p>
</td></tr>
<tr><td><code id="loadScoreFromFile_+3A_...">...</code></td>
<td>
<p>optional: use arguments from read.csv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List Object - Names correspond to the first column, usually Letters. Associated numerical scores are in the second column. If probabilities are provided, 
they will be loaded too and presumed to be in the third column
</p>

<hr>
<h2 id='localScore-package'>
Package for sequence analysis by local score
</h2><span id='topic+localScore-package'></span><span id='topic+localScore'></span>

<h3>Description</h3>

<p>Provides functionalities for: 
</p>

<ul>
<li><p> calculating the local score 
</p>
</li>
<li><p> calculating statistical relevance (p-value) to find a local Score in a sequence of given distribution. 
</p>
</li></ul>



<h3>Details</h3>

<p>Please refer to the vignette of this package or the manual for details on how to use this package.
</p>


<h3>Author(s)</h3>

<p>Sebastian Simon, Sabine Mercier, David Robelin, Anne-Benedicte Urbano
</p>
<p>Maintainer: David Robelin david.robelin@inra.fr
</p>


<h3>References</h3>

<p>p-value:
</p>


<ul>
<li><p> An Improved Approximation For Assessing The Statistical Significance of molecular Sequence Features, Mercier and al 2003  
</p>
</li>
<li><p> Exact distribution for the local score of one i.i.d. random sequence, Sabine Mercier and JJ Daudin, 2001
</p>
</li>
<li><p> Limit Distributions of Maximal Segmental Score among Markov-Dependent Partial Sums, Karlin and Dembo 1992
</p>
</li>
<li><p> Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes, Karlin and al 1990
</p>
</li></ul>

<p>local Score:
</p>

<ul>
<li><p> Detection de courts segments inverses dans les genomes: methodes et applications, David Robelin 2005
</p>
</li>
<li><p> A Linear Time Algorithm for Finding All Maximal Scoring Subsequences, Constable and Bates 1985
</p>
</li></ul>


<hr>
<h2 id='localScoreC'>Local score</h2><span id='topic+localScoreC'></span>

<h3>Description</h3>

<p>Calculates the local score for a sequence of integer scores. Only provides the
first occurrence of the local score. Use function suboptimalSegment() or Lindley() to obtain the others localizations of the different realizations of the local score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localScoreC(v, supressWarnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localScoreC_+3A_v">v</code></td>
<td>
<p>: a sequence of integer values as vector.</p>
</td></tr>
<tr><td><code id="localScoreC_+3A_supresswarnings">supressWarnings</code></td>
<td>
<p>: if warnings should not be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing: the local score value and the begin and end index of the segment realizing this optimal score ; all the local maxima of the Lindley process (non negative excursion) and their begin and ens index ; the record times of the Lindley process but only the ones corresponding to the begin index of non negative excursions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq.OneSegment=c(1,-2,3,1,-1,2)
# one segment realizing the local score value
localScoreC(seq.OneSegment) 
seq.TwoSegments=c(1,-2,3,1,2,-2,-2,-1,1,-2,3,1,2,-1,-2,-2,-1,1)
# two segments realizing the local score value
localScoreC(seq.TwoSegments) 
# only the first realization
localScoreC(seq.TwoSegments)$localScore 
# all the realization of the local together with the suboptimal ones
localScoreC(seq.TwoSegments)$suboptimalSegmentScores 
# for small sequences, you can also use lindley() fonction to check if 
# several segments achieve the local Score
lindley(seq.TwoSegments) 
plot(1:length(seq.TwoSegments),lindley(seq.TwoSegments),type='b')
seq.TwoSegments.InSameExcursion=c(1,-2,3,2,-1,0,1,-2,-2,-4,1)
localScoreC(seq.TwoSegments.InSameExcursion)
# lindley() shows two realizations in the same excursion (no 0 value between the two LS values)
lindley(seq.TwoSegments.InSameExcursion) 
# same beginning index but two possible ending indexes
# only one excursion realizes the local score even in there is two possible length of segment
localScoreC(seq.TwoSegments.InSameExcursion)$suboptimalSegmentScores 
plot(1:length(seq.TwoSegments.InSameExcursion),lindley(seq.TwoSegments.InSameExcursion),type='b')
</code></pre>

<hr>
<h2 id='localScoreC_double'>Local score for sequences of floating values</h2><span id='topic+localScoreC_double'></span>

<h3>Description</h3>

<p>Calculates the local score for a sequence of doubles. Only provides the
first occurrence. Use function suboptimalSegment() or Lindley() to obtain the others localizations of the different realizations of the local score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localScoreC_double(v, supressWarnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localScoreC_double_+3A_v">v</code></td>
<td>
<p>A sequence of values as vector.</p>
</td></tr>
<tr><td><code id="localScoreC_double_+3A_supresswarnings">supressWarnings</code></td>
<td>
<p>if warnings should be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing: the local score value and the begin and end index of the segment realizing this optimal score ; all the local maxima of the Lindley process (non negative excursion) and their begin and ens index ; the record times of the Lindley process but only the ones corresponding to the begin index of non negative excursions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>localScoreC_double(c(1.2,-2.1,3.5,1.7,-1.1,2.3))
seq.TwoSegments=c(1.2,-2.1,3.5,1.7,2,-2,-2,-3.5,1,3.5,1.7,1,-2,-2)
# two segments realizing the local score value
localScoreC(seq.TwoSegments) 
# only the first realization
localScoreC(seq.TwoSegments)$localScore 
# all the realization of the local together with the suboptimal ones
localScoreC(seq.TwoSegments)$suboptimalSegmentScores 
# for small sequences, you can also use lindley() fonction to check if 
# several segments achieve the local score
lindley(seq.TwoSegments) 
plot(1:length(seq.TwoSegments),lindley(seq.TwoSegments),type='b')
seq.TwoSegments.InSameExcursion=c(1,-2,3,2,-1,0,1,-2,-2)
localScoreC(seq.TwoSegments.InSameExcursion)
# lindley() shows two realizations in the same excursion (no 0 value between the two LS values)
lindley(seq.TwoSegments.InSameExcursion) 
plot(1:length(seq.TwoSegments.InSameExcursion),lindley(seq.TwoSegments.InSameExcursion),type='b')
# same beginning index but two possible ending indexes
# only one excursion realizes the local score even in there is two possible length of segment
localScoreC(seq.TwoSegments.InSameExcursion)$suboptimalSegmentScores 
</code></pre>

<hr>
<h2 id='LongSeq'>Deprecated. Use 'Seq1093' instead.</h2><span id='topic+LongSeq'></span>

<h3>Description</h3>

<p>Deprecated. Use 'Seq1093' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LongSeq
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'Seq1093' instead.
</p>

<hr>
<h2 id='maxPartialSumd'>Maximum of the partial sum [probability] [iid]</h2><span id='topic+maxPartialSumd'></span>

<h3>Description</h3>

<p>Calculates the distribution of the maximum of the partial sum process for a given value in the identically and independantly distributed model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxPartialSumd(k, score_probabilities, sequence_min, sequence_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxPartialSumd_+3A_k">k</code></td>
<td>
<p>value at which calculates the probability</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="maxPartialSumd_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implement the formula (4) of the article Mercier, S., Cellier, D., &amp; Charlot, D. (2003). An improved approximation for assessing the statistical significance of molecular sequence features. Journal of Applied Probability, 40(2), 427-441. doi:10.1239/jap/1053003554 <br />
Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistency.
</p>


<h3>Value</h3>

<p>A double representing the probability of the maximum of the partial sum process equal to k
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maxPartialSumd(10, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
</code></pre>

<hr>
<h2 id='mcc'>MCC [p-value] [iid]</h2><span id='topic+mcc'></span>

<h3>Description</h3>

<p>Calculates an approximated p-value for a given local score value and a medium to long sequence length in the identically and independantly distributed model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcc(
  localScore,
  sequence_length,
  score_probabilities,
  sequence_min,
  sequence_max
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcc_+3A_localscore">localScore</code></td>
<td>
<p>the observed local score</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_length">sequence_length</code></td>
<td>
<p>length of the sequence (up to one hundred)</p>
</td></tr>
<tr><td><code id="mcc_+3A_score_probabilities">score_probabilities</code></td>
<td>
<p>the probabilities for each unique score from lowest to greatest</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_min">sequence_min</code></td>
<td>
<p>minimum score</p>
</td></tr>
<tr><td><code id="mcc_+3A_sequence_max">sequence_max</code></td>
<td>
<p>maximum score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This methods is actually an improved method of Karlin and produces more precise results. It should be privileged whenever possible. <br />
As with karlin, the method works the better the longer the sequence. Important note : the calculus of the parameter of the distribution uses
the resolution of a polynome which is a function of the score distribution, of order max(score)-min(score). There exists only empirical methods to solve a polynome of order greater that 5
with no warranty of reliable solution.
The found roots are checked internally to the function and an error message is throw in case of inconsistency. In such case, you could try to change your score scheme (in case of discretization)
or use the function <code><a href="#topic+karlinMonteCarlo">karlinMonteCarlo</a></code> .
</p>


<h3>Value</h3>

<p>A double representing the probability of a local score as high as the one given as argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcc(40, 100, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
mcc(40, 10000, c(0.08, 0.32, 0.08, 0.00, 0.08, 0.00, 0.00, 0.08, 0.02, 0.32, 0.02), -6, 4)
</code></pre>

<hr>
<h2 id='MidSeq'>Deprecated. Use 'Seq219' instead.</h2><span id='topic+MidSeq'></span>

<h3>Description</h3>

<p>Deprecated. Use 'Seq219' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MidSeq
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'Seq219' instead.
</p>

<hr>
<h2 id='monteCarlo'>Monte Carlo method [p-value]</h2><span id='topic+monteCarlo'></span>

<h3>Description</h3>

<p>Calculates an empirical p-value based on simulations of similar integer sequences of the same length.
Perfect for small sequences (both markov chains and identically and independantly distributed) with length ~ 10^3. 
See function monteCarlo_double() for possible real scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monteCarlo(local_score, FUN, ..., plot = TRUE, numSim = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monteCarlo_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a segment.</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_plot">plot</code></td>
<td>
<p>boolean value if to display plots for cumulated function and density</p>
</td></tr>
<tr><td><code id="monteCarlo_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to generate during simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Floating value corresponding to the probability to obtain a local score with value greater or equal to the parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
monteCarlo(120, FUN = rbinom, n = 100, size = 5, prob=0.2)

new = sample(-7:6, replace = TRUE, size = 1000)
#MonteCarlo taking random sample from the input sequence itself

monteCarlo(local_score = 20, FUN = function(x) {return(sample(x = x, 
size = length(x), replace = TRUE))}, x=new)

# Markovian example
MyTransMat &lt;-
+     matrix(c(0.3,0.1,0.1,0.1,0.4, 0.2,0.2,0.1,0.2,0.3, 0.3,0.4,0.1,0.1,0.1, 0.3,0.3,0.1,0.0,0.3,
+              0.1,0.1,0.2,0.3,0.3), ncol = 5, byrow=TRUE)

monteCarlo(local_score = 50,
          FUN = transmatrix2sequence, matrix = MyTransMat,
          length=150, score = c(-2,-1,0,2,3), plot=FALSE, numSim = 5000)

</code></pre>

<hr>
<h2 id='monteCarlo_double'>Monte Carlo method for real score case [p-value]</h2><span id='topic+monteCarlo_double'></span>

<h3>Description</h3>

<p>Calculates an empirical p-value based on simulations of similar sequences of the same length.
Perfect for small sequences (both markov chains and identically and independantly distributed) with length ~ 10^3. Function dedicated for real score case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monteCarlo_double(local_score, FUN, ..., plot = TRUE, numSim = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monteCarlo_double_+3A_local_score">local_score</code></td>
<td>
<p>local score observed in a segment.</p>
</td></tr>
<tr><td><code id="monteCarlo_double_+3A_fun">FUN</code></td>
<td>
<p>function to simulate similar sequences with.</p>
</td></tr>
<tr><td><code id="monteCarlo_double_+3A_...">...</code></td>
<td>
<p>parameters for FUN</p>
</td></tr>
<tr><td><code id="monteCarlo_double_+3A_plot">plot</code></td>
<td>
<p>Boolean value if to display plots for cumulated function and density</p>
</td></tr>
<tr><td><code id="monteCarlo_double_+3A_numsim">numSim</code></td>
<td>
<p>number of sequences to generate during simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Floating value corresponding to the probability to obtain a local score with value greater or equal to the parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
score_reels=c(-1,-0.5,0,0.5,1)
proba_score_reels=c(0.2,0.3,0.1,0.2,0.2)
sample_from_model &lt;- function(score.sple,proba.sple, length.sple){sample(score.sple,
                                  size=length.sple, prob=proba.sple, replace=TRUE)}

monteCarlo_double(5.5,FUN=sample_from_model, plot = TRUE, 
score.sple=score_reels,proba.sple=proba_score_reels, length.sple=100, numSim = 1000)

</code></pre>

<hr>
<h2 id='MySeqList'>Deprecated. Use 'SeqListSCOPe' instead.</h2><span id='topic+MySeqList'></span>

<h3>Description</h3>

<p>Deprecated. Use 'SeqListSCOPe' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MySeqList
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'SeqListSCOPe' instead.
</p>

<hr>
<h2 id='RealScores2IntegerScores'>Convert a real scores vector into an integer scores vector</h2><span id='topic+RealScores2IntegerScores'></span>

<h3>Description</h3>

<p>Convert real scores into integer scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RealScores2IntegerScores(RealScore, ProbRealScore, coef = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RealScores2IntegerScores_+3A_realscore">RealScore</code></td>
<td>
<p>vector of real scores</p>
</td></tr>
<tr><td><code id="RealScores2IntegerScores_+3A_probrealscore">ProbRealScore</code></td>
<td>
<p>vector of probability</p>
</td></tr>
<tr><td><code id="RealScores2IntegerScores_+3A_coef">coef</code></td>
<td>
<p>coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert real scores into integer scores by multiplying real
scores by a coefficient (default 10) and then assigning probability to corresponding
extended (from the minimum to the maximum) integer scores
</p>


<h3>Value</h3>

<p>list containing ExtendedIntegerScore and ProbExtendedIntegerScore
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score &lt;- c(-1,-0.5,0,0.5,1)
prob.score &lt;- c(0.2,0,0.4,0.1,0.3)
(res1 &lt;- RealScores2IntegerScores(score, prob.score, coef=10))
prob.score.err &lt;- c(0.1,0,0.4,0.1,0.3)
(res2 &lt;- RealScores2IntegerScores(score, prob.score.err, coef=10))
# When coef=1, the function can handle integer scores
ex.integer.score &lt;- c(-3,-1,0,1, 5)
(res3 &lt;- RealScores2IntegerScores(ex.integer.score, prob.score, coef=1))
</code></pre>

<hr>
<h2 id='scoreDictionnary2probabilityVector'>Check for missing scores values in the score distribution</h2><span id='topic+scoreDictionnary2probabilityVector'></span>

<h3>Description</h3>

<p>Get extremes scores, then create a complete list and set a probability equal to zeros for not present scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreDictionnary2probabilityVector(list, score_extremes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreDictionnary2probabilityVector_+3A_list">list</code></td>
<td>
<p>vector of scores</p>
</td></tr>
<tr><td><code id="scoreDictionnary2probabilityVector_+3A_score_extremes">score_extremes</code></td>
<td>
<p>vector of probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector containing all score values between extremes and the probability equal to 0 for missing score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mylist=list("x1"=c(-2,0.1),"x2"=c(0,0.7),"x3"=c(1,0.2))
scoreDictionnary2probabilityVector(list=Mylist,score_extremes=c(-2,1))
</code></pre>

<hr>
<h2 id='scoreSequences2probabilityVector'>Empirical distribution from sequences</h2><span id='topic+scoreSequences2probabilityVector'></span>

<h3>Description</h3>

<p>Builds empirical distribution from a list of numerical sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreSequences2probabilityVector(sequences)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreSequences2probabilityVector_+3A_sequences">sequences</code></td>
<td>
<p>list of numerical sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By determining the extreme scores in the sequences, this function creates a vector of probabilities
including values that do not occur at all. In this it differs from table(). For example, two sequences containing
values from 1:2 and 5:6 will produce a vector of size 6.
</p>


<h3>Value</h3>

<p>empirical distribution from minimum score to maximum score as a vector of floating numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq1 = sample(7:8, size = 10, replace = TRUE)
seq2 = sample(2:3, size = 15, replace = TRUE)
l = list(seq1, seq2)
scoreSequences2probabilityVector(l)
</code></pre>

<hr>
<h2 id='Seq1093'>Long protein sequence</h2><span id='topic+Seq1093'></span>

<h3>Description</h3>

<p>A long protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Seq1093
</code></pre>


<h3>Format</h3>

<p>A character string with 1093 characters corresponding to Q60519.fasta in UniProt Data base.
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq1093)
Seq1093
nchar(Seq1093)
data(HydroScore)
seqScore=CharSequence2ScoreSequence(Seq1093,HydroScore)
seqScore[1:50]
localScoreC(seqScore)$localScore
LS=localScoreC(seqScore)$localScore[1]
prob1 = scoreSequences2probabilityVector(list(seqScore))
daudin(localScore = LS, sequence_length = nchar(Seq1093),
               score_probabilities = prob1,
               sequence_min = min(seqScore),
               sequence_max = max(seqScore))
karlin(localScore = LS, sequence_length = nchar(Seq1093),
score_probabilities = prob1,
sequence_min = min(seqScore),
sequence_max = max(seqScore))
</code></pre>

<hr>
<h2 id='Seq219'>Protein sequence</h2><span id='topic+Seq219'></span>

<h3>Description</h3>

<p>A protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Seq219
</code></pre>


<h3>Format</h3>

<p>A character string with 219 characters corresponding to P49755.fasta query in UniProt Data base.
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq219)
Seq219
nchar(Seq219)
data(HydroScore)
seqScore=CharSequence2ScoreSequence(Seq219,HydroScore)
seqScore[1:30]
localScoreC(seqScore)$localScore
prob1 = scoreSequences2probabilityVector(list(seqScore))
daudin(localScore = 52, sequence_length = nchar(Seq219),
               score_probabilities = prob1,
               sequence_min = min(seqScore),
               sequence_max = max(seqScore))
score=-5:5
prob2=c(0.15,0.15,0.1,0.1,0.0,0.05,0.15,0.05,0.2,0.0,0.05)
daudin(localScore = 52, sequence_length = nchar(Seq219),
       score_probabilities = prob2,
       sequence_min = min(seqScore),
       sequence_max = max(seqScore))
</code></pre>

<hr>
<h2 id='Seq31'>Short protein sequence</h2><span id='topic+Seq31'></span>

<h3>Description</h3>

<p>A short protein sequence of 31 amino acids corresponding to Q09FU3.fasta query in UniProt Data base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Seq31
</code></pre>


<h3>Format</h3>

<p>A character string with 31 characters &quot;MLTITSYFGFLLAALTITSVLFIGLNKIRLI&quot;
</p>


<h3>Source</h3>

<p><a href="https://www.uniprot.org/">https://www.uniprot.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Seq31)
Seq31
nchar(Seq31)
data(HydroScore) 
SeqScore=CharSequence2ScoreSequence(Seq31,HydroScore)
SeqScore
localScoreC(SeqScore)$localScore
LS=localScoreC(SeqScore)$localScore[1]
prob1 = scoreSequences2probabilityVector(list(SeqScore))
daudin(localScore = LS, sequence_length = nchar(Seq31),
               score_probabilities = prob1,
               sequence_min = min(SeqScore),
               sequence_max = max(SeqScore))
score=-5:5
prob2=c(0.15,0.15,0.1,0.1,0.0,0.05,0.15,0.05,0.2,0.0,0.05)
sum(prob2*score)
karlin(localScore = LS, sequence_length = nchar(Seq31),
score_probabilities = prob2,
sequence_min = min(SeqScore),
sequence_max = max(SeqScore))
</code></pre>

<hr>
<h2 id='SeqListSCOPe'>Several sequences</h2><span id='topic+SeqListSCOPe'></span>

<h3>Description</h3>

<p>A vector of character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqListSCOPe
</code></pre>


<h3>Format</h3>

<p>A list of 285 character strings with their entry codes as names
</p>


<h3>Source</h3>

<p>Structural Classification Of Proteins database (SCOP). More precisely this data contain the 285 protein sequences of the data called &quot;CF_scop2dom_20140205aa&quot; with length from 31 to 404.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SeqListSCOPe)
head(SeqListSCOPe)
SeqListSCOPe[1]
nchar(SeqListSCOPe[1])
summary(sapply(SeqListSCOPe, nchar))
data(HydroScore)
MySeqScoreList=lapply(SeqListSCOPe, FUN=CharSequence2ScoreSequence, HydroScore)
head(MySeqScoreList)
AA=automatic_analysis(sequences=MySeqScoreList, model='iid')
AA[[1]]
# the p-value of the first 10 sequences 
sapply(AA, function(x){x$`p-value`})[1:10]
# the 20th smallest p-values
sort(sapply(AA, function(x){x$`p-value`}))[1:20]
which(sapply(AA, function(x){x$`p-value`})&lt;0.05)
table(sapply(AA, function(x){x$`method`}))
# The maximum sequence length equals 404 so it here normal that the exact method is used for
# all the 606 sequences of the data base 
# Score distribution learnt on the data set
scoreSequences2probabilityVector(MySeqScoreList)
</code></pre>

<hr>
<h2 id='sequences2transmatrix'>Transition matrix from sequence(s)</h2><span id='topic+sequences2transmatrix'></span>

<h3>Description</h3>

<p>Calculates the transition matrix by counting occurences of tuples in given vector list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequences2transmatrix(sequences)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequences2transmatrix_+3A_sequences">sequences</code></td>
<td>
<p>Sequences to be analyzed, as list of numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition matrix will be structured so that the lowest score corresponds to the first column and row
and the highest score corresponds to the last column and row. Note that the resulting matrix is not stochastic because it can occur rows filled up with only 0 for not observed score in Min Value Max Value interval.
</p>


<h3>Value</h3>

<p>A list object containing
</p>
<table>
<tr><td><code>Transition Matrix</code></td>
<td>
<p>Transition Matrix</p>
</td></tr>
<tr><td><code>Min Value</code></td>
<td>
<p>minimal score found in supplied sequences</p>
</td></tr>
<tr><td><code>Max Value</code></td>
<td>
<p>maximal score found in supplied sequences</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>seq = sample(-1:1, size = 20, replace = TRUE)
seq2 = sample(-6:1, size = 20, replace = TRUE)
seq3 = sample(3:6, size = 50, replace = TRUE)
sequences2transmatrix(list(seq, seq2, seq3))
</code></pre>

<hr>
<h2 id='ShortSeq'>Deprecated. Use 'Seq31' instead.</h2><span id='topic+ShortSeq'></span>

<h3>Description</h3>

<p>Deprecated. Use 'Seq31' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortSeq
</code></pre>


<h3>Format</h3>

<p>Deprecated. Use 'Seq31' instead.
</p>

<hr>
<h2 id='SJSyndrome.data'>Stevens-Johnson syndrome data</h2><span id='topic+SJSyndrome.data'></span>

<h3>Description</h3>

<p>The Stevens-Johnson syndrome is an acute and serious dermatological disease due to a drug allergy. 
The syndrome appearance is life-threatening emergency. They are very rare, around 2 cases per million people per year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SJSyndrome.data
</code></pre>


<h3>Format</h3>

<p>A data.frame of 824 lines, each describing a syndrome appearance described by 15 covariates:
Case ID,
Initial FDA Received Date,
days since last fda,
Event Date,
Latest FDA Received Date,
Suspect Product Names,
Suspect Product Active Ingredients,
Reason for Use,
Reactions,
Serious,
Outcomes,
Sex,
Patient Age,
Sender,
Concomitant Product Names
The third column correspond to the number of days between two adverse events.
</p>


<h3>Source</h3>

<p>FDA open data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SJSyndrome.data)
summary(SJSyndrome.data)
</code></pre>

<hr>
<h2 id='stationary_distribution'>Stationary distribution [Markov chains]</h2><span id='topic+stationary_distribution'></span>

<h3>Description</h3>

<p>Calculates stationary distribution of markov transition matrix by use of eigenvectors of length 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_distribution(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stationary_distribution_+3A_m">m</code></td>
<td>
<p>Transition Matrix [matrix object]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = t(matrix (c(0.2, 0.8, 0.4, 0.6), nrow = 2))
stationary_distribution(B)
</code></pre>

<hr>
<h2 id='transmatrix2sequence'>Sampling function for Markov chains</h2><span id='topic+transmatrix2sequence'></span>

<h3>Description</h3>

<p>Creates Markov chains based on a transition matrix. Can be used as parameter for the Monte Carlo function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmatrix2sequence(matrix, length, initialIndex, score)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmatrix2sequence_+3A_matrix">matrix</code></td>
<td>
<p>transition matrix of Markov process</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_length">length</code></td>
<td>
<p>length of sequence to be sampled</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_initialindex">initialIndex</code></td>
<td>
<p>(optional) index of matrix which should be initial value of sequence. If none supplied, a value from the stationary distribution is sampled as initial value.</p>
</td></tr>
<tr><td><code id="transmatrix2sequence_+3A_score">score</code></td>
<td>
<p>(optional) a vector representing the scores (in ascending order) of the matrix index. If supplied, the result will be a vector of these values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition matrix is considered representing the transition from one score to another such that the score in the first row is the lowest 
and the last row are the transitions from the highest score to another. The matrix must be stochastic (no rows filled up with only '0' values).
</p>


<h3>Value</h3>

<p>a Markov chain sampled from the transition matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B = t(matrix (c(0.2, 0.8, 0.4, 0.6), nrow = 2))
transmatrix2sequence(B, length = 10)
MyTransMat &lt;-
   matrix(c(0.3,0.1,0.1,0.1,0.4, 0.2,0.2,0.1,0.2,0.3, 0.3,0.4,0.1,0.1,0.1, 0.3,0.3,0.1,0.0,0.3,
    0.1,0.1,0.2,0.3,0.3), ncol = 5, byrow=TRUE)
MySeq.CM=transmatrix2sequence(matrix = MyTransMat,length=90, score =c(-2,-1,0,2,3))
MySeq.CM
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
