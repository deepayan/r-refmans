<!DOCTYPE html><html lang="en"><head><title>Help for package RConics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RConics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RConics-package'><p>RConics: Computations on conics</p></a></li>
<li><a href='#addLine'><p>Plot a &quot;homogeneous&quot; line to a plot.</p></a></li>
<li><a href='#adjoint'><p>Adjoint matrix</p></a></li>
<li><a href='#arcLengthEllipse'><p>Arc length of an ellipse</p></a></li>
<li><a href='#cofactor'><p><code class="reqn">(i,j)</code>-cofactor and <code class="reqn">(i,j)</code>-minor of a matrix</p></a></li>
<li><a href='#colinear'><p>Test for colinearity</p></a></li>
<li><a href='#conicMatrixToEllipse'>
<p>Transformation of the matrix representation of an ellipse into the ellipse parameters</p></a></li>
<li><a href='#conicThrough5Points'><p>Compute the conic that passes through 5 points</p></a></li>
<li><a href='#cubic'><p>Roots of the cubic equation.</p></a></li>
<li><a href='#ellipse'><p>Return ellipse points</p></a></li>
<li><a href='#ellipseToConicMatrix'><p>Transformation of the ellipse parameters into the matrix representation</p></a></li>
<li><a href='#intersectConicConic'><p>Intersection between two conics</p></a></li>
<li><a href='#intersectConicLine'><p>Intersections between a conic and a line</p></a></li>
<li><a href='#join'><p>The join and meet of two points and the parallel</p></a></li>
<li><a href='#pEllipticInt'><p>Partial elliptic integral</p></a></li>
<li><a href='#polar'><p>Polar line of point with respect to a conic</p></a></li>
<li><a href='#quadraticFormToMatrix'><p>Transformation of the quadratic conic representation into the matrix representation.</p></a></li>
<li><a href='#rotation'><p>Affine planar transformations matrix</p></a></li>
<li><a href='#skewSymmetricMatrix'><p><code class="reqn">(3 \times 3)</code> skew symmetric matrix</p></a></li>
<li><a href='#splitDegenerateConic'><p>Split degenerate conic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computations on Conics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emanuel Huber &lt;emanuel.huber@pm.me&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Solve some conic related problems (intersection of conics with lines and conics, arc length of an ellipse, polar lines, etc.). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>base, R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emanuelhuber/RConics">https://github.com/emanuelhuber/RConics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emanuelhuber/RConics/issues">https://github.com/emanuelhuber/RConics/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-17 21:57:03 UTC; huber</td>
</tr>
<tr>
<td>Author:</td>
<td>Emanuel Huber <a href="https://orcid.org/0000-0002-5528-0412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-17 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RConics-package'>RConics: Computations on conics</h2><span id='topic+RConics'></span><span id='topic+RConics-package'></span>

<h3>Description</h3>

<p>A package to solve some conic related problems 
(intersection of conics with lines and conics, arc length of an ellipse, 
polar lines, etc.).
</p>


<h3>Details</h3>

<p>Some of the functions are based on the <em>projective</em> geometry. 
In projective geometry parallel lines meet at an infinite point and 
all infinite points are incident to a line at infinity. 
Points and lines of a projective plane are represented by <em>homogeneous</em>
coordinates, that means by 3D vectors: <code class="reqn">(x, y, z)</code> for the points and 
<code class="reqn">(a, b, c)</code> such that <code class="reqn">ax + by + c = 0</code> for the lines. 
The Euclidian points correspond to <code class="reqn">(x, y, 1)</code>, 
the infinite points to <code class="reqn">(x, y, 0)</code>, the Euclidean lines to 
<code class="reqn">(a, b, c)</code> with <code class="reqn">a \neq 0</code> or <code class="reqn">b \neq 0</code>, the line at 
infinity to <code class="reqn">(0, 0, 1)</code>.
</p>
<p><strong>Advice</strong>: to plot conics use the package <code>conics</code> 
from Bernard Desgraupes.
</p>
<p>This work was funded by the Swiss National Science Foundation within the 
ENSEMBLE project (grant no. CRSI_132249).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emanuel Huber <a href="mailto:emanuel.huber@pm.me">emanuel.huber@pm.me</a> (<a href="https://orcid.org/0000-0002-5528-0412">ORCID</a>)
</p>


<h3>References</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real and Complex Geometry</em>, 
Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/emanuelhuber/RConics">https://github.com/emanuelhuber/RConics</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/emanuelhuber/RConics/issues">https://github.com/emanuelhuber/RConics/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addLine'>Plot a &quot;homogeneous&quot; line to a plot.</h2><span id='topic+addLine'></span><span id='topic+plotHLine'></span>

<h3>Description</h3>

<p>Add a homogeneous line to a plot. The line parameters must be in homogeneous coordinates, e.g. <code class="reqn">(a,b,c)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLine(l, ...)

plotHLine(l, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addLine_+3A_l">l</code></td>
<td>
<p>A <code class="reqn">3 \times 1</code> vector of the homogeneous representation of a line.</p>
</td></tr>
<tr><td><code id="addLine_+3A_...">...</code></td>
<td>
<p><a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> such as <code>col</code>, <code>lty</code> and  <code>lwd</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># two points in homogeneous coordinates
p1 &lt;- c(3,1,1)
p2 &lt;- c(0,2,1)

# homogeneous line joining p1 and p2
l_12 &lt;- join(p1,p2)
l_12

# plot
plot(0,0,type="n", xlim=c(-2,5),ylim=c(-2,5),asp=1)
points(t(p1))
points(t(p2))
addLine(l_12,col="red",lwd=2)
</code></pre>

<hr>
<h2 id='adjoint'>Adjoint matrix</h2><span id='topic+adjoint'></span>

<h3>Description</h3>

<p>Compute the classical adjoint (also called adjugate) of a square matrix. The adjoint is the transpose of the cofactor matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjoint(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjoint_+3A_a">A</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjoint matrix of A (square matrix with the same dimension as A).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cofactor">cofactor</a></code>, <code><a href="#topic+minor">minor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,4,5,3,7,2,2,8,3),nrow=3,ncol=3)
A
B &lt;- adjoint(A)
B
</code></pre>

<hr>
<h2 id='arcLengthEllipse'>Arc length of an ellipse</h2><span id='topic+arcLengthEllipse'></span>

<h3>Description</h3>

<p>This function computes the arc length of an ellipse centered in <code class="reqn">(0,0)</code> 
with the semi-axes aligned with the <code class="reqn">x</code>- and <code class="reqn">y</code>-axes. 
The arc length is defined by the points <code class="reqn">1</code> and <code class="reqn">2</code>. 
These two points do not need to lie exactly on the ellipse: 
the <code class="reqn">x</code>-coordinate of the points and the quadrant where they lie 
define the positions on the ellipse used to compute the arc length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcLengthEllipse(p1, p2 = NULL, saxes, n = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arcLengthEllipse_+3A_p1">p1</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the Cartesian coordinates of point <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="arcLengthEllipse_+3A_p2">p2</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the Cartesian coordinates of point <code class="reqn">2</code> (optional).</p>
</td></tr>
<tr><td><code id="arcLengthEllipse_+3A_saxes">saxes</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of length of the semi-axes of the ellipse.</p>
</td></tr>
<tr><td><code id="arcLengthEllipse_+3A_n">n</code></td>
<td>
<p>the number of iterations used in the numerical approximation of the incomplete elliptic integral of the second kind.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the coordinates <code>p2</code> of the point <code class="reqn">2</code> are omitted the function 
<code>arcLengthEllipse</code> computes the arc length between the point <code class="reqn">1</code> 
and the point defined by <code class="reqn">(0,b)</code>, <code class="reqn">b</code> beeing the minor semi-axis.
</p>


<h3>Value</h3>

<p>The length of the shortest arc of the ellipse defined by the 
points 1 and 2.
</p>


<h3>Source</h3>

<p>Van de Vel, H. (1969).
<em>On the series expansion method for Computing incomplete elliptic 
integrals of the first and second kinds</em>, Math. Comp. 23, 61-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pEllipticInt">pEllipticInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- c(3,1)
p2 &lt;- c(0,2)

# Ellipse with semi-axes: a = 5, b= 2
saxes &lt;- c(5,2)

# 1 iteration
arcLengthEllipse(p1,p2,saxes,n=1)

# 5 iterations
arcLengthEllipse(p1,p2,saxes,n=5)

# 10 iterations
arcLengthEllipse(p1,p2,saxes,n=10)
</code></pre>

<hr>
<h2 id='cofactor'><code class="reqn">(i,j)</code>-cofactor and <code class="reqn">(i,j)</code>-minor of a matrix</h2><span id='topic+cofactor'></span><span id='topic+minor'></span>

<h3>Description</h3>

<p>Compute the <code class="reqn">(i,j)</code>-cofactor, respectively the <code class="reqn">(i,j)</code>-minor of 
the matrix <code class="reqn">A</code>. The <code class="reqn">(i,j)</code>-cofactor is obtained by multiplying 
the <code class="reqn">(i,j)</code>-minor by <code class="reqn">(-1)^{i+j}</code>. The <code class="reqn">(i,j)</code>-minor of <code class="reqn">A</code>, 
is the determinant of the <code class="reqn">(n - 1) \times (n - 1)</code> matrix that results 
by deleting the <code class="reqn">i</code>-th row and the <code class="reqn">j</code>-th column of <code class="reqn">A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cofactor(A, i, j)

minor(A, i, j)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cofactor_+3A_a">A</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
<tr><td><code id="cofactor_+3A_i">i</code></td>
<td>
<p>the <code class="reqn">i</code>-th row.</p>
</td></tr>
<tr><td><code id="cofactor_+3A_j">j</code></td>
<td>
<p>the <code class="reqn">j</code>-th column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">(i,j)</code>-minor/cofactor of the matrix <code class="reqn">A</code> (single value).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjoint">adjoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,4,5,3,7,2,2,8,3),nrow=3,ncol=3)
A
minor(A,2,3)
cofactor(A,2,3)
</code></pre>

<hr>
<h2 id='colinear'>Test for colinearity</h2><span id='topic+colinear'></span>

<h3>Description</h3>

<p>Tests if three points are colinear. The coordinates of the points have to be in homogeneous coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colinear(p1, p2, p3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colinear_+3A_p1">p1</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vector of the homogeneous coordinates of point <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="colinear_+3A_p2">p2</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vector of the homogeneous coordinates of point <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="colinear_+3A_p3">p3</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vector of the homogeneous coordinates of point <code class="reqn">3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the three points are colinear, else <code>FALSE</code>.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># points: homogeneous coordinates
p1 &lt;- c(3,1,1)
p2 &lt;- c(0,2,1)
p3 &lt;- c(1.5,-2,1)
p4 &lt;- c(1,3,1)

# homogeneous line passing through p1 and p2
l1 &lt;- join(p1,p2)

# homogeneous line passing through p3 and p3
l2 &lt;- join(p3,p4)

# homogeneous points formed by the intersection of the lines
p5 &lt;- meet(l1,l2)

# test for colinearity
colinear(p1, p2, p3)
colinear(p1, p2, p5)
colinear(p3, p4, p5)

# plot
plot(rbind(p1,p2,p3,p4),xlim=c(-5,5),ylim=c(-5,5),asp=1)
abline(h=0,v=0,col="grey",lty=3)
addLine(l1,col="red")
addLine(l2,col="blue")
points(t(p5),cex=1.5,pch=20,col="blue")
</code></pre>

<hr>
<h2 id='conicMatrixToEllipse'>
Transformation of the matrix representation of an ellipse into the ellipse parameters
</h2><span id='topic+conicMatrixToEllipse'></span>

<h3>Description</h3>

<p>Ellipses can be represented by a <code class="reqn">(3 \times 3)</code> matrix <code class="reqn">A</code>, such that for each point <code class="reqn">x</code> on the ellipse <code class="reqn">x^T A x = 0</code>. The function <code>conicMatrixToEllipse</code> transforms the matrix <code class="reqn">A</code> into the ellipse parameters: center location, semi-axes length and angle of rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conicMatrixToEllipse(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conicMatrixToEllipse_+3A_a">A</code></td>
<td>

<p>a <code class="reqn">(3 \times 3)</code> matrix representation of an ellipse.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>loc</code></td>
<td>
<p>  a <code class="reqn">(2 \times 1)</code> vector of the Cartesian coordinates of the ellipse center.</p>
</td></tr>
<tr><td><code>saxes</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the length of the ellipse semi-axes.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the angle of rotation of the ellipse (in radians).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wolfram, Mathworld (<a href="http://mathworld.wolfram.com/">http://mathworld.wolfram.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ellipseToConicMatrix">ellipseToConicMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ellipse parameter
saxes &lt;- c(5,2)
loc &lt;- c(0,0)
theta &lt;- pi/4
# matrix representation of the ellipse
C &lt;- ellipseToConicMatrix(saxes,loc,theta)
C
# back to the ellipse parameters
conicMatrixToEllipse(C)
</code></pre>

<hr>
<h2 id='conicThrough5Points'>Compute the conic that passes through 5 points</h2><span id='topic+conicThrough5Points'></span>

<h3>Description</h3>

<p>Return the matrix representation of the conic that passes through exactly 5 points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conicThrough5Points(p1, p2, p3, p4, p5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conicThrough5Points_+3A_p1">p1</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of one of the five points.</p>
</td></tr>
<tr><td><code id="conicThrough5Points_+3A_p2">p2</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of one of the five points.</p>
</td></tr>
<tr><td><code id="conicThrough5Points_+3A_p3">p3</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of one of the five points.</p>
</td></tr>
<tr><td><code id="conicThrough5Points_+3A_p4">p4</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of one of the five points.</p>
</td></tr>
<tr><td><code id="conicThrough5Points_+3A_p5">p5</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of one of the five points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 3)</code> matrix representation of the conic passing through the 5 points.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># five points
p1 &lt;- c(-4.13, 6.24, 1)
p2 &lt;- c(-8.36, 1.17, 1)
p3 &lt;- c(-2.03, -4.61, 1)
p4 &lt;- c(9.70, -3.49, 1)
p5 &lt;- c(8.02, 3.34, 1)

# matrix representation of the conic passing
# through the five points
C5 &lt;- conicThrough5Points(p1,p2,p3,p4,p5)

# plot
plot(rbind(p1,p2,p3,p4,p5),xlim=c(-10,10), ylim=c(-10,10), asp=1) 
# from matrix to ellipse parameters
E5 &lt;- conicMatrixToEllipse(C5)
lines(ellipse(E5$saxes, E5$loc, E5$theta, n=500))
</code></pre>

<hr>
<h2 id='cubic'>Roots of the cubic equation.</h2><span id='topic+cubic'></span>

<h3>Description</h3>

<p>Return the roots of a cubic equation of the form <code class="reqn">ax^3 + bx^2 + cx + d=0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubic(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubic_+3A_p">p</code></td>
<td>
<p>a <code class="reqn">(4 \times 1)</code> vector of the four parameters <code class="reqn">(a, b, c, d)</code> of the cubic equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector corresponding to the roots of the cubic equation.
</p>


<h3>Source</h3>

<p>W. H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery (2007). 
<em>NUMERICAL RECIPES - the art of scientific computing</em>. 
Cambridge, University Press, chap 5.6, p. 227-229.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cubic equation x^3 - 6x^2 + 11x - 6 = 0
# parameter
b &lt;- c(1,-6, 11, -6)

# roots
x0 &lt;- cubic(b)

# plot
x &lt;- seq(0,4, by=0.001)
y &lt;- b[1]*x^3 + b[2]*x^2 + b[3]*x + b[4]

# plot
plot(x,y,type="l")
abline(h=0,v=0)
points(cbind(x0,c(0,0,0)), pch=20,col="red",cex=1.8)
</code></pre>

<hr>
<h2 id='ellipse'>Return ellipse points</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Return ellipse points. Usefull for ploting ellipses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(
  saxes = c(1, 1),
  loc = c(0, 0),
  theta = 0,
  n = 201,
  method = c("default", "angle", "distance")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse_+3A_saxes">saxes</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the length of the ellipse semi-axes.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_loc">loc</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the Cartesian coordinates of the ellipse center.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_theta">theta</code></td>
<td>
<p>the angle of rotation of the elllipse (in radians).</p>
</td></tr>
<tr><td><code id="ellipse_+3A_n">n</code></td>
<td>
<p>the number of points returned by the function.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_method">method</code></td>
<td>
<p>The method used to return the points: either <code>"default"</code>, <code>"angle"</code>, or <code>"distance"</code> (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>"default"</code></dt><dd><p>returns points according to the polar equation;</p>
</dd>
<dt><code>"angle"</code></dt><dd><p>returns points radially equidistant;</p>
</dd>
<dt><code>"distance"</code></dt><dd><p> returns points that are equidistant on the ellipse arc.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code class="reqn">(n \times 2)</code> matrix whose columns correspond to the Cartesian coordinates of the points lying on the ellipse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipse parameters
saxes &lt;- c(5,2)
loc &lt;- c(0,0)
theta &lt;- pi/4

# Plot
plot(ellipse(saxes, loc, theta, n=500),type="l")
points(ellipse(saxes, loc, theta, n=30),pch=20,col="red")
points(ellipse(saxes, loc, theta, n=30, method="angle"),pch=20,col="blue")
points(ellipse(saxes, loc, theta, n=30, method="distance"),pch=20,col="green")
</code></pre>

<hr>
<h2 id='ellipseToConicMatrix'>Transformation of the ellipse parameters into the matrix representation</h2><span id='topic+ellipseToConicMatrix'></span>

<h3>Description</h3>

<p>Transformation of the ellipse parameters (Cartesian coordinates of the 
ellipse center, length of the semi-axes and angle of rotation) into the 
<code class="reqn">(3 \times 3)</code> into the matrix representation of conics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipseToConicMatrix(saxes = c(1, 1), loc = c(0, 0), theta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipseToConicMatrix_+3A_saxes">saxes</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the length of the
ellipse semi-axes.</p>
</td></tr>
<tr><td><code id="ellipseToConicMatrix_+3A_loc">loc</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the Cartesian coordinates of 
the ellipse center.</p>
</td></tr>
<tr><td><code id="ellipseToConicMatrix_+3A_theta">theta</code></td>
<td>
<p>the angle of rotation of the ellipse (in radians).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 3)</code> matrix that represents the ellipse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conicMatrixToEllipse">conicMatrixToEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipse parameters
saxes &lt;- c(5,2)
loc &lt;- c(0,0)
theta &lt;- pi/4
# Matrix representation of the ellipse
C &lt;- ellipseToConicMatrix(saxes,loc,theta)
</code></pre>

<hr>
<h2 id='intersectConicConic'>Intersection between two conics</h2><span id='topic+intersectConicConic'></span>

<h3>Description</h3>

<p>Returns the point(s) of intersection between two conics in homogeneous coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectConicConic(C1, C2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersectConicConic_+3A_c1">C1</code></td>
<td>
<p><code class="reqn">(3 \times 3)</code> matrix representation of conics.</p>
</td></tr>
<tr><td><code id="intersectConicConic_+3A_c2">C2</code></td>
<td>
<p><code class="reqn">(3 \times 3)</code> matrix representation of conics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The homogeneous coordinates of the intersection points. 
If there are <code class="reqn">k</code> points of intersection, it returns a <code class="reqn">(3 \times k)</code> 
matrix whose columns correspond to the homogeneous coordinates of the intersection points. 
If there is only one point, a <code class="reqn">(3 \times 1)</code> vector of the homogeneous 
coordinates of the intersection point is returned. 
If there is no intersection, <code>NULL</code> is returned.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipse with semi-axes a=8, b=2, centered in (0,0), with orientation angle = -pi/3
C1 &lt;- ellipseToConicMatrix(c(8,2), c(0,0), -pi/3)

# Ellipse with semi-axes a=5, b=2, centered in (1,-2), with orientation angle = pi/5
C2 &lt;- ellipseToConicMatrix(c(5,2), c(1,-2), pi/5)

# intersection conic C with conic C2
p_CC2 &lt;- intersectConicConic(C1,C2)

# plot
plot(ellipse(c(8,2), c(0,0), -pi/3),type="l",asp=1)
lines(ellipse(c(5,2), c(1,-2), pi/5), col="blue")
points(t(p_CC2), pch=20,col="blue")
</code></pre>

<hr>
<h2 id='intersectConicLine'>Intersections between a conic and a line</h2><span id='topic+intersectConicLine'></span>

<h3>Description</h3>

<p>Returns the point(s) of intersection between a conic and a line in homogeneous coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectConicLine(C, l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersectConicLine_+3A_c">C</code></td>
<td>
<p><code class="reqn">(3 \times 3)</code> matrix representation of conics.</p>
</td></tr>
<tr><td><code id="intersectConicLine_+3A_l">l</code></td>
<td>
<p>a <code class="reqn">(3 \times 3)</code> vector of the homogeneous representation of a line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The homogeneous coordinates of the intersection points. 
If there are two points of intersection, it returns a <code class="reqn">(3 \times 2)</code> 
matrix whose columns correspond to the homogeneous coordinates of the 
intersection points. If there is only one point, a <code class="reqn">(3 \times 1)</code> 
vector of the homogeneous coordinates of the intersection point is returned. 
If there is no intersection, <code>NULL</code> is returned.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Ellipse with semi-axes a=8, b=2, centered in (0,0), with orientation angle = -pi/3
C &lt;- ellipseToConicMatrix(c(8,2),c(0,0),-pi/3)

# line
l &lt;- c(0.25,0.85,-3)

# intersection conic C with line l:
p_Cl &lt;- intersectConicLine(C,l)

# plot
plot(ellipse(c(8,2),c(0,0),-pi/3),type="l",asp=1)
addLine(l,col="red")
points(t(p_Cl), pch=20,col="red")
</code></pre>

<hr>
<h2 id='join'>The join and meet of two points and the parallel</h2><span id='topic+join'></span><span id='topic+meet'></span><span id='topic+parallel'></span>

<h3>Description</h3>

<p>The join operation of two points is the cross-product of these two points 
and represents the line passing through them. The meet operation of two lines 
is the cross-product of these two lines and represents their intersection. 
The line parallel to a line <code class="reqn">l</code> and passing through the point <code class="reqn">p</code> 
corresponds to the join of <code class="reqn">p</code> with the meet of <code class="reqn">l</code> and the line 
at infinity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(p, q)

meet(l, m)

parallel(p, l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_+3A_p">p</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of a point.</p>
</td></tr>
<tr><td><code id="join_+3A_q">q</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous coordinates of a point.</p>
</td></tr>
<tr><td><code id="join_+3A_l">l</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous representation of a line.</p>
</td></tr>
<tr><td><code id="join_+3A_m">m</code></td>
<td>
<p><code class="reqn">(3 \times 1)</code> vectors of the homogeneous representation of a line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 1)</code> vector of either the homogeneous coordinates of
the meet of two lines (a point), the homogeneous representation of the 
join of two points (line), or the homogeneous representation of the 
parallel line. The vector has the form <code class="reqn">(x,y,1)</code>.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(3,1,1)
q &lt;- c(0,2,1)
l &lt;- c(0.75,0.25,1)

# m is the line passin through p and q
m &lt;- join(p,q)

# intersection point of m and l
ml &lt;- meet(l,m)

# line parallel to l and through p
lp &lt;- parallel(p,l)

# plot
plot(rbind(p,q),xlim=c(-5,5),ylim=c(-5,5))
abline(h=0,v=0,col="grey",lty=3)
addLine(l,col="red")
addLine(m,col="blue")
points(t(ml),cex=1.5,pch=20,col="blue")
addLine(lp,col="green")
</code></pre>

<hr>
<h2 id='pEllipticInt'>Partial elliptic integral</h2><span id='topic+pEllipticInt'></span>

<h3>Description</h3>

<p>Partial elliptic integral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pEllipticInt(x, saxes, n = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pEllipticInt_+3A_x">x</code></td>
<td>
<p>the <code class="reqn">x</code>-coordinate.</p>
</td></tr>
<tr><td><code id="pEllipticInt_+3A_saxes">saxes</code></td>
<td>
<p>a <code class="reqn">(2 \times 1)</code> vector of the length of the ellipse semi-axes.</p>
</td></tr>
<tr><td><code id="pEllipticInt_+3A_n">n</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the partial elliptic integral.
</p>


<h3>Source</h3>

<p>Van de Vel, H. (1969). <em>On the series expansion method for Computing 
incomplete elliptic integrals of the first and second kinds</em>, 
Math. Comp. 23, 61-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcLengthEllipse">arcLengthEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipse with semi-axes: a = 5, b= 2
saxes &lt;- c(5,2)

# 1 iteration
pEllipticInt(3,saxes,n=1)
# 5 iterations
pEllipticInt(3,saxes,n=5)
# 10 iterations
pEllipticInt(3,saxes,n=10)
</code></pre>

<hr>
<h2 id='polar'>Polar line of point with respect to a conic</h2><span id='topic+polar'></span>

<h3>Description</h3>

<p>Return the polar line <code class="reqn">l</code> of a point <code class="reqn">p</code> with respect to a conic with matrix representation <code class="reqn">C</code>. The polar line <code class="reqn">l</code> is defined by <code class="reqn">l = Cp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar(p, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polar_+3A_p">p</code></td>
<td>
<p>a <code class="reqn">(3 \times 1)</code> vector of the homogeneous coordinates of a point.</p>
</td></tr>
<tr><td><code id="polar_+3A_c">C</code></td>
<td>
<p>a <code class="reqn">(3 \times 3)</code> matrix representation of the conic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The polar line of a point <code class="reqn">p</code> on a conic is tangent to the conic on <code class="reqn">p</code>.
</p>


<h3>Value</h3>

<p>A  <code class="reqn">(3 \times 1)</code> vector of the homogeneous representation of the polar line.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ellipse with semi-axes a=5, b=2, centered in (1,-2), with orientation angle = pi/5
C &lt;- ellipseToConicMatrix(c(5,2),c(1,-2),pi/5)

# line
l &lt;- c(0.25,0.85,-1)

# intersection conic C with line l:
p_Cl &lt;- intersectConicLine(C,l)

# if p is on the conic, the polar line is tangent to the conic
l_p &lt;- polar(p_Cl[,1],C)

# point outside the conic
p1 &lt;- c(5,-3,1)
l_p1 &lt;- polar(p1,C)

# point inside the conic
p2 &lt;- c(-1,-4,1)
l_p2 &lt;- polar(p2,C)

# plot
plot(ellipse(c(5,2),c(1,-2),pi/5),type="l",asp=1, ylim=c(-10,2))
# addLine(l,col="red")
points(t(p_Cl[,1]), pch=20,col="red")
addLine(l_p,col="red")
points(t(p1), pch=20,col="blue")
addLine(l_p1,col="blue")
points(t(p2), pch=20,col="green")
addLine(l_p2,col="green")

# DUAL CONICS
saxes &lt;- c(5,2)
theta &lt;- pi/7
E &lt;- ellipse(saxes,theta=theta, n=50)
C &lt;-  ellipseToConicMatrix(saxes,c(0,0),theta)
plot(E,type="n",xlab="x", ylab="y", asp=1)
points(E,pch=20)
E &lt;- rbind(t(E),rep(1,nrow(E)))

All_tangant &lt;- polar(E,C)
apply(All_tangant, 2, addLine, col="blue")
</code></pre>

<hr>
<h2 id='quadraticFormToMatrix'>Transformation of the quadratic conic representation into the matrix representation.</h2><span id='topic+quadraticFormToMatrix'></span>

<h3>Description</h3>

<p>Transformation of the quadratic conic representation into the matrix representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadraticFormToMatrix(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadraticFormToMatrix_+3A_v">v</code></td>
<td>
<p>a <code class="reqn">(6 \times 1)</code> vector of the parameters <code class="reqn">(a, b, c, d, e, f)</code> 
of the quadratic form <code class="reqn">ax^2 + bxy + cy^2 + dxz + eyz + fz^2 = 0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 3)</code> matrix representation of the conic (symmetric matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(2,2,-2,-20,20,10)
quadraticFormToMatrix(v)
</code></pre>

<hr>
<h2 id='rotation'>Affine planar transformations matrix</h2><span id='topic+rotation'></span><span id='topic+translation'></span><span id='topic+scaling'></span><span id='topic+reflection'></span>

<h3>Description</h3>

<p><code class="reqn">(3 \times 3)</code> affine planar transformation matrix corresponding 
to reflection, rotation, scaling and translation in projective geometry. 
To transform a point <code class="reqn">p</code> multiply the transformation matrix <code class="reqn">A</code> with 
the homogeneous coordinates <code class="reqn">(x,y,z)</code> of <code class="reqn">p</code> 
(e.g. <code class="reqn">p_{transformed} = Ap</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation(theta, pt = NULL)

translation(v)

scaling(s)

reflection(alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation_+3A_theta">theta</code></td>
<td>
<p>the angle of the rotation (in radian).</p>
</td></tr>
<tr><td><code id="rotation_+3A_pt">pt</code></td>
<td>
<p>the homogeneous coordinates of the rotation center (optional).</p>
</td></tr>
<tr><td><code id="rotation_+3A_v">v</code></td>
<td>
<p>the <code class="reqn">(2 \times 1)</code> translation vector in direction <code class="reqn">x</code> and <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="rotation_+3A_s">s</code></td>
<td>
<p>the <code class="reqn">(2 \times 1)</code> scaling vector in direction <code class="reqn">x</code> and <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="rotation_+3A_alpha">alpha</code></td>
<td>
<p>the angle made by the line of reflection (in radian).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 3)</code> affine transformation matrix.
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- c(2,5,1)  # homogeneous coordinate

# rotation
r_p1 &lt;- rotation(4.5) %*% p1

# rotation centered in (3,1)
rt_p1 &lt;- rotation(4.5, pt=c(3,1,1)) %*% p1

# translation
t_p1 &lt;- translation(c(2,-4)) %*% p1

# scaling
s_p1 &lt;- scaling(c(-3,1)) %*% p1

# plot
plot(t(p1),xlab="x",ylab="y", xlim=c(-5,5),ylim=c(-5,5),asp=1)
abline(v=0,h=0, col="grey",lty=1)
abline(v=3,h=1, col="grey",lty=3)
points(3,1,pch=4)
points(t(r_p1),col="red",pch=20)
points(t(rt_p1),col="blue",pch=20)
points(t(t_p1),col="green",pch=20)
points(t(s_p1),col="black",pch=20)
</code></pre>

<hr>
<h2 id='skewSymmetricMatrix'><code class="reqn">(3 \times 3)</code> skew symmetric matrix</h2><span id='topic+skewSymmetricMatrix'></span>

<h3>Description</h3>

<p>Return a <code class="reqn">(3 \times 3)</code> skew symmetric matrix from three parameters <code class="reqn">(\lambda, \mu, \tau)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewSymmetricMatrix(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewSymmetricMatrix_+3A_p">p</code></td>
<td>
<p>a <code class="reqn">(3 \times 1)</code> vector <code class="reqn">(\lambda, \mu, \tau)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 3)</code> skew symmetric matrix, with :
</p>

<ul>
<li> <p><code class="reqn">A_{1,2}  = -A_{2,1} = \tau</code>
</p>
</li>
<li> <p><code class="reqn">-A_{1,3} =  A_{3,1} = \mu</code>
</p>
</li>
<li> <p><code class="reqn">A_{3,2}  = -A_{2,3} = \lambda</code>
</p>
</li></ul>



<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(3,7,11)
skewSymmetricMatrix(p)
</code></pre>

<hr>
<h2 id='splitDegenerateConic'>Split degenerate conic</h2><span id='topic+splitDegenerateConic'></span>

<h3>Description</h3>

<p>Split a degenerate conic into two lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitDegenerateConic(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitDegenerateConic_+3A_c">C</code></td>
<td>
<p>a <code class="reqn">(3 \times 3)</code> matrix representation of a degenerate conic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(3 \times 2)</code> matrix whose columns correspond to the homongeneous representation of two lines (real or complex).
</p>


<h3>Source</h3>

<p>Richter-Gebert, Jürgen (2011). 
<em>Perspectives on Projective Geometry - A Guided Tour Through Real
and Complex Geometry</em>, Springer, Berlin, ISBN: 978-3-642-17285-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tw0 lines
g &lt;- c(0.75,0.25,3)
h &lt;- c(0.5,-0.25,2)

# a degenerate conic 
D &lt;- g %*% t(h) + h %*% t(g)

# split the degenerate conic into 2 lines
L &lt;- splitDegenerateConic(D)

# plot
plot(0,0,xlim=c(-10,5),ylim=c(-10,10),type="n")
addLine(L[,1],col="red")
addLine(L[,2],col="green")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
