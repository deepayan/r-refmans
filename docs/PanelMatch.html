<!DOCTYPE html><html><head><title>Help for package PanelMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PanelMatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PanelMatch-package'><p>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</p></a></li>
<li><a href='#balance_scatter'><p>balance_scatter</p></a></li>
<li><a href='#dem'><p>County-level Democracy indicator</p></a></li>
<li><a href='#DisplayTreatment'><p>DisplayTreatment</p></a></li>
<li><a href='#findBinaryTreated'><p>findBinaryTreated</p></a></li>
<li><a href='#findContinuousTreated'><p>findContinuousTreated</p></a></li>
<li><a href='#get_covariate_balance'><p>Calculate covariate balance</p></a></li>
<li><a href='#get_set_treatment_effects'><p>get_set_treatment_effects</p></a></li>
<li><a href='#get.matchedsets'><p>get.matchedsets</p></a></li>
<li><a href='#matched_set'><p>matched_set</p></a></li>
<li><a href='#PanelEstimate'><p>PanelEstimate</p></a></li>
<li><a href='#PanelMatch'><p>PanelMatch</p></a></li>
<li><a href='#placebo_test'><p>placebo_test</p></a></li>
<li><a href='#plot.matched.set'><p>Plot the distribution of the sizes of matched sets.</p></a></li>
<li><a href='#plot.PanelEstimate'><p>Plot point estimates and standard errors from a PanelEstimate calculation.</p></a></li>
<li><a href='#print.matched.set'><p>Print <code>matched.set</code> objects.</p></a></li>
<li><a href='#summary.matched.set'><p>Summarize information about a <code>matched.set</code> object and the matched sets contained within them.</p></a></li>
<li><a href='#summary.PanelEstimate'><p>Get summaries of PanelEstimate objects/calculations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching Methods for Causal Inference with Time-Series
Cross-Sectional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a set of methodological tools
	     that enable researchers to apply matching methods to
	     time-series cross-sectional data. Imai, Kim, and Wang
	     (2021) <a href="http://web.mit.edu/insong/www/pdf/tscs.pdf">http://web.mit.edu/insong/www/pdf/tscs.pdf</a> 
	     proposes a nonparametric generalization of the
	     difference-in-differences estimator, which does not rely
	     on the linearity assumption as often done in
	     practice. Researchers first select a method of matching
	     each treated observation for a given unit in a
	     particular time period with control observations from
	     other units in the same time period that have a similar
	     treatment and covariate history. These methods include
	     standard matching methods based on propensity score and
	     Mahalanobis distance, as well as weighting methods. Once 
	     matching is done, both short-term and long-term average 
	     treatment effects for the treated can be estimated with 
	     standard errors. The package also offers a visualization 
	     technique that allows researchers to assess the quality 
	     of matches by examining the resulting covariate balance.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), data.table, ggplot2, CBPS, stats, graphics,
grDevices, MASS, Matrix, igraph, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insongkim/PanelMatch/issues">https://github.com/insongkim/PanelMatch/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-21 17:38:06 UTC; adamrauh</td>
</tr>
<tr>
<td>Author:</td>
<td>In Song Kim [aut, cre],
  Adam Rauh [aut],
  Erik Wang [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>In Song Kim &lt;insong@mit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-26 21:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='PanelMatch-package'>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</h2><span id='topic+PanelMatch-package'></span>

<h3>Description</h3>

<p>Implements a set of methodological tools
that enable researchers to apply matching methods to
time-series cross-sectional data. Imai, Kim, and Wang
(2021) proposes a nonparametric generalization of the
difference-in-differences estimator, which does not rely
on the linearity assumption as often done in
practice. Researchers first select a method of matching
each treated observation for a given unit in a
particular time period with control observations from
other units in the same time period that have a similar
treatment and covariate history. These methods include
standard matching methods based on propensity score and
Mahalanobis distance, as well as weighting methods. Once 
matching is done, both short-term and long-term average 
treatment effects for the treated can be estimated with 
standard errors. The package also offers a visualization 
technique that allows researchers to assess the quality 
of matches by examining the resulting covariate balance.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> PanelMatch</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 2.0.0-</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-09-02</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>
<p>Maintainer: In Song Kim <a href="mailto:insong@mit.edu">insong@mit.edu</a>
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim and Erik Wang. (2021)
</p>

<hr>
<h2 id='balance_scatter'>balance_scatter</h2><span id='topic+balance_scatter'></span>

<h3>Description</h3>

<p>Visualizing the standardized mean differences for covariates via a scatter plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_scatter(
  matched_set_list,
  xlim = c(0, 0.8),
  ylim = c(0, 0.8),
  main = "Standardized Mean Difference of Covariates",
  pchs = c(2, 3),
  covariates,
  data,
  x.axis.label = "Before refinement",
  y.axis.label = "After refinement",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_scatter_+3A_matched_set_list">matched_set_list</code></td>
<td>
<p>a list of one or more <code>matched.set</code> objects</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_xlim">xlim</code></td>
<td>
<p>xlim of the scatter plot. This is the same as the <code>xlim</code> argument in <code>plot</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_ylim">ylim</code></td>
<td>
<p>ylim of the scatter plot. This is the same as the <code>ylim</code> argument in <code>plot</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_main">main</code></td>
<td>
<p>title of the scatter plot. This is the same as the <code>main</code> argument in <code>plot</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_pchs">pchs</code></td>
<td>
<p>one or more pch indicators for the symbols on the scatter plot. You should specify a phc symbol for each matched.set you specify in matched_set_list. See <code>plot</code> for more information</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_covariates">covariates</code></td>
<td>
<p>variables for which balance is displayed</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_data">data</code></td>
<td>
<p>the same time series cross sectional data set used to create the matched sets.</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_x.axis.label">x.axis.label</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>balance_scatter</code> visualizes the standardized mean differences for each covariate.
Although users can use the scatter plot in a variety of ways, it is recommended that
the x-axis refers to balance for covariates before refinement, and y-axis
refers to balance after refinement. Users can utilize parameters powered by <code>plot</code>
in base R to further customize the figure.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a matched set without refinement
sets0 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "none",
                    data = dem, match.missing = FALSE,
                    covs.formula = ~ I(lag(y, 1:4)) + I(lag(tradewb, 1:4)),
                    size.match = 5, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)

# get a matched set with refinement using CBPS.match, setting the
# size of matched set to 5
sets1 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "mahalanobis",
                    data = dem, match.missing = FALSE,
                    covs.formula = ~ I(lag(y, 1:4)) + I(lag(tradewb, 1:4)),
                    size.match = 5, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)

# get another matched set with refinement using CBPS.weight
sets2 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "ps.weight",
                    data = dem, match.missing = FALSE,
                    covs.formula = ~ I(lag(y, 1:4)) + I(lag(tradewb, 1:4)),
                    size.match = 10, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)


# use the function to produce the scatter plot
balance_scatter(non_refined_set = sets0$att,
              matched_set_list = list(sets1$att, sets2$att),
              data = dem,
              covariates = c("y", "tradewb"))
# add legend
legend(x = 0, y = 0.8,
legend = c("mahalanobis",
           "PS weighting"),
y.intersp = 0.65,
x.intersp = 0.3,
xjust = 0,
pch = c(1, 3), pt.cex = 1,
bty = "n", ncol = 1, cex = 1, bg = "white")



</code></pre>

<hr>
<h2 id='dem'>County-level Democracy indicator</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>A dataset containing the democracy indicator for 184 countries from
1960 to 2010
</p>


<h3>Format</h3>

<p>A dataframe containing 9384 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> wbcode2. World Bank country ID
</p>
</li>
<li><p> year. year (1960&ndash;2010)
</p>
</li>
<li><p> dem. binary indicator of democracy as defined in Acemoglu et al.
</p>
</li>
<li><p> y log of GDP per capita in 2000 constant dollars (multiplied by 100)
</p>
</li>
<li><p> tradewb Exports plus Imports as a share of GDP from World Bank
</p>
</li></ul>



<h3>Source</h3>

<p>Acemoglu, Daron, Suresh Naidu, Pascual Restrepo, and James
A Robinson. &ldquo;Democracy does cause growth.&rdquo; Journal of Political
Economy.
</p>

<hr>
<h2 id='DisplayTreatment'>DisplayTreatment</h2><span id='topic+DisplayTreatment'></span>

<h3>Description</h3>

<p><code>DisplayTreatment</code> visualizes the treatment distribution
across units and time in a panel dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayTreatment(
  unit.id,
  time.id,
  treatment,
  data,
  color.of.treated = "red",
  color.of.untreated = "blue",
  title = "Treatment Distribution \n Across Units and Time",
  xlab = "Time",
  ylab = "Unit",
  x.size = NULL,
  y.size = NULL,
  legend.position = "none",
  x.angle = NULL,
  y.angle = NULL,
  legend.labels = c("not treated", "treated"),
  decreasing = FALSE,
  matched.set = NULL,
  show.set.only = FALSE,
  hide.x.tick.label = FALSE,
  hide.y.tick.label = FALSE,
  gradient.weights = FALSE,
  dense.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DisplayTreatment_+3A_unit.id">unit.id</code></td>
<td>
<p>Name of the unit identifier variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_time.id">time.id</code></td>
<td>
<p>Name of the time identifier variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_treatment">treatment</code></td>
<td>
<p>Name of the treatment variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_data">data</code></td>
<td>
<p>data.frame that contains the time series cross sectional data used for matching and estimation. Unit and time data must be integers. Time data must also be formatted as sequential integers that increase by one.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.treated">color.of.treated</code></td>
<td>
<p>Color of the treated observations provided as a character string (this includes hex values). Default is red.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.untreated">color.of.untreated</code></td>
<td>
<p>Color of the untreated observations provided as a character string (this includes hex values). Default is blue.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_title">title</code></td>
<td>
<p>Title of the plot provided as character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_xlab">xlab</code></td>
<td>
<p>Character label of the x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_ylab">ylab</code></td>
<td>
<p>Character label of the y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.size">x.size</code></td>
<td>
<p>Numeric size of the text for xlab or x axis tick labels. Assign x.size = NULL to use built in ggplot2 method of determining label size. 
When the length of the time period is long, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.size">y.size</code></td>
<td>
<p>Numeric size of the text for ylab or y axis tick labels. Assign y.size = NULL to use built in ggplot2 method of determining label size. 
When the number of units is large, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.position">legend.position</code></td>
<td>
<p>Position of the legend. Provide this according to ggplot2 standards.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.angle">x.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.angle">y.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.labels">legend.labels</code></td>
<td>
<p>Character vector of length two describing the
labels of the legend to be shown in the plot. ggplot2 standards are used.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Determines if display order should be increasing or decreasing by the amount of treatment received. Default is <code>decreasing</code> = FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_matched.set">matched.set</code></td>
<td>
<p>a matched.set object (optional) containing a single treated unit and a set of matched controls. If provided, this set will be highlighted on the resulting plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_show.set.only">show.set.only</code></td>
<td>
<p>logical. If TRUE, only the treated unit and control units contained in the provided <code>matched.set</code> object will be shown on the plot. 
Default is FALSE. If no <code>matched.set</code> is provided, then this argument will have no effect.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.x.tick.label">hide.x.tick.label</code></td>
<td>
<p>logical. If TRUE, x axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.y.tick.label">hide.y.tick.label</code></td>
<td>
<p>logical. If TRUE, y axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_gradient.weights">gradient.weights</code></td>
<td>
<p>logical. If TRUE, the &quot;darkness&quot;/shade of units in the provided <code>matched.set</code> object will be displayed according to their weight. Control units with higher weights will appear darker on the resulting plot. Control units with lower weights will appear lighter. This argument has no effect unless a <code>matched.set</code> is provided.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_dense.plot">dense.plot</code></td>
<td>
<p>logical. if TRUE, lines between tiles are removed on resulting plot. This is useful for producing more readable plots in situations where the number of units and/or time periods is very high.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DisplayTreatment</code> returns a treatment variation plot (using ggplot2),
which visualizes the variation of treatment across unit and time.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DisplayTreatment(unit.id = "wbcode2",
                 time.id = "year", legend.position = "none",
                 xlab = "year", ylab = "Country Code",
                 treatment = "dem", data = dem)


</code></pre>

<hr>
<h2 id='findBinaryTreated'>findBinaryTreated</h2><span id='topic+findBinaryTreated'></span>

<h3>Description</h3>

<p><code>findBinaryTreated</code> is used to identify t,id pairs of units for which a matched set might exist.
More precisely, it finds units for which at time t, the specified treatment has been applied, but at time t - 1, the treatment has not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findBinaryTreated(
  dmat,
  qoi.in,
  treatedvar,
  time.var,
  unit.var,
  hasbeensorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findBinaryTreated_+3A_dmat">dmat</code></td>
<td>
<p>Data frame or matrix containing data used to identify potential treated units. Must be specified in such a way that a combination of time and id variables will correspond to a unique row. Must also contain at least a binary treatment variable column as well.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that provides information about the binary treatment variable</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_time.var">time.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the time variable. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_unit.var">unit.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the variable used as a unit id. This data must be integer</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>findBinaryTreated</code> returns a subset of the data in the <code>dmat</code> data frame, containing only treated units for which a matched set might exist
</p>

<hr>
<h2 id='findContinuousTreated'>findContinuousTreated</h2><span id='topic+findContinuousTreated'></span>

<h3>Description</h3>

<p><code>findContinuousTreated</code> is used to identify t,id pairs of units for which a matched set might exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findContinuousTreated(
  dmat,
  treatedvar,
  time.var,
  unit.var,
  qoi,
  continuous.treatment.info
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findContinuousTreated_+3A_dmat">dmat</code></td>
<td>
<p>Sorted data frame or matrix containing data used to identify potential treated units. Must be specified in such a way that a combination of time and id variables will correspond to a unique row. Must also contain at least a continuous treatment variable column as well.</p>
</td></tr>
<tr><td><code id="findContinuousTreated_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that provides information about the continuous treatment variable</p>
</td></tr>
<tr><td><code id="findContinuousTreated_+3A_time.var">time.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the time variable. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="findContinuousTreated_+3A_unit.var">unit.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the variable used as a unit id. This data must be integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>findContinuousTreated</code> returns a subset of the data in the <code>dmat</code> data frame, containing only treated units for which a matched set might exist
</p>

<hr>
<h2 id='get_covariate_balance'>Calculate covariate balance</h2><span id='topic+get_covariate_balance'></span>

<h3>Description</h3>

<p>Calculate covariate balance for user specified covariates across matched sets. Balance is assessed by taking the average
of the difference between the values of the specified covariates for the treated unit(s) and the weighted average of
the control units across all matched sets. Results are standardized and are expressed in standard deviations.
Balance is calculated for each period in the specified lag window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covariate_balance(
  matched.sets,
  data,
  covariates,
  use.equal.weights = FALSE,
  verbose = TRUE,
  plot = FALSE,
  reference.line = TRUE,
  legend = TRUE,
  ylab = "SD",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covariate_balance_+3A_matched.sets">matched.sets</code></td>
<td>
<p>A <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_data">data</code></td>
<td>
<p>The time series cross sectional data set (as a <code>data.frame</code> object) used to produce the <code>matched.set</code> object. This data set should be identical to the one passed to <code>PanelMatch</code> and <code>PanelEstimate</code> to ensure consistent results.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_covariates">covariates</code></td>
<td>
<p>a character vector, specifying the names of the covariates for which the user is interested in calculating balance.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_use.equal.weights">use.equal.weights</code></td>
<td>
<p>logical. If set to TRUE, then equal weights will be assigned to control units, rather than using whatever calculated weights have been assigned. This is helpful for assessing the improvement in covariate balance as a result of refining the matched sets.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_verbose">verbose</code></td>
<td>
<p>logical. When TRUE, the function will return more information about the calculations/results. When FALSE, a more compact version of the results/calculations are returned.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_plot">plot</code></td>
<td>
<p>logical. When TRUE, a plot showing the covariate balance calculation results will be shown. When FALSE, no plot is made, but the results of the calculations are returned. default is FALSE</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_reference.line">reference.line</code></td>
<td>
<p>logical indicating whether or not a horizontal line should be present on the plot at y = 0. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_legend">legend</code></td>
<td>
<p>logical indicating whether or not a legend identifying the variables should be included on the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis. Default is &quot;SD&quot;. This is the same as the ylab argument to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to the <code>plot</code> function in base R.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#add some additional data to data set for demonstration purposes
dem$rdata &lt;- runif(runif(nrow(dem)))
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, time.id = "year", unit.id = "wbcode2", treatment = "dem",
                    outcome.var ="y", refinement.method = "mahalanobis",
                    data = dem, match.missing = TRUE,
                    covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                    size.match = 5, qoi = "att")
get_covariate_balance(pm.obj$att, dem, covariates = c("tradewb", "rdata"),
                         ylim = c(-2,2))
get_covariate_balance(pm.obj$att, dem, covariates = c("tradewb", "rdata"),
                         plot = TRUE, ylim = c(-2,2))

</code></pre>

<hr>
<h2 id='get_set_treatment_effects'>get_set_treatment_effects</h2><span id='topic+get_set_treatment_effects'></span>

<h3>Description</h3>

<p>Calculates the treatment effect size at the matched set level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_set_treatment_effects(pm.obj, data, lead)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_set_treatment_effects_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_data">data</code></td>
<td>
<p>data.frame with the original data</p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_lead">lead</code></td>
<td>
<p>integer (or integer vector) indicating the time period(s) in the future for which the treatment effect size will be calculated. Calculations will be made for the period t + lead, where t is the time of treatment. If more than one lead value is provided, then calculations will be performed for each value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the size of treatment effects for each matched set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE,
                         placebo.test = FALSE)
set.effects &lt;- get_set_treatment_effects(pm.obj = PM.results, data = dem, lead = 0)


</code></pre>

<hr>
<h2 id='get.matchedsets'>get.matchedsets</h2><span id='topic+get.matchedsets'></span>

<h3>Description</h3>

<p><code>get.matchedsets</code> is used to identify matched sets for a given unit with a specified i, t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.matchedsets(
  t,
  id,
  data,
  L,
  t.column,
  id.column,
  treatedvar,
  hasbeensorted = FALSE,
  match.on.missingness = TRUE,
  matching = TRUE,
  continuous = FALSE,
  continuous.treatment.info = NULL,
  qoi.in,
  restrict.control.period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.matchedsets_+3A_t">t</code></td>
<td>
<p>integer vector specifying the times of treated units for which matched sets should be found. This vector should be the same length as the following <code>id</code> parameter &ndash; the entries at corresponding indices in each vector should form the t,id pair of a specified treatment unit.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id">id</code></td>
<td>
<p>integer vector specifying the unit ids of treated units for which matched sets should be found. note that both <code>t</code> and <code>id</code> can be of length 1</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_data">data</code></td>
<td>
<p>data frame containing the data to be used for finding matched sets.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_l">L</code></td>
<td>
<p>An integer value indicating the length of treatment history to be matched</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_t.column">t.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the time variable. Each specified entry in <code>t</code> should be somewhere in this column in the data. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id.column">id.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the unit id variable. Each specified entry in <code>id</code> should be somewhere in this column in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the binary treatment variable.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_match.on.missingness">match.on.missingness</code></td>
<td>
<p>TRUE/FALSE indicating whether or not the user wants to &quot;match on missingness.&quot; That is, should units with NAs in their treatment history windows be matched with control units that have NA's in corresponding places?</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not the treatment history should be used for matching. This should almost always be set to TRUE, except for specific situations where the user is interested in particular diagnostic questions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.matchedsets</code> returns a &quot;matched set&quot; object, which primarily contains a named list of vectors. Each vector is a &quot;matched set&quot; containing the unit ids included in a matched set. The list names will indicate an i,t pair (formatted as &quot;&lt;i variable&gt;.&lt;t variable&gt;&quot;) to which the vector/matched set corresponds.
</p>

<hr>
<h2 id='matched_set'>matched_set</h2><span id='topic+matched_set'></span>

<h3>Description</h3>

<p><code>matched_set</code> is a constructor for the <code>matched.set</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched_set(matchedsets, id, t, L, t.var, id.var, treatment.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matched_set_+3A_matchedsets">matchedsets</code></td>
<td>
<p>a list of treated units and matched control units. Each element in the list should be a vector of control unit ids.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id">id</code></td>
<td>
<p>A vector containing the ids of treated units</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t">t</code></td>
<td>
<p>A vector containing the times of treatment for treated units.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_l">L</code></td>
<td>
<p>integer specifying the length of the lag window used in matching</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_treatment.var">treatment.var</code></td>
<td>
<p>string specifying the treatment variable.
</p>
<p>The constructor function returns a <code>matched.set</code> object.
<code>matched.set</code> objects are a modified lists. Each element in the list is a vector of ids
corresponding to the control unit ids in a matched set.
Additionally, these vectors might have additional attributes &ndash; &quot;weights&quot;. These correspond to the
weights assigned to each control unit,
as determined by the specified refinement method.
Each element in the list also has a name, which corresponds to the unit id of the treated unit and time of treatment,
concatenated together and separated by a period. <code>matched.set</code> objects also have a number of
methods defined: <code>summary</code>, <code>plot</code>, and <code>`[`</code>. <code>matched.set</code> objects can be modified manually
as long as these conventions (and conventions about other attributes) are maintained. It is important to note that <code>matched.set</code> objects
are distinct from <code>PanelMatch</code> objects. <code>matched.set</code> objects are often contained within <code>PanelMatch</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users should never need to use this function by itself. See below for more about <code>matched.set</code> objects.
</p>


<h3>Value</h3>

<p><code>matched.set</code> objects have additional attributes. These reflect the specified parameters when using the <code>PanelMatch</code> function:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>an integer value indicating the length of treatment history to be used for matching. Treated and control units are matched based on whether or not they have exactly matching treatment histories in the lag window.</p>
</td></tr>
<tr><td><code>t.var</code></td>
<td>
<p>time variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>id.var</code></td>
<td>
<p>unit id variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>treatment.var</code></td>
<td>
<p>treatment variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class of the object: should always be &quot;matched.set&quot;</p>
</td></tr>
<tr><td><code>refinement.method</code></td>
<td>
<p>method used to refine and/or weight the control units in each set.</p>
</td></tr>
<tr><td><code>covs.formula</code></td>
<td>
<p>One sided formula indicating which variables should be used for matching and refinement</p>
</td></tr>
<tr><td><code>match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories</p>
</td></tr>
<tr><td><code>max.match.size</code></td>
<td>
<p>Maximum size of the matched sets after refinement. This argument only affects results when using a matching method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;adamrauh@mit.edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>

<hr>
<h2 id='PanelEstimate'>PanelEstimate</h2><span id='topic+PanelEstimate'></span>

<h3>Description</h3>

<p><code>PanelEstimate</code> estimates a causal quantity of interest, including the average treatment effect for
treated or control units (att and atc, respectively), the average effect of treatment reversal on reversed units, or average treatment effect (ate), as specified in <code>PanelMatch</code>.
This is done by estimating the counterfactual outcomes for each treated unit using
matched sets. Users will provide matched sets that were obtained by the
<code>PanelMatch</code> function and obtain point estimates via a
weighted average computation with weighted bootstrap standard errors. Point estimates and standard errors will be
produced for each period in the lead window specified by the <code>lead</code> argument from <code>PanelMatch</code>.
Users may run multiple estimations by providing lists of each argument to the function.
However, in this format, every argument must be explicitly specified in each configuration
and must adhere to the same data types/structures outlined below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelEstimate(
  sets,
  data,
  number.iterations = 1000,
  df.adjustment = FALSE,
  confidence.level = 0.95,
  moderator = NULL,
  se.method = "bootstrap",
  pooled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PanelEstimate_+3A_sets">sets</code></td>
<td>
<p>A <code>PanelMatch</code> object attained via the
<code>PanelMatch</code> function.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_data">data</code></td>
<td>
<p>The same time series cross sectional data set provided to the PanelMatch function used to produce
the matched sets.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_number.iterations">number.iterations</code></td>
<td>
<p>If using bootstrapping for calculating standard errors, this is the number of bootstrap iterations. Provide as integer. If se.method is not equal to &quot;bootstrap&quot;, this argument has no effect.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_df.adjustment">df.adjustment</code></td>
<td>
<p>A logical value indicating whether or not a
degree-of-freedom adjustment should be performed for the standard error
calculation. The default is <code>FALSE</code>. This parameter is only available for the bootstrap method of standard error calculation.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_confidence.level">confidence.level</code></td>
<td>
<p>A numerical value specifying the confidence level and range of interval
estimates for statistical inference. The default is .95.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_moderator">moderator</code></td>
<td>
<p>The name of a moderating variable, provided as a character string. If a moderating variable is provided,the returned object will be a list of <code>PanelEstimate</code> objects. The names of the list will reflect the different values of the moderating variable. More specifically, the moderating variable values will be converted to syntactically proper names using <code>make.names</code>.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_se.method">se.method</code></td>
<td>
<p>Method used for calculating standard errors, provided as a character string. Users must choose between &quot;bootstrap&quot;, &quot;conditional&quot;, and &quot;unconditional&quot; methods. Default is &quot;bootstrap&quot;. &quot;bootstrap&quot; uses a block bootstrapping procedure to calculate standard errors. The conditional method calculates the variance of the estimator, assuming independence across units but not across time. The unconditional method also calculates the variance of the estimator analytically, but makes no such assumptions about independence across units. When the quantity of interest is &quot;att&quot;, &quot;atc&quot;, or &quot;art&quot;, all methods are available. Only &quot;bootstrap&quot; is available for the ate. See Section 3.4 of Imai, Kim, and Wang (2021) for more details.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_pooled">pooled</code></td>
<td>
<p>Logical. If TRUE, estimates and standard errors are returned for treatment effects pooled across the entire lead window. Only available for <code>se.method = ``bootstrap''</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PanelEstimate</code> returns a list of class
&lsquo;PanelEstimate&rsquo; containing the following components:
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>the point estimates of the quantity of interest for the lead periods specified</p>
</td></tr>
<tr><td><code>se.method</code></td>
<td>
<p>The method used to calculate standard errors. This is the same as the argument provided to the function.</p>
</td></tr>
<tr><td><code>bootstrapped.estimates</code></td>
<td>
<p>the bootstrapped point estimate values, when applicable</p>
</td></tr>
<tr><td><code>bootstrap.iterations</code></td>
<td>
<p>the number of iterations used in bootstrapping, when applicable</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>refinement method used to create the matched sets from which the estimates were calculated</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>See PanelMatch argument <code>lag</code> for more information.</p>
</td></tr>
<tr><td><code>lead</code></td>
<td>
<p>The lead window sequence for which <code>PanelEstimate</code> is producing point estimates and standard errors.</p>
</td></tr>
<tr><td><code>confidence.level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
<tr><td><code>qoi</code></td>
<td>
<p>the quantity of interest</p>
</td></tr>
<tr><td><code>matched.sets</code></td>
<td>
<p>the refined matched sets used to produce the estimations</p>
</td></tr>
<tr><td><code>standard.error</code></td>
<td>
<p>the standard error(s) of the point estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = TRUE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem, number.iterations = 100)



</code></pre>

<hr>
<h2 id='PanelMatch'>PanelMatch</h2><span id='topic+PanelMatch'></span>

<h3>Description</h3>

<p>Create refined/weighted sets of treated and control units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelMatch(
  lag,
  time.id,
  unit.id,
  treatment,
  refinement.method,
  size.match = 10,
  data,
  match.missing = TRUE,
  covs.formula = NULL,
  verbose = FALSE,
  qoi,
  lead = 0,
  outcome.var,
  exact.match.variables = NULL,
  forbid.treatment.reversal = FALSE,
  matching = TRUE,
  listwise.delete = FALSE,
  use.diagonal.variance.matrix = FALSE,
  restrict.control.period = NULL,
  placebo.test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PanelMatch_+3A_lag">lag</code></td>
<td>
<p>An integer value indicating the length of treatment history periods to be matched on</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_time.id">time.id</code></td>
<td>
<p>A character string indicating the name of the time 
variable in the <code>data</code>. This data currently must be formatted as sequential integers.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_unit.id">unit.id</code></td>
<td>
<p>A character string indicating the name of unit identifier in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_treatment">treatment</code></td>
<td>
<p>A character string indicating the name of the treatment variable in the <code>data</code>. 
The treatment must be a binary indicator variable (integer with 0 for the control group and 1 for the treatment group).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_refinement.method">refinement.method</code></td>
<td>
<p>A character string specifying the matching or weighting method to be used for refining the matched sets. The user can choose &quot;mahalanobis&quot;, &quot;ps.match&quot;, &quot;CBPS.match&quot;, &quot;ps.weight&quot;, &quot;CBPS.weight&quot;, &quot;ps.msm.weight&quot;, &quot;CBPS.msm.weight&quot;, or &quot;none&quot;. The first three methods will use the <code>size.match</code> argument to create sets of at most <code>size.match</code> closest control units. Choosing &quot;none&quot; will assign equal weights to all control units in each matched set.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_size.match">size.match</code></td>
<td>
<p>An integer dictating the number of permitted closest control units in a matched set after refinement. 
This argument only affects results when using a matching method (&quot;mahalanobis&quot; or any of the refinement methods that end in &quot;.match&quot;).
This argument is not needed and will have no impact if included when a weighting method is specified (any <code>refinement.method</code> that includes &quot;weight&quot; in the name).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> object containing time series cross sectional data. 
Time data must be sequential integers that increase by 1. Unit identifiers must be integers. Treatment data must be binary.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_match.missing">match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories. Default is TRUE. When FALSE, neither treated nor control units are allowed to have missing treatment data in the lag window.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_covs.formula">covs.formula</code></td>
<td>
<p>One sided formula object indicating which variables should be used for matching and refinement. 
Argument is not needed if <code>refinement.method</code> is set to &quot;none&quot;
If the user wants to include lagged variables, this can be done using a function, &quot;lag()&quot;, which takes two, unnamed, 
positional arguments. The first is the name of the variable which you wish to lag. The second is the lag window, 
specified as an integer sequence in increasing order.
For instance, I(lag(x, 1:4)) will then add new columns to the data for variable &quot;x&quot; for time t-1, t-2, t-3, and t-4 internally
and use them for defining/measuring similarity between units. 
Other transformations using the I() function, such as I(x^2) are also permitted.
The variables specified in this formula are used to define the similarity/distances between units.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_verbose">verbose</code></td>
<td>
<p>option to include more information about the <code>matched.set</code> object calculations, 
like the distances used to create the refined sets and weights.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_qoi">qoi</code></td>
<td>
<p>quantity of interest, provided as a string: <code>att</code> (average treatment effect on treated units), <code>atc</code> (average treatment effect of treatment on the control units) <code>art</code> (average effect of treatment reversal for units that experience treatment reversal), or <code>ate</code> (average treatment effect). 
Note that the qoi for MSM methods will give the estimated average treatment effect of being treated for a chosen <code>lead</code> 
time periods. This differs slightly from the non-MSM methods, where treatment reversal is permitted.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_lead">lead</code></td>
<td>
<p>integer sequence specifying the lead window, for which qoi point estimates (and standard errors) will 
ultimately be produced. Default is 0 (which corresponds to contemporaneous treatment effect).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_outcome.var">outcome.var</code></td>
<td>
<p>A character string identifying the outcome variable.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_exact.match.variables">exact.match.variables</code></td>
<td>
<p>character vector giving the names of variables to be exactly matched on. These should be time invariant variables. 
Exact matching for time varying covariates is not currently supported.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_forbid.treatment.reversal">forbid.treatment.reversal</code></td>
<td>
<p>Logical indicating whether or not it is permissible for treatment to reverse in the specified lead window. 
This must be set to TRUE for MSM methods. When set to TRUE, only matched sets for treated units where treatment is 
applied continuously in the lead window are included in the results. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not any matching on treatment history should be performed. 
This is primarily used for diagnostic purposes, and most users will never need to set this to FALSE. Default is TRUE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_listwise.delete">listwise.delete</code></td>
<td>
<p>TRUE/FALSE indicating whether or not missing data should be handled using listwise deletion or the package's default missing data handling procedures. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_use.diagonal.variance.matrix">use.diagonal.variance.matrix</code></td>
<td>
<p>TRUE/FALSE indicating whether or not a regular covariance matrix should be used in mahalanobis distance calculations during refinement, 
or if a diagonal matrix with only covariate variances should be used instead. 
In many cases, setting this to TRUE can lead to better covariate balance, especially when there is 
high correlation between variables. Default is FALSE. This argument is only necessary when 
<code>refinement.method = mahalanobis</code> and will have no impact otherwise.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_restrict.control.period">restrict.control.period</code></td>
<td>
<p>(optional) integer specifying the number of pre-treatment periods that treated units and potentially matched control units should be non-NULL and in the control state. For instance, specifying 4 would mean that the treatment history cannot contain any missing data or treatment from t-4 to t.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_placebo.test">placebo.test</code></td>
<td>
<p>logical TRUE/FALSE. indicates whether or not you want to be able to run a placebo test. This will add additional requirements on the data &ndash; specifically, it requires that no unit included in the matching/refinement process can having missing outcome data over the lag window. Additionally, you should not use the outcome variable in refinement when <code>placebo.test = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PanelMatch</code> identifies a matched set for each treated
observation. Specifically, for a given treated unit, the matched
set consists of control observations that have an identical
treatment history up to a number of <code>lag</code>
time periods. Researchers must specify <code>lag</code>. A further refinement of
the matched set may be performed by setting a maximum size of each matched
set, <code>size.match</code> (the maximum number of control units that can be matched to a treated unit). Users can 
also specify covariates that should be used to identify
similar control units and a method for defining similarity/distance between units. This is done 
via the <code>covs.formula</code> and <code>refinement.method</code> arguments, respectively, which are explained in more detail below.
</p>


<h3>Value</h3>

<p><code>PanelMatch</code> returns an object of class &quot;PanelMatch&quot;. This is a list that contains a few specific elements: 
First, a <code>matched.set</code> object(s) that has the same name as the provided qoi if the qoi is &quot;att&quot;, &quot;art&quot;, or &quot;atc&quot;. 
If qoi = &quot;ate&quot; then two <code>matched.set</code> objects will be attached, named &quot;att&quot; and &quot;atc.&quot; Please consult the documentation for
<code>matched_set</code> to read more about the structure and usage of <code>matched.set</code> objects. Also, see the vignette page about matched.set objects for 
more information about these objects: <code>vignette("matched_set_objects", package = "PanelMatch")</code>.
The <code>PanelMatch</code> object also has some additional attributes:
</p>
<table>
<tr><td><code>qoi</code></td>
<td>
<p>The qoi specified in the original function call</p>
</td></tr>
<tr><td><code>lead</code></td>
<td>
<p>the lead window specified in the original function call</p>
</td></tr>
<tr><td><code>forbid.treatment.reversal</code></td>
<td>
<p>logial value matching the forbid.treatment.reversal parameter provided in the function call.</p>
</td></tr>
<tr><td><code>outcome.var</code></td>
<td>
<p>character string matching the outcome variable provided in the original function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;amrauh@umich.edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "mahalanobis", 
                         data = dem, match.missing = TRUE, 
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
#not including any lagged variables
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "mahalanobis", 
                         data = dem, match.missing = TRUE, 
                         covs.formula = ~ tradewb, 
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)


</code></pre>

<hr>
<h2 id='placebo_test'>placebo_test</h2><span id='topic+placebo_test'></span>

<h3>Description</h3>

<p>Calculates results for a placebo test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placebo_test(
  pm.obj,
  data,
  lag.in = NULL,
  number.iterations = 1000,
  confidence.level = 0.95,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placebo_test_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="placebo_test_+3A_data">data</code></td>
<td>
<p>data.frame with the original data</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_lag.in">lag.in</code></td>
<td>
<p>integer indicating earliest the time period(s) in the future for which the placebo test change in outcome will be calculated. Calculations will be made over the period t - max(lag) to t-2, where t is the time of treatment. The results are similar to those returned by PanelEstimate, except t-1 is used as the period of comparison, rather than the lead window.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer specifying the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_confidence.level">confidence.level</code></td>
<td>
<p>confidence level for the calculated standard error intervals</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether or not a plot should be generated, or just return the raw data from the calculations</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_...">...</code></td>
<td>
<p>extra arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the results of a placebo test, looking at the change in outcome at time = t-1, compared to other pre-treatment periods in the lag window.
</p>


<h3>Value</h3>

<p>list with 2 elements: &quot;estimates&quot;, which contains the point estimates for the test and &quot;bootstrapped.estimates&quot;, containing the bootstrapped point estimates for the test for each specified lag window period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE,
                         placebo.test = TRUE)
placebo_test(PM.results, data = dem, number.iterations = 100, plot = FALSE)


</code></pre>

<hr>
<h2 id='plot.matched.set'>Plot the distribution of the sizes of matched sets.</h2><span id='topic+plot.matched.set'></span>

<h3>Description</h3>

<p>A plot method for creating a histogram of the distribution of the sizes of matched sets.
This method accepts all standard optional <code>hist</code> arguments via the <code>...</code> argument.
By default, empty matched sets (treated units that could not be
matched with any control units) are noted as a vertical bar at x = 0 and not included in the
regular histogram. See the <code>include.empty.sets</code> argument for more information about this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
plot(
  x,
  ...,
  border = NA,
  col = "grey",
  ylab = "Frequency of Size",
  xlab = "Matched Set Size",
  lwd = NULL,
  main = "Distribution of Matched Set Sizes",
  freq = TRUE,
  include.empty.sets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_border">border</code></td>
<td>
<p>default is NA. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_col">col</code></td>
<td>
<p>default is &quot;grey&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Frequency of Size&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Matched Set Size&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_lwd">lwd</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_main">main</code></td>
<td>
<p>default is &quot;Distribution of Matched Set Sizes&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_freq">freq</code></td>
<td>
<p>default is TRUE. See <code>freq</code> argument in <code>hist</code> function for more.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_include.empty.sets">include.empty.sets</code></td>
<td>
<p>logical value indicating whether or not empty sets should be included in the histogram. default is FALSE. If FALSE, then empty sets will be noted as a separate vertical bar at x = 0. If TRUE, empty sets will be included as normal sets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
plot(PM.results$att)
plot(PM.results$att, include.empty.sets = TRUE)

</code></pre>

<hr>
<h2 id='plot.PanelEstimate'>Plot point estimates and standard errors from a PanelEstimate calculation.</h2><span id='topic+plot.PanelEstimate'></span>

<h3>Description</h3>

<p>The <code>plot.PanelEstimate</code> method takes an object returned by the <code>PanelEstimate</code> function and plots the calculated 
point estimates and standard errors over the specified <code>lead</code> time period. 
The only mandatory argument is an object of the <code>PanelEstimate</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
plot(
  x,
  ylab = "Estimated Effect of Treatment",
  xlab = "Time",
  main = "Estimated Effects of Treatment Over Time",
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PanelEstimate_+3A_x">x</code></td>
<td>
<p>a <code>PanelEstimate</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Estimated Effect of Treatment. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Time&quot;. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_main">main</code></td>
<td>
<p>default is &quot;Estimated Effects of Treatment Over Time&quot;. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylim">ylim</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "mahalanobis", 
                         data = dem, match.missing = TRUE, 
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem)
plot(PE.results)


</code></pre>

<hr>
<h2 id='print.matched.set'>Print <code>matched.set</code> objects.</h2><span id='topic+print.matched.set'></span>

<h3>Description</h3>

<p>Print <code>matched.set</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
print(x, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print</code></p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in expanded/raw list form.
The verbose form is not recommended unless the data set is small. Default is FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
print(PM.results$att)



</code></pre>

<hr>
<h2 id='summary.matched.set'>Summarize information about a <code>matched.set</code> object and the matched sets contained within them.</h2><span id='topic+summary.matched.set'></span>

<h3>Description</h3>

<p>A method for viewing summary data about the sizes of matched sets and metadata about how they were created. This method
accepts all standard <code>summary</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
summary(object, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.matched.set_+3A_object">object</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to be passed to the <code>summary</code> function</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>Logical value specifying whether or not a longer, more verbose summary should be calculated and returned. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object with either 5 or 1 element(s), depending on whether or not <code>verbose</code> is set to <code>TRUE</code> or not.
</p>
<table>
<tr><td><code>overview</code></td>
<td>
<p>A <code>data.frame</code> object containing information about the treated units (unit id, time of treatment), and the number of matched control units with weights zero and above.</p>
</td></tr>
<tr><td><code>set.size.summary</code></td>
<td>
<p>a <code>summary</code> object summarizing the minimum, maximum, and IQR of matched set sizes</p>
</td></tr>
<tr><td><code>number.of.treated.units</code></td>
<td>
<p>The number of unit, time pairs that are considered to be &quot;treated&quot; units</p>
</td></tr>
<tr><td><code>num.units.empty.set</code></td>
<td>
<p>The number of units treated at a particular time that were not able to be matched to any control units</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>The size of the lag window used for matching on treatment history. This affects which treated and control units are matched.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
summary(PM.results$att)



</code></pre>

<hr>
<h2 id='summary.PanelEstimate'>Get summaries of PanelEstimate objects/calculations</h2><span id='topic+summary.PanelEstimate'></span>

<h3>Description</h3>

<p><code>summary.PanelEstimate</code> takes an object returned by
<code>PanelEstimate</code>, and returns a summary table of point
estimates and confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
summary(object, verbose = TRUE, bias.corrected = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PanelEstimate_+3A_object">object</code></td>
<td>
<p>A PanelEstimate object</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in an expanded form. Default is TRUE</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_bias.corrected">bias.corrected</code></td>
<td>
<p>logical indicating whether or not bias corrected estimates should be provided. Default is FALSE. This argument only applies for standard errors calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently, no additional arguments are supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "none", 
                         data = dem, match.missing = TRUE, 
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem, number.iterations = 500)
summary(PE.results)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
