<!DOCTYPE html><html><head><title>Help for package PanelMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PanelMatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PanelMatch-package'><p>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</p></a></li>
<li><a href='#balance_scatter'><p>balance_scatter</p></a></li>
<li><a href='#build_maha_mats'><p>build_maha_mats</p>
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set</a></li>
<li><a href='#build_ps_data'><p>build_ps_data</p></a></li>
<li><a href='#calculate_estimates'><p>calculate_estimates</p></a></li>
<li><a href='#calculate_placebo_estimates'><p>calculate_placebo_estimates</p></a></li>
<li><a href='#calculate_point_estimates'><p>calculate_point_estimates</p>
Helper function that calculates the point estimates for the specified QOI</a></li>
<li><a href='#check_time_data'><p>check_time_data</p></a></li>
<li><a href='#clean_leads'><p>clean_leads</p>
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.</a></li>
<li><a href='#dem'><p>Country-level Democracy indicator</p></a></li>
<li><a href='#DisplayTreatment'><p>DisplayTreatment</p></a></li>
<li><a href='#enforce_lead_restrictions'><p>enforce_lead_restrictions</p>
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)</a></li>
<li><a href='#equality_four'><p>equality_four</p>
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)</a></li>
<li><a href='#equality_four_placebo'><p>equality_four_placebo</p></a></li>
<li><a href='#expand_treated_ts'><p>expand_treated_ts</p>
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets</a></li>
<li><a href='#extract_differences'><p>extract_differences</p>
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.</a></li>
<li><a href='#find_ps'><p>find_ps</p></a></li>
<li><a href='#findBinaryTreated'><p>findBinaryTreated</p></a></li>
<li><a href='#get_covariate_balance'><p>Calculate covariate balance</p></a></li>
<li><a href='#get_set_treatment_effects'><p>get_set_treatment_effects</p></a></li>
<li><a href='#get.matchedsets'><p>get.matchedsets</p></a></li>
<li><a href='#getDits'><p>getDits</p>
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.</a></li>
<li><a href='#getWits'><p>getWits</p>
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.</a></li>
<li><a href='#handle_bootstrap'><p>handle_bootstrap</p></a></li>
<li><a href='#handle_bootstrap_parallel'><p>handle_bootstrap_parallel</p></a></li>
<li><a href='#handle_bootstrap_placebo'><p>handle_bootstrap_placebo</p></a></li>
<li><a href='#handle_bootstrap_placebo_parallel'><p>handle_bootstrap_placebo_parallel</p></a></li>
<li><a href='#handle_conditional_se'><p>handle_conditional_se</p>
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</a></li>
<li><a href='#handle_mahalanobis_calculations'><p>handle_mahalanobis_calculations</p>
Returns a matched.set object with weights for control units, along with some other metadata</a></li>
<li><a href='#handle_missing_data'><p>handle_missing_data</p></a></li>
<li><a href='#handle_moderating_variable'><p>handle_moderating_variable</p>
handles moderating variable calculations: In practice, this just involves slicing the data up according to the moderator, calling PanelEstimate() and putting everything back together This function creates the sets of objects on which PanelEstimate() will be called. It identifies the set of valid values the moderating variable can take on.</a></li>
<li><a href='#handle_ps_match'><p>handle_ps_match</p>
Returns a matched.set object with weights for control units, along with some other metadata</a></li>
<li><a href='#handle_ps_weighted'><p>handle_ps_weighted</p></a></li>
<li><a href='#handle_unconditional_se'><p>handle_conditional_se</p>
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</a></li>
<li><a href='#identifyDirectionalChanges'><p>identifyDirectionalChanges</p>
Identifies changes in treatment variable for treated and control observations</a></li>
<li><a href='#lwd_refinement'><p>lwd_refinement</p>
master function that performs refinement with listwise deletion = TRUE</a></li>
<li><a href='#lwd_units'><p>lwd_units</p>
helper function that actually subsets sets down to contain units with complete data</a></li>
<li><a href='#matched_set'><p>matched_set</p></a></li>
<li><a href='#merge_formula'><p>merge_formula</p></a></li>
<li><a href='#PanelEstimate'><p>PanelEstimate</p></a></li>
<li><a href='#PanelMatch'><p>PanelMatch</p></a></li>
<li><a href='#parse_and_prep'><p>parse_and_prep</p></a></li>
<li><a href='#pcs'><p>Prepare Control Units</p>
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.</a></li>
<li><a href='#perform_refinement'><p>perform_refinement</p>
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()</a></li>
<li><a href='#perunitSum'><p>perunitSum</p>
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)</a></li>
<li><a href='#perunitSum_Dit'><p>perunitSum_Dit</p>
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit</a></li>
<li><a href='#placebo_test'><p>placebo_test</p></a></li>
<li><a href='#plot.matched.set'><p>Plot the distribution of the sizes of matched sets.</p></a></li>
<li><a href='#plot.PanelEstimate'><p>Plot point estimates and standard errors from a PanelEstimate calculation.</p></a></li>
<li><a href='#prepare_data'><p>prepare_data</p>
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.</a></li>
<li><a href='#print.matched.set'><p>Print <code>matched.set</code> objects.</p></a></li>
<li><a href='#set_lwd_refinement'><p>set_lwd_refinement</p>
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.</a></li>
<li><a href='#summary.matched.set'><p>Summarize information about a <code>matched.set</code> object and the matched sets contained within them.</p></a></li>
<li><a href='#summary.PanelEstimate'><p>Get summaries of PanelEstimate objects/calculations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching Methods for Causal Inference with Time-Series
Cross-Sectional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a set of methodological tools
	     that enable researchers to apply matching methods to
	     time-series cross-sectional data. Imai, Kim, and Wang
	     (2023) <a href="http://web.mit.edu/insong/www/pdf/tscs.pdf">http://web.mit.edu/insong/www/pdf/tscs.pdf</a> 
	     proposes a nonparametric generalization of the
	     difference-in-differences estimator, which does not rely
	     on the linearity assumption as often done in
	     practice. Researchers first select a method of matching
	     each treated observation for a given unit in a
	     particular time period with control observations from
	     other units in the same time period that have a similar
	     treatment and covariate history. These methods include
	     standard matching methods based on propensity score and
	     Mahalanobis distance, as well as weighting methods. Once 
	     matching and refinement is done,  
	     treatment effects can be estimated with 
	     standard errors. The package also offers diagnostics for researchers to assess the quality 
	     of their results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), data.table, ggplot2, CBPS, stats, graphics,
MASS, Matrix, doParallel, foreach, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insongkim/PanelMatch/issues">https://github.com/insongkim/PanelMatch/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-03 04:49:15 UTC; adamrauh</td>
</tr>
<tr>
<td>Author:</td>
<td>In Song Kim [aut, cre],
  Adam Rauh [aut],
  Erik Wang [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>In Song Kim &lt;insong@mit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 09:47:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='PanelMatch-package'>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</h2><span id='topic+PanelMatch-package'></span>

<h3>Description</h3>

<p>Implements a set of methodological tools
that enable researchers to apply matching methods to
time-series cross-sectional data. Imai, Kim, and Wang
(2023) proposes a nonparametric generalization of the
difference-in-differences estimator, which does not rely
on the linearity assumption as often done in
practice. Researchers first select a method of matching
each treated observation for a given unit in a
particular time period with control observations from
other units in the same time period that have a similar
treatment and covariate history. These methods include
standard matching methods based on propensity score and
Mahalanobis distance, as well as weighting methods. Once 
matching is done, both short-term and long-term average 
treatment effects for the treated can be estimated with 
standard errors. The package also offers a visualization 
technique that allows researchers to assess the quality 
of matches by examining the resulting covariate balance.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>
<p>Maintainer: In Song Kim <a href="mailto:insong@mit.edu">insong@mit.edu</a>
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim and Erik Wang. (2023)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/insongkim/PanelMatch/issues">https://github.com/insongkim/PanelMatch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='balance_scatter'>balance_scatter</h2><span id='topic+balance_scatter'></span>

<h3>Description</h3>

<p>Visualizing the standardized mean differences for covariates via a scatter plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_scatter(
  matched_set_list,
  xlim = c(0, 0.8),
  ylim = c(0, 0.8),
  main = "Standardized Mean Difference of Covariates",
  pchs = c(2, 3),
  covariates,
  data,
  x.axis.label = "Before refinement",
  y.axis.label = "After refinement",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_scatter_+3A_matched_set_list">matched_set_list</code></td>
<td>
<p>a list of one or more <code>matched.set</code> objects</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_xlim">xlim</code></td>
<td>
<p>xlim of the scatter plot. This is the same as the <code>xlim</code> argument in <code>plot()</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_ylim">ylim</code></td>
<td>
<p>ylim of the scatter plot. This is the same as the <code>ylim</code> argument in <code>plot()</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_main">main</code></td>
<td>
<p>title of the scatter plot. This is the same as the <code>main</code> argument in <code>plot()</code></p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_pchs">pchs</code></td>
<td>
<p>one or more pch indicators for the symbols on the scatter plot. You should specify a pch symbol for each matched.set you specify in matched_set_list. See <code>plot()</code> for more information</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_covariates">covariates</code></td>
<td>
<p>variables for which balance is displayed</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_data">data</code></td>
<td>
<p>the same time series cross sectional data set used to create the matched sets.</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_x.axis.label">x.axis.label</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="balance_scatter_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>balance_scatter</code> visualizes the standardized mean differences for each covariate.
Although users can use the scatter plot in a variety of ways, it is recommended that
the x-axis refers to balance for covariates before refinement, and y-axis
refers to balance after refinement. Users can utilize parameters powered by <code>plot()</code>
in base R to further customize the figure.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
# get a matched set without refinement
sets0 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "none",
                    data = dem.sub, match.missing = FALSE,
                    size.match = 5, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)

# get a matched set with refinement using propensity score matching, setting the
# size of matched set to 5
sets1 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "ps.match",
                    data = dem.sub, match.missing = FALSE,
                    covs.formula = ~ tradewb,
                    size.match = 5, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)

# get another matched set with refinement using propensity score weighting
sets2 &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                    treatment = "dem", refinement.method = "ps.weight",
                    data = dem.sub, match.missing = FALSE,
                    covs.formula = ~ tradewb,
                    size.match = 10, qoi = "att",
                    outcome.var = "y",
                    lead = 0:4, forbid.treatment.reversal = FALSE)


# use the function to produce the scatter plot
balance_scatter(matched_set_list = list(sets0$att, sets1$att, sets2$att),
              data = dem.sub,
              covariates = c("y", "tradewb"))
# add legend
legend(x = 0, y = 0.8,
legend = c("mahalanobis",
           "PS weighting"),
y.intersp = 0.65,
x.intersp = 0.3,
xjust = 0,
pch = c(1, 3), pt.cex = 1,
bty = "n", ncol = 1, cex = 1, bg = "white")



</code></pre>

<hr>
<h2 id='build_maha_mats'>build_maha_mats
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set</h2><span id='topic+build_maha_mats'></span>

<h3>Description</h3>

<p>build_maha_mats
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_maha_mats(idx, ordered_expanded_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_maha_mats_+3A_idx">idx</code></td>
<td>
<p>List of vectors specifying which observations should be extracted</p>
</td></tr>
<tr><td><code id="build_maha_mats_+3A_ordered_expanded_data">ordered_expanded_data</code></td>
<td>
<p>data.frame of prepared/parsed input data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of parsed distance matrices, with elements corresponding to each matched set
</p>

<hr>
<h2 id='build_ps_data'>build_ps_data</h2><span id='topic+build_ps_data'></span>

<h3>Description</h3>

<p>build_ps_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_ps_data(idxlist, data, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_ps_data_+3A_idxlist">idxlist</code></td>
<td>
</td></tr>
<tr><td><code id="build_ps_data_+3A_data">data</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="build_ps_data_+3A_lag">lag</code></td>
<td>
<p>see PanelMatch() documentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of length equal to the number of matched sets. Each item is a data frame and each data frame contains information at time = t + 0 for each treated unit and their corresponding controls.
</p>

<hr>
<h2 id='calculate_estimates'>calculate_estimates</h2><span id='topic+calculate_estimates'></span>

<h3>Description</h3>

<p>Mid-level function that helps with estimation process. Calls lower level helper functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_estimates(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  att.sets,
  atc.sets,
  placebo.test = FALSE,
  lag,
  se.method,
  pooled = FALSE,
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_estimates_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_lead">lead</code></td>
<td>
<p>integer specifying lead window</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_att.sets">att.sets</code></td>
<td>
<p>matched.set object specifying the att or art sets</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_atc.sets">atc.sets</code></td>
<td>
<p>matched.set object specifying the atc sets</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_se.method">se.method</code></td>
<td>
<p>string specifying which method should be used for standard error calculation</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_pooled">pooled</code></td>
<td>
<p>bool. specifies whether or not estimates should be calculated for each lead period, or pooled across all lead periods</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_parallel">parallel</code></td>
<td>
<p>bool. Specifies whether or not parallelization should be used</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. specifies how many cores to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PanelEstimate object.
</p>

<hr>
<h2 id='calculate_placebo_estimates'>calculate_placebo_estimates</h2><span id='topic+calculate_placebo_estimates'></span>

<h3>Description</h3>

<p>Handles the procedures for calculating point estimates and standard errors for the placebo test. Code is structured very similarly to the calculate_estimates() code, but with appropriate modifications for the placebo test. See that function for description of arguments. Bootstrap SEs are available for any specification. Conditional, unconditional standard errors only available for att, art, atc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_placebo_estimates(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  att.sets,
  atc.sets,
  placebo.test = FALSE,
  lag,
  placebo.lead,
  se.method = "bootstrap",
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Value</h3>

<p>Returns a PanelEstimate object
</p>

<hr>
<h2 id='calculate_point_estimates'>calculate_point_estimates
Helper function that calculates the point estimates for the specified QOI</h2><span id='topic+calculate_point_estimates'></span>

<h3>Description</h3>

<p>calculate_point_estimates
Helper function that calculates the point estimates for the specified QOI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_point_estimates(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  pooled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_point_estimates_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_data.in">data.in</code></td>
<td>
<p>data.frame providing the processed/parsed data to be used for calculations</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_lead">lead</code></td>
<td>
<p>see PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the outcome variable</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_pooled">pooled</code></td>
<td>
<p>Logical. See PanelEstimate() documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of point estimates
</p>

<hr>
<h2 id='check_time_data'>check_time_data</h2><span id='topic+check_time_data'></span>

<h3>Description</h3>

<p>Time data should be consecutive integers: When it is not, try to convert it as best we can or throw an error. If function does not fail, returns the data as data frame object, either processed or not as appropriately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_time_data(data, time.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_time_data_+3A_data">data</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="check_time_data_+3A_time.id">time.id</code></td>
<td>
<p>string specifying the time id variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>enforces the requirements for time data, with some reasonable defaults
</p>


<h3>Value</h3>

<p>data.frame object with the data. If function throws error, nothing is returned.
</p>

<hr>
<h2 id='clean_leads'>clean_leads
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.</h2><span id='topic+clean_leads'></span>

<h3>Description</h3>

<p>clean_leads
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_leads(matched_sets, ordered.data, max.lead, t.var, id.var, outcome.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_leads_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object contained pre-filtered matched sets</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame object to be checked for missing data. This should have been passed through data preparation functions already.</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_max.lead">max.lead</code></td>
<td>
<p>Integer specifying the biggest value of the lead window.</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time id variable</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_outcome.var">outcome.var</code></td>
<td>
<p>string specifying the outcome variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cleaned/filtered matched.set object
</p>

<hr>
<h2 id='dem'>Country-level Democracy indicator</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>A dataset containing the democracy indicator for 184 countries from
1960 to 2010
</p>


<h3>Format</h3>

<p>A data.frame containing 9384 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> wbcode2. World Bank country ID. Integer.
</p>
</li>
<li><p> year. year (1960&ndash;2010). Integer.
</p>
</li>
<li><p> dem. binary indicator of democracy as defined in Acemoglu et al (2019).
</p>
</li>
<li><p> y log of GDP per capita in 2000 constant dollars (multiplied by 100). Numeric.
</p>
</li>
<li><p> tradewb Exports plus imports as a share of GDP from World Bank. Numeric.
</p>
</li></ul>



<h3>Source</h3>

<p>Acemoglu, Daron, Suresh Naidu, Pascual Restrepo, and James
A Robinson. &ldquo;Democracy does cause growth.&rdquo; Journal of Political
Economy.
</p>

<hr>
<h2 id='DisplayTreatment'>DisplayTreatment</h2><span id='topic+DisplayTreatment'></span>

<h3>Description</h3>

<p><code>DisplayTreatment</code> visualizes the treatment distribution
across units and time in a panel data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayTreatment(
  unit.id,
  time.id,
  treatment,
  data,
  color.of.treated = "red",
  color.of.untreated = "blue",
  title = "Treatment Distribution \n Across Units and Time",
  xlab = "Time",
  ylab = "Unit",
  x.size = NULL,
  y.size = NULL,
  legend.position = "none",
  x.angle = NULL,
  y.angle = NULL,
  legend.labels = c("not treated", "treated"),
  decreasing = FALSE,
  matched.set = NULL,
  show.set.only = FALSE,
  hide.x.tick.label = FALSE,
  hide.y.tick.label = FALSE,
  gradient.weights = FALSE,
  dense.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DisplayTreatment_+3A_unit.id">unit.id</code></td>
<td>
<p>Name of the unit identifier variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_time.id">time.id</code></td>
<td>
<p>Name of the time identifier variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_treatment">treatment</code></td>
<td>
<p>Name of the treatment variable as a character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_data">data</code></td>
<td>
<p>data.frame that contains the time series cross sectional data used for matching and estimation. Unit and time data must be integers. Time data must also be formatted as sequential integers that increase by one.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.treated">color.of.treated</code></td>
<td>
<p>Color of the treated observations provided as a character string (this includes hex values). Default is red.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.untreated">color.of.untreated</code></td>
<td>
<p>Color of the untreated observations provided as a character string (this includes hex values). Default is blue.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_title">title</code></td>
<td>
<p>Title of the plot provided as character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_xlab">xlab</code></td>
<td>
<p>Character label of the x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_ylab">ylab</code></td>
<td>
<p>Character label of the y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.size">x.size</code></td>
<td>
<p>Numeric size of the text for xlab or x axis tick labels. Assign x.size = NULL to use built in ggplot2 method of determining label size. 
When the length of the time period is long, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.size">y.size</code></td>
<td>
<p>Numeric size of the text for ylab or y axis tick labels. Assign y.size = NULL to use built in ggplot2 method of determining label size. 
When the number of units is large, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.position">legend.position</code></td>
<td>
<p>Position of the legend. Provide this according to ggplot2 standards.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.angle">x.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.angle">y.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.labels">legend.labels</code></td>
<td>
<p>Character vector of length two describing the
labels of the legend to be shown in the plot. ggplot2 standards are used.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Determines if display order should be increasing or decreasing by the amount of treatment received. Default is <code>decreasing</code> = FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_matched.set">matched.set</code></td>
<td>
<p>a matched.set object (optional) containing a single treated unit and a set of matched controls. If provided, this set will be highlighted on the resulting plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_show.set.only">show.set.only</code></td>
<td>
<p>logical. If TRUE, only the treated unit and control units contained in the provided <code>matched.set</code> object will be shown on the plot. 
Default is FALSE. If no <code>matched.set</code> is provided, then this argument will have no effect.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.x.tick.label">hide.x.tick.label</code></td>
<td>
<p>logical. If TRUE, x axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.y.tick.label">hide.y.tick.label</code></td>
<td>
<p>logical. If TRUE, y axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_gradient.weights">gradient.weights</code></td>
<td>
<p>logical. If TRUE, the &quot;darkness&quot;/shade of units in the provided <code>matched.set</code> object will be displayed according to their weight. Control units with higher weights will appear darker on the resulting plot. Control units with lower weights will appear lighter. This argument has no effect unless a <code>matched.set</code> is provided.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_dense.plot">dense.plot</code></td>
<td>
<p>logical. if TRUE, lines between tiles are removed on resulting plot. This is useful for producing more readable plots in situations where the number of units and/or time periods is very high.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DisplayTreatment</code> returns a treatment variation plot (using ggplot2 geom_tile() or geom_raster()),
which visualizes the variation of treatment across unit and time.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DisplayTreatment(unit.id = "wbcode2",
                 time.id = "year", legend.position = "none",
                 xlab = "year", ylab = "Country Code",
                 treatment = "dem", data = dem)


</code></pre>

<hr>
<h2 id='enforce_lead_restrictions'>enforce_lead_restrictions
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)</h2><span id='topic+enforce_lead_restrictions'></span>

<h3>Description</h3>

<p>enforce_lead_restrictions
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enforce_lead_restrictions(
  matched_sets,
  ordered.data,
  max.lead,
  t.var,
  id.var,
  treatment.var
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enforce_lead_restrictions_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_ordered.data">ordered.data</code></td>
<td>
<p>parsed data as data.frame object</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_max.lead">max.lead</code></td>
<td>
<p>The largest lead value (e.g. the biggest F)</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time variable</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_treatment.var">treatment.var</code></td>
<td>
<p>string specifying the treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with the matched sets that meet the conditions
</p>

<hr>
<h2 id='equality_four'>equality_four
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)</h2><span id='topic+equality_four'></span>

<h3>Description</h3>

<p>equality_four
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equality_four(x, y, z)
</code></pre>


<h3>Value</h3>

<p>Returns numeric vector of results.
</p>

<hr>
<h2 id='equality_four_placebo'>equality_four_placebo</h2><span id='topic+equality_four_placebo'></span>

<h3>Description</h3>

<p>Small helper function implementing estimation function from Imai, Kim, and Wang (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equality_four_placebo(x, y, z)
</code></pre>


<h3>Value</h3>

<p>Returns numeric vector of results.
</p>

<hr>
<h2 id='expand_treated_ts'>expand_treated_ts
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets</h2><span id='topic+expand_treated_ts'></span>

<h3>Description</h3>

<p>expand_treated_ts
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_treated_ts(lag, treated.ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_treated_ts_+3A_lag">lag</code></td>
<td>
<p>lag value</p>
</td></tr>
<tr><td><code id="expand_treated_ts_+3A_treated.ts">treated.ts</code></td>
<td>
<p>times of treated observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list. Contains all times in a lag window that correspond to a particular treated unit
</p>

<hr>
<h2 id='extract_differences'>extract_differences
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.</h2><span id='topic+extract_differences'></span>

<h3>Description</h3>

<p>extract_differences
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_differences(indexed.data, matched.set, treatment.variable, qoi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_differences_+3A_indexed.data">indexed.data</code></td>
<td>
<p>data that has been indexed. Rows have been named with a unique identifier.</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_matched.set">matched.set</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_treatment.variable">treatment.variable</code></td>
<td>
<p>string specifying treatment variable</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_qoi">qoi</code></td>
<td>
<p>string specifying QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object, with differences extracted as described previously for each matched set.
</p>

<hr>
<h2 id='find_ps'>find_ps</h2><span id='topic+find_ps'></span>

<h3>Description</h3>

<p>find_ps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ps(sets, fitted.model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ps_+3A_sets">sets</code></td>
<td>
<p>matched sets</p>
</td></tr>
<tr><td><code id="find_ps_+3A_fitted.model">fitted.model</code></td>
<td>
<p>Result of a fitted (CB) PS model call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frames with propensity score weights for each unit in a matched set. Each element in the list is a data frame which corresponds to a matched set of 1 treatment and all matched control units
</p>

<hr>
<h2 id='findBinaryTreated'>findBinaryTreated</h2><span id='topic+findBinaryTreated'></span>

<h3>Description</h3>

<p><code>findBinaryTreated</code> is used to identify t,id pairs of units for which a matched set might exist.
More precisely, it finds units for which at time t, the specified treatment has been applied, but at time t - 1, the treatment has not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findBinaryTreated(
  dmat,
  qoi.in,
  treatedvar,
  time.var,
  unit.var,
  hasbeensorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findBinaryTreated_+3A_dmat">dmat</code></td>
<td>
<p>Data frame or matrix containing data used to identify potential treated units. Must be specified in such a way that a combination of time and id variables will correspond to a unique row. Must also contain at least a binary treatment variable column as well.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that provides information about the binary treatment variable</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_time.var">time.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the time variable. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_unit.var">unit.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the variable used as a unit id. This data must be integer</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>findBinaryTreated</code> returns a subset of the data in the <code>dmat</code> data frame, containing only treated units for which a matched set might exist
</p>

<hr>
<h2 id='get_covariate_balance'>Calculate covariate balance</h2><span id='topic+get_covariate_balance'></span>

<h3>Description</h3>

<p>Calculate covariate balance for user specified covariates across matched sets. Balance is assessed by taking the average
of the difference between the values of the specified covariates for the treated unit(s) and the weighted average of
the control units across all matched sets. Results are standardized and are expressed in standard deviations.
Balance is calculated for each period in the specified lag window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covariate_balance(
  matched.sets,
  data,
  covariates,
  use.equal.weights = FALSE,
  plot = FALSE,
  reference.line = TRUE,
  legend = TRUE,
  ylab = "SD",
  include.treatment.period = TRUE,
  legend.position = "topleft",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covariate_balance_+3A_matched.sets">matched.sets</code></td>
<td>
<p>A <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_data">data</code></td>
<td>
<p>The time series cross sectional data set (as a <code>data.frame</code> object) used to produce the <code>matched.set</code> object. This data set should be identical to the one passed to <code>PanelMatch()</code> and <code>PanelEstimate()</code> to ensure consistent results.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_covariates">covariates</code></td>
<td>
<p>a character vector, specifying the names of the covariates for which the user is interested in calculating balance.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_use.equal.weights">use.equal.weights</code></td>
<td>
<p>logical. If set to TRUE, then equal weights will be assigned to control units, rather than using whatever calculated weights have been assigned. This is helpful for assessing the improvement in covariate balance as a result of refining the matched sets.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_plot">plot</code></td>
<td>
<p>logical. When TRUE, a plot showing the covariate balance calculation results will be shown. When FALSE, no plot is made, but the results of the calculations are returned. default is FALSE</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_reference.line">reference.line</code></td>
<td>
<p>logical indicating whether or not a horizontal line should be present on the plot at y = 0. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_legend">legend</code></td>
<td>
<p>logical indicating whether or not a legend identifying the variables should be included on the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis. Default is &quot;SD&quot;. This is the same as the ylab argument to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_include.treatment.period">include.treatment.period</code></td>
<td>
<p>logical. Default is TRUE. When TRUE, covariate balance measures for the period during which treatment occurs is included. These calculations are not included when FALSE. Users may wish to leave this period off in some circumstances. For instance, one would expect covariate balance to be poor during this period when treatment is continuous and a lagged outcome is included in the refinement formula.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_legend.position">legend.position</code></td>
<td>
<p>position of legend. See documentation for graphics::legend. Default is &quot;topleft&quot;</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to the <code>plot</code> function in base R.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
#add some additional data to data set for demonstration purposes
dem.sub$rdata &lt;- runif(runif(nrow(dem.sub)))
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, time.id = "year", unit.id = "wbcode2", treatment = "dem",
                    outcome.var ="y", refinement.method = "ps.match",
                    data = dem.sub, match.missing = TRUE,
                    covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                    size.match = 5, qoi = "att")
get_covariate_balance(pm.obj$att, dem.sub, covariates = c("tradewb", "rdata"),
                         ylim = c(-2,2))

</code></pre>

<hr>
<h2 id='get_set_treatment_effects'>get_set_treatment_effects</h2><span id='topic+get_set_treatment_effects'></span>

<h3>Description</h3>

<p>Calculates the treatment effect size at the matched set level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_set_treatment_effects(pm.obj, data, lead)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_set_treatment_effects_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_data">data</code></td>
<td>
<p>data.frame with the time series cross sectional data used for matching, refinement, and estimation</p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_lead">lead</code></td>
<td>
<p>integer (or integer vector) indicating the time period(s) in the future for which the treatment effect size will be calculated. Calculations will be made for the period t + lead, where t is the time of treatment. If more than one lead value is provided, then calculations will be performed for each value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the size of treatment effects for each matched set.
</p>


<h3>Value</h3>

<p>a list equal in length to the number of lead periods specified to the <code>lead</code> argument. Each element in the list is a vector of the matched set level effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "ps.match",
                         data = dem.sub, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE,
                         placebo.test = FALSE)
set.effects &lt;- get_set_treatment_effects(pm.obj = PM.results, data = dem.sub, lead = 0)


</code></pre>

<hr>
<h2 id='get.matchedsets'>get.matchedsets</h2><span id='topic+get.matchedsets'></span>

<h3>Description</h3>

<p><code>get.matchedsets</code> is used to identify matched sets for a given unit with a specified i, t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.matchedsets(
  t,
  id,
  data,
  L,
  t.column,
  id.column,
  treatedvar,
  hasbeensorted = FALSE,
  match.on.missingness = TRUE,
  matching = TRUE,
  qoi.in,
  restrict.control.period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.matchedsets_+3A_t">t</code></td>
<td>
<p>integer vector specifying the times of treated units for which matched sets should be found. This vector should be the same length as the following <code>id</code> parameter &ndash; the entries at corresponding indices in each vector should form the t,id pair of a specified treatment unit.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id">id</code></td>
<td>
<p>integer vector specifying the unit ids of treated units for which matched sets should be found. note that both <code>t</code> and <code>id</code> can be of length 1</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_data">data</code></td>
<td>
<p>data frame containing the data to be used for finding matched sets.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_l">L</code></td>
<td>
<p>An integer value indicating the length of treatment history to be matched</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_t.column">t.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the time variable. Each specified entry in <code>t</code> should be somewhere in this column in the data. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id.column">id.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the unit id variable. Each specified entry in <code>id</code> should be somewhere in this column in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the binary treatment variable.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_match.on.missingness">match.on.missingness</code></td>
<td>
<p>TRUE/FALSE indicating whether or not the user wants to &quot;match on missingness.&quot; That is, should units with NAs in their treatment history windows be matched with control units that have NA's in corresponding places?</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not the treatment history should be used for matching. This should almost always be set to TRUE, except for specific situations where the user is interested in particular diagnostic questions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.matchedsets</code> returns a &quot;matched set&quot; object, which primarily contains a named list of vectors. Each vector is a &quot;matched set&quot; containing the unit ids included in a matched set. The list names will indicate an i,t pair (formatted as &quot;&lt;i variable&gt;.&lt;t variable&gt;&quot;) to which the vector/matched set corresponds.
</p>

<hr>
<h2 id='getDits'>getDits
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.</h2><span id='topic+getDits'></span>

<h3>Description</h3>

<p>getDits
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDits(matched_sets, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDits_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="getDits_+3A_data">data</code></td>
<td>
<p>data.frame object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of Dits, as described in Imai et al. (2023)
</p>

<hr>
<h2 id='getWits'>getWits
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.</h2><span id='topic+getWits'></span>

<h3>Description</h3>

<p>getWits
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWits(matched_sets, lead, data, estimation.method = "bootstrap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWits_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="getWits_+3A_lead">lead</code></td>
<td>
<p>integer providing a specific lead value</p>
</td></tr>
<tr><td><code id="getWits_+3A_data">data</code></td>
<td>
<p>data.frame object</p>
</td></tr>
<tr><td><code id="getWits_+3A_estimation.method">estimation.method</code></td>
<td>
<p>method of estimation for calculating standard errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of Wits, as described above
</p>

<hr>
<h2 id='handle_bootstrap'>handle_bootstrap</h2><span id='topic+handle_bootstrap'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the QOI. This version is not parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  pooled
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_bootstrap_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_pooled">pooled</code></td>
<td>
<p>logical. Specifies whether or not to calculate point estimates for each specified lead value, or a single pooled estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_parallel'>handle_bootstrap_parallel</h2><span id='topic+handle_bootstrap_parallel'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the QOI. This version is parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_parallel(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  pooled,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_bootstrap_parallel_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_pooled">pooled</code></td>
<td>
<p>logical. Specifies whether or not to calculate point estimates for each specified lead value, or a single pooled estimate.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to be used for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_placebo'>handle_bootstrap_placebo</h2><span id='topic+handle_bootstrap_placebo'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the placebo test. This version is not parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_placebo(
  qoi.in,
  data.in,
  placebo.lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_bootstrap_placebo_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_placebo_parallel'>handle_bootstrap_placebo_parallel</h2><span id='topic+handle_bootstrap_placebo_parallel'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the placebo test. This version is parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_placebo_parallel(
  qoi.in,
  data.in,
  placebo.lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to be used for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_conditional_se'>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</h2><span id='topic+handle_conditional_se'></span>

<h3>Description</h3>

<p>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_conditional_se(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  unit.id.variable
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_conditional_se_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_data.in">data.in</code></td>
<td>
<p>data.frame specifying the data</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector with standard error estimates
</p>

<hr>
<h2 id='handle_mahalanobis_calculations'>handle_mahalanobis_calculations
Returns a matched.set object with weights for control units, along with some other metadata</h2><span id='topic+handle_mahalanobis_calculations'></span>

<h3>Description</h3>

<p>handle_mahalanobis_calculations
Returns a matched.set object with weights for control units, along with some other metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_mahalanobis_calculations(
  mahal.nested.list,
  msets,
  max.size,
  verbose,
  use.diagonal.covmat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_mahalanobis_calculations_+3A_mahal.nested.list">mahal.nested.list</code></td>
<td>
<p>Output from build_maha_mats function</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_msets">msets</code></td>
<td>
<p>matched.set object &ndash; list containing the treated observations and matched controls</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_max.size">max.size</code></td>
<td>
<p>maximum number of control units that will receive non-zero weights within a matched set</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_verbose">verbose</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_use.diagonal.covmat">use.diagonal.covmat</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with weights for control units, along with some other metadata
</p>

<hr>
<h2 id='handle_missing_data'>handle_missing_data</h2><span id='topic+handle_missing_data'></span>

<h3>Description</h3>

<p>use col.index to determine which columns we want to &quot;scan&quot; for missing data. Note that in earlier points in the code, we rearrange the columns and prepare the data frame such that cols 1-4 are bookkeeping (unit id, time id, treated variable, unlagged outcome variable) and all remaining columns are used in the calculations after going through parse_and_prep function, so col.index should usually be 5:ncol(data). In practice, this function just looks over the data in the specified columns in the &quot;data&quot; data frame for missing data. Then it creates columns with indicator variables about the missingness of those variables: 1 for missing data, 0 for present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_missing_data(data, col.index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_missing_data_+3A_data">data</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="handle_missing_data_+3A_col.index">col.index</code></td>
<td>
<p>numeric vector specifying which columns to inspect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tags missing data
</p>


<h3>Value</h3>

<p>data.frame object with the data and the missingness indicators described above.
</p>

<hr>
<h2 id='handle_moderating_variable'>handle_moderating_variable
handles moderating variable calculations: In practice, this just involves slicing the data up according to the moderator, calling PanelEstimate() and putting everything back together This function creates the sets of objects on which PanelEstimate() will be called. It identifies the set of valid values the moderating variable can take on.</h2><span id='topic+handle_moderating_variable'></span>

<h3>Description</h3>

<p>handle_moderating_variable
handles moderating variable calculations: In practice, this just involves slicing the data up according to the moderator, calling PanelEstimate() and putting everything back together This function creates the sets of objects on which PanelEstimate() will be called. It identifies the set of valid values the moderating variable can take on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_moderating_variable(
  ordered.data,
  att.sets,
  atc.sets,
  PM.object,
  moderator,
  unit.id,
  time.id,
  qoi.in
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_moderating_variable_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_att.sets">att.sets</code></td>
<td>
<p>matched.set object for the ATT or ART</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_atc.sets">atc.sets</code></td>
<td>
<p>matched.set object for the ATC</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_pm.object">PM.object</code></td>
<td>
<p>PanelMatch object</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_moderator">moderator</code></td>
<td>
<p>string specifying the name of the moderating variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_unit.id">unit.id</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_time.id">time.id</code></td>
<td>
<p>string specifying the time id variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of valid moderating variable values
</p>

<hr>
<h2 id='handle_ps_match'>handle_ps_match
Returns a matched.set object with weights for control units, along with some other metadata</h2><span id='topic+handle_ps_match'></span>

<h3>Description</h3>

<p>handle_ps_match
Returns a matched.set object with weights for control units, along with some other metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_ps_match(just.ps.sets, msets, refinement.method, verbose, max.set.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_ps_match_+3A_just.ps.sets">just.ps.sets</code></td>
<td>
<p>Output from find_ps() function</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_msets">msets</code></td>
<td>
<p>matched.set object &ndash; list containing the treated observations and matched controls</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_verbose">verbose</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_max.set.size">max.set.size</code></td>
<td>
<p>maximum number of control units that will receive non-zero weights within a matched set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with weights for control units, along with some other metadata
</p>

<hr>
<h2 id='handle_ps_weighted'>handle_ps_weighted</h2><span id='topic+handle_ps_weighted'></span>

<h3>Description</h3>

<p>handle_ps_weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_ps_weighted(just.ps.sets, msets, refinement.method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_ps_weighted_+3A_just.ps.sets">just.ps.sets</code></td>
<td>
<p>results of find_ps()</p>
</td></tr>
<tr><td><code id="handle_ps_weighted_+3A_msets">msets</code></td>
<td>
<p>list of matched sets of treated and control observations</p>
</td></tr>
<tr><td><code id="handle_ps_weighted_+3A_refinement.method">refinement.method</code></td>
<td>
<p>string specifying the refinement method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with treated and matched control observations, with weights as determined by the specification
</p>

<hr>
<h2 id='handle_unconditional_se'>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</h2><span id='topic+handle_unconditional_se'></span>

<h3>Description</h3>

<p>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_unconditional_se(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  unit.id.variable
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_unconditional_se_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_data.in">data.in</code></td>
<td>
<p>data.frame specifying the data</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector with standard error estimates
</p>

<hr>
<h2 id='identifyDirectionalChanges'>identifyDirectionalChanges
Identifies changes in treatment variable for treated and control observations</h2><span id='topic+identifyDirectionalChanges'></span>

<h3>Description</h3>

<p>identifyDirectionalChanges
Identifies changes in treatment variable for treated and control observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyDirectionalChanges(
  msets,
  ordered.data,
  id.var,
  time.var,
  treatment.var,
  qoi
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyDirectionalChanges_+3A_msets">msets</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_ordered.data">ordered.data</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_id.var">id.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_time.var">time.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_treatment.var">treatment.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_qoi">qoi</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with changes in the treatment variable for treated and control observations identified.
</p>

<hr>
<h2 id='lwd_refinement'>lwd_refinement
master function that performs refinement with listwise deletion = TRUE</h2><span id='topic+lwd_refinement'></span>

<h3>Description</h3>

<p>lwd_refinement
master function that performs refinement with listwise deletion = TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwd_refinement(
  msets,
  global.data,
  treated.ts,
  treated.ids,
  lag,
  time.id,
  unit.id,
  lead,
  refinement.method,
  treatment,
  size.match,
  match.missing,
  covs.formula,
  verbose,
  outcome.var,
  e.sets,
  use.diag.covmat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lwd_refinement_+3A_msets">msets</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_global.data">global.data</code></td>
<td>
<p>data.frame. needs to be fully prepped/parsed data set that is internally balanced, full of NAs likely</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treated.ts">treated.ts</code></td>
<td>
<p>vector of the times of treatment for treated observations</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treated.ids">treated.ids</code></td>
<td>
<p>vector of unit identifiers of treated observations</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_lag">lag</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_time.id">time.id</code></td>
<td>
<p>string specifying</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_unit.id">unit.id</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_lead">lead</code></td>
<td>
<p>vector of lead values</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_refinement.method">refinement.method</code></td>
<td>
<p>string specifying refinement method</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treatment">treatment</code></td>
<td>
<p>string specifying treatment variable</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_size.match">size.match</code></td>
<td>
<p>maximum number of units to give non-zero weight to when using matching refinement method</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_match.missing">match.missing</code></td>
<td>
<p>logical. indicates whether or not to allow the package to match units on missingness in treatment history</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_covs.formula">covs.formula</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_verbose">verbose</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_outcome.var">outcome.var</code></td>
<td>
<p>string specifying outcome variable</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_e.sets">e.sets</code></td>
<td>
<p>empty sets (treated observations with no matched controls)</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_use.diag.covmat">use.diag.covmat</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with refined matched sets.
</p>

<hr>
<h2 id='lwd_units'>lwd_units
helper function that actually subsets sets down to contain units with complete data</h2><span id='topic+lwd_units'></span>

<h3>Description</h3>

<p>lwd_units
helper function that actually subsets sets down to contain units with complete data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwd_units(full.local.data, unit.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lwd_units_+3A_full.local.data">full.local.data</code></td>
<td>
<p>data.frame containing the data to be used in set-level refinement, but containing missing data</p>
</td></tr>
<tr><td><code id="lwd_units_+3A_unit.id">unit.id</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the missing data removed to be used for set-level refinement.
</p>

<hr>
<h2 id='matched_set'>matched_set</h2><span id='topic+matched_set'></span>

<h3>Description</h3>

<p><code>matched_set</code> is a constructor for the <code>matched.set</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched_set(matchedsets, id, t, L, t.var, id.var, treatment.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matched_set_+3A_matchedsets">matchedsets</code></td>
<td>
<p>a list of treated units and matched control units. Each element in the list should be a vector of control unit ids.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id">id</code></td>
<td>
<p>A vector containing the ids of treated units</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t">t</code></td>
<td>
<p>A vector containing the times of treatment for treated units.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_l">L</code></td>
<td>
<p>integer specifying the length of the lag window used in matching</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_treatment.var">treatment.var</code></td>
<td>
<p>string specifying the treatment variable.
</p>
<p>The constructor function returns a <code>matched.set</code> object.
<code>matched.set</code> objects are a modified lists. Each element in the list is a vector of ids
corresponding to the control unit ids in a matched set.
Additionally, these vectors might have additional attributes &ndash; &quot;weights&quot;. These correspond to the
weights assigned to each control unit,
as determined by the specified refinement method.
Each element in the list also has a name, which corresponds to the unit id of the treated unit and time of treatment,
concatenated together and separated by a period. <code>matched.set</code> objects also have a number of
methods defined: <code>summary</code>, <code>plot</code>, and <code>`[`</code>. <code>matched.set</code> objects can be modified manually
as long as these conventions (and conventions about other attributes) are maintained. It is important to note that <code>matched.set</code> objects
are distinct from <code>PanelMatch</code> objects. <code>matched.set</code> objects are often contained within <code>PanelMatch</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users should never need to use this function by itself. See below for more about <code>matched.set</code> objects.
</p>


<h3>Value</h3>

<p><code>matched.set</code> objects have additional attributes. These reflect the specified parameters when using the <code>PanelMatch</code> function:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>an integer value indicating the length of treatment history to be used for matching. Treated and control units are matched based on whether or not they have exactly matching treatment histories in the lag window.</p>
</td></tr>
<tr><td><code>t.var</code></td>
<td>
<p>time variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>id.var</code></td>
<td>
<p>unit id variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>treatment.var</code></td>
<td>
<p>treatment variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class of the object: should always be &quot;matched.set&quot;</p>
</td></tr>
<tr><td><code>refinement.method</code></td>
<td>
<p>method used to refine and/or weight the control units in each set.</p>
</td></tr>
<tr><td><code>covs.formula</code></td>
<td>
<p>One sided formula indicating which variables should be used for matching and refinement</p>
</td></tr>
<tr><td><code>match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories</p>
</td></tr>
<tr><td><code>max.match.size</code></td>
<td>
<p>Maximum size of the matched sets after refinement. This argument only affects results when using a matching method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;amrauh@umich..edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>

<hr>
<h2 id='merge_formula'>merge_formula</h2><span id='topic+merge_formula'></span>

<h3>Description</h3>

<p>Simple helper function for merging formula objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_formula(form1, form2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_formula_+3A_form1">form1</code></td>
<td>
<p>formula object</p>
</td></tr>
<tr><td><code id="merge_formula_+3A_form2">form2</code></td>
<td>
<p>formula object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a formula object, which is the concatenation of two provided formula objects.
</p>

<hr>
<h2 id='PanelEstimate'>PanelEstimate</h2><span id='topic+PanelEstimate'></span>

<h3>Description</h3>

<p><code>PanelEstimate</code> estimates a causal quantity of interest, including the average treatment effect for
treated or control units (att and atc, respectively), the average effect of treatment reversal on reversed units (art), or average treatment effect (ate), as specified in <code>PanelMatch()</code>.
This is done by estimating the counterfactual outcomes for each treated unit using
matched sets. Users will provide matched sets that were obtained by the
<code>PanelMatch</code> function and obtain point estimates via a
weighted average computation with weighted bootstrap standard errors. Point estimates and standard errors will be
produced for each period in the lead window specified by the <code>lead</code> argument from <code>PanelMatch()</code>.
Users may run multiple estimations by providing lists of each argument to the function.
However, in this format, every argument must be explicitly specified in each configuration
and must adhere to the same data types/structures outlined below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelEstimate(
  sets,
  data,
  number.iterations = 1000,
  df.adjustment = FALSE,
  confidence.level = 0.95,
  moderator = NULL,
  se.method = "bootstrap",
  pooled = FALSE,
  include.placebo.test = FALSE,
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PanelEstimate_+3A_sets">sets</code></td>
<td>
<p>A <code>PanelMatch</code> object attained via the
<code>PanelMatch()</code> function.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_data">data</code></td>
<td>
<p>The same time series cross sectional data set provided to the <code>PanelMatch()</code> function used to produce
the matched sets.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_number.iterations">number.iterations</code></td>
<td>
<p>If using bootstrapping for calculating standard errors, this is the number of bootstrap iterations. Provide as integer. If <code>se.method</code> is not equal to &quot;bootstrap&quot;, this argument has no effect.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_df.adjustment">df.adjustment</code></td>
<td>
<p>A logical value indicating whether or not a
degree-of-freedom adjustment should be performed for the standard error
calculation. The default is <code>FALSE</code>. This parameter is only available for the bootstrap method of standard error calculation.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_confidence.level">confidence.level</code></td>
<td>
<p>A numerical value specifying the confidence level and range of interval
estimates for statistical inference. The default is .95.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_moderator">moderator</code></td>
<td>
<p>The name of a moderating variable, provided as a character string. If a moderating variable is provided,the returned object will be a list of <code>PanelEstimate</code> objects. The names of the list will reflect the different values of the moderating variable. More specifically, the moderating variable values will be converted to syntactically proper names using <code>make.names()</code>.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_se.method">se.method</code></td>
<td>
<p>Method used for calculating standard errors, provided as a character string. Users must choose between &quot;bootstrap&quot;, &quot;conditional&quot;, and &quot;unconditional&quot; methods. Default is &quot;bootstrap&quot;. &quot;bootstrap&quot; uses a block bootstrapping procedure to calculate standard errors. The conditional method calculates the variance of the estimator, assuming independence across units but not across time. The unconditional method also calculates the variance of the estimator analytically, but makes no such assumptions about independence across units. When the quantity of interest is &quot;att&quot;, &quot;atc&quot;, or &quot;art&quot;, all methods are available. Only &quot;bootstrap&quot; is available for the ate. If <code>pooled</code> argument is TRUE, then only bootstrap is available.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_pooled">pooled</code></td>
<td>
<p>Logical. If TRUE, estimates and standard errors are returned for treatment effects pooled across the entire lead window. Only available for <code>se.method = ``bootstrap''</code></p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_include.placebo.test">include.placebo.test</code></td>
<td>
<p>Logical. If TRUE, a placebo test is run and returned in the results. The placebo test uses the same specifications for calculating standard errors as the main results. That is, standard errors are calculated according to the user provided <code>se.method</code> and <code>confidence.level</code> arguments (and, if applicable, parallelization specifications). If these are invalid for some reason, an error will be thrown.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE and <code>se.method = ``bootstrap''</code>, bootstrap procedure will be parallelized. Default is FALSE. If <code>se.method</code> is not set to <code>bootstrap</code>, this option does nothing.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. Specifies the number of cores to use for parallelization. If <code>se.method = ``bootstrap''</code> and <code>parallel = TRUE</code>, then this option will take effect. Otherwise, it will do nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PanelEstimate</code> returns a list of class
&lsquo;PanelEstimate&rsquo; containing the following components:
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>the point estimates of the quantity of interest for the lead periods specified</p>
</td></tr>
<tr><td><code>se.method</code></td>
<td>
<p>The method used to calculate standard errors. This is the same as the argument provided to the function.</p>
</td></tr>
<tr><td><code>bootstrapped.estimates</code></td>
<td>
<p>the bootstrapped point estimate values, when applicable</p>
</td></tr>
<tr><td><code>bootstrap.iterations</code></td>
<td>
<p>the number of iterations used in bootstrapping, when applicable</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>refinement method used to create the matched sets from which the estimates were calculated</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>See PanelMatch() argument <code>lag</code> for more information.</p>
</td></tr>
<tr><td><code>lead</code></td>
<td>
<p>The lead window sequence for which <code>PanelEstimate()</code> is producing point estimates and standard errors.</p>
</td></tr>
<tr><td><code>confidence.level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
<tr><td><code>qoi</code></td>
<td>
<p>the quantity of interest</p>
</td></tr>
<tr><td><code>matched.sets</code></td>
<td>
<p>the refined matched sets used to produce the estimations</p>
</td></tr>
<tr><td><code>standard.error</code></td>
<td>
<p>the standard error(s) of the point estimates</p>
</td></tr>
<tr><td><code>pooled</code></td>
<td>
<p>Logical indicating whether or not estimates were calculated for individual lead periods or pooled.</p>
</td></tr>
<tr><td><code>placebo.test</code></td>
<td>
<p>if <code>include.placebo.test = TRUE</code>, a placebo test is conducted using <code>placebo_test()</code> and returned as a list. See documentation for <code>placebo_test()</code> for more about each individual item.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2023)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                        treatment = "dem", refinement.method = "ps.match", 
                         data = dem.sub, match.missing = TRUE, covs.formula = ~ tradewb, 
                         size.match = 5, qoi = "att", outcome.var = "y", 
                         lead = 0:4, forbid.treatment.reversal = TRUE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem.sub, se.method = "unconditional")

</code></pre>

<hr>
<h2 id='PanelMatch'>PanelMatch</h2><span id='topic+PanelMatch'></span>

<h3>Description</h3>

<p>Create refined/weighted sets of treated and control units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelMatch(
  lag,
  time.id,
  unit.id,
  treatment,
  outcome.var,
  refinement.method,
  data,
  qoi,
  size.match = 10,
  match.missing = TRUE,
  covs.formula = NULL,
  lead = 0,
  verbose = FALSE,
  exact.match.variables = NULL,
  forbid.treatment.reversal = FALSE,
  matching = TRUE,
  listwise.delete = FALSE,
  use.diagonal.variance.matrix = FALSE,
  restrict.control.period = NULL,
  placebo.test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PanelMatch_+3A_lag">lag</code></td>
<td>
<p>An integer value indicating the length of treatment history periods to be matched on</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_time.id">time.id</code></td>
<td>
<p>A character string indicating the name of the time 
variable in the <code>data</code>. This data currently must be formatted as sequential integers.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_unit.id">unit.id</code></td>
<td>
<p>A character string indicating the name of unit identifier in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_treatment">treatment</code></td>
<td>
<p>A character string indicating the name of the treatment variable in the <code>data</code>. 
The treatment must be a binary indicator variable (integer with 0 for the control group and 1 for the treatment group).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_outcome.var">outcome.var</code></td>
<td>
<p>A character string identifying the outcome variable.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_refinement.method">refinement.method</code></td>
<td>
<p>A character string specifying the matching or weighting method to be used for refining the matched sets. The user can choose &quot;mahalanobis&quot;, &quot;ps.match&quot;, &quot;CBPS.match&quot;, &quot;ps.weight&quot;, &quot;CBPS.weight&quot;, or &quot;none&quot;. The first three methods will use the <code>size.match</code> argument to create sets of at most <code>size.match</code> closest control units. Choosing &quot;none&quot; will assign equal weights to all control units in each matched set.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> object containing time series cross sectional data. 
Time data must be sequential integers that increase by 1. Unit identifiers must be integers. Treatment data must be binary.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_qoi">qoi</code></td>
<td>
<p>quantity of interest, provided as a string: <code>att</code> (average treatment effect on treated units), <code>atc</code> (average treatment effect of treatment on the control units) <code>art</code> (average effect of treatment reversal for units that experience treatment reversal), or <code>ate</code> (average treatment effect).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_size.match">size.match</code></td>
<td>
<p>An integer dictating the number of permitted closest control units in a matched set after refinement. 
This argument only affects results when using a matching method (&quot;mahalanobis&quot; or any of the refinement methods that end in &quot;.match&quot;).
This argument is not needed and will have no impact if included when a weighting method is specified (any <code>refinement.method</code> that includes &quot;weight&quot; in the name).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_match.missing">match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories. Default is TRUE. When FALSE, neither treated nor control units are allowed to have missing treatment data in the lag window.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_covs.formula">covs.formula</code></td>
<td>
<p>One sided formula object indicating which variables should be used for matching and refinement. 
Argument is not needed if <code>refinement.method</code> is set to &quot;none&quot;
If the user wants to include lagged variables, this can be done using a function, &quot;lag()&quot;, which takes two, unnamed, 
positional arguments. The first is the name of the variable which you wish to lag. The second is the lag window, 
specified as an integer sequence in increasing order.
For instance, I(lag(x, 1:4)) will then add new columns to the data for variable &quot;x&quot; for time t-1, t-2, t-3, and t-4 internally
and use them for defining/measuring similarity between units. 
Other transformations using the I() function, such as I(x^2) are also permitted.
The variables specified in this formula are used to define the similarity/distances between units.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_lead">lead</code></td>
<td>
<p>integer sequence specifying the lead window, for which qoi point estimates (and standard errors) will 
ultimately be produced. Default is 0 (which corresponds to contemporaneous treatment effect).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_verbose">verbose</code></td>
<td>
<p>option to include more information about the <code>matched.set</code> object calculations, 
like the distances used to create the refined sets and weights.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_exact.match.variables">exact.match.variables</code></td>
<td>
<p>character vector giving the names of variables to be exactly matched on. These should be time invariant variables. 
Exact matching for time varying covariates is not currently supported.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_forbid.treatment.reversal">forbid.treatment.reversal</code></td>
<td>
<p>Logical. For the ATT, it indicates whether or not it is permissible for treatment to reverse in the specified lead window. This is defined analogously for the ART. It is not valid for the ATC or ATE. 
When set to TRUE, only matched sets for treated units where treatment is 
applied continuously in the lead window are included in the results. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not any matching on treatment history should be performed. 
This is primarily used for diagnostic purposes, and most users will never need to set this to FALSE. Default is TRUE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_listwise.delete">listwise.delete</code></td>
<td>
<p>TRUE/FALSE indicating whether or not missing data should be handled using listwise deletion or the package's default missing data handling procedures. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_use.diagonal.variance.matrix">use.diagonal.variance.matrix</code></td>
<td>
<p>TRUE/FALSE indicating whether or not a regular covariance matrix should be used in mahalanobis distance calculations during refinement, 
or if a diagonal matrix with only covariate variances should be used instead. 
In many cases, setting this to TRUE can lead to better covariate balance, especially when there is 
high correlation between variables. Default is FALSE. This argument is only necessary when 
<code>refinement.method = mahalanobis</code> and will have no impact otherwise.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_restrict.control.period">restrict.control.period</code></td>
<td>
<p>(optional) integer specifying the number of pre-treatment periods that treated units and potentially matched control units should be non-NULL and in the control state. For instance, specifying 4 would mean that the treatment history cannot contain any missing data or treatment from t-4 to t.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_placebo.test">placebo.test</code></td>
<td>
<p>logical TRUE/FALSE. indicates whether or not you want to be able to run a placebo test. This will add additional requirements on the data &ndash; specifically, it requires that no unit included in the matching/refinement process can having missing outcome data over the lag window. Additionally, you should not use the outcome variable in refinement when <code>placebo.test = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PanelMatch</code> identifies a matched set for each treated
observation. Specifically, for a given treated unit, the matched
set consists of control observations that have an identical
treatment history up to a number of <code>lag</code>
time periods. Researchers must specify <code>lag</code>. A further refinement of
the matched set may be performed by setting a maximum size of each matched
set, <code>size.match</code> (the maximum number of control units that can be matched to a treated unit). Users can 
also specify covariates that should be used to identify
similar control units and a method for defining similarity/distance between units. This is done 
via the <code>covs.formula</code> and <code>refinement.method</code> arguments, respectively, which are explained in more detail below.
</p>


<h3>Value</h3>

<p><code>PanelMatch()</code> returns an object of class &quot;PanelMatch&quot;. This is a list that contains a few specific elements: 
First, a <code>matched.set</code> object(s) that has the same name as the provided qoi if the qoi is &quot;att&quot;, &quot;art&quot;, or &quot;atc&quot;. 
If qoi = &quot;ate&quot; then two <code>matched.set</code> objects will be attached, named &quot;att&quot; and &quot;atc.&quot; Please consult the documentation for
<code>matched_set()</code> to read more about the structure and usage of <code>matched.set</code> objects. Also, see the vignette page about matched.set objects for 
more information about these objects: <code>vignette("matched_set_objects", package = "PanelMatch")</code>.
The <code>PanelMatch</code> object also has some additional attributes:
</p>
<table>
<tr><td><code>qoi</code></td>
<td>
<p>The qoi specified in the original function call</p>
</td></tr>
<tr><td><code>lead</code></td>
<td>
<p>the lead window specified in the original function call</p>
</td></tr>
<tr><td><code>forbid.treatment.reversal</code></td>
<td>
<p>logial value matching the forbid.treatment.reversal parameter provided in the function call.</p>
</td></tr>
<tr><td><code>outcome.var</code></td>
<td>
<p>character string matching the outcome variable provided in the original function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;amrauh@umich.edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2023)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "ps.match", 
                         data = dem.sub, match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)


</code></pre>

<hr>
<h2 id='parse_and_prep'>parse_and_prep</h2><span id='topic+parse_and_prep'></span>

<h3>Description</h3>

<p>accepts formula object and data, creates the data used for refinement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_and_prep(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_and_prep_+3A_formula">formula</code></td>
<td>
<p>formula object specifying how to construct the data used for refinement. This is likely to be some variation of the covs.formula argument.</p>
</td></tr>
<tr><td><code id="parse_and_prep_+3A_data">data</code></td>
<td>
<p>data.frame object to be used to create the data needed for refinement. data has unit, time, treatment columns in that order, followed by everything else</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with the data prepared for refinement. Data will have unit, time, treatment columns in that order, followed by everything else.
</p>

<hr>
<h2 id='pcs'>Prepare Control Units
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.</h2><span id='topic+pcs'></span>

<h3>Description</h3>

<p>Prepare Control Units
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcs(sets, lead.in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcs_+3A_sets">sets</code></td>
<td>
<p>object describing the matched sets</p>
</td></tr>
<tr><td><code id="pcs_+3A_lead.in">lead.in</code></td>
<td>
<p>integer describing a particular lead value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with time-id combinations
</p>

<hr>
<h2 id='perform_refinement'>perform_refinement
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()</h2><span id='topic+perform_refinement'></span>

<h3>Description</h3>

<p>perform_refinement
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform_refinement(
  lag,
  time.id,
  unit.id,
  treatment,
  refinement.method,
  size.match,
  ordered.data,
  match.missing,
  covs.formula,
  verbose,
  lead,
  outcome.var = NULL,
  forbid.treatment.reversal = FALSE,
  qoi = "",
  matching = TRUE,
  exact.matching.variables = NULL,
  listwise.deletion,
  use.diag.covmat = FALSE,
  placebo.test = FALSE,
  restrict.control.period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perform_refinement_+3A_lag">lag</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_time.id">time.id</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_unit.id">unit.id</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_treatment">treatment</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_refinement.method">refinement.method</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_size.match">size.match</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame that has been balanced and ordered by time-unit.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_match.missing">match.missing</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_covs.formula">covs.formula</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_verbose">verbose</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_outcome.var">outcome.var</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_forbid.treatment.reversal">forbid.treatment.reversal</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_qoi">qoi</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_matching">matching</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_exact.matching.variables">exact.matching.variables</code></td>
<td>
</td></tr>
<tr><td><code id="perform_refinement_+3A_listwise.deletion">listwise.deletion</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_use.diag.covmat">use.diag.covmat</code></td>
<td>
<p>See PanelMatch() documentation for use.diagonal.covariance.matrix argument.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_placebo.test">placebo.test</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_restrict.control.period">restrict.control.period</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matched.set object containing the refined matched sets
</p>

<hr>
<h2 id='perunitSum'>perunitSum
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)</h2><span id='topic+perunitSum'></span>

<h3>Description</h3>

<p>perunitSum
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perunitSum(udf, lead.in, dependent.in, qoi_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perunitSum_+3A_udf">udf</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_lead.in">lead.in</code></td>
<td>
<p>integer. A particular lead value</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_dependent.in">dependent.in</code></td>
<td>
<p>string specifying the dependent variable name</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_qoi_in">qoi_in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector containing the per-unit sums.
</p>

<hr>
<h2 id='perunitSum_Dit'>perunitSum_Dit
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit</h2><span id='topic+perunitSum_Dit'></span>

<h3>Description</h3>

<p>perunitSum_Dit
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perunitSum_Dit(udf, qoi_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perunitSum_Dit_+3A_udf">udf</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="perunitSum_Dit_+3A_qoi_in">qoi_in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector containing the per-unit sums.
</p>

<hr>
<h2 id='placebo_test'>placebo_test</h2><span id='topic+placebo_test'></span>

<h3>Description</h3>

<p>Calculates results for a placebo test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placebo_test(
  pm.obj,
  data,
  lag.in = NULL,
  number.iterations = 1000,
  confidence.level = 0.95,
  plot = FALSE,
  se.method = "bootstrap",
  parallel = FALSE,
  num.cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placebo_test_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="placebo_test_+3A_data">data</code></td>
<td>
<p>data.frame with the original data</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_lag.in">lag.in</code></td>
<td>
<p>integer indicating earliest the time period(s) in the future for which the placebo test change in outcome will be calculated. Calculations will be made over the period t - max(lag) to t-2, where t is the time of treatment. The results are similar to those returned by PanelEstimate(), except t-1 is used as the period of comparison, rather than the lead window. If not specified, the placebo test is conducted for periods from t - max(lag) to t-2.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer specifying the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_confidence.level">confidence.level</code></td>
<td>
<p>confidence level for the calculated standard error intervals</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether or not a plot should be generated, or just return the raw data from the calculations</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_se.method">se.method</code></td>
<td>
<p>character string describing the type of standard error to be used. Valid inputs include &quot;bootstrap&quot;, &quot;conditional&quot; and &quot;unconditional&quot;. When the QOI is ATE, only bootstrap can be used.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE and <code>se.method = ``bootstrap''</code>, bootstrap procedure will be parallelized. Default is FALSE. If <code>se.method</code> is not set to <code>bootstrap</code>, this option does nothing.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. Specifies the number of cores to use for parallelization. If <code>se.method = ``bootstrap''</code> and <code>parallel = TRUE</code>, then this option will take effect. Otherwise, it will do nothing.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_...">...</code></td>
<td>
<p>extra arguments to be passed to plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the results of a placebo test, looking at the change in outcome at time = t-1, compared to other pre-treatment periods in the lag window.
</p>


<h3>Value</h3>

<p>list with 2 or 3 elements: &quot;estimates&quot;, which contains the point estimates for the test, &quot;standard.errors&quot; which has the standard errors for each period and optionally &quot;bootstrapped.estimates&quot;, containing the bootstrapped point estimates for the test for each specified lag window period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "mahalanobis",
                         data = dem.sub, match.missing = TRUE,
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE,
                         placebo.test = TRUE)
placebo_test(PM.results, data = dem.sub, se.method = "unconditional", plot = FALSE)


</code></pre>

<hr>
<h2 id='plot.matched.set'>Plot the distribution of the sizes of matched sets.</h2><span id='topic+plot.matched.set'></span>

<h3>Description</h3>

<p>A plot method for creating a histogram of the distribution of the sizes of matched sets.
This method accepts all standard optional <code>hist</code> arguments via the <code>...</code> argument.
By default, empty matched sets (treated units that could not be
matched with any control units) are noted as a vertical bar at x = 0 and not included in the
regular histogram. See the <code>include.empty.sets</code> argument for more information about this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
plot(
  x,
  ...,
  border = NA,
  col = "grey",
  ylab = "Frequency of Size",
  xlab = "Matched Set Size",
  lwd = NULL,
  main = "Distribution of Matched Set Sizes",
  freq = TRUE,
  include.empty.sets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_border">border</code></td>
<td>
<p>default is NA. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_col">col</code></td>
<td>
<p>default is &quot;grey&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Frequency of Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Matched Set Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_lwd">lwd</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_main">main</code></td>
<td>
<p>default is &quot;Distribution of Matched Set Sizes&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_freq">freq</code></td>
<td>
<p>default is TRUE. See <code>freq</code> argument in <code>hist()</code> function for more.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_include.empty.sets">include.empty.sets</code></td>
<td>
<p>logical value indicating whether or not empty sets should be included in the histogram. default is FALSE. If FALSE, then empty sets will be noted as a separate vertical bar at x = 0. If TRUE, empty sets will be included as normal sets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "ps.match",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
plot(PM.results$att)
plot(PM.results$att, include.empty.sets = TRUE)

</code></pre>

<hr>
<h2 id='plot.PanelEstimate'>Plot point estimates and standard errors from a PanelEstimate calculation.</h2><span id='topic+plot.PanelEstimate'></span>

<h3>Description</h3>

<p>The <code>plot.PanelEstimate</code> method takes an object returned by the <code>PanelEstimate</code> function and plots the calculated 
point estimates and standard errors over the specified <code>lead</code> time period. 
The only mandatory argument is an object of the <code>PanelEstimate</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
plot(
  x,
  ylab = "Estimated Effect of Treatment",
  xlab = "Time",
  main = "Estimated Effects of Treatment Over Time",
  ylim = NULL,
  pch = NULL,
  cex = NULL,
  bias.corrected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PanelEstimate_+3A_x">x</code></td>
<td>
<p>a <code>PanelEstimate</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Estimated Effect of Treatment.&quot; This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Time&quot;. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_main">main</code></td>
<td>
<p>default is &quot;Estimated Effects of Treatment Over Time&quot;. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylim">ylim</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_pch">pch</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_cex">cex</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_bias.corrected">bias.corrected</code></td>
<td>
<p>logical indicating whether or not bias corrected estimates should be plotted Default is FALSE. This argument only applies for standard errors calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "mahalanobis", 
                         data = dem.sub, match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem.sub, se.method = "unconditional")
plot(PE.results)

</code></pre>

<hr>
<h2 id='prepare_data'>prepare_data
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>prepare_data
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  data.in,
  lead,
  sets.att = NULL,
  sets.atc = NULL,
  qoi.in,
  dependent.variable
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_data.in">data.in</code></td>
<td>
<p>data.frame: the data to be used in the analysis</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_sets.att">sets.att</code></td>
<td>
<p>matched.set object containing ATT or ART matched sets.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_sets.atc">sets.atc</code></td>
<td>
<p>matched.set object containing ATC matched sets.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_qoi.in">qoi.in</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_dependent.variable">dependent.variable</code></td>
<td>
<p>string specifying the outcome/dependent variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the results of the lower level calculations
</p>

<hr>
<h2 id='print.matched.set'>Print <code>matched.set</code> objects.</h2><span id='topic+print.matched.set'></span>

<h3>Description</h3>

<p>Print <code>matched.set</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
print(x, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print</code></p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in expanded/raw list form.
The verbose form is not recommended unless the data set is small. Default is FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "ps.match",
                         data = dem, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
print(PM.results$att)



</code></pre>

<hr>
<h2 id='set_lwd_refinement'>set_lwd_refinement
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.</h2><span id='topic+set_lwd_refinement'></span>

<h3>Description</h3>

<p>set_lwd_refinement
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_lwd_refinement(
  mset,
  local.data,
  time,
  id,
  lag,
  refinement.method,
  lead,
  verbose,
  size.match,
  unit.id,
  time.id,
  covs.formula,
  match.missing,
  treatment,
  use.diag.covmat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_lwd_refinement_+3A_mset">mset</code></td>
<td>
<p>individual matched set</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_local.data">local.data</code></td>
<td>
<p>data.frame containing the data relevant for set level refinement</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_time">time</code></td>
<td>
<p>time of treated observation</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_id">id</code></td>
<td>
<p>id of treated observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an individual matched set
</p>

<hr>
<h2 id='summary.matched.set'>Summarize information about a <code>matched.set</code> object and the matched sets contained within them.</h2><span id='topic+summary.matched.set'></span>

<h3>Description</h3>

<p>A method for viewing summary data about the sizes of matched sets and metadata about how they were created. This method
accepts all standard <code>summary</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
summary(object, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.matched.set_+3A_object">object</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to be passed to the <code>summary</code> function</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>Logical value specifying whether or not a longer, more verbose summary should be calculated and returned. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object with either 5 or 1 element(s), depending on whether or not <code>verbose</code> is set to <code>TRUE</code> or not.
</p>
<table>
<tr><td><code>overview</code></td>
<td>
<p>A <code>data.frame</code> object containing information about the treated units (unit id, time of treatment), and the number of matched control units with weights zero and above.</p>
</td></tr>
<tr><td><code>set.size.summary</code></td>
<td>
<p>a <code>summary</code> object summarizing the minimum, maximum, and IQR of matched set sizes</p>
</td></tr>
<tr><td><code>number.of.treated.units</code></td>
<td>
<p>The number of unit, time pairs that are considered to be &quot;treated&quot; units</p>
</td></tr>
<tr><td><code>num.units.empty.set</code></td>
<td>
<p>The number of units treated at a particular time that were not able to be matched to any control units</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>The size of the lag window used for matching on treatment history. This affects which treated and control units are matched.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2",
                         treatment = "dem", refinement.method = "ps.match",
                         data = dem.sub, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
summary(PM.results$att)



</code></pre>

<hr>
<h2 id='summary.PanelEstimate'>Get summaries of PanelEstimate objects/calculations</h2><span id='topic+summary.PanelEstimate'></span>

<h3>Description</h3>

<p><code>summary.PanelEstimate</code> takes an object returned by
<code>PanelEstimate</code>, and returns a summary table of point
estimates and confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
summary(object, verbose = TRUE, bias.corrected = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PanelEstimate_+3A_object">object</code></td>
<td>
<p>A PanelEstimate object</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in an expanded form. Default is TRUE</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_bias.corrected">bias.corrected</code></td>
<td>
<p>logical indicating whether or not bias corrected estimates should be provided. Default is FALSE. This argument only applies for standard errors calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently, no additional arguments are supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, time.id = "year", unit.id = "wbcode2", 
                         treatment = "dem", refinement.method = "ps.weight", 
                         data = dem.sub, match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         outcome.var = "y", lead = 0:4, forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, data = dem.sub, se.method = "unconditional")
summary(PE.results)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
