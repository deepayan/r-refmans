<!DOCTYPE html><html lang="en"><head><title>Help for package PanelMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PanelMatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PanelMatch-package'><p>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</p></a></li>
<li><a href='#+5B.matched.set'><p>Subset matched.set object</p></a></li>
<li><a href='#+5B.PanelBalance'><p>Subset PanelBalance objects</p></a></li>
<li><a href='#build_maha_mats'><p>build_maha_mats</p>
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set</a></li>
<li><a href='#build_ps_data'><p>build_ps_data</p></a></li>
<li><a href='#calculate_estimates'><p>calculate_estimates</p></a></li>
<li><a href='#calculate_placebo_estimates'><p>calculate_placebo_estimates</p></a></li>
<li><a href='#calculate_point_estimates'><p>calculate_point_estimates</p>
Helper function that calculates the point estimates for the specified QOI</a></li>
<li><a href='#check_time_data'><p>check_time_data</p></a></li>
<li><a href='#clean_leads'><p>clean_leads</p>
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.</a></li>
<li><a href='#dem'><p>Country-year level democratization data</p></a></li>
<li><a href='#DisplayTreatment'><p>Visualize the treatment distribution across units and time in a panel data set</p></a></li>
<li><a href='#distances'><p>Get distances</p>
See distances.matched.set method</a></li>
<li><a href='#distances.matched.set'><p>Extract the distances of matched control units</p></a></li>
<li><a href='#enforce_lead_restrictions'><p>enforce_lead_restrictions</p>
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)</a></li>
<li><a href='#equality_four'><p>equality_four</p>
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)</a></li>
<li><a href='#equality_four_placebo'><p>equality_four_placebo</p></a></li>
<li><a href='#expand_treated_ts'><p>expand_treated_ts</p>
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets</a></li>
<li><a href='#extract'><p>Extract matched.set objects from PanelMatch results</p></a></li>
<li><a href='#extract_differences'><p>extract_differences</p>
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.</a></li>
<li><a href='#extract.PanelMatch'><p>Extract matched.set objects from PanelMatch results</p></a></li>
<li><a href='#find_ps'><p>find_ps</p></a></li>
<li><a href='#findBinaryTreated'><p>findBinaryTreated</p></a></li>
<li><a href='#get_covariate_balance'><p>Calculate covariate balance measures for refined and unrefined matched sets</p></a></li>
<li><a href='#get_set_treatment_effects'><p>Calculate matched set level treatment effects</p></a></li>
<li><a href='#get_unrefined_balance'><p>Extract just the unrefined covariate balance results, if they exist</p></a></li>
<li><a href='#get_unrefined_balance.PanelBalance'><p>Extract unrefined covariate balance results, if they exist</p></a></li>
<li><a href='#get.matchedsets'><p>get.matchedsets</p></a></li>
<li><a href='#getDits'><p>getDits</p>
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.</a></li>
<li><a href='#getWits'><p>getWits</p>
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.</a></li>
<li><a href='#handle_bootstrap'><p>handle_bootstrap</p></a></li>
<li><a href='#handle_bootstrap_parallel'><p>handle_bootstrap_parallel</p></a></li>
<li><a href='#handle_bootstrap_placebo'><p>handle_bootstrap_placebo</p></a></li>
<li><a href='#handle_bootstrap_placebo_parallel'><p>handle_bootstrap_placebo_parallel</p></a></li>
<li><a href='#handle_conditional_se'><p>handle_conditional_se</p>
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</a></li>
<li><a href='#handle_mahalanobis_calculations'><p>handle_mahalanobis_calculations</p>
Returns a matched.set object with weights for control units, along with some other metadata</a></li>
<li><a href='#handle_missing_data'><p>handle_missing_data</p></a></li>
<li><a href='#handle_moderating_variable'><p>handle_moderating_variable</p></a></li>
<li><a href='#handle_ps_match'><p>handle_ps_match</p>
Returns a matched.set object with weights for control units, along with some other metadata</a></li>
<li><a href='#handle_ps_weighted'><p>handle_ps_weighted</p></a></li>
<li><a href='#handle_unconditional_se'><p>handle_conditional_se</p>
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</a></li>
<li><a href='#identifyDirectionalChanges'><p>identifyDirectionalChanges</p>
Identifies changes in treatment variable for treated and control observations</a></li>
<li><a href='#lwd_refinement'><p>lwd_refinement</p>
master function that performs refinement with listwise deletion = TRUE</a></li>
<li><a href='#lwd_units'><p>lwd_units</p>
helper function that actually subsets sets down to contain units with complete data</a></li>
<li><a href='#matched_set'><p>A constructor for the matched.set class.</p></a></li>
<li><a href='#merge_formula'><p>merge_formula</p></a></li>
<li><a href='#PanelData'><p>Pre-process and balance panel data</p></a></li>
<li><a href='#PanelEstimate'><p>Estimate a causal quantity of interest</p></a></li>
<li><a href='#PanelMatch'><p>Create and refine sets of matched treated and control observations</p></a></li>
<li><a href='#parse_and_prep'><p>parse_and_prep</p></a></li>
<li><a href='#pcs'><p>Prepare Control Units</p>
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.</a></li>
<li><a href='#perform_refinement'><p>perform_refinement</p>
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()</a></li>
<li><a href='#perunitSum'><p>perunitSum</p>
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)</a></li>
<li><a href='#perunitSum_Dit'><p>perunitSum_Dit</p>
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit</a></li>
<li><a href='#placebo_test'><p>Conduct a placebo test</p></a></li>
<li><a href='#plot_matched_set'><p>Helper function for plotting the distribution of matched set sizes</p></a></li>
<li><a href='#plot.matched.set'><p>Plot the distribution of control unit weights</p></a></li>
<li><a href='#plot.PanelBalance'><p>Plot covariate balance results</p>
Create figures displaying covariate balance results for one or more <code>PanelMatch</code> configurations. Users can customize these visualizations.</a></li>
<li><a href='#plot.PanelData'><p>Create basic plots of PanelData objects</p></a></li>
<li><a href='#plot.PanelEstimate'><p>Plot point estimates and standard errors from a PanelEstimate calculation.</p></a></li>
<li><a href='#plot.PanelMatch'><p>Plot the distribution of the sizes of matched sets.</p></a></li>
<li><a href='#prepare_data'><p>prepare_data</p>
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.</a></li>
<li><a href='#print.matched.set'><p>Print matched.set objects.</p></a></li>
<li><a href='#print.PanelBalance'><p>Print basic information about PanelBalance objects</p></a></li>
<li><a href='#print.PanelData'><p>Print PanelData objects and basic metadata</p></a></li>
<li><a href='#print.PanelEstimate'><p>Print point estimates and standard errors</p></a></li>
<li><a href='#print.PanelMatch'><p>Print PanelMatch objects.</p></a></li>
<li><a href='#set_lwd_refinement'><p>set_lwd_refinement</p>
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.</a></li>
<li><a href='#summary.matched.set'><p>Summarize information about a matched.set object and the matched sets contained within them.</p></a></li>
<li><a href='#summary.PanelBalance'><p>Summarize covariate balance over time</p></a></li>
<li><a href='#summary.PanelData'><p>Summarize the number of unique units and time periods in a PanelData object</p></a></li>
<li><a href='#summary.PanelEstimate'><p>Get summaries of PanelEstimate objects and calculations</p></a></li>
<li><a href='#summary.PanelMatch'><p>Summarize information about a PanelMatch object and the matched sets contained within them.</p></a></li>
<li><a href='#weights'><p>Get weights of matched control units</p>
See weights.matched.set method</a></li>
<li><a href='#weights.matched.set'><p>Extract the weights of matched control units</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching Methods for Causal Inference with Time-Series
Cross-Sectional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a set of methodological tools
	     that enable researchers to apply matching methods to
	     time-series cross-sectional data. Imai, Kim, and Wang
	     (2023) <a href="http://web.mit.edu/insong/www/pdf/tscs.pdf">http://web.mit.edu/insong/www/pdf/tscs.pdf</a> 
	     proposes a nonparametric generalization of the
	     difference-in-differences estimator, which does not rely
	     on the linearity assumption as often done in
	     practice. Researchers first select a method of matching
	     each treated observation for a given unit in a
	     particular time period with control observations from
	     other units in the same time period that have a similar
	     treatment and covariate history. These methods include
	     standard matching methods based on propensity score and
	     Mahalanobis distance, as well as weighting methods. Once 
	     matching and refinement is done,  
	     treatment effects can be estimated with 
	     standard errors. The package also offers diagnostics for researchers to assess the quality 
	     of their results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), data.table, ggplot2, CBPS, stats, graphics,
MASS, Matrix, doParallel, foreach, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insongkim/PanelMatch/issues">https://github.com/insongkim/PanelMatch/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-01 22:09:31 UTC; adamrauh</td>
</tr>
<tr>
<td>Author:</td>
<td>In Song Kim [aut, cre],
  Adam Rauh [aut],
  Erik Wang [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>In Song Kim &lt;insong@mit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 09:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='PanelMatch-package'>Matching Methods for Causal Inference with Time-Series Cross-Sectional Data</h2><span id='topic+PanelMatch-package'></span>

<h3>Description</h3>

<p>Implements a set of methodological tools
that enable researchers to apply matching methods to
time-series cross-sectional data. Imai, Kim, and Wang
(2023) proposes a nonparametric generalization of the
difference-in-differences estimator, which does not rely
on the linearity assumption as often done in
practice. Researchers first select a method of matching
each treated observation for a given unit in a
particular time period with control observations from
other units in the same time period that have a similar
treatment and covariate history. These methods include
standard matching methods based on propensity score and
Mahalanobis distance, as well as weighting methods. Once 
matching is done, both short-term and long-term average 
treatment effects for the treated observations can be estimated with 
standard errors. The package also offers a variety of diagnostic
and visualization functions to assess the credibility of results.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>
<p>Maintainer: In Song Kim <a href="mailto:insong@mit.edu">insong@mit.edu</a>
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim and Erik Wang. (2023)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/insongkim/PanelMatch/issues">https://github.com/insongkim/PanelMatch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.matched.set'>Subset matched.set object</h2><span id='topic++5B.matched.set'></span>

<h3>Description</h3>

<p>Subsets <code>matched.set</code> objects while preserving attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
x[i, j = NULL, drop = NULL]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.matched.set_+3A_x">x</code></td>
<td>
<p><code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="+2B5B.matched.set_+3A_i">i</code></td>
<td>
<p>numeric. specifies the index of which element to extract.</p>
</td></tr>
<tr><td><code id="+2B5B.matched.set_+3A_j">j</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code id="+2B5B.matched.set_+3A_drop">drop</code></td>
<td>
<p>NULL</p>
</td></tr>
</table>

<hr>
<h2 id='+5B.PanelBalance'>Subset PanelBalance objects</h2><span id='topic++5B.PanelBalance'></span>

<h3>Description</h3>

<p>Subset PanelBalance objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelBalance'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.PanelBalance_+3A_x">x</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
<tr><td><code id="+2B5B.PanelBalance_+3A_i">i</code></td>
<td>
<p>numeric. Specifies which element to extract. Substantively, it specifies which <code>PanelMatch</code> configuration data to extract.</p>
</td></tr>
<tr><td><code id="+2B5B.PanelBalance_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns balance information for specified <code>PanelMatch</code> configuration. Note that results are still returned as a <code>PanelBalance</code> object. In order to return a list, use the [[ operator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- runif(runif(nrow(dem)))
dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "mahalanobis", 
                     panel.data = dem.panel, match.missing = TRUE,
                     covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                     size.match = 5, qoi = "att")

# create multiple configurations to compare
pm2 &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "ps.match", 
                  panel.data = dem.panel, match.missing = TRUE,
                  covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                  size.match = 5, qoi = "att")

pb &lt;- get_covariate_balance(pm.obj, pm2,
                            include.unrefined = TRUE,
                            panel.data = dem.panel, 
                            covariates = c("tradewb", "rdata"))
bal.maha &lt;- pb[1]
bal.ps &lt;- pb[2]                             
</code></pre>

<hr>
<h2 id='build_maha_mats'>build_maha_mats
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set</h2><span id='topic+build_maha_mats'></span>

<h3>Description</h3>

<p>build_maha_mats
Builds the matrices that we will then use to calculate the mahalanobis distances for each matched set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_maha_mats(idx, ordered_expanded_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_maha_mats_+3A_idx">idx</code></td>
<td>
<p>List of vectors specifying which observations should be extracted</p>
</td></tr>
<tr><td><code id="build_maha_mats_+3A_ordered_expanded_data">ordered_expanded_data</code></td>
<td>
<p>data.frame of prepared/parsed input data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of parsed distance matrices, with elements corresponding to each matched set
</p>

<hr>
<h2 id='build_ps_data'>build_ps_data</h2><span id='topic+build_ps_data'></span>

<h3>Description</h3>

<p>build_ps_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_ps_data(idxlist, data, lag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_ps_data_+3A_idxlist">idxlist</code></td>
<td>
</td></tr>
<tr><td><code id="build_ps_data_+3A_data">data</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="build_ps_data_+3A_lag">lag</code></td>
<td>
<p>see PanelMatch() documentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of length equal to the number of matched sets. Each item is a data frame and each data frame contains information at time = t + 0 for each treated unit and their corresponding controls.
</p>

<hr>
<h2 id='calculate_estimates'>calculate_estimates</h2><span id='topic+calculate_estimates'></span>

<h3>Description</h3>

<p>Mid-level function that helps with estimation process. Calls lower level helper functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_estimates(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  att.sets,
  atc.sets,
  placebo.test = FALSE,
  lag,
  se.method,
  pooled = FALSE,
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_estimates_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_lead">lead</code></td>
<td>
<p>integer specifying lead window</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_att.sets">att.sets</code></td>
<td>
<p>matched.set object specifying the att or art sets</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_atc.sets">atc.sets</code></td>
<td>
<p>matched.set object specifying the atc sets</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_se.method">se.method</code></td>
<td>
<p>string specifying which method should be used for standard error calculation</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_pooled">pooled</code></td>
<td>
<p>bool. specifies whether or not estimates should be calculated for each lead period, or pooled across all lead periods</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_parallel">parallel</code></td>
<td>
<p>bool. Specifies whether or not parallelization should be used</p>
</td></tr>
<tr><td><code id="calculate_estimates_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. specifies how many cores to use for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PanelEstimate object.
</p>

<hr>
<h2 id='calculate_placebo_estimates'>calculate_placebo_estimates</h2><span id='topic+calculate_placebo_estimates'></span>

<h3>Description</h3>

<p>Handles the procedures for calculating point estimates and standard errors for the placebo test. Code is structured very similarly to the calculate_estimates() code, but with appropriate modifications for the placebo test. See that function for description of arguments. Bootstrap SEs are available for any specification. Conditional, unconditional standard errors only available for att, art, atc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_placebo_estimates(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  att.sets,
  atc.sets,
  placebo.test = FALSE,
  lag,
  placebo.lead,
  se.method = "bootstrap",
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Value</h3>

<p>Returns a PanelEstimate object
</p>

<hr>
<h2 id='calculate_point_estimates'>calculate_point_estimates
Helper function that calculates the point estimates for the specified QOI</h2><span id='topic+calculate_point_estimates'></span>

<h3>Description</h3>

<p>calculate_point_estimates
Helper function that calculates the point estimates for the specified QOI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_point_estimates(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  pooled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_point_estimates_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_data.in">data.in</code></td>
<td>
<p>data.frame providing the processed/parsed data to be used for calculations</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_lead">lead</code></td>
<td>
<p>see PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the outcome variable</p>
</td></tr>
<tr><td><code id="calculate_point_estimates_+3A_pooled">pooled</code></td>
<td>
<p>Logical. See PanelEstimate() documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of point estimates
</p>

<hr>
<h2 id='check_time_data'>check_time_data</h2><span id='topic+check_time_data'></span>

<h3>Description</h3>

<p>Time data should be consecutive integers: When it is not, try to convert it as best we can or throw an error. If function does not fail, returns the data as data frame object, either processed or not as appropriately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_time_data(data, time.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_time_data_+3A_data">data</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="check_time_data_+3A_time.id">time.id</code></td>
<td>
<p>string specifying the time id variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>enforces the requirements for time data, with some reasonable defaults
</p>


<h3>Value</h3>

<p>data.frame object with the data. If function throws error, nothing is returned.
</p>

<hr>
<h2 id='clean_leads'>clean_leads
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.</h2><span id='topic+clean_leads'></span>

<h3>Description</h3>

<p>clean_leads
Function to check the lead windows in treated and control units for missing outcome data. If data is missing, remove those units from matched sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_leads(matched_sets, ordered.data, max.lead, t.var, id.var, outcome.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_leads_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object contained pre-filtered matched sets</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame object to be checked for missing data. This should have been passed through data preparation functions already.</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_max.lead">max.lead</code></td>
<td>
<p>Integer specifying the biggest value of the lead window.</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time id variable</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="clean_leads_+3A_outcome.var">outcome.var</code></td>
<td>
<p>string specifying the outcome variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cleaned/filtered matched.set object
</p>

<hr>
<h2 id='dem'>Country-year level democratization data</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>A dataset containing the democracy indicator for 184 countries from
1960 to 2010
</p>


<h3>Format</h3>

<p>A data.frame containing 9384 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> wbcode2. World Bank country ID. Integer.
</p>
</li>
<li><p> year. year (1960&ndash;2010). Integer.
</p>
</li>
<li><p> dem. binary indicator of democracy as defined in Acemoglu et al (2019).
</p>
</li>
<li><p> y log of GDP per capita in 2000 constant dollars (multiplied by 100). Numeric.
</p>
</li>
<li><p> tradewb Exports plus imports as a share of GDP from World Bank. Numeric.
</p>
</li></ul>



<h3>Source</h3>

<p>Acemoglu, Daron, Suresh Naidu, Pascual Restrepo, and James
A Robinson. &ldquo;Democracy does cause growth.&rdquo; Journal of Political
Economy.
</p>

<hr>
<h2 id='DisplayTreatment'>Visualize the treatment distribution across units and time in a panel data set</h2><span id='topic+DisplayTreatment'></span>

<h3>Description</h3>

<p>Visualize the treatment distribution across units and time in a panel data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayTreatment(
  panel.data,
  color.of.treated = "red",
  color.of.untreated = "blue",
  title = "Treatment Distribution \n Across Units and Time",
  xlab = "Time",
  ylab = "Unit",
  x.size = NULL,
  y.size = NULL,
  legend.position = "none",
  x.angle = NULL,
  y.angle = NULL,
  legend.labels = c("not treated", "treated"),
  decreasing = FALSE,
  matched.set = NULL,
  show.set.only = FALSE,
  hide.x.tick.label = FALSE,
  hide.y.tick.label = FALSE,
  gradient.weights = FALSE,
  dense.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DisplayTreatment_+3A_panel.data">panel.data</code></td>
<td>
<p><code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.treated">color.of.treated</code></td>
<td>
<p>Color of the treated observations provided as a character string (this includes hex values). Default is red.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_color.of.untreated">color.of.untreated</code></td>
<td>
<p>Color of the untreated observations provided as a character string (this includes hex values). Default is blue.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_title">title</code></td>
<td>
<p>Title of the plot provided as character string</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_xlab">xlab</code></td>
<td>
<p>Character label of the x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_ylab">ylab</code></td>
<td>
<p>Character label of the y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.size">x.size</code></td>
<td>
<p>Numeric size of the text for xlab or x axis tick labels. Assign x.size = NULL to use built in ggplot2 method of determining label size. 
When the length of the time period is long, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.size">y.size</code></td>
<td>
<p>Numeric size of the text for ylab or y axis tick labels. Assign y.size = NULL to use built in ggplot2 method of determining label size. 
When the number of units is large, consider setting to NULL and adjusting size and ratio of the plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.position">legend.position</code></td>
<td>
<p>Position of the legend. Provide this according to ggplot2 standards.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_x.angle">x.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for x-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_y.angle">y.angle</code></td>
<td>
<p>Angle (in degrees) of the tick labels for y-axis</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_legend.labels">legend.labels</code></td>
<td>
<p>Character vector of length two describing the
labels of the legend to be shown in the plot. ggplot2 standards are used.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Determines if display order should be increasing or decreasing by the amount of treatment received. Default is <code>decreasing</code> = FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_matched.set">matched.set</code></td>
<td>
<p>(optional) a <code>matched.set</code> object containing a single treated unit and a set of matched controls. If provided, this set will be highlighted on the resulting plot.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_show.set.only">show.set.only</code></td>
<td>
<p>(optional) logical. If TRUE, only the treated unit and control units contained in the provided <code>matched.set</code> object will be shown on the plot. 
Default is FALSE. If no <code>matched.set</code> is provided, then this argument will have no effect.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.x.tick.label">hide.x.tick.label</code></td>
<td>
<p>logical. If TRUE, x axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_hide.y.tick.label">hide.y.tick.label</code></td>
<td>
<p>logical. If TRUE, y axis tick labels are not shown. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_gradient.weights">gradient.weights</code></td>
<td>
<p>(optional) logical. If TRUE, the &quot;darkness&quot;/shade of units in the provided <code>matched.set</code> object will be displayed according to their weight. Control units with higher weights will appear darker on the resulting plot. Control units with lower weights will appear lighter. This argument has no effect unless a <code>matched.set</code> is provided.</p>
</td></tr>
<tr><td><code id="DisplayTreatment_+3A_dense.plot">dense.plot</code></td>
<td>
<p>logical. if TRUE, lines between tiles are removed on resulting plot. This is useful for producing more readable plots in situations where the number of units and/or time periods is very high.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DisplayTreatment</code> returns a treatment variation plot (generated via ggplot2 geom_tile() or geom_raster()),
which visualizes the variation of treatment across units and time. The results can be customized using ggplot2 syntax.
</p>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.panel &lt;- PanelData(panel.data = dem, 
              unit.id = "wbcode2", 
              time.id = "year", 
              treatment = "dem", 
              outcome = "y")
DisplayTreatment(panel.data = dem.panel,
                 legend.position = "none",
                 xlab = "year", ylab = "Country Code")


</code></pre>

<hr>
<h2 id='distances'>Get distances
See distances.matched.set method</h2><span id='topic+distances'></span>

<h3>Description</h3>

<p>Get distances
See distances.matched.set method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distances(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distances_+3A_object">object</code></td>
<td>
<p><code>matched.set</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='distances.matched.set'>Extract the distances of matched control units</h2><span id='topic+distances.matched.set'></span>

<h3>Description</h3>

<p>Extract the distances of matched control units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
distances(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distances.matched.set_+3A_object">object</code></td>
<td>
<p>a matched.set object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of named vectors. Each element corresponds to a matched set and will be a named vector, where the names of each element will identify a matched control unit and its distance from the treated observation within a particular matched set. These correspond to the &quot;distances&quot; attribute, which are calculated and included when the <code>verbose</code> option is set to TRUE in <code>PanelMatch</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.panel, lag = 4,
                         refinement.method = "mahalanobis",
                         verbose = TRUE,
                         match.missing = TRUE,
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4,
                         forbid.treatment.reversal = FALSE)
r1 &lt;- extract(PM.results, qoi = "att")
lt &lt;- distances(r1)
</code></pre>

<hr>
<h2 id='enforce_lead_restrictions'>enforce_lead_restrictions
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)</h2><span id='topic+enforce_lead_restrictions'></span>

<h3>Description</h3>

<p>enforce_lead_restrictions
check treatment and control units for treatment reversion in the lead window. Treated units must stay treated and control units must stay in control (according to the specified qoi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enforce_lead_restrictions(
  matched_sets,
  ordered.data,
  max.lead,
  t.var,
  id.var,
  treatment.var
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enforce_lead_restrictions_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_ordered.data">ordered.data</code></td>
<td>
<p>parsed data as data.frame object</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_max.lead">max.lead</code></td>
<td>
<p>The largest lead value (e.g. the biggest F)</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time variable</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="enforce_lead_restrictions_+3A_treatment.var">treatment.var</code></td>
<td>
<p>string specifying the treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with the matched sets that meet the conditions
</p>

<hr>
<h2 id='equality_four'>equality_four
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)</h2><span id='topic+equality_four'></span>

<h3>Description</h3>

<p>equality_four
Small helper function implementing estimation function from Imai, Kim, and Wang (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equality_four(x, y, z)
</code></pre>


<h3>Value</h3>

<p>Returns numeric vector of results.
</p>

<hr>
<h2 id='equality_four_placebo'>equality_four_placebo</h2><span id='topic+equality_four_placebo'></span>

<h3>Description</h3>

<p>Small helper function implementing estimation function from Imai, Kim, and Wang (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equality_four_placebo(x, y, z)
</code></pre>


<h3>Value</h3>

<p>Returns numeric vector of results.
</p>

<hr>
<h2 id='expand_treated_ts'>expand_treated_ts
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets</h2><span id='topic+expand_treated_ts'></span>

<h3>Description</h3>

<p>expand_treated_ts
Builds a list that contains all times in a lag window that correspond to a particular treated unit. This is structured as a list of vectors. Each vector is lag + 1 units long. The overall list will be the same length as the number of matched sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_treated_ts(lag, treated.ts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_treated_ts_+3A_lag">lag</code></td>
<td>
<p>lag value</p>
</td></tr>
<tr><td><code id="expand_treated_ts_+3A_treated.ts">treated.ts</code></td>
<td>
<p>times of treated observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list. Contains all times in a lag window that correspond to a particular treated unit
</p>

<hr>
<h2 id='extract'>Extract matched.set objects from PanelMatch results</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>Extract matched.set objects from PanelMatch results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(pm.object, qoi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_+3A_pm.object">pm.object</code></td>
<td>
<p><code>PanelMatch</code> object</p>
</td></tr>
<tr><td><code id="extract_+3A_qoi">qoi</code></td>
<td>
<p>character, specifying the qoi. Valid inputs include &quot;att&quot;, &quot;atc&quot;, &quot;art&quot;, and NULL. If NULL, function extracts att, art, or atc results if possible. Otherwise, throws an error if ate is specified.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_differences'>extract_differences
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.</h2><span id='topic+extract_differences'></span>

<h3>Description</h3>

<p>extract_differences
This function calculates the differences from t-1 to 1 for treated and control units in the treatment variable. While functionality is somewhat trivial for current implementation of package, it will be needed for continuous treatment version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_differences(indexed.data, matched.set, treatment.variable, qoi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_differences_+3A_indexed.data">indexed.data</code></td>
<td>
<p>data that has been indexed. Rows have been named with a unique identifier.</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_matched.set">matched.set</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_treatment.variable">treatment.variable</code></td>
<td>
<p>string specifying treatment variable</p>
</td></tr>
<tr><td><code id="extract_differences_+3A_qoi">qoi</code></td>
<td>
<p>string specifying QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object, with differences extracted as described previously for each matched set.
</p>

<hr>
<h2 id='extract.PanelMatch'>Extract matched.set objects from PanelMatch results</h2><span id='topic+extract.PanelMatch'></span>

<h3>Description</h3>

<p>Extract matched.set objects from PanelMatch results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelMatch'
extract(pm.object, qoi = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.PanelMatch_+3A_pm.object">pm.object</code></td>
<td>
<p><code>PanelMatch</code> obect</p>
</td></tr>
<tr><td><code id="extract.PanelMatch_+3A_qoi">qoi</code></td>
<td>
<p>character, specifying the qoi. Valid inputs include &quot;att&quot;, &quot;atc&quot;, &quot;art&quot;, and NULL. If NULL, function extracts att, art, or atc results if possible. Otherwise, throws an error if ate is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matched.set</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel,
                         lag = 4, 
                         refinement.method = "mahalanobis",
                         match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, forbid.treatment.reversal = FALSE)
extract(PM.results, qoi = "att")
extract(PM.results) # valid since att is specified
</code></pre>

<hr>
<h2 id='find_ps'>find_ps</h2><span id='topic+find_ps'></span>

<h3>Description</h3>

<p>find_ps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ps(sets, fitted.model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_ps_+3A_sets">sets</code></td>
<td>
<p>matched sets</p>
</td></tr>
<tr><td><code id="find_ps_+3A_fitted.model">fitted.model</code></td>
<td>
<p>Result of a fitted (CB) PS model call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frames with propensity score weights for each unit in a matched set. Each element in the list is a data frame which corresponds to a matched set of 1 treatment and all matched control units
</p>

<hr>
<h2 id='findBinaryTreated'>findBinaryTreated</h2><span id='topic+findBinaryTreated'></span>

<h3>Description</h3>

<p><code>findBinaryTreated</code> is used to identify t,id pairs of units for which a matched set might exist.
More precisely, it finds units for which at time t, the specified treatment has been applied, but at time t - 1, the treatment has not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findBinaryTreated(
  dmat,
  qoi.in,
  treatedvar,
  time.var,
  unit.var,
  hasbeensorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findBinaryTreated_+3A_dmat">dmat</code></td>
<td>
<p>Data frame or matrix containing data used to identify potential treated units. Must be specified in such a way that a combination of time and id variables will correspond to a unique row. Must also contain at least a binary treatment variable column as well.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that provides information about the binary treatment variable</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_time.var">time.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the time variable. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_unit.var">unit.var</code></td>
<td>
<p>Character string that identifies the name of the column in <code>dmat</code> that contains data about the variable used as a unit id. This data must be integer</p>
</td></tr>
<tr><td><code id="findBinaryTreated_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>findBinaryTreated</code> returns a subset of the data in the <code>dmat</code> data frame, containing only treated units for which a matched set might exist
</p>

<hr>
<h2 id='get_covariate_balance'>Calculate covariate balance measures for refined and unrefined matched sets</h2><span id='topic+get_covariate_balance'></span>

<h3>Description</h3>

<p>Calculate covariate balance for user specified covariates across matched sets. Balance is assessed by taking the average
of the difference between the values of the specified covariates for the treated unit(s) and the weighted average of
the control units across all matched sets. Results are standardized and are expressed in standard deviations.
Balance is calculated for each period in the specified lag window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covariate_balance(..., panel.data, covariates, include.unrefined = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_covariate_balance_+3A_...">...</code></td>
<td>
<p>one or more PanelMatch objects</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_panel.data">panel.data</code></td>
<td>
<p><code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_covariates">covariates</code></td>
<td>
<p>a character vector, specifying the names of the covariates for which the user is interested in calculating balance.</p>
</td></tr>
<tr><td><code id="get_covariate_balance_+3A_include.unrefined">include.unrefined</code></td>
<td>
<p>logical. Indicates whether or not covariate balance measures for unrefined matched sets should be included. If TRUE, the function will return covariate balance results for the PanelMatch configurations provided, as well as a set of balance results that assume all matched controls have equal weight (i.e., the matched sets are unrefined). These results are included in addition to whatever PanelMatch configurations are specified to the function. Note that if you provide a PanelMatch object where no refinement is applied (that is, where <code>refinement.method = "none"</code>) and set this option to TRUE, then both sets of covariate balance results will be identical. If FALSE, then only balance calculations for the provided PanelMatch specifications are performed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices, or a list of lists (if the QOI is ATE). The matrices contain the calculated covariate balance levels for each specified covariate for each period. Each element in the list (whether that be a matrix or a sublist) corresponds to a <code>PanelMatch</code> configuration specified to the function. Results are returned in the order they were provided. Unrefined results are stored as a parallel list object in an attribute called &quot;unrefined.balance.results&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
#add some additional data to data set for demonstration purposes
dem.sub$rdata &lt;- runif(runif(nrow(dem.sub)))
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb + rdata,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
get_covariate_balance(PM.results, panel.data = dem.sub.panel, covariates = c("tradewb", "rdata"))

</code></pre>

<hr>
<h2 id='get_set_treatment_effects'>Calculate matched set level treatment effects</h2><span id='topic+get_set_treatment_effects'></span>

<h3>Description</h3>

<p>Calculate the size of treatment effects for each matched set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_set_treatment_effects(pm.obj, panel.data, lead)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_set_treatment_effects_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_panel.data">panel.data</code></td>
<td>
<p><code>PanelData</code> object with the time series cross sectional data used for matching, refinement, and estimation</p>
</td></tr>
<tr><td><code id="get_set_treatment_effects_+3A_lead">lead</code></td>
<td>
<p>integer (or integer vector) indicating the time period(s) in the future for which the treatment effect size will be calculated. Calculations will be made for the period t + lead, where t is the time of treatment. If more than one lead value is provided, then calculations will be performed for each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list equal in length to the number of lead periods specified to the <code>lead</code> argument. Each element in the list is a vector of the matched set level effect estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
set.effects &lt;- get_set_treatment_effects(pm.obj = PM.results, 
                panel.data = dem.sub.panel, lead = 0)


</code></pre>

<hr>
<h2 id='get_unrefined_balance'>Extract just the unrefined covariate balance results, if they exist</h2><span id='topic+get_unrefined_balance'></span>

<h3>Description</h3>

<p>Extract just the unrefined covariate balance results, if they exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unrefined_balance(pb.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_unrefined_balance_+3A_pb.object">pb.object</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='get_unrefined_balance.PanelBalance'>Extract unrefined covariate balance results, if they exist</h2><span id='topic+get_unrefined_balance.PanelBalance'></span>

<h3>Description</h3>

<p>Extract unrefined covariate balance results, if they exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelBalance'
get_unrefined_balance(pb.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_unrefined_balance.PanelBalance_+3A_pb.object">pb.object</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PanelBalance</code> object, with just the unrefined balance results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- runif(runif(nrow(dem)))
dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "mahalanobis", 
                     panel.data = dem.panel, match.missing = TRUE,
                     covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                     size.match = 5, qoi = "att")

# create multiple configurations to compare
pm2 &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "ps.match", 
                  panel.data = dem.panel, match.missing = TRUE,
                  covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                  size.match = 5, qoi = "att")

pb &lt;- get_covariate_balance(pm.obj, pm2,
                            include.unrefined = TRUE,
                            panel.data = dem.panel, 
                            covariates = c("tradewb", "rdata"))
get_unrefined_balance(pb)
</code></pre>

<hr>
<h2 id='get.matchedsets'>get.matchedsets</h2><span id='topic+get.matchedsets'></span>

<h3>Description</h3>

<p><code>get.matchedsets</code> is used to identify matched sets for a given unit with a specified i, t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.matchedsets(
  t,
  id,
  data,
  L,
  t.column,
  id.column,
  treatedvar,
  hasbeensorted = FALSE,
  match.on.missingness = TRUE,
  matching = TRUE,
  qoi.in,
  restrict.control.period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.matchedsets_+3A_t">t</code></td>
<td>
<p>integer vector specifying the times of treated units for which matched sets should be found. This vector should be the same length as the following <code>id</code> parameter &ndash; the entries at corresponding indices in each vector should form the t,id pair of a specified treatment unit.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id">id</code></td>
<td>
<p>integer vector specifying the unit ids of treated units for which matched sets should be found. note that both <code>t</code> and <code>id</code> can be of length 1</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_data">data</code></td>
<td>
<p>data frame containing the data to be used for finding matched sets.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_l">L</code></td>
<td>
<p>An integer value indicating the length of treatment history to be matched</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_t.column">t.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the time variable. Each specified entry in <code>t</code> should be somewhere in this column in the data. This data must be integer that increases by one.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_id.column">id.column</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the unit id variable. Each specified entry in <code>id</code> should be somewhere in this column in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_treatedvar">treatedvar</code></td>
<td>
<p>Character string that identifies the name of the column in <code>data</code> that contains data about the binary treatment variable.</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_hasbeensorted">hasbeensorted</code></td>
<td>
<p>variable that only has internal usage for optimization purposes. There should be no need for a user to toggle this</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_match.on.missingness">match.on.missingness</code></td>
<td>
<p>TRUE/FALSE indicating whether or not the user wants to &quot;match on missingness.&quot; That is, should units with NAs in their treatment history windows be matched with control units that have NA's in corresponding places?</p>
</td></tr>
<tr><td><code id="get.matchedsets_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not the treatment history should be used for matching. This should almost always be set to TRUE, except for specific situations where the user is interested in particular diagnostic questions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.matchedsets</code> returns a &quot;matched set&quot; object, which primarily contains a named list of vectors. Each vector is a &quot;matched set&quot; containing the unit ids included in a matched set. The list names will indicate an i,t pair (formatted as &quot;&lt;i variable&gt;.&lt;t variable&gt;&quot;) to which the vector/matched set corresponds.
</p>

<hr>
<h2 id='getDits'>getDits
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.</h2><span id='topic+getDits'></span>

<h3>Description</h3>

<p>getDits
returns a vector of Dit values, as defined in the paper. They should be in the same order as the data frame containing the original problem data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDits(matched_sets, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDits_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="getDits_+3A_data">data</code></td>
<td>
<p>data.frame object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of Dits, as described in Imai et al. (2023)
</p>

<hr>
<h2 id='getWits'>getWits
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.</h2><span id='topic+getWits'></span>

<h3>Description</h3>

<p>getWits
returns a vector of Wits, as defined in the paper (equation 25 or equation 23). They should be in the same order as the data frame containing the original problem data. The pts, pcs, and getWits functions act for a specific lead. So, for instance if our lead window is 0,1,2,3,4, these function must be called for each of those &ndash; so for 0, then for 1, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWits(matched_sets, lead, data, estimation.method = "bootstrap")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWits_+3A_matched_sets">matched_sets</code></td>
<td>
<p>matched.set object</p>
</td></tr>
<tr><td><code id="getWits_+3A_lead">lead</code></td>
<td>
<p>integer providing a specific lead value</p>
</td></tr>
<tr><td><code id="getWits_+3A_data">data</code></td>
<td>
<p>data.frame object</p>
</td></tr>
<tr><td><code id="getWits_+3A_estimation.method">estimation.method</code></td>
<td>
<p>method of estimation for calculating standard errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of Wits, as described above
</p>

<hr>
<h2 id='handle_bootstrap'>handle_bootstrap</h2><span id='topic+handle_bootstrap'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the QOI. This version is not parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  pooled
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_bootstrap_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_+3A_pooled">pooled</code></td>
<td>
<p>logical. Specifies whether or not to calculate point estimates for each specified lead value, or a single pooled estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_parallel'>handle_bootstrap_parallel</h2><span id='topic+handle_bootstrap_parallel'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the QOI. This version is parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_parallel(
  qoi.in,
  data.in,
  lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  pooled,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_bootstrap_parallel_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_pooled">pooled</code></td>
<td>
<p>logical. Specifies whether or not to calculate point estimates for each specified lead value, or a single pooled estimate.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to be used for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_placebo'>handle_bootstrap_placebo</h2><span id='topic+handle_bootstrap_placebo'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the placebo test. This version is not parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_placebo(
  qoi.in,
  data.in,
  placebo.lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_bootstrap_placebo_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_bootstrap_placebo_parallel'>handle_bootstrap_placebo_parallel</h2><span id='topic+handle_bootstrap_placebo_parallel'></span>

<h3>Description</h3>

<p>Helper function for calculating bootstrapped estimates for the placebo test. This version is parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_bootstrap_placebo_parallel(
  qoi.in,
  data.in,
  placebo.lead,
  number.iterations,
  att.treated.unit.ids,
  atc.treated.unit.ids,
  outcome.variable,
  unit.id.variable,
  confidence.level,
  lag,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_qoi.in">qoi.in</code></td>
<td>
<p>String specifying qoi</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_data.in">data.in</code></td>
<td>
<p>data.frame object with the data</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer. Specifies number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_att.treated.unit.ids">att.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the treated units for the att or art</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_atc.treated.unit.ids">atc.treated.unit.ids</code></td>
<td>
<p>Integer vector specifying the &quot;treated&quot; units under the atc definition</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_confidence.level">confidence.level</code></td>
<td>
<p>double. specifies confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_lag">lag</code></td>
<td>
<p>integer vector specifying size of the lag.</p>
</td></tr>
<tr><td><code id="handle_bootstrap_placebo_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to be used for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of bootstrapped QOI estimate values.
</p>

<hr>
<h2 id='handle_conditional_se'>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</h2><span id='topic+handle_conditional_se'></span>

<h3>Description</h3>

<p>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_conditional_se(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  unit.id.variable
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_conditional_se_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_data.in">data.in</code></td>
<td>
<p>data.frame specifying the data</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_conditional_se_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector with standard error estimates
</p>

<hr>
<h2 id='handle_mahalanobis_calculations'>handle_mahalanobis_calculations
Returns a matched.set object with weights for control units, along with some other metadata</h2><span id='topic+handle_mahalanobis_calculations'></span>

<h3>Description</h3>

<p>handle_mahalanobis_calculations
Returns a matched.set object with weights for control units, along with some other metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_mahalanobis_calculations(
  mahal.nested.list,
  msets,
  max.size,
  verbose,
  use.diagonal.covmat
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_mahalanobis_calculations_+3A_mahal.nested.list">mahal.nested.list</code></td>
<td>
<p>Output from build_maha_mats function</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_msets">msets</code></td>
<td>
<p>matched.set object &ndash; list containing the treated observations and matched controls</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_max.size">max.size</code></td>
<td>
<p>maximum number of control units that will receive non-zero weights within a matched set</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_verbose">verbose</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_mahalanobis_calculations_+3A_use.diagonal.covmat">use.diagonal.covmat</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with weights for control units, along with some other metadata
</p>

<hr>
<h2 id='handle_missing_data'>handle_missing_data</h2><span id='topic+handle_missing_data'></span>

<h3>Description</h3>

<p>use col.index to determine which columns we want to &quot;scan&quot; for missing data. Note that in earlier points in the code, we rearrange the columns and prepare the data frame such that cols 1-4 are bookkeeping (unit id, time id, treated variable, unlagged outcome variable) and all remaining columns are used in the calculations after going through parse_and_prep function, so col.index should usually be 5:ncol(data). In practice, this function just looks over the data in the specified columns in the &quot;data&quot; data frame for missing data. Then it creates columns with indicator variables about the missingness of those variables: 1 for missing data, 0 for present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_missing_data(data, col.index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_missing_data_+3A_data">data</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="handle_missing_data_+3A_col.index">col.index</code></td>
<td>
<p>numeric vector specifying which columns to inspect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tags missing data
</p>


<h3>Value</h3>

<p>data.frame object with the data and the missingness indicators described above.
</p>

<hr>
<h2 id='handle_moderating_variable'>handle_moderating_variable</h2><span id='topic+handle_moderating_variable'></span>

<h3>Description</h3>

<p>handles moderating variable calculations: In practice, this just involves slicing the data up according to the moderator, calling PanelEstimate() and putting everything back together This function creates the sets of objects on which PanelEstimate() will be called. It identifies the set of valid values the moderating variable can take on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_moderating_variable(
  ordered.data,
  att.sets,
  atc.sets,
  PM.object,
  moderator,
  unit.id,
  time.id,
  qoi.in
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_moderating_variable_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_att.sets">att.sets</code></td>
<td>
<p>matched.set object for the ATT or ART</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_atc.sets">atc.sets</code></td>
<td>
<p>matched.set object for the ATC</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_pm.object">PM.object</code></td>
<td>
<p>PanelMatch object</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_moderator">moderator</code></td>
<td>
<p>string specifying the name of the moderating variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_unit.id">unit.id</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_time.id">time.id</code></td>
<td>
<p>string specifying the time id variable</p>
</td></tr>
<tr><td><code id="handle_moderating_variable_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of valid moderating variable values
</p>

<hr>
<h2 id='handle_ps_match'>handle_ps_match
Returns a matched.set object with weights for control units, along with some other metadata</h2><span id='topic+handle_ps_match'></span>

<h3>Description</h3>

<p>handle_ps_match
Returns a matched.set object with weights for control units, along with some other metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_ps_match(just.ps.sets, msets, refinement.method, verbose, max.set.size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_ps_match_+3A_just.ps.sets">just.ps.sets</code></td>
<td>
<p>Output from find_ps() function</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_msets">msets</code></td>
<td>
<p>matched.set object &ndash; list containing the treated observations and matched controls</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_verbose">verbose</code></td>
<td>
<p>Logical. See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_ps_match_+3A_max.set.size">max.set.size</code></td>
<td>
<p>maximum number of control units that will receive non-zero weights within a matched set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with weights for control units, along with some other metadata
</p>

<hr>
<h2 id='handle_ps_weighted'>handle_ps_weighted</h2><span id='topic+handle_ps_weighted'></span>

<h3>Description</h3>

<p>handle_ps_weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_ps_weighted(just.ps.sets, msets, refinement.method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_ps_weighted_+3A_just.ps.sets">just.ps.sets</code></td>
<td>
<p>results of find_ps()</p>
</td></tr>
<tr><td><code id="handle_ps_weighted_+3A_msets">msets</code></td>
<td>
<p>list of matched sets of treated and control observations</p>
</td></tr>
<tr><td><code id="handle_ps_weighted_+3A_refinement.method">refinement.method</code></td>
<td>
<p>string specifying the refinement method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with treated and matched control observations, with weights as determined by the specification
</p>

<hr>
<h2 id='handle_unconditional_se'>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.</h2><span id='topic+handle_unconditional_se'></span>

<h3>Description</h3>

<p>handle_conditional_se
Calculates conditional standard errors analytically, as defined in Imai et al. (2023). See PanelEstimate() for a more complete description of the standard error types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_unconditional_se(
  qoi.in,
  data.in,
  lead,
  outcome.variable,
  unit.id.variable
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_unconditional_se_+3A_qoi.in">qoi.in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_data.in">data.in</code></td>
<td>
<p>data.frame specifying the data</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_outcome.variable">outcome.variable</code></td>
<td>
<p>string specifying the name of the outcome variable</p>
</td></tr>
<tr><td><code id="handle_unconditional_se_+3A_unit.id.variable">unit.id.variable</code></td>
<td>
<p>string specifying the name of the unit id variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector with standard error estimates
</p>

<hr>
<h2 id='identifyDirectionalChanges'>identifyDirectionalChanges
Identifies changes in treatment variable for treated and control observations</h2><span id='topic+identifyDirectionalChanges'></span>

<h3>Description</h3>

<p>identifyDirectionalChanges
Identifies changes in treatment variable for treated and control observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyDirectionalChanges(
  msets,
  ordered.data,
  id.var,
  time.var,
  treatment.var,
  qoi
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identifyDirectionalChanges_+3A_msets">msets</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_ordered.data">ordered.data</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_id.var">id.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_time.var">time.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_treatment.var">treatment.var</code></td>
<td>
</td></tr>
<tr><td><code id="identifyDirectionalChanges_+3A_qoi">qoi</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with changes in the treatment variable for treated and control observations identified.
</p>

<hr>
<h2 id='lwd_refinement'>lwd_refinement
master function that performs refinement with listwise deletion = TRUE</h2><span id='topic+lwd_refinement'></span>

<h3>Description</h3>

<p>lwd_refinement
master function that performs refinement with listwise deletion = TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwd_refinement(
  msets,
  global.data,
  treated.ts,
  treated.ids,
  lag,
  time.id,
  unit.id,
  lead,
  refinement.method,
  treatment,
  size.match,
  match.missing,
  covs.formula,
  verbose,
  outcome.var,
  e.sets,
  use.diag.covmat
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lwd_refinement_+3A_msets">msets</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_global.data">global.data</code></td>
<td>
<p>data.frame. needs to be fully prepped/parsed data set that is internally balanced, full of NAs likely</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treated.ts">treated.ts</code></td>
<td>
<p>vector of the times of treatment for treated observations</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treated.ids">treated.ids</code></td>
<td>
<p>vector of unit identifiers of treated observations</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_lag">lag</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_time.id">time.id</code></td>
<td>
<p>string specifying</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_unit.id">unit.id</code></td>
<td>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_lead">lead</code></td>
<td>
<p>vector of lead values</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_refinement.method">refinement.method</code></td>
<td>
<p>string specifying refinement method</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_treatment">treatment</code></td>
<td>
<p>string specifying treatment variable</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_size.match">size.match</code></td>
<td>
<p>maximum number of units to give non-zero weight to when using matching refinement method</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_match.missing">match.missing</code></td>
<td>
<p>logical. indicates whether or not to allow the package to match units on missingness in treatment history</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_covs.formula">covs.formula</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_verbose">verbose</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_outcome.var">outcome.var</code></td>
<td>
<p>string specifying outcome variable</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_e.sets">e.sets</code></td>
<td>
<p>empty sets (treated observations with no matched controls)</p>
</td></tr>
<tr><td><code id="lwd_refinement_+3A_use.diag.covmat">use.diag.covmat</code></td>
<td>
<p>see PanelMatch documentation for descriptions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched.set object with refined matched sets.
</p>

<hr>
<h2 id='lwd_units'>lwd_units
helper function that actually subsets sets down to contain units with complete data</h2><span id='topic+lwd_units'></span>

<h3>Description</h3>

<p>lwd_units
helper function that actually subsets sets down to contain units with complete data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwd_units(full.local.data, unit.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lwd_units_+3A_full.local.data">full.local.data</code></td>
<td>
<p>data.frame containing the data to be used in set-level refinement, but containing missing data</p>
</td></tr>
<tr><td><code id="lwd_units_+3A_unit.id">unit.id</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the missing data removed to be used for set-level refinement.
</p>

<hr>
<h2 id='matched_set'>A constructor for the matched.set class.</h2><span id='topic+matched_set'></span>

<h3>Description</h3>

<p>Users should never need to use this function by itself. See below for more about <code>matched.set</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched_set(matchedsets, id, t, L, t.var, id.var, treatment.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matched_set_+3A_matchedsets">matchedsets</code></td>
<td>
<p>a list of treated units and matched control units. Each element in the list should be a vector of control unit ids.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id">id</code></td>
<td>
<p>A vector containing the ids of treated units</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t">t</code></td>
<td>
<p>A vector containing the times of treatment for treated units.</p>
</td></tr>
<tr><td><code id="matched_set_+3A_l">L</code></td>
<td>
<p>integer specifying the length of the lag window used in matching</p>
</td></tr>
<tr><td><code id="matched_set_+3A_t.var">t.var</code></td>
<td>
<p>string specifying the time variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_id.var">id.var</code></td>
<td>
<p>string specifying the unit id variable</p>
</td></tr>
<tr><td><code id="matched_set_+3A_treatment.var">treatment.var</code></td>
<td>
<p>string specifying the treatment variable.
</p>
<p>The constructor function returns a <code>matched.set</code> object.
<code>matched.set</code> objects are a modified list. Each element in the list is a vector of ids
corresponding to the control unit ids in a matched set.
Additionally, these vectors might have additional attributes &ndash; &quot;weights&quot;. These correspond to the
weights assigned to each control unit,
as determined by the specified refinement method.
Each element in the list also has a name, which corresponds to the unit id of the treated unit and time of treatment,
concatenated together and separated by a period. <code>matched.set</code> objects also have a number of
methods defined: <code>summary</code>, <code>plot</code>, and <code>`[`</code>. <code>matched.set</code> objects can be modified manually
as long as these conventions (and conventions about other attributes) are maintained. It is important to note that <code>matched.set</code> objects
are distinct from <code>PanelMatch</code> objects. <code>matched.set</code> objects are often contained within <code>PanelMatch</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matched.set</code> objects have additional attributes. These reflect the specified parameters when using the <code>PanelMatch</code> function:
</p>
<table role = "presentation">
<tr><td><code>lag</code></td>
<td>
<p>an integer value indicating the length of treatment history to be used for matching. Treated and control units are matched based on whether or not they have exactly matching treatment histories in the lag window.</p>
</td></tr>
<tr><td><code>t.var</code></td>
<td>
<p>time variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>id.var</code></td>
<td>
<p>unit id variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>treatment.var</code></td>
<td>
<p>treatment variable name, represented as a character/string</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class of the object: should always be &quot;matched.set&quot;</p>
</td></tr>
<tr><td><code>refinement.method</code></td>
<td>
<p>method used to refine and/or weight the control units in each set.</p>
</td></tr>
<tr><td><code>covs.formula</code></td>
<td>
<p>One sided formula indicating which variables should be used for matching and refinement</p>
</td></tr>
<tr><td><code>match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories</p>
</td></tr>
<tr><td><code>max.match.size</code></td>
<td>
<p>Maximum size of the matched sets after refinement. This argument only affects results when using a matching method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;amrauh@umich..edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>

<hr>
<h2 id='merge_formula'>merge_formula</h2><span id='topic+merge_formula'></span>

<h3>Description</h3>

<p>Simple helper function for merging formula objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_formula(form1, form2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_formula_+3A_form1">form1</code></td>
<td>
<p>formula object</p>
</td></tr>
<tr><td><code id="merge_formula_+3A_form2">form2</code></td>
<td>
<p>formula object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a formula object, which is the concatenation of two provided formula objects.
</p>

<hr>
<h2 id='PanelData'>Pre-process and balance panel data</h2><span id='topic+PanelData'></span>

<h3>Description</h3>

<p>Pre-process and balance panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelData(panel.data, unit.id, time.id, treatment, outcome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PanelData_+3A_panel.data">panel.data</code></td>
<td>
<p>A <code>data.frame</code> object containing time series cross sectional data. 
Time data should be sequential integers that increase by 1. Unit identifiers must be integers. Treatment data must be binary. If time data is non-integer, the package will attempt to sensibly convert it by converting the data to factor, then to integer. If a conversion is performed, a mapping will be returned as an attribute called &quot;time.data.map&quot;</p>
</td></tr>
<tr><td><code id="PanelData_+3A_unit.id">unit.id</code></td>
<td>
<p>A character string indicating the name of unit identifier in the data. This data must be integer.</p>
</td></tr>
<tr><td><code id="PanelData_+3A_time.id">time.id</code></td>
<td>
<p>A character string indicating the name of the time variable in the data.</p>
</td></tr>
<tr><td><code id="PanelData_+3A_treatment">treatment</code></td>
<td>
<p>A character string indicating the name of the treatment variable.
The treatment must be a binary indicator variable (integer with 0 for the control group and 1 for the treatment group).</p>
</td></tr>
<tr><td><code id="PanelData_+3A_outcome">outcome</code></td>
<td>
<p>A character string identifying the outcome variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PanelData()</code> returns an object of class <code>PanelData</code>. This takes the form of a <code>data.frame</code> object with the following properties and attributes. First, the data has been balanced and sorted. These properties are noted in the &quot;is.balanced&quot; and &quot;is.sorted&quot; attributes, respectively. So, each unit appears the same number of times in the resulting <code>PanelData</code> object, with NAs filling out missing data. Second, the data has been sorted to appear in order for each unit. Next, the <code>PanelData</code> object has the following attributes: &quot;unit.id&quot;, &quot;time.id&quot;, &quot;treatment&quot;, and &quot;outcome&quot; reflecting the variables provided in the specification. If the function attempts to automatically convert time data to be consecutive integers, the mapping between the original time data and the &quot;new&quot; converted time data is provided as a <code>data.frame</code> object and stored as the &quot;time.data.map&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- PanelData(panel.data = dem, 
               unit.id = "wbcode2", 
               time.id = "year", 
               treatment = "dem", 
               outcome = "y")
</code></pre>

<hr>
<h2 id='PanelEstimate'>Estimate a causal quantity of interest</h2><span id='topic+PanelEstimate'></span>

<h3>Description</h3>

<p>Estimate a causal quantity of interest, including the average treatment effect for
treated or control units (att and atc, respectively), the average effect of treatment reversal on reversed units (art), or average treatment effect (ate), as specified in <code>PanelMatch()</code>.
This is done by estimating the counterfactual outcomes for each treated unit using
matched sets. Users will provide matched sets that were obtained by the
<code>PanelMatch</code> function and obtain point estimates and standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelEstimate(
  sets,
  panel.data,
  number.iterations = 1000,
  df.adjustment = FALSE,
  confidence.level = 0.95,
  moderator = NULL,
  se.method = "bootstrap",
  pooled = FALSE,
  include.placebo.test = FALSE,
  parallel = FALSE,
  num.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PanelEstimate_+3A_sets">sets</code></td>
<td>
<p>A <code>PanelMatch</code> object attained via the
<code>PanelMatch()</code> function.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_panel.data">panel.data</code></td>
<td>
<p>The same time series cross sectional data set provided to the <code>PanelMatch()</code> function used to produce the matched sets. This should be a <code>PanelData</code> object.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_number.iterations">number.iterations</code></td>
<td>
<p>If using bootstrapping for calculating standard errors, this is the number of bootstrap iterations. Provide as integer. If <code>se.method</code> is not equal to &quot;bootstrap&quot;, this argument has no effect.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_df.adjustment">df.adjustment</code></td>
<td>
<p>A logical value indicating whether or not a
degree-of-freedom adjustment should be performed for the standard error
calculation. The default is <code>FALSE</code>. This parameter is only available for the bootstrap method of standard error calculation.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_confidence.level">confidence.level</code></td>
<td>
<p>A numerical value specifying the confidence level and range of interval
estimates for statistical inference. The default is .95.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_moderator">moderator</code></td>
<td>
<p>The name of a moderating variable, provided as a character string. If a moderating variable is provided,the returned object will be a list of <code>PanelEstimate</code> objects. The names of the list will reflect the different values of the moderating variable. More specifically, the moderating variable values will be converted to syntactically proper names using <code>make.names()</code>.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_se.method">se.method</code></td>
<td>
<p>Method used for calculating standard errors, provided as a character string. Users must choose between &quot;bootstrap&quot;, &quot;conditional&quot;, and &quot;unconditional&quot; methods. Default is &quot;bootstrap&quot;. &quot;bootstrap&quot; uses a block bootstrapping procedure to calculate standard errors. The conditional method calculates the variance of the estimator, assuming independence across units but not across time. The unconditional method also calculates the variance of the estimator analytically, but makes no such assumptions about independence across units. When the quantity of interest is &quot;att&quot;, &quot;atc&quot;, or &quot;art&quot;, all methods are available. Only &quot;bootstrap&quot; is available for the ate. If <code>pooled</code> argument is TRUE, then only bootstrap is available.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_pooled">pooled</code></td>
<td>
<p>Logical. If TRUE, estimates and standard errors are returned for treatment effects pooled across the entire lead window. Only available for <code>se.method = ``bootstrap''</code></p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_include.placebo.test">include.placebo.test</code></td>
<td>
<p>Logical. If TRUE, a placebo test is run and returned in the results. The placebo test uses the same specifications for calculating standard errors as the main results. That is, standard errors are calculated according to the user provided <code>se.method</code> and <code>confidence.level</code> arguments (and, if applicable, parallelization specifications).</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE and <code>se.method = ``bootstrap''</code>, bootstrap procedure will be parallelized. Default is FALSE. If <code>se.method</code> is not set to <code>bootstrap</code>, this option does nothing.</p>
</td></tr>
<tr><td><code id="PanelEstimate_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. Specifies the number of cores to use for parallelization. If <code>se.method = ``bootstrap''</code> and <code>parallel = TRUE</code>, then this option will take effect. Otherwise, it will do nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PanelEstimate</code> returns a list of class
<code>PanelEstimate</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>estimates</code></td>
<td>
<p>the point estimates of the quantity of interest for the lead periods specified</p>
</td></tr>
<tr><td><code>se.method</code></td>
<td>
<p>The method used to calculate standard errors. This is the same as the argument provided to the function.</p>
</td></tr>
<tr><td><code>bootstrapped.estimates</code></td>
<td>
<p>the bootstrapped point estimate values, when applicable</p>
</td></tr>
<tr><td><code>bootstrap.iterations</code></td>
<td>
<p>the number of iterations used in bootstrapping, when applicable</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>refinement method used to create the matched sets from which the estimates were calculated</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>See PanelMatch() argument <code>lag</code> for more information.</p>
</td></tr>
<tr><td><code>lead</code></td>
<td>
<p>The lead window sequence for which <code>PanelEstimate()</code> is producing point estimates and standard errors.</p>
</td></tr>
<tr><td><code>confidence.level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
<tr><td><code>qoi</code></td>
<td>
<p>the quantity of interest</p>
</td></tr>
<tr><td><code>matched.sets</code></td>
<td>
<p>the refined matched sets used to produce the estimations</p>
</td></tr>
<tr><td><code>standard.error</code></td>
<td>
<p>the standard error(s) of the point estimates</p>
</td></tr>
<tr><td><code>pooled</code></td>
<td>
<p>Logical indicating whether or not estimates were calculated for individual lead periods or pooled.</p>
</td></tr>
<tr><td><code>placebo.test</code></td>
<td>
<p>if <code>include.placebo.test = TRUE</code>, a placebo test is conducted using <code>placebo_test()</code> and returned as a list. See documentation for <code>placebo_test()</code> for more about each individual item.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, Adam Rauh &lt;amrauh@umich.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2023)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, 
               panel.data = dem.sub.panel, 
               se.method = "unconditional")

</code></pre>

<hr>
<h2 id='PanelMatch'>Create and refine sets of matched treated and control observations</h2><span id='topic+PanelMatch'></span>

<h3>Description</h3>

<p><code>PanelMatch</code> identifies treated observations and a matched set for each treated
observation. Specifically, for a given treated unit, the matched
set consists of control observations that have an identical
treatment history up to a number of <code>lag</code>
time periods. A further refinement of
the matched set using matching or weighting techniques, described below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PanelMatch(
  panel.data,
  lag,
  refinement.method,
  qoi,
  size.match = 10,
  match.missing = TRUE,
  covs.formula = NULL,
  lead = 0,
  verbose = FALSE,
  exact.match.variables = NULL,
  forbid.treatment.reversal = FALSE,
  matching = TRUE,
  listwise.delete = FALSE,
  use.diagonal.variance.matrix = FALSE,
  restrict.control.period = NULL,
  placebo.test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PanelMatch_+3A_panel.data">panel.data</code></td>
<td>
<p>A <code>PanelData</code> object containing time series cross sectional data. 
Time data must be sequential integers that increase by 1. Unit identifiers must be integers. Treatment data must be binary.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_lag">lag</code></td>
<td>
<p>An integer value indicating the length of treatment history periods to be matched on</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_refinement.method">refinement.method</code></td>
<td>
<p>A character string specifying the matching or weighting method to be used for refining the matched sets. The user can choose &quot;mahalanobis&quot;, &quot;ps.match&quot;, &quot;CBPS.match&quot;, &quot;ps.weight&quot;, &quot;CBPS.weight&quot;, &quot;ps.msm.weight&quot;, &quot;CBPS.msm.weight&quot;, or &quot;none&quot;. The first three methods will use the <code>size.match</code> argument to create sets of at most <code>size.match</code> closest control units. Choosing &quot;none&quot; will assign equal weights to all control units in each matched set. The MSM methods refer to marginal structural models. See Imai, Kim, and Wang (2023) for a more in-depth discussion of MSMs.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_qoi">qoi</code></td>
<td>
<p>quantity of interest, provided as a string: <code>att</code> (average treatment effect on treated units), <code>atc</code> (average treatment effect of treatment on the control units) <code>art</code> (average effect of treatment reversal for units that experience treatment reversal), or <code>ate</code> (average treatment effect).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_size.match">size.match</code></td>
<td>
<p>An integer dictating the number of permitted closest control units in a matched set after refinement. 
This argument only affects results when using a matching method (&quot;mahalanobis&quot; or any of the refinement methods that end in &quot;.match&quot;).
This argument is not needed and will have no impact if included when a weighting method is specified (any <code>refinement.method</code> that includes &quot;weight&quot; in the name).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_match.missing">match.missing</code></td>
<td>
<p>Logical variable indicating whether or not units should be matched on the patterns of missingness in their treatment histories. Default is TRUE. When FALSE, neither treated nor control units are allowed to have missing treatment data in the lag window.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_covs.formula">covs.formula</code></td>
<td>
<p>One sided formula object indicating which variables should be used for matching and refinement. 
Argument is not needed if <code>refinement.method</code> is set to &quot;none&quot;
If the user wants to include lagged variables, this can be done using a function, &quot;lag()&quot;, which takes two, unnamed, 
positional arguments. The first is the name of the variable which you wish to lag. The second is the lag window, 
specified as an integer sequence in increasing order.
For instance, I(lag(x, 1:4)) will then add new columns to the data for variable &quot;x&quot; for time t-1, t-2, t-3, and t-4 internally
and use them for defining/measuring similarity between units. 
Other transformations using the I() function, such as I(x^2) are also permitted.
The variables specified in this formula are used to define the similarity/distances between units.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_lead">lead</code></td>
<td>
<p>integer sequence specifying the lead window, for which qoi point estimates (and standard errors) will 
ultimately be produced. Default is 0 (which corresponds to contemporaneous treatment effect).</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_verbose">verbose</code></td>
<td>
<p>option to include more information about the <code>matched.set</code> object calculations, 
like the distances used to create the refined sets and weights.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_exact.match.variables">exact.match.variables</code></td>
<td>
<p>character vector giving the names of variables to be exactly matched on. These should be time invariant variables. 
Exact matching for time varying covariates is not currently supported.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_forbid.treatment.reversal">forbid.treatment.reversal</code></td>
<td>
<p>Logical. For the ATT, it indicates whether or not it is permissible for treatment to reverse in the specified lead window. This is defined analogously for the ART. It is not valid for the ATC or ATE. 
When set to TRUE, only matched sets for treated units where treatment is 
applied continuously in the lead window are included in the results. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_matching">matching</code></td>
<td>
<p>logical indicating whether or not any matching on treatment history should be performed. 
This is primarily used for diagnostic purposes, and most users will never need to set this to FALSE. Default is TRUE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_listwise.delete">listwise.delete</code></td>
<td>
<p>TRUE/FALSE indicating whether or not missing data should be handled using listwise deletion or the package's default missing data handling procedures. Default is FALSE.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_use.diagonal.variance.matrix">use.diagonal.variance.matrix</code></td>
<td>
<p>TRUE/FALSE indicating whether or not a regular covariance matrix should be used in mahalanobis distance calculations during refinement, 
or if a diagonal matrix with only covariate variances should be used instead. 
In many cases, setting this to TRUE can lead to better covariate balance, especially when there is 
high correlation between variables. Default is FALSE. This argument is only necessary when 
<code>refinement.method = mahalanobis</code> and will have no impact otherwise.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_restrict.control.period">restrict.control.period</code></td>
<td>
<p>(optional) integer specifying the number of pre-treatment periods that treated units and potentially matched control units should be non-NULL and in the control state. For instance, specifying 4 would mean that the treatment history cannot contain any missing data or treatment from t-4 to t.</p>
</td></tr>
<tr><td><code id="PanelMatch_+3A_placebo.test">placebo.test</code></td>
<td>
<p>logical TRUE/FALSE. indicates whether or not you want to be able to run a placebo test. This will add additional requirements on the data &ndash; specifically, it requires that no unit included in the matching/refinement process can having missing outcome data over the lag window. Additionally, you should not use the outcome variable in refinement when <code>placebo.test = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PanelMatch()</code> returns an object of class <code>PanelMatch</code>. This is a list that contains a few specific elements: 
First, a <code>matched.set</code> object(s) that has the same name as the provided qoi if the qoi is &quot;att&quot;, &quot;art&quot;, or &quot;atc&quot;. 
If qoi = &quot;ate&quot; then two <code>matched.set</code> objects will be attached, named &quot;att&quot; and &quot;atc.&quot; Please consult the documentation for
<code>matched_set()</code> to read more about the structure and usage of <code>matched.set</code> objects. 
The <code>PanelMatch</code> object also has some additional attributes that track metadata about the specification, like the names of the unit and time identifier variables.
</p>


<h3>Author(s)</h3>

<p>Adam Rauh &lt;amrauh@umich.edu&gt;, In Song Kim &lt;insong@mit.edu&gt;, Erik Wang
&lt;haixiao@Princeton.edu&gt;, and Kosuke Imai &lt;imai@harvard.edu&gt;
</p>


<h3>References</h3>

<p>Imai, Kosuke, In Song Kim, and Erik Wang (2023)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
# include lagged variables
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.weight", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)

</code></pre>

<hr>
<h2 id='parse_and_prep'>parse_and_prep</h2><span id='topic+parse_and_prep'></span>

<h3>Description</h3>

<p>accepts formula object and data, creates the data used for refinement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_and_prep(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_and_prep_+3A_formula">formula</code></td>
<td>
<p>formula object specifying how to construct the data used for refinement. This is likely to be some variation of the covs.formula argument.</p>
</td></tr>
<tr><td><code id="parse_and_prep_+3A_data">data</code></td>
<td>
<p>data.frame object to be used to create the data needed for refinement. data has unit, time, treatment columns in that order, followed by everything else</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with the data prepared for refinement. Data will have unit, time, treatment columns in that order, followed by everything else.
</p>

<hr>
<h2 id='pcs'>Prepare Control Units
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.</h2><span id='topic+pcs'></span>

<h3>Description</h3>

<p>Prepare Control Units
pcs and pts create data frames with the time/id combinations&ndash;that need to be found so that they can be easily looked up in the data frame via a hash table. The data frame also contains information about the weight of that unit at particular times, so we use the hash table to look up where to put this data so that we can easily assign the appropriate weights in the original data frame containing the problem data. pcs does this for all control units in a matched set. pts does this for all treated units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcs(sets, lead.in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcs_+3A_sets">sets</code></td>
<td>
<p>object describing the matched sets</p>
</td></tr>
<tr><td><code id="pcs_+3A_lead.in">lead.in</code></td>
<td>
<p>integer describing a particular lead value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with time-id combinations
</p>

<hr>
<h2 id='perform_refinement'>perform_refinement
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()</h2><span id='topic+perform_refinement'></span>

<h3>Description</h3>

<p>perform_refinement
Performs refinement of matched sets, ultimately returning sets of treated observations and controls with weights. This function mostly acts as an intermediary between PanelMatch and lower level functions that do the dirty work of refinement. The function takes a lot of the same arguments as PanelMatch()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform_refinement(
  lag,
  time.id,
  unit.id,
  treatment,
  refinement.method,
  size.match,
  ordered.data,
  match.missing,
  covs.formula,
  verbose,
  lead,
  outcome.var = NULL,
  forbid.treatment.reversal = FALSE,
  qoi = "",
  matching = TRUE,
  exact.matching.variables = NULL,
  listwise.deletion,
  use.diag.covmat = FALSE,
  placebo.test = FALSE,
  restrict.control.period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perform_refinement_+3A_lag">lag</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_time.id">time.id</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_unit.id">unit.id</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_treatment">treatment</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_refinement.method">refinement.method</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_size.match">size.match</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_ordered.data">ordered.data</code></td>
<td>
<p>data.frame that has been balanced and ordered by time-unit.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_match.missing">match.missing</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_covs.formula">covs.formula</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_verbose">verbose</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_outcome.var">outcome.var</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_forbid.treatment.reversal">forbid.treatment.reversal</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_qoi">qoi</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_matching">matching</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_exact.matching.variables">exact.matching.variables</code></td>
<td>
</td></tr>
<tr><td><code id="perform_refinement_+3A_listwise.deletion">listwise.deletion</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_use.diag.covmat">use.diag.covmat</code></td>
<td>
<p>See PanelMatch() documentation for use.diagonal.covariance.matrix argument.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_placebo.test">placebo.test</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
<tr><td><code id="perform_refinement_+3A_restrict.control.period">restrict.control.period</code></td>
<td>
<p>See PanelMatch() documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matched.set object containing the refined matched sets
</p>

<hr>
<h2 id='perunitSum'>perunitSum
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)</h2><span id='topic+perunitSum'></span>

<h3>Description</h3>

<p>perunitSum
This is a low level function that is used to calculate a value associated with each unit. This value is a weighted summation of the dependent variable, based on the Wit values discussed in Imai et al. (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perunitSum(udf, lead.in, dependent.in, qoi_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perunitSum_+3A_udf">udf</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_lead.in">lead.in</code></td>
<td>
<p>integer. A particular lead value</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_dependent.in">dependent.in</code></td>
<td>
<p>string specifying the dependent variable name</p>
</td></tr>
<tr><td><code id="perunitSum_+3A_qoi_in">qoi_in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector containing the per-unit sums.
</p>

<hr>
<h2 id='perunitSum_Dit'>perunitSum_Dit
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit</h2><span id='topic+perunitSum_Dit'></span>

<h3>Description</h3>

<p>perunitSum_Dit
Similar to perunitSum, this is a low level helper function for calculating specific values defined in Imai et al. (2023). This focuses on Dit rather than Wit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perunitSum_Dit(udf, qoi_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perunitSum_Dit_+3A_udf">udf</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="perunitSum_Dit_+3A_qoi_in">qoi_in</code></td>
<td>
<p>string specifying the QOI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector containing the per-unit sums.
</p>

<hr>
<h2 id='placebo_test'>Conduct a placebo test</h2><span id='topic+placebo_test'></span>

<h3>Description</h3>

<p>Calculate the results of a placebo test, looking at the change in outcome at time = t-1, compared to other pre-treatment periods in the lag window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placebo_test(
  pm.obj,
  panel.data,
  lag.in = NULL,
  number.iterations = 1000,
  confidence.level = 0.95,
  plot = FALSE,
  se.method = "bootstrap",
  parallel = FALSE,
  num.cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="placebo_test_+3A_pm.obj">pm.obj</code></td>
<td>
<p>an object of class <code>PanelMatch</code></p>
</td></tr>
<tr><td><code id="placebo_test_+3A_panel.data">panel.data</code></td>
<td>
<p><code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_lag.in">lag.in</code></td>
<td>
<p>integer indicating earliest the time period(s) in the future for which the placebo test change in outcome will be calculated. Calculations will be made over the period t - max(lag) to t-2, where t is the time of treatment. The results are similar to those returned by <code>PanelEstimate()</code>, except t-1 is used as the period of comparison, rather than the lead window. If not specified, the placebo test is conducted for periods from t - max(lag) to t-2.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_number.iterations">number.iterations</code></td>
<td>
<p>integer specifying the number of bootstrap iterations. This argument only has an effect if standard errors are calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_confidence.level">confidence.level</code></td>
<td>
<p>confidence level for the calculated standard error intervals. Should be specified as a numeric between 0 and 1.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether or not a plot should be generated, or just return the raw data from the calculations</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_se.method">se.method</code></td>
<td>
<p>character string describing the type of standard error to be used. Valid inputs include &quot;bootstrap&quot;, &quot;conditional&quot; and &quot;unconditional&quot;. When the QOI is ATE, only bootstrap can be used. See the documentation of this argument in <code>PanelEstimate()</code> for more.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE and <code>se.method = "bootstrap"</code>, bootstrap procedure will be parallelized. Default is FALSE. If <code>se.method</code> is not set to <code>bootstrap</code>, this option does nothing.&quot;</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer. Specifies the number of cores to use for parallelization. If <code>se.method = "bootstrap"</code> and <code>parallel = TRUE</code>, then this option will take effect. Otherwise, it will do nothing.</p>
</td></tr>
<tr><td><code id="placebo_test_+3A_...">...</code></td>
<td>
<p>extra arguments to be passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 2 or 3 elements: &quot;estimate&quot;, which contains the point estimates for the test, &quot;standard.errors&quot; which has the standard errors for each period and optionally &quot;bootstrapped.estimates&quot;, containing the bootstrapped point estimates for the test for each specified lag window period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE, placebo.test = TRUE)
placebo_test(PM.results, panel.data = dem.sub.panel, se.method = "unconditional", plot = FALSE)


</code></pre>

<hr>
<h2 id='plot_matched_set'>Helper function for plotting the distribution of matched set sizes</h2><span id='topic+plot_matched_set'></span>

<h3>Description</h3>

<p>Helper function for plotting the distribution of matched set sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matched_set(
  x,
  border = NA,
  col = "grey",
  ylab = "Frequency of Size",
  xlab = "Matched Set Size",
  lwd = NULL,
  main = "Distribution of Matched Set Sizes",
  freq = TRUE,
  include.empty.sets = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_matched_set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_border">border</code></td>
<td>
<p>default is NA. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_col">col</code></td>
<td>
<p>default is &quot;grey&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Frequency of Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Matched Set Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_lwd">lwd</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_main">main</code></td>
<td>
<p>default is &quot;Distribution of Matched Set Sizes&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_freq">freq</code></td>
<td>
<p>default is TRUE. See <code>freq</code> argument in <code>hist()</code> function for more.</p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_include.empty.sets">include.empty.sets</code></td>
<td>
<p>logical value indicating whether or not empty sets should be included in the histogram. default is FALSE. If FALSE, then empty sets will be noted as a separate vertical bar at x = 0. If TRUE, empty sets will be included as normal sets.</p>
</td></tr>
<tr><td><code id="plot_matched_set_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>hist()</code></p>
</td></tr>
</table>

<hr>
<h2 id='plot.matched.set'>Plot the distribution of control unit weights</h2><span id='topic+plot.matched.set'></span>

<h3>Description</h3>

<p>The method creates a heatmap with the following characteristics. The heatmap grid is m x n, where m is the number of treated observations (as identified by i,t pairs) and n is the number of units. Treated observations represent the rows, and every unit in the data set form the columns. The figure then shows the calculated weights or distances (as specified) for each control unit within the matched set as identified by the row. Weights/distances that are missing or zero are not considered in the shading scheme and are both treated as NA for all practical purposes. Note that not all refinement methods will return a distance. Those that do also require <code>verbose = TRUE</code> in the <code>PanelMatch</code> specification. 
For example say (2, 5) is a treated observation and units 1, 4, 8 are matched as controls. Row i will represent (2,5) in the matrix, M. The columns indexed by w, x, and y, correspond to units 1, 4, and 8. M[i, w], M[i, x],  M[i, y] then contain the weights or pairwise distances of units 1, 4, and 8 within that matched set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
plot(
  x,
  ...,
  panel.data,
  type = "weights",
  include.missing = TRUE,
  low.color = "blue",
  mid.color = "white",
  high.color = "red",
  missing.color = "grey50"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_panel.data">panel.data</code></td>
<td>
<p>a <code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_type">type</code></td>
<td>
<p>character indicating whether or not weights or distances should be plotted</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_include.missing">include.missing</code></td>
<td>
<p>logical. When TRUE, all units appear as columns, including those that are never included in any matched sets. When FALSE, only units that appear in at least one matched set are included.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_low.color">low.color</code></td>
<td>
<p>option passed to <code>ggplot2::scale_fill_gradientn()</code>. The color representing the low weight/distance values.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_mid.color">mid.color</code></td>
<td>
<p>option passed to <code>ggplot2::scale_fill_gradientn()</code>. The color representing the medium weight/distance values.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_high.color">high.color</code></td>
<td>
<p>option passed to <code>ggplot2::scale_fill_gradientn()</code>. The color representing the high weight/distance values.</p>
</td></tr>
<tr><td><code id="plot.matched.set_+3A_missing.color">missing.color</code></td>
<td>
<p>option passed to <code>ggplot2::scale_fill_gradientn()</code>. The color representing the missing/zero weight/distance values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>ggplot2::geom_tile()</code> object producing a plot in alignment with the description above
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
 PM.results &lt;- PanelMatch(panel.data = dem.panel, lag = 4,
                        refinement.method = "ps.match",
                        match.missing = TRUE,
                        covs.formula = ~ tradewb,
                        size.match = 5, qoi = "att",
                        lead = 0:4,
                        forbid.treatment.reversal = FALSE)

 mso &lt;- extract(PM.results)
 plot(mso, panel.data = dem.panel)


</code></pre>

<hr>
<h2 id='plot.PanelBalance'>Plot covariate balance results
Create figures displaying covariate balance results for one or more <code>PanelMatch</code> configurations. Users can customize these visualizations.</h2><span id='topic+plot.PanelBalance'></span>

<h3>Description</h3>

<p>Plot covariate balance results
Create figures displaying covariate balance results for one or more <code>PanelMatch</code> configurations. Users can customize these visualizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelBalance'
plot(
  x,
  ...,
  type = "panel",
  reference.line = TRUE,
  legend = TRUE,
  ylab = NULL,
  include.treatment.period = TRUE,
  include.unrefined.panel = TRUE,
  legend.position = "topleft"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PanelBalance_+3A_x">x</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code>base::plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_type">type</code></td>
<td>
<p>character specifying which type of plot to produce. Can be either &quot;panel&quot; or &quot;scatter&quot;. When &quot;panel,&quot; covariate balance results for covariates are shown over the lag period. When &quot;scatter,&quot; the figure has the following characteristics. Each point on the plot represents a specific covariate at a particular time period in the lag window from t-L to t-1. The horizontal axis represents the covariate balance for this particular variable and time period before refinement is applied, while the vertical axis represents the post-refinement balance value.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_reference.line">reference.line</code></td>
<td>
<p>logical. Include a reference line at y = 0? Only applicable to the panel plot.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_legend">legend</code></td>
<td>
<p>logical. Describes whether or not to include a legend.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_ylab">ylab</code></td>
<td>
<p>character. Y-axis label.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_include.treatment.period">include.treatment.period</code></td>
<td>
<p>Logical. Describes whether or not the treatment period should be included on the panel plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_include.unrefined.panel">include.unrefined.panel</code></td>
<td>
<p>logical indicating whether or not unrefined balance plots should be returned for panel plot. Only applicable to panel plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.PanelBalance_+3A_legend.position">legend.position</code></td>
<td>
<p>character. Describes where the legend should be placed on the figure. Uses base R syntax.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a set of base R plots, depending on the specification of &quot;panel&quot; or &quot;scatter&quot; above. When <code>type = "panel"</code> and <code>include.unrefined.panel = TRUE</code>, two sets of plots are returned. The first set shows covariate balance levels for the specified <code>PanelMatch</code> configurations. The second set shows covariate balance levels for the same <code>PanelMatch</code> configurations, but with all control units receiving equal weight (i.e., balance levels prior to refinement). If <code>include.unrefined.panel = FALSE</code>, only the first set of figures are returned. The sets of figures are both returned in the same order as the <code>PanelMatch</code> configurations specified to <code>get_covariate_balance()</code> that compose the <code>PanelBalance</code> object. When <code>type = "scatter"</code>, the visualization described above is produced, with all configurations shown on the same plot with different symbols.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- runif(runif(nrow(dem)))
dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "mahalanobis", 
                     panel.data = dem.panel, match.missing = TRUE,
                     covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                     size.match = 5, qoi = "att")

# create multiple configurations to compare
pm2 &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "ps.match", 
                  panel.data = dem.panel, match.missing = TRUE,
                  covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                  size.match = 5, qoi = "att")

pb &lt;- get_covariate_balance(pm.obj, pm2,
                            include.unrefined = TRUE,
                            panel.data = dem.panel, 
                            covariates = c("tradewb", "rdata"))
plot(pb, type = "panel", include.unrefined.panel = TRUE)
plot(pb, type = "scatter")
# only show refined balance figures
plot(pb, type = "panel", include.unrefined.panel = FALSE)
</code></pre>

<hr>
<h2 id='plot.PanelData'>Create basic plots of PanelData objects</h2><span id='topic+plot.PanelData'></span>

<h3>Description</h3>

<p>Create basic plots of PanelData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelData'
plot(x, ..., plotting.variable = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PanelData_+3A_x">x</code></td>
<td>
<p><code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelData_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot.PanelData_+3A_plotting.variable">plotting.variable</code></td>
<td>
<p>character string specifying which variable to plot in the resulting figure. The values of this variable will be used to fill in cells on the resulting heatmap. Defaults to whatever is specified as the treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object created by <code>geom_tile()</code>. The basic figure shows units along the y-axis and time along the x-axis. The figure takes the form of a heatmap. The value of the plotting.variable argument is used to fill in the color of the cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- rnorm(nrow(dem))
d &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
plot(d)
plot(d, plotting.variable = "rdata")
</code></pre>

<hr>
<h2 id='plot.PanelEstimate'>Plot point estimates and standard errors from a PanelEstimate calculation.</h2><span id='topic+plot.PanelEstimate'></span>

<h3>Description</h3>

<p>The <code>plot.PanelEstimate</code> method takes an object returned by the <code>PanelEstimate</code> function and plots the calculated 
point estimates and standard errors over the specified <code>lead</code> time period. 
The only mandatory argument is an object of the <code>PanelEstimate</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
plot(
  x,
  ylab = "Estimated Effect of Treatment",
  xlab = "Time",
  main = "Estimated Effects of Treatment Over Time",
  ylim = NULL,
  pch = NULL,
  cex = NULL,
  confidence.level = NULL,
  bias.corrected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PanelEstimate_+3A_x">x</code></td>
<td>
<p>a <code>PanelEstimate</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Estimated Effect of Treatment.&quot; This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Time&quot;. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_main">main</code></td>
<td>
<p>default is &quot;Estimated Effects of Treatment Over Time&quot;. This is the same argument as the standard argument for <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_ylim">ylim</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_pch">pch</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_cex">cex</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>plot()</code></p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_confidence.level">confidence.level</code></td>
<td>
<p>confidence.level Confidence level to be used for confidence interval calculations. Must be numeric between 0 and 1. If NULL, confidence level from <code>PanelEstimate()</code> specification is used.</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_bias.corrected">bias.corrected</code></td>
<td>
<p>logical indicating whether or not bias corrected estimates should be plotted Default is FALSE. This argument only applies for standard errors calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="plot.PanelEstimate_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, 
              panel.data = dem.sub.panel, 
              se.method = "unconditional")
plot(PE.results)

</code></pre>

<hr>
<h2 id='plot.PanelMatch'>Plot the distribution of the sizes of matched sets.</h2><span id='topic+plot.PanelMatch'></span>

<h3>Description</h3>

<p>A plot method for creating a histogram of the distribution of the sizes of matched sets.
This method accepts all standard optional <code>hist</code> arguments via the <code>...</code> argument.
By default, empty matched sets (treated units that could not be
matched with any control units) are noted as a vertical bar at x = 0 and not included in the
regular histogram. See the <code>include.empty.sets</code> argument for more information about this. If the quantity of interest is ATE, a plot will be returned for the matched sets associated with the att and the atc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelMatch'
plot(
  x,
  ...,
  border = NA,
  col = "grey",
  ylab = "Frequency of Size",
  xlab = "Matched Set Size",
  lwd = NULL,
  main = "Distribution of Matched Set Sizes",
  freq = TRUE,
  include.empty.sets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PanelMatch_+3A_x">x</code></td>
<td>
<p>a <code>PanelMatch</code> object</p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_border">border</code></td>
<td>
<p>default is NA. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_col">col</code></td>
<td>
<p>default is &quot;grey&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_ylab">ylab</code></td>
<td>
<p>default is &quot;Frequency of Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_xlab">xlab</code></td>
<td>
<p>default is &quot;Matched Set Size&quot;. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_lwd">lwd</code></td>
<td>
<p>default is NULL. This is the same argument as the standard argument for <code>hist()</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_main">main</code></td>
<td>
<p>default is &quot;Distribution of Matched Set Sizes&quot;. This is the same argument as the standard argument for <code>hist</code></p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_freq">freq</code></td>
<td>
<p>default is TRUE. See <code>freq</code> argument in <code>hist()</code> function for more.</p>
</td></tr>
<tr><td><code id="plot.PanelMatch_+3A_include.empty.sets">include.empty.sets</code></td>
<td>
<p>logical value indicating whether or not empty sets should be included in the histogram. default is FALSE. If FALSE, then empty sets will be noted as a separate vertical bar at x = 0. If TRUE, empty sets will be included as normal sets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel,
                         lag = 4, 
                         refinement.method = "mahalanobis",
                         match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, forbid.treatment.reversal = FALSE)
plot(PM.results)
plot(PM.results, include.empty.sets = TRUE)

</code></pre>

<hr>
<h2 id='prepare_data'>prepare_data
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>prepare_data
The calculation of point estimates and standard errors first requires the calculation of a variety of different weights, parameters, and indicator variables. This function prepares the data within PanelEstimate() such that the estimates can be calculated easily. In practical terms, the function calls the lower level helpers to calculate W_its and D_its as described in Imai et al. (2023) and merges those results together with the original data to facilitate calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  data.in,
  lead,
  sets.att = NULL,
  sets.atc = NULL,
  qoi.in,
  dependent.variable
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_data_+3A_data.in">data.in</code></td>
<td>
<p>data.frame: the data to be used in the analysis</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_lead">lead</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_sets.att">sets.att</code></td>
<td>
<p>matched.set object containing ATT or ART matched sets.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_sets.atc">sets.atc</code></td>
<td>
<p>matched.set object containing ATC matched sets.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_qoi.in">qoi.in</code></td>
<td>
<p>See PanelMatch() documentation</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_dependent.variable">dependent.variable</code></td>
<td>
<p>string specifying the outcome/dependent variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the results of the lower level calculations
</p>

<hr>
<h2 id='print.matched.set'>Print matched.set objects.</h2><span id='topic+print.matched.set'></span>

<h3>Description</h3>

<p>Print matched.set objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
print(x, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.matched.set_+3A_x">x</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_...">...</code></td>
<td>
<p>Not used. additional arguments to be passed to <code>print</code></p>
</td></tr>
<tr><td><code id="print.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in expanded/raw list form.
The verbose form is not recommended unless the data set is small. Default is FALSE, which prints an overview of matched set sizes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
# create subset of data for simplicity
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4,
                        refinement.method = "ps.match",
                        match.missing = TRUE,
                        covs.formula = ~ tradewb,
                        size.match = 5, qoi = "att",
                        lead = 0:4,
                        forbid.treatment.reversal = FALSE)
print(extract(PM.results, qoi = "att"))



</code></pre>

<hr>
<h2 id='print.PanelBalance'>Print basic information about PanelBalance objects</h2><span id='topic+print.PanelBalance'></span>

<h3>Description</h3>

<p>Print basic information about PanelBalance objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelBalance'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PanelBalance_+3A_x">x</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
<tr><td><code id="print.PanelBalance_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- runif(runif(nrow(dem)))
dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "mahalanobis", 
                     panel.data = dem.panel, match.missing = TRUE,
                     covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                     size.match = 5, qoi = "att")
pb &lt;- get_covariate_balance(pm.obj,
                            include.unrefined = TRUE,
                            panel.data = dem.panel, 
                            covariates = c("tradewb", "rdata"))
print(pb)
</code></pre>

<hr>
<h2 id='print.PanelData'>Print PanelData objects and basic metadata</h2><span id='topic+print.PanelData'></span>

<h3>Description</h3>

<p>Print PanelData objects and basic metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PanelData_+3A_x">x</code></td>
<td>
<p><code>PanelData</code> object</p>
</td></tr>
<tr><td><code id="print.PanelData_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print.data.frame()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
print(d)

</code></pre>

<hr>
<h2 id='print.PanelEstimate'>Print point estimates and standard errors</h2><span id='topic+print.PanelEstimate'></span>

<h3>Description</h3>

<p>Print point estimates and standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PanelEstimate_+3A_x">x</code></td>
<td>
<p><code>PanelEstimate</code> object</p>
</td></tr>
<tr><td><code id="print.PanelEstimate_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print.data.frame()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, 
              panel.data = dem.sub.panel, 
              se.method = "unconditional")
print(PE.results)
</code></pre>

<hr>
<h2 id='print.PanelMatch'>Print PanelMatch objects.</h2><span id='topic+print.PanelMatch'></span>

<h3>Description</h3>

<p>Print PanelMatch objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelMatch'
print(x, ..., verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PanelMatch_+3A_x">x</code></td>
<td>
<p>a <code>PanelMatch</code> object</p>
</td></tr>
<tr><td><code id="print.PanelMatch_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>print</code></p>
</td></tr>
<tr><td><code id="print.PanelMatch_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not underlying data should be printed in expanded/raw list form.
The verbose form is not recommended unless the data set is small. Default is FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem, 'wbcode2', 'year', 'dem', 'y')
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel,
                         lag = 4, 
                         refinement.method = "mahalanobis",
                         match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, forbid.treatment.reversal = FALSE)
print(PM.results)


</code></pre>

<hr>
<h2 id='set_lwd_refinement'>set_lwd_refinement
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.</h2><span id='topic+set_lwd_refinement'></span>

<h3>Description</h3>

<p>set_lwd_refinement
Performs the set-level operations for refinement with listwise deletion. See documentation for lwd_refinement for descriptions of most parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_lwd_refinement(
  mset,
  local.data,
  time,
  id,
  lag,
  refinement.method,
  lead,
  verbose,
  size.match,
  unit.id,
  time.id,
  covs.formula,
  match.missing,
  treatment,
  use.diag.covmat
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_lwd_refinement_+3A_mset">mset</code></td>
<td>
<p>individual matched set</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_local.data">local.data</code></td>
<td>
<p>data.frame containing the data relevant for set level refinement</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_time">time</code></td>
<td>
<p>time of treated observation</p>
</td></tr>
<tr><td><code id="set_lwd_refinement_+3A_id">id</code></td>
<td>
<p>id of treated observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an individual matched set
</p>

<hr>
<h2 id='summary.matched.set'>Summarize information about a matched.set object and the matched sets contained within them.</h2><span id='topic+summary.matched.set'></span>

<h3>Description</h3>

<p>A method for viewing summary data about the sizes of matched sets and metadata about how they were created. This method accepts all standard <code>summary</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
summary(object, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.matched.set_+3A_object">object</code></td>
<td>
<p>a <code>matched.set</code> object</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to be passed to the <code>summary</code> function</p>
</td></tr>
<tr><td><code id="summary.matched.set_+3A_verbose">verbose</code></td>
<td>
<p>Logical value specifying whether or not a longer, more verbose summary should be calculated and returned. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object with either 5 or 1 element(s), depending on whether or not <code>verbose</code> is set to TRUE or not.
</p>
<table role = "presentation">
<tr><td><code>overview</code></td>
<td>
<p>A <code>data.frame</code> object containing information about the treated units (unit id, time of treatment), and the number of matched control units with weights zero and above.</p>
</td></tr>
<tr><td><code>set.size.summary</code></td>
<td>
<p>a <code>summary</code> object summarizing the minimum, maximum, and IQR of matched set sizes</p>
</td></tr>
<tr><td><code>number.of.treated.units</code></td>
<td>
<p>The number of unit, time pairs that are considered to be &quot;treated&quot; units</p>
</td></tr>
<tr><td><code>num.units.empty.set</code></td>
<td>
<p>The number of units treated at a particular time that were not able to be matched to any control units</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>The size of the lag window used for matching on treatment history. This affects which treated and control units are matched.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(lag = 4, refinement.method = "ps.match",
                         panel.data = dem.sub.panel, match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, forbid.treatment.reversal = FALSE)
summary(extract(PM.results, qoi = "att"))



</code></pre>

<hr>
<h2 id='summary.PanelBalance'>Summarize covariate balance over time</h2><span id='topic+summary.PanelBalance'></span>

<h3>Description</h3>

<p>Summarize covariate balance over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelBalance'
summary(
  object,
  qoi = NULL,
  include.unrefined = TRUE,
  unrefined.only = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PanelBalance_+3A_object">object</code></td>
<td>
<p><code>PanelBalance</code> object</p>
</td></tr>
<tr><td><code id="summary.PanelBalance_+3A_qoi">qoi</code></td>
<td>
<p>Character. Valid values include &quot;att&quot;, &quot;art&quot;, or &quot;atc&quot;. Specifying which QOI information to extract and summarize.</p>
</td></tr>
<tr><td><code id="summary.PanelBalance_+3A_include.unrefined">include.unrefined</code></td>
<td>
<p>logical. Indicates whether or not unrefined balance results should be included in the summary.</p>
</td></tr>
<tr><td><code id="summary.PanelBalance_+3A_unrefined.only">unrefined.only</code></td>
<td>
<p>logical. Indicates whether or not only unrefined balance results should be included in the summary.</p>
</td></tr>
<tr><td><code id="summary.PanelBalance_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of matrices with covariate balance results calculated. Each element in the list corresponds to a <code>PanelMatch</code> configuration given to <code>get_covariate_balance()</code> and are returned in order. Note that if a configuration has <code>qoi = "ate"</code>, the corresponding element in the returned list will also be a list, containing balance results corresponding to the ATT and ATC. Otherwise, each element in the returned list will be a matrix. Each matrix entry corresponds to balance results for a particular covariate in a particular period. When unrefined balance results are included, users will see additional columns with &quot;_unrefined&quot; appended to covariate names. These correspond to the unrefined balance results for a particular covariate-period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem$rdata &lt;- runif(runif(nrow(dem)))
dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
pm.obj &lt;- PanelMatch(lead = 0:3, lag = 4, refinement.method = "mahalanobis", 
                     panel.data = dem.panel, match.missing = TRUE,
                     covs.formula = ~ tradewb + rdata + I(lag(tradewb, 1:4)) + I(lag(y, 1:4)), 
                     size.match = 5, qoi = "att")
pb &lt;- get_covariate_balance(pm.obj,
                            include.unrefined = TRUE,
                            panel.data = dem.panel, 
                            covariates = c("tradewb", "rdata"))
summary(pb)
</code></pre>

<hr>
<h2 id='summary.PanelData'>Summarize the number of unique units and time periods in a PanelData object</h2><span id='topic+summary.PanelData'></span>

<h3>Description</h3>

<p>Summarize the number of unique units and time periods in a PanelData object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PanelData_+3A_object">object</code></td>
<td>
<p>PanelData object</p>
</td></tr>
<tr><td><code id="summary.PanelData_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> object, with columns &quot;num.units&quot; and &quot;num.periods.&quot; These specify the number of unique units and time periods that appear in the balanced panel data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
summary(d)

</code></pre>

<hr>
<h2 id='summary.PanelEstimate'>Get summaries of PanelEstimate objects and calculations</h2><span id='topic+summary.PanelEstimate'></span>

<h3>Description</h3>

<p><code>summary.PanelEstimate</code> takes an object returned by
<code>PanelEstimate</code>, and returns a summary table of point
estimates and confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelEstimate'
summary(
  object,
  confidence.level = NULL,
  verbose = FALSE,
  bias.corrected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PanelEstimate_+3A_object">object</code></td>
<td>
<p>A <code>PanelEstimate</code> object</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_confidence.level">confidence.level</code></td>
<td>
<p>Confidence level to be used for confidence interval calculations. Must be numeric between 0 and 1. If NULL, confidence level from <code>PanelEstimate()</code> specification is used.</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether or not output should be printed in an expanded form. Default is FALSE</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_bias.corrected">bias.corrected</code></td>
<td>
<p>logical indicating whether or not bias corrected estimates should be provided. Default is FALSE. This argument only applies for standard errors calculated with the bootstrap.</p>
</td></tr>
<tr><td><code id="summary.PanelEstimate_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently, no additional arguments are supported.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
# create subset of data for simplicity
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel, lag = 4, 
                         refinement.method = "ps.match", 
                         match.missing = TRUE, 
                         covs.formula = ~ tradewb,
                         size.match = 5, qoi = "att",
                         lead = 0:4, 
                         forbid.treatment.reversal = FALSE)
PE.results &lt;- PanelEstimate(sets = PM.results, 
                            panel.data = dem.sub.panel, 
                            se.method = "unconditional")
summary(PE.results)
summary(PE.results, confidence.level = .9)

</code></pre>

<hr>
<h2 id='summary.PanelMatch'>Summarize information about a PanelMatch object and the matched sets contained within them.</h2><span id='topic+summary.PanelMatch'></span>

<h3>Description</h3>

<p>A method for viewing summary data about the sizes of matched sets and metadata about how they were created. This method
accepts all standard <code>summary</code> arguments. If the quantity of interest is ate, then a summary will be provided for the matched sets associated with the att and the atc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PanelMatch'
summary(object, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PanelMatch_+3A_object">object</code></td>
<td>
<p>a <code>PanelMatch</code> object</p>
</td></tr>
<tr><td><code id="summary.PanelMatch_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to be passed to the <code>summary</code> function</p>
</td></tr>
<tr><td><code id="summary.PanelMatch_+3A_verbose">verbose</code></td>
<td>
<p>Logical value specifying whether or not a longer, more verbose summary should be calculated and returned. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists containing a summary of the matched sets associated with the specified qoi. Each sublist object will either have 5 or 1 element(s), depending on whether or not <code>verbose</code> is set to <code>TRUE</code> or not.
</p>
<table role = "presentation">
<tr><td><code>overview</code></td>
<td>
<p>A <code>data.frame</code> object containing information about the treated units (unit id, time of treatment), and the number of matched control units with weights zero and above.</p>
</td></tr>
<tr><td><code>set.size.summary</code></td>
<td>
<p>a <code>summary</code> object summarizing the minimum, maximum, and IQR of matched set sizes</p>
</td></tr>
<tr><td><code>number.of.treated.units</code></td>
<td>
<p>The number of unit, time pairs that are considered to be &quot;treated&quot; units</p>
</td></tr>
<tr><td><code>num.units.empty.set</code></td>
<td>
<p>The number of units treated at a particular time that were not able to be matched to any control units</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>The size of the lag window used for matching on treatment history. This affects which treated and control units are matched.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dem.sub &lt;- dem[dem[, "wbcode2"] &lt;= 100, ]
dem.sub.panel &lt;- PanelData(dem.sub, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.sub.panel,
                         lag = 4, 
                         refinement.method = "mahalanobis",
                         match.missing = TRUE,
                         covs.formula = ~ I(lag(tradewb, 1:4)) + I(lag(y, 1:4)),
                         size.match = 5, qoi = "att",
                         lead = 0:4, forbid.treatment.reversal = FALSE)
summary(PM.results)

</code></pre>

<hr>
<h2 id='weights'>Get weights of matched control units
See weights.matched.set method</h2><span id='topic+weights'></span>

<h3>Description</h3>

<p>Get weights of matched control units
See weights.matched.set method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_+3A_object">object</code></td>
<td>
<p><code>Matched.set object</code></p>
</td></tr>
</table>

<hr>
<h2 id='weights.matched.set'>Extract the weights of matched control units</h2><span id='topic+weights.matched.set'></span>

<h3>Description</h3>

<p>Extract the weights of matched control units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matched.set'
weights(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights.matched.set_+3A_object">object</code></td>
<td>
<p>matched.set object, extracted using the <code>get.PanelMatch()</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of named vectors. Each list element corresponds to a particular treated observation and contains the matched control units, along with their weights. These correspond to the &quot;weights&quot; attribute, which are calculated in the <code>PanelMatch</code> refinement process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem.panel &lt;- PanelData(dem, "wbcode2", "year", "dem", "y")
PM.results &lt;- PanelMatch(panel.data = dem.panel, lag = 4,
                        refinement.method = "ps.match",
                        match.missing = TRUE,
                        covs.formula = ~ tradewb,
                        size.match = 5, qoi = "att",
                        lead = 0:4,
                        forbid.treatment.reversal = FALSE)
r1 &lt;- extract(PM.results, qoi = "att")
lt &lt;- weights(r1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
