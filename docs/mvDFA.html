<!DOCTYPE html><html lang="en"><head><title>Help for package mvDFA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvDFA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DFA'><p>Analyze univariate time series and estimate long memory using Detrended Fluctuations Analysis (DFA; Peng et al., 1995)</p></a></li>
<li><a href='#mvDFA'><p>Analyze multivariate correlated time series and estimate long memory by the extension of the using univariate Detrended Fluctuations Analysis (DFA; Peng et al., 1995) to multivariate time series: mvDFA</p></a></li>
<li><a href='#print.DFA'><p>print object of class DFA</p></a></li>
<li><a href='#print.mvDFA'><p>print object of class mvDFA</p></a></li>
<li><a href='#simulate_cMTS'><p>Approximate correlated time series with given Hurst Exponent</p></a></li>
<li><a href='#simulate_Lorenz_noise'><p>Simulate the Lorenz System with noise</p></a></li>
<li><a href='#simulate_MTS_mixed_white_pink_brown'><p>Approximate correlated time series from white, pink and brown noise from independent realization of normal variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Detrended Fluctuation Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>This R package provides an implementation of multivariate extensions of a well-known fractal analysis technique, Detrended Fluctuations Analysis (DFA; Peng et al., 1995&lt;<a href="https://doi.org/10.1063%2F1.166141">doi:10.1063/1.166141</a>&gt;), for multivariate time series: multivariate DFA (mvDFA). Several coefficients are implemented that take into account the correlation structure of the multivariate time series to varying degrees. These coefficients may be used to analyze long memory and changes in the dynamic structure that would by univariate DFA. Therefore, this R package aims to extend and complement the original univariate DFA (Peng et al., 1995) for estimating the scaling properties of nonstationary time series.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Patrick Irmer
    <a href="https://orcid.org/0000-0002-7544-6483"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Sebastian Wallot [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Patrick Irmer &lt;jirmer@psych.uni-frankfurt.de&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jpirmer/mvDFA">https://github.com/jpirmer/mvDFA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jpirmer/mvDFA/issues">https://github.com/jpirmer/mvDFA/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>longmemo, stats, pbapply, deSolve, RobPer, mvtnorm, pracma</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-15 08:12:26 UTC; JulienMac</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-15 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DFA'>Analyze univariate time series and estimate long memory using Detrended Fluctuations Analysis (DFA; Peng et al., 1995)</h2><span id='topic+DFA'></span>

<h3>Description</h3>

<p>Analyze univariate time series and estimate long memory using Detrended Fluctuations Analysis (DFA; Peng et al., 1995)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFA(X, steps = 50, brownian = FALSE, degree = 1, verbose = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DFA_+3A_x">X</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="DFA_+3A_steps">steps</code></td>
<td>
<p>Maximum number of window sizes. These are spread logarithmically. If time series is short and steps is large, fewer window sizes are drawn. Default to <code>50</code>.</p>
</td></tr>
<tr><td><code id="DFA_+3A_brownian">brownian</code></td>
<td>
<p>Indicator whether time series is assumed to be brownian (i.e. variance increases proportional to time)</p>
</td></tr>
<tr><td><code id="DFA_+3A_degree">degree</code></td>
<td>
<p>The maximum order of the detrending polynomial in the segments. This influences the smallest window size <code>minS</code> such that <code>minS</code> = <code>degree + 2</code>.</p>
</td></tr>
<tr><td><code id="DFA_+3A_verbose">verbose</code></td>
<td>
<p>Indicator whether additional info should be printed. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DFA_+3A_cores">cores</code></td>
<td>
<p>Number of cores used in computation. Default to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of Root Mean Squares per window size <code>RMS_s</code>, the window sizes <code>S</code> and the estimated long memory coefficient <code>L</code> - the Hurst Exponent.
</p>


<h3>References</h3>

<p>Peng, C. K., Havlin, S., Stanley, H. E., &amp; Goldberger, A. L. (1995). Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time-series. Chaos, 5, 82–87. &lt;doi:10.1063/1.166141&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(500) # generate Gaussian white noise (i.i.d. standard normal variables)
DFA(X = X, steps = 5) # steps = 5 is only for demonstration,
                        # use many steps instead, e.g. steps = 50!
</code></pre>

<hr>
<h2 id='mvDFA'>Analyze multivariate correlated time series and estimate long memory by the extension of the using univariate Detrended Fluctuations Analysis (DFA; Peng et al., 1995) to multivariate time series: mvDFA</h2><span id='topic+mvDFA'></span>

<h3>Description</h3>

<p>Analyze multivariate correlated time series and estimate long memory by the extension of the using univariate Detrended Fluctuations Analysis (DFA; Peng et al., 1995) to multivariate time series: mvDFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvDFA(
  X,
  steps = 50,
  degree = 1,
  verbose = FALSE,
  cores = 1,
  covlist = FALSE,
  brownian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvDFA_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame containing the time series in long format.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_steps">steps</code></td>
<td>
<p>Maximum number of window sizes. These are spread logarithmically. If time series is short and steps is large, fewer window sizes are drawn. Default to <code>50</code>. The dimensions (<code>ncol(X)</code>) and the <code>degree</code> influence the smallest possible window size.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_degree">degree</code></td>
<td>
<p>The maximum order of the detrending polynomial in the segments. This influences the smallest window size <code>minS</code> such that <code>minS</code> = <code>d + degree + 2</code>, where <code>d</code> is the dimension of the time series.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_verbose">verbose</code></td>
<td>
<p>Indicator whether additional info should be printed. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_cores">cores</code></td>
<td>
<p>Number of cores used in computation. Default to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_covlist">covlist</code></td>
<td>
<p>Indicator whether covariance of the time series per window size should be saved in a list.</p>
</td></tr>
<tr><td><code id="mvDFA_+3A_brownian">brownian</code></td>
<td>
<p>Indicator whether time series are assumed to be brownian (i.e. variance increases proportional to time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mvDFA</code> containing long memory coefficients (Hurst exponents) and corresponding further informations:
</p>
<table role = "presentation">
<tr><td><code>Ltot</code></td>
<td>
<p> the estimated long memory coefficient for the multivariate time series using the total variance approach</p>
</td></tr>
<tr><td><code>Lgen</code></td>
<td>
<p>the generalized approach</p>
</td></tr>
<tr><td><code>Lfull</code></td>
<td>
<p>the average covariance approach</p>
</td></tr>
<tr><td><code>LmeanUni</code></td>
<td>
<p>average Hurst exponent across all time series</p>
</td></tr>
<tr><td><code>univariate_DFA</code></td>
<td>
<p>univariate Hurst exponents</p>
</td></tr>
<tr><td><code>R2tot</code></td>
<td>
<p>R-squared of total variance approach in regression of log10(RMS) vs log10(S)</p>
</td></tr>
<tr><td><code>R2gen</code></td>
<td>
<p>R-squared of generalized variance approach in regression of log10(RMS) vs log10(S)</p>
</td></tr>
<tr><td><code>R2full</code></td>
<td>
<p>R-squared of  covariance approach in regression of log10(RMS) vs log10(S)</p>
</td></tr>
<tr><td><code>R2meanUni</code></td>
<td>
<p>average R-squared across all time series in regression of log10(RMS) vs log10(S)</p>
</td></tr>
<tr><td><code>R2univariate_DFA</code></td>
<td>
<p>R-squares of single time series approach in regression of log10(RMS) vs log10(S)</p>
</td></tr>
<tr><td><code>RMS_tot</code></td>
<td>
<p>a list of Root Mean Squares per window size corresponding to the total variance approach</p>
</td></tr>
<tr><td><code>RMS_gen</code></td>
<td>
<p>a list of Root Mean Squares per window size corresponding to the total generalized approach</p>
</td></tr>
<tr><td><code>Cov_RMS_s</code></td>
<td>
<p>a list of Root Mean Squares per window size corresponding to the covariance approach</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>window sizes used</p>
</td></tr>
<tr><td><code>CovRMS_list</code></td>
<td>
<p>a list of covariance matrices per <code>S</code> may be returned</p>
</td></tr>
</table>


<h3>References</h3>

<p>Peng, C. K., Havlin, S., Stanley, H. E., &amp; Goldberger, A. L. (1995). Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time-series. Chaos, 5, 82–87. &lt;doi:10.1063/1.166141&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(.5, 3, 3); diag(Sigma) &lt;- 1
# generate correlated Gaussian white noise (i.i.d. multivariate normal variables)
X &lt;- mvtnorm::rmvnorm(n = 500, sigma = Sigma)
mvDFA(X = X, steps = 5) # steps = 5 is only for demonstration,
                        # use many steps instead, e.g. steps = 50!
</code></pre>

<hr>
<h2 id='print.DFA'>print object of class DFA</h2><span id='topic+print.DFA'></span>

<h3>Description</h3>

<p>print object of class DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DFA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DFA_+3A_x">x</code></td>
<td>
<p>object of class DFA to print.</p>
</td></tr>
<tr><td><code id="print.DFA_+3A_...">...</code></td>
<td>
<p>further parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Truncates the output printed into the console of objects of class <code>DFA</code>, but does not change object itself.
</p>

<hr>
<h2 id='print.mvDFA'>print object of class mvDFA</h2><span id='topic+print.mvDFA'></span>

<h3>Description</h3>

<p>print object of class mvDFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvDFA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mvDFA_+3A_x">x</code></td>
<td>
<p>object of class DFA to print.</p>
</td></tr>
<tr><td><code id="print.mvDFA_+3A_...">...</code></td>
<td>
<p>further parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Truncates the output printed into the console of objects of class <code>mvDFA</code>, but does not change object itself.
</p>

<hr>
<h2 id='simulate_cMTS'>Approximate correlated time series with given Hurst Exponent</h2><span id='topic+simulate_cMTS'></span>

<h3>Description</h3>

<p>Approximation of correlated time series with given &quot;Hurst&quot; exponents. Internally <code>longmemo::simFGN0</code> or <code>longmemo::simFGN.fft</code> are used which simulate Gaussian series by generating fractional ARIMA(0,h,0) models (with $h=H-1/2$, <code>longmemo::FGN0</code>), or fractional Gaussian noise <code>longmemo::FGN.fft</code>. We cautiously note that we use empirical scaling (i.e., the variances are scaled to be 1 in the sample not the population), hence the between sample variance may be underrepresented. We further note that the covariance estimates for correlated time series (not using increments) is unstable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cMTS(
  N,
  H,
  Sigma,
  simulation_process = "FGN0",
  decomposition = "chol",
  cor_increments = TRUE,
  X0 = rep(0, ncol(Sigma))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_cMTS_+3A_n">N</code></td>
<td>
<p>Length of Times Series</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_h">H</code></td>
<td>
<p>Hurst Exponents for <code>d</code> time series. These are then mixed using one of two different decompositions of the given covariance matrix <code>Sigma</code>.</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_sigma">Sigma</code></td>
<td>
<p>Positive semi definite covariance matrix of desired multi-dimensional time series.</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_simulation_process">simulation_process</code></td>
<td>
<p>The simulation process passed to the <code>longmemo::sim...</code> function. Can either be <code>longmemo::simFGN.fft</code> (using FFT) or <code>longmemo::simFGN0</code> (using fractional gaussian processes). FGN0 looks more like <code>rnorm</code>, when <code>H=0.5</code>. <code>DEFAULT</code> to <code>"FGN0"</code>. Use <code>simulation_process="FGN.fft"</code> to use the FFT based version.</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_decomposition">decomposition</code></td>
<td>
<p>Character whether the Cholesky decomposition <code>"chol"</code> (or <code>"cholesky"</code>) should be used or whether the eigen decomposition should be used (<code>decomposition = "eigen"</code>). <code>DEFAULT</code> to <code>"chol"</code>.</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_cor_increments">cor_increments</code></td>
<td>
<p>Logical, whether to correlate the increments or the time series themselves. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_cMTS_+3A_x0">X0</code></td>
<td>
<p>Starting values for the time series if increments are correlated. Default to <code>rep(0, ncol(Sigma))</code>, i.e., the zero vector of required length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multivariate correlated time series with covariance matrix <code>Sigma</code>. The Hurst exponents are only approximating the univariate ones, since they result from mixed time series. Uncorrelated time series keep their univariate Hurst exponents <code>H</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(.5, 3, 3); diag(Sigma) &lt;- c(1,2,3)
data &lt;- simulate_cMTS(N = 10^5, Sigma = Sigma, H = c(.2, .5, .7),
                      cor_increments = TRUE)
cov(data)
cov(apply(data,2,diff))
</code></pre>

<hr>
<h2 id='simulate_Lorenz_noise'>Simulate the Lorenz System with noise</h2><span id='topic+simulate_Lorenz_noise'></span>

<h3>Description</h3>

<p>Simulate the Lorenz System with noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_Lorenz_noise(
  N = 1000,
  delta_t = NULL,
  tmax = 50,
  X0 = 0,
  Y0 = 1,
  Z0 = 1,
  sdX = NULL,
  sdY = NULL,
  sdZ = NULL,
  sdnoiseX,
  sdnoiseY,
  sdnoiseZ,
  s = 10,
  r = 28,
  b = 8/3,
  naive = FALSE,
  return_time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_Lorenz_noise_+3A_n">N</code></td>
<td>
<p>Length of Times Series</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_delta_t">delta_t</code></td>
<td>
<p>Step size for time scale. If <code>NULL</code> this is derived using <code>N</code> and <code>tmax</code>. <code>DEFAULT</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_tmax">tmax</code></td>
<td>
<p>Upper bound of the time scale. This argument is ignored if <code>delta_t</code> is provided. <code>DEFAULT</code> to <code>50</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_x0">X0</code></td>
<td>
<p>Initial value for X at t=0. <code>DEFAULT</code> to 0.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_y0">Y0</code></td>
<td>
<p>Initial value for Y at t=0. <code>DEFAULT</code> to 1.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_z0">Z0</code></td>
<td>
<p>Initial value for Z at t=0. <code>DEFAULT</code> to 1.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdx">sdX</code></td>
<td>
<p>Use this argument to rescale the X-coordinate to have the desired standard deviation (exactly). This is ignored if set to <code>NULL</code>. <code>DEFAULT</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdy">sdY</code></td>
<td>
<p>Use this argument to rescale the Y-coordinate to have the desired standard deviation (exactly). This is ignored if set to <code>NULL</code>. <code>DEFAULT</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdz">sdZ</code></td>
<td>
<p>Use this argument to rescale the Z-coordinate to have the desired standard deviation (exactly). This is ignored if set to <code>NULL</code>. <code>DEFAULT</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdnoisex">sdnoiseX</code></td>
<td>
<p>Standard deviation of Gaussian noise of X-coordinate. If set to <code>0</code>, no noise is created.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdnoisey">sdnoiseY</code></td>
<td>
<p>Standard deviation of Gaussian noise of Y-coordinate. If set to <code>0</code>, no noise is created.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_sdnoisez">sdnoiseZ</code></td>
<td>
<p>Standard deviation of Gaussian noise of Z-coordinate. If set to <code>0</code>, no noise is created.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_s">s</code></td>
<td>
<p>s-parameter of the Lorenz ODE. See Vignette for further details. <code>DEFAULT</code> to <code>10</code>, which is the original value chosen by Lorenz.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_r">r</code></td>
<td>
<p>r-parameter of the Lorenz ODE. See Vignette for further details. <code>DEFAULT</code> to <code>28</code>, which is the original value chosen by Lorenz.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_b">b</code></td>
<td>
<p>b-parameter of the Lorenz ODE. See Vignette for further details. <code>DEFAULT</code> to <code>8/3</code>, which is the original value chosen by Lorenz.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_naive">naive</code></td>
<td>
<p>Logical whether naive calculation should be used. <code>DEFAULT</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate_Lorenz_noise_+3A_return_time">return_time</code></td>
<td>
<p>Logical whether the time-coordinate should be included in the returned <code>data.frame</code>. <code>DEFAULT</code> to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a three dimensional time series as <code>data.frame</code> following the Lorenz system (Lorenz, 1963, &lt;doi:10.1175/1520-0469(1963)020&lt;0130:DNF&gt;2.0.CO;2&gt;).
</p>


<h3>References</h3>

<p>Lorenz, E. N. (1963). Deterministic nonperiodic flow. Journal of atmospheric sciences, 20(2), 130-141. &lt;doi:10.1175/1520-0469(1963)020&lt;0130:DNF&gt;2.0.CO;2&gt;
</p>

<hr>
<h2 id='simulate_MTS_mixed_white_pink_brown'>Approximate correlated time series from white, pink and brown noise from independent realization of normal variables</h2><span id='topic+simulate_MTS_mixed_white_pink_brown'></span>

<h3>Description</h3>

<p>Approximation of correlated time series representing &quot;white&quot;, &quot;pink&quot; or &quot;brown&quot; noise from independent realization of normal variates Internally normal variables are simulated using <code>rnorm</code> and then are cumulated for white or brown noise and we use <code>RobPer::TK95</code> for the generation of pink noise. We cautiously note that we use empirical scaling (i.e., the variances are scaled to be 1 in the sample not the population), hence the between sample variance may be underrepresented. We further note that the covariance estimates for correlated time series (not using increments) is unstable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_MTS_mixed_white_pink_brown(
  N,
  Sigma,
  process = "white",
  decomposition = "chol",
  cor_increments = TRUE,
  X0 = rep(0, ncol(Sigma))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_n">N</code></td>
<td>
<p>Length of multivariate Times Series</p>
</td></tr>
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_sigma">Sigma</code></td>
<td>
<p>Positive semi definite covariance matrix the increments of desired multi dimensional time series. The dimensionality of Sigma sets the dimension of the time series. The variance scale the time. If the variances are all 1, then each data point represents one unit of time.</p>
</td></tr>
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_process">process</code></td>
<td>
<p>Type of process. Can either be &quot;white&quot;, &quot;brown&quot; or &quot;pink&quot;. Default to &quot;white&quot;. If process is a vector, a mixture of the three process is generated, correlated by Sigma.</p>
</td></tr>
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_decomposition">decomposition</code></td>
<td>
<p>Character whether the Cholesky decomposition <code>"chol"</code> (or <code>"cholesky"</code>) should be used or whether the eigen decomposition should be used (<code>decomposition = "eigen"</code>). <code>DEFAULT</code> to <code>"chol"</code>.</p>
</td></tr>
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_cor_increments">cor_increments</code></td>
<td>
<p>Logical, whether to correlate the increments or the time series themselves. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_MTS_mixed_white_pink_brown_+3A_x0">X0</code></td>
<td>
<p>Starting values for the time series if increments are correlated. Default to <code>rep(0, ncol(Sigma))</code>, i.e., the zero vector of required length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multivariate correlated time series with covariance matrix 'Sigma'. The Hurst exponents are only approximating the univariate ones, since they result from mixed time series. Here, a mixture of &quot;white&quot;, &quot;pink&quot; and &quot;brown&quot; noise can be chosen from. Uncorrelated time series keep their univariate Hurst exponent 'H'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(.5, 3, 3); diag(Sigma) &lt;- c(1,2,3)
data &lt;- simulate_MTS_mixed_white_pink_brown(N = 10^5, Sigma = Sigma,
                                            process = c("white", "pink", "brown"),
                                            cor_increments = FALSE)
cov(data) # unstable covariances
cov(apply(data,2,diff))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
