<!DOCTYPE html><html><head><title>Help for package mixKernel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixKernel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#center.scale'><p>Center and scale</p></a></li>
<li><a href='#cim.kernel'><p>Compute and display similarities between multiple kernels</p></a></li>
<li><a href='#combine.kernels'><p>Combine multiple kernels into a meta-kernel</p></a></li>
<li><a href='#compute.kernel'><p>Compute a kernel</p></a></li>
<li><a href='#kernel.pca'><p>Kernel Principal Components Analysis</p></a></li>
<li><a href='#kernel.pca.permute'><p>Assess variable importance</p></a></li>
<li><a href='#mixKernel.users.guide'><p>View mixKernel User's Guide</p></a></li>
<li><a href='#plotVar.kernel.pca'><p>Plot importance of variables in kernel PCA</p></a></li>
<li><a href='#select.features'><p>Select important features</p></a></li>
<li><a href='#TARAoceans'><p>TARA ocean microbiome data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Omics Data Integration Using Kernel Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-27</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), mixOmics, ggplot2, reticulate (&ge; 1.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan, phyloseq, corrplot, psych, quadprog, LDRTools, Matrix,
methods, markdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Kernel-based methods are powerful methods for integrating 
    heterogeneous types of data. mixKernel aims at providing methods to combine
    kernel for unsupervised exploratory analysis. Different solutions are 
    provided to compute a meta-kernel, in a consensus way or in a way that 
    best preserves the original topology of the data. mixKernel also integrates
    kernel PCA to visualize similarities between samples in a non linear space
    and from the multiple source point of view 
    &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx682">doi:10.1093/bioinformatics/btx682</a>&gt;. A method to select (as well as 
    funtions to display) important variables is also provided 
    &lt;<a href="https://doi.org/10.1093%2Fnargab%2Flqac014">doi:10.1093/nargab/lqac014</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://forgemia.inra.fr/genotoul-bioinfo/mixKernel/-/issues">https://forgemia.inra.fr/genotoul-bioinfo/mixKernel/-/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mixkernel.clementine.wf">http://mixkernel.clementine.wf</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "autograd",
pip = TRUE), list(package = "numpy", pip = TRUE), list(package
= "scipy", pip = TRUE), list(package = "sklearn", pip = TRUE) )
)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 13:58:14 UTC; nathalie</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathalie Vialaneix [aut, cre],
  Celine Brouard [aut],
  Remi Flamary [aut],
  Julien Henry [aut],
  Jerome Mariette [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='center.scale'>Center and scale</h2><span id='topic+center.scale'></span>

<h3>Description</h3>

<p>Center and scale a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.scale(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.scale_+3A_x">X</code></td>
<td>
<p>a numeric matrix (or data frame) to center and scaled.
<code>NA</code>s not allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>center.scale</code> returns a centered and scaled matrix.
</p>


<h3>Author(s)</h3>

<p>Celine Brouard &lt;celine.brouard@inrae.fr&gt;
Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>, <code><a href="#topic+combine.kernels">combine.kernels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nutrimouse")
## Not run: 
 nutrimouse.sc &lt;- center.scale(nutrimouse$gene)

## End(Not run)

</code></pre>

<hr>
<h2 id='cim.kernel'>Compute and display similarities between multiple kernels</h2><span id='topic+cim.kernel'></span>

<h3>Description</h3>

<p>Compute cosine from Frobenius norm between kernels and display the 
corresponding correlation plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cim.kernel(
  ...,
  scale = TRUE,
  method = c("circle", "square", "number", "shade", "color", "pie")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cim.kernel_+3A_...">...</code></td>
<td>
<p>list of kernels (called 'blocks') computed on different datasets 
and measured on the same samples.</p>
</td></tr>
<tr><td><code id="cim.kernel_+3A_scale">scale</code></td>
<td>
<p>boleean. If <code>scale = TRUE</code>, each block is standardized to 
zero mean and unit variance and cosine normalization is performed on the 
kernel. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cim.kernel_+3A_method">method</code></td>
<td>
<p>character. The visualization method to be used. Currently, 
seven methods are supported (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The displayed similarities are the kernel generalization of the 
RV-coefficient described in Lavit <em>et al.</em>, 1994.
</p>
<p>The plot is displayed using the <code><a href="corrplot.html#topic+corrplot">corrplot</a></code> package. 
Seven visualization methods are implemented: <code>"circle"</code> (default), 
<code>"square"</code>, <code>"number"</code>, <code>"pie"</code>, <code>"shade"</code> and 
<code>"color"</code>. Circle and square areas are proportional to the absolute 
value of corresponding similarities coefficients.
</p>


<h3>Value</h3>

<p><code>cim.kernel</code> returns a matrix containing the cosine from 
Frobenius norm between kernels.
</p>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Lavit C., Escoufier Y., Sabatier R. and Traissac P. (1994). The 
ACT (STATIS method). <em>Computational Statistics and Data Analysis</em>, 
<b>18</b>(1), 97-119.
</p>
<p>Mariette J. and Villa-Vialaneix N. (2018). Unsupervised multiple kernel 
learning for heterogeneous data integration. <em>Bioinformatics</em>, 
<b>34</b>(6), 1009-1015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)

# compute one kernel per dataset
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
pro.phylo.kernel &lt;- compute.kernel(TARAoceans$pro.phylo, 
                                   kernel.func = "abundance")
pro.NOGs.kernel &lt;- compute.kernel(TARAoceans$pro.NOGs, 
                                  kernel.func = "abundance")

# display similarities between kernels
cim.kernel(phychem = phychem.kernel,
           pro.phylo = pro.phylo.kernel,
           pro.NOGs = pro.NOGs.kernel, 
           method = "square")

</code></pre>

<hr>
<h2 id='combine.kernels'>Combine multiple kernels into a meta-kernel</h2><span id='topic+combine.kernels'></span>

<h3>Description</h3>

<p>Compute multiple kernels into a single meta-kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.kernels(
  ...,
  scale = TRUE,
  method = c("full-UMKL", "STATIS-UMKL", "sparse-UMKL"),
  knn = 5,
  rho = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.kernels_+3A_...">...</code></td>
<td>
<p>list of kernels (called 'blocks') computed on different datasets 
and measured on the same samples.</p>
</td></tr>
<tr><td><code id="combine.kernels_+3A_scale">scale</code></td>
<td>
<p>boleean. If <code>scale = TRUE</code>, each block is standardized to 
zero mean and unit variance and cosine normalization is performed on the 
kernel. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="combine.kernels_+3A_method">method</code></td>
<td>
<p>character. Which method should be used to compute the 
meta-kernel. Default: <code>"full-UMKL"</code>.</p>
</td></tr>
<tr><td><code id="combine.kernels_+3A_knn">knn</code></td>
<td>
<p>integer. If <code>method = "sparse-UMKL"</code> or
<code>method = "full-UMKL"</code>, number of neighbors used to get a proxy of the 
local topology of the datasets from each kernel. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="combine.kernels_+3A_rho">rho</code></td>
<td>
<p>integer. Parameters for the augmented Lagrangian method. Default: 
<code>20</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>method</code> allows to specify the Unsupervised Multiple
Kernel Learning (UMKL) method to use: </p>

<ul>
<li> <p><code>"STATIS-UMKL"</code>: combines input kernels into the best 
consensus of all kernels;
</p>
</li>
<li> <p><code>"full-UMKL"</code>: computes a kernel that minimizes the distortion 
between the meta-kernel and the k-NN graphs obtained from all input 
kernels;
</p>
</li>
<li> <p><code>"sparse-UMKL"</code>: a sparse variant of the <code>"full-UMKL"</code> 
approach.
</p>
</li></ul>



<h3>Value</h3>

<p><code>combine.kernels</code> returns an object of classes <code>"kernel"</code> 
and <code>"metaKernel"</code>, a list that contains the following components: 
</p>
<table>
<tr><td><code>kernel</code></td>
<td>
<p>: the computed meta-kernel matrix;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>: the dataset from which the kernel has been computed, as given by
the function <code><a href="#topic+compute.kernel">compute.kernel</a></code>. Can be <code>NULL</code> if a kernel
matrix was passed to this function;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>: a vector containing the weights used to combine the 
kernels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Mariette J. and Villa-Vialaneix N. (2018). Unsupervised multiple 
kernel learning for heterogeneous data integration . <em>Bioinformatics</em>, 
<b>34</b>(6), 1009-1015. DOI: <a href="https://doi.org/10.1093/bioinformatics/btx682">doi:10.1093/bioinformatics/btx682</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>, <code><a href="#topic+kernel.pca">kernel.pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)

# compute one kernel per dataset
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
pro.phylo.kernel &lt;- compute.kernel(TARAoceans$pro.phylo, kernel.func = "abundance")
pro.NOGs.kernel &lt;- compute.kernel(TARAoceans$pro.NOGs, kernel.func = "abundance")

# compute the meta kernel
meta.kernel &lt;- combine.kernels(phychem = phychem.kernel,
                               pro.phylo = pro.phylo.kernel,
                               pro.NOGs = pro.NOGs.kernel, 
                               method = "full-UMKL")

</code></pre>

<hr>
<h2 id='compute.kernel'>Compute a kernel</h2><span id='topic+compute.kernel'></span>

<h3>Description</h3>

<p>Compute a kernel from a given data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.kernel(X, kernel.func = "linear", ..., test.pos.semidef = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.kernel_+3A_x">X</code></td>
<td>
<p>a numeric matrix (or data frame) used to compute the kernel. 
<code>NA</code>s not allowed.</p>
</td></tr>
<tr><td><code id="compute.kernel_+3A_kernel.func">kernel.func</code></td>
<td>
<p>the kernel function to use. This parameter can be set to 
any user defined kernel function. Widely used kernel functions are 
pre-implemented, that can be used by setting <code>kernel.func</code> to one of the
following strings: <code>"kidentity"</code>, <code>"abundance"</code>, <code>"linear"</code>, 
<code>"gaussian.radial.basis"</code>, <code>"poisson"</code> or <code>"phylogenetic"</code>. 
Default: <code>"linear"</code>.</p>
</td></tr>
<tr><td><code id="compute.kernel_+3A_...">...</code></td>
<td>
<p>the kernel function arguments. Valid parameters for 
pre-implemented kernels are: </p>

<ul>
<li> <p><code>phylogenetic.tree</code> (<code>"phylogenetic"</code>): an instance of 
phylo-class that contains a phylogenetic tree (required).
</p>
</li>
<li> <p><code>scale</code> (<code>"linear"</code> or <code>"gaussian.radial.basis"</code>): 
logical. Should the variables be scaled to unit variance prior the 
kernel computation? Default: <code>TRUE</code>.
</p>
</li>
<li> <p><code>sigma</code> (<code>"gaussian.radial.basis"</code>): double. The inverse 
kernel width used by <code>"gaussian.radial.basis"</code>.
</p>
</li>
<li> <p><code>method</code> (<code>"phylogenetic"</code> or <code>"abundance"</code>): 
character. Can be <code>"unifrac"</code> or <code>"wunifrac"</code> for 
<code>"phylogenetic"</code>. Which dissimilarity to use for <code>"abundance"</code>:
one of <code>"bray"</code>, <code>"euclidean"</code>, <code>"canberra"</code>, 
<code>"manhattan"</code>, <code>"kulczynski"</code>, <code>"jaccard"</code>, 
<code>"gower"</code>, <code>"altGower"</code>, <code>"morisita"</code>, <code>"horn"</code>, 
<code>"mountford"</code>, <code>"raup"</code>, <code>"binomial"</code>, <code>"chao"</code> and 
<code>"cao"</code>.
</p>
</li>
<li> <p><code>normalization</code> (<code>"poisson"</code>): character. Can be 
<code>"deseq"</code> (more robust), <code>"mle"</code> (less robust) or 
<code>"quantile"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute.kernel_+3A_test.pos.semidef">test.pos.semidef</code></td>
<td>
<p>boleean. If <code>test.pos.semidef = TRUE</code>, the 
positive semidefiniteness of the resulting matrix is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute.kernel</code> returns an object of classes <code>"kernel"</code>, a
list that contains the following components:
</p>
<table>
<tr><td><code>kernel</code></td>
<td>
<p>: the computed kernel matrix.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>: the original dataset. If <code>"kidentity"</code>, <code>X</code> is set to 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code>kernel.func</code></td>
<td>
<p>: the kernel function used.</p>
</td></tr>
<tr><td><code>kernel.args</code></td>
<td>
<p>: the arguments used to compute the kernel.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Lozupone C. and Knight R. (2005). UniFrac: a new phylogenetic 
method for comparing microbial communities. <em>Applied and Environmental 
Microbiology</em>, <b>71</b>(12), 8228-8235.
</p>
<p>Lozupone C., Hamady M., Kelley S.T. and Knight R. (2007). Quantitative and 
qualitative beta diversity measures lead to different insights into factors 
that structure microbial communities. <em>Applied and Environmental 
Microbiology</em>, <b>73</b>(5), 1576-1585.
</p>
<p>Witten D. (2011). Classification and clustering of sequencing data using a 
Poisson model. <em>Annals of Applied Statistics</em>, <b>5</b>(4), 2493-2518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combine.kernels">combine.kernels</a></code>, <code><a href="#topic+kernel.pca">kernel.pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)
pro.NOGs.kernel &lt;- compute.kernel(TARAoceans$pro.NOGs, 
                                  kernel.func = "abundance")

</code></pre>

<hr>
<h2 id='kernel.pca'>Kernel Principal Components Analysis</h2><span id='topic+kernel.pca'></span>

<h3>Description</h3>

<p>Performs a kernel PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.pca(K, ncomp = nrow(K$kernel))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.pca_+3A_k">K</code></td>
<td>
<p>a kernel object obtained using either <code>compute.kernel</code> or
<code>combine.kernels</code>.</p>
</td></tr>
<tr><td><code id="kernel.pca_+3A_ncomp">ncomp</code></td>
<td>
<p>integer. Indicates the number of components to return..</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kernel.pca</code> returns an object of classes <code>"kernel.pca"</code> 
and <code>"pca"</code>, which is a list containing the following entries: 
</p>
<table>
<tr><td><code>ncomp</code></td>
<td>
<p>: the number of principal components;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>: the input kernel matrix;</p>
</td></tr> 
<tr><td><code>kernel</code></td>
<td>
<p>: the input kernel object provided by the user;</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>
<p>: the singular values (square root of the eigenvalues);</p>
</td></tr> 
<tr><td><code>rotation</code></td>
<td>
<p>: the matrix of variable loadings (<em>i.e.</em>, a matrix 
whose columns contain the eigenvectors);</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>: same as 'rotation' to keep the mixOmics spirit;</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>: same as 'rotation' to keep the mixOmics spirit;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Scholkopf B., Smola A. and Muller K.R. (1998) Nonlinear component 
analysis as a kernel eigenvalue problem. <em>Neural Computation</em>, 
<b>10</b>, 1299-1319.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>, <code><a href="#topic+combine.kernels">combine.kernels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
kernel.pca.result &lt;- kernel.pca(phychem.kernel, ncomp = 3)

</code></pre>

<hr>
<h2 id='kernel.pca.permute'>Assess variable importance</h2><span id='topic+kernel.pca.permute'></span>

<h3>Description</h3>

<p>Assess importance of variables on a given PC component by computing the 
Crone-Crosby distance between original sample positions and sample positions 
obtained by a random permutation of the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel.pca.permute(kpca.result, ncomp = 1, ..., directory = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.pca.permute_+3A_kpca.result">kpca.result</code></td>
<td>
<p>a kernel.pca object returned by the
<code><a href="#topic+kernel.pca">kernel.pca</a></code> function.</p>
</td></tr>
<tr><td><code id="kernel.pca.permute_+3A_ncomp">ncomp</code></td>
<td>
<p>integer. Number of KPCA components used to compute the 
importance. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="kernel.pca.permute_+3A_...">...</code></td>
<td>
<p>list of character vectors. The parameter name must be the kernel 
name to be considered for permutation of variables. Provided vectors length 
has to be equal to the number of variables of the input dataset. A kernel is 
performed on each unique variables values. Crone-Crosby distances are 
computed on each KPCA performed on resulted kernels or meta-kernels and can 
be displayed using the <code><a href="#topic+plotVar.kernel.pca">plotVar.kernel.pca</a></code>.</p>
</td></tr>
<tr><td><code id="kernel.pca.permute_+3A_directory">directory</code></td>
<td>
<p>character. To limit computational burden, this argument 
allows to store / read temporary computed kernels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotVar.kernel.pca</code> produces a barplot for each block. The variables 
for which the importance has been computed with 
<code><a href="#topic+kernel.pca.permute">kernel.pca.permute</a></code> are displayed. The representation is limited 
to the <code>ndisplay</code> most important variables.
</p>


<h3>Value</h3>

<p><code>kernel.pca.permute</code> returns a copy of the input 
<code>kpca.result</code> results and add values in the three entries: 
<code>cc.distances</code>, <code>cc.variables</code> and <code>cc.blocks</code>.
</p>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Mariette J. and Villa-Vialaneix N. (2018). Unsupervised multiple 
kernel learning for heterogeneous data integration. <em>Bioinformatics</em>, 
<b>34</b>(6), 1009-1015. DOI: <a href="https://doi.org/10.1093/bioinformatics/btx682">doi:10.1093/bioinformatics/btx682</a>
</p>
<p>Crone L. and Crosby D. (1995). Statistical applications of a metric on 
subspaces to satellite meteorology. <em>Technometrics</em>, <b>37</b>(3), 
324-328.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>, <code><a href="#topic+kernel.pca">kernel.pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)

# compute one kernel for the psychem dataset
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
# perform a KPCA
kernel.pca.result &lt;- kernel.pca(phychem.kernel)

# compute importance for all variables in this kernel
kernel.pca.result &lt;- kernel.pca.permute(kernel.pca.result, 
                                        phychem = colnames(TARAoceans$phychem))

</code></pre>

<hr>
<h2 id='mixKernel.users.guide'>View mixKernel User's Guide</h2><span id='topic+mixKernel.users.guide'></span>

<h3>Description</h3>

<p>Find the location of the mixKernel User's Guide and optionnaly opens it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixKernel.users.guide(html = TRUE, view = html)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixKernel.users.guide_+3A_html">html</code></td>
<td>
<p>logical. Should the document returned by the function be the
compiled PDF or the Rmd source. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mixKernel.users.guide_+3A_view">view</code></td>
<td>
<p>logical. Should the document be opened using the default HTML
viewer? Default to <code>html</code>. It has no effect if <code>html = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the operating system is not Windows, then the HTML viewer used is that
given by <code>Sys.getenv("R_BROWSER")</code>. The HTML viewer can be changed using
<code>Sys.setenv(R_BROWSER = )</code>.
</p>


<h3>Value</h3>

<p>Character string giving the file location. If <code>html = TRUE</code> and
<code>view = TRUE</code>, the HTML document reader is started and the User's Guide
is opened in it.
</p>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixKernel.users.guide(view = FALSE)
mixKernel.users.guide(html = FALSE)
## Not run: mixKernel.users.guide()

</code></pre>

<hr>
<h2 id='plotVar.kernel.pca'>Plot importance of variables in kernel PCA</h2><span id='topic+plotVar.kernel.pca'></span>

<h3>Description</h3>

<p>Provides a representation of variable importance in kernel PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVar.kernel.pca(
  object,
  blocks = unique(object$cc.blocks),
  ndisplay = 5,
  ncol = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVar.kernel.pca_+3A_object">object</code></td>
<td>
<p>: a kernel.pca object returned by <code><a href="#topic+kernel.pca">kernel.pca</a></code>.</p>
</td></tr>
<tr><td><code id="plotVar.kernel.pca_+3A_blocks">blocks</code></td>
<td>
<p>a numerical vector indicating the block variables to display.</p>
</td></tr>
<tr><td><code id="plotVar.kernel.pca_+3A_ndisplay">ndisplay</code></td>
<td>
<p>integer. The number of important variables per blocks shown in 
the representation. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="plotVar.kernel.pca_+3A_ncol">ncol</code></td>
<td>
<p>integer. Each block of variables is displayed in a separate 
subfigure. <code>ncol</code> sets the number of columns for the global figure. 
Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="plotVar.kernel.pca_+3A_...">...</code></td>
<td>
<p>external arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotVar.kernel.pca</code> produces a barplot for each block. The variables for which the 
importance has been computed with <code><a href="#topic+kernel.pca.permute">kernel.pca.permute</a></code> are 
displayed. The representation is limited to the <code>ndisplay</code> most important 
variables.
</p>


<h3>Author(s)</h3>

<p>Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Crone L. and Crosby D. (1995). Statistical applications of a metric on subspaces
to satellite meteorology. <em>Technometrics</em>, <b>37</b>(3), 324-328.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel.pca">kernel.pca</a></code>, <code><a href="#topic+kernel.pca.permute">kernel.pca.permute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TARAoceans)

# compute one kernel for the psychem dataset
phychem.kernel &lt;- compute.kernel(TARAoceans$phychem, kernel.func = "linear")
# perform a KPCA
kernel.pca.result &lt;- kernel.pca(phychem.kernel)
# compute importance for all variables in this kernel
kernel.pca.result &lt;- kernel.pca.permute(kernel.pca.result, phychem = colnames(TARAoceans$phychem))

## Not run: plotVar.kernel.pca(kernel.pca.result, ndisplay = 10)

</code></pre>

<hr>
<h2 id='select.features'>Select important features</h2><span id='topic+select.features'></span>

<h3>Description</h3>

<p>Select features using supervised or unsupervised kernel method. A 
supervised feature selection method is performed if <code>Y</code> is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'features'
select(
  X,
  Y = NULL,
  kx.func = c("linear", "gaussian.radial.basis", "bray"),
  ky.func = c("linear", "gaussian.radial.basis"),
  keepX = NULL,
  method = c("kernel", "kpca", "graph"),
  lambda = NULL,
  n_components = 2,
  Lg = NULL,
  mu = 1,
  max_iter = 100,
  nstep = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.features_+3A_x">X</code></td>
<td>
<p>a numeric matrix (or data frame) used to select variables. 
<code>NA</code>s not allowed.</p>
</td></tr>
<tr><td><code id="select.features_+3A_y">Y</code></td>
<td>
<p>a numeric matrix (or data frame) used to select variables. 
<code>NA</code>s not allowed.</p>
</td></tr>
<tr><td><code id="select.features_+3A_kx.func">kx.func</code></td>
<td>
<p>the kernel function name to use on <code>X</code>. Widely used 
kernel functions are pre-implemented, and can be directly used by setting 
<code>kx.func</code> to one of the following values: <code>"linear"</code>, 
<code>"gaussian.radial.basis"</code> or <code>"bray"</code>. Default: <code>"linear"</code>. If 
<code>Y</code> is provided, the kernel <code>"bray"</code> is not allowed.</p>
</td></tr>
<tr><td><code id="select.features_+3A_ky.func">ky.func</code></td>
<td>
<p>the kernel function name to use on <code>Y</code>. Available 
kernels are: <code>"linear"</code>, and <code>"gaussian.radial.basis"</code>. Default: 
<code>"linear"</code>. This value is ignored when <code>Y</code> is not provided.</p>
</td></tr>
<tr><td><code id="select.features_+3A_keepx">keepX</code></td>
<td>
<p>the number of variables to select.</p>
</td></tr>
<tr><td><code id="select.features_+3A_method">method</code></td>
<td>
<p>the method to use. Either an unsupervised variable selection
method (<code>"kernel"</code>), a kernel PCA oriented variable selection method 
(<code>"kpca"</code>) or a structure driven variable selection selection 
(<code>"graph"</code>). Default: <code>"kernel"</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_lambda">lambda</code></td>
<td>
<p>the penalization parameter that controls the trade-off between 
the minimization of the distorsion and the sparsity of the solution 
parameter.</p>
</td></tr>
<tr><td><code id="select.features_+3A_n_components">n_components</code></td>
<td>
<p>how many principal components should be used with method
<code>"kpca"</code>. Required with method <code>"kpca"</code>. Default: <code>2</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_lg">Lg</code></td>
<td>
<p>the Laplacian matrix of the graph representing relations between 
the input dataset variables. Required with method <code>"graph"</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_mu">mu</code></td>
<td>
<p>the penalization parameter that controls the trade-off between the
the distorsion and the influence of the graph. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_nstep">nstep</code></td>
<td>
<p>the number of values used for the regularization path. Default: 
<code>50</code>.</p>
</td></tr>
<tr><td><code id="select.features_+3A_...">...</code></td>
<td>
<p>the kernel function arguments. In particular, 
<code>sigma</code>(<code>"gaussian.radial.basis"</code>): double. The inverse kernel 
width used by <code>"gaussian.radial.basis"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ukfs</code> returns a vector of sorted selected features indexes.
</p>


<h3>Author(s)</h3>

<p>Celine Brouard &lt;celine.brouard@inrae.fr&gt;
Jerome Mariette &lt;jerome.mariette@inrae.fr&gt;
Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;
</p>


<h3>References</h3>

<p>Brouard C., Mariette J., Flamary R. and Vialaneix N. (2022). 
Feature selection for kernel methods in systems biology. <em>NAR Genomics
and Bioinformatics</em>, <b>4</b>(1), lqac014. DOI: <a href="https://doi.org/10.1093/nargab/lqac014">doi:10.1093/nargab/lqac014</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.kernel">compute.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These examples require the installation of python modules
## See installation instruction at: http://mixkernel.clementine.wf

data("Koren.16S")
## Not run: 
 sf.res &lt;- select.features(Koren.16S$data.raw, kx.func = "bray", lambda = 1,
                           keepX = 40, nstep = 1)
 colnames(Koren.16S$data.raw)[sf.res]

## End(Not run)

data("nutrimouse")
## Not run: 
 grb.func &lt;- "gaussian.radial.basis"
 genes &lt;- center.scale(nutrimouse$gene)
 lipids &lt;- center.scale(nutrimouse$lipid)
 sf.res &lt;- select.features(genes, lipids, kx.func = grb.func, 
                           ky.func = grb.func, keepX = 40)
 colnames(nutrimouse$gene)[sf.res]

## End(Not run)

</code></pre>

<hr>
<h2 id='TARAoceans'>TARA ocean microbiome data</h2><span id='topic+TARAoceans'></span>

<h3>Description</h3>

<p>The TARA Oceans expedition facilitated the study of plankton communities by 
providing oceans metagenomic data combined with environmental measures to the 
scientific community. This dataset focuses on 139 prokaryotic-enriched 
samples collected from 68 stations and spread across three depth layers: the 
surface (SRF), the deep chlorophyll maximum (DCM) layer and the mesopelagic 
(MES) zones. Samples were located in height different oceans or seas: Indian 
Ocean (IO), Mediterranean Sea (MS), North Atlantic Ocean (NAO), North Pacific
Ocean (NPO), Red Sea (RS), South Atlantic Ocean (SAO), South Pacific Ocean 
(SPO) and South Ocean (SO). Here, only a subset of the original data is 
provided (1% of the 35,650 prokaryotic operational taxonomic units (OTUs) 
and of the 39,246 bacterial genes (NOGs) (selected at random).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TARAoceans)
</code></pre>


<h3>Format</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>phychem</code></dt><dd><p>data matrix with 139 rows and 22 columns. Each row 
represents a sample and each column an environmental variable.</p>
</dd>
<dt><code>pro.phylo</code></dt><dd><p>data matrix with 139 rows (samples) and 356 columns
(prokaryotic OTUs).</p>
</dd>
<dt><code>taxonomy</code></dt><dd><p>data matrix with 356 rows (prokaryotic OTUs) and 6 
columns indicating the taxonomy of each OTU.</p>
</dd>
<dt><code>phylogenetic.tree</code></dt><dd><p>a phylo object (see package 'ape') 
representing the prokaryotic OTUs phylogenetic tree.</p>
</dd>
<dt><code>pro.NOGs</code></dt><dd><p>data matrix with 139 rows (samples) and 638 columns 
(NOGs).</p>
</dd>
<dt><code>sample</code></dt><dd><p>a list containing three following entries (all three 
are character vectors): <code>name</code> (sample name), <code>ocean</code> (oceanic 
region of the sample) and <code>depth</code> (sample depth).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The raw data were downloaded from 
<a href="http://ocean-microbiome.embl.de/companion.html">http://ocean-microbiome.embl.de/companion.html</a>.
</p>


<h3>References</h3>

<p>Sunagawa S., Coelho L.P., Chaffron S., Kultima J.R., Labadie K., 
Salazar F., Djahanschiri B., Zeller G., Mende D.R., Alberti A., 
Cornejo-Castillo F., Costea P.I., Cruaud C., d'Oviedo F., Engelen S., 
Ferrera I., Gasol J., Guidi L., Hildebrand F., Kokoszka F., Lepoivre C., 
Lima-Mendez G., Poulain J., Poulos B., Royo-Llonch M., Sarmento H., 
Vieira-Silva S., Dimier C., Picheral M., Searson S., Kandels-Lewis S., 
<em>Tara</em> Oceans coordinators, Bowler C., de Vargas C., Gorsky G., 
Grimsley N., Hingamp P., Iudicone D., Jaillon O., Not F., Ogata H., Pesant 
S., Speich S., Stemmann L., Sullivan M., Weissenbach J., Wincker P., Karsenti 
E., Raes J., Acinas S. and Bork P. (2015). Structure and function of the 
global ocean microbiome. <em>Science</em>, <b>348</b>, 6237.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
