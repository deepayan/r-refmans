<!DOCTYPE html><html><head><title>Help for package simmer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simmer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simmer-package'><p><span class="pkg">simmer</span>: Discrete-Event Simulation for <span class="rlang"><b>R</b></span></p></a></li>
<li><a href='#activate'><p>Activate/Deactivate Sources</p></a></li>
<li><a href='#add_dataframe'><p>Add a Data Frame</p></a></li>
<li><a href='#add_generator'><p>Add a Generator</p></a></li>
<li><a href='#add_global'><p>Add a Global Attribute</p></a></li>
<li><a href='#add_resource'><p>Add a Resource</p></a></li>
<li><a href='#batch'><p>Batch/Separate Arrivals</p></a></li>
<li><a href='#branch'><p>Fork the Trajectory Path</p></a></li>
<li><a href='#clone'><p>Clone/Synchronize Arrivals</p></a></li>
<li><a href='#Extract.trajectory'><p>Extract or Replace Parts of a Trajectory</p></a></li>
<li><a href='#generators'><p>Convenience Functions for Generators</p></a></li>
<li><a href='#get_capacity'><p>Get Resource Parameters</p></a></li>
<li><a href='#get_mon'><p>Monitoring Statistics</p></a></li>
<li><a href='#get_n_generated'><p>Get Process Parameters</p></a></li>
<li><a href='#get_sources'><p>Get Sources and Resources Defined</p></a></li>
<li><a href='#handle_unfinished'><p>Handle Unfinished Arrivals</p></a></li>
<li><a href='#join'><p>Join Trajectories</p></a></li>
<li><a href='#length.trajectory'><p>Number of Activities in a Trajectory</p></a></li>
<li><a href='#log_'><p>Debugging</p></a></li>
<li><a href='#monitor'><p>Create a Monitor</p></a></li>
<li><a href='#now'><p>Simulation Time</p></a></li>
<li><a href='#peek'><p>Peek Next Events</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#renege'><p>Renege on some Condition</p></a></li>
<li><a href='#reset'><p>Reset a Simulator</p></a></li>
<li><a href='#rollback'><p>Rollback to a Previous Activity</p></a></li>
<li><a href='#run'><p>Run a Simulation</p></a></li>
<li><a href='#schedule'><p>Generate a Scheduling Object</p></a></li>
<li><a href='#seize'><p>Seize/Release Resources</p></a></li>
<li><a href='#select'><p>Select Resources</p></a></li>
<li><a href='#send'><p>Inter-arrival Communication</p></a></li>
<li><a href='#set_attribute'><p>Set Attributes</p></a></li>
<li><a href='#set_capacity'><p>Set Resource Parameters</p></a></li>
<li><a href='#set_prioritization'><p>Set Prioritization Values</p></a></li>
<li><a href='#set_trajectory'><p>Set Source Parameters</p></a></li>
<li><a href='#simmer'><p>Create a Simulator</p></a></li>
<li><a href='#timeout'><p>Delay</p></a></li>
<li><a href='#trajectory'><p>Create a Trajectory</p></a></li>
<li><a href='#wrap'><p>Wrap a Simulation Environment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discrete-Event Simulation for R</td>
</tr>
<tr>
<td>Version:</td>
<td>4.4.6.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A process-oriented and trajectory-based Discrete-Event Simulation
    (DES) package for R. It is designed as a generic yet powerful framework. The
    architecture encloses a robust and fast simulation core written in 'C++' with
    automatic monitoring capabilities. It provides a rich and flexible R API that
    revolves around the concept of trajectory, a common path in the simulation
    model for entities of the same type. Documentation about 'simmer' is provided
    by several vignettes included in this package, via the paper by Ucar, Smeets
    &amp; Azcorra (2019, &lt;<a href="https://doi.org/10.18637%2Fjss.v090.i02">doi:10.18637/jss.v090.i02</a>&gt;), and the paper by Ucar,
    Hernández, Serrano &amp; Azcorra (2018, &lt;<a href="https://doi.org/10.1109%2FMCOM.2018.1700960">doi:10.1109/MCOM.2018.1700960</a>&gt;);
    see 'citation("simmer")' for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-simmer.org">https://r-simmer.org</a>, <a href="https://github.com/r-simmer/simmer">https://github.com/r-simmer/simmer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-simmer/simmer/issues">https://github.com/r-simmer/simmer/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, magrittr, codetools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>simmer.plot, parallel, testthat, knitr, rmarkdown, rticles</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.9)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 13:33:10 UTC; iucar</td>
</tr>
<tr>
<td>Author:</td>
<td>Iñaki Ucar <a href="https://orcid.org/0000-0001-6403-5550"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph, cre],
  Bart Smeets [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Iñaki Ucar &lt;iucar@fedoraproject.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simmer-package'><span class="pkg">simmer</span>: Discrete-Event Simulation for <span class="rlang"><b>R</b></span></h2><span id='topic+simmer-package'></span>

<h3>Description</h3>

<p>A process-oriented and trajectory-based Discrete-Event Simulation (DES)
package for <span class="rlang"><b>R</b></span>. Designed to be a generic framework like <span class="pkg">SimPy</span> or
<span class="pkg">SimJulia</span>, it leverages the power of <span class="pkg">Rcpp</span> to boost the performance
and turning DES in <span class="rlang"><b>R</b></span> feasible. As a noteworthy characteristic, <span class="pkg">simmer</span>
exploits the concept of trajectory: a common path in the simulation model for
entities of the same type. It is pretty flexible and simple to use, and
leverages the chaining/piping workflow introduced by the <span class="pkg">magrittr</span> package.
</p>


<h3>Author(s)</h3>

<p>Iñaki Ucar and Bart Smeets
</p>


<h3>References</h3>

<p>Ucar I., Smeets B., Azcorra A. (2019).
&quot;<span class="pkg">simmer</span>: Discrete-Event Simulation for <span class="rlang"><b>R</b></span>.&quot;
<em>Journal of Statistical Software</em>, <strong>90</strong>(2), 1-30.
<a href="https://doi.org/10.18637/jss.v090.i02">doi:10.18637/jss.v090.i02</a>.
</p>
<p>Ucar I., Hernández J.A., Serrano P., Azcorra A. (2018).
&quot;Design and Analysis of 5G Scenarios with <span class="pkg">simmer</span>: An <span class="rlang"><b>R</b></span> Package for
Fast DES Prototyping.&quot;
<em>IEEE Communications Magazine</em>, <strong>56</strong>(11), 145-151.
<a href="https://doi.org/10.1109/MCOM.2018.1700960">doi:10.1109/MCOM.2018.1700960</a>.
</p>


<h3>See Also</h3>

<p><span class="pkg">simmer</span>'s homepage <a href="https://r-simmer.org">https://r-simmer.org</a> and
GitHub repository <a href="https://github.com/r-simmer/simmer">https://github.com/r-simmer/simmer</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# introduction to simmer
vignette("simmer-01-introduction")

# JSS paper available as vignette
vignette("simmer-02-jss")

# more vignettes
vignette(package = "simmer")

## End(Not run)

</code></pre>

<hr>
<h2 id='activate'>Activate/Deactivate Sources</h2><span id='topic+activate'></span><span id='topic+deactivate'></span>

<h3>Description</h3>

<p>Activities for activating or deactivating the generation of arrivals by name.
Sources must be defined in the simulation environment (see
<code><a href="#topic+add_generator">add_generator</a></code>, <code><a href="#topic+add_dataframe">add_dataframe</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate(.trj, sources, ..., tag)

deactivate(.trj, sources, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activate_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="activate_+3A_sources">sources</code></td>
<td>
<p>the name(s) of the source(s) or a function returning the name(s).</p>
</td></tr>
<tr><td><code id="activate_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="activate_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_trajectory">set_trajectory</a></code>, <code><a href="#topic+set_source">set_source</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traj &lt;- trajectory() %&gt;%
  deactivate("dummy") %&gt;%
  timeout(1) %&gt;%
  activate("dummy")

simmer() %&gt;%
  add_generator("dummy", traj, function() 1) %&gt;%
  run(10) %&gt;%
  get_mon_arrivals()

</code></pre>

<hr>
<h2 id='add_dataframe'>Add a Data Frame</h2><span id='topic+add_dataframe'></span>

<h3>Description</h3>

<p>Attach a new source of arrivals to a trajectory from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dataframe(.env, name_prefix, trajectory, data, mon = 1, batch = 50,
  col_time = "time", time = c("interarrival", "absolute"),
  col_attributes = NULL, col_priority = "priority",
  col_preemptible = col_priority, col_restart = "restart")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dataframe_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_name_prefix">name_prefix</code></td>
<td>
<p>the name prefix of the generated arrivals.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_trajectory">trajectory</code></td>
<td>
<p>the trajectory that the generated arrivals will follow (see
<code><a href="#topic+trajectory">trajectory</a></code>).</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_data">data</code></td>
<td>
<p>a data frame with, at least, a column of (inter)arrival times (see details).</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_mon">mon</code></td>
<td>
<p>whether the simulator must monitor the generated arrivals or not
(0 = no monitoring, 1 = simple arrival monitoring, 2 = level 1 + arrival
attribute monitoring)</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_batch">batch</code></td>
<td>
<p>number of arrivals generated at a time. Arrivals are read from
the data frame and attached to the trajectory in batches depending on this
value. In general, it should not be changed.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_col_time">col_time</code></td>
<td>
<p>name of the time column in the data frame.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_time">time</code></td>
<td>
<p>type of time column: <em>interarrival</em>, if the time column
contains interarrival times, or <em>absolute</em>, if the time column contains
absolute arrival times.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_col_attributes">col_attributes</code></td>
<td>
<p>vector of names of the attributes columns (see details).</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_col_priority">col_priority</code></td>
<td>
<p>name of the priority column.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_col_preemptible">col_preemptible</code></td>
<td>
<p>name of the preemptible column.</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_col_restart">col_restart</code></td>
<td>
<p>name of the restart column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame provided must have, at least, a column of (inter)arrival
times. This method will look for it under the name <code>"time"</code> by default,
although this can be changed with the <code>col_time</code> parameter.
</p>
<p>If there is any column named <code>col_priority="priority"</code>,
<code>col_preemptible=priority</code> or <code>col_restart="restart"</code>, they will be
used to set the prioritization values for each arrival (see <code><a href="#topic+add_generator">add_generator</a></code>).
</p>
<p>If there are additional columns (with <code>col_attributes=NULL</code>, by default),
they will be assigned to arrival attributes named after each column name. All
these columns must be numeric (or logical). Otherwise, if a vector of column
names is specified, only these will be assigned as attributes and the rest of
the columns will be ignored.
</p>
<p>A value of <code>batch=Inf</code> means that the whole data frame will be attached
at the beginning of the simulation. This is not desirable in general, because
the performance of the event queue is degraded when it is populated with too
many events. On the other hand, a low value results in an increased overhead
due to many function calls. The default value has been tested to provide a
good trade-off.
</p>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p>Other sources: <code><a href="#topic+add_generator">add_generator</a></code>.
</p>

<hr>
<h2 id='add_generator'>Add a Generator</h2><span id='topic+add_generator'></span>

<h3>Description</h3>

<p>Attach a new source of arrivals to a trajectory from a generator function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_generator(.env, name_prefix, trajectory, distribution, mon = 1,
  priority = 0, preemptible = priority, restart = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_generator_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="add_generator_+3A_name_prefix">name_prefix</code></td>
<td>
<p>the name prefix of the generated arrivals. If several
names are provided, several generators will be defined with the same parameters.</p>
</td></tr>
<tr><td><code id="add_generator_+3A_trajectory">trajectory</code></td>
<td>
<p>the trajectory that the generated arrivals will follow (see
<code><a href="#topic+trajectory">trajectory</a></code>).</p>
</td></tr>
<tr><td><code id="add_generator_+3A_distribution">distribution</code></td>
<td>
<p>a function modelling the interarrival times (returning a
negative value or a missing value stops the generator).</p>
</td></tr>
<tr><td><code id="add_generator_+3A_mon">mon</code></td>
<td>
<p>whether the simulator must monitor the generated arrivals or not
(0 = no monitoring, 1 = simple arrival monitoring, 2 = level 1 + arrival
attribute monitoring)</p>
</td></tr>
<tr><td><code id="add_generator_+3A_priority">priority</code></td>
<td>
<p>the priority of each arrival (a higher integer equals higher
priority; defaults to the minimum priority, which is 0).</p>
</td></tr>
<tr><td><code id="add_generator_+3A_preemptible">preemptible</code></td>
<td>
<p>if a seize occurs in a preemptive resource, this parameter
establishes the minimum incoming priority that can preempt these arrivals (an
arrival with a priority greater than <code>preemptible</code> gains the resource). In
any case, <code>preemptible</code> must be equal or greater than <code>priority</code>, and
thus only higher priority arrivals can trigger preemption.</p>
</td></tr>
<tr><td><code id="add_generator_+3A_restart">restart</code></td>
<td>
<p>whether the activity must be restarted after being preempted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p>Convenience functions: <code><a href="#topic+at">at</a></code>, <code><a href="#topic+from">from</a></code>,
<code><a href="#topic+to">to</a></code>, <code><a href="#topic+from_to">from_to</a></code>, <code><a href="#topic+when_activated">when_activated</a></code>.
</p>
<p>Other sources: <code><a href="#topic+add_dataframe">add_dataframe</a></code>.
</p>

<hr>
<h2 id='add_global'>Add a Global Attribute</h2><span id='topic+add_global'></span>

<h3>Description</h3>

<p>Attach a global variable to the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_global(.env, key, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_global_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="add_global_+3A_key">key</code></td>
<td>
<p>the attribute name.</p>
</td></tr>
<tr><td><code id="add_global_+3A_value">value</code></td>
<td>
<p>the value to set, either a numeric or a <code><a href="#topic+schedule">schedule</a></code>,
so that the global may change during the simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p>Convenience functions: <code><a href="#topic+schedule">schedule</a></code>.
</p>

<hr>
<h2 id='add_resource'>Add a Resource</h2><span id='topic+add_resource'></span>

<h3>Description</h3>

<p>Define a new resource in a simulation environment. Resources are conceived
with queuing systems in mind, and therefore they comprise two internal
self-managed parts: a <em>server</em>, which is the active part, with a
specified capacity that can be seized and released (see <code><a href="#topic+seize">seize</a></code>);
and a priority <em>queue</em> of a certain size, in which arrivals may wait for
the server to be available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_resource(.env, name, capacity = 1, queue_size = Inf, mon = TRUE,
  preemptive = FALSE, preempt_order = c("fifo", "lifo"),
  queue_size_strict = FALSE, queue_priority = c(0, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_resource_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_name">name</code></td>
<td>
<p>the name of the resource. If several names are provided, several
resources will be defined with the same parameters.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_capacity">capacity</code></td>
<td>
<p>the capacity of the server, either an integer or a
<code><a href="#topic+schedule">schedule</a></code>, so that the value may change during the simulation.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_queue_size">queue_size</code></td>
<td>
<p>the size of the queue, either an integer or a
<code><a href="#topic+schedule">schedule</a></code>, so that the value may change during the simulation.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_mon">mon</code></td>
<td>
<p>whether the simulator must monitor this resource or not.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_preemptive">preemptive</code></td>
<td>
<p>whether arrivals in the server can be preempted or not based
on seize priorities.</p>
</td></tr>
<tr><td><code id="add_resource_+3A_preempt_order">preempt_order</code></td>
<td>
<p>if <code>preemptive=TRUE</code> and several arrivals are
preempted, this parameter defines which arrival should be preempted first.
Either <code>fifo</code> (First In First Out: older preemptible tasks are preempted
first) or <code>lifo</code> (Last In First Out: newer preemptible tasks are
preempted first).</p>
</td></tr>
<tr><td><code id="add_resource_+3A_queue_size_strict">queue_size_strict</code></td>
<td>
<p>whether the <code>queue_size</code> is a hard limit (see
details).</p>
</td></tr>
<tr><td><code id="add_resource_+3A_queue_priority">queue_priority</code></td>
<td>
<p>the priority range required to be able to access the
queue if there is no room in the server (if a single value is provided, it is
treated as the minimum priority). By default, all arrivals can be enqueued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An entity trying to seize a resource (see <code><a href="#topic+seize">seize</a></code>) may
1) access the server straightaway if there is enough capacity, 2) wait in the
queue if there is no room in the server but there is room in the queue, or 3)
rejected if there is no room in the queue either.
</p>
<p>There are two special situations regarding queue management: 1) the
<code>queue_size</code> is shrinked below the actual number of items waiting, and
2) preemption occurs, and an item previously in the server goes to the queue.
By default in both cases, the excess of items in the queue is allowed.
However, with <code>queue_size_strict=TRUE</code>, the maximum <code>queue_size</code> is
guaranteed, and thus some entities will be rejected (dropped) by the resource.
</p>
<p>Whenever an arrival is rejected (due to a server drop or a queue drop), it
will set the <code>finished</code> flag to <code>FALSE</code> in the output of
<code><a href="#topic+get_mon_arrivals">get_mon_arrivals</a></code>. Unfinished arrivals can be handled with a
drop-out trajectory that can be set using the <code><a href="#topic+handle_unfinished">handle_unfinished</a></code>
activity.
</p>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p>Convenience functions: <code><a href="#topic+schedule">schedule</a></code>.
</p>

<hr>
<h2 id='batch'>Batch/Separate Arrivals</h2><span id='topic+batch'></span><span id='topic+separate'></span>

<h3>Description</h3>

<p>Activities for collecting a number of arrivals before they can continue processing
and splitting a previously established batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch(.trj, n, timeout = 0, permanent = FALSE, name = "", rule = NULL,
  ..., tag)

separate(.trj, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="batch_+3A_n">n</code></td>
<td>
<p>batch size, accepts a numeric or a callable object (a function)
which must return a numeric.</p>
</td></tr>
<tr><td><code id="batch_+3A_timeout">timeout</code></td>
<td>
<p>set an optional timer which triggers batches every
<code>timeout</code> time units even if the batch size has not been fulfilled,
accepts a numeric or a callable object (a function) which must return a
numeric (0 = disabled).</p>
</td></tr>
<tr><td><code id="batch_+3A_permanent">permanent</code></td>
<td>
<p>if <code>TRUE</code>, batches cannot be split.</p>
</td></tr>
<tr><td><code id="batch_+3A_name">name</code></td>
<td>
<p>optional string. Unnamed batches from different <code>batch</code>
activities are independent. However, if you want to feed arrivals from
different trajectories into a same batch, you need to specify a common name
across all your <code>batch</code> activities.</p>
</td></tr>
<tr><td><code id="batch_+3A_rule">rule</code></td>
<td>
<p>an optional callable object (a function) which will be applied to
every arrival to determine whether it should be included into the batch, thus
it must return a boolean.</p>
</td></tr>
<tr><td><code id="batch_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="batch_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## unnamed batch with a timeout
traj &lt;- trajectory() %&gt;%
  log_("arrived") %&gt;%
  batch(2, timeout=5) %&gt;%
  log_("in a batch") %&gt;%
  timeout(5) %&gt;%
  separate() %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_generator("dummy", traj, at(0:2)) %&gt;%
  run() %&gt;% invisible

## batching based on some dynamic rule
traj &lt;- trajectory() %&gt;%
  log_("arrived") %&gt;%
  # always FALSE -&gt; no batches
  batch(2, rule=function() FALSE) %&gt;%
  log_("not in a batch") %&gt;%
  timeout(5) %&gt;%
  separate() %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_generator("dummy", traj, at(0:2)) %&gt;%
  run() %&gt;% invisible

## named batch, shared across trajectories
traj0 &lt;- trajectory() %&gt;%
  log_("arrived traj0") %&gt;%
  batch(2, name = "mybatch")

traj1 &lt;- trajectory() %&gt;%
  log_("arrived traj1") %&gt;%
  timeout(1) %&gt;%
  batch(2, name = "mybatch") %&gt;%
  log_("in a batch") %&gt;%
  timeout(2) %&gt;%
  separate() %&gt;%
  log_("leaving traj1")

simmer() %&gt;%
  add_generator("dummy0", traj0, at(0)) %&gt;%
  add_generator("dummy1", traj1, at(0)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='branch'>Fork the Trajectory Path</h2><span id='topic+branch'></span>

<h3>Description</h3>

<p>Activity for defining a fork with <code>N</code> alternative sub-trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branch(.trj, option, continue, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branch_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="branch_+3A_option">option</code></td>
<td>
<p>a callable object (a function) which must return an integer between
<code>0</code> and <code>N</code>. A return value equal to <code>0</code> skips the branch and
continues to the next activity. A returning value between <code>1</code> to <code>N</code>
makes the arrival to follow the corresponding sub-trajectory.</p>
</td></tr>
<tr><td><code id="branch_+3A_continue">continue</code></td>
<td>
<p>a vector of <code>N</code> booleans that indicate whether the arrival
must continue to the main trajectory after each sub-trajectory or not (if only
one value is provided, it will be recycled to match the number of sub-trajectories).</p>
</td></tr>
<tr><td><code id="branch_+3A_...">...</code></td>
<td>
<p><code>N</code> trajectory objects (or a list of <code>N</code> trajectory objects)
describing each sub-trajectory.</p>
</td></tr>
<tr><td><code id="branch_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- simmer()

traj &lt;- trajectory() %&gt;%
  set_global("path", 1, mod="+", init=-1) %&gt;%
  log_(function() paste("Path", get_global(env, "path"), "selected")) %&gt;%
  branch(
    function() get_global(env, "path"), continue=c(TRUE, FALSE),
    trajectory() %&gt;%
      log_("following path 1"),
    trajectory() %&gt;%
      log_("following path 2")) %&gt;%
  log_("continuing after the branch (path 0)")

env %&gt;%
  add_generator("dummy", traj, at(0:2)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='clone'>Clone/Synchronize Arrivals</h2><span id='topic+clone'></span><span id='topic+synchronize'></span>

<h3>Description</h3>

<p>Activities for defining a parallel fork and removing the copies. <code>clone</code>
replicates an arrival <code>n</code> times (the original one + <code>n-1</code> copies).
<code>synchronize</code> removes all but one clone for each set of clones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(.trj, n, ..., tag)

synchronize(.trj, wait = TRUE, mon_all = FALSE, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="clone_+3A_n">n</code></td>
<td>
<p>number of clones, accepts either a numeric or a callable object
(a function) which must return a numeric.</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>a number of optional parallel sub-trajectories (or a list of
sub-trajectories). Each clone will follow a different sub-trajectory if available.</p>
</td></tr>
<tr><td><code id="clone_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="clone_+3A_wait">wait</code></td>
<td>
<p>if <code>FALSE</code>, all clones but the first to arrive are removed.
if <code>TRUE</code> (default), all clones but the last to arrive are removed.</p>
</td></tr>
<tr><td><code id="clone_+3A_mon_all">mon_all</code></td>
<td>
<p>if <code>TRUE</code>, <code>get_mon_arrivals</code> will show one
line per clone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## clone and wait for the others
traj &lt;- trajectory() %&gt;%
  clone(
    n = 3,
    trajectory() %&gt;%
      log_("clone 0 (original)") %&gt;%
      timeout(1),
    trajectory() %&gt;%
      log_("clone 1") %&gt;%
      timeout(2),
    trajectory() %&gt;%
      log_("clone 2") %&gt;%
      timeout(3)) %&gt;%
  log_("sync reached") %&gt;%
  synchronize(wait = TRUE) %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_generator("arrival", traj, at(0)) %&gt;%
  run() %&gt;% invisible

## more clones that trajectories available
traj &lt;- trajectory() %&gt;%
  clone(
    n = 5,
    trajectory() %&gt;%
      log_("clone 0 (original)") %&gt;%
      timeout(1)) %&gt;%
  log_("sync reached") %&gt;%
  synchronize(wait = TRUE) %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_generator("arrival", traj, at(0)) %&gt;%
  run() %&gt;% invisible

## clone and continue without waiting
traj &lt;- trajectory() %&gt;%
  clone(
    n = 3,
    trajectory() %&gt;%
      log_("clone 0 (original)") %&gt;%
      timeout(1),
    trajectory() %&gt;%
      log_("clone 1") %&gt;%
      timeout(2),
    trajectory() %&gt;%
      log_("clone 2") %&gt;%
      timeout(3)) %&gt;%
  log_("sync reached") %&gt;%
  synchronize(wait = FALSE) %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_generator("arrival", traj, at(0)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='Extract.trajectory'>Extract or Replace Parts of a Trajectory</h2><span id='topic+Extract.trajectory'></span><span id='topic++5B.trajectory'></span><span id='topic++5B+5B.trajectory'></span><span id='topic++5B+3C-.trajectory'></span><span id='topic++5B+5B+3C-.trajectory'></span>

<h3>Description</h3>

<p>Operators acting on trajectories to extract or replace parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory'
x[i]

## S3 method for class 'trajectory'
x[[i]]

## S3 replacement method for class 'trajectory'
x[i] &lt;- value

## S3 replacement method for class 'trajectory'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.trajectory_+3A_x">x</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="Extract.trajectory_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract. Indices are <code>numeric</code>
or <code>character</code> or <code>logical</code> vectors or empty (missing) or <code>NULL</code>.
</p>
<p>Numeric values are coerced to integer as by <code><a href="base.html#topic+as.integer">as.integer</a></code> (and
hence truncated towards zero). Negative integers indicate elements/slices to
leave out the selection.
</p>
<p>Character vectors will be matched to the names of the activities in the
trajectory as by <code><a href="base.html#topic++25in+25">%in%</a></code>.
</p>
<p>Logical vectors indicate elements/slices to select. Such vectors are recycled
if necessary to match the corresponding extent.
</p>
<p>An empty index will return the whole trajectory.
</p>
<p>An index value of <code>NULL</code> is treated as if it were <code>integer(0)</code>.</p>
</td></tr>
<tr><td><code id="Extract.trajectory_+3A_value">value</code></td>
<td>
<p>another trajectory object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+length.trajectory">length.trajectory</a></code>, <code><a href="#topic+get_n_activities">get_n_activities</a></code>,
<code><a href="#topic+join">join</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- join(lapply(1:12, function(i)
  trajectory() %&gt;% timeout(i)
))
x

x[10]                 # the tenth element of x
x[-1]                 # delete the 1st element of x
x[c(TRUE, FALSE)]     # logical indexing
x[c(1, 5, 2, 12, 4)]  # numeric indexing
x[c(FALSE, TRUE)] &lt;- x[c(TRUE, FALSE)] # replacing
x

</code></pre>

<hr>
<h2 id='generators'>Convenience Functions for Generators</h2><span id='topic+generators'></span><span id='topic+at'></span><span id='topic+from'></span><span id='topic+to'></span><span id='topic+from_to'></span><span id='topic+when_activated'></span>

<h3>Description</h3>

<p>These convenience functions facilitate the definition of generators of arrivals
for some common cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at(...)

from(start_time, dist, arrive = TRUE)

to(stop_time, dist)

from_to(start_time, stop_time, dist, arrive = TRUE, every = NULL)

when_activated(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generators_+3A_...">...</code></td>
<td>
<p>a vector or multiple parameters of times at which to initiate an arrival.</p>
</td></tr>
<tr><td><code id="generators_+3A_start_time">start_time</code></td>
<td>
<p>the time at which to launch the initial arrival
(numeric or function).</p>
</td></tr>
<tr><td><code id="generators_+3A_dist">dist</code></td>
<td>
<p>a function modelling the interarrival times. It is supposed to be
an infinite source of values <code>&gt;= 0</code> (e.g., <code>rexp</code> and the like). If
the function provided returns any negative value, the behaviour is undefined.</p>
</td></tr>
<tr><td><code id="generators_+3A_arrive">arrive</code></td>
<td>
<p>if set to <code>TRUE</code> (default) the first arrival will be
generated at <code>start_time</code> and will follow <code>dist</code> from then on.
If set to <code>FALSE</code>, will initiate <code>dist</code> at <code>start_time</code>
(and the first arrival will most likely start at a time later than
<code>start_time</code>).</p>
</td></tr>
<tr><td><code id="generators_+3A_stop_time">stop_time</code></td>
<td>
<p>the time at which to stop the generator (numeric or function).</p>
</td></tr>
<tr><td><code id="generators_+3A_every">every</code></td>
<td>
<p>repeat with this time cycle (numeric or function).</p>
</td></tr>
<tr><td><code id="generators_+3A_n">n</code></td>
<td>
<p>an integer or a callable object (a function) which must return
a number of arrivals to generate when activated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+at">at</a></code> generates arrivals at specific absolute times.
</p>
<p><code><a href="#topic+from">from</a></code> generates inter-arrivals following a given distribution
with a specified start time.
union of the last two.
</p>
<p><code><a href="#topic+to">to</a></code> generates inter-arrivals following a given
distribution with a specified stop time.
</p>
<p><code><a href="#topic+from_to">from_to</a></code> is the union of <code>from</code> and <code>to</code>.
</p>
<p><code><a href="#topic+when_activated">when_activated</a></code> sets up an initially inactive generator
which generates <code>n</code> arrivals each time it is activated from any
trajectory using the activity <code><a href="#topic+activate">activate</a></code>.
</p>


<h3>Value</h3>

<p>Returns a generator function (a closure).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_generator">add_generator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## common to all examples below
# some trajectory
t0 &lt;- trajectory() %&gt;%
  timeout(0)
# some distribution
distr &lt;- function() runif(1, 1, 2)

# arrivals at 0, 1, 10, 30, 40 and 43
simmer() %&gt;%
  add_generator("dummy", t0, at(0, c(1,10,30), 40, 43)) %&gt;%
  run(100) %&gt;%
  get_mon_arrivals()

# apply distribution starting at 5 (and no end)
simmer() %&gt;%
  add_generator("dummy", t0, from(5, distr)) %&gt;%
  run(10) %&gt;%
  get_mon_arrivals()

# apply distribution until 5 (starting at 0)
simmer() %&gt;%
  add_generator("dummy", t0, to(5, distr)) %&gt;%
  run(10) %&gt;%
  get_mon_arrivals()

# apply distribution from 8 to 16 h every 24 h:
simmer() %&gt;%
  add_generator("dummy", t0, from_to(8, 16, distr, every=24)) %&gt;%
  run(48) %&gt;%
  get_mon_arrivals()

# triggering arrivals on demand from a trajectory
t1 &lt;- trajectory() %&gt;%
  activate("dummy")

simmer() %&gt;%
  add_generator("dummy", t0, when_activated()) %&gt;%
  add_generator("trigger", t1, at(2)) %&gt;%
  run() %&gt;%
  get_mon_arrivals()

</code></pre>

<hr>
<h2 id='get_capacity'>Get Resource Parameters</h2><span id='topic+get_capacity'></span><span id='topic+get_capacity_selected'></span><span id='topic+get_queue_size'></span><span id='topic+get_queue_size_selected'></span><span id='topic+get_server_count'></span><span id='topic+get_server_count_selected'></span><span id='topic+get_queue_count'></span><span id='topic+get_queue_count_selected'></span><span id='topic+get_seized'></span><span id='topic+get_seized_selected'></span><span id='topic+get_activity_time'></span><span id='topic+get_activity_time_selected'></span><span id='topic+get_selected'></span>

<h3>Description</h3>

<p>Getters for resources: server capacity/count and queue size/count, seized
amount, activity time, and selected resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_capacity(.env, resources)

get_capacity_selected(.env, id = 0)

get_queue_size(.env, resources)

get_queue_size_selected(.env, id = 0)

get_server_count(.env, resources)

get_server_count_selected(.env, id = 0)

get_queue_count(.env, resources)

get_queue_count_selected(.env, id = 0)

get_seized(.env, resources)

get_seized_selected(.env, id = 0)

get_activity_time(.env, resources)

get_activity_time_selected(.env, id = 0)

get_selected(.env, id = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_capacity_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="get_capacity_+3A_resources">resources</code></td>
<td>
<p>one or more resource names.</p>
</td></tr>
<tr><td><code id="get_capacity_+3A_id">id</code></td>
<td>
<p>selection identifier for nested usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no resources are provided to <code>get_activity_time</code>, the
overall activity time is reported.
</p>


<h3>Value</h3>

<p>Return a vector (character for <code>get_selected</code>, numeric for the
rest of them).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_resources">get_resources</a></code>, <code><a href="#topic+set_capacity">set_capacity</a></code>,
<code><a href="#topic+set_queue_size">set_queue_size</a></code>, <code><a href="#topic+seize">seize</a></code>, <code><a href="#topic+timeout">timeout</a></code>.
</p>

<hr>
<h2 id='get_mon'>Monitoring Statistics</h2><span id='topic+get_mon'></span><span id='topic+get_mon_arrivals'></span><span id='topic+get_mon_attributes'></span><span id='topic+get_mon_resources'></span>

<h3>Description</h3>

<p>Getters for obtaining monitored data (if any) about arrivals, attributes and resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mon_arrivals(.envs, per_resource = FALSE, ongoing = FALSE)

get_mon_attributes(.envs)

get_mon_resources(.envs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mon_+3A_.envs">.envs</code></td>
<td>
<p>the simulation environment (or a list of environments).</p>
</td></tr>
<tr><td><code id="get_mon_+3A_per_resource">per_resource</code></td>
<td>
<p>if <code>TRUE</code>, statistics will be reported on a per-resource basis.</p>
</td></tr>
<tr><td><code id="get_mon_+3A_ongoing">ongoing</code></td>
<td>
<p>if <code>TRUE</code>, ongoing arrivals will be reported. The columns
<code>end_time</code> and <code>finished</code> of these arrivals are reported as <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame.
</p>

<hr>
<h2 id='get_n_generated'>Get Process Parameters</h2><span id='topic+get_n_generated'></span><span id='topic+get_trajectory'></span><span id='topic+get_name'></span><span id='topic+get_attribute'></span><span id='topic+get_global'></span><span id='topic+get_prioritization'></span><span id='topic+get_batch_size'></span>

<h3>Description</h3>

<p>Getters for processes (sources and arrivals) number of arrivals generated
by a source, the name of the active arrival, an attribute from the active
arrival or a global one, prioritization values, or the number of arrivals
in an active batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_n_generated(.env, sources)

get_trajectory(.env, sources)

get_name(.env)

get_attribute(.env, keys)

get_global(.env, keys)

get_prioritization(.env)

get_batch_size(.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_n_generated_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="get_n_generated_+3A_sources">sources</code></td>
<td>
<p>one or more resource names.</p>
</td></tr>
<tr><td><code id="get_n_generated_+3A_keys">keys</code></td>
<td>
<p>the attribute name(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_n_generated</code> returns the number of arrivals generated by
the given sources. <code>get_trajectory</code> returns the trajectory to which they
are attached (as a list).
</p>
<p><code>get_name</code> returns the number of the running arrival. <code>get_attribute</code>
returns a running arrival's attributes. If a provided key was not previously
set, it returns a missing value. <code>get_global</code> returns a global attribute.
<code>get_prioritization</code> returns a running arrival's prioritization values.
<code>get_name</code>, <code>get_attribute</code> and <code>get_prioritization</code> are meant
to be used inside a trajectory; otherwise, there will be no arrival running
and these functions will throw an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_sources">get_sources</a></code>, <code><a href="#topic+set_trajectory">set_trajectory</a></code>,
<code><a href="#topic+set_attribute">set_attribute</a></code>, <code><a href="#topic+set_global">set_global</a></code>,
<code><a href="#topic+set_prioritization">set_prioritization</a></code>, <code><a href="#topic+batch">batch</a></code>.
</p>

<hr>
<h2 id='get_sources'>Get Sources and Resources Defined</h2><span id='topic+get_sources'></span><span id='topic+get_resources'></span>

<h3>Description</h3>

<p>Get a list of names of sources or resources defined in a simulation environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sources(.env)

get_resources(.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sources_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='handle_unfinished'>Handle Unfinished Arrivals</h2><span id='topic+handle_unfinished'></span>

<h3>Description</h3>

<p>Activity for setting a drop-out trajectory for unfinished arrivals, i.e.,
those dropped from a resource (due to preemption, resource shrinkage or a
rejected <code><a href="#topic+seize">seize</a></code>) or those that <code><a href="#topic+leave">leave</a></code> a trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_unfinished(.trj, handler, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_unfinished_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="handle_unfinished_+3A_handler">handler</code></td>
<td>
<p>trajectory object to handle unfinished arrivals. A <code>NULL</code>
value will unset the drop-out trajectory.</p>
</td></tr>
<tr><td><code id="handle_unfinished_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="handle_unfinished_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leave">leave</a></code>, <code><a href="#topic+set_capacity">set_capacity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traj &lt;- trajectory() %&gt;%
  log_("arrived") %&gt;%
  handle_unfinished(
    trajectory() %&gt;%
      log_("preempted!")) %&gt;%
  seize("res") %&gt;%
  log_("resource seized") %&gt;%
  timeout(10) %&gt;%
  release("res") %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_resource("res", 1, 0, preemptive=TRUE, queue_size_strict=TRUE) %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  add_generator("priority_dummy", traj, at(5), priority=1) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='join'>Join Trajectories</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Concatenate any number of trajectories in the specified order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p>trajectory objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extract.trajectory">Extract.trajectory</a></code>, <code><a href="#topic+length.trajectory">length.trajectory</a></code>,
<code><a href="#topic+get_n_activities">get_n_activities</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- trajectory() %&gt;% seize("dummy", 1)
t2 &lt;- trajectory() %&gt;% timeout(1)
t3 &lt;- trajectory() %&gt;% release("dummy", 1)

## join can be used alone
join(t1, t2, t3)

## or can be chained in a trajectory definition
trajectory() %&gt;%
  join(t1) %&gt;%
  timeout(1) %&gt;%
  join(t3)

</code></pre>

<hr>
<h2 id='length.trajectory'>Number of Activities in a Trajectory</h2><span id='topic+length.trajectory'></span><span id='topic+get_n_activities'></span>

<h3>Description</h3>

<p>Get the number of activities in a trajectory. <code>length</code> returns the number
of first-level activities (sub-trajectories not included). <code>get_n_activities</code>
returns the total number of activities (sub-trajectories included).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trajectory'
length(x)

get_n_activities(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.trajectory_+3A_x">x</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a non-negative integer of length 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extract.trajectory">Extract.trajectory</a></code>, <code><a href="#topic+join">join</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- trajectory() %&gt;%
  timeout(1)

x &lt;- x %&gt;%
  clone(2, x, x)
x

## length does not account for subtrajectories
length(x)
get_n_activities(x)

</code></pre>

<hr>
<h2 id='log_'>Debugging</h2><span id='topic+log_'></span><span id='topic+stop_if'></span>

<h3>Description</h3>

<p>Activities for displaying messages preceded by the simulation time and the
name of the arrival, and for setting conditional breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_(.trj, message, level = 0, ..., tag)

stop_if(.trj, condition, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log__+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="log__+3A_message">message</code></td>
<td>
<p>the message to display, accepts either a string or a callable object
(a function) which must return a string.</p>
</td></tr>
<tr><td><code id="log__+3A_level">level</code></td>
<td>
<p>debugging level. The <code>message</code> will be printed if, and only if,
the <code>level</code> provided is less or equal to the <code>log_level</code> defined in the
simulation environment (see <code><a href="#topic+simmer">simmer</a></code>).</p>
</td></tr>
<tr><td><code id="log__+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="log__+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="log__+3A_condition">condition</code></td>
<td>
<p>a boolean or a function returning a boolean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## log levels
traj &lt;- trajectory() %&gt;%
  log_("this is always printed") %&gt;% # level = 0 by default
  log_("this is printed if `log_level&gt;=1`", level = 1) %&gt;%
  log_("this is printed if `log_level&gt;=2`", level = 2)

simmer() %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  run() %&gt;% invisible

simmer(log_level = 1) %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  run() %&gt;% invisible

simmer(log_level = Inf) %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='monitor'>Create a Monitor</h2><span id='topic+monitor'></span><span id='topic+monitor_mem'></span><span id='topic+monitor_delim'></span><span id='topic+monitor_csv'></span>

<h3>Description</h3>

<p>Methods for creating <code>monitor</code> objects for simulation environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitor(name, xptr, get_arrivals, get_attributes, get_resources,
  handlers = NULL, finalizer = NULL)

monitor_mem()

monitor_delim(path = tempdir(), keep = FALSE, sep = " ", ext = ".txt",
  reader = read.delim, args = list(stringsAsFactors = FALSE))

monitor_csv(path = tempdir(), keep = FALSE, reader = read.csv,
  args = list(stringsAsFactors = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monitor_+3A_name">name</code></td>
<td>
<p>an identifier to show when printed.</p>
</td></tr>
<tr><td><code id="monitor_+3A_xptr">xptr</code></td>
<td>
<p>an external pointer pointing to a C++ object derived from the
abstract class simmer::Monitor. See C++ API for further details and, in
particular, the <code>simmer/monitor.h</code> header.</p>
</td></tr>
<tr><td><code id="monitor_+3A_get_arrivals">get_arrivals</code></td>
<td>
<p>a function to retrieve the arrivals tables. It must accept
the <code>xptr</code> as a first argument, even if it is not needed, and a boolean
<code>per_resource</code> as a second argument (see <code><a href="#topic+get_mon_arrivals">get_mon_arrivals</a></code>).</p>
</td></tr>
<tr><td><code id="monitor_+3A_get_attributes">get_attributes</code></td>
<td>
<p>a function to retrieve the attributes table. It must accept
the <code>xptr</code> as a first argument, even if it is not needed.</p>
</td></tr>
<tr><td><code id="monitor_+3A_get_resources">get_resources</code></td>
<td>
<p>a function to retrieve the resources table. It must accept
the <code>xptr</code> as a first argument, even if it is not needed.</p>
</td></tr>
<tr><td><code id="monitor_+3A_handlers">handlers</code></td>
<td>
<p>an optional list of handlers that will be stored in a slot of
the same name. For example, <code>monitor_mem</code> does not use this slot, but
<code>monitor_delim</code> and <code>monitor_csv</code> store the path to the created files.</p>
</td></tr>
<tr><td><code id="monitor_+3A_finalizer">finalizer</code></td>
<td>
<p>an optional one-argument function to be called when the
object is destroyed. For example, <code>monitor_mem</code> does not require any
finalizer, but <code>monitor_delim</code> and <code>monitor_csv</code> use this to remove
the created files when the monitor is destroyed.</p>
</td></tr>
<tr><td><code id="monitor_+3A_path">path</code></td>
<td>
<p>directory where files will be created (must exist).</p>
</td></tr>
<tr><td><code id="monitor_+3A_keep">keep</code></td>
<td>
<p>whether to keep files on exit. By default, files are removed.</p>
</td></tr>
<tr><td><code id="monitor_+3A_sep">sep</code></td>
<td>
<p>separator character.</p>
</td></tr>
<tr><td><code id="monitor_+3A_ext">ext</code></td>
<td>
<p>file extension to use.</p>
</td></tr>
<tr><td><code id="monitor_+3A_reader">reader</code></td>
<td>
<p>function that will be used to read the files.</p>
</td></tr>
<tr><td><code id="monitor_+3A_args">args</code></td>
<td>
<p>a list of further arguments for <code>reader</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>monitor</code> method is a generic function to instantiate a
<code>monitor</code> object. It should not be used in general unless you want to
extend <code>simmer</code> with a custom monitor.
</p>
<p>The in-memory monitor is enabled by default (<code>memory_mem</code>),
and it should the fastest.
</p>
<p>For large simulations, or if the RAM footprint is an issue, you may
consider monitoring to disk. To that end, <code>monitor_delim</code> stores the values
in flat delimited files. The usual <code><a href="#topic+get_mon">get_mon</a>_*</code> methods retrieve
data frames from such files using the <code>reader</code> provided. By default,
<code><a href="utils.html#topic+read.table">read.delim</a></code> is used, but you may consider using faster
alternatives from other packages. It is also possible to <code>keep</code> the
files in a custom directory to read and post-process them in a separate
workflow.
</p>
<p><code>monitor_csv</code> is a special case of <code>monitor_delim</code> with
<code>sep=","</code> and <code>ext=".csv"</code>.
</p>


<h3>Value</h3>

<p>A <code>monitor</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mon &lt;- monitor_csv()
mon

env &lt;- simmer(mon=mon) %&gt;%
  add_generator("dummy", trajectory() %&gt;% timeout(1), function() 1) %&gt;%
  run(10)
env

read.csv(mon$handlers$arrivals) # direct access
get_mon_arrivals(env)           # adds the "replication" column

</code></pre>

<hr>
<h2 id='now'>Simulation Time</h2><span id='topic+now'></span>

<h3>Description</h3>

<p>Get the current simulation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>now(.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="now_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+peek">peek</a></code>.
</p>

<hr>
<h2 id='peek'>Peek Next Events</h2><span id='topic+peek'></span>

<h3>Description</h3>

<p>Look for future events in the event queue and (optionally) obtain info about them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(.env, steps = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peek_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="peek_+3A_steps">steps</code></td>
<td>
<p>number of steps to peek.</p>
</td></tr>
<tr><td><code id="peek_+3A_verbose">verbose</code></td>
<td>
<p>show additional information (i.e., the name of the process)
about future events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns numeric values if <code>verbose=F</code> and a data frame otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+now">now</a></code>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='renege'>Renege on some Condition</h2><span id='topic+renege'></span><span id='topic+leave'></span><span id='topic+renege_in'></span><span id='topic+renege_if'></span><span id='topic+renege_abort'></span>

<h3>Description</h3>

<p>Activities for leaving with some probability, or for setting or unsetting a
timer or a signal after which the arrival will abandon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leave(.trj, prob, out = NULL, keep_seized = TRUE, ..., tag)

renege_in(.trj, t, out = NULL, keep_seized = FALSE, ..., tag)

renege_if(.trj, signal, out = NULL, keep_seized = FALSE, ..., tag)

renege_abort(.trj, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renege_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="renege_+3A_prob">prob</code></td>
<td>
<p>a probability or a function returning a probability.</p>
</td></tr>
<tr><td><code id="renege_+3A_out">out</code></td>
<td>
<p>optional sub-trajectory in case of reneging.</p>
</td></tr>
<tr><td><code id="renege_+3A_keep_seized">keep_seized</code></td>
<td>
<p>whether to keep already seized resources. By default, all
resources are released.</p>
</td></tr>
<tr><td><code id="renege_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="renege_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="renege_+3A_t">t</code></td>
<td>
<p>timeout to trigger reneging, accepts either a numeric or a callable
object (a function) which must return a numeric.</p>
</td></tr>
<tr><td><code id="renege_+3A_signal">signal</code></td>
<td>
<p>signal to trigger reneging, accepts either a string or a
callable object (a function) which must return a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arrivals that leave the trajectory will set the <code>finished</code> flag
to <code>FALSE</code> in the output of <code><a href="#topic+get_mon_arrivals">get_mon_arrivals</a></code>. Unfinished
arrivals can be handled with a drop-out trajectory that can be set using the
optional argument <code>out</code> or the <code><a href="#topic+handle_unfinished">handle_unfinished</a></code> activity.
</p>
<p>Note that, for historical reasons, <code>leave</code> has <code>keep_seized=TRUE</code>
by default, while <code>renege_*</code> does not.
</p>
<p>Note that <code>renege_if</code> works similarly to <code><a href="#topic+trap">trap</a></code>,
but in contrast to that, reneging is triggered even if the arrival is waiting
in a queue or is part of a non-permanent <code><a href="#topic+batch">batch</a></code>.
</p>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+handle_unfinished">handle_unfinished</a></code>
</p>
<p><code><a href="#topic+send">send</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## leave with some probability
set.seed(1234)

traj &lt;- trajectory() %&gt;%
  log_("leave with some probability") %&gt;%
  leave(function() runif(1) &lt; 0.5) %&gt;%
  log_("didn't leave")

simmer() %&gt;%
  add_generator("dummy", traj, at(0, 1)) %&gt;%
  run() %&gt;% invisible

## reneging after some time
bank &lt;- trajectory() %&gt;%
  log_("here I am") %&gt;%
  # renege in 5 minutes
  renege_in(
    5,
    out = trajectory() %&gt;%
      log_("lost my patience. Reneging...")) %&gt;%
  seize("clerk") %&gt;%
  # stay if I'm being attended within 5 minutes
  renege_abort() %&gt;%
  log_("I'm being attended") %&gt;%
  timeout(10) %&gt;%
  release("clerk") %&gt;%
  log_("finished")

simmer() %&gt;%
  add_resource("clerk", 1) %&gt;%
  add_generator("customer", bank, at(0, 1)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='reset'>Reset a Simulator</h2><span id='topic+reset'></span>

<h3>Description</h3>

<p>Reset the following components of a simulation environment:
time, event queue, resources, sources and statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset(.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepn">stepn</a></code>, <code><a href="#topic+run">run</a></code>.
</p>

<hr>
<h2 id='rollback'>Rollback to a Previous Activity</h2><span id='topic+rollback'></span>

<h3>Description</h3>

<p>Activity for going backwards to a previous point in the trajectory. Useful to
implement loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollback(.trj, target, times = Inf, check = NULL, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollback_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="rollback_+3A_target">target</code></td>
<td>
<p>tag name (previously set with the <code>tag</code> argument in any
activity) or amount of activities (of the same or parent trajectories) to
roll back (see examples).</p>
</td></tr>
<tr><td><code id="rollback_+3A_times">times</code></td>
<td>
<p>the number of repetitions until an arrival may continue.</p>
</td></tr>
<tr><td><code id="rollback_+3A_check">check</code></td>
<td>
<p>a callable object (a function) which must return a boolean. If
present, the <code>times</code> parameter is ignored, and the activity uses this
function to check whether the rollback must be done or not.</p>
</td></tr>
<tr><td><code id="rollback_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="rollback_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rollback a specific number of times
traj &lt;- trajectory() %&gt;%
  log_("hello!") %&gt;%
  timeout(1) %&gt;%
  rollback(2, 3)

simmer() %&gt;%
  add_generator("hello_sayer", traj, at(0)) %&gt;%
  run() %&gt;% invisible

## same but with a tag as target
traj &lt;- trajectory() %&gt;%
  log_("hello!", tag="msg") %&gt;%
  timeout(1) %&gt;%
  rollback("msg", 3)

simmer() %&gt;%
  add_generator("hello_sayer", traj, at(0)) %&gt;%
  run() %&gt;% invisible

## custom check
env &lt;- simmer()

traj &lt;- trajectory() %&gt;%
  set_attribute("var", 0) %&gt;%
  log_(tag="msg", function()
    paste("attribute level is at:", get_attribute(env, "var"))) %&gt;%
  set_attribute("var", 25, mod="+") %&gt;%
  rollback("msg", check=function() get_attribute(env, "var") &lt; 100) %&gt;%
  log_("done")

env %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='run'>Run a Simulation</h2><span id='topic+run'></span><span id='topic+stepn'></span>

<h3>Description</h3>

<p>Execute steps until a given criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(.env, until = Inf, progress = NULL, steps = 10)

stepn(.env, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
<tr><td><code id="run_+3A_until">until</code></td>
<td>
<p>stop time.</p>
</td></tr>
<tr><td><code id="run_+3A_progress">progress</code></td>
<td>
<p>optional callback to show the progress of the simulation. The
completed ratio is periodically passed as argument to the callback.</p>
</td></tr>
<tr><td><code id="run_+3A_steps">steps</code></td>
<td>
<p>number of steps to show as progress (it takes effect only if
<code>progress</code> is provided).</p>
</td></tr>
<tr><td><code id="run_+3A_n">n</code></td>
<td>
<p>number of events to simulate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the simulation environment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset">reset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show the progress just printing the steps
simmer() %&gt;%
  run(progress=message, steps=5)

## using the 'progress' package
## Not run: 
mm1 &lt;- trajectory() %&gt;%
  seize("server", 1) %&gt;%
  timeout(function() rexp(1, 66)) %&gt;%
  release("server", 1)

simmer() %&gt;%
  add_resource("server", 1) %&gt;%
  add_generator("customer", mm1, function() rexp(100, 60)) %&gt;%
  run(3000, progress=progress::progress_bar$new()$update)

## End(Not run)

</code></pre>

<hr>
<h2 id='schedule'>Generate a Scheduling Object</h2><span id='topic+schedule'></span>

<h3>Description</h3>

<p>Resource convenience function to generate a scheduling object from a
timetable specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schedule(timetable, values, period = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schedule_+3A_timetable">timetable</code></td>
<td>
<p>absolute points in time in which the desired value changes.</p>
</td></tr>
<tr><td><code id="schedule_+3A_values">values</code></td>
<td>
<p>one value for each point in time.</p>
</td></tr>
<tr><td><code id="schedule_+3A_period">period</code></td>
<td>
<p>period of repetition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>schedule</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_resource">add_resource</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Schedule 3 units from 8 to 16 h
#          2 units from 16 to 24 h
#          1 units from 24 to 8 h
capacity_schedule &lt;- schedule(c(8, 16, 24), c(3, 2, 1), period=24)

env &lt;- simmer() %&gt;%
  add_resource("dummy", capacity_schedule)

# Composition of schedules
sch1 &lt;- schedule(c(8, 16), c(3, 0), period=24)
sch2 &lt;- schedule(c(16, 24), c(2, 1), period=24)
all.equal(sch1 + sch2, capacity_schedule)

</code></pre>

<hr>
<h2 id='seize'>Seize/Release Resources</h2><span id='topic+seize'></span><span id='topic+seize_selected'></span><span id='topic+release'></span><span id='topic+release_selected'></span><span id='topic+release_all'></span><span id='topic+release_selected_all'></span>

<h3>Description</h3>

<p>Activities for seizing/releasing a resource, by name or a previously selected
one. Resources must be defined in the simulation environment (see
<code><a href="#topic+add_resource">add_resource</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seize(.trj, resource, amount = 1, continue = NULL, post.seize = NULL,
  reject = NULL, ..., tag)

seize_selected(.trj, amount = 1, id = 0, continue = NULL,
  post.seize = NULL, reject = NULL, ..., tag)

release(.trj, resource, amount = 1, ..., tag)

release_selected(.trj, amount = 1, id = 0, ..., tag)

release_all(.trj, resource, ..., tag)

release_selected_all(.trj, id = 0, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seize_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="seize_+3A_resource">resource</code></td>
<td>
<p>the name of the resource.</p>
</td></tr>
<tr><td><code id="seize_+3A_amount">amount</code></td>
<td>
<p>the amount to seize/release, accepts either a numeric or a
callable object (a function) which must return a numeric.</p>
</td></tr>
<tr><td><code id="seize_+3A_continue">continue</code></td>
<td>
<p>a boolean (if <code>post.seize</code> OR <code>reject</code> is defined)
or a pair of booleans (if <code>post.seize</code> AND <code>reject</code> are defined; if
only one value is provided, it will be recycled) to indicate whether these
subtrajectories should continue to the next activity in the main trajectory.</p>
</td></tr>
<tr><td><code id="seize_+3A_post.seize">post.seize</code></td>
<td>
<p>an optional trajectory object which will be followed after
a successful seize.</p>
</td></tr>
<tr><td><code id="seize_+3A_reject">reject</code></td>
<td>
<p>an optional trajectory object which will be followed if the
arrival is rejected (dropped).</p>
</td></tr>
<tr><td><code id="seize_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="seize_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="seize_+3A_id">id</code></td>
<td>
<p>selection identifier for nested usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rejection happens when a resource is at full capacity and there is
no room in the queue (either because there is a finite <code>queue_size</code> and
it is full, or because <code>queue_size=0</code> and thus it is disabled). In those
cases, the <code>reject</code> parameter defines a fallback trajectory. Note,
however, that, if the arrival is accepted (either in the queue or in the
server) and then it is dropped afterwards due to preemption or resource
shrinkage, then this trajectory will not be executed. Instead, see
<code><a href="#topic+handle_unfinished">handle_unfinished</a></code> for another, more general, method for
handling all kinds of unfinished arrivals.
</p>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>, <code><a href="#topic+set_capacity">set_capacity</a></code>, <code><a href="#topic+set_queue_size">set_queue_size</a></code>,
<code><a href="#topic+set_capacity_selected">set_capacity_selected</a></code>, <code><a href="#topic+set_queue_size_selected">set_queue_size_selected</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple seize, delay, then release
traj &lt;- trajectory() %&gt;%
  seize("doctor", 1) %&gt;%
  timeout(3) %&gt;%
  release("doctor", 1)

simmer() %&gt;%
  add_resource("doctor", capacity=1) %&gt;%
  add_generator("patient", traj, at(0, 1)) %&gt;%
  run() %&gt;%
  get_mon_resources()

## arrival rejection (no space left in the queue)
traj &lt;- trajectory() %&gt;%
  log_("arriving...") %&gt;%
  seize("doctor", 1) %&gt;%
  # the second patient won't reach this point
  log_("doctor seized") %&gt;%
  timeout(5) %&gt;%
  release("doctor", 1)

simmer() %&gt;%
  add_resource("doctor", capacity=1, queue_size=0) %&gt;%
  add_generator("patient", traj, at(0, 1)) %&gt;%
  run() %&gt;% invisible

## capturing rejection to retry
traj &lt;- trajectory() %&gt;%
  log_("arriving...") %&gt;%
  seize(
    "doctor", 1, continue = FALSE,
    reject = trajectory() %&gt;%
      log_("rejected!") %&gt;%
      # go for a walk and try again
      timeout(2) %&gt;%
      log_("retrying...") %&gt;%
      rollback(amount = 4, times = Inf)) %&gt;%
  # the second patient will reach this point after a couple of walks
  log_("doctor seized") %&gt;%
  timeout(5) %&gt;%
  release("doctor", 1) %&gt;%
  log_("leaving")

simmer() %&gt;%
  add_resource("doctor", capacity=1, queue_size=0) %&gt;%
  add_generator("patient", traj, at(0, 1)) %&gt;%
  run() %&gt;% invisible

## combining post.seize and reject
traj &lt;- trajectory() %&gt;%
  log_("arriving...") %&gt;%
  seize(
    "doctor", 1, continue = c(TRUE, TRUE),
    post.seize = trajectory("admitted patient") %&gt;%
      log_("admitted") %&gt;%
      timeout(5) %&gt;%
      release("doctor", 1),
    reject = trajectory("rejected patient") %&gt;%
      log_("rejected!") %&gt;%
      seize("nurse", 1) %&gt;%
      timeout(2) %&gt;%
      release("nurse", 1)) %&gt;%
  # both patients will reach this point, as continue = c(TRUE, TRUE)
  timeout(10) %&gt;%
  log_("leaving...")

simmer() %&gt;%
  add_resource("doctor", capacity=1, queue_size=0) %&gt;%
  add_resource("nurse", capacity=10, queue_size=0) %&gt;%
  add_generator("patient", traj, at(0, 1)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='select'>Select Resources</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Activity for selecting a resource for a subsequent seize/release or setting
its parameters (capacity or queue size). Resources must be defined in the
simulation environment (see <code><a href="#topic+add_resource">add_resource</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(.trj, resources, policy = c("shortest-queue",
  "shortest-queue-available", "round-robin", "round-robin-available",
  "first-available", "random", "random-available"), id = 0, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="select_+3A_resources">resources</code></td>
<td>
<p>one or more resource names, or a callable object (a function)
which must return one or more resource names.</p>
</td></tr>
<tr><td><code id="select_+3A_policy">policy</code></td>
<td>
<p>if <code>resources</code> is a character vector, this parameter
determines the criteria for selecting a resource among the set of policies
available (see details).</p>
</td></tr>
<tr><td><code id="select_+3A_id">id</code></td>
<td>
<p>selection identifier for nested usage.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="select_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'shortest-queue' policy selects the least busy resource;
'round-robin' selects resources in cyclical order; 'first-available' selects
the first resource available, and 'random' selects a resource randomly.
</p>
<p>All the 'available'-ending policies ('first-available', but also
'shortest-queue-available', 'round-robin-available' and 'random-available')
check for resource availability (i.e., whether the capacity is non-zero),
and exclude from the selection procedure those resources with capacity set
to zero. This means that, for these policies, an error will be raised if all
resources are unavailable.
</p>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seize_selected">seize_selected</a></code>, <code><a href="#topic+release_selected">release_selected</a></code>,
<code><a href="#topic+set_capacity_selected">set_capacity_selected</a></code>, <code><a href="#topic+set_queue_size_selected">set_queue_size_selected</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## predefined policy
traj &lt;- trajectory() %&gt;%
  select(paste0("doctor", 1:3), "round-robin") %&gt;%
  seize_selected(1) %&gt;%
  timeout(5) %&gt;%
  release_selected(1)

simmer() %&gt;%
  add_resource("doctor1") %&gt;%
  add_resource("doctor2") %&gt;%
  add_resource("doctor3") %&gt;%
  add_generator("patient", traj, at(0, 1, 2)) %&gt;%
  run() %&gt;%
  get_mon_resources()

## custom policy
env &lt;- simmer()
res &lt;- paste0("doctor", 1:3)

traj &lt;- trajectory() %&gt;%
  select(function() {
    occ &lt;- get_server_count(env, res) + get_queue_count(env, res)
    res[which.min(occ)[1]]
  }) %&gt;%
  seize_selected(1) %&gt;%
  timeout(5) %&gt;%
  release_selected(1)

for (i in res) env %&gt;%
  add_resource(i)
env %&gt;%
  add_generator("patient", traj, at(0, 1, 2)) %&gt;%
  run() %&gt;%
  get_mon_resources()

</code></pre>

<hr>
<h2 id='send'>Inter-arrival Communication</h2><span id='topic+send'></span><span id='topic+trap'></span><span id='topic+untrap'></span><span id='topic+wait'></span>

<h3>Description</h3>

<p>These activities enable asynchronous programming. <code>send()</code> broadcasts a
signal or a list of signals. Arrivals can subscribe to signals and (optionally)
assign a handler with <code>trap()</code>. Note that, while inside a batch, all the
signals subscribed before entering the batch are ignored. Upon a signal
reception, the arrival stops the current activity and executes the handler
(if provided). Then, the execution returns to the activity following the
point of the interruption. <code>untrap()</code> can be used to unsubscribe from
signals. <code>wait()</code> blocks until a signal is received.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send(.trj, signals, delay = 0, ..., tag)

trap(.trj, signals, handler = NULL, interruptible = TRUE, ..., tag)

untrap(.trj, signals, ..., tag)

wait(.trj, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="send_+3A_signals">signals</code></td>
<td>
<p>signal or list of signals, accepts either a string, a list of
strings or a callable object (a function) which must return a string or a
list of strings.</p>
</td></tr>
<tr><td><code id="send_+3A_delay">delay</code></td>
<td>
<p>optional timeout to trigger the signals, accepts either a
numeric or a callable object (a function) which must return a numeric.</p>
</td></tr>
<tr><td><code id="send_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="send_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="send_+3A_handler">handler</code></td>
<td>
<p>optional trajectory object to handle a signal received.</p>
</td></tr>
<tr><td><code id="send_+3A_interruptible">interruptible</code></td>
<td>
<p>whether the handler can be interrupted by signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renege_if">renege_if</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## block, signal and continue with a handler
signal &lt;- "you shall pass"

t_blocked &lt;- trajectory() %&gt;%
  trap(
    signal,
    trajectory() %&gt;%
      log_("executing the handler")) %&gt;%
  log_("waiting...") %&gt;%
  wait() %&gt;%
  log_("continuing!")

t_signaler &lt;- trajectory() %&gt;%
  log_(signal) %&gt;%
  send(signal)

simmer() %&gt;%
  add_generator("blocked", t_blocked, at(0)) %&gt;%
  add_generator("signaler", t_signaler, at(5)) %&gt;%
  run() %&gt;% invisible

## handlers can be interrupted, unless interruptible=FALSE
t_worker &lt;- trajectory() %&gt;%
  trap(
  signal,
  handler = trajectory() %&gt;%
    log_("ok, I'm packing...") %&gt;%
    timeout(1)) %&gt;%
  log_("performing a looong task...") %&gt;%
  timeout(100) %&gt;%
  log_("and I'm leaving!")

simmer() %&gt;%
  add_generator("worker", t_worker, at(0)) %&gt;%
  add_generator("signaler", t_signaler, at(5, 5.5)) %&gt;%
  run() %&gt;% invisible

</code></pre>

<hr>
<h2 id='set_attribute'>Set Attributes</h2><span id='topic+set_attribute'></span><span id='topic+set_global'></span>

<h3>Description</h3>

<p>Activity for modifying attributes. Attributes defined with
<code>set_attribute</code> are <em>per arrival</em>, meaning that each arrival has
its own set of attributes, not visible by any other one. On the other hand,
attributes defined with <code>set_global</code> are shared by all the arrivals in
the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_attribute(.trj, keys, values, mod = c(NA, "+", "*"), init = 0, ...,
  tag)

set_global(.trj, keys, values, mod = c(NA, "+", "*"), init = 0, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_attribute_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_keys">keys</code></td>
<td>
<p>the attribute name(s), or a callable object (a function) which
must return attribute name(s).</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_values">values</code></td>
<td>
<p>numeric value(s) to set, or a callable object (a function) which
must return numeric value(s).</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_mod">mod</code></td>
<td>
<p>if set, <code>values</code> modify the attributes rather than substituting them.</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_init">init</code></td>
<td>
<p>initial value, applied if <code>mod</code> is set and the attribute was
not previously initialised. Useful for counters or indexes.</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="set_attribute_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attribute monitoring is disabled by default. To enable it, set
<code>mon=2</code> in the corresponding source (see, e.g., <code><a href="#topic+add_generator">add_generator</a></code>).
Then, the evolution of the attributes during the simulation can be retrieved
with <code><a href="#topic+get_mon_attributes">get_mon_attributes</a></code>. Global attributes are reported as
unnamed key/value pairs.
</p>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_attribute">get_attribute</a></code>, <code><a href="#topic+get_global">get_global</a></code>,
<code><a href="#topic+timeout_from_attribute">timeout_from_attribute</a></code>, <code><a href="#topic+timeout_from_global">timeout_from_global</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- simmer()

traj &lt;- trajectory() %&gt;%

  # simple assignment
  set_attribute("my_key", 123) %&gt;%
  set_global("global_key", 321) %&gt;%

  # more than one assignment at once
  set_attribute(c("my_key", "other_key"), c(5, 64)) %&gt;%

  # increment
  set_attribute("my_key", 1, mod="+") %&gt;%

  # assignment using a function
  set_attribute("independent_key", function() runif(1)) %&gt;%

  # assignment dependent on another attribute
  set_attribute("dependent_key", function()
    ifelse(get_attribute(env, "my_key") &lt;= 0.5, 1, 0))

env %&gt;%
  add_generator("dummy", traj, at(3), mon=2) %&gt;%
  run() %&gt;%
  get_mon_attributes()

</code></pre>

<hr>
<h2 id='set_capacity'>Set Resource Parameters</h2><span id='topic+set_capacity'></span><span id='topic+set_capacity_selected'></span><span id='topic+set_queue_size'></span><span id='topic+set_queue_size_selected'></span>

<h3>Description</h3>

<p>Activities for dynamically modifying a resource's server capacity or queue
size, by name or a previously selected one. Resources must be defined in the
simulation environment (see <code><a href="#topic+add_resource">add_resource</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_capacity(.trj, resource, value, mod = c(NA, "+", "*"), ..., tag)

set_capacity_selected(.trj, value, id = 0, mod = c(NA, "+", "*"), ..., tag)

set_queue_size(.trj, resource, value, mod = c(NA, "+", "*"), ..., tag)

set_queue_size_selected(.trj, value, id = 0, mod = c(NA, "+", "*"), ...,
  tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_capacity_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_resource">resource</code></td>
<td>
<p>the name of the resource.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_value">value</code></td>
<td>
<p>numeric value to set, or a callable object (a function) which must return a numeric value.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_mod">mod</code></td>
<td>
<p>if set, <code>values</code> modify the attributes rather than substituting them.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="set_capacity_+3A_id">id</code></td>
<td>
<p>selection identifier for nested usage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select">select</a></code>, <code><a href="#topic+seize">seize</a></code>, <code><a href="#topic+release">release</a></code>,
<code><a href="#topic+seize_selected">seize_selected</a></code>, <code><a href="#topic+release_selected">release_selected</a></code>,
<code><a href="#topic+get_capacity">get_capacity</a></code>, <code><a href="#topic+get_queue_size">get_queue_size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a resource with a queue size equal to the number of arrivals waiting
traj &lt;- trajectory() %&gt;%
  set_queue_size("res", 1, mod="+") %&gt;%
  seize("res") %&gt;%
  set_queue_size("res", -1, mod="+") %&gt;%
  timeout(10) %&gt;%
  release("res")

simmer() %&gt;%
  add_resource("res", 1, 0) %&gt;%
  add_generator("dummy", traj, at(0:2)) %&gt;%
  run() %&gt;%
  get_mon_resources()

</code></pre>

<hr>
<h2 id='set_prioritization'>Set Prioritization Values</h2><span id='topic+set_prioritization'></span>

<h3>Description</h3>

<p>Activity for dynamically modifying an arrival's prioritization values.
Default prioritization values are defined by the source (see
<code><a href="#topic+add_generator">add_generator</a></code>, <code><a href="#topic+add_dataframe">add_dataframe</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prioritization(.trj, values, mod = c(NA, "+", "*"), ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prioritization_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="set_prioritization_+3A_values">values</code></td>
<td>
<p>expects either a vector/list or a callable object (a function)
returning a vector/list of three values <code>c(priority, preemptible, restart)</code>.
A negative value leaves the corresponding parameter unchanged.
See <code><a href="#topic+add_generator">add_generator</a></code> for more information about these parameters.</p>
</td></tr>
<tr><td><code id="set_prioritization_+3A_mod">mod</code></td>
<td>
<p>if set, <code>values</code> modify the attributes rather than substituting them.</p>
</td></tr>
<tr><td><code id="set_prioritization_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="set_prioritization_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_prioritization">get_prioritization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traj &lt;- trajectory() %&gt;%

  # static values
  set_prioritization(c(3, 7, TRUE)) %&gt;%

  # increment
  set_prioritization(c(2, 1, 0), mod="+") %&gt;%

  # dynamic, custom
  set_attribute("priority", 3) %&gt;%
  set_prioritization(function() {
    prio &lt;- get_prioritization(env)
    attr &lt;- get_attribute(env, "priority")
    c(attr, prio[[2]]+1, FALSE)
  })

</code></pre>

<hr>
<h2 id='set_trajectory'>Set Source Parameters</h2><span id='topic+set_trajectory'></span><span id='topic+set_source'></span>

<h3>Description</h3>

<p>Activities for modifying a source's trajectory or source object by name.
Sources must be defined in the simulation environment (see
<code><a href="#topic+add_generator">add_generator</a></code>, <code><a href="#topic+add_dataframe">add_dataframe</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_trajectory(.trj, sources, trajectory, ..., tag)

set_source(.trj, sources, object, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_trajectory_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="set_trajectory_+3A_sources">sources</code></td>
<td>
<p>the name(s) of the source(s) or a function returning the name(s).</p>
</td></tr>
<tr><td><code id="set_trajectory_+3A_trajectory">trajectory</code></td>
<td>
<p>the trajectory that the generated arrivals will follow.</p>
</td></tr>
<tr><td><code id="set_trajectory_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="set_trajectory_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="set_trajectory_+3A_object">object</code></td>
<td>
<p>a function modelling the interarrival times (if the source type
is a generator; returning a negative value or a missing value stops the
generator) or a data frame (if the source type is a data source).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activate">activate</a></code>, <code><a href="#topic+deactivate">deactivate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traj1 &lt;- trajectory() %&gt;%
  timeout(1)

traj2 &lt;- trajectory() %&gt;%
  set_source("dummy", function() 1) %&gt;%
  set_trajectory("dummy", traj1) %&gt;%
  timeout(2)

simmer() %&gt;%
  add_generator("dummy", traj2, function() 2) %&gt;%
  run(6) %&gt;%
  get_mon_arrivals()

</code></pre>

<hr>
<h2 id='simmer'>Create a Simulator</h2><span id='topic+simmer'></span>

<h3>Description</h3>

<p>This method initialises a simulation environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simmer(name = "anonymous", verbose = FALSE, mon = monitor_mem(),
  log_level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simmer_+3A_name">name</code></td>
<td>
<p>the name of the simulator.</p>
</td></tr>
<tr><td><code id="simmer_+3A_verbose">verbose</code></td>
<td>
<p>enable showing activity information.</p>
</td></tr>
<tr><td><code id="simmer_+3A_mon">mon</code></td>
<td>
<p>monitor (in memory by default); see <code><a href="#topic+monitor">monitor</a></code> for
other options.</p>
</td></tr>
<tr><td><code id="simmer_+3A_log_level">log_level</code></td>
<td>
<p>debugging level (see <code><a href="#topic+log_">log_</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a simulation environment.
</p>


<h3>See Also</h3>

<p>Available methods by category:
</p>

<ul>
<li><p> Simulation control: <code><a href="#topic+stepn">stepn</a></code>, <code><a href="#topic+run">run</a></code>,
<code><a href="#topic+now">now</a></code>, <code><a href="#topic+peek">peek</a></code>, <code><a href="#topic+reset">reset</a></code>
</p>
</li>
<li><p> Resources: <code><a href="#topic+add_resource">add_resource</a></code>, <code><a href="#topic+get_resources">get_resources</a></code>,
<code><a href="#topic+get_capacity">get_capacity</a></code>, <code><a href="#topic+get_capacity_selected">get_capacity_selected</a></code>,
<code><a href="#topic+get_queue_size">get_queue_size</a></code>, <code><a href="#topic+get_queue_size_selected">get_queue_size_selected</a></code>,
<code><a href="#topic+get_server_count">get_server_count</a></code>, <code><a href="#topic+get_server_count_selected">get_server_count_selected</a></code>,
<code><a href="#topic+get_queue_count">get_queue_count</a></code>, <code><a href="#topic+get_queue_count_selected">get_queue_count_selected</a></code>,
<code><a href="#topic+get_seized">get_seized</a></code>, <code><a href="#topic+get_seized_selected">get_seized_selected</a></code>,
<code><a href="#topic+get_activity_time">get_activity_time</a></code>, <code><a href="#topic+get_activity_time_selected">get_activity_time_selected</a></code>,
<code><a href="#topic+get_selected">get_selected</a></code>
</p>
</li>
<li><p> Sources: <code><a href="#topic+add_generator">add_generator</a></code>, <code><a href="#topic+add_dataframe">add_dataframe</a></code>,
<code><a href="#topic+get_sources">get_sources</a></code>, <code><a href="#topic+get_n_generated">get_n_generated</a></code>,
<code><a href="#topic+get_trajectory">get_trajectory</a></code>
</p>
</li>
<li><p> Arrivals: <code><a href="#topic+get_name">get_name</a></code>, <code><a href="#topic+get_attribute">get_attribute</a></code>,
<code><a href="#topic+get_prioritization">get_prioritization</a></code>, <code><a href="#topic+get_batch_size">get_batch_size</a></code>
</p>
</li>
<li><p> Globals: <code><a href="#topic+add_global">add_global</a></code>, <code><a href="#topic+get_global">get_global</a></code>
</p>
</li>
<li><p> Data retrieval: <code><a href="#topic+get_mon_arrivals">get_mon_arrivals</a></code>,
<code><a href="#topic+get_mon_attributes">get_mon_attributes</a></code>, <code><a href="#topic+get_mon_resources">get_mon_resources</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## a simple trajectory that prints a message
t0 &lt;- trajectory("my trajectory") %&gt;%
  log_("arrival generated")

## create an empty simulation environment
env &lt;- simmer("SuperDuperSim")
env

## add a generator and attach it to the trajectory above
env %&gt;% add_generator("dummy", t0, function() 1)

## run for some time
env %&gt;% run(until=4.5)
env %&gt;% now()           # current simulation time
env %&gt;% peek()          # time for the next event
env %&gt;% stepn()         # execute next event

</code></pre>

<hr>
<h2 id='timeout'>Delay</h2><span id='topic+timeout'></span><span id='topic+timeout_from_attribute'></span><span id='topic+timeout_from_global'></span>

<h3>Description</h3>

<p>Activity for inserting delays and execute user-defined tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeout(.trj, task, ..., tag)

timeout_from_attribute(.trj, key, ..., tag)

timeout_from_global(.trj, key, ..., tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeout_+3A_.trj">.trj</code></td>
<td>
<p>the trajectory object.</p>
</td></tr>
<tr><td><code id="timeout_+3A_task">task</code></td>
<td>
<p>the timeout duration supplied by either passing a numeric or a
callable object (a function) which must return a numeric (negative values are
automatically coerced to positive).</p>
</td></tr>
<tr><td><code id="timeout_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="timeout_+3A_tag">tag</code></td>
<td>
<p>activity tag name to perform named rollbacks (see
<code><a href="#topic+rollback">rollback</a></code>) or just to better identify your activities.</p>
</td></tr>
<tr><td><code id="timeout_+3A_key">key</code></td>
<td>
<p>the attribute name, or a callable object (a function) which
must return the attribute name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the trajectory object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_attribute">set_attribute</a></code>, <code><a href="#topic+set_global">set_global</a></code>
</p>
<p><code><a href="#topic+set_attribute">set_attribute</a></code>, <code><a href="#topic+set_global">set_global</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env &lt;- simmer()

traj &lt;- trajectory() %&gt;%

  # static delay
  timeout(3) %&gt;%

  # dynamic, exponential delay
  timeout(function() rexp(1, 10)) %&gt;%

  # dependent on an attribute
  set_attribute("delay", 2) %&gt;%
  set_global("other", function() rexp(1, 2)) %&gt;%
  timeout_from_attribute("delay") %&gt;%
  timeout_from_global("other")

env %&gt;%
  add_generator("dummy", traj, at(0)) %&gt;%
  run() %&gt;%
  get_mon_arrivals()

</code></pre>

<hr>
<h2 id='trajectory'>Create a Trajectory</h2><span id='topic+trajectory'></span>

<h3>Description</h3>

<p>This method initialises a trajectory object, which comprises a chain of
activities that can be attached to a generator. See below for a complete list
of available activities by category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectory(name = "anonymous", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory_+3A_name">name</code></td>
<td>
<p>the name of the trajectory.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_verbose">verbose</code></td>
<td>
<p>enable showing additional information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an environment that represents the trajectory.
</p>


<h3>See Also</h3>

<p>Available activities by category:
</p>

<ul>
<li><p> Debugging: <code><a href="#topic+log_">log_</a></code>, <code><a href="#topic+stop_if">stop_if</a></code>
</p>
</li>
<li><p> Delays: <code><a href="#topic+timeout">timeout</a></code>, <code><a href="#topic+timeout_from_attribute">timeout_from_attribute</a></code>,
<code><a href="#topic+timeout_from_global">timeout_from_global</a></code>
</p>
</li>
<li><p> Arrival properties: <code><a href="#topic+set_attribute">set_attribute</a></code>, <code><a href="#topic+set_global">set_global</a></code>,
<code><a href="#topic+set_prioritization">set_prioritization</a></code>
</p>
</li>
<li><p> Interaction with resources: <code><a href="#topic+select">select</a></code>, <code><a href="#topic+seize">seize</a></code>,
<code><a href="#topic+release">release</a></code>, <code><a href="#topic+release_all">release_all</a></code>, <code><a href="#topic+seize_selected">seize_selected</a></code>,
<code><a href="#topic+release_selected">release_selected</a></code>, <code><a href="#topic+release_selected_all">release_selected_all</a></code>,
<code><a href="#topic+set_capacity">set_capacity</a></code>, <code><a href="#topic+set_queue_size">set_queue_size</a></code>,
<code><a href="#topic+set_capacity_selected">set_capacity_selected</a></code>, <code><a href="#topic+set_queue_size_selected">set_queue_size_selected</a></code>
</p>
</li>
<li><p> Interaction with generators: <code><a href="#topic+activate">activate</a></code>, <code><a href="#topic+deactivate">deactivate</a></code>,
<code><a href="#topic+set_trajectory">set_trajectory</a></code>, <code><a href="#topic+set_source">set_source</a></code>
</p>
</li>
<li><p> Branching: <code><a href="#topic+branch">branch</a></code>, <code><a href="#topic+clone">clone</a></code>, <code><a href="#topic+synchronize">synchronize</a></code>
</p>
</li>
<li><p> Loops: <code><a href="#topic+rollback">rollback</a></code>
</p>
</li>
<li><p> Batching: <code><a href="#topic+batch">batch</a></code>, <code><a href="#topic+separate">separate</a></code>
</p>
</li>
<li><p> Asynchronous programming: <code><a href="#topic+send">send</a></code>, <code><a href="#topic+trap">trap</a></code>,
<code><a href="#topic+untrap">untrap</a></code>, <code><a href="#topic+wait">wait</a></code>
</p>
</li>
<li><p> Reneging: <code><a href="#topic+leave">leave</a></code>, <code><a href="#topic+handle_unfinished">handle_unfinished</a></code>,
<code><a href="#topic+renege_in">renege_in</a></code>, <code><a href="#topic+renege_if">renege_if</a></code>, <code><a href="#topic+renege_abort">renege_abort</a></code>
</p>
</li></ul>

<p>Manage trajectories:
</p>

<ul>
<li><p> Extract or Replace Parts of a Trajectory: <code><a href="#topic+Extract.trajectory">Extract.trajectory</a></code>
</p>
</li>
<li><p> Join Trajectories: <code><a href="#topic+join">join</a></code>
</p>
</li>
<li><p> Number of Activities in a Trajectory: <code><a href="#topic+length.trajectory">length.trajectory</a></code>,
<code><a href="#topic+get_n_activities">get_n_activities</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## create an empty trajectory
x &lt;- trajectory("my trajectory")
x

## add some activities by chaining them
x &lt;- x %&gt;%
  log_("here I am!") %&gt;%
  timeout(5) %&gt;%
  log_("leaving!")
x

## join trajectories
x &lt;- join(x, x)

## extract and replace
x[c(3, 4)] &lt;- x[2]
x

</code></pre>

<hr>
<h2 id='wrap'>Wrap a Simulation Environment</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>This function extracts the monitored data from a simulation environment
making it accessible through the same methods. Only useful if you want
to parallelize heavy replicas (see the example below), because the C++
simulation backend is destroyed when the threads exit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_.env">.env</code></td>
<td>
<p>the simulation environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a simulation wrapper.
</p>


<h3>See Also</h3>

<p>Methods for dealing with a simulation wrapper:
<code><a href="#topic+get_mon_arrivals">get_mon_arrivals</a></code>, <code><a href="#topic+get_mon_attributes">get_mon_attributes</a></code>,
<code><a href="#topic+get_mon_resources">get_mon_resources</a></code>, <code><a href="#topic+get_n_generated">get_n_generated</a></code>,
<code><a href="#topic+get_capacity">get_capacity</a></code>, <code><a href="#topic+get_queue_size">get_queue_size</a></code>,
<code><a href="#topic+get_server_count">get_server_count</a></code>, <code><a href="#topic+get_queue_count">get_queue_count</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(parallel)

mm1 &lt;- trajectory() %&gt;%
  seize("server", 1) %&gt;%
  timeout(function() rexp(1, 2)) %&gt;%
  release("server", 1)

envs &lt;- mclapply(1:4, function(i) {
  simmer("M/M/1 example") %&gt;%
    add_resource("server", 1) %&gt;%
    add_generator("customer", mm1, function() rexp(1, 1)) %&gt;%
    run(100) %&gt;%
    wrap()
})

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
