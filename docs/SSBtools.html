<!DOCTYPE html><html lang="en"><head><title>Help for package SSBtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SSBtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddLeadingZeros'><p>Add leading zeros to numbers while preserving other text</p></a></li>
<li><a href='#aggregate_by_pkg'><p>Aggregate by base R or data.table</p></a></li>
<li><a href='#aggregate_multiple_fun'><p>Wrapper to <code>aggregate</code></p></a></li>
<li><a href='#As_TsparseMatrix'><p>Transform to TsparseMatrix/dgTMatrix</p></a></li>
<li><a href='#AutoHierarchies'><p>Ensure standardized coding of hierarchies</p></a></li>
<li><a href='#AutoSplit'><p>Creating variables by splitting the elements of a character vector</p>
without needing a split string</a></li>
<li><a href='#CbindIdMatch'><p>Combine several data frames by using id variables to match rows</p></a></li>
<li><a href='#CharacterDataFrame'><p>CharacterDataFrame</p></a></li>
<li><a href='#CheckInput'><p>Checking function inputs</p></a></li>
<li><a href='#combine_formulas'><p>Combine formulas</p></a></li>
<li><a href='#CrossCodeFrames'><p>Cross codes in data frames</p></a></li>
<li><a href='#crossMerge'><p>crossMerge</p></a></li>
<li><a href='#DataDummyHierarchy'><p>Create a (signed) dummy matrix for hierarcical mapping of codes in data</p></a></li>
<li><a href='#DataFrameToMatrix'><p>DataFrameToMatrix</p></a></li>
<li><a href='#DimList2Hierarchy'><p>DimList2Hierarchy</p></a></li>
<li><a href='#DimList2Hrc'><p>DimList2Hrc/Hrc2DimList</p></a></li>
<li><a href='#dummy_aggregate'><p><code>aggregate_multiple_fun</code> using a dummy matrix</p></a></li>
<li><a href='#DummyApply'><p>Apply a function to subsets defined by a dummy matrix</p></a></li>
<li><a href='#DummyDuplicated'><p>Duplicated columns in dummy matrix</p></a></li>
<li><a href='#DummyHierarchy'><p>Converting hierarchy specifications to a (signed) dummy matrix</p></a></li>
<li><a href='#Extend0'><p>Add zero frequency rows</p></a></li>
<li><a href='#Extend0fromModelMatrixInput'><p>A specialized version of Extend0()</p></a></li>
<li><a href='#Extend0rnd1'><p>varGroups-attribute to Extend0, Example functions</p></a></li>
<li><a href='#FactorLevCorr'><p>Factor level correlation</p></a></li>
<li><a href='#filter_by_variable'><p>Filter a List of Items or Retrieve Names by a Variable</p></a></li>
<li><a href='#FindCommonCells'><p>Finding commonCells</p></a></li>
<li><a href='#FindDimLists'><p>Finding dimList</p></a></li>
<li><a href='#FindDisclosiveCells'><p>Find directly disclosive cells</p></a></li>
<li><a href='#FindHierarchies'><p>Finding hierarchies automatically from data</p></a></li>
<li><a href='#FindTableGroup'><p>Finding table(s) of hierarchical variable groups</p></a></li>
<li><a href='#fix_fun_amf'><p>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code></p></a></li>
<li><a href='#fix_vars_amf'><p>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code></p></a></li>
<li><a href='#ForceCharacterDataFrame'><p>ForceCharacterDataFrame</p></a></li>
<li><a href='#ForceFactorDataFrame'><p>ForceFactorDataFrame</p></a></li>
<li><a href='#formula_from_vars'><p>Generate model formula by specifying which variables have totals or not.</p></a></li>
<li><a href='#formula_utils'><p>Functions for formula manipulation</p></a></li>
<li><a href='#FormulaSelection.default'><p>Limit matrix or data frame to selected model terms</p></a></li>
<li><a href='#FormulaSums'><p>Sums (aggregates) and/or sparse model matrix with possible cross table</p></a></li>
<li><a href='#GaussIndependent'><p>Linearly independent rows and columns by Gaussian elimination</p></a></li>
<li><a href='#GaussIterationFunction'><p>An <code>iFunction</code> argument to <code>GaussSuppression</code></p></a></li>
<li><a href='#GaussSuppression'><p>Secondary suppression by Gaussian elimination</p></a></li>
<li><a href='#HierarchicalGroups'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalGroups2'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalGroups3'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalWildcardGlobbing'><p>Find variable combinations by advanced wildcard/globbing specifications.</p></a></li>
<li><a href='#hierarchies_as_vars'><p>Hierarchies coded as variables</p></a></li>
<li><a href='#Hierarchies2ModelMatrix'><p>Model matrix representing crossed hierarchies</p></a></li>
<li><a href='#HierarchiesAndFormula2ModelMatrix'><p>Model matrix representing crossed hierarchies according to a formula</p></a></li>
<li><a href='#Hierarchy2Formula'><p>Hierarchy2Formula</p></a></li>
<li><a href='#HierarchyCompute'><p>Hierarchical Computations</p></a></li>
<li><a href='#HierarchyCompute2'><p>Extended Hierarchical Computations</p></a></li>
<li><a href='#HierarchyComputeDummy'><p>HierarchyComputeDummy</p></a></li>
<li><a href='#HierarchyFix'><p>Change the hierarchy table to follow the standard</p></a></li>
<li><a href='#inc_default'><p>Default progress indicator function</p></a></li>
<li><a href='#LSfitNonNeg'><p>Non-negative regression fits with a sparse overparameterized model matrix</p></a></li>
<li><a href='#MakeFreq'><p>Microdata frequency data conversion</p></a></li>
<li><a href='#MakeHierFormula'><p>Make model formula from data taking into account hierarchical variables</p></a></li>
<li><a href='#map_hierarchies_to_data'><p>Add variables to dataset based on hierarchies</p></a></li>
<li><a href='#Match'><p>Matching rows in data frames</p></a></li>
<li><a href='#matlabColon'><p>Simulate Matlab's ':'</p></a></li>
<li><a href='#Matrix2list'><p>Convert matrix to sparse list</p></a></li>
<li><a href='#MatrixPaste'><p>Combining columns of a matrix</p></a></li>
<li><a href='#MatrixToDataFrame'><p>MatrixToDataFrame</p></a></li>
<li><a href='#max_contribution'><p>Find Major Contributions to Aggregates and Count Contributors</p></a></li>
<li><a href='#Mipf'><p>Iterative proportional fitting from matrix input</p></a></li>
<li><a href='#model_aggregate'><p>Hierarchical aggregation via model specification</p></a></li>
<li><a href='#Model_Matrix'><p>Overparameterized model matrix</p></a></li>
<li><a href='#ModelMatrix'><p>Model matrix from hierarchies and/or a formula</p></a></li>
<li><a href='#Number'><p>Adding leading zeros</p></a></li>
<li><a href='#NumSingleton'><p>Decoding of <code>singletonMethod</code></p></a></li>
<li><a href='#quantile_weighted'><p>Weighted quantiles</p></a></li>
<li><a href='#RbindAll'><p>Combining several data frames when the columns don't match</p></a></li>
<li><a href='#Reduce0exact'><p>Reducing a non-negative regression problem</p></a></li>
<li><a href='#RoundWhole'><p>Round values that are close two whole numbers</p></a></li>
<li><a href='#RowGroups'><p>Create numbering according to unique rows</p></a></li>
<li><a href='#SortRows'><p>Sorting rows of a matrix or data frame</p></a></li>
<li><a href='#sosialFiktiv'><p>Fictitious datasets returned by SSBtoolsData()</p></a></li>
<li><a href='#SSBtoolsData'><p>Function that returns a dataset</p></a></li>
<li><a href='#Stack'><p>Stack columns from a data frame and include variables.</p></a></li>
<li><a href='#substitute_formula_vars'><p>Replace variables in formula with sum of other variables</p></a></li>
<li><a href='#table_all_integers'><p>Table all integers from 1 to n</p></a></li>
<li><a href='#tables_by_formulas'><p>Tabular Statistics Based on Formulas</p></a></li>
<li><a href='#total_collapse'><p>Collapse variables to single representation</p></a></li>
<li><a href='#UniqueSeq'><p>Sequence within unique values</p></a></li>
<li><a href='#unmatrix'><p>Transform data frame with embedded matrices</p></a></li>
<li><a href='#Unstack'><p>Unstack a column from a data frame and include additional variables.</p></a></li>
<li><a href='#vars_to_hierarchies'><p>Transform hierarchies coded as Variables to &quot;to-from&quot; format</p></a></li>
<li><a href='#WildcardGlobbing'><p>Row selection by wildcard/globbing</p></a></li>
<li><a href='#WildcardGlobbingVector'><p>Selection of elements by wildcard/globbing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms and Tools for Tabular Statistics and Hierarchical
Computations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-14</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, MASS, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes general data manipulation functions, algorithms for statistical disclosure control (Langsrud, 2024) &lt;<a href="https://doi.org/10.1007%2F978-3-031-69651-0_6">doi:10.1007/978-3-031-69651-0_6</a>&gt; and functions for hierarchical computations by sparse model matrices (Langsrud, 2023) &lt;<a href="https://doi.org/10.32614%2FRJ-2023-088">doi:10.32614/RJ-2023-088</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statisticsnorway/ssb-ssbtools">https://github.com/statisticsnorway/ssb-ssbtools</a>,
<a href="https://statisticsnorway.github.io/ssb-ssbtools/">https://statisticsnorway.github.io/ssb-ssbtools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statisticsnorway/ssb-ssbtools/issues">https://github.com/statisticsnorway/ssb-ssbtools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, data.table</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 04:59:06 UTC; oyl</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud <a href="https://orcid.org/0000-0002-1380-4396"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Daniel Lupp <a href="https://orcid.org/0000-0003-3575-1691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bjørn-Helge Mevik [ctb],
  Vidar Norstein Klungre
    <a href="https://orcid.org/0000-0003-1925-5911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Statistics Norway [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddLeadingZeros'>Add leading zeros to numbers while preserving other text</h2><span id='topic+AddLeadingZeros'></span>

<h3>Description</h3>

<p>This function is created to fix problems caused by a serious bug in Excel.
Editing csv files in that program causes leading zeros to disappear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddLeadingZeros(
  codes,
  places,
  warningText = NULL,
  viaFactor = TRUE,
  nWarning = 6,
  removeLeadingTrailingWhitespace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddLeadingZeros_+3A_codes">codes</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_places">places</code></td>
<td>
<p>Number of places for positive numbers. Minus sign is extra</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_warningtext">warningText</code></td>
<td>
<p>When non-NULL, warning will be produced</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_viafactor">viaFactor</code></td>
<td>
<p>When TRUE, the algorithm uses factor coding internally.</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_nwarning">nWarning</code></td>
<td>
<p>Number of elements to be written before ... in warnings.</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_removeleadingtrailingwhitespace">removeLeadingTrailingWhitespace</code></td>
<td>
<p>Remove leading and trailing whitespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 10)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, removeLeadingTrailingWhitespace = FALSE)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, warningText = "string changes")
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, warningText = "", nWarning = 2)
</code></pre>

<hr>
<h2 id='aggregate_by_pkg'>Aggregate by base R or data.table</h2><span id='topic+aggregate_by_pkg'></span>

<h3>Description</h3>

<p>This function aggregates data by specified grouping variables, using either base R or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_by_pkg(
  data,
  by,
  var,
  pkg = "base",
  include_na = FALSE,
  fun = sum,
  base_order = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_by_pkg_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_by">by</code></td>
<td>
<p>A character vector specifying the column names to group by.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_var">var</code></td>
<td>
<p>A character vector specifying the column names of the variables to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_pkg">pkg</code></td>
<td>
<p>A character string indicating which package to use for aggregation.
Must be either <code>"base"</code> for base R or <code>"data.table"</code> for <code>data.table</code>. Default is <code>"base"</code>.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_include_na">include_na</code></td>
<td>
<p>A logical value indicating whether <code>NA</code> values in the grouping variables should be included in the aggregation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_fun">fun</code></td>
<td>
<p>The function to be applied for aggregation. Default is <code>sum</code>.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_base_order">base_order</code></td>
<td>
<p>A logical value indicating whether to attempt to return the results in the same order as base R when using <code>data.table</code>.
Note that while the function strives to maintain this order, it cannot be guaranteed due to potential variations in
sorting behavior across different systems. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aggregate_by_pkg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+aggregate">aggregate</a></code> when <code>pkg</code> is <code>"base"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the aggregated results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- SSBtoolsData("d2")[1:20, ]
d[[2]] &lt;- as.numeric(d[[2]])
d$y &lt;- as.numeric(1:20)
d$y[2] &lt;- NA
d$county[8:9] &lt;- NA
d$main_income[11:12] &lt;- NA
d$k_group[19:20] &lt;- NA
by &lt;- c("main_income", "county", "k_group")

a1 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"))
a2 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"), 
                       include_na = TRUE)
a3 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"), 
                       include_na = TRUE, fun = function(x) list(x))
 
if (requireNamespace("data.table", quietly = TRUE)) {  
                       
  b1 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"), pkg = "data.table")
  b2 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"), pkg = "data.table", 
                         include_na = TRUE)
  b3 &lt;- aggregate_by_pkg(d, by = by, var = c("y", "freq"), pkg = "data.table", 
                         include_na = TRUE, fun = function(x) list(x))                        
                       
  print(identical(a1, b1))   # TRUE when base_order succeeds
  print(identical(a2, b2))
  print(identical(a3, b3))
  
}  else {
   print("The 'data.table' package is not installed.")
}
                        
</code></pre>

<hr>
<h2 id='aggregate_multiple_fun'>Wrapper to <code>aggregate</code></h2><span id='topic+aggregate_multiple_fun'></span>

<h3>Description</h3>

<p>Wrapper to <code><a href="stats.html#topic+aggregate">aggregate</a></code> that allows multiple functions and functions of several variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_multiple_fun(
  data,
  by,
  vars,
  fun = NULL,
  ind = NULL,
  ...,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  forward_dots = FALSE,
  dots2dots = FALSE,
  do_unmatrix = TRUE,
  do_unlist = TRUE,
  inc_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_multiple_fun_+3A_data">data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_by">by</code></td>
<td>
<p>A data frame defining grouping</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_vars">vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li><p> Parameter <code>vars</code> will converted to an internal standard by the function <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>. Indices instead of variable names are allowed.
</p>
</li>
<li><p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li><p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_fun">fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code><a href="#topic+fix_fun_amf">fix_fun_amf</a></code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_ind">ind</code></td>
<td>
<p>When non-NULL, a data frame of indices.
When NULL, this variable will be generated internally as <code>data.frame(ind = seq_len(nrow(data)))</code>.
The parameter is useful for advanced use involving model/dummy matrices.
For special use (<code>dummy = FALSE</code> in <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>) <code>ind</code> can also be a two-column data frame.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>aggregate</code> and,
depending on <code>forward_dots</code>/<code>dots2dots</code>, forwarded to the functions in <code>fun</code> (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_name_sep">name_sep</code></td>
<td>
<p>A character string used when output variable names are generated.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_seve_sep">seve_sep</code></td>
<td>
<p>A character string used when output variable names are generated from functions of several variables.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_multi_sep">multi_sep</code></td>
<td>
<p>A character string used when multiple output variable names are sent as input.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_forward_dots">forward_dots</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of <code>fun</code> that determines whether <code>...</code> should be forwarded (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_dots2dots">dots2dots</code></td>
<td>
<p>Logical vector (possibly recycled) specifying the behavior when <code>forward_dots = TRUE</code> (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_do_unmatrix">do_unmatrix</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code><a href="#topic+unmatrix">unmatrix</a></code> before returning output.
For special use this can be omitted (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_do_unlist">do_unlist</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code><a href="base.html#topic+unlist">unlist</a></code> to combine output from multiple functions.
For special use this can be omitted (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_inc_progress">inc_progress</code></td>
<td>
<p>logigal, <code>NULL</code> (same as <code>FALSE</code>) or a  progress indicator function taking two parameters (i and n).
<code>TRUE</code> means the same as <code><a href="#topic+inc_default">inc_default</a></code>. Note that this feature is implemented in a
hacky manner as internal/hidden variables are grabbed from <code><a href="stats.html#topic+aggregate">aggregate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One intention of <code>aggregate_multiple_fun</code> is to be a true generalization of <code>aggregate</code>.
However, when many functions are involved, passing extra parameters can easily lead to errors.
Therefore <code>forward_dots</code> and <code>dots2dots</code> are set to <code>FALSE</code> by default.
When <code>forward_dots = TRUE</code> and <code>dots2dots = FALSE</code>, parameters will be forwarded,
but only parameters that are explicitly defined in the specific <code>fun</code> function.
For the <code>sum</code> function, this means that a possible <code>na.rm</code> parameter is forwarded but not others.
When <code>forward_dots = TRUE</code> and <code>dots2dots = TRUE</code>, other parameters will also be forwarded to <code>fun</code> functions where <code>...</code> is included.
For the <code>sum</code> function, this means that such extra parameters will, probably erroneously, be included in the summation (see examples).
</p>
<p>For the function to work with <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>,
the data is subject to <code><a href="base.html#topic+unlist">unlist</a></code> before the <code>fun</code> functions are called.
This does not apply in the special case where <code>ind</code> is a two-column data frame.
Then, in the case of list data, the <code>fun</code> functions have to handle this themselves.
</p>
<p>A limitation when default output, when <code>do_unlist = TRUE</code>, is that variables in output are forced to have the same class.
This is caused by the <code><a href="base.html#topic+unlist">unlist</a></code> function being run on the output. This means, for example,
that all the variables will become numeric when they should have been both integer and numeric.
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c("freq", "y", median = "freq", median = "y", e1 = "freq"),
   fun = c(sum, median = median, e1 = function(x) x[1])  
)

# With functions as named strings 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", med = "freq", med = "y"),
   fun = c(sum = "sum", med = "median")
)

# Without specifying functions 
# - equivalent to `fun = c("sum", "median")` 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", median = "freq", median = "y")
)

# The single unnamed variable feature. Also functions as strings. 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = "y",
   fun = c("sum", "median", "min", "max")
) 

# with multiple outputs (function my_range)
# and with function of two variables (weighted.mean(y, freq))
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", ra = "freq", wmean  = c("y", "freq")),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)


# To illustrate forward_dots and dots2dots
q &lt;- d[1, ]
q$w &lt;- 100 * rnorm(1)
for (dots2dots in c(FALSE, TRUE)) for (forward_dots in c(FALSE, TRUE)) {
  cat("\n=======================================\n")
  cat("forward_dots =", forward_dots, ", dots2dots =", dots2dots)
  out &lt;- aggregate_multiple_fun(
    data = q, by = q["k_group"], 
    vars = c(sum = "freq", round = "w"), fun = c("sum", "round"),  
    digits = 3, forward_dots = forward_dots, dots2dots = dots2dots)
  cat("\n")
  print(out)
}
# In last case digits forwarded to sum (as ...) 
# and wrongly included in the summation
 
</code></pre>

<hr>
<h2 id='As_TsparseMatrix'>Transform to TsparseMatrix/dgTMatrix</h2><span id='topic+As_TsparseMatrix'></span>

<h3>Description</h3>

<p>To implement adaption needed after Matrix ver. 1.4-2 since
<code>as(from, "dgTMatrix")</code> no longer allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>As_TsparseMatrix(from, do_drop0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="As_TsparseMatrix_+3A_from">from</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="As_TsparseMatrix_+3A_do_drop0">do_drop0</code></td>
<td>
<p>whether to run <code>drop0</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is made to replace <code>as(from, "dgTMatrix")</code> and <code>as(drop0(from), "dgTMatrix")</code> in <code>SSBtools</code> and related packages.
</p>


<h3>Value</h3>

<p>A matrix. Virtual class is <code>TsparseMatrix</code>. Class <code>dgTMatrix</code> expected.
</p>


<h3>Note</h3>

<p><code>Matrix:::.as.via.virtual</code> in development version of package <code>Matrix</code> (date 2022-08-13) used to generate code.
</p>

<hr>
<h2 id='AutoHierarchies'>Ensure standardized coding of hierarchies</h2><span id='topic+AutoHierarchies'></span>

<h3>Description</h3>

<p>Automatic convert list of hierarchies coded in different ways to standardized to-from coding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoHierarchies(
  hierarchies,
  data = NULL,
  total = "Total",
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  combineHierarchies = TRUE,
  unionComplement = FALSE,
  autoLevel = TRUE,
  autoNames = c(to = "from", parentCode = "code", parent = "child", root = "leaf"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoHierarchies_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_total">total</code></td>
<td>
<p>Within <code>AutoHierarchies</code>: Vector of total codes (possibly recycled) used when running <code><a href="#topic+Hrc2DimList">Hrc2DimList</a></code> or <code><a href="#topic+FindDimLists">FindDimLists</a></code>.</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>. However:
</p>

<ul>
<li> <p><code>level</code> is by default not required (see <code>autoLevel</code> below).
</p>
</li>
<li><p> If the <code>sign</code> variable is missing, it defaults to a variable of 1s.
</p>
</li>
<li><p> Common 'from-to' variable names are recognized (see <code>autoNames</code> below).
</p>
</li></ul>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_combinehierarchies">combineHierarchies</code></td>
<td>
<p>Whether to combine several hierarchies for same variable into a single hierarchy (see examples).</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector as in <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>. The parameter is only in use when hierarchies are combined.</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_autolevel">autoLevel</code></td>
<td>
<p>When TRUE (default), the level is computed automatically, ignoring the input level variable.
This parameter is passed to <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>..</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_autonames">autoNames</code></td>
<td>
<p>Named character vector of 'from-to' variable names to be automatically recognized.
These names do not need to be specified in <code>hierarchyVarNames</code>.
Thus, <code>autoNames</code> can serve as an alternative to <code>hierarchyVarNames</code>.</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input can be to-from coded hierarchies, hierarchies/dimList as in sdcTable, TauArgus coded hierarchies or formulas.
Automatic coding from data is also supported. Output is on a from ready for input to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>.
A single string as hierarchy input is assumed to be a total code.
Then, the hierarchy is created as a simple hierarchy where all codes in data sum up to this total.
For consistence with <code>HierarchyCompute</code>,
the codes <code>"rowFactor"</code> and <code>"colFactor"</code> are unchanged.
An empty string is recoded to  <code>"rowFactor"</code>.
</p>
<p>A special possibility is to include character vector(s) as unnamed list element(s) of <code>hierarchies</code>.
Then the elements of the character vector(s) must be variable names within data.
This will cause hierarchies to be created from selected data columns by running <code><a href="#topic+FindDimLists">FindDimLists</a></code>.
Total coded can be specified by parameter <code>total</code> or by naming the character vector. See examples.
</p>


<h3>Value</h3>

<p>List of hierarchies
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FindHierarchies">FindHierarchies</a></code>, <code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>,
<code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+DummyHierarchies">DummyHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, create different types of input
z &lt;- SSBtoolsData("sprt_emp_withEU")
yearFormula &lt;- c("y_14 = 2014", "y_15_16 = y_all - y_14", "y_all = 2014 + 2015 + 2016")
yearHier &lt;- Formula2Hierarchy(yearFormula)
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]
geoDimList2 &lt;- FindDimLists(z[, c("geo", "eu")])[[1]]
geoHrc &lt;- DimList2Hrc(geoDimList)
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

h1 &lt;- AutoHierarchies(list(age = ageHier, geo = geoDimList, year = yearFormula))
h2 &lt;- AutoHierarchies(list(age = "Y15-64", geo = geoHrc, year = yearHier), data = z, 
                      total = "Europe")
h3 &lt;- AutoHierarchies(list(age = "Total", geo = geoDimList2, year = "Total"), data = z)
h4 &lt;- FindHierarchies(z[, c(1, 2, 3, 5)])
h5 &lt;- AutoHierarchies(list(age = "Total", geo = "", year = "colFactor"), data = z)
identical(h1, h2)
identical(h3, h4)

# Print the resulting hierarchies
h1 # = h2
h3 # = h4
h5

FindHierarchies(z[, c("geo", "eu", "age")])


# ===================================================================== 
#   Examples illustrating the combineHierarchies parameter
# =====================================================================

# First, create data
d &lt;- SSBtoolsData("d2ws")[1:3]
d$isCounty1 &lt;- "NO"
d$isCounty1[d$county == "county-1"] &lt;- "YES"
d

# sdcTable coding showing two tree-shaped hierarchies
dimList &lt;- FindDimLists(d)
dimList

# Two tree-shaped hierarchies can still be seen 
# Hierarchies with three and two levels
hA &lt;- AutoHierarchies(dimList, combineHierarchies = FALSE)
hA

# A single hierarchy with only one level 
# Contains the information needed to create a dummy matrix
hB &lt;- AutoHierarchies(dimList)
hB

# Dummy matrices from the hierarchies
DummyHierarchies(hA)
DummyHierarchies(hB)


# ===================================================================== 
#   Special examples with character vector(s) as unnamed list elements
# =====================================================================

# Same output as FindHierarchies above
AutoHierarchies(list(c("geo", "eu", "age")), data = z)

# Now combined with a named list element 
AutoHierarchies(list(year = yearHier, c("geo", "eu", "age")), data = z)

# Total codes by unnamed list element as named character vector 
AutoHierarchies(list(year = yearHier, c(Europe = "geo", "eu", All = "age")), data = z)

# Two types of year input. Total codes by using the parameter `total`. 
AutoHierarchies(list("year", year = yearHier, c("geo", "eu", "age")), data = z, 
                total = c("allYears", "unused", "Tot"))

# Avoid combineHierarchies to see effect of each year input separately 
# (even earlier return possible with `combineHierarchies = NA`)
AutoHierarchies(list("year", year = yearHier, c("geo", "eu", "age")), data = z, 
                total = c("allYears", "unused", "Tot"), combineHierarchies = FALSE)

</code></pre>

<hr>
<h2 id='AutoSplit'>Creating variables by splitting the elements of a character vector
without needing a split string</h2><span id='topic+AutoSplit'></span>

<h3>Description</h3>

<p>Creating variables by splitting the elements of a character vector
without needing a split string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoSplit(
  s,
  split = NULL,
  border = "_",
  revBorder = FALSE,
  noSplit = FALSE,
  varNames = paste("var", 1:100, sep = ""),
  tryReverse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoSplit_+3A_s">s</code></td>
<td>
<p>The character vector</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_split">split</code></td>
<td>
<p>Split string. When NULL (default), automatic splitting without a split string.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_border">border</code></td>
<td>
<p>A split character
or an integer (move split) to be used when the exact split position
is not unique.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_revborder">revBorder</code></td>
<td>
<p>When border is integer the split position is moved from the other side.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_nosplit">noSplit</code></td>
<td>
<p>No splitting when TRUE.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_varnames">varNames</code></td>
<td>
<p>Variable names of the created variables (too many is ok)</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_tryreverse">tryReverse</code></td>
<td>
<p>When TRUE, the automatic method tries to find more variables by
splitting from reversed strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with s as row names.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- c("A12-3-A-x","A12-3-B-x","B12-3-A-x","B12-3-B-x",
       "A12-3-A-y","A12-3-B-y","B12-3-A-y","B12-3-B-y")
AutoSplit(s)
AutoSplit(s,border="-")
AutoSplit(s,split="-")
AutoSplit(s,border=1)
AutoSplit(s,border=2)
AutoSplit(s,border=2,revBorder=TRUE)
AutoSplit(s,noSplit=TRUE)
AutoSplit(s,varNames=c("A","B","C","D"))
</code></pre>

<hr>
<h2 id='CbindIdMatch'>Combine several data frames by using id variables to match rows</h2><span id='topic+CbindIdMatch'></span>

<h3>Description</h3>

<p>Combine several data frames by using id variables to match rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CbindIdMatch(
  ...,
  addName = names(x),
  sep = "_",
  idNames = sapply(x, function(x) names(x)[1]),
  idNames1 = idNames,
  addLast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CbindIdMatch_+3A_...">...</code></td>
<td>
<p>Several data frames as several input parameters or a list of data frames</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_addname">addName</code></td>
<td>
<p>NULL or vector of strings used to name columns according to origin frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when addName apply</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_idnames">idNames</code></td>
<td>
<p>Names of a id variable within each data frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_idnames1">idNames1</code></td>
<td>
<p>Names of variables in first data frame that correspond to the id variable within each data frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_addlast">addLast</code></td>
<td>
<p>When TRUE addName will be at end</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first data frame is the basis and the other frames will be matched by using id-variables.
The default id-variables are the first variable in each frame. Corresponding variables with
the same name in first frame is assumed. An id-variable is not needed if the number of rows
is one or the same as the first frame. Then the element of idNames can be set to a string
with zero length.
</p>


<h3>Value</h3>

<p>A single data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RbindAll">RbindAll</a></code> (same example data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zA &lt;- data.frame(idA = 1:10, idB = rep(10 * (1:5), 2), idC = rep(c(100, 200), 5), 
                 idC2 = c(100, rep(200, 9)), idC3 = rep(100, 10), 
                 idD = 99, x = round(rnorm(10), 3), xA = round(runif(10), 2))
zB &lt;- data.frame(idB = 10 * (1:5), x = round(rnorm(5), 3), xB = round(runif(5), 2))
zC &lt;- data.frame(idC = c(100, 200), x = round(rnorm(2), 3), xC = round(runif(2), 2))
zD &lt;- data.frame(idD = 99, x = round(rnorm(1), 3), xD = round(runif(1), 2))
CbindIdMatch(zA, zB, zC, zD)
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames = c("", "idB", "idC", ""))
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames1 = c("", "idB", "idC2", ""))
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames1 = c("", "idB", "idC3", ""))
CbindIdMatch(zA, zB, zC, zD, addName = c("", "bbb", "ccc", "ddd"), sep = ".", addLast = TRUE)
try(CbindIdMatch(X = zA, Y = zA[, 4:5], Z = zC, idNames = NULL)) # Error
CbindIdMatch(X = zA, Y = zA[, 4:5], Z = zD, idNames = NULL)      # Ok since equal NROW or NROW==1
CbindIdMatch(list(a = zA, b = zB, c = zC, d = zD))               # List is alternative input
</code></pre>

<hr>
<h2 id='CharacterDataFrame'>CharacterDataFrame</h2><span id='topic+CharacterDataFrame'></span>

<h3>Description</h3>

<p>CharacterDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharacterDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CharacterDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='CheckInput'>Checking function inputs</h2><span id='topic+CheckInput'></span><span id='topic+check_input'></span>

<h3>Description</h3>

<p>An input vector (of length one unless <code>okSeveral</code> is <code>TRUE</code>) is checked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckInput(
  x,
  alt = NULL,
  min = NULL,
  max = NULL,
  type = "character",
  data = NULL,
  okSeveral = FALSE,
  okNULL = FALSE,
  okNA = FALSE,
  okDuplicates = is.null(alt) &amp; !(type %in% c("varName", "varNr", "varNrName"))
)

check_input(
  x,
  alt = NULL,
  min = NULL,
  max = NULL,
  type = "character",
  data = NULL,
  okSeveral = FALSE,
  okNULL = FALSE,
  okNA = FALSE,
  okDuplicates = is.null(alt) &amp; !(type %in% c("varName", "varNr", "varNrName"))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckInput_+3A_x">x</code></td>
<td>
<p>Input vector to be checked</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_alt">alt</code></td>
<td>
<p><code>NULL</code> or vector of allowed values</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_min">min</code></td>
<td>
<p><code>NULL</code> or minimum value (when <code>type</code> is numeric or integer)</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_max">max</code></td>
<td>
<p><code>NULL</code> or maximum value (when <code>type</code> is numeric or integer)</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_type">type</code></td>
<td>
<p>One of: <code>"character"</code>, <code>"numeric"</code>, <code>"integer"</code>, <code>"logical"</code>, <code>"varName"</code>, <code>"varNr"</code>, <code>"varNrName"</code>.
numeric/integer is not checked against exact class, but whether the value fit into the class.
Also see data below.</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_data">data</code></td>
<td>
<p>A data frame or matrix. When above type is <code>varNames</code>, <code>x</code> is checked against <code>colnames(data)</code>.
When type is <code>varNr</code>, <code>x</code> is checked against column numbers.
When type is <code>varNrName</code>, <code>x</code> can be either column numbers or column names.</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_okseveral">okSeveral</code></td>
<td>
<p>When <code>TRUE</code>, <code>length(x)&gt;1</code> is allowed</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_oknull">okNULL</code></td>
<td>
<p>When <code>TRUE</code>, <code>NULL</code> is allowed</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_okna">okNA</code></td>
<td>
<p>When <code>TRUE</code>, <code>NA</code> is allowed</p>
</td></tr>
<tr><td><code id="CheckInput_+3A_okduplicates">okDuplicates</code></td>
<td>
<p>When <code>TRUE</code>, duplicated values are allowed.
Default is <code>TRUE</code> if <code>alt</code> is <code>NULL</code> and if <code>type</code> does not refer to column(s) of <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is checked according to the other input parameters.
When <code>x</code> is wrong an error is produced with appropriate text.
</p>
<p><em>The function was originally created in 2016 and has been included in
internal packages at Statistics Norway (SSB). Due to its widespread use,
it was beneficial to include it in this CRAN package.</em>
</p>


<h3>Note</h3>

<p><code>check_input</code> and <code>CheckInput</code> are identical
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c("no", "yes")
b &lt;- c(3.14, 4, 5)
z &lt;- data.frame(A = a, B = b[1:2], C = TRUE)

# Lines causing error are embedded in 'try'

try(CheckInput(a, type = "character"))
CheckInput(a, type = "character", alt = c("no", "yes", "dontknow"), okSeveral = TRUE)
try(CheckInput("yesno", type = "character", alt = c("no", "yes", "dontknow")))
CheckInput(a[1], type = "character", alt = c("no", "yes", "dontknow"))

try(CheckInput(b, type = "integer", max = 100, okSeveral = TRUE))
try(CheckInput(b, type = "numeric", min = 4, okSeveral = TRUE))
CheckInput(b, type = "numeric", max = 100, okSeveral = TRUE)
try(CheckInput(b, type = "numeric", alt = 1:10, okSeveral = TRUE))
CheckInput(b[2], type = "numeric", alt = 1:10)

try(CheckInput("TRUE", type = "logical"))
CheckInput(TRUE, type = "logical")

try(CheckInput("A", type = "varName"))
CheckInput("A", type = "varName", data = z)
CheckInput(c("A", "B"), type = "varNrName", data = z, okSeveral = TRUE)
try(CheckInput("ABC", type = "varNrName", data = z))
try(CheckInput(5, type = "varNrName", data = z))
CheckInput(3, type = "varNr", data = z)
CheckInput(2:3, type = "varNr", data = z, okSeveral = TRUE)
</code></pre>

<hr>
<h2 id='combine_formulas'>Combine formulas</h2><span id='topic+combine_formulas'></span>

<h3>Description</h3>

<p>Combining formulas by <code>+</code> or another operator.
This is particularly useful for linking tables in the case of table building with formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_formulas(lof, operator = "+", simplify = FALSE, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_formulas_+3A_lof">lof</code></td>
<td>
<p>list or vector of formulas to be linked</p>
</td></tr>
<tr><td><code id="combine_formulas_+3A_operator">operator</code></td>
<td>
<p><code>"+"</code> (default), <code>"*"</code>, <code>":"</code> or another operator</p>
</td></tr>
<tr><td><code id="combine_formulas_+3A_simplify">simplify</code></td>
<td>
<p>logical value, default FALSE. Determines whether the formula
should be expanded and simplified before output or not.</p>
</td></tr>
<tr><td><code id="combine_formulas_+3A_env">env</code></td>
<td>
<p>the environment for the output formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model formula
</p>


<h3>Author(s)</h3>

<p>Daniel Lupp and Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lof1 &lt;- c(~a+b, ~a:c, ~c*d)
combine_formulas(lof1)
combine_formulas(lof1, operator = "*")
combine_formulas(lof1, simplify = TRUE)

# Intercept is included when needed
lof2 &lt;- c(~a+b -1, ~a:c -1, ~c*d)
combine_formulas(lof2)
combine_formulas(lof2, simplify = TRUE)
combine_formulas(lof2[1:2])
combine_formulas(lof2[1:2], simplify = TRUE)
</code></pre>

<hr>
<h2 id='CrossCodeFrames'>Cross codes in data frames</h2><span id='topic+CrossCodeFrames'></span>

<h3>Description</h3>

<p>Cross codes in data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossCodeFrames(codeFrame1, codeFrame2, useMatrixToDataFrame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CrossCodeFrames_+3A_codeframe1">codeFrame1</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="CrossCodeFrames_+3A_codeframe2">codeFrame2</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="CrossCodeFrames_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>useMatrixToDataFrame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='crossMerge'>crossMerge</h2><span id='topic+crossMerge'></span>

<h3>Description</h3>

<p>crossMerge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossMerge(ind1, ind2, x, y, useMatrixToDataFrame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossMerge_+3A_ind1">ind1</code></td>
<td>
<p>ind1</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_ind2">ind2</code></td>
<td>
<p>ind2</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
</table>

<hr>
<h2 id='DataDummyHierarchy'>Create a (signed) dummy matrix for hierarcical mapping of codes in data</h2><span id='topic+DataDummyHierarchy'></span><span id='topic+DataDummyHierarchies'></span>

<h3>Description</h3>

<p>Create a (signed) dummy matrix for hierarcical mapping of codes in data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataDummyHierarchy(dataVector, dummyHierarchy)

DataDummyHierarchies(data, dummyHierarchies, colNamesFromData = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataDummyHierarchy_+3A_datavector">dataVector</code></td>
<td>
<p>A vector of codes in data</p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_dummyhierarchy">dummyHierarchy</code></td>
<td>
<p>Output from <code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code></p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_dummyhierarchies">dummyHierarchies</code></td>
<td>
<p>Output from <code><a href="#topic+DummyHierarchies">DummyHierarchies</a></code></p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_colnamesfromdata">colNamesFromData</code></td>
<td>
<p>Column names from data when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DataDummyHierarchies</code> is a user-friendly wrapper for the original function <code>DataDummyHierarchy</code>.
When <code>colNamesFromData</code> is <code>FALSE</code> (default), this function returns
<code style="white-space: pre;">&#8288;mapply(DataDummyHierarchy,&#8288;</code> <code style="white-space: pre;">&#8288;data[names(dummyHierarchies)],&#8288;</code> <code style="white-space: pre;">&#8288;dummyHierarchies)&#8288;</code>.
</p>


<h3>Value</h3>

<p>A sparse matrix.
Column names are taken from dataVector (if non-NULL) and row names are taken from
the row names of dummyHierarchy.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[1:9, ]
hi &lt;- FindHierarchies(z[, c("geo", "eu", "age", "year")])
dhi &lt;- DummyHierarchies(hi, inputInOutput = TRUE)
DataDummyHierarchies(z, dhi, colNamesFromData = TRUE)
</code></pre>

<hr>
<h2 id='DataFrameToMatrix'>DataFrameToMatrix</h2><span id='topic+DataFrameToMatrix'></span>

<h3>Description</h3>

<p>DataFrameToMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataFrameToMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataFrameToMatrix_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='DimList2Hierarchy'>DimList2Hierarchy</h2><span id='topic+DimList2Hierarchy'></span>

<h3>Description</h3>

<p>From hierarchy/dimList as in sdcTable to to-from coded hierarchy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimList2Hierarchy(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DimList2Hierarchy_+3A_x">x</code></td>
<td>
<p>An element of a dimList as in sdcTable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with to-from coded hierarchy
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>, <code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First generate a dimList element 
x &lt;- FindDimLists(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu")], , total = "Europe")[[1]]
x

DimList2Hierarchy(x)

</code></pre>

<hr>
<h2 id='DimList2Hrc'>DimList2Hrc/Hrc2DimList</h2><span id='topic+DimList2Hrc'></span><span id='topic+Hrc2DimList'></span>

<h3>Description</h3>

<p>Conversion between hierarchies/dimList as in sdcTable and TauArgus coded hierarchies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimList2Hrc(dimList)

Hrc2DimList(hrc, total = "Total")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DimList2Hrc_+3A_dimlist">dimList</code></td>
<td>
<p>List of data frames according to the specifications in sdcTable</p>
</td></tr>
<tr><td><code id="DimList2Hrc_+3A_hrc">hrc</code></td>
<td>
<p>List of character vectors</p>
</td></tr>
<tr><td><code id="DimList2Hrc_+3A_total">total</code></td>
<td>
<p>String used to name totals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See Arguments
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First generate dimList
dimList &lt;- FindDimLists(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")])
dimList
hrc &lt;- DimList2Hrc(dimList)
hrc
dimList2 &lt;- Hrc2DimList(hrc)
identical(dimList, dimList2)
</code></pre>

<hr>
<h2 id='dummy_aggregate'><code>aggregate_multiple_fun</code> using a dummy matrix</h2><span id='topic+dummy_aggregate'></span>

<h3>Description</h3>

<p>Wrapper to <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>
that uses a dummy matrix instead of the <code>by</code> parameter.
Functionality for non-dummy  matrices as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_aggregate(
  data,
  x,
  vars,
  fun = NULL,
  dummy = TRUE,
  when_non_dummy = warning,
  keep_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_aggregate_+3A_data">data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_vars">vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li><p> Parameter <code>vars</code> will converted to an internal standard by the function <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>. Indices instead of variable names are allowed.
</p>
</li>
<li><p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li><p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_fun">fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code><a href="#topic+fix_fun_amf">fix_fun_amf</a></code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_dummy">dummy</code></td>
<td>
<p>When <code>TRUE</code>, only 0s and 1s are assumed in <code>x</code>.
When <code>FALSE</code>, non-0s in <code>x</code> are passed as an additional first input parameter to the <code>fun</code> functions.
Thus, the same result as matrix multiplication is achieved with <code>fun = function(x, y) sum(x * y)</code>.
In this case, the data will not be subjected to <code>unlist</code>. See <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_when_non_dummy">when_non_dummy</code></td>
<td>
<p>Function to be called when <code>dummy</code> is <code>TRUE</code> and when <code>x</code> is non-dummy.  Supply <code>NULL</code> to do nothing.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_keep_names">keep_names</code></td>
<td>
<p>When <code>TRUE</code>, output row names are inherited from column names in <code>x</code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>aggregate_multiple_fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally this function make use of the <code>ind</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Code that generates output similar to the 
# last example in aggregate_multiple_fun

d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]

x &lt;- ModelMatrix(d, formula = ~main_income:k_group - 1)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
dummy_aggregate(
   data = d, 
   x = x, 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean))


# Make a non-dummy matrix 
x2 &lt;- x
x2[17, 2:5] &lt;- c(-1, 3, 0, 10)
x2[, 4] &lt;- 0

# Now warning 
# Result is not same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, vars = "freq", fun = sum)

# Now same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, 
                vars = "freq", dummy = FALSE,
                fun = function(x, y) sum(x * y))


# Same as t(x2) %*% d[["freq"]]  + t(x2^2) %*% d[["y"]] 
dummy_aggregate(data = d, x = x2, 
                vars = list(c("freq", "y")), dummy = FALSE,
                fun = function(x, y1, y2) {sum(x * y1) + sum(x^2 * y2)})
                
</code></pre>

<hr>
<h2 id='DummyApply'>Apply a function to subsets defined by a dummy matrix</h2><span id='topic+DummyApply'></span>

<h3>Description</h3>

<p>For each column, <code>i</code>,  of the matrix <code>x</code> of zeros and ones, the output value is equivalent to <code>FUN(y[x[, i] != 0])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyApply(x, y, FUN = sum, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DummyApply_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_y">y</code></td>
<td>
<p>Vector of input values</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_fun">FUN</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_simplify">simplify</code></td>
<td>
<p>Parameter to <code><a href="stats.html#topic+aggregate">aggregate</a></code>. When <code>FALSE</code>, list output is ensured.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a dummy <code>x</code> and <code>FUN = sum</code>, output is equivalent to <code>z = t(x) %*% y</code>.
</p>


<h3>Value</h3>

<p>Vector of output values or a matrix when multiple outputs from <code>FUN</code>  (see examples).
List output is also possible (ensured when <code>simplify = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

a &lt;- ModelMatrix(z, formula = ~age + geo, crossTable = TRUE)

cbind(as.data.frame(a$crossTable), 
      sum1 = (Matrix::t(a$modelMatrix) %*% z$ths_per)[,1],
      sum2 = DummyApply(a$modelMatrix, z$ths_per, sum),
       max = DummyApply(a$modelMatrix, z$ths_per, max))
       
DummyApply(a$modelMatrix, z$ths_per, range)
DummyApply(a$modelMatrix, z$ths_per, range, simplify = FALSE)  

a$modelMatrix[, c(3, 5)] &lt;- 0   # Introduce two empty columns. 
DummyApply(a$modelMatrix, z$ths_per, function(x){ 
  c(min = min(x), 
    max = max(x), 
    mean = mean(x), 
    median = median(x), 
    n = length(x))})   
    
DummyApply(a$modelMatrix, z$ths_per, function(x) x, simplify = FALSE)          

</code></pre>

<hr>
<h2 id='DummyDuplicated'>Duplicated columns in dummy matrix</h2><span id='topic+DummyDuplicated'></span>

<h3>Description</h3>

<p>The algorithm is based on <code>crossprod(x)</code> or <code>crossprod(x, u)</code> where <code>u</code> is a vector of random numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyDuplicated(x, idx = FALSE, rows = FALSE, rnd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DummyDuplicated_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_idx">idx</code></td>
<td>
<p>Indices returned when TRUE</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_rows">rows</code></td>
<td>
<p>Duplicated rows instead when TRUE</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_rnd">rnd</code></td>
<td>
<p>Algorithm based on cross product with random numbers when TRUE (dummy matrix not required)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The efficiency of the default algorithm depends on the sparsity of <code>crossprod(x)</code>.
The random values are generated locally within the function without affecting the random value stream in R.
</p>


<h3>Value</h3>

<p>Logical vectors specifying duplicated columns or vector of indices (first match)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1, rbind(diag(2), diag(2)), diag(4)[, 1:2])
z &lt;- Matrix::Matrix(x[c(1:4, 2:3), c(1, 2, 1:5, 5, 2)])

DummyDuplicated(z)
which(DummyDuplicated(z, rows = TRUE))

# Four ways to obtain the same result
DummyDuplicated(z, idx = TRUE)
DummyDuplicated(z, idx = TRUE, rnd = TRUE)
DummyDuplicated(Matrix::t(z), idx = TRUE, rows = TRUE)
DummyDuplicated(Matrix::t(z), idx = TRUE, rows = TRUE, rnd = TRUE)

# The unique values in four ways 
which(!DummyDuplicated(z), )
which(!DummyDuplicated(z, rnd = TRUE))
which(!DummyDuplicated(Matrix::t(z), rows = TRUE))
which(!DummyDuplicated(Matrix::t(z), rows = TRUE, rnd = TRUE))
</code></pre>

<hr>
<h2 id='DummyHierarchy'>Converting hierarchy specifications to a (signed) dummy matrix</h2><span id='topic+DummyHierarchy'></span><span id='topic+DummyHierarchies'></span>

<h3>Description</h3>

<p>A matrix for mapping input codes (columns) to output codes (rows) are created.
The elements of the matrix specify how columns contribute to rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyHierarchy(
  mapsFrom,
  mapsTo,
  sign,
  level,
  mapsInput = NULL,
  inputInOutput = FALSE,
  keepCodes = mapsFrom[integer(0)],
  unionComplement = FALSE,
  reOrder = FALSE
)

DummyHierarchies(
  hierarchies,
  data = NULL,
  inputInOutput = FALSE,
  unionComplement = FALSE,
  reOrder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DummyHierarchy_+3A_mapsfrom">mapsFrom</code></td>
<td>
<p>Character vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_mapsto">mapsTo</code></td>
<td>
<p>Character vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_sign">sign</code></td>
<td>
<p>Numeric vector of either 1 or -1 from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_level">level</code></td>
<td>
<p>Numeric vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_mapsinput">mapsInput</code></td>
<td>
<p>All codes in mapsFrom not in mapsTo (created automatically when NULL) and possibly other codes in input data.</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>When FALSE all output rows represent codes in mapsTo</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_keepcodes">keepCodes</code></td>
<td>
<p>To prevent some codes to be removed when inputInOutput = FALSE</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>When TRUE, sign means union and complement instead of addition or subtraction (see note)</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (FALSE is default) output codes are ordered differently, more similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DummyHierarchies</code> is a user-friendly wrapper for the original function <code>DummyHierarchy</code>.
Then, the logical input parameters are vectors (possibly recycled).
<code>mapsInput</code> and <code>keepCodes</code> can be supplied as attributes.
<code>mapsInput</code> will be generated when <code>data</code> is non-NULL.
</p>


<h3>Value</h3>

<p>A sparse matrix with row and column and names
</p>


<h3>Note</h3>

<p>With unionComplement = FALSE (default), the sign of each mapping specifies the contribution as addition or subtraction.
Thus, values above one and negative values in output can occur.
With unionComplement = TRUE,  positive is treated as union and negative as complement. Then 0 and 1 are the only possible elements in the output matrix.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A hierarchy table
h &lt;- SSBtoolsData("FIFA2018ABCD")

DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level)
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level, inputInOutput = TRUE)
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level, keepCodes = c("Portugal", "Spain"))

# Extend the hierarchy table to illustrate the effect of unionComplement
h2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Schengen"), mapsTo = "EUandSchengen", 
                       sign = 1, level = 3), h)

DummyHierarchy(h2$mapsFrom, h2$mapsTo, h2$sign, h2$level)
DummyHierarchy(h2$mapsFrom, h2$mapsTo, h2$sign, h2$level, unionComplement = TRUE)

# Extend mapsInput - leading to zero columns.
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level,
               mapsInput = c(h$mapsFrom[!(h$mapsFrom %in% h$mapsTo)], "Norway", "Finland"))

# DummyHierarchies
DummyHierarchies(FindHierarchies(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")]), 
                 inputInOutput = c(FALSE, TRUE))
</code></pre>

<hr>
<h2 id='Extend0'>Add zero frequency rows</h2><span id='topic+Extend0'></span>

<h3>Description</h3>

<p>Microdata or tabular frequency data is extended to contain all combinations of unique rows
of (hierarchical) groups of dimensional variables. Extra variables are extended by <code>NA</code>'s or <code>0</code>'s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend0(
  data,
  freqName = "freq",
  hierarchical = TRUE,
  varGroups = NULL,
  dimVar = NULL,
  extraVar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extend0_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Extend0_+3A_freqname">freqName</code></td>
<td>
<p>Name of (existing) frequency variable</p>
</td></tr>
<tr><td><code id="Extend0_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Hierarchical variables treated atomatically when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Extend0_+3A_vargroups">varGroups</code></td>
<td>
<p>List of variable groups, possibly with data (see details and examples).</p>
</td></tr>
<tr><td><code id="Extend0_+3A_dimvar">dimVar</code></td>
<td>
<p>The dimensional variables</p>
</td></tr>
<tr><td><code id="Extend0_+3A_extravar">extraVar</code></td>
<td>
<p>Extra variables as variable names, TRUE (all remaining) or FALSE (none).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With no frequency variable in input (microdata), the frequency variable in output  consists of ones and zeros.
By default, all variables, except the frequencies, are considered as dimensional variables.
By default, the grouping of dimensional variables is based on hierarchical relationships (<code>hierarchical = TRUE</code>).
With <code>varGroups = NULL</code> and <code>hierarchical = FALSE</code>,
each dimensional variable forms a separate group (as <code>as.list(dimVar)</code>).
Parameter <code>extraVar</code> can be specified as variable names.
<code>TRUE</code> means all remaining variables and <code>FALSE</code> no variables.
</p>
<p>When the contents of <code>varGroups[[i]]</code> is variable names, the data frame <code>unique(data[varGroups[[i]]])</code> will be made as a
building block within the function. A possibility is to supply such a data frame instead of variable names.
Then, the building block will be <code>unique(varGroups[[i]])</code>. Names and data frames can be mixed.
</p>


<h3>Value</h3>

<p>Extended data frame
</p>


<h3>See Also</h3>

<p>Advanced possibilities by varGroups-attribute. See <code><a href="#topic+Extend0rnd1">Extend0rnd1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[c(1, 4:6, 8, 11:15), ]
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

Extend0(z[, -4])
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"))
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"), extraVar = "year")
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"), extraVar = FALSE)
Extend0(z, varGroups = list(c("age", "geo", "year"), "eu"))
Extend0(MakeFreq(z[c(1, 1, 1, 2, 2, 3:10), -4]))
Extend0(z, "ths_per")

# varGroups with data frames (same result as with names above)
Extend0(z, varGroups = list(z[c("age", "geo", "year")], z["eu"]))

# varGroups with both names and data frame
Extend0(z, varGroups = list(c("year", "geo", "eu"), data.frame(age = c("middle", "old"))))
</code></pre>

<hr>
<h2 id='Extend0fromModelMatrixInput'>A specialized version of Extend0()</h2><span id='topic+Extend0fromModelMatrixInput'></span><span id='topic+IsExtend0'></span>

<h3>Description</h3>

<p><code>Extend0fromModelMatrixInput()</code> is a specialized function that extends the input data based on the provided parameters.
It is designed specifically to work with input to <code><a href="#topic+ModelMatrix">ModelMatrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend0fromModelMatrixInput(
  data,
  freqName,
  hierarchies,
  formula,
  dimVar,
  extend0,
  dVar = NULL,
  avoidHierarchical = FALSE,
  hierarchical_extend0 = !avoidHierarchical &amp; is.null(hierarchies),
  ...
)

IsExtend0(extend0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extend0fromModelMatrixInput_+3A_data">data</code></td>
<td>
<p>Input data frame</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_freqname">freqName</code></td>
<td>
<p>Name of (existing) frequency variable</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_extend0">extend0</code></td>
<td>
<p>When <code>extend0</code> is set to <code>TRUE</code>, the data is automatically extended.
Additionally, <code>extend0</code> can be specified as a list, representing the <code>varGroups</code> parameter
in the <code><a href="#topic+Extend0">Extend0</a></code> function.
Can also be set to <code>"all"</code> which means that input codes in hierarchies
are considered in addition to those in data.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_dvar">dVar</code></td>
<td>
<p>Optional. Specifies the <code>dimVar</code> input for <code><a href="#topic+Extend0">Extend0()</a></code>.
If not provided, <code>dimVar</code> is calculated by the <code><a href="#topic+NamesFromModelMatrixInput">NamesFromModelMatrixInput()</a></code> function.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_avoidhierarchical">avoidHierarchical</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix()</a></code> via <code><a href="#topic+ModelMatrix">ModelMatrix()</a></code>.
The default value (<code>FALSE</code>) is the same as in the receiving function.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_hierarchical_extend0">hierarchical_extend0</code></td>
<td>
<p>Specifies the <code>hierarchical</code> input to <code><a href="#topic+Extend0">Extend0()</a></code>.
By default, it is set to the opposite of <code>avoidHierarchical</code> when <code>hierarchies</code> is not provided.
If <code>hierarchies</code> is provided, <code>hierarchical_extend0</code> is by default set to <code>FALSE</code>.
This parameter allows the <code>hierarchical</code> input to <code>Extend0()</code> to be specified manually,
independent of the input provided to <code>ModelMatrix()</code>.</p>
</td></tr>
<tr><td><code id="Extend0fromModelMatrixInput_+3A_...">...</code></td>
<td>
<p>Further arguments to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>Extend0fromModelMatrixInput()</code>: The main function that processes and extends input data according to the specified parameters.
</p>
</li>
<li> <p><code>IsExtend0()</code>: A helper function that evaluates the <code>extend0</code> parameter and returns <code>TRUE</code> or <code>FALSE</code>, indicating whether the data should be extended.
</p>
</li></ul>



<h3>Value</h3>

<p>Extended data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extend0">Extend0()</a></code>
</p>

<hr>
<h2 id='Extend0rnd1'>varGroups-attribute to Extend0, Example functions</h2><span id='topic+Extend0rnd1'></span><span id='topic+Extend0rnd2'></span><span id='topic+Extend0rnd1b'></span>

<h3>Description</h3>

<p>Setting <code>attr(varGroups, "FunctionExtend0")</code> to a function
makes <code>Extend0</code> behave differently
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend0rnd1(data, varGroups, k = 1, rndSeed = 123)

Extend0rnd2(...)

Extend0rnd1b(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extend0rnd1_+3A_data">data</code></td>
<td>
<p>data.frame within <code><a href="#topic+Extend0">Extend0</a></code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_vargroups">varGroups</code></td>
<td>
<p>argument to <code><a href="#topic+Extend0">Extend0</a></code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_k">k</code></td>
<td>
<p>Number of rows generated is approx. <code>k*nrow(data)</code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_rndseed">rndSeed</code></td>
<td>
<p>Internal random seed to be used</p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point is to create a function that takes <code>data</code> and <code>varGroups</code> as input
and that returns a data frame with a limited number of combinations of the elements in <code>varGroups</code>.
The example function here is limited to two varGroups elements.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[c(1, 5, 8, 14), ]
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

varGroups &lt;- list(c("year", "geo", "eu"), data.frame(age = c("middle", "old")))
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd1
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd1b
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd2
Extend0(z, varGroups = varGroups)

# To see what's going on internally. Data used only via nrow 
varGroups &lt;- list(data.frame(ab = rep(c("a", "b"), each = 4), abcd = c("a", "b", "c", "d")), 
                  data.frame(AB = rep(c("A", "B"), each = 3), ABC = c("A", "B", "C"))) 
a &lt;- Extend0rnd1(data.frame(1:5), varGroups)
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd1b(data.frame(1:5), varGroups)
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd2(data.frame(1:5), varGroups[2:1])
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd1(data.frame(1:100), varGroups)
table(a[[1]], a[[2]]) # Maybe smaller numbers than expected since duplicates were removed
table(a[[3]], a[[4]])
</code></pre>

<hr>
<h2 id='FactorLevCorr'>Factor level correlation</h2><span id='topic+FactorLevCorr'></span>

<h3>Description</h3>

<p>A sort of correlation matrix useful to detect (hierarchical) relationships between the levels of factor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorLevCorr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorLevCorr_+3A_x">x</code></td>
<td>
<p>Input matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a sort of correlation matrix.
</p>
<p>Here we refer to ni as the number of present levels of variable i (the number of unique elements) and we refer to mij as the number
of present levels obtained by crossing variable i and variable j (the number unique rows of x[,c(i,j)]).
</p>
<p>The diagonal elements of the output matrix contains the number of present levels of each variable (=ni).
</p>
<p>The absolute values of off-diagonal elements:
</p>
<table role = "presentation">
<tr><td><code>0</code></td>
<td>
<p>when mij = ni*nj</p>
</td></tr>
<tr><td><code>1</code></td>
<td>
<p>when mij = max(ni,nj)</p>
</td></tr>
<tr><td><code>Other values</code></td>
<td>
<p>Computed as (ni*nj-mij)/(ni*nj-max(ni,nj))</p>
</td></tr>
</table>
<p>So 0 means that all possible level combinations exist in the data and 1 means that the two variables are
hierarchically related.
</p>
<p>The sign of off-diagonal elements:
</p>
<table role = "presentation">
<tr><td><code>positive</code></td>
<td>
<p>when ni&lt;nj</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>when ni&gt;nj</p>
</td></tr>
</table>
<p>In cases where ni=nj elements will be positive above the diagonal and negative below.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c("A","B","C"),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep="")
 m &lt;- cbind(x,y,z,zy)
 FactorLevCorr(m)

</code></pre>

<hr>
<h2 id='filter_by_variable'>Filter a List of Items or Retrieve Names by a Variable</h2><span id='topic+filter_by_variable'></span><span id='topic+names_by_variable'></span>

<h3>Description</h3>

<p>Filters a list of items, retaining only those associated with a specific variable,
or retrieves the names of items associated with the variable. The association between
items and variables is provided via a named list, where each element contains a
vector of variables corresponding to an item in <code>items</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_by_variable(variable, items, variable_mapping)

names_by_variable(variable, variable_mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_by_variable_+3A_variable">variable</code></td>
<td>
<p>A character string. The variable to filter the items by.</p>
</td></tr>
<tr><td><code id="filter_by_variable_+3A_items">items</code></td>
<td>
<p>A named list of elements. These can be any type of objects (e.g., formulas, data, etc.).</p>
</td></tr>
<tr><td><code id="filter_by_variable_+3A_variable_mapping">variable_mapping</code></td>
<td>
<p>A named list. Each element is a character vector of variables associated
with the corresponding item in <code>items</code>. The names of the list in <code>variable_mapping</code> should match
the names of the list in <code>items</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>filter_by_variable()</code> returns the filtered list of items, whereas
<code>names_by_variable()</code> is a simpler function that just returns the names of the items.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>filter_by_variable()</code>: A named list containing a subset of <code>items</code> where each element is
associated with the specified <code>variable</code>. If no matches are found, an empty list is returned.
</p>
</li>
<li> <p><code>names_by_variable()</code>: A character vector of names from <code>variable_mapping</code> that are associated
with the specified <code>variable</code>. If no matches are found, an empty character vector is returned.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is written and documented by ChatGPT after some discussion.
The examples have been chosen to be relevant in connection with the
<code><a href="#topic+tables_by_formulas">tables_by_formulas</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
items &lt;- list(
  table_1 = ~region * sector2, 
  table_2 = ~region1:sector4 - 1, 
  table_3 = ~region + sector4 - 1
)

variable_mapping &lt;- list(
  table_3 = c("z", "y"), 
  table_1 = c("value", "x"), 
  table_2 = c("value", "x", "y")
)

filter_by_variable("value", items, variable_mapping)
filter_by_variable("y", items, variable_mapping)
filter_by_variable("nonexistent", items, variable_mapping)

names_by_variable("value", variable_mapping)
names_by_variable("y", variable_mapping)
names_by_variable("nonexistent", variable_mapping)

</code></pre>

<hr>
<h2 id='FindCommonCells'>Finding commonCells</h2><span id='topic+FindCommonCells'></span>

<h3>Description</h3>

<p>Finding lists defining common cells as needed for the input parameter
commonCells to the function protectLinkedTables in package sdcTable.
The function handles two tables based on the same main variables
but possibly different aggregating variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindCommonCells(dimList1, dimList2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindCommonCells_+3A_dimlist1">dimList1</code></td>
<td>
<p>As input parameter dimList to the function makeProblem in package sdcTable.</p>
</td></tr>
<tr><td><code id="FindCommonCells_+3A_dimlist2">dimList2</code></td>
<td>
<p>Another dimList with the same names and using the same level names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list according to the specifications in sdcTable.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 fg &lt;- FindTableGroup(m,findLinked=TRUE)
 dimLists &lt;- FindDimLists(m,fg$groupVarInd)
 # Using table1 and table2 in this example cause error,
 # but in other cases this may work well
 try(FindCommonCells(dimLists[fg$table$table1],dimLists[fg$table$table2]))
 FindCommonCells(dimLists[c(1,2)],dimLists[c(1,3)])
</code></pre>

<hr>
<h2 id='FindDimLists'>Finding dimList</h2><span id='topic+FindDimLists'></span>

<h3>Description</h3>

<p>Finding lists of level-hierarchy as needed for the input parameter
dimList to the function makeProblem in package sdcTable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDimLists(
  x,
  groupVarInd = HierarchicalGroups(x = x),
  addName = FALSE,
  sep = ".",
  xReturn = FALSE,
  total = "Total"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindDimLists_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables (micro data or cell counts data).</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_groupvarind">groupVarInd</code></td>
<td>
<p>List of vectors of indices defining the hierarchical variable groups.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_addname">addName</code></td>
<td>
<p>When TRUE the variable name is added to the level names, except for variables with most levels.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when addName apply.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_xreturn">xReturn</code></td>
<td>
<p>When TRUE x is also in output, possibly changed according to addName.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_total">total</code></td>
<td>
<p>String used to name totals. A vector of length <code>ncol(x)</code> is also possible (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list according to the specifications in sdcTable.
When xReturn is TRUE output has an extra list level and x is the first element.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
FindDimLists(dataset[1:2])
FindDimLists(dataset[2:3])
FindDimLists(dataset[1:4])

FindDimLists(SSBtoolsData("magnitude1")[1:4], 
                total = c("TOTAL", "unused1", "Europe", "unused2"))
                
 x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 FindDimLists(m)
 FindDimLists(m, total = paste0("A", 1:4))
</code></pre>

<hr>
<h2 id='FindDisclosiveCells'>Find directly disclosive cells</h2><span id='topic+FindDisclosiveCells'></span>

<h3>Description</h3>

<p>Function for determining which cells in a frequency table can lead to
direct disclosure of an identifiable individual, assuming an attacker has the
background knowledge to place themselves (or a coalition) in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDisclosiveCells(
  data,
  freq,
  crossTable,
  primaryDims = names(crossTable),
  unknowns = rep(NA, length(primaryDims)),
  total = rep("Total", length(primaryDims)),
  unknown.threshold = 0,
  coalition = 1,
  suppressSmallCells = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindDisclosiveCells_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_freq">freq</code></td>
<td>
<p>vector containing frequencies</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_crosstable">crossTable</code></td>
<td>
<p>cross table of key variables produced by ModelMatrix
in parent function</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_primarydims">primaryDims</code></td>
<td>
<p>dimensions to be considered for direct disclosure.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_unknowns">unknowns</code></td>
<td>
<p>vector of unknown values for each of the primary dimensions.
If a primary dimension does not contain unknown values, NA should be passed.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_total">total</code></td>
<td>
<p>string name for marginal values</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_unknown.threshold">unknown.threshold</code></td>
<td>
<p>numeric for specifying a percentage for calculating
safety of cells. A cell is &quot;safe&quot; in a row if the number of unknowns exceeds
<code>unknown.threshold</code> percent of the row total.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_coalition">coalition</code></td>
<td>
<p>maximum number of units in a possible coalition, default 1</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_suppresssmallcells">suppressSmallCells</code></td>
<td>
<p>logical variable which determines whether small cells (&lt;= coalition) or large cells should be suppressed. Default FALSE.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_...">...</code></td>
<td>
<p>parameters from main suppression method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not work on data containing hierarchical variables.
</p>


<h3>Value</h3>

<p>list with two named elements, the first ($primary) being a logical vector
marking directly disclosive cells, the second ($numExtra) a data.frame containing
information regarding the dimensions in which the cells are directly disclosive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extable &lt;- data.frame(v1 = rep(c('a', 'b', 'c'), times = 4),
            v2 = c('i','i', 'i','h','h','h','i','i','i','h','h','h'),
            v3 = c('y', 'y', 'y', 'y', 'y', 'y','z','z', 'z', 'z', 'z', 'z'),
            freq = c(0,0,5,0,2,3,1,0,3,1,1,2))
ex_freq &lt;- c(18,10,8,9,5,4,9,5,4,2,0,2,1,0,1,1,0,1,3,2,1,3,2,1,0,0,0,13,8,5,
             5,3,2,8,5,3)
cross &lt;- ModelMatrix(extable,
                     dimVar = 1:3,
                     crossTable = TRUE)$crossTable

FindDisclosiveCells(extable, ex_freq, cross) 
</code></pre>

<hr>
<h2 id='FindHierarchies'>Finding hierarchies automatically from data</h2><span id='topic+FindHierarchies'></span>

<h3>Description</h3>

<p><code><a href="#topic+FindDimLists">FindDimLists</a></code> and <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code> wrapped into a single function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindHierarchies(data, total = "Total")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindHierarchies_+3A_data">data</code></td>
<td>
<p>Matrix or data frame containing the variables (micro data or cell counts data).</p>
</td></tr>
<tr><td><code id="FindHierarchies_+3A_total">total</code></td>
<td>
<p>String used to name totals. A vector of length <code>ncol(data)</code> is also possible (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of hierarchies
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
FindHierarchies(dataset[1:2])
FindHierarchies(dataset[2:3])
FindHierarchies(dataset[1:4])

FindHierarchies(SSBtoolsData("magnitude1")[1:4], 
                total = c("TOTAL", "unused1", "Europe", "unused2"))

x &lt;- rep(c("A", "B", "C"), 3)
y &lt;- rep(c(11, 22, 11), 3)
z &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3)
zy &lt;- paste(z, y, sep = "")
m &lt;- cbind(x, y, z, zy)
FindHierarchies(m)
FindHierarchies(m, total = paste0("A", 1:4))
</code></pre>

<hr>
<h2 id='FindTableGroup'>Finding table(s) of hierarchical variable groups</h2><span id='topic+FindTableGroup'></span>

<h3>Description</h3>

<p>A single table or two linked tables are found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindTableGroup(
  x = NULL,
  findLinked = FALSE,
  mainName = TRUE,
  fCorr = FactorLevCorr(x),
  CheckHandling = warning
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindTableGroup_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_findlinked">findLinked</code></td>
<td>
<p>When TRUE, two linked tables can be in output</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_mainname">mainName</code></td>
<td>
<p>When TRUE the groupVarInd ouput is named according to first variable in group.</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_fcorr">fCorr</code></td>
<td>
<p>When non-null x is not needed as input.</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_checkhandling">CheckHandling</code></td>
<td>
<p>Function (warning or stop) to be used in problematic situations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list with items
</p>
<table role = "presentation">
<tr><td><code>groupVarInd</code></td>
<td>
<p>List defining the hierarchical variable groups. First variable has most levels.</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>List containing one or two tables. These tables are coded as indices referring to elements of groupVarInd.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 FindTableGroup(m)
 FindTableGroup(m,findLinked=TRUE)
</code></pre>

<hr>
<h2 id='fix_fun_amf'>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code></h2><span id='topic+fix_fun_amf'></span>

<h3>Description</h3>

<p>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_fun_amf(fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_fun_amf_+3A_fun">fun</code></td>
<td>
<p>fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identical(fix_fun_amf("median"), c(median = median))

identical(fix_fun_amf(c("sum", "median")), c(sum = sum, median = median))

ff &lt;- c("sum", "median", "cor")
names(ff) &lt;- c("", NA, "Correlation")
identical(fix_fun_amf(ff), c(sum, median = median, Correlation = cor))

identical(fix_fun_amf(structure("median", names = "")), fix_fun_amf(median))
</code></pre>

<hr>
<h2 id='fix_vars_amf'>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code></h2><span id='topic+fix_vars_amf'></span>

<h3>Description</h3>

<p>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_vars_amf(
  vars,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  names_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_vars_amf_+3A_vars">vars</code></td>
<td>
<p>vars</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_name_sep">name_sep</code></td>
<td>
<p>A character string used when output variable names are generated.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_seve_sep">seve_sep</code></td>
<td>
<p>A character string used when output variable names are generated from functions of several variables.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_multi_sep">multi_sep</code></td>
<td>
<p>A character string used when multiple output variable names are sent as input.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_names_data">names_data</code></td>
<td>
<p><code>names(data)</code> to convert numeric input (indices)</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vars
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- fix_vars_amf

f(c("freq", "y", median = "freq", median = "y", e1 = "freq"))

v1 &lt;- list(sum = "a", sum = "w", q = c("a", "w"), mean = c("b", "w"))
v2 &lt;- list(c(fun = "sum", "a"), c(fun = "sum", "w"), c(fun = "q", "a", "w"), 
           c(fun = "mean", "b", "w"))
v3 &lt;- list(sum = "a", sum = "w", q = c(name = "a:w_q", "a", "w"), 
           `b:w_mean` = list(mean = c("b", "w")))
v4 &lt;- list(c(name = "a_sum", fun = "sum", "a"), 
           c(name = "w_sum", fun = "sum", "w"), 
           c(name = "a:w_q", fun = "q", "a", "w"), 
           c(name = "b:w_mean", fun = "mean", "b", "w"))
v5 &lt;- list(a_sum = c(fun = "sum", "a"), 
           w_sum = c(fun = "sum", "w"), 
           `a:w_q` = c(fun = "q", "a", "w"), 
           `b:w_mean` = c(fun = "mean", "b", "w"))

identical(f(v1), f(v2))
identical(f(v1), f(v3))
identical(f(v1), f(v4))
identical(f(v1), f(v5))

identical(f(v1), f(f(v1)))
identical(f(v1), v4)
</code></pre>

<hr>
<h2 id='ForceCharacterDataFrame'>ForceCharacterDataFrame</h2><span id='topic+ForceCharacterDataFrame'></span>

<h3>Description</h3>

<p>ForceCharacterDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceCharacterDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ForceCharacterDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='ForceFactorDataFrame'>ForceFactorDataFrame</h2><span id='topic+ForceFactorDataFrame'></span>

<h3>Description</h3>

<p>ForceFactorDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceFactorDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ForceFactorDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='formula_from_vars'>Generate model formula by specifying which variables have totals or not.</h2><span id='topic+formula_from_vars'></span>

<h3>Description</h3>

<p>Generate model formula by specifying which variables have totals or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_from_vars(
  nontotal_vars = NULL,
  total_vars = NULL,
  simplify = TRUE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_from_vars_+3A_nontotal_vars">nontotal_vars</code></td>
<td>
<p>character vector of the variable names without totals</p>
</td></tr>
<tr><td><code id="formula_from_vars_+3A_total_vars">total_vars</code></td>
<td>
<p>character vector of the variable names with totals</p>
</td></tr>
<tr><td><code id="formula_from_vars_+3A_simplify">simplify</code></td>
<td>
<p>logical value, default TRUE. Determines whether the formula
should be simplified before output or not.</p>
</td></tr>
<tr><td><code id="formula_from_vars_+3A_env">env</code></td>
<td>
<p>the environment for the output formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model formula
</p>


<h3>Author(s)</h3>

<p>Daniel Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula_from_vars(c("a", "b", "c"), c("a"))
formula_from_vars(c("a", "b", "c"), c("a", "c"))
formula_from_vars(c("a", "b", "c"), c("a", "b", "c"))
formula_from_vars(c("a", "b", "c"), NULL)
formula_from_vars(NULL, c("a", "b", "c"))
formula_from_vars(c("a", "b"), c("d"))
</code></pre>

<hr>
<h2 id='formula_utils'>Functions for formula manipulation</h2><span id='topic+formula_utils'></span>

<h3>Description</h3>

<p>Functions for formula manipulation
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+combine_formulas">combine_formulas</a></code>: Combine formulas
</p>
</li>
<li> <p><code><a href="#topic+formula_from_vars">formula_from_vars</a></code>:  Generate model formula by specifying which variables have totals or not
</p>
</li>
<li> <p><code><a href="#topic+substitute_formula_vars">substitute_formula_vars</a></code>: Replace variables in formula with sum of other variables
</p>
</li></ul>


<hr>
<h2 id='FormulaSelection.default'>Limit matrix or data frame to selected model terms</h2><span id='topic+FormulaSelection.default'></span><span id='topic+FormulaSelection'></span><span id='topic+formula_selection'></span>

<h3>Description</h3>

<p>For use with output from <code><a href="#topic+ModelMatrix">ModelMatrix</a></code> or data frames derived from such output.
It is a generic function which means that methods for other input objects can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
FormulaSelection(x, formula, intercept = NA, logical = FALSE)

FormulaSelection(x, formula, intercept = NA, logical = FALSE)

formula_selection(x, formula, intercept = NA, logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FormulaSelection.default_+3A_x">x</code></td>
<td>
<p>Model matrix or a data frame</p>
</td></tr>
<tr><td><code id="FormulaSelection.default_+3A_formula">formula</code></td>
<td>
<p>Formula representing the limitation
or character string(s) to be converted to a formula (see details)</p>
</td></tr>
<tr><td><code id="FormulaSelection.default_+3A_intercept">intercept</code></td>
<td>
<p>Parameter that specifies whether a possible intercept term (overall total) should be included in the output.
Default is <code>TRUE</code> when a formula is input. Otherwise, see details.</p>
</td></tr>
<tr><td><code id="FormulaSelection.default_+3A_logical">logical</code></td>
<td>
<p>When <code>TRUE</code>, the logical selection vector is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection is based on <code>startCol</code> or <code>startRow</code> attribute in input <code>x</code>.
</p>
<p>With <strong>formula as character</strong>:
</p>

<ul>
<li> <p><strong><code>~</code></strong> is included:
Input is converted by <code>as.formula</code> and default intercept is <code>TRUE</code>.
</p>
</li>
<li> <p><strong><code>~</code></strong> is not included:
Internally, input data is converted to a formula by adding <code>~</code> and possibly <code>+</code>'s when the length is <code style="white-space: pre;">&#8288;&gt;1&#8288;</code>.
Default intercept is <code>FALSE</code> unless <code>"1"</code> or <code>"(Intercept)"</code> (is changed internally to <code>"1"</code>) is included.
</p>
</li></ul>



<h3>Value</h3>

<p>Limited model matrix or a data frame
</p>


<h3>Note</h3>

<p><code>formula_selection</code> and <code>FormulaSelection</code> are identical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

x &lt;- ModelMatrix(z, formula = ~age * year)

FormulaSelection(x, "age")
FormulaSelection(x, ~year)
FormulaSelection(x, ~year:age)

# x1, x2, x3, x4 and x4 are identical
x1 &lt;- FormulaSelection(x, ~age)
x2 &lt;- FormulaSelection(x, "~age")
x3 &lt;- FormulaSelection(x, "age", intercept = TRUE)
x4 &lt;- FormulaSelection(x, c("1", "age"))
x5 &lt;- FormulaSelection(x, c("(Intercept)", "age"))


a &lt;- ModelMatrix(z, formula = ~age * geo + year, crossTable = TRUE)
b &lt;- cbind(as.data.frame(a$crossTable), 
           sum = (Matrix::t(a$modelMatrix) %*% z$ths_per)[, 1], 
           max = DummyApply(a$modelMatrix, 
           z$ths_per, max))
rownames(b) &lt;- NULL
attr(b, "startRow") &lt;- attr(a$modelMatrix, "startCol", exact = TRUE)

FormulaSelection(b, ~geo * age)
FormulaSelection(b, "age:geo")
FormulaSelection(b, ~year - 1)
FormulaSelection(b, ~geo:age, logical = TRUE)
</code></pre>

<hr>
<h2 id='FormulaSums'>Sums (aggregates) and/or sparse model matrix with possible cross table</h2><span id='topic+FormulaSums'></span><span id='topic+Formula2ModelMatrix'></span>

<h3>Description</h3>

<p>By default this function return sums if the formula contains a response part and a model matrix otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormulaSums(
  data,
  formula,
  makeNames = TRUE,
  crossTable = FALSE,
  total = "Total",
  printInc = FALSE,
  dropResponse = FALSE,
  makeModelMatrix = NULL,
  sep = "-",
  sepCross = ":",
  avoidHierarchical = FALSE,
  includeEmpty = FALSE,
  NAomit = TRUE,
  rowGroupsPackage = "base",
  viaSparseMatrix = TRUE,
  ...
)

Formula2ModelMatrix(data, formula, dropResponse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FormulaSums_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_makenames">makeNames</code></td>
<td>
<p>Column/row names made when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_total">total</code></td>
<td>
<p>String used to name totals</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_dropresponse">dropResponse</code></td>
<td>
<p>When TRUE response part of formula ignored.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_makemodelmatrix">makeModelMatrix</code></td>
<td>
<p>Make model matrix when TRUE. NULL means automatic.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_sep">sep</code></td>
<td>
<p>String to separate when creating column names</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_sepcross">sepCross</code></td>
<td>
<p>String to separate when creating column names involving crossing</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_avoidhierarchical">avoidHierarchical</code></td>
<td>
<p>Whether to avoid treating of hierarchical variables. Instead of logical, variables can be specified.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_includeempty">includeEmpty</code></td>
<td>
<p>When <code>TRUE</code>, empty columns of the model matrix (only zeros) are included.
This is not implemented when a response term is included in the formula and <code>dropResponse = FALSE</code> (error will be produced).</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_naomit">NAomit</code></td>
<td>
<p>When <code>TRUE</code>, NAs in the grouping variables are omitted in output and not included as a separate category.
Technically, this parameter is utilized through the function <code><a href="#topic+RowGroups">RowGroups</a></code>.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_rowgroupspackage">rowGroupsPackage</code></td>
<td>
<p>Parameter <code>pkg</code> to the function <code><a href="#topic+RowGroups">RowGroups</a></code>.
Default is <code>"base"</code>.
Setting this parameter to <code>"data.table"</code> can improve speed.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_viasparsematrix">viaSparseMatrix</code></td>
<td>
<p>When TRUE, the model matrix is constructed by a single call to <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
Setting it to FALSE reverts to the previous behavior.
This parameter is included for testing purposes and will likely be removed in future versions.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>FormulaSums</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the original version of the function the model matrix was constructed by
calling <code><a href="Matrix.html#topic+fac2sparse">fac2sparse</a></code> repeatedly.
Now this is replaced by a single call to <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.
The sums are computed by calling <code><a href="stats.html#topic+aggregate">aggregate</a></code> repeatedly.
Hierarchical variables handled when constructing cross table.
Column names constructed from the cross table.
The returned model matrix includes the attribute <code>startCol</code> (see last example line).
</p>


<h3>Value</h3>

<p>A matrix of sums, a sparse model matrix or a list of two or three elements (model matrix and cross table and sums when relevant).
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_withEU")

FormulaSums(x, ths_per ~ year*geo + year*eu)
FormulaSums(x, ~ year*age*eu)
FormulaSums(x, ths_per ~ year*age*geo + year*age*eu, crossTable = TRUE, makeModelMatrix = TRUE)
FormulaSums(x, ths_per ~ year:age:geo -1)
m &lt;- Formula2ModelMatrix(x, ~ year*geo + year*eu)
print(m[1:3, ], col.names = TRUE)
attr(m, "startCol")
</code></pre>

<hr>
<h2 id='GaussIndependent'>Linearly independent rows and columns by Gaussian elimination</h2><span id='topic+GaussIndependent'></span><span id='topic+GaussRank'></span>

<h3>Description</h3>

<p>The function is written primarily for large sparse matrices with integers
and even more correctly it is primarily written for dummy matrices (0s and 1s in input matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussIndependent(
  x,
  printInc = FALSE,
  tolGauss = (.Machine$double.eps)^(1/2),
  testMaxInt = 0,
  allNumeric = FALSE
)

GaussRank(x, printInc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GaussIndependent_+3A_x">x</code></td>
<td>
<p>A (sparse) matrix</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_tolgauss">tolGauss</code></td>
<td>
<p>A tolerance parameter for sparse Gaussian elimination and linear dependency. This parameter is used only in cases where integer calculation cannot be used.</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_testmaxint">testMaxInt</code></td>
<td>
<p>Parameter for testing: The Integer overflow situation will be forced when testMaxInt is exceeded</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_allnumeric">allNumeric</code></td>
<td>
<p>Parameter for testing: All calculations use numeric algorithm (as integer overflow) when TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GaussRank returns the rank
</p>


<h3>Value</h3>

<p>List of logical vectors specifying independent rows and columns
</p>


<h3>Note</h3>

<p>The main algorithm is based on integers and exact calculations. When integers cannot be used (because of input or overflow), the algorithm switches.
With <code>printInc = TRUE</code> as a parameter, <code>.....</code> change to <code style="white-space: pre;">&#8288;-----&#8288;</code> when switching to numeric algorithm.
With numeric algorithm, a kind of tolerance for linear dependency is included.
This tolerance is designed having in mind that the input matrix is a dummy matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ModelMatrix(SSBtoolsData("z2"), formula = ~fylke + kostragr * hovedint - 1)

GaussIndependent(x)
GaussRank(x)
GaussRank(Matrix::t(x))

## Not run: 
# For comparison, qr-based rank may not work
rankMatrix(x, method = "qr")

# Dense qr works 
qr(as.matrix(x))$rank

## End(Not run)
</code></pre>

<hr>
<h2 id='GaussIterationFunction'>An <code>iFunction</code> argument to <code><a href="#topic+GaussSuppression">GaussSuppression</a></code></h2><span id='topic+GaussIterationFunction'></span>

<h3>Description</h3>

<p>Use this function as <code>iFunction</code> or write your own using the same seven first parameters and also using <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussIterationFunction(i, I, j, J, true, false, na, filename = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GaussIterationFunction_+3A_i">i</code></td>
<td>
<p>Number of candidates processed (columns of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_i">I</code></td>
<td>
<p>Total number of candidates to be processed (columns of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_j">j</code></td>
<td>
<p>Number of eliminated dimensions (rows of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_j">J</code></td>
<td>
<p>Total number of dimensions (rows of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_true">true</code></td>
<td>
<p>Candidates decided to be suppressed</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_false">false</code></td>
<td>
<p>Candidates decided to be not suppressed</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_na">na</code></td>
<td>
<p>Candidates not decided</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_filename">filename</code></td>
<td>
<p>When non-NULL, the above arguments will be saved to this file.
Note that <code>GaussSuppression</code> passes this parameter via <code>...</code>.</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_...">...</code></td>
<td>
<p>Extra parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of candidates decided (<code>true</code> and <code>false</code>) may differ from the number of candidates processed (<code>i</code>) due to parameter <code>removeDuplicated</code>
and because the decision for some unprocessed candidates can be found due to empty columns.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='GaussSuppression'>Secondary suppression by Gaussian elimination</h2><span id='topic+GaussSuppression'></span>

<h3>Description</h3>

<p>Sequentially the secondary suppression candidates (columns in x) are used to reduce the x-matrix by Gaussian elimination.
Candidates who completely eliminate one or more primary suppressed cells (columns in x) are omitted and made secondary suppressed.
This ensures that the primary suppressed cells do not depend linearly on the non-suppressed cells.
How to order the input candidates is an important choice.
The singleton problem and the related problem of zeros are also handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSuppression(
  x,
  candidates = 1:ncol(x),
  primary = NULL,
  forced = NULL,
  hidden = NULL,
  singleton = rep(FALSE, nrow(x)),
  singletonMethod = "anySum",
  printInc = TRUE,
  tolGauss = (.Machine$double.eps)^(1/2),
  whenEmptySuppressed = warning,
  whenEmptyUnsuppressed = message,
  whenPrimaryForced = warning,
  removeDuplicated = TRUE,
  iFunction = GaussIterationFunction,
  iWait = Inf,
  xExtraPrimary = NULL,
  unsafeAsNegative = FALSE,
  printXdim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GaussSuppression_+3A_x">x</code></td>
<td>
<p>Matrix that relates cells to be published or suppressed to inner cells. yPublish = crossprod(x,yInner)</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_candidates">candidates</code></td>
<td>
<p>Indices of candidates for secondary suppression</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_primary">primary</code></td>
<td>
<p>Indices of primary suppressed cells</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_forced">forced</code></td>
<td>
<p>Indices forced to be not suppressed. <code>forced</code> has precedence over <code>primary</code>. See <code>whenPrimaryForced</code> below.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_hidden">hidden</code></td>
<td>
<p>Indices to be removed from the above <code>candidates</code> input (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_singleton">singleton</code></td>
<td>
<p>Logical or integer vector of length <code>nrow(x)</code> specifying inner cells for singleton handling.
Normally, for frequency tables, this means cells with 1s when 0s are non-suppressed and cells with 0s when 0s are suppressed.
For some singleton methods, integer values representing the unique magnitude table contributors are needed.
For all other singleton methods, only the values after conversion with <code>as.logical</code> matter.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p>Method for handling the problem of singletons and zeros:
<code>"anySum"</code> (default), <code>"anySum0"</code>, <code>"anySumNOTprimary"</code>, <code>"subSum"</code>, <code>"subSpace"</code>, <code>"sub2Sum"</code>, <code>"none"</code>
or a <code><a href="#topic+NumSingleton">NumSingleton</a></code> method (see details).</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when TRUE</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_tolgauss">tolGauss</code></td>
<td>
<p>A tolerance parameter for sparse Gaussian elimination and linear dependency. This parameter is used only in cases where integer calculation cannot be used.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenemptysuppressed">whenEmptySuppressed</code></td>
<td>
<p>Function to be called when empty input to primary suppressed cells is problematic. Supply NULL to do nothing.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenemptyunsuppressed">whenEmptyUnsuppressed</code></td>
<td>
<p>Function to be called when empty input to candidate cells may be problematic. Supply NULL to do nothing.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenprimaryforced">whenPrimaryForced</code></td>
<td>
<p>Function to be called if any forced cells are primary suppressed (suppression will be ignored). Supply NULL to do nothing.
The same function will also be called when there are forced cells marked as singletons (will be ignored).</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_removeduplicated">removeDuplicated</code></td>
<td>
<p>Specifies whether to remove duplicated columns and rows in <code>x</code> before running the main algorithm.
Removing duplicates results in a faster algorithm while generally maintaining the same results.
In some cases, singleton handling for magnitude tables may be affected.
In such cases, singleton handling will generally be improved.
Singletons are considered when removing duplicate rows, so not all duplicates are removed.
The available options for <code>removeDuplicated</code> are as follows:
</p>

<ul>
<li> <p><code>TRUE</code> (default): Removes both duplicate columns and rows.
</p>
</li>
<li> <p><code>FALSE</code>: No removal of duplicates.
</p>
</li>
<li> <p><code>"cols"</code>: Removes only duplicate columns.
</p>
</li>
<li> <p><code>"rows"</code>: Removes only duplicate rows.
</p>
</li>
<li> <p><code>"rows2"</code>: Removes only duplicate non-singleton rows in a way that preserves singleton handling.
</p>
</li>
<li><p> Combined possibilities: Variants can be combined with &quot;_&quot;. For example,
<code>"cols_rows"</code> is equivalent to <code>TRUE</code>,
and <code>"cols_rows2"</code> represents an alternative variant. Combining <code>"rows"</code> and <code>"rows2"</code> is possible, but superfluous calculations are then performed.
</p>
</li>
<li> <p><code>"test"</code>: A special variant for testing purposes. The four configurations <code>TRUE</code>, <code>FALSE</code>, <code>"cols_rows2"</code>, and <code>"rows"</code> are executed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_ifunction">iFunction</code></td>
<td>
<p>A function to be called during the iterations. See the default function, <code><a href="#topic+GaussIterationFunction">GaussIterationFunction</a></code>, for description of parameters.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_iwait">iWait</code></td>
<td>
<p>The minimum number of seconds between each call to <code>iFunction</code>.
Whenever <code>iWait&lt;Inf</code>, <code>iFunction</code> will also be called after last iteration.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_xextraprimary">xExtraPrimary</code></td>
<td>
<p>Extra x-matrix that defines extra primary suppressed cells in addition to those defined by other inputs.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_unsafeasnegative">unsafeAsNegative</code></td>
<td>
<p>When <code>TRUE</code>, unsafe primary cells due to forced cells are included in the output vector as negative indices.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_printxdim">printXdim</code></td>
<td>
<p>When set to <code>TRUE</code>, the <code>printInc</code> parameter is also automatically set to <code>TRUE</code>.
Additionally, the dimensions of the <code>x</code> matrix are printed twice:
first, the dimensions of the input <code>x</code>, potentially extended with <code>xExtraPrimary</code>;
second, the dimensions after applying <code>singletonMethod</code> and <code>removeDuplicated</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to specify too many (all) indices as <code>candidates</code>.
Indices specified as <code>primary</code> or <code>hidded</code> will be removed.
Hidden indices (not candidates or primary) refer to cells that will not be published, but do not need protection.
</p>

<ul>
<li> <p><strong>Singleton methods for frequency tables:</strong>
All singleton methods, except <code>"sub2Sum"</code> and the <code><a href="#topic+NumSingleton">NumSingleton</a></code> methods, have been implemented with frequency tables in mind.
The singleton method <code>"subSum"</code> makes new virtual primary suppressed cells, which are the sum of the singletons
within each group. The <code>"subSpace"</code> method is conservative and ignores the singleton dimensions when looking for
linear dependency. The default method, <code>"anySum"</code>, is between the other two. Instead of making virtual cells of
sums within groups, the aim is to handle all possible sums, also across groups. In addition, <code>"subSumSpace"</code>  and
<code>"subSumAny"</code> are possible methods, primarily for testing. These methods are similar to <code>"subSpace"</code> and <code>"anySum"</code>,
and additional cells are created as in <code>"subSum"</code>. It is believed that the extra cells are redundant.
Note that in order to give information about unsafe cells, <code>"anySum"</code>  is internally changed to <code>"subSumAny"</code> when there are forced cells.
All the above methods assume that any published singletons are primary suppressed.
If this is not the case, either <code>"anySumNOTprimary"</code> or <code>"anySum0"</code> must be used.
Notably, <code>"anySum0"</code> is an enhancement of <code>"anySumNOTprimary"</code> for situations where zeros are singletons.
Using that method avoids suppressing a zero marginal along with only one of its children.
</p>
</li>
<li> <p><strong>Singleton methods for magnitude tables:</strong>
The singleton method <code>"sub2Sum"</code> makes new virtual primary suppressed cells, which are the sum of two inner cells.
This is done when a group contains exactly two primary suppressed inner cells provided that at least one of them is singleton.
This was the first method implemented. Other magnitude methods follow the coding according to <code><a href="#topic+NumSingleton">NumSingleton</a></code>.
The <code>"sub2Sum"</code> method is equivalent to <code>"numFFT"</code>.
Also note that <code>"num"</code>, <code>"numFFF"</code> and <code>"numFTF"</code> are equivalent to <code>"none"</code>.
</p>
</li>
<li> <p><strong>Combined:</strong>
For advanced use, <code>singleton</code> can be a two-element list with names <code>"freq"</code> and <code>"num"</code>.
Then <code>singletonMethod</code> must be a corresponding named two-element vector.
For example: <code>singletonMethod = c(freq = "anySumNOTprimary", num = "sub2Sum")</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Secondary suppression indices
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2024):
&ldquo;Secondary Cell Suppression by Gaussian Elimination: An Algorithm Suitable for Handling Issues with Zeros and Singletons&rdquo;.
Presented at: <em>Privacy in statistical databases</em>, Antibes, France. September 25-27, 2024.
<a href="https://doi.org/10.1007/978-3-031-69651-0_6">doi:10.1007/978-3-031-69651-0_6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Input data
df &lt;- data.frame(values = c(1, 1, 1, 5, 5, 9, 9, 9, 9, 9, 0, 0, 0, 7, 7), 
                 var1 = rep(1:3, each = 5), 
                 var2 = c("A", "B", "C", "D", "E"), stringsAsFactors = FALSE)

# Make output data frame and x 
fs &lt;- FormulaSums(df, values ~ var1 * var2, crossTable = TRUE, makeModelMatrix = TRUE)
x &lt;- fs$modelMatrix
datF &lt;- data.frame(fs$crossTable, values = as.vector(fs$allSums))

# Add primary suppression 
datF$primary &lt;- datF$values
datF$primary[datF$values &lt; 5 &amp; datF$values &gt; 0] &lt;- NA
datF$suppressedA &lt;- datF$primary
datF$suppressedB &lt;- datF$primary
datF$suppressedC &lt;- datF$primary

# zero secondary suppressed
datF$suppressedA[GaussSuppression(x, primary = is.na(datF$primary))] &lt;- NA

# zero not secondary suppressed by first in ordering
datF$suppressedB[GaussSuppression(x, c(which(datF$values == 0), which(datF$values &gt; 0)), 
                            primary = is.na(datF$primary))] &lt;- NA

# with singleton
datF$suppressedC[GaussSuppression(x, c(which(datF$values == 0), which(datF$values &gt; 0)), 
                            primary = is.na(datF$primary), singleton = df$values == 1)] &lt;- NA

datF

</code></pre>

<hr>
<h2 id='HierarchicalGroups'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups'></span>

<h3>Description</h3>

<p>According to the (factor) levels of the variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups(
  x = NULL,
  mainName = TRUE,
  eachName = FALSE,
  fCorr = FactorLevCorr(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchicalGroups_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_mainname">mainName</code></td>
<td>
<p>When TRUE output list is named according to first variable in group.</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_eachname">eachName</code></td>
<td>
<p>When TRUE variable names in output instead of indices.</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_fcorr">fCorr</code></td>
<td>
<p>When non-null, x is not needed as input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list containing the groups. First variable has most levels.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
HierarchicalGroups(dataset[1:2], eachName = TRUE)
HierarchicalGroups(dataset[2:3])
HierarchicalGroups(dataset[1:4], eachName = TRUE)

HierarchicalGroups(SSBtoolsData("magnitude1")[1:4])

 x &lt;- rep(c("A","B","C"),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep="")
 m &lt;- cbind(x,y,z,zy)
 HierarchicalGroups(m)
</code></pre>

<hr>
<h2 id='HierarchicalGroups2'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups2'></span>

<h3>Description</h3>

<p>As HierarchicalGroups() with eachName = TRUE, but output belonging to same mainName are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchicalGroups2_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the groups.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='HierarchicalGroups3'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups3'></span>

<h3>Description</h3>

<p>As HierarchicalGroups() with eachName = FALSE, but output belonging to same mainName are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchicalGroups3_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the groups.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='HierarchicalWildcardGlobbing'>Find variable combinations by advanced wildcard/globbing specifications.</h2><span id='topic+HierarchicalWildcardGlobbing'></span>

<h3>Description</h3>

<p>Find combinations present in an input data frame or, when input is a list,
find all possible combinations that meet the requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalWildcardGlobbing(
  z,
  wg,
  useUnique = NULL,
  useFactor = FALSE,
  makeWarning = TRUE,
  printInfo = FALSE,
  useMatrixToDataFrame = TRUE,
  invert = "!"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_z">z</code></td>
<td>
<p>list or data.frame</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_wg">wg</code></td>
<td>
<p>data.frame with data globbing and wildcards</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_useunique">useUnique</code></td>
<td>
<p>Logical variable about recoding within the algorithm. By default (NULL) an automatic decision is made.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_usefactor">useFactor</code></td>
<td>
<p>When TRUE, internal factor recoding is used.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_makewarning">makeWarning</code></td>
<td>
<p>When TRUE, warning is made in cases of unused variables. Only variables common to z and wg are used.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_printinfo">printInfo</code></td>
<td>
<p>When TRUE, information is printed during the process.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>When TRUE, special functions (DataFrameToMatrix/MatrixToDataFrame)
for improving speed and memory is utilized.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_invert">invert</code></td>
<td>
<p>Character to invert each single selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The final variable combinations must meet the requirements in each positive sign group
and must not match the requirements in the negative sign groups.The function is implemented by
calling <code><a href="#topic+WildcardGlobbing">WildcardGlobbing</a></code> several times within an algorithm that uses
hierarchical clustering (<code><a href="stats.html#topic+hclust">hclust</a></code>).
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                  
# useUnique=NULL betyr valg ut fra antall rader i kombinasjonsfil
data(precip)
data(mtcars)
codes &lt;- as.character(c(100, 200, 300, 600, 700, 101, 102, 103, 104, 134, 647, 783, 
                        13401, 13402, 64701, 64702))


# Create list input
zList &lt;- list(car = rownames(mtcars), wt = as.character(1000 * mtcars$wt), 
              city = names(precip), code = codes)

# Create data.frame input
m &lt;- cbind(car = rownames(mtcars), wt = as.character(1000 * mtcars$wt))
zFrame &lt;- data.frame(m[rep(1:NROW(m), each = 35), ], 
                     city = names(precip), code = codes, stringsAsFactors = FALSE)

# Create globbing/wildcards input
wg &lt;- data.frame(rbind(c("Merc*", ""    , ""    , "?00"  ), 
                       c("F*"   , ""    , ""    , "?????"), 
                       c(""     , "???0", "C*"  , ""     ), 
                       c(""     , ""    , "!Co*", ""     ), 
                       c(""     , ""    , "?i*" , "????2"), 
                       c(""     , ""    , "?h*" , "????1")), 
           sign = c("+", "+", "+", "+", "-", "-"), stringsAsFactors = FALSE)
names(wg)[1:4] &lt;- names(zList)



# =================================================================== 
#   Finding unique combinations present in the input data frame
# ===================================================================


# Using first row of wg. Combinations of car starting with Merc 
# and three-digit code ending with 00
HierarchicalWildcardGlobbing(zFrame[, c(1, 4)], wg[1, c(1, 4, 5)])

# Using first row of wg. Combinations of all four variables
HierarchicalWildcardGlobbing(zFrame, wg[1, ])

# More combinations when using second row also
HierarchicalWildcardGlobbing(zFrame, wg[1:2, ])

# Less combinations when using third row also 
# since last digit of wt must be 0 and only cities starting with C
HierarchicalWildcardGlobbing(zFrame, wg[1:3, ])


# Less combinations when using fourth row also since city cannot start with Co
HierarchicalWildcardGlobbing(zFrame, wg[1:4, ])

# Less combinations when using fourth row also 
# since specific combinations of city and code are removed
HierarchicalWildcardGlobbing(zFrame, wg)


# =================================================================== 
#  Using list input to create all possible combinations
# ===================================================================

dim(HierarchicalWildcardGlobbing(zList, wg))

# same result with as.list since same unique values of each variable
dim(HierarchicalWildcardGlobbing(as.list(zFrame), wg))
</code></pre>

<hr>
<h2 id='hierarchies_as_vars'>Hierarchies coded as variables</h2><span id='topic+hierarchies_as_vars'></span>

<h3>Description</h3>

<p>The hierarchical relations are stored as minimal datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchies_as_vars(
  hierarchies,
  name_function = function(name, level) paste0(name, "_level_", level),
  single_vars = FALSE,
  from_dummy = NA,
  dummy_reorder = TRUE,
  combine_vars = TRUE,
  drop_codes = NULL,
  include_codes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchies_as_vars_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies in the same format as input to <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code></p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_name_function">name_function</code></td>
<td>
<p>A function defining how to name all columns except the first.
The input consists of the hierarchy name (identical to the first column’s name, <code>name</code>)
and the column number minus 1 (<code>level</code>).</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_single_vars">single_vars</code></td>
<td>
<p>When <code>TRUE</code>, a single variable is created for all codes except the input codes.</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_from_dummy">from_dummy</code></td>
<td>
<p>Logical value indicating the method for handling hierarchies.
</p>

<ul>
<li><p> When <code>TRUE</code>, the algorithm uses dummy-coded hierarchies.
</p>
</li>
<li><p> When <code>FALSE</code>, the algorithm works directly on hierarchies standardized by <code>AutoHierarchies</code>, often resulting in well-structured output variables.
</p>
</li>
<li><p> When <code>NA</code> (default), the algorithm first attempts the <code>FALSE</code> method; if not feasible, it falls back to the <code>TRUE</code> method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_dummy_reorder">dummy_reorder</code></td>
<td>
<p>When <code>TRUE</code>, dummy-coded hierarchies are reordered to potentially improve the structure of output variables.</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_combine_vars">combine_vars</code></td>
<td>
<p>When <code>TRUE</code>, an algorithm is applied to potentially reduce the number of output variables needed.</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_drop_codes">drop_codes</code></td>
<td>
<p>A named list of codes (except the input codes) to be dropped from the output.
The list must have the same names as the hierarchies, but not all names/elements need to be included.</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_include_codes">include_codes</code></td>
<td>
<p>Similar to drop_codes, but specifies the codes to be included instead.</p>
</td></tr>
<tr><td><code id="hierarchies_as_vars_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of data frames
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vars_to_hierarchies">vars_to_hierarchies</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples based on those from AutoHierarchies
# You may also try converting other examples from AutoHierarchies

z &lt;- SSBtoolsData("sprt_emp_withEU")
year_formula &lt;- c("y_14 = 2014", "y_15_16 = y_all - y_14", "y_all = 2014 + 2015 + 2016")
geo_dim_list &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]
age_hierarchy &lt;- SSBtoolsData("sprt_emp_ageHier")

hierarchies_as_vars(list(age = age_hierarchy, geo = geo_dim_list, year = year_formula))
hierarchies_as_vars(list(age = age_hierarchy, geo = geo_dim_list, year = year_formula), 
                    singleVars = TRUE)
                    
# NAs are included in data when necessary
hierarchies_as_vars(list(f = c("AB = A + B", "AC = A + C", "CD = C + D", "ABCD = AB + CD")))                     

# drop_codes and include_codes  
hierarchies_as_vars(list(age = age_hierarchy, geo = geo_dim_list, year = year_formula), 
                    drop_codes = list(geo = "nonEU", year = c("y_14", "y_all")))  
hierarchies_as_vars(list(age = age_hierarchy, geo = geo_dim_list, year = year_formula), 
                    include_codes = list(year = c("y_14", "y_all")))      
               
</code></pre>

<hr>
<h2 id='Hierarchies2ModelMatrix'>Model matrix representing crossed hierarchies</h2><span id='topic+Hierarchies2ModelMatrix'></span>

<h3>Description</h3>

<p>Make a model matrix, x, that corresponds to data and represents all hierarchies crossed.
This means that aggregates corresponding to numerical variables can be computed as
<code>t(x) %*% y</code>, where  <code>y</code> is a matrix with one column for each numerical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hierarchies2ModelMatrix(
  data,
  hierarchies,
  inputInOutput = TRUE,
  crossTable = FALSE,
  total = "Total",
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  unionComplement = FALSE,
  reOrder = TRUE,
  select = NULL,
  removeEmpty = FALSE,
  selectionByMultiplicationLimit = 10^7,
  makeColnames = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hierarchies2ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.
Also see note.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_total">total</code></td>
<td>
<p>See <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code></p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code></p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (default) output codes are ordered in a way similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output
or a named list specifying code selections for each variable (see details).</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When TRUE and when <code>select</code> is not a data frame, empty columns (only zeros) are not included in output.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_selectionbymultiplicationlimit">selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>select</code> and when the number of elements in the model matrix exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_makecolnames">makeColnames</code></td>
<td>
<p>Colnames included when TRUE (default).</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>
and <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>  via  <code><a href="#topic+HierarchyComputeDummy">HierarchyComputeDummy</a></code>.
Since the dummy matrix is transposed in comparison to <code>HierarchyCompute</code>, the parameter <code>rowSelect</code> is renamed to <code>select</code>
and  <code>makeRownames</code> is renamed to <code>makeColnames</code>.
</p>
<p>The select parameter as a list can be partially specified in the sense that not all hierarchy names have to be included.
The parameter <code>inputInOutput</code> will only apply to hierarchies that are not in the <code>select</code> list (see note).
</p>


<h3>Value</h3>

<p>A sparse model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Note</h3>

<p>The <code>select</code> as a list is run via a special coding of the <code>inputInOutput</code> parameter.
This parameter is converted into a list (<code>as.list</code>) and <code>select</code> elements are inserted into this list.
This is also an additional option for users of the function.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>, <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sprt_emp_withEU")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]


# First example has list output
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE, 
                        crossTable = TRUE)


m1 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE)
m2 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList))
m3 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = ""),
                              inputInOutput = FALSE)
m4 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = "allYears"), 
                              inputInOutput = c(FALSE, FALSE, TRUE))

# Illustrate the effect of unionComplement, geoHier2 as in the examples of HierarchyCompute
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  SSBtoolsData("sprt_emp_geoHier")[, -4])
m5 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE)  # Spain is counted twice
m6 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE, unionComplement = TRUE)


# Compute aggregates
ths_per &lt;- as.matrix(z[, "ths_per", drop = FALSE])  # matrix with the values to be aggregated
Matrix::t(m1) %*% ths_per  # Matrix::crossprod(m1, ths_per) is equivalent and faster
Matrix::t(m2) %*% ths_per
Matrix::t(m3) %*% ths_per
Matrix::t(m4) %*% ths_per
Matrix::t(m5) %*% ths_per
Matrix::t(m6) %*% ths_per


# Example using the select parameter as a data frame
select &lt;- data.frame(age = c("Y15-64", "Y15-29", "Y30-64"), geo = c("EU", "nonEU", "Spain"))
m2a &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), select = select)

# Same result by slower alternative
m2B &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), crossTable = TRUE)
m2b &lt;- m2B$modelMatrix[, Match(select, m2B$crossTable), drop = FALSE]
Matrix::t(m2b) %*% ths_per

# Examples using the select parameter as a list
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       inputInOutput = FALSE, 
       select = list(geo = c("nonEU", "Portugal")))
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       select = list(geo = c("nonEU", "Portugal"), age = c("Y15-64", "Y15-29")))

</code></pre>

<hr>
<h2 id='HierarchiesAndFormula2ModelMatrix'>Model matrix representing crossed hierarchies according to a formula</h2><span id='topic+HierarchiesAndFormula2ModelMatrix'></span>

<h3>Description</h3>

<p>How to cross the hierarchies are defined by a formula. The formula is automatically simplified when totals are involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchiesAndFormula2ModelMatrix(
  data,
  hierarchies,
  formula,
  inputInOutput = TRUE,
  makeColNames = TRUE,
  crossTable = FALSE,
  total = "Total",
  simplify = TRUE,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  unionComplement = FALSE,
  removeEmpty = FALSE,
  reOrder = TRUE,
  sep = "-",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_makecolnames">makeColNames</code></td>
<td>
<p>Colnames included when TRUE (default).</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_total">total</code></td>
<td>
<p>Vector of total codes (possibly recycled) used when running <code><a href="#topic+Hrc2DimList">Hrc2DimList</a></code></p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_simplify">simplify</code></td>
<td>
<p>When TRUE (default) the model can be simplified when total codes are found in the hierarchies (see examples).</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code></p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When TRUE, empty columns (only zeros) are not included in output.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (default) output codes are ordered in a way similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_sep">sep</code></td>
<td>
<p>String to separate when creating column names</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>, <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sprt_emp_withEU")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]

# Shorter function name
H &lt;- HierarchiesAndFormula2ModelMatrix

# Small dataset example. Two dimensions.
s &lt;- z[z$geo == "Spain", ]
geoYear &lt;- list(geo = geoDimList, year = "")
m &lt;- H(s, geoYear, ~geo * year, inputInOutput = c(FALSE, TRUE))
print(m, col.names = TRUE)
attr(m, "total")     # Total code 'Europe' is found
attr(m, "startCol")  # Two model terms needed

# Another model and with crossTable in output
H(s, geoYear, ~geo + year, crossTable = TRUE)

# Without empty columns  
H(s, geoYear, ~geo + year, crossTable = TRUE, removeEmpty = TRUE)

# Three dimensions
ageGeoYear &lt;- list(age = ageHier, geo = geoDimList, year = "allYears")
m &lt;- H(z, ageGeoYear, ~age * geo + geo * year)
head(colnames(m))
attr(m, "total")
attr(m, "startCol")

# With simplify = FALSE
m &lt;- H(z, ageGeoYear, ~age * geo + geo * year, simplify = FALSE)
head(colnames(m))
attr(m, "total")
attr(m, "startCol")

# Compute aggregates
m &lt;- H(z, ageGeoYear, ~geo * age, inputInOutput = c(TRUE, FALSE, TRUE))
Matrix::t(m) %*% z$ths_per

# Without hierarchies. Only factors.
ageGeoYearFactor &lt;- list(age = "", geo = "", year = "")
Matrix::t(H(z, ageGeoYearFactor, ~geo * age + year:geo))
</code></pre>

<hr>
<h2 id='Hierarchy2Formula'>Hierarchy2Formula</h2><span id='topic+Hierarchy2Formula'></span><span id='topic+Formula2Hierarchy'></span><span id='topic+Hierarchies2Formulas'></span>

<h3>Description</h3>

<p>Conversion between to-from coded hierarchy and formulas written with =, - and +.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hierarchy2Formula(
  x,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level")
)

Formula2Hierarchy(s)

Hierarchies2Formulas(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hierarchy2Formula_+3A_x">x</code></td>
<td>
<p>Data frame with to-from coded hierarchy</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_s">s</code></td>
<td>
<p>Character vector of formulas written with =, - and +.</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_...">...</code></td>
<td>
<p>Extra parameters. Only <code>hierarchyVarNames</code> is relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See Arguments
</p>


<h3>Note</h3>

<p><code>Hierarchies2Formulas</code> is a wrapper for <code>lapply(x, Hierarchy2Formula, ...)</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_geoHier")
s &lt;- Hierarchy2Formula(x)
s
Formula2Hierarchy(s)

# Demonstrate Hierarchies2Formulas and problems 
hi &lt;- FindHierarchies(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")])
hi
Hierarchies2Formulas(hi) # problematic formula since minus sign in coding 
AutoHierarchies(Hierarchies2Formulas(hi)) # Not same as hi because of problems 

# Change coding to avoid problems 
hi$age$mapsFrom &lt;- gsub("-", "_", hi$age$mapsFrom)
hi
Hierarchies2Formulas(hi)
AutoHierarchies(Hierarchies2Formulas(hi))

</code></pre>

<hr>
<h2 id='HierarchyCompute'>Hierarchical Computations</h2><span id='topic+HierarchyCompute'></span>

<h3>Description</h3>

<p>This function computes aggregates by crossing several hierarchical specifications and factorial variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyCompute(
  data,
  hierarchies,
  valueVar,
  colVar = NULL,
  rowSelect = NULL,
  colSelect = NULL,
  select = NULL,
  inputInOutput = FALSE,
  output = "data.frame",
  autoLevel = TRUE,
  unionComplement = FALSE,
  constantsInOutput = NULL,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  selectionByMultiplicationLimit = 10^7,
  colNotInDataWarning = TRUE,
  useMatrixToDataFrame = TRUE,
  handleDuplicated = "sum",
  asInput = FALSE,
  verbose = FALSE,
  reOrder = FALSE,
  reduceData = TRUE,
  makeRownames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchyCompute_+3A_data">data</code></td>
<td>
<p>The input data frame</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_hierarchies">hierarchies</code></td>
<td>
<p>A named (names in <code>data</code>) list with hierarchies. Variables can also be coded by <code>"rowFactor"</code> and <code>"colFactor"</code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_valuevar">valueVar</code></td>
<td>
<p>Name of the variable(s) to be aggregated.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colvar">colVar</code></td>
<td>
<p>When non-NULL, the function <code><a href="#topic+HierarchyCompute2">HierarchyCompute2</a></code> is called. See its documentation for more information.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_rowselect">rowSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is not included.
In addition <code>rowSelect="removeEmpty"</code> removes combinations corresponding to empty rows (only zeros) of <code>dataDummyHierarchy</code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colselect">colSelect</code></td>
<td>
<p>Vector specifying categories of the colFactor variable for output.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is included.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_output">output</code></td>
<td>
<p>One of &quot;data.frame&quot; (default), &quot;dummyHierarchies&quot;, &quot;outputMatrix&quot;, &quot;dataDummyHierarchy&quot;, &quot;valueMatrix&quot;, &quot;fromCrossCode&quot;,
&quot;toCrossCode&quot;, &quot;crossCode&quot; (as toCrossCode), &quot;outputMatrixWithCrossCode&quot;, &quot;matrixComponents&quot;,
&quot;dataDummyHierarchyWithCodeFrame&quot;, &quot;dataDummyHierarchyQuick&quot;.
The latter two do not require <code>valueVar</code> (<code>reduceData</code> set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_autolevel">autoLevel</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, level is computed by automatic method as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction as in <code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_constantsinoutput">constantsInOutput</code></td>
<td>
<p>A single row data frame to be combine by the other output.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_selectionbymultiplicationlimit">selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>rowSelect</code> and when the number of elements in <code>dataDummyHierarchy</code> exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colnotindatawarning">colNotInDataWarning</code></td>
<td>
<p>When TRUE, warning produced when elements of <code>colSelect</code> are not in data.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>When TRUE (default) special functionality for saving time and memory is used.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_handleduplicated">handleDuplicated</code></td>
<td>
<p>Handling of duplicated code rows in data. One of: &quot;sum&quot; (default), &quot;sumByAggregate&quot;, &quot;sumWithWarning&quot;, &quot;stop&quot; (error), &quot;single&quot; or &quot;singleWithWarning&quot;.
With no colFactor sum and sumByAggregate/sumWithWarning are different (original values or aggregates in &quot;valueMatrix&quot;).
When single, only one of the values is used (by matrix subsetting).</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_asinput">asInput</code></td>
<td>
<p>When TRUE (FALSE is default) output matrices match input data. Thus
<code>valueMatrix</code> <code>=</code> <code>Matrix(data[, valueVar],ncol=1)</code>. Only possible when no colFactor.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (FALSE is default) output codes are ordered differently, more similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_reducedata">reduceData</code></td>
<td>
<p>When TRUE (default) unnecessary (for the aggregated result) rows of <code>valueMatrix</code> are allowed to be removed.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_makerownames">makeRownames</code></td>
<td>
<p>When TRUE <code>dataDummyHierarchy</code> contains rownames. By default, this is decided based on the parameter <code>output</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A key element of this function is the matrix multiplication:
<code>outputMatrix</code> <code>=</code> <code>dataDummyHierarchy</code> <code>%*%</code> <code>valueMatrix</code>.
The matrix, <code>valueMatrix</code> is a re-organized version of the valueVar vector from input. In particular,
if a variable is selected as <code>colFactor</code>, there is one column for each level of that variable.
The matrix, <code>dataDummyHierarchy</code> is constructed by crossing dummy coding of hierarchies (<code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code>) and factorial variables
in a way that matches <code>valueMatrix</code>.  The code combinations corresponding to rows and columns of <code>dataDummyHierarchy</code>
can be obtained as <code>toCrossCode</code> and <code>fromCrossCode</code>.  In the default data frame output, the <code>outputMatrix</code> is stacked
to one column and combined with the code combinations of all variables.
</p>


<h3>Value</h3>

<p>As specified by the parameter <code>output</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data and hierarchies used in the examples
x &lt;- SSBtoolsData("sprt_emp")  # Employment in sport in thousand persons from Eurostat database
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

# Two hierarchies and year as rowFactor
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per")

# Same result with year as colFactor (but columns ordered differently)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per")

# Internally the computations are different as seen when output='matrixComponents'
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 output = "matrixComponents")
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")


# Include input age groups by setting inputInOutput = TRUE for this variable
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 inputInOutput = c(TRUE, FALSE))

# Only input age groups by switching to rowFactor
HierarchyCompute(x, list(age = "rowFactor", geo = geoHier, year = "colFactor"), "ths_per")

# Select some years (colFactor) including a year not in input data (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 colSelect = c("2014", "2016", "2018"))

# Select combinations of geo and age including a code not in data or hierarchy (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 rowSelect = data.frame(geo = "EU", age = c("Y0-100", "Y15-64", "Y15-29")))
                 
# Select combinations of geo, age and year 
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
     select = data.frame(geo = c("EU", "Spain"), age = c("Y15-64", "Y15-29"), year = 2015))

# Extend the hierarchy table to illustrate the effect of unionComplement 
# Omit level since this is handled by autoLevel
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  geoHier[, -4])

# Spain is counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per")

# Can be seen in the dataDummyHierarchy matrix
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")

# With unionComplement=TRUE Spain is not counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 unionComplement = TRUE)

# With constantsInOutput
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per",
                 constantsInOutput = data.frame(c1 = "AB", c2 = "CD"))
                 
# More that one valueVar
x$y &lt;- 10*x$ths_per
HierarchyCompute(x, list(age = ageHier, geo = geoHier), c("y", "ths_per"))
</code></pre>

<hr>
<h2 id='HierarchyCompute2'>Extended Hierarchical Computations</h2><span id='topic+HierarchyCompute2'></span>

<h3>Description</h3>

<p>Extended variant of <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code> with several column variables (not just <code>"colFactor"</code>).
Parameter colVar splits the hierarchy variables in two groups and this variable overrides the difference between <code>"rowFactor"</code> and <code>"colFactor"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyCompute2(
  data,
  hierarchies,
  valueVar,
  colVar,
  rowSelect = NULL,
  colSelect = NULL,
  select = NULL,
  output = "data.frame",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchyCompute2_+3A_data">data</code></td>
<td>
<p>The input data frame</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_hierarchies">hierarchies</code></td>
<td>
<p>A named list with hierarchies</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_valuevar">valueVar</code></td>
<td>
<p>Name of the variable(s) to be aggregated</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_colvar">colVar</code></td>
<td>
<p>Name of the column variable(s)</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_rowselect">rowSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_colselect">colSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_output">output</code></td>
<td>
<p>One of &quot;data.frame&quot; (default), &quot;outputMatrix&quot;, &quot;matrixComponents&quot;.</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within this function, <code>HierarchyCompute</code> is called two times.
By specifying output as <code>"matrixComponents"</code>,
output from the two runs are retuned as a list with elements <code>hcRow</code> and <code>hcCol</code>.
The matrix multiplication in HierarchyCompute is extended to
<code>outputMatrix</code> <code>=</code> <code>hcRow$dataDummyHierarchy</code>
<code>%*%</code> <code>hcRow$valueMatrix</code>
<code>%*%</code> <code>t(hcCol$dataDummyHierarchy)</code>.
This is modified in cases with more than a single <code>valueVar</code>.
</p>


<h3>Value</h3>

<p>As specified by the parameter <code>output</code>
</p>


<h3>Note</h3>

<p>There is no need to call <code>HierarchyCompute2</code> directly.
The main function <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>  can be used instead.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp")
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "year"))
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per",
                 colVar = c("age", "geo"))
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "year"), output = "matrixComponents")
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "geo"), output = "matrixComponents")

</code></pre>

<hr>
<h2 id='HierarchyComputeDummy'>HierarchyComputeDummy</h2><span id='topic+HierarchyComputeDummy'></span>

<h3>Description</h3>

<p>From hierarchies to a sparse model matrix with possible cross table by wrapping HierarchyCompute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyComputeDummy(
  data,
  hierarchies,
  inputInOutput = TRUE,
  crossTable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchyComputeDummy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_hierarchies">hierarchies</code></td>
<td>
<p>hierarchies</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a special wrapper of <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code> and the input argument hierarchies is specified the same way.
That is, variables can also be coded by <code>"rowFactor"</code>  ( but not colFactor).
</p>


<h3>Value</h3>

<p>A sparse model matrix or a list of model matrix and cross table
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data and hierarchies used in the examples
x &lt;- SSBtoolsData("sprt_emp")  # Employment in sport in thousand persons from Eurostat database
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
HierarchyComputeDummy(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), 
                      inputInOutput = FALSE, crossTable = TRUE)
</code></pre>

<hr>
<h2 id='HierarchyFix'>Change the hierarchy table to follow the standard</h2><span id='topic+HierarchyFix'></span>

<h3>Description</h3>

<p>Make sure that variable names and sign coding follow an internal standard. Level may be computed automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyFix(
  hierarchy,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  autoLevel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierarchyFix_+3A_hierarchy">hierarchy</code></td>
<td>
<p>data frame with hierarchy table</p>
</td></tr>
<tr><td><code id="HierarchyFix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>variable names</p>
</td></tr>
<tr><td><code id="HierarchyFix_+3A_autolevel">autoLevel</code></td>
<td>
<p>When TRUE, level is computed by automatic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with hierarchy table
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make input data by changing variable names and sign coding.
h &lt;- SSBtoolsData("FIFA2018ABCD")[, 1:3]
names(h)[1:2] &lt;- c("from", "to")
minus &lt;- h$sign &lt; 0
h$sign &lt;- "+"
h$sign[minus] &lt;- "-"

# Run HierarchyFix - Two levels created
HierarchyFix(h, c(mapsFrom = "from", mapsTo = "to", sign = "sign"))

# Extend the hierarchy table
h2 &lt;- rbind(data.frame(from = c("Oceania", "Asia", "Africa", "America", "Europe"),
                       to = "World", sign = "+"),
           data.frame(from = c("World", "Europe"),
                      to = "nonEurope", sign = c("+", "-")), h)

# Run HierarchyFix - Three levels created
HierarchyFix(h2, c(mapsFrom = "from", mapsTo = "to", sign = "sign"))

</code></pre>

<hr>
<h2 id='inc_default'>Default progress indicator function</h2><span id='topic+inc_default'></span>

<h3>Description</h3>

<p>Default progress indicator function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_default(i = 0L, n = 0L, steps = 25L, dot = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inc_default_+3A_i">i</code></td>
<td>
<p>i in &quot;i out of n&quot;</p>
</td></tr>
<tr><td><code id="inc_default_+3A_n">n</code></td>
<td>
<p>n in &quot;i out of n&quot;</p>
</td></tr>
<tr><td><code id="inc_default_+3A_steps">steps</code></td>
<td>
<p>Number of dots to print</p>
</td></tr>
<tr><td><code id="inc_default_+3A_dot">dot</code></td>
<td>
<p>dot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in 1:5) inc_default(i, 5)
cat("\n")
for (i in 1:100) inc_default(i, 100)
cat("\n")
for (i in 1:1000) inc_default(i, 1000)
cat("\n")
for (i in 1:1000) inc_default(i, 1000, steps = 10)
cat("\n")
for (i in 1:10) inc_default()
cat("\n")
</code></pre>

<hr>
<h2 id='LSfitNonNeg'>Non-negative regression fits with a sparse overparameterized model matrix</h2><span id='topic+LSfitNonNeg'></span>

<h3>Description</h3>

<p>Assuming  <code>z = t(x) %*% y  + noise</code>, a non-negatively modified least squares estimate of <code>t(x) %*% y</code> is made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSfitNonNeg(x, z, limit = 1e-10, viaQR = FALSE, printInc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSfitNonNeg_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_z">z</code></td>
<td>
<p>A single column matrix</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_limit">limit</code></td>
<td>
<p>Lower limit for non-zero fits. Set to <code>NULL</code> or <code>-Inf</code> to avoid the non-zero restriction.</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_viaqr">viaQR</code></td>
<td>
<p>Least squares fits obtained using <code><a href="base.html#topic+qr">qr</a></code> when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The problem is first reduced by elimination some rows of <code>x</code>  (elements of <code>y</code>) using <code><a href="#topic+GaussIndependent">GaussIndependent</a></code>.
Thereafter least squares fits are obtained using <code><a href="base.html#topic+solve">solve</a></code> or <code><a href="base.html#topic+qr">qr</a></code>.
Possible negative fits will be forced to zero in the next estimation iteration(s).
</p>


<h3>Value</h3>

<p>A fitted version of <code>z</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data2 &lt;- SSBtoolsData("z2")
x &lt;- ModelMatrix(data2, formula = ~fylke + kostragr * hovedint - 1)
z &lt;- Matrix::t(x) %*% data2$ant + rnorm(ncol(x), sd = 3)
LSfitNonNeg(x, z)
LSfitNonNeg(x, z, limit = NULL)

## Not run: 
mf &lt;- ~region*mnd + hovedint*mnd + fylke*hovedint*mnd + kostragr*hovedint*mnd
data4 &lt;- SSBtoolsData("sosialFiktiv")
x &lt;- ModelMatrix(data4, formula = mf)
z &lt;- Matrix::t(x) %*% data4$ant + rnorm(ncol(x), sd = 3)
zFit &lt;- LSfitNonNeg(x, z)

## End(Not run)
</code></pre>

<hr>
<h2 id='MakeFreq'>Microdata frequency data conversion</h2><span id='topic+MakeFreq'></span><span id='topic+MakeMicro'></span>

<h3>Description</h3>

<p>Microdata frequency data conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeFreq(x, freqName = "freq", all = FALSE, hierarchies = FALSE)

MakeMicro(x, freqVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeFreq_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_freqname">freqName</code></td>
<td>
<p>Name of new frequency variable in output data</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_all">all</code></td>
<td>
<p>Whether to include level combinations not in microdata (zero frequency)</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_hierarchies">hierarchies</code></td>
<td>
<p>Whether to treat hierarchical variables automatically when  <code>all=TRUE</code></p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_freqvar">freqVar</code></td>
<td>
<p>The frequency variable in input data, name or number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp")[c(1, 2, 4, 7:12, 15, 17, 18), -4]
z$eu &lt;- z$geo != "Iceland"
z

MakeFreq(z)
MakeFreq(z[, -2])
MakeFreq(z[, -(2:3)])
MakeFreq(z[, -1])
MakeFreq(z[, -1], all = TRUE)

x &lt;- MakeFreq(z[, -1], all = TRUE, hierarchies = TRUE)
x

MakeMicro(x, "freq")
</code></pre>

<hr>
<h2 id='MakeHierFormula'>Make model formula from data taking into account hierarchical variables</h2><span id='topic+MakeHierFormula'></span>

<h3>Description</h3>

<p>Make model formula from data taking into account hierarchical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeHierFormula(
  data = NULL,
  hGroups = HierarchicalGroups2(data),
  n = length(hGroups),
  sim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeHierFormula_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_hgroups">hGroups</code></td>
<td>
<p>Output from HierarchicalGroups2()</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_n">n</code></td>
<td>
<p>Interaction level or 0 (all levels)</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_sim">sim</code></td>
<td>
<p>Include &quot;~&quot; when TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formula as character string
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_withEU")[, -4]
MakeHierFormula(x)
MakeHierFormula(x, n = 2)
MakeHierFormula(x, n = 0)
</code></pre>

<hr>
<h2 id='map_hierarchies_to_data'>Add variables to dataset based on hierarchies</h2><span id='topic+map_hierarchies_to_data'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+hierarchies_as_vars">hierarchies_as_vars</a></code> to transform hierarchies, followed by mapping to the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_hierarchies_to_data(
  data,
  hierarchies,
  when_overwritten = warning,
  add_comment = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_hierarchies_to_data_+3A_data">data</code></td>
<td>
<p>A data frame containing variables with names matching the names of the hierarchies.</p>
</td></tr>
<tr><td><code id="map_hierarchies_to_data_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies in the same format as input to <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code></p>
</td></tr>
<tr><td><code id="map_hierarchies_to_data_+3A_when_overwritten">when_overwritten</code></td>
<td>
<p>A function to be called when existing column(s) are overwritten.
Supply <code>stop</code> to invoke an error, <code>warning</code> for a warning (default),
<code>message</code> to display an informational message, or <code>NULL</code> to do nothing.</p>
</td></tr>
<tr><td><code id="map_hierarchies_to_data_+3A_add_comment">add_comment</code></td>
<td>
<p>Logical. When <code>TRUE</code> (default), a comment attribute will be added to the output data frame,
containing the names of the variables that were added.</p>
</td></tr>
<tr><td><code id="map_hierarchies_to_data_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="#topic+hierarchies_as_vars">hierarchies_as_vars</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input <code>data</code> with extra Variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Examples similar those from hierarchies_as_vars

z &lt;- SSBtoolsData("sprt_emp_withEU")
year_formula &lt;- c("y_14 = 2014", "y_15_16 = y_all - y_14", "y_all = 2014 + 2015 + 2016")
geo_dim_list &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]
age_hierarchy &lt;- SSBtoolsData("sprt_emp_ageHier")

map_hierarchies_to_data(z, list(age = age_hierarchy, geo = geo_dim_list, 
                                year = year_formula))

map_hierarchies_to_data(data.frame(f = c("A", "B", "C", "D", "E", "A")), list(f = 
       c("AB = A + B", "AC = A + C", "CD = C + D", "ABCD = AB + CD")))
       
       
# Examples demonstrating when_overwritten and add_comment        
       
a &lt;- map_hierarchies_to_data(z, list(age = age_hierarchy, geo = geo_dim_list))
comment(a)

b &lt;- map_hierarchies_to_data(a[-7], list(age = age_hierarchy, geo = geo_dim_list), 
                             when_overwritten = message, add_comment = FALSE)
comment(b)

</code></pre>

<hr>
<h2 id='Match'>Matching rows in data frames</h2><span id='topic+Match'></span>

<h3>Description</h3>

<p>The algorithm is based on converting variable combinations to whole numbers.
The final matching is performed using <code><a href="base.html#topic+match">match</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Match(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Match_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Match_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the result of multiplying together the number of unique values in each column of x exceeds 9E15
(largest value stored exactly by the numeric data type), the algorithm is recursive.
</p>


<h3>Value</h3>

<p>An integer vector giving the position in y of the first match if there is a match, otherwise NA.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- data.frame(x = c("a", "b", "c"), y = c("A", "B"), z = 1:6)
b &lt;- data.frame(x = c("b", "c"), y = c("B", "K", "A", "B"), z = c(2, 3, 5, 6))

Match(a, b)
Match(b, a)

# Slower alternative
match(data.frame(t(a), stringsAsFactors = FALSE), data.frame(t(b), stringsAsFactors = FALSE))
match(data.frame(t(b), stringsAsFactors = FALSE), data.frame(t(a), stringsAsFactors = FALSE))

# More comprehensive example (n, m and k may be changed)
n &lt;- 10^4
m &lt;- 10^3
k &lt;- 10^2
data(precip)
data(mtcars)
y &lt;- data.frame(car = sample(rownames(mtcars), n, replace = TRUE), 
                city = sample(names(precip), n, replace = TRUE),
                n = rep_len(1:k, n), a = rep_len(c("A", "B", "C", "D"), n),
                b = rep_len(as.character(rnorm(1000)), n),
                d = sample.int(k + 10, n, replace = TRUE),
                e = paste(sample.int(k * 2, n, replace = TRUE), 
                          rep_len(c("Green", "Red", "Blue"), n), sep = "_"),
                r = rnorm(k)^99)
x &lt;- y[sample.int(n, m), ]
row.names(x) &lt;- NULL
ix &lt;- Match(x, y)
</code></pre>

<hr>
<h2 id='matlabColon'>Simulate Matlab's ':'</h2><span id='topic+matlabColon'></span><span id='topic+SeqInc'></span>

<h3>Description</h3>

<p>Functions to generate increasing sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlabColon(from, to)

SeqInc(from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matlabColon_+3A_from">from</code></td>
<td>
<p>numeric. The start value</p>
</td></tr>
<tr><td><code id="matlabColon_+3A_to">to</code></td>
<td>
<p>numeric. The end value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>matlabColon(a,b) returns a:b (R's version) unless a &gt; b, in which case it returns integer(0).
SeqInc(a,b) is similar, but results in error when the calculated length of the sequence (1+to-from) is negative.
</p>


<h3>Value</h3>

<p>A numeric vector, possibly empty.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik (matlabColon) and Øyvind Langsrud (SeqInc)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identical(3:5, matlabColon(3, 5)) ## =&gt; TRUE
3:1 ## =&gt; 3 2 1
matlabColon(3, 1) ## =&gt; integer(0)
try(SeqInc(3, 1)) ## =&gt; Error
SeqInc(3, 2)      ## =&gt; integer(0)
</code></pre>

<hr>
<h2 id='Matrix2list'>Convert matrix to sparse list</h2><span id='topic+Matrix2list'></span><span id='topic+Matrix2listInt'></span>

<h3>Description</h3>

<p>Convert matrix to sparse list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix2list(x)

Matrix2listInt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Matrix2list_+3A_x">x</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the function, the input matrix is first converted to a dgTMatrix matrix (Matrix package).
</p>


<h3>Value</h3>

<p>A two-element list: List of row numbers (r) and a list of numeric or integer values (x)
</p>


<h3>Note</h3>

<p><code>Matrix2listInt</code> convers the values to integers by <code>as.integer</code>
and no checking is performed. Thus, zeros are possible.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(c(0.5, 1.1, 3.14, 0, 0, 0, 0, 4, 5), 3, 3)
Matrix2list(m)
Matrix2listInt(m)
</code></pre>

<hr>
<h2 id='MatrixPaste'>Combining columns of a matrix</h2><span id='topic+MatrixPaste'></span><span id='topic+MatrixPaste1'></span>

<h3>Description</h3>

<p>Combining columns of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixPaste(x, sep = "_", forceCharacter = FALSE, stringEmpty = " ")

MatrixPaste1(x, stringEmpty = "1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatrixPaste_+3A_x">x</code></td>
<td>
<p>Matrix or vector</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_sep">sep</code></td>
<td>
<p>String used to combine columns</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_forcecharacter">forceCharacter</code></td>
<td>
<p>When FALSE single column input will keep to original class in output.</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_stringempty">stringEmpty</code></td>
<td>
<p>String used when input is empty (can be set to NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in input will be combined to a single string using sep.
</p>


<h3>Value</h3>

<p>Character vector or possibly same vector as input
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MatrixPaste(matrix(1:12,3,4))
MatrixPaste(1:5)
MatrixPaste(1:5, forceCharacter=TRUE)
MatrixPaste(matrix(integer(0),3,0))
MatrixPaste(NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='MatrixToDataFrame'>MatrixToDataFrame</h2><span id='topic+MatrixToDataFrame'></span>

<h3>Description</h3>

<p>MatrixToDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixToDataFrame(x, forceStringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatrixToDataFrame_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="MatrixToDataFrame_+3A_forcestringsasfactors">forceStringsAsFactors</code></td>
<td>
<p>forceStringsAsFactors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='max_contribution'>Find Major Contributions to Aggregates and Count Contributors</h2><span id='topic+max_contribution'></span><span id='topic+n_contributors'></span>

<h3>Description</h3>

<p>These functions analyze contributions to aggregates, assuming that the aggregates are calculated
using a dummy matrix with the formula: <code>z = t(x) %*% y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_contribution(
  x,
  y,
  n = 1,
  id = NULL,
  output = "y",
  drop = TRUE,
  decreasing = TRUE,
  remove_fraction = NULL,
  do_abs = TRUE
)

n_contributors(x, y = rep(1L, nrow(x)), id = NULL, output = "n_contr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_contribution_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_y">y</code></td>
<td>
<p>A numeric vector of input values (contributions).</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_n">n</code></td>
<td>
<p>Integer. The number of largest contributors to identify for each aggregate.
Default is 1.</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_id">id</code></td>
<td>
<p>An optional vector for grouping. When non-NULL, major contributions are
found after aggregation within each group specified by <code>id</code>.
Aggregates with missing <code>id</code> values are excluded.</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_output">output</code></td>
<td>
<p>A character vector specifying the desired output. Possible values:
</p>

<ul>
<li> <p><code>"y"</code>: A matrix with the largest contributions in the first column, the second largest in the second column, and so on.
</p>
</li>
<li> <p><code>"id"</code>: A matrix of IDs associated with the largest contributions. If an <code>id</code> vector is provided, it returns these IDs; otherwise, it returns indices.
</p>
</li>
<li> <p><code>"n_contr"</code>: An integer vector indicating the number of contributors to each aggregate.
</p>
</li>
<li> <p><code>"n_0_contr"</code>: An integer vector indicating the number of contributors that contribute a value of 0 to each aggregate.
</p>
</li>
<li> <p><code>"n_non0_contr"</code>: An integer vector indicating the number of contributors that contribute a nonzero value to each aggregate.
</p>
</li>
<li> <p><code>"sums"</code>: A numeric vector containing the aggregate sums of <code>y</code>.
</p>
</li>
<li> <p><code>"n_contr_all"</code>, <code>"n_0_contr_all"</code>, <code>"n_non0_contr_all"</code>, <code>"sums_all"</code>:
Same as the corresponding outputs above, but without applying the <code>remove_fraction</code> parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="max_contribution_+3A_drop">drop</code></td>
<td>
<p>Logical. If TRUE (default) and <code>output</code> has length 1,
the function returns the single list element directly instead of a list containing one element.</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. If TRUE (default), finds the largest contributors.
If FALSE, finds the smallest contributors.</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_remove_fraction">remove_fraction</code></td>
<td>
<p>A numeric vector containing values in the interval <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, specifying contributors to be removed when identifying the largest contributions.
</p>

<ul>
<li><p> If an <code>id</code> vector is provided, <code>remove_fraction</code> must be named according to the IDs of the contributors to be removed.
</p>
</li>
<li><p> If no <code>id</code> vector is provided, the length of <code>remove_fraction</code> must match the length of <code>y</code>. In this case, contributors not to be removed should have a value of <code>NA</code> in <code>remove_fraction</code>.
</p>
</li>
<li><p> The actual values in <code>remove_fraction</code> are used for calculating <code>"sums"</code> (see description above).
</p>
</li></ul>
</td></tr>
<tr><td><code id="max_contribution_+3A_do_abs">do_abs</code></td>
<td>
<p>Logical. If TRUE (default), uses the absolute values of the summed contributions.
The summation is performed for all contributions from the same contributor,
within each aggregate being computed.</p>
</td></tr>
<tr><td><code id="max_contribution_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>max_contribution</code>  (used by <code>n_contributors</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>max_contribution</code> function identifies the largest contributions to these aggregates, while
the wrapper function <code>n_contributors</code> is designed specifically to count the number of contributors
for each aggregate.
</p>


<h3>Value</h3>

<p>A list or a single element, depending on the values of the <code>output</code> and <code>drop</code> parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- SSBtoolsData("magnitude1")
a &lt;- ModelMatrix(z, formula = ~sector4 + geo, crossTable = TRUE)

cbind(a$crossTable, 
      y =  max_contribution(x = a$modelMatrix, y = z$value, n = 2), 
      id = max_contribution(x = a$modelMatrix, y = z$value, n = 2, output = "id"),
      n =  n_contributors(  x = a$modelMatrix, y = z$value, n = 2))

cbind(a$crossTable, 
      y = max_contribution(x = a$modelMatrix, y = z$value, n = 3, id = z$company), 
      id = max_contribution(a$modelMatrix, z$value, 3, id = z$company, output = "id"))

max_contribution(x = a$modelMatrix, 
                 y = z$value, 
                 n = 3, 
                 id = z$company, 
                 output = c("y", "id", "n_contr", "sums"))

as.data.frame(
  max_contribution(x = a$modelMatrix, 
                   y = z$value, 
                   n = 3, 
                   id = z$company, 
                   output = c("y", "id", "n_contr", "sums", "n_contr_all", "sums_all"), 
                   remove_fraction = c(B = 1)))

</code></pre>

<hr>
<h2 id='Mipf'>Iterative proportional fitting from matrix input</h2><span id='topic+Mipf'></span>

<h3>Description</h3>

<p>The linear equation, <code>z = t(x) %*% y</code>, is (hopefully)  solved for <code>y</code> by
iterative proportional fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mipf(
  x,
  z = NULL,
  iter = 100,
  yStart = matrix(1, nrow(x), 1),
  eps = 0.01,
  tol = 1e-10,
  reduceBy0 = FALSE,
  reduceByColSums = FALSE,
  reduceByLeverage = FALSE,
  returnDetails = FALSE,
  y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mipf_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="Mipf_+3A_z">z</code></td>
<td>
<p>a single column matrix</p>
</td></tr>
<tr><td><code id="Mipf_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="Mipf_+3A_ystart">yStart</code></td>
<td>
<p>a starting estimate of <code>y</code></p>
</td></tr>
<tr><td><code id="Mipf_+3A_eps">eps</code></td>
<td>
<p>stopping criterion. Maximum allowed value of <code>max(abs(z - t(x) %*% yHat))</code></p>
</td></tr>
<tr><td><code id="Mipf_+3A_tol">tol</code></td>
<td>
<p>Another stopping criterion. Maximum absolute difference between two iterations.</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reduceby0">reduceBy0</code></td>
<td>
<p>When TRUE, <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> used within the function</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reducebycolsums">reduceByColSums</code></td>
<td>
<p>Parameter to <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> (when TRUE)</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reducebyleverage">reduceByLeverage</code></td>
<td>
<p>Parameter to <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> (when TRUE)</p>
</td></tr>
<tr><td><code id="Mipf_+3A_returndetails">returnDetails</code></td>
<td>
<p>More output when TRUE.</p>
</td></tr>
<tr><td><code id="Mipf_+3A_y">y</code></td>
<td>
<p>It is possible to set <code>z</code> to NULL and supply original <code>y</code> instead  (<code>z = t(x) %*% y</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm will work similar to <code><a href="stats.html#topic+loglin">loglin</a></code> when the input x-matrix is a overparameterized model matrix
– as can be created by <code><a href="#topic+ModelMatrix">ModelMatrix</a></code> and <code><a href="#topic+FormulaSums">FormulaSums</a></code>. See Examples.
</p>


<h3>Value</h3>

<p><code>yHat</code>, the estimate of <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data2 &lt;- SSBtoolsData("z2")
x &lt;- ModelMatrix(data2, formula = ~fylke + kostragr * hovedint - 1)
z &lt;- Matrix::t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z)

#############################
# loglm comparison  
#############################

if (require(MASS)){

# Increase accuracy
yHat &lt;- Mipf(x, z, eps = 1e-04)

# Run loglm and store fitted values in a data frame
outLoglm &lt;- loglm(ant ~ fylke + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Problem 1: Variable region not in output, but instead the variable .Within.  
# Problem 2: Extra zeros since hierarchy not treated. Impossible combinations in output.

# By sorting data, it becomes clear that the fitted values are the same.
max(abs(sort(dfLoglm$Freq, decreasing = TRUE)[1:nrow(data2)] - sort(yHat, decreasing = TRUE)))

# Modify so that region is in output. Problem 1 avoided.
x &lt;- ModelMatrix(data2, formula = ~region + kostragr * hovedint - 1)
z &lt;- Matrix::t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z, eps = 1e-04)
outLoglm &lt;- loglm(ant ~ region + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Now it is possible to merge data
merg &lt;- merge(cbind(data2, yHat), dfLoglm)

# Identical output
max(abs(merg$yHat - merg$Freq))

}

## End(Not run)

#############################
# loglin comparison  
#############################


# Generate input data for loglin
n &lt;- 5:9
tab &lt;- array(sample(1:prod(n)), n)

# Input parameters
iter &lt;- 20
eps &lt;- 1e-05

# Estimate yHat by loglin
out &lt;- loglin(tab, list(c(1, 2), c(1, 3), c(1, 4), c(1, 5), c(2, 3, 4), c(3, 4, 5)), 
              fit = TRUE, iter = iter, eps = eps)
yHatLoglin &lt;- matrix(((out$fit)), ncol = 1)

# Transform the data for input to Mipf
df &lt;- as.data.frame.table(tab)
names(df)[1:5] &lt;- c("A", "B", "C", "D", "E")
x &lt;- ModelMatrix(df, formula = ~A:B + A:C + A:D + A:E + B:C:D + C:D:E - 1)
z &lt;- Matrix::t(x) %*% df$Freq

# Estimate yHat by Mipf
yHatPMipf &lt;- Mipf(x, z, iter = iter, eps = eps)

# Maximal absolute difference
max(abs(yHatPMipf - yHatLoglin))

# Note: loglin reports one iteration extra 

# Another example. Only one iteration needed.
max(abs(Mipf(x = FormulaSums(df, ~A:B + C - 1), 
             z = FormulaSums(df, Freq ~ A:B + C -1)) 
             - matrix(loglin(tab, list(1:2, 3), fit = TRUE)$fit, ncol = 1)))


#########################################
# Examples utilizing Reduce0exact 
#########################################

z3 &lt;- SSBtoolsData("z3")
x &lt;- ModelMatrix(z3, formula = ~region + kostragr * hovedint + region * mnd2 + fylke * mnd + 
                     mnd * hovedint + mnd2 * fylke * hovedint - 1)

# reduceBy0, but no iteration improvement. Identical results.
t &lt;- 360
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- Matrix::t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 0.1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 0.1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 0.1)
max(abs(a1 - a2))
max(abs(a1 - a3))


## Not run: 
# Improvement by reduceByColSums. Changing eps and iter give more similar results.
t &lt;- 402
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- Matrix::t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))


# Improvement by ReduceByLeverage. Changing eps and iter give more similar results.
t &lt;- 378
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- Matrix::t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
a4 &lt;- Mipf(x, z, reduceByLeverage = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))
max(abs(a1 - a4))


# Example with small eps and "Iteration stopped since tol reached"
t &lt;- 384
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- Matrix::t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1e-14)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1e-14)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1e-14)
max(abs(a1 - a2))
max(abs(a1 - a3))

## End(Not run)

# All y-data found by reduceByColSums (0 iterations). 
t &lt;- 411
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- Matrix::t(x) %*% y
a1 &lt;- Mipf(x, z)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE)
max(abs(a1 - y))
max(abs(a2 - y))
max(abs(a3 - y))
</code></pre>

<hr>
<h2 id='model_aggregate'>Hierarchical aggregation via model specification</h2><span id='topic+model_aggregate'></span>

<h3>Description</h3>

<p>Internally a dummy/model matrix is created according to the model specification.
This model matrix is used in the aggregation process via matrix multiplication and/or the function <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_aggregate(
  data,
  sum_vars = NULL,
  fun_vars = NULL,
  fun = NULL,
  hierarchies = NULL,
  formula = NULL,
  dim_var = NULL,
  total = NULL,
  input_in_output = NULL,
  remove_empty = NULL,
  avoid_hierarchical = NULL,
  preagg_var = NULL,
  dummy = TRUE,
  pre_aggregate = dummy,
  aggregate_pkg = "base",
  aggregate_na = TRUE,
  aggregate_base_order = FALSE,
  list_return = FALSE,
  pre_return = FALSE,
  verbose = TRUE,
  mm_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_aggregate_+3A_data">data</code></td>
<td>
<p>Input data containing data to be aggregated, typically a data frame, tibble, or data.table.
If data is not a classic data frame, it will be coerced to one internally.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_sum_vars">sum_vars</code></td>
<td>
<p>Variables to be summed. This will be done via matrix multiplication.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_fun_vars">fun_vars</code></td>
<td>
<p>Variables to be aggregated by supplied functions.
This will be done via <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code> and <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code> and
<code>fun_vars</code> is specified as the parameter <code>vars</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_fun">fun</code></td>
<td>
<p>The <code>fun</code>         parameter to <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_hierarchies">hierarchies</code></td>
<td>
<p>The <code>hierarchies</code> parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_formula">formula</code></td>
<td>
<p>The <code>formula</code>     parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_dim_var">dim_var</code></td>
<td>
<p>The <code>dimVar</code>      parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_total">total</code></td>
<td>
<p>When non-NULL, the <code>total</code> parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>.
Thus, the actual default value is <code>"Total"</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_input_in_output">input_in_output</code></td>
<td>
<p>When non-NULL, the <code>inputInOutput</code> parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>.
Thus, the actual default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_remove_empty">remove_empty</code></td>
<td>
<p>When non-NULL, the <code>removeEmpty</code> parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>.
Thus, the actual default value is <code>TRUE</code> with formula input without hierarchy and
otherwise <code>FALSE</code> (see <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>).</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_avoid_hierarchical">avoid_hierarchical</code></td>
<td>
<p>When non-NULL, the <code>avoidHierarchical</code> parameter to <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code>,
which is an underlying function of <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_preagg_var">preagg_var</code></td>
<td>
<p>Extra variables to be used as grouping elements in the pre-aggregate step</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_dummy">dummy</code></td>
<td>
<p>The <code>dummy</code>       parameter to <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>.
When <code>TRUE</code>, only 0s and 1s are assumed in the generated model matrix.
When <code>FALSE</code>, non-0s in this matrix are passed as an additional first input parameter to the <code>fun</code> functions.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_pre_aggregate">pre_aggregate</code></td>
<td>
<p>Whether to pre-aggregate data to reduce the dimension of the model matrix.
Note that all original <code>fun_vars</code> observations are retained in the aggregated dataset and <code>pre_aggregate</code> does not affect the final result.
However, <code>pre_aggregate</code> must be set to <code>FALSE</code> when the <code>dummy_aggregate</code> parameter <code>dummy</code> is set to <code>FALSE</code>
since then <code><a href="base.html#topic+unlist">unlist</a></code> will not be run.
An exception to this is if the <code>fun</code> functions are written to handle list data.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_aggregate_pkg">aggregate_pkg</code></td>
<td>
<p>Package used to pre-aggregate.
Parameter <code>pkg</code> to <code><a href="#topic+aggregate_by_pkg">aggregate_by_pkg</a></code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_aggregate_na">aggregate_na</code></td>
<td>
<p>Whether to include NAs in the grouping variables while preAggregate.
Parameter <code>include_na</code> to <code><a href="#topic+aggregate_by_pkg">aggregate_by_pkg</a></code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_aggregate_base_order">aggregate_base_order</code></td>
<td>
<p>Parameter <code>base_order</code> to <code><a href="#topic+aggregate_by_pkg">aggregate_by_pkg</a></code>, used when pre-aggregate.
The default is set to <code>FALSE</code> to avoid unnecessary sorting operations.
When <code>TRUE</code>, an attempt is made to return the same result with <code>data.table</code> as with base R.
This cannot be guaranteed due to potential variations in sorting behavior across different systems.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_list_return">list_return</code></td>
<td>
<p>Whether to return a list of separate components including the model matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_pre_return">pre_return</code></td>
<td>
<p>Whether to return the pre-aggregate data as a two-component list. Can also be combined with <code>list_return</code> (see examples).</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_mm_args">mm_args</code></td>
<td>
<p>List of further arguments passed to <code>ModelMatrix</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>dummy_aggregate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With formula input, limited output can be achieved by <code><a href="#topic+formula_selection">formula_selection</a></code> (see example).
An attribute called <code>startCol</code> has been added to the output data frame to make this functionality work.
</p>


<h3>Value</h3>

<p>A data frame or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"
names(z)[names(z) == "ths_per"] &lt;- "ths"
z$y &lt;- 1:18

my_range &lt;- function(x) c(min = min(x), max = max(x))

out &lt;- model_aggregate(z, 
   formula = ~age:year + geo, 
   sum_vars = c("y", "ths"), 
   fun_vars = c(sum = "ths", mean = "y", med = "y", ra = "ths"), 
   fun = c(sum = sum, mean = mean, med = median, ra = my_range))

out

# Limited output can be achieved by formula_selection
formula_selection(out, ~geo)


# Using the single unnamed variable feature.
model_aggregate(z, formula = ~age, fun_vars = "y", 
                fun = c(sum = sum, mean = mean, med = median, n = length))


# To illustrate list_return and pre_return 
for (pre_return in c(FALSE, TRUE)) for (list_return in c(FALSE, TRUE)) {
  cat("\n=======================================\n")
  cat("list_return =", list_return, ", pre_return =", pre_return, "\n\n")
  out &lt;- model_aggregate(z, formula = ~age:year, 
                         sum_vars = c("ths", "y"), 
                         fun_vars = c(mean = "y", ra = "y"), 
                         fun = c(mean = mean, ra = my_range), 
                         list_return = list_return,
                         pre_return = pre_return)
  cat("\n")
  print(out)
}


# To illustrate preagg_var 
model_aggregate(z, formula = ~age:year, 
sum_vars = c("ths", "y"), 
fun_vars = c(mean = "y", ra = "y"), 
fun = c(mean = mean, ra = my_range), 
preagg_var = "eu",
pre_return = TRUE)[["pre_data"]]


# To illustrate hierarchies 
geo_hier &lt;- SSBtoolsData("sprt_emp_geoHier")
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"))

####  Special non-dummy cases illustrated below  ####

# Extend the hierarchy to make non-dummy model matrix  
geo_hier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), 
                              mapsTo = "EUandSpain", sign = 1), geo_hier[, -4])

# Warning since non-dummy
# y and y_sum are different 
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"))

# No warning since dummy since unionComplement = TRUE (see ?HierarchyCompute)
# y and y_sum are equal   
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"),
                mm_args = list(unionComplement = TRUE))

# Non-dummy again, but no warning since dummy = FALSE
# Then pre_aggregate is by default set to FALSE (error when TRUE) 
# fun with extra argument needed (see ?dummy_aggregate)
# y and y_sum2 are equal
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum2 = "y"),
                fun = c(sum2 = function(x, y) sum(x * y)),
                dummy = FALSE) 
                
</code></pre>

<hr>
<h2 id='Model_Matrix'>Overparameterized model matrix</h2><span id='topic+Model_Matrix'></span>

<h3>Description</h3>

<p>All factor levels included
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model_Matrix(
  formula,
  data = NULL,
  mf = model.frame(formula, data = data),
  allFactor = TRUE,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model_Matrix_+3A_formula">formula</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_mf">mf</code></td>
<td>
<p>model frame (alternative input instead of data)</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_allfactor">allFactor</code></td>
<td>
<p>When TRUE all variables are coerced to factor</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_sparse">sparse</code></td>
<td>
<p>When TRUE sparse matrix created by sparse.model.matrix()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example:
</p>
<p><code>z &lt;- SSBtoolsData("sp_emp_withEU")</code>
</p>
<p><code>SSBtools:::Model_Matrix(~age*year + geo, z)</code>
</p>


<h3>Value</h3>

<p>model matrix created via model.matrix() or sparse.model.matrix()
</p>

<hr>
<h2 id='ModelMatrix'>Model matrix from hierarchies and/or a formula</h2><span id='topic+ModelMatrix'></span><span id='topic+NamesFromModelMatrixInput'></span>

<h3>Description</h3>

<p>A common interface to <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> and <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelMatrix(
  data,
  hierarchies = NULL,
  formula = NULL,
  inputInOutput = TRUE,
  crossTable = FALSE,
  sparse = TRUE,
  viaOrdinary = FALSE,
  total = "Total",
  removeEmpty = !is.null(formula) &amp; is.null(hierarchies),
  modelMatrix = NULL,
  dimVar = NULL,
  select = NULL,
  ...
)

NamesFromModelMatrixInput(
  data = NULL,
  hierarchies = NULL,
  formula = NULL,
  dimVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Sparse matrix in output when TRUE (default)</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_viaordinary">viaOrdinary</code></td>
<td>
<p>When TRUE, output is generated by <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> or <code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code>.
Since these functions omit a factor level, an empty factor level is first added.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_total">total</code></td>
<td>
<p>String(s) used to name totals</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When <code>TRUE</code>, empty columns (only zeros) are not included in output.
Default is <code>TRUE</code> with formula input without hierarchy and otherwise <code>FALSE</code> (see details).</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_modelmatrix">modelMatrix</code></td>
<td>
<p>The model matrix as input (same as output)</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output
or a named list specifying code selections for each variable (see details).</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_...">...</code></td>
<td>
<p>Further arguments to  <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> or <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>removeEmpty</code> corresponds to the default settings of the underlying functions.
The functions <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code> and <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
have <code>removeEmpty</code> as an explicit parameter with <code>FALSE</code> as default.
The function <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> is a wrapper for <code><a href="#topic+FormulaSums">FormulaSums</a></code>,
which has a parameter <code>includeEmpty</code> with <code>FALSE</code> as default.
Thus, <code>ModelMatrix</code> makes a call to <code>Formula2ModelMatrix</code> with <code>includeEmpty = !removeEmpty</code>.
</p>
<p><code>NamesFromModelMatrixInput</code> returns the names of the data columns involved in creating the model matrix.
Note that <code>data</code> must be non-NULL to convert dimVar as indices to names.
</p>
<p>The <code>select</code> parameter is forwarded to <code>Hierarchies2ModelMatrix</code> unless <code>removeEmpty = TRUE</code> is combined with <code>select</code> as a data frame.
In all other cases, <code>select</code> is handled outside the underlying functions by making selections in the result.
Empty columns can be added to the model matrix when <code>removeEmpty = FALSE</code> (with warning).
</p>


<h3>Value</h3>

<p>A (sparse) model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><a href="#topic+formula_utils">formula_utils</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sp_emp_withEU")
ageHier &lt;- data.frame(mapsFrom = c("young", "old"), mapsTo = "Total", sign = 1)
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]

# Small dataset example. Two dimensions.
s &lt;- z[z$geo == "Spain" &amp; z$year != 2016, ]
rownames(s) &lt;- NULL
s

# via Hierarchies2ModelMatrix() and converted to ordinary matrix (not sparse)
ModelMatrix(s, list(age = ageHier, year = ""), sparse = FALSE)

# Hierarchies generated automatically. Then via Hierarchies2ModelMatrix()
ModelMatrix(s[, c(1, 4)])

# via Formula2ModelMatrix()
ModelMatrix(s, formula = ~age + year)

# via model.matrix() after adding empty factor levels
ModelMatrix(s, formula = ~age + year, sparse = FALSE, viaOrdinary = TRUE)

# via sparse.model.matrix() after adding empty factor levels
ModelMatrix(s, formula = ~age + year, viaOrdinary = TRUE)

# via HierarchiesAndFormula2ModelMatrix() and using different data and parameter settings
ModelMatrix(s, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * geo + year, 
            inputInOutput = FALSE, removeEmpty = TRUE, crossTable = TRUE)
ModelMatrix(s, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * geo + year, 
            inputInOutput = c(TRUE, FALSE), removeEmpty = FALSE, crossTable = TRUE)
ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * year + geo, 
            inputInOutput = c(FALSE, TRUE), crossTable = TRUE)
            
# via Hierarchies2ModelMatrix() using unnamed list element. See AutoHierarchies.             
colnames(ModelMatrix(z, list(age = ageHier, c(Europe = "geo", Allyears = "year", "eu"))))
colnames(ModelMatrix(z, list(age = ageHier, c("geo", "year", "eu")), total = c("t1", "t2")))

# Example using the select parameter as a data frame
select &lt;- data.frame(age = c("Total", "young", "old"), geo = c("EU", "nonEU", "Spain"))
ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
            select = select, crossTable = TRUE)$crossTable
            
# Examples using the select parameter as a list
ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE, 
            select = list(geo = c("nonEU", "Portugal")), crossTable = TRUE)$crossTable
ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
            select = list(geo = c("nonEU", "Portugal"), age = c("Total", "young")), 
            crossTable = TRUE)$crossTable

# Using NAomit parameter avalable in Formula2ModelMatrix()
s$age[1] &lt;- NA
ModelMatrix(s, formula = ~age + year)
ModelMatrix(s, formula = ~age + year, NAomit = FALSE)

</code></pre>

<hr>
<h2 id='Number'>Adding leading zeros</h2><span id='topic+Number'></span>

<h3>Description</h3>

<p>Adding leading zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Number(n, width = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Number_+3A_n">n</code></td>
<td>
<p>numeric vector of whole numbers</p>
</td></tr>
<tr><td><code id="Number_+3A_width">width</code></td>
<td>
<p>width</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Number(1:3)
</code></pre>

<hr>
<h2 id='NumSingleton'>Decoding of <code>singletonMethod</code></h2><span id='topic+NumSingleton'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> <code>singletonMethod</code> starting with <code>"num"</code> is decoded into separate characters.
Part of the theory for interpreting the 3rd, 4th, and 5th characters is discussed in Langsrud (2024).
To utilize possibly duplicated contributor IDs, the 2nd character must be <code>"T"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumSingleton(singletonMethod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NumSingleton_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p>String to be decoded. If necessary, the input string is extended with <code>F</code>'s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>F</code> means the feature is turned off.
Other characters have the following meaning:
</p>

<ol>
<li> <p><code>singleton2Primary</code> (1st character):
</p>

<ul>
<li> <p><code>T</code>: All singletons are forced to be primary suppressed.
</p>
</li>
<li> <p><code>t</code>: Non-published singletons are primary suppressed.
</p>
</li></ul>

</li>
<li> <p><code>integerUnique</code> (2nd character):
</p>

<ul>
<li> <p><code>T</code>: Integer values representing the unique contributors are utilized.  Error if <code>singleton</code> not supplied as integer.
</p>
</li>
<li> <p><code>t</code>: As <code>T</code> above, but instead of error, the feature is turned off  (as <code>F</code>) if <code>singleton</code> is not supplied as integer.
</p>
</li></ul>

</li>
<li> <p><code>sum2</code> (3rd character):
</p>

<ul>
<li> <p><code>T</code>: Virtual primary suppressed cells are made,
which are the sum of some suppressed inner cells and which can be divided into two components.
At least one component is singleton contributor. The other component may be an inner cell.
</p>
</li>
<li> <p><code>H</code>: As <code>T</code> above. And in addition, the other component can be any primary suppressed published cell.
This method may be computationally demanding for big data.
</p>
</li></ul>

</li>
<li> <p><code>elimination</code> (4th character):
</p>

<ul>
<li> <p><code>t</code>: The singleton problem will be handled by methodology implemented as a part of the Gaussian elimination algorithm.
</p>
</li>
<li> <p><code>m</code>: As <code>t</code> above. And in addition, a message will be printed to inform about problematic singletons.
Actual reveals will be calculated when <code>singleton2Primary = T</code> (1st character)
and when <code>singleton2Primary = t</code> yield the same result as <code>singleton2Primary = T</code>.
Problematic singletons can appear since the algorithm is not perfect in the sense that the elimination of rows may cause problems.
Such problems can be a reason not to switch off <code>sum2</code>.
</p>
</li>
<li> <p><code>w</code>: As <code>m</code> above, but <code>warning</code> instead of <code>message</code>.
</p>
</li>
<li> <p><code>T</code>, <code>M</code> and <code>W</code>: As <code>t</code>, <code>m</code> and <code>w</code> above.
In addition, the gauss elimination routine is allowed to run in parallel with different sortings
so that the problem of eliminated singleton rows is reduced.
</p>
</li>
<li> <p><code>f</code>: As <code>F</code>, which means that the elimination feature is turned off.
However, when possible, a message will provide information about actual reveals, similar to <code>m</code> above.
</p>
</li></ul>

</li>
<li> <p><code>combinations</code> (5th character):
</p>

<ul>
<li> <p><code>T</code>: This is a sort of extension of <code>singleton2Primary</code> which is relevant when both <code>integerUnique</code> and <code>elimination</code> are used.
For each unique singleton contributor, the method seeks to protect all linear combinations of singleton cells from the unique contributor.
Instead of construction new primary cells, protection is achieved as a part of the elimination procedure.
Technically this is implemented by extending the above <code>elimination</code> method.
It cannot be guaranteed that all problems are solved, and this is a reason not to turn off <code>singleton2Primary</code>.
Best performance is achieved when <code>elimination</code> is <code>T</code>, <code>M</code> or <code>W</code>.
</p>
</li>
<li> <p><code>t</code>:  As <code>T</code>, but without the added singleton protection.
This means that protected linear combinations cannot be calculated linearly from non-suppressed cells.
However, other contributors may still be able to recalculate these combinations using their own suppressed values.
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>A character vector or <code>NULL</code>
</p>


<h3>Note</h3>

<p>Note an update made in SSBtools version 1.7.5, which relates to this sentence in Langsrud (2024):
<em>&quot;The remaining non-zero rows for columns corresponding to primary cells must not originate solely from one contributor.&quot;</em>
Due to speed and memory considerations, the algorithm does not first perform elimination and then check the result.
Instead, it first verifies whether elimination is permissible before executing it.
This approach allows for a more thorough validation process compared to performing elimination with a fixed row order.
Specifically, this means that the singleton procedure, denoted as <code>elimination</code> (4th character),
can take into account different row orders.
Such an improvement was introduced in SSBtools version 1.7.5 after the publication of Langsrud (2024).
As a result, more potential issues can now be detected during
a single elimination sequence (<code>t</code> as the 4th character),
slightly reducing the need for double elimination (<code>T</code> as the 4th character).
However, since the row order influences subsequent elimination steps,
double elimination remains an important safeguard.
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2024):
&ldquo;Secondary Cell Suppression by Gaussian Elimination: An Algorithm Suitable for Handling Issues with Zeros and Singletons&rdquo;.
Presented at: <em>Privacy in statistical databases</em>, Antibes, France. September 25-27, 2024.
<a href="https://doi.org/10.1007/978-3-031-69651-0_6">doi:10.1007/978-3-031-69651-0_6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NumSingleton("numTFF")
NumSingleton("numFtT")
NumSingleton("numttH")
NumSingleton("numTTFTT")
</code></pre>

<hr>
<h2 id='quantile_weighted'>Weighted quantiles</h2><span id='topic+quantile_weighted'></span>

<h3>Description</h3>

<p>The default method (<code>type=2</code>) corresponds to weighted percentiles in SAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_weighted(
  x,
  probs = (0:4)/4,
  weights = rep(1, length(x)),
  type = 2,
  eps = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_weighted_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_type">type</code></td>
<td>
<p>An integer, <code>2</code> (default) or <code>5</code>. Similar to types 2 and 5 in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_eps">eps</code></td>
<td>
<p>Precision parameter used when <code>type=2</code> so that numerical inaccuracy is accepted (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type=2</code>, averaging is used in case of equal of probabilities.
Equal probabilities (<code>p[j]==probs[i]</code>) is determined by
<code>abs(1-p[j]/probs[i])&lt;eps</code>
with <code>p=cumsum(w)/sum(w)</code>
where <code>w=weights[order(x)]</code>.
</p>
<p>With zero length of <code>x</code>, <code>NA</code>s are returned.
</p>
<p>When all weights are zero and when when all <code>x</code>'s are not equal,
<code>NaN</code>s are returned except for the 0% and 100% quantiles.
</p>


<h3>Value</h3>

<p>Quantiles as a named numeric vector.
</p>


<h3>Note</h3>

<p>Type 2 similar to type 5 in <code>DescTools::Quantile</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(27)/5 + 1:27
w &lt;- (1:27)/27

quantile_weighted(x, (0:5)/5, weights = w)
quantile_weighted(x, (0:5)/5, weights = w, type = 5)

quantile_weighted(x) - quantile(x, type = 2)
quantile_weighted(x, type = 5) - quantile(x, type = 5)

</code></pre>

<hr>
<h2 id='RbindAll'>Combining several data frames when the columns don't match</h2><span id='topic+RbindAll'></span>

<h3>Description</h3>

<p>Combining several data frames when the columns don't match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RbindAll(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RbindAll_+3A_...">...</code></td>
<td>
<p>Several data frames as several input parameters or a list of data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single data frame
</p>


<h3>Note</h3>

<p>The function is an extended version of rbind.all.columns at
<a href="https://amywhiteheadresearch.wordpress.com/2013/05/13/combining-dataframes-when-the-columns-dont-match/">https://amywhiteheadresearch.wordpress.com/2013/05/13/combining-dataframes-when-the-columns-dont-match/</a>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CbindIdMatch">CbindIdMatch</a></code> (same example data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zA &lt;- data.frame(idA = 1:10, idB = rep(10 * (1:5), 2), idC = rep(c(100, 200), 5), 
                 idC2 = c(100, rep(200, 9)), idC3 = rep(100, 10), 
                 idD = 99, x = round(rnorm(10), 3), xA = round(runif(10), 2))
zB &lt;- data.frame(idB = 10 * (1:5), x = round(rnorm(5), 3), xB = round(runif(5), 2))
zC &lt;- data.frame(idC = c(100, 200), x = round(rnorm(2), 3), xC = round(runif(2), 2))
zD &lt;- data.frame(idD = 99, x = round(rnorm(1), 3), xD = round(runif(1), 2))
RbindAll(zA, zB, zC, zD)
RbindAll(list(zA, zB, zC, zD))
</code></pre>

<hr>
<h2 id='Reduce0exact'>Reducing a non-negative regression problem</h2><span id='topic+Reduce0exact'></span>

<h3>Description</h3>

<p>The linear equation problem, <code>z = t(x) %*% y</code> with y non-negative and x as a design (dummy) matrix,
is reduced to a smaller problem by identifying elements of <code>y</code> that can be found exactly from <code>x</code> and <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reduce0exact(
  x,
  z = NULL,
  reduceByColSums = FALSE,
  reduceByLeverage = FALSE,
  leverageLimit = 0.999999,
  digitsRoundWhole = 9,
  y = NULL,
  yStart = NULL,
  printInc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Reduce0exact_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_z">z</code></td>
<td>
<p>A single column matrix</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_reducebycolsums">reduceByColSums</code></td>
<td>
<p>See Details</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_reducebyleverage">reduceByLeverage</code></td>
<td>
<p>See Details</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_leveragelimit">leverageLimit</code></td>
<td>
<p>Limit to determine perfect fit</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_digitsroundwhole">digitsRoundWhole</code></td>
<td>
<p><code><a href="#topic+RoundWhole">RoundWhole</a></code> parameter for fitted values (when <code>leverageLimit</code> and <code>y</code> not in input)</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_y">y</code></td>
<td>
<p>A single column matrix. With <code>y</code> in input, <code>z</code> in input can be omitted and estimating <code>y</code> (when <code>leverageLimit</code>) is avoided.</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_ystart">yStart</code></td>
<td>
<p>A starting estimate when this function is combined with iterative proportional fitting. Zeros in yStart will be used to reduce the problem.</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_printinc">printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact elements can be identified in three ways in an iterative manner:
</p>

<ol>
<li><p> By zeros in <code>z</code>. This is always done.
</p>
</li>
<li><p> By columns in x with a singe nonzero value. Done when <code>reduceByColSums</code> or <code>reduceByLeverage</code> is <code>TRUE</code>.
</p>
</li>
<li><p> By exact linear regression fit (when leverage is one). Done when <code>reduceByLeverage</code> is <code>TRUE</code>.
The leverages are computed by <code>hat(as.matrix(x), intercept = FALSE)</code>, which can be very time and memory consuming.
Furthermore, without <code>y</code> in input, known values will be computed by <code><a href="MASS.html#topic+ginv">ginv</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A list of five elements:
</p>

<ul>
<li> <p><code>x</code>: A reduced version of input <code>x</code>
</p>
</li>
<li> <p><code>z</code>: Corresponding reduced <code>z</code>
</p>
</li>
<li> <p><code>yKnown</code>: Logical, specifying known values of <code>y</code>
</p>
</li>
<li> <p><code>y</code>: A version of <code>y</code> with known values correct and others zero
</p>
</li>
<li> <p><code>zSkipped</code>: Logical, specifying omitted columns of <code>x</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a special data set
d &lt;- SSBtoolsData("sprt_emp")
d$ths_per &lt;- round(d$ths_per)
d &lt;- rbind(d, d)
d$year &lt;- as.character(rep(2014:2019, each = 6))
to0 &lt;- rep(TRUE, 36)
to0[c(6, 14, 17, 18, 25, 27, 30, 34, 36)] &lt;- FALSE
d$ths_per[to0] &lt;- 0

# Values as a single column matrix
y &lt;- Matrix::Matrix(d$ths_per, ncol = 1)

# A model matrix using a special year hierarchy
x &lt;- Hierarchies2ModelMatrix(d, hierarchies = list(geo = "", age = "", year = 
    c("y1418 = 2014+2015+2016+2017+2018", "y1519 = 2015+2016+2017+2018+2019", 
      "y151719 = 2015+2017+2019", "yTotal = 2014+2015+2016+2017+2018+2019")), 
      inputInOutput = FALSE)

# Aggregates 
z &lt;- Matrix::t(x) %*% y
sum(z == 0)  # 5 zeros

# From zeros in z
a &lt;- Reduce0exact(x, z)
sum(a$yKnown)   # 17 zeros in y is known
dim(a$x)        # Reduced x, without known y and z with zeros 
dim(a$z)        # Corresponding reduced z 
sum(a$zSkipped) # 5 elements skipped 
Matrix::t(a$y)          # Just zeros (known are 0 and unknown set to 0) 

# It seems that three additional y-values can be found directly from z
sum(Matrix::colSums(a$x) == 1)

# But it is the same element of y (row 18)
a$x[18, Matrix::colSums(a$x) == 1]

# Make use of ones in colSums
a2 &lt;- Reduce0exact(x, z, reduceByColSums = TRUE)
sum(a2$yKnown)          # 18 values in y is known
dim(a2$x)               # Reduced x
dim(a2$z)               # Corresponding reduced z
a2$y[which(a2$yKnown)]  # The known values of y (unknown set to 0)

# Six ones in leverage values 
# Thus six extra elements in y can be found by linear estimation
hat(as.matrix(a2$x), intercept = FALSE)

# Make use of ones in leverages (hat-values)
a3 &lt;- Reduce0exact(x, z, reduceByLeverage = TRUE)
sum(a3$yKnown)          # 26 values in y is known (more than 6 extra)
dim(a3$x)               # Reduced x
dim(a3$z)               # Corresponding reduced z
a3$y[which(a3$yKnown)]  # The known values of y (unknown set to 0)

# More than 6 extra is caused by iteration 
# Extra checking of zeros in z after reduction by leverages 
# Similar checking performed also after reduction by colSums

</code></pre>

<hr>
<h2 id='RoundWhole'>Round values that are close two whole numbers</h2><span id='topic+RoundWhole'></span>

<h3>Description</h3>

<p>Round values that are close two whole numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoundWhole(x, digits = 9, onlyZeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RoundWhole_+3A_x">x</code></td>
<td>
<p>vector or matrix</p>
</td></tr>
<tr><td><code id="RoundWhole_+3A_digits">digits</code></td>
<td>
<p>parameter to <code><a href="base.html#topic+round">round</a></code></p>
</td></tr>
<tr><td><code id="RoundWhole_+3A_onlyzeros">onlyZeros</code></td>
<td>
<p>Only round values close to zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>digits</code> is <code>NA</code>, <code>Inf</code> or <code>NULL</code>, input is returned unmodified.
When there is more than one element in <code>digits</code> or <code>onlyZeros</code>,
rounding is performed column-wise.
</p>


<h3>Value</h3>

<p>Modified x
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.0002, 1.00003, 3.00014)
RoundWhole(x)     # No values rounded
RoundWhole(x, 4)  # One value rounded
RoundWhole(x, 3)  # All values rounded
RoundWhole(x, NA) # No values rounded (always)
RoundWhole(x, 3, TRUE)  # One value rounded
RoundWhole(cbind(x, x, x), digits = c(3, 4, NA))
RoundWhole(cbind(x, x), digits = 3, onlyZeros = c(FALSE, TRUE))
</code></pre>

<hr>
<h2 id='RowGroups'>Create numbering according to unique rows</h2><span id='topic+RowGroups'></span>

<h3>Description</h3>

<p>Create numbering according to unique rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RowGroups(
  x,
  returnGroups = FALSE,
  returnGroupsId = FALSE,
  NAomit = FALSE,
  pkg = "base"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RowGroups_+3A_x">x</code></td>
<td>
<p>Data frame or matrix</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_returngroups">returnGroups</code></td>
<td>
<p>When TRUE unique rows are returned</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_returngroupsid">returnGroupsId</code></td>
<td>
<p>When TRUE Index of unique rows are returned</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_naomit">NAomit</code></td>
<td>
<p>When <code>TRUE</code>, rows containing NAs are omitted, and the corresponding index numbers are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_pkg">pkg</code></td>
<td>
<p>A character string indicating which package to use.
Must be either <code>"base"</code> for base R or <code>"data.table"</code> for <code>data.table</code>. Default is <code>"base"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the numbering or, according to the arguments,
a list with more output.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(x = c("a", "b"), y = c("A", "B", "A"), z = rep(1:4, 3))
RowGroups(a)
RowGroups(a, TRUE)
RowGroups(a[, 1:2], TRUE, TRUE)
RowGroups(a[, 1, drop = FALSE], TRUE)
</code></pre>

<hr>
<h2 id='SortRows'>Sorting rows of a matrix or data frame</h2><span id='topic+SortRows'></span>

<h3>Description</h3>

<p>Sorting rows of a matrix or data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SortRows(m, cols = 1:dim(m)[2], index.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SortRows_+3A_m">m</code></td>
<td>
<p>matrix or data frame</p>
</td></tr>
<tr><td><code id="SortRows_+3A_cols">cols</code></td>
<td>
<p>Indexes of columns, in the desired order, used for sorting.</p>
</td></tr>
<tr><td><code id="SortRows_+3A_index.return">index.return</code></td>
<td>
<p>logical indicating if the ordering index vector should be
returned instead of sorted input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted <code>m</code> or a row index vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- SSBtoolsData("d2w")
SortRows(d[4:7])
SortRows(d, cols = 4:7)
SortRows(d, cols = c(2, 4))

SortRows(matrix(sample(1:3,15,TRUE),5,3))
</code></pre>

<hr>
<h2 id='sosialFiktiv'>Fictitious datasets returned by SSBtoolsData()</h2><span id='topic+sosialFiktiv'></span><span id='topic+z1'></span><span id='topic+z1micro'></span><span id='topic+z1w'></span><span id='topic+z2'></span><span id='topic+z2w'></span><span id='topic+z3'></span><span id='topic+z3w'></span><span id='topic+z3wb'></span>

<h3>Description</h3>

<p>The most comprehensive dataset, <code>sosialFiktiv</code>, contains three dimensions.
The first dimension is 'region' which is grouped in two ways, 'fylke' and
'kostragr'. The other two are 'hovedint' and 'mnd'. In 'mnd2' two of the
three categories in 'mnd' are merged.
The other datasets (<code>z1</code>, <code>z1w</code>, <code>z2</code>, <code>z2w</code>, <code>z3</code>,
<code>z3w</code>, <code>z3wb</code>) are smaller subdatasets.
Datasets marked with '<code>w</code>' are unstacked and several variables are holding counts.
</p>

<hr>
<h2 id='SSBtoolsData'>Function that returns a dataset</h2><span id='topic+SSBtoolsData'></span>

<h3>Description</h3>

<p>Function that returns a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSBtoolsData(dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSBtoolsData_+3A_dataset">dataset</code></td>
<td>
<p>Name of data set within the SSBtools package</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>FIFA2018ABCD:</strong> A hierarchy table based on
countries within groups A-D in the football championship, 2018 FIFA World Cup.
</p>
<p><strong>sprt_emp:</strong> Employment in sport in thousand persons. Data from Eurostat database.
</p>
<p><strong>sprt_emp_geoHier:</strong>  Country hierarchy for the employment in sport data.
</p>
<p><strong>sprt_emp_ageHier:</strong>  Age hierarchy for the employment in sport data.
</p>
<p><strong>sprt_emp_withEU:</strong> The data set sprt_emp extended with a EU variable.
</p>
<p><strong>sp_emp_withEU:</strong> As <code>sprt_emp_withEU</code>, but coded differently.
</p>
<p><strong>example1</strong> Example data similar to <code>sp_emp_withEU</code>.
</p>
<p><strong>magnitude1:</strong> Example data for magnitude tabulation. Same countries as above.
</p>
<p><strong>my_km2:</strong> Fictitious grid data.
</p>
<p><strong>mun_accidents:</strong> Fictitious traffic accident by municipality data.
</p>
<p><strong>sosialFiktiv, z1, z1w, z2, z2w, z3, z3w, z3wb:</strong> See <code><a href="#topic+sosialFiktiv">sosialFiktiv</a></code>.
</p>
<p><strong>d4, d1, d1w, d2, d2w, d3, d3w, d3wb:</strong> English translation of the datasets above.
</p>
<p><strong>d2s, d2ws:</strong> <code>d2</code> and <code>d2w</code> modified to smaller/easier data.
</p>
<p><strong>power10to1, power10to2, <code class="reqn">\ldots</code>:</strong> <code>power10to</code><code class="reqn">i</code> is hierarchical data with <code class="reqn">10^i</code> rows and <code class="reqn">2*i</code> columns.
Tip: Try <code>FindDimLists(SSBtoolsData("power10to3"))</code>
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Daniel Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SSBtoolsData("FIFA2018ABCD")
SSBtoolsData("sprt_emp")
SSBtoolsData("sprt_emp_geoHier")
SSBtoolsData("sprt_emp_ageHier")
SSBtoolsData("sprt_emp_withEU")
SSBtoolsData("d1w")
</code></pre>

<hr>
<h2 id='Stack'>Stack columns from a data frame and include variables.</h2><span id='topic+Stack'></span>

<h3>Description</h3>

<p>Stack columns from a data frame and include variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stack(
  data,
  stackVar = 1:NCOL(data),
  blockVar = integer(0),
  rowData = data.frame(stackVar)[, integer(0), drop = FALSE],
  valueName = "values",
  indName = "ind"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Stack_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Stack_+3A_stackvar">stackVar</code></td>
<td>
<p>Indices of variables to be stacked</p>
</td></tr>
<tr><td><code id="Stack_+3A_blockvar">blockVar</code></td>
<td>
<p>Indices of variables to be replicated</p>
</td></tr>
<tr><td><code id="Stack_+3A_rowdata">rowData</code></td>
<td>
<p>A separate data frame where NROW(rowData)=length(stackVar)
such that each row may contain multiple information of each stackVar variable.
The output data frame will contain an extended variant of rowData.</p>
</td></tr>
<tr><td><code id="Stack_+3A_valuename">valueName</code></td>
<td>
<p>Name of the stacked/concatenated output variable</p>
</td></tr>
<tr><td><code id="Stack_+3A_indname">indName</code></td>
<td>
<p>Name of the output variable with information of which vector in x the observation originated.
When indName is NULL this variable is not included in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where the variable ordering corresponds to: blockVar, rowData, valueName, indName
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Unstack">Unstack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 z &lt;- data.frame(n=c(10,20,30), ssb=c('S','S','B'),
 Ayes=1:3,Ano=4:6,Byes=7:9,Bno=10:12)
 zRow &lt;- data.frame(letter=c('A','A','B','B'),answer=c('yes','no','yes','no') )
 
 x &lt;- Stack(z,3:6,1:2,zRow)
 
 Unstack(x,6,3:4,numeric(0),1:2)
 Unstack(x,6,5,numeric(0),1:2)
 Unstack(x,6,3:4,5,1:2)
</code></pre>

<hr>
<h2 id='substitute_formula_vars'>Replace variables in formula with sum of other variables</h2><span id='topic+substitute_formula_vars'></span>

<h3>Description</h3>

<p>Replace variables in formula with sum of other variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitute_formula_vars(
  f,
  replacements,
  simplify = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="substitute_formula_vars_+3A_f">f</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="substitute_formula_vars_+3A_replacements">replacements</code></td>
<td>
<p>A named list. The names of <code>replacements</code> must correspond to variables in <code>f</code>.
Each element in <code>replacements</code> must be a character vector consisting of
the variables you wish to replace.</p>
</td></tr>
<tr><td><code id="substitute_formula_vars_+3A_simplify">simplify</code></td>
<td>
<p>Logical, default is FALSE. Determines whether the formula
should be expanded and simplified before output or not.</p>
</td></tr>
<tr><td><code id="substitute_formula_vars_+3A_env">env</code></td>
<td>
<p>The environment for the output formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model formula
</p>


<h3>Author(s)</h3>

<p>Daniel Lupp and Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- ~b + a*c  + b:d
substitute_formula_vars(f, list(a = c("hello", "world", "b"), 
                                b = c("Q1", "Q2")))

</code></pre>

<hr>
<h2 id='table_all_integers'>Table all integers from 1 to n</h2><span id='topic+table_all_integers'></span>

<h3>Description</h3>

<p>Table all integers from 1 to n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_all_integers(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_all_integers_+3A_x">x</code></td>
<td>
<p>A vector of integers.</p>
</td></tr>
<tr><td><code id="table_all_integers_+3A_n">n</code></td>
<td>
<p>The maximum integer value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1D array of class <code>"table"</code> representing the frequency of each integer from 1 to n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table_all_integers(c(2, 3, 5, 3, 5, 3), 7)

</code></pre>

<hr>
<h2 id='tables_by_formulas'>Tabular Statistics Based on Formulas</h2><span id='topic+tables_by_formulas'></span>

<h3>Description</h3>

<p>This function acts as an overlay for functions that produce tabular statistics
through an interface utilizing the <code><a href="#topic+ModelMatrix">ModelMatrix()</a></code> function and its <code>formula</code> parameter.
Each table (individual statistic) is defined by a formula. The output is a single <code>data.frame</code>
that contains the results for all tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tables_by_formulas(
  data,
  table_fun,
  ...,
  table_formulas,
  substitute_vars = NULL,
  auto_collapse = TRUE,
  collapse_vars = NULL,
  total = "Total",
  hierarchical_extend0 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tables_by_formulas_+3A_data">data</code></td>
<td>
<p>The input data to be processed by <code>table_fun</code>.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_table_fun">table_fun</code></td>
<td>
<p>The table-producing function to be used.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>table_fun</code>.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_table_formulas">table_formulas</code></td>
<td>
<p>A named list of formulas, where each entry defines a specific table.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_substitute_vars">substitute_vars</code></td>
<td>
<p>Allows formulas in <code>table_formulas</code> to be written in a simplified way.
If <code>substitute_vars</code> is specified, the final formulas are generated
using <code><a href="#topic+substitute_formula_vars">substitute_formula_vars()</a></code> with <code>substitute_vars</code> as input.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_auto_collapse">auto_collapse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, variables are collapsed using <code><a href="#topic+total_collapse">total_collapse()</a></code>
with the <code>variables</code> parameter according to <code>substitute_vars</code>.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_collapse_vars">collapse_vars</code></td>
<td>
<p>When specified, <code><a href="#topic+total_collapse">total_collapse()</a></code> is called with <code>collapse_vars</code> as the <code>variables</code> parameter,
after any call triggered by the <code>auto_collapse</code> parameter.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_total">total</code></td>
<td>
<p>A string used to name totals. Passed to both <code>table_fun</code> and <code><a href="#topic+total_collapse">total_collapse()</a></code>.</p>
</td></tr>
<tr><td><code id="tables_by_formulas_+3A_hierarchical_extend0">hierarchical_extend0</code></td>
<td>
<p>Controls automatic hierarchy generation for <code><a href="#topic+Extend0">Extend0()</a></code>.
See &quot;Details&quot; for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To ensure full control over the generated output variables, <code>table_fun</code> is called with <code>avoid_hierarchical</code>
or <code>avoidHierarchical</code> set to <code>TRUE</code>. Desired variables in the output are achieved using
<code>substitute_vars</code>, <code>auto_collapse</code>, and <code>collapse_vars</code>.
</p>
<p>If <code>table_fun</code> automatically uses <code><a href="#topic+Extend0">Extend0()</a></code>, the parameter <code>hierarchical_extend0</code>
specifies the <code>hierarchical</code> parameter in <code><a href="#topic+Extend0">Extend0()</a></code> via <code><a href="#topic+Extend0fromModelMatrixInput">Extend0fromModelMatrixInput()</a></code>.
When <code>hierarchical_extend0</code> is <code>TRUE</code>, hierarchies are generated automatically.
By default, it is set to <code>TRUE</code>, preventing excessive data extension and aligning with
the default behavior of <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix()</a></code>, where <code>avoidHierarchical = FALSE</code>.
</p>
<p>Note: The use of <code>total_collapse</code> internally allows handling of variable names not present in the data.
This ensures flexibility when modifying the <code>table_formulas</code> parameter.
</p>


<h3>Value</h3>

<p>A single <code>data.frame</code> containing results for all tables defined in <code>table_formulas</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_by_variable">filter_by_variable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tables_by_formulas(SSBtoolsData("magnitude1"),
                   table_fun = model_aggregate, 
                   table_formulas = list(table_1 = ~region * sector2, 
                                         table_2 = ~region1:sector4 - 1, 
                                         table_3 = ~region + sector4 - 1), 
                   substitute_vars = list(region = c("geo", "eu"), region1 = "eu"), 
                   collapse_vars = list(sector = c("sector2", "sector4")), 
                   sum_vars = "value", 
                   total = "T")
</code></pre>

<hr>
<h2 id='total_collapse'>Collapse variables to single representation</h2><span id='topic+total_collapse'></span>

<h3>Description</h3>

<p>Simplify a data frame by collapsing specified variables,
according to the location of total codes,
into a single vector or by consolidating groups of variables into new columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_collapse(data, variables, total = "Total", include_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_collapse_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables to be collapsed.</p>
</td></tr>
<tr><td><code id="total_collapse_+3A_variables">variables</code></td>
<td>
<p>A vector of variable names or a named list of variable names.
</p>

<ul>
<li><p> If <code>variables</code> is a vector, the specified variables in <code>data</code> are collapsed
into a single character vector.
</p>
</li>
<li><p> If <code>variables</code> is a named list, each element in the list defines a group of
variables to consolidate into a new column.
Each list name will be used as the new column name in the resulting data frame.
</p>
</li></ul>
</td></tr>
<tr><td><code id="total_collapse_+3A_total">total</code></td>
<td>
<p>A total code or vector of total codes to use in the result.
</p>

<ul>
<li><p> If <code>variables</code> is a vector, <code>total</code> specifies the code to represent collapsed values.
</p>
</li>
<li><p> If <code>variables</code> is a named list, <code>total</code> may contain one code per group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="total_collapse_+3A_include_names">include_names</code></td>
<td>
<p>A character string or <code>NULL</code> (default).
</p>

<ul>
<li><p> If <code>variables</code> is a vector, whether the resulting output vector is named depends
on whether <code>include_names</code> is <code>NULL</code> or not. The actual value of <code>include_names</code>
is ignored in this case.
</p>
</li>
<li><p> If <code>variables</code> is a named list, <code>include_names</code> specifies a suffix to append to
each group name, creating one additional column per group.
If <code>NULL</code>, no additional columns with variable names are included in the result.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector (if <code>variables</code> is a vector) or a modified data frame (if <code>variables</code> is a named list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creates data that can act as input
magnitude1 &lt;- SSBtoolsData("magnitude1")
a &lt;- model_aggregate(magnitude1, 
                     formula = ~geo + eu + sector2 + sector4, 
                     sum_vars = "value", 
                     avoid_hierarchical = TRUE)
a

b &lt;- total_collapse(a, list(GEO = c("geo", "eu"), SECTOR = c("sector2", "sector4")))
b

total_collapse(a, c("geo", "eu"))
total_collapse(a, c("sector2", "sector4"))                                 


# Similar examples with both `total` and `include_names` parameters
aa &lt;- a
aa[1:2][aa[1:2] == "Total"] &lt;- "Europe"
aa[3:4][aa[3:4] == "Total"] &lt;- ""
aa

bb &lt;- total_collapse(data = aa, 
                     variables = list(GEO = c("geo", "eu"), 
                                      SECTOR = c("sector2", "sector4")), 
                     total = c("Europe", ""),
                     include_names = "_Vars")
bb

total_collapse(aa, c("geo", "eu"), total = "Europe", include_names = "_Vars")
total_collapse(aa, c("sector2", "sector4"), total = "", include_names = "_Vars") 


# All four variables can be collapsed
total_collapse(a, 
               list(ALL = c("geo", "eu", "sector2", "sector4")), 
               include_names = "_Vars")

</code></pre>

<hr>
<h2 id='UniqueSeq'>Sequence within unique values</h2><span id='topic+UniqueSeq'></span>

<h3>Description</h3>

<p>Sequence within unique values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniqueSeq(x, sortdata = matrix(1L, length(x), 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UniqueSeq_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="UniqueSeq_+3A_sortdata">sortdata</code></td>
<td>
<p>matrix or vector to determine sequence order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1:4 within A and 1:2 within B
UniqueSeq(c("A", "A", "B", "B", "A", "A"))

# Ordered differently
UniqueSeq(c("A", "A", "B", "B", "A", "A"), c(4, 5, 20, 10, 3, 0))
</code></pre>

<hr>
<h2 id='unmatrix'>Transform data frame with embedded matrices</h2><span id='topic+unmatrix'></span>

<h3>Description</h3>

<p>Transform data frame with embedded matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmatrix(data, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unmatrix_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="unmatrix_+3A_sep">sep</code></td>
<td>
<p>A character string used when variable names are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- aggregate(1:6, list(rep(1:3, 2)), range)
b &lt;- unmatrix(a)

a
b

dim(a)
dim(b)

names(a)
names(b)

class(a[, 2])
class(b[, 2])
</code></pre>

<hr>
<h2 id='Unstack'>Unstack a column from a data frame and include additional variables.</h2><span id='topic+Unstack'></span>

<h3>Description</h3>

<p>Unstack a column from a data frame and include additional variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unstack(
  data,
  mainVar = 1,
  stackVar = (1:NCOL(data))[-mainVar],
  extraVar = integer(0),
  blockVar = integer(0),
  sep = "_",
  returnRowData = TRUE,
  sorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unstack_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Unstack_+3A_mainvar">mainVar</code></td>
<td>
<p>Index of the variable to be unstacked</p>
</td></tr>
<tr><td><code id="Unstack_+3A_stackvar">stackVar</code></td>
<td>
<p>Index of variables defining the unstack grouping</p>
</td></tr>
<tr><td><code id="Unstack_+3A_extravar">extraVar</code></td>
<td>
<p>Indices of within-replicated variables to be added to the rowData output</p>
</td></tr>
<tr><td><code id="Unstack_+3A_blockvar">blockVar</code></td>
<td>
<p>Indices of between-replicated variables to be added to the data output</p>
</td></tr>
<tr><td><code id="Unstack_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when creating variable names</p>
</td></tr>
<tr><td><code id="Unstack_+3A_returnrowdata">returnRowData</code></td>
<td>
<p>When FALSE output is no list, but only data</p>
</td></tr>
<tr><td><code id="Unstack_+3A_sorted">sorted</code></td>
<td>
<p>When TRUE the created variables is in sorted order. Otherwise input order is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When returnRowData=TRUE output is list of two elements.
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>Unstacked data</p>
</td></tr>
<tr><td><code>rowData</code></td>
<td>
<p>A separate data frame with one row for each unstack grouping composed of the stackVar variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Stack">Stack</a></code>  (examples)
</p>

<hr>
<h2 id='vars_to_hierarchies'>Transform hierarchies coded as Variables to &quot;to-from&quot; format</h2><span id='topic+vars_to_hierarchies'></span>

<h3>Description</h3>

<p>A kind of reverse operation of <code><a href="#topic+hierarchies_as_vars">hierarchies_as_vars</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_to_hierarchies(var_hierarchies)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_to_hierarchies_+3A_var_hierarchies">var_hierarchies</code></td>
<td>
<p>As output from <code><a href="#topic+hierarchies_as_vars">hierarchies_as_vars</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of hierarchies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- hierarchies_as_vars(list(f = 
       c("AB = A + B", "CD = C + D", "AC = A + C", "ABCD = AB + CD")))
a

vars_to_hierarchies(a)
</code></pre>

<hr>
<h2 id='WildcardGlobbing'>Row selection by wildcard/globbing</h2><span id='topic+WildcardGlobbing'></span>

<h3>Description</h3>

<p>The selected rows match combined requirements for all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WildcardGlobbing(x, wg, sign = TRUE, invert = "!")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WildcardGlobbing_+3A_x">x</code></td>
<td>
<p>data.frame with character data</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_wg">wg</code></td>
<td>
<p>data.frame with wildcard/globbing</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_sign">sign</code></td>
<td>
<p>When FALSE, the result is inverted.</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_invert">invert</code></td>
<td>
<p>Character to invert each single selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+HierarchicalWildcardGlobbing">HierarchicalWildcardGlobbing</a></code>
and <code><a href="#topic+WildcardGlobbingVector">WildcardGlobbingVector</a></code> and make use of
<code><a href="base.html#topic+grepl">grepl</a></code> and <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.
</p>


<h3>Value</h3>

<p>Logical vector defining subset of rows.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create data input
data(precip)
data(mtcars)
x &lt;- data.frame(car = rownames(mtcars)[rep(1:NROW(mtcars), each = 35)], city = names(precip), 
                stringsAsFactors = FALSE)

# Create globbing/wildcards input
wg &lt;- data.frame(rbind(c("Merc*", "C*"), c("F*", "??????"), c("!?????????*", "!???????*")), 
                 stringsAsFactors = FALSE)
names(wg) &lt;- names(x)

# Select the following combinations:
# - Cars starting with Merc and cities starting with C
# - Cars starting with F and six-letter cities 
# - Cars with less than nine letters and cities with less than seven letters
x[WildcardGlobbing(x, wg), ]
</code></pre>

<hr>
<h2 id='WildcardGlobbingVector'>Selection of elements by wildcard/globbing</h2><span id='topic+WildcardGlobbingVector'></span>

<h3>Description</h3>

<p>Selection of elements by wildcard/globbing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WildcardGlobbingVector(x, wg, negSign = "-", invert = "!")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WildcardGlobbingVector_+3A_x">x</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_wg">wg</code></td>
<td>
<p>Character vector with wildcard/globbing</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_negsign">negSign</code></td>
<td>
<p>Character representing selection to be removed</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_invert">invert</code></td>
<td>
<p>Character to invert each single selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with selected elements of x
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(precip)
x &lt;- names(precip)

# Select the cities starting with B, C and Sa.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*"))

# Remove from the selection cities with o and t in position 2 and 4, respectively.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*", "-?o*", "-???t*"))

# Add to the selection cities not having six or more letters.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*", "-?o*", "-???t*", "!??????*"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
