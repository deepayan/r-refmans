<!DOCTYPE html><html><head><title>Help for package SSBtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SSBtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddLeadingZeros'><p>Add leading zeros to numbers while preserving other text</p></a></li>
<li><a href='#aggregate_multiple_fun'><p>Wrapper to <code>aggregate</code></p></a></li>
<li><a href='#As_TsparseMatrix'><p>Transform to TsparseMatrix/dgTMatrix</p></a></li>
<li><a href='#AutoHierarchies'><p>Ensure standardized coding of hierarchies</p></a></li>
<li><a href='#AutoSplit'><p>Creating variables by splitting the elements of a character vector</p>
without needing a split string</a></li>
<li><a href='#CbindIdMatch'><p>Combine several data frames by using id variables to match rows</p></a></li>
<li><a href='#CharacterDataFrame'><p>CharacterDataFrame</p></a></li>
<li><a href='#CrossCodeFrames'><p>Cross codes in data frames</p></a></li>
<li><a href='#crossMerge'><p>crossMerge</p></a></li>
<li><a href='#DataDummyHierarchy'><p>Create a (signed) dummy matrix for hierarcical mapping of codes in data</p></a></li>
<li><a href='#DataFrameToMatrix'><p>DataFrameToMatrix</p></a></li>
<li><a href='#DimList2Hierarchy'><p>DimList2Hierarchy</p></a></li>
<li><a href='#DimList2Hrc'><p>DimList2Hrc/Hrc2DimList</p></a></li>
<li><a href='#dummy_aggregate'><p><code>aggregate_multiple_fun</code> using a dummy matrix</p></a></li>
<li><a href='#DummyApply'><p>Apply a function to subsets defined by a dummy matrix</p></a></li>
<li><a href='#DummyDuplicated'><p>Duplicated columns in dummy matrix</p></a></li>
<li><a href='#DummyHierarchy'><p>Converting hierarchy specifications to a (signed) dummy matrix</p></a></li>
<li><a href='#Extend0'><p>Add zero frequency rows</p></a></li>
<li><a href='#Extend0rnd1'><p>varGroups-attribute to Extend0, Example functions</p></a></li>
<li><a href='#FactorLevCorr'><p>Factor level correlation</p></a></li>
<li><a href='#FindCommonCells'><p>Finding commonCells</p></a></li>
<li><a href='#FindDimLists'><p>Finding dimList</p></a></li>
<li><a href='#FindDisclosiveCells'><p>Find directly disclosive cells</p></a></li>
<li><a href='#FindHierarchies'><p>Finding hierarchies automatically from data</p></a></li>
<li><a href='#FindTableGroup'><p>Finding table(s) of hierarchical variable groups</p></a></li>
<li><a href='#fix_fun_amf'><p>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code></p></a></li>
<li><a href='#fix_vars_amf'><p>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code></p></a></li>
<li><a href='#ForceCharacterDataFrame'><p>ForceCharacterDataFrame</p></a></li>
<li><a href='#ForceFactorDataFrame'><p>ForceFactorDataFrame</p></a></li>
<li><a href='#FormulaSelection'><p>Limit matrix or data frame to selected model terms</p></a></li>
<li><a href='#FormulaSums'><p>Sums (aggregates) and/or sparse model matrix with possible cross table</p></a></li>
<li><a href='#GaussIndependent'><p>Linearly independent rows and columns by Gaussian elimination</p></a></li>
<li><a href='#GaussIterationFunction'><p>An <code>iFunction</code> argument to <code>GaussSuppression</code></p></a></li>
<li><a href='#GaussSuppression'><p>Secondary suppression by Gaussian elimination</p></a></li>
<li><a href='#HierarchicalGroups'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalGroups2'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalGroups3'><p>Finding hierarchical variable groups</p></a></li>
<li><a href='#HierarchicalWildcardGlobbing'><p>Find variable combinations by advanced wildcard/globbing specifications.</p></a></li>
<li><a href='#Hierarchies2ModelMatrix'><p>Model matrix representing crossed hierarchies</p></a></li>
<li><a href='#HierarchiesAndFormula2ModelMatrix'><p>Model matrix representing crossed hierarchies according to a formula</p></a></li>
<li><a href='#Hierarchy2Formula'><p>Hierarchy2Formula</p></a></li>
<li><a href='#HierarchyCompute'><p>Hierarchical Computations</p></a></li>
<li><a href='#HierarchyCompute2'><p>Extended Hierarchical Computations</p></a></li>
<li><a href='#HierarchyComputeDummy'><p>HierarchyComputeDummy</p></a></li>
<li><a href='#HierarchyFix'><p>Change the hierarchy table to follow the standard</p></a></li>
<li><a href='#inc_default'><p>Default progress indicator function</p></a></li>
<li><a href='#LSfitNonNeg'><p>Non-negative regression fits with a sparse overparameterized model matrix</p></a></li>
<li><a href='#MakeFreq'><p>Microdata frequency data conversion</p></a></li>
<li><a href='#MakeHierFormula'><p>Make model formula from data taking into account hierarchical variables</p></a></li>
<li><a href='#Match'><p>Matching rows in data frames</p></a></li>
<li><a href='#matlabColon'><p>Simulate Matlab's ':'</p></a></li>
<li><a href='#Matrix2list'><p>Convert matrix to sparse list</p></a></li>
<li><a href='#MatrixPaste'><p>Combining columns of a matrix</p></a></li>
<li><a href='#MatrixToDataFrame'><p>MatrixToDataFrame</p></a></li>
<li><a href='#Mipf'><p>Iterative proportional fitting from matrix input</p></a></li>
<li><a href='#model_aggregate'><p>Hierarchical aggregation via model specification</p></a></li>
<li><a href='#Model_Matrix'><p>Overparameterized model matrix</p></a></li>
<li><a href='#ModelMatrix'><p>Model matrix from hierarchies and/or a formula</p></a></li>
<li><a href='#Number'><p>Adding leading zeros</p></a></li>
<li><a href='#NumSingleton'><p>Decoding of <code>singletonMethod</code></p></a></li>
<li><a href='#quantile_weighted'><p>Weighted quantiles</p></a></li>
<li><a href='#RbindAll'><p>Combining several data frames when the columns don't match</p></a></li>
<li><a href='#Reduce0exact'><p>Reducing a non-negative regression problem</p></a></li>
<li><a href='#RoundWhole'><p>Round values that are close two whole numbers</p></a></li>
<li><a href='#RowGroups'><p>Create numbering according to unique rows</p></a></li>
<li><a href='#SortRows'><p>Sorting rows of a matrix or data frame</p></a></li>
<li><a href='#sosialFiktiv'><p>Fictitious datasets returned by SSBtoolsData()</p></a></li>
<li><a href='#SSBtoolsData'><p>Function that returns a dataset</p></a></li>
<li><a href='#Stack'><p>Stack columns from a data frame and include variables.</p></a></li>
<li><a href='#UniqueSeq'><p>Sequence within unique values</p></a></li>
<li><a href='#unmatrix'><p>Transform data frame with embedded matrices</p></a></li>
<li><a href='#Unstack'><p>Unstack a column from a data frame and include additional variables.</p></a></li>
<li><a href='#WildcardGlobbing'><p>Row selection by wildcard/globbing</p></a></li>
<li><a href='#WildcardGlobbingVector'><p>Selection of elements by wildcard/globbing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistics Norway's Miscellaneous Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, methods, MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions used by other packages from Statistics Norway are gathered. General data manipulation functions, and functions for hierarchical computations are included (Langsrud, 2020) &lt;<a href="https://doi.org/10.13140%2FRG.2.2.27313.61283">doi:10.13140/RG.2.2.27313.61283</a>&gt;. The hierarchy specification functions are useful within statistical disclosure control.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statisticsnorway/SSBtools">https://github.com/statisticsnorway/SSBtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statisticsnorway/SSBtools/issues">https://github.com/statisticsnorway/SSBtools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 05:49:57 UTC; oyl</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud [aut, cre],
  Daniel Lupp [aut],
  Bjørn-Helge Mevik [ctb],
  Statistics Norway [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 11:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddLeadingZeros'>Add leading zeros to numbers while preserving other text</h2><span id='topic+AddLeadingZeros'></span>

<h3>Description</h3>

<p>This function is created to fix problems caused by a serious bug in Excel.
Editing csv files in that program causes leading zeros to disappear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddLeadingZeros(
  codes,
  places,
  warningText = NULL,
  viaFactor = TRUE,
  nWarning = 6,
  removeLeadingTrailingWhitespace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddLeadingZeros_+3A_codes">codes</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_places">places</code></td>
<td>
<p>Number of places for positive numbers. Minus sign is extra</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_warningtext">warningText</code></td>
<td>
<p>When non-NULL, warning will be produced</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_viafactor">viaFactor</code></td>
<td>
<p>When TRUE, the algorithm uses factor coding internally.</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_nwarning">nWarning</code></td>
<td>
<p>Number of elements to be written before ... in warnings.</p>
</td></tr>
<tr><td><code id="AddLeadingZeros_+3A_removeleadingtrailingwhitespace">removeLeadingTrailingWhitespace</code></td>
<td>
<p>Remove leading and trailing whitespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 10)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, removeLeadingTrailingWhitespace = FALSE)
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, warningText = "string changes")
AddLeadingZeros(c("1", "ABC", "12345", " 23", "-8", "45 ", " -9", " Agent ", "007", 
                  "7 James Bond "), 4, warningText = "", nWarning = 2)
</code></pre>

<hr>
<h2 id='aggregate_multiple_fun'>Wrapper to <code>aggregate</code></h2><span id='topic+aggregate_multiple_fun'></span>

<h3>Description</h3>

<p>Wrapper to <code><a href="stats.html#topic+aggregate">aggregate</a></code> that allows multiple functions and functions of several variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_multiple_fun(
  data,
  by,
  vars,
  fun = NULL,
  ind = NULL,
  ...,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  forward_dots = FALSE,
  dots2dots = FALSE,
  do_unmatrix = TRUE,
  do_unlist = TRUE,
  inc_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_multiple_fun_+3A_data">data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_by">by</code></td>
<td>
<p>A data frame defining grouping</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_vars">vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li><p> Parameter <code>vars</code> will converted to an internal standard by the function <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>. Indices instead of variable names are allowed.
</p>
</li>
<li><p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li><p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_fun">fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code><a href="#topic+fix_fun_amf">fix_fun_amf</a></code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_ind">ind</code></td>
<td>
<p>When non-NULL, a data frame of indices.
When NULL, this variable will be generated internally as <code>data.frame(ind = seq_len(nrow(data)))</code>.
The parameter is useful for advanced use involving model/dummy matrices.
For special use (<code>dummy = FALSE</code> in <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>) <code>ind</code> can also be a two-column data frame.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>aggregate</code> and,
depending on <code>forward_dots</code>/<code>dots2dots</code>, forwarded to the functions in <code>fun</code> (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_name_sep">name_sep</code></td>
<td>
<p>A character string used when output variable names are generated.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_seve_sep">seve_sep</code></td>
<td>
<p>A character string used when output variable names are generated from functions of several variables.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_multi_sep">multi_sep</code></td>
<td>
<p>A character string used when multiple output variable names are sent as input.</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_forward_dots">forward_dots</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of <code>fun</code> that determines whether <code>...</code> should be forwarded (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_dots2dots">dots2dots</code></td>
<td>
<p>Logical vector (possibly recycled) specifying the behavior when <code>forward_dots = TRUE</code> (see details).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_do_unmatrix">do_unmatrix</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code><a href="#topic+unmatrix">unmatrix</a></code> before returning output.
For special use this can be omitted (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_do_unlist">do_unlist</code></td>
<td>
<p>By default (<code>TRUE</code>), the implementation uses <code><a href="base.html#topic+unlist">unlist</a></code> to combine output from multiple functions.
For special use this can be omitted (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="aggregate_multiple_fun_+3A_inc_progress">inc_progress</code></td>
<td>
<p>logigal, <code>NULL</code> (same as <code>FALSE</code>) or a  progress indicator function taking two parameters (i and n).
<code>TRUE</code> means the same as <code><a href="#topic+inc_default">inc_default</a></code>. Note that this feature is implemented in a
hacky manner as internal/hidden variables are grabbed from <code><a href="stats.html#topic+aggregate">aggregate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One intention of <code>aggregate_multiple_fun</code> is to be a true generalization of <code>aggregate</code>.
However, when many functions are involved, passing extra parameters can easily lead to errors.
Therefore <code>forward_dots</code> and <code>dots2dots</code> are set to <code>FALSE</code> by default.
When <code>forward_dots = TRUE</code> and <code>dots2dots = FALSE</code>, parameters will be forwarded,
but only parameters that are explicitly defined in the specific <code>fun</code> function.
For the <code>sum</code> function, this means that a possible <code>na.rm</code> parameter is forwarded but not others.
When <code>forward_dots = TRUE</code> and <code>dots2dots = TRUE</code>, other parameters will also be forwarded to <code>fun</code> functions where <code>...</code> is included.
For the <code>sum</code> function, this means that such extra parameters will, probably erroneously, be included in the summation (see examples).
</p>
<p>For the function to work with <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>,
the data is subject to <code><a href="base.html#topic+unlist">unlist</a></code> before the <code>fun</code> functions are called.
This does not apply in the special case where <code>ind</code> is a two-column data frame.
Then, in the case of list data, the <code>fun</code> functions have to handle this themselves.
</p>
<p>A limitation when default output, when <code>do_unlist = TRUE</code>, is that variables in output are forced to have the same class.
This is caused by the <code><a href="base.html#topic+unlist">unlist</a></code> function being run on the output. This means, for example,
that all the variables will become numeric when they should have been both integer and numeric.
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c("freq", "y", median = "freq", median = "y", e1 = "freq"),
   fun = c(sum, median = median, e1 = function(x) x[1])  
)

# With functions as named strings 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", med = "freq", med = "y"),
   fun = c(sum = "sum", med = "median")
)

# Without specifying functions 
# - equivalent to `fun = c("sum", "median")` 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = c(sum = "y", median = "freq", median = "y")
)

# The single unnamed variable feature. Also functions as strings. 
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = "y",
   fun = c("sum", "median", "min", "max")
) 

# with multiple outputs (function my_range)
# and with function of two variables (weighted.mean(y, freq))
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", ra = "freq", wmean  = c("y", "freq")),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
aggregate_multiple_fun(
   data = d, 
   by = d[c("k_group", "main_income")], 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean)
)


# To illustrate forward_dots and dots2dots
q &lt;- d[1, ]
q$w &lt;- 100 * rnorm(1)
for (dots2dots in c(FALSE, TRUE)) for (forward_dots in c(FALSE, TRUE)) {
  cat("\n=======================================\n")
  cat("forward_dots =", forward_dots, ", dots2dots =", dots2dots)
  out &lt;- aggregate_multiple_fun(
    data = q, by = q["k_group"], 
    vars = c(sum = "freq", round = "w"), fun = c("sum", "round"),  
    digits = 3, forward_dots = forward_dots, dots2dots = dots2dots)
  cat("\n")
  print(out)
}
# In last case digits forwarded to sum (as ...) 
# and wrongly included in the summation
 
</code></pre>

<hr>
<h2 id='As_TsparseMatrix'>Transform to TsparseMatrix/dgTMatrix</h2><span id='topic+As_TsparseMatrix'></span>

<h3>Description</h3>

<p>To implement adaption needed after Matrix ver. 1.4-2 since
<code>as(from, "dgTMatrix")</code> no longer allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>As_TsparseMatrix(from, do_drop0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="As_TsparseMatrix_+3A_from">from</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="As_TsparseMatrix_+3A_do_drop0">do_drop0</code></td>
<td>
<p>whether to run <code>drop0</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is made to replace <code>as(from, "dgTMatrix")</code> and <code>as(drop0(from), "dgTMatrix")</code> in <code>SSBtools</code> and related packages.
</p>


<h3>Value</h3>

<p>A matrix. Virtual class is <code>TsparseMatrix</code>. Class <code>dgTMatrix</code> expected.
</p>


<h3>Note</h3>

<p><code>Matrix:::.as.via.virtual</code> in development version of package <code>Matrix</code> (date 2022-08-13) used to generate code.
</p>

<hr>
<h2 id='AutoHierarchies'>Ensure standardized coding of hierarchies</h2><span id='topic+AutoHierarchies'></span>

<h3>Description</h3>

<p>Automatic convert list of hierarchies coded in different ways to standardized to-from coding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoHierarchies(
  hierarchies,
  data = NULL,
  total = "Total",
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  combineHierarchies = TRUE,
  unionComplement = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoHierarchies_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_total">total</code></td>
<td>
<p>Within <code>AutoHierarchies</code>: Vector of total codes (possibly recycled) used when running <code><a href="#topic+Hrc2DimList">Hrc2DimList</a></code> or <code><a href="#topic+FindDimLists">FindDimLists</a></code>.</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code></p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_combinehierarchies">combineHierarchies</code></td>
<td>
<p>Whether to combine several hierarchies for same variable into a single hierarchy (see examples).</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector as in <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>. The parameter is only in use when hierarchies are combined.</p>
</td></tr>
<tr><td><code id="AutoHierarchies_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input can be to-from coded hierarchies, hierarchies/dimList as in sdcTable, TauArgus coded hierarchies or formulas.
Automatic coding from data is also supported. Output is on a from ready for input to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>.
A single string as hierarchy input is assumed to be a total code.
Then, the hierarchy is created as a simple hierarchy where all codes in data sum up to this total.
For consistence with <code>HierarchyCompute</code>,
the codes <code>"rowFactor"</code> and <code>"colFactor"</code> are unchanged.
An empty string is recoded to  <code>"rowFactor"</code>.
</p>
<p>A special possibility is to include character vector(s) as unnamed list element(s) of <code>hierarchies</code>.
Then the elements of the character vector(s) must be variable names within data.
This will cause hierarchies to be created from selected data columns by running <code><a href="#topic+FindDimLists">FindDimLists</a></code>.
Total coded can be specified by parameter <code>total</code> or by naming the character vector. See examples.
</p>


<h3>Value</h3>

<p>List of hierarchies
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FindHierarchies">FindHierarchies</a></code>, <code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>,
<code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+DummyHierarchies">DummyHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, create different types of input
z &lt;- SSBtoolsData("sprt_emp_withEU")
yearFormula &lt;- c("y_14 = 2014", "y_15_16 = y_all - y_14", "y_all = 2014 + 2015 + 2016")
yearHier &lt;- Formula2Hierarchy(yearFormula)
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]
geoDimList2 &lt;- FindDimLists(z[, c("geo", "eu")])[[1]]
geoHrc &lt;- DimList2Hrc(geoDimList)
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

h1 &lt;- AutoHierarchies(list(age = ageHier, geo = geoDimList, year = yearFormula))
h2 &lt;- AutoHierarchies(list(age = "Y15-64", geo = geoHrc, year = yearHier), data = z, 
                      total = "Europe")
h3 &lt;- AutoHierarchies(list(age = "Total", geo = geoDimList2, year = "Total"), data = z)
h4 &lt;- FindHierarchies(z[, c(1, 2, 3, 5)])
h5 &lt;- AutoHierarchies(list(age = "Total", geo = "", year = "colFactor"), data = z)
identical(h1, h2)
identical(h3, h4)

# Print the resulting hierarchies
h1 # = h2
h3 # = h4
h5

FindHierarchies(z[, c("geo", "eu", "age")])


# ===================================================================== 
#   Examples illustrating the combineHierarchies parameter
# =====================================================================

# First, create data
d &lt;- SSBtoolsData("d2ws")[1:3]
d$isCounty1 &lt;- "NO"
d$isCounty1[d$county == "county-1"] &lt;- "YES"
d

# sdcTable coding showing two tree-shaped hierarchies
dimList &lt;- FindDimLists(d)
dimList

# Two tree-shaped hierarchies can still be seen 
# Hierarchies with three and two levels
hA &lt;- AutoHierarchies(dimList, combineHierarchies = FALSE)
hA

# A single hierarchy with only one level 
# Contains the information needed to create a dummy matrix
hB &lt;- AutoHierarchies(dimList)
hB

# Dummy matrices from the hierarchies
DummyHierarchies(hA)
DummyHierarchies(hB)


# ===================================================================== 
#   Special examples with character vector(s) as unnamed list elements
# =====================================================================

# Same output as FindHierarchies above
AutoHierarchies(list(c("geo", "eu", "age")), data = z)

# Now combined with a named list element 
AutoHierarchies(list(year = yearHier, c("geo", "eu", "age")), data = z)

# Total codes by unnamed list element as named character vector 
AutoHierarchies(list(year = yearHier, c(Europe = "geo", "eu", All = "age")), data = z)

# Two types of year input. Total codes by using the parameter `total`. 
AutoHierarchies(list("year", year = yearHier, c("geo", "eu", "age")), data = z, 
                total = c("allYears", "unused", "Tot"))

# Avoid combineHierarchies to see effect of each year input separately 
# (even earlier return possible with `combineHierarchies = NA`)
AutoHierarchies(list("year", year = yearHier, c("geo", "eu", "age")), data = z, 
                total = c("allYears", "unused", "Tot"), combineHierarchies = FALSE)

</code></pre>

<hr>
<h2 id='AutoSplit'>Creating variables by splitting the elements of a character vector
without needing a split string</h2><span id='topic+AutoSplit'></span>

<h3>Description</h3>

<p>Creating variables by splitting the elements of a character vector
without needing a split string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoSplit(
  s,
  split = NULL,
  border = "_",
  revBorder = FALSE,
  noSplit = FALSE,
  varNames = paste("var", 1:100, sep = ""),
  tryReverse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoSplit_+3A_s">s</code></td>
<td>
<p>The character vector</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_split">split</code></td>
<td>
<p>Split string. When NULL (default), automatic splitting without a split string.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_border">border</code></td>
<td>
<p>A split character
or an integer (move split) to be used when the exact split position
is not unique.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_revborder">revBorder</code></td>
<td>
<p>When border is integer the split position is moved from the other side.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_nosplit">noSplit</code></td>
<td>
<p>No splitting when TRUE.</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_varnames">varNames</code></td>
<td>
<p>Variable names of the created variables (too many is ok)</p>
</td></tr>
<tr><td><code id="AutoSplit_+3A_tryreverse">tryReverse</code></td>
<td>
<p>When TRUE, the automatic method tries to find more variables by
splitting from reversed strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with s as row names.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- c("A12-3-A-x","A12-3-B-x","B12-3-A-x","B12-3-B-x",
       "A12-3-A-y","A12-3-B-y","B12-3-A-y","B12-3-B-y")
AutoSplit(s)
AutoSplit(s,border="-")
AutoSplit(s,split="-")
AutoSplit(s,border=1)
AutoSplit(s,border=2)
AutoSplit(s,border=2,revBorder=TRUE)
AutoSplit(s,noSplit=TRUE)
AutoSplit(s,varNames=c("A","B","C","D"))
</code></pre>

<hr>
<h2 id='CbindIdMatch'>Combine several data frames by using id variables to match rows</h2><span id='topic+CbindIdMatch'></span>

<h3>Description</h3>

<p>Combine several data frames by using id variables to match rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CbindIdMatch(
  ...,
  addName = names(x),
  sep = "_",
  idNames = sapply(x, function(x) names(x)[1]),
  idNames1 = idNames,
  addLast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CbindIdMatch_+3A_...">...</code></td>
<td>
<p>Several data frames as several input parameters or a list of data frames</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_addname">addName</code></td>
<td>
<p>NULL or vector of strings used to name columns according to origin frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when addName apply</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_idnames">idNames</code></td>
<td>
<p>Names of a id variable within each data frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_idnames1">idNames1</code></td>
<td>
<p>Names of variables in first data frame that correspond to the id variable within each data frame</p>
</td></tr>
<tr><td><code id="CbindIdMatch_+3A_addlast">addLast</code></td>
<td>
<p>When TRUE addName will be at end</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first data frame is the basis and the other frames will be matched by using id-variables.
The default id-variables are the first variable in each frame. Corresponding variables with
the same name in first frame is assumed. An id-variable is not needed if the number of rows
is one or the same as the first frame. Then the element of idNames can be set to a string
with zero length.
</p>


<h3>Value</h3>

<p>A single data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RbindAll">RbindAll</a></code> (same example data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zA &lt;- data.frame(idA = 1:10, idB = rep(10 * (1:5), 2), idC = rep(c(100, 200), 5), 
                 idC2 = c(100, rep(200, 9)), idC3 = rep(100, 10), 
                 idD = 99, x = round(rnorm(10), 3), xA = round(runif(10), 2))
zB &lt;- data.frame(idB = 10 * (1:5), x = round(rnorm(5), 3), xB = round(runif(5), 2))
zC &lt;- data.frame(idC = c(100, 200), x = round(rnorm(2), 3), xC = round(runif(2), 2))
zD &lt;- data.frame(idD = 99, x = round(rnorm(1), 3), xD = round(runif(1), 2))
CbindIdMatch(zA, zB, zC, zD)
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames = c("", "idB", "idC", ""))
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames1 = c("", "idB", "idC2", ""))
CbindIdMatch(a = zA, b = zB, c = zC, d = zD, idNames1 = c("", "idB", "idC3", ""))
CbindIdMatch(zA, zB, zC, zD, addName = c("", "bbb", "ccc", "ddd"), sep = ".", addLast = TRUE)
try(CbindIdMatch(X = zA, Y = zA[, 4:5], Z = zC, idNames = NULL)) # Error
CbindIdMatch(X = zA, Y = zA[, 4:5], Z = zD, idNames = NULL)      # Ok since equal NROW or NROW==1
CbindIdMatch(list(a = zA, b = zB, c = zC, d = zD))               # List is alternative input
</code></pre>

<hr>
<h2 id='CharacterDataFrame'>CharacterDataFrame</h2><span id='topic+CharacterDataFrame'></span>

<h3>Description</h3>

<p>CharacterDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CharacterDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CharacterDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='CrossCodeFrames'>Cross codes in data frames</h2><span id='topic+CrossCodeFrames'></span>

<h3>Description</h3>

<p>Cross codes in data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossCodeFrames(codeFrame1, codeFrame2, useMatrixToDataFrame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossCodeFrames_+3A_codeframe1">codeFrame1</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="CrossCodeFrames_+3A_codeframe2">codeFrame2</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="CrossCodeFrames_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>useMatrixToDataFrame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='crossMerge'>crossMerge</h2><span id='topic+crossMerge'></span>

<h3>Description</h3>

<p>crossMerge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossMerge(ind1, ind2, x, y, useMatrixToDataFrame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossMerge_+3A_ind1">ind1</code></td>
<td>
<p>ind1</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_ind2">ind2</code></td>
<td>
<p>ind2</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="crossMerge_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
</table>

<hr>
<h2 id='DataDummyHierarchy'>Create a (signed) dummy matrix for hierarcical mapping of codes in data</h2><span id='topic+DataDummyHierarchy'></span><span id='topic+DataDummyHierarchies'></span>

<h3>Description</h3>

<p>Create a (signed) dummy matrix for hierarcical mapping of codes in data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataDummyHierarchy(dataVector, dummyHierarchy)

DataDummyHierarchies(data, dummyHierarchies, colNamesFromData = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataDummyHierarchy_+3A_datavector">dataVector</code></td>
<td>
<p>A vector of codes in data</p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_dummyhierarchy">dummyHierarchy</code></td>
<td>
<p>Output from <code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code></p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_dummyhierarchies">dummyHierarchies</code></td>
<td>
<p>Output from <code><a href="#topic+DummyHierarchies">DummyHierarchies</a></code></p>
</td></tr>
<tr><td><code id="DataDummyHierarchy_+3A_colnamesfromdata">colNamesFromData</code></td>
<td>
<p>Column names from data when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DataDummyHierarchies</code> is a user-friendly wrapper for the original function <code>DataDummyHierarchy</code>.
When <code>colNamesFromData</code> is <code>FALSE</code> (default), this function returns
<code style="white-space: pre;">&#8288;mapply(DataDummyHierarchy,&#8288;</code> <code style="white-space: pre;">&#8288;data[names(dummyHierarchies)],&#8288;</code> <code style="white-space: pre;">&#8288;dummyHierarchies)&#8288;</code>.
</p>


<h3>Value</h3>

<p>A sparse matrix.
Column names are taken from dataVector (if non-NULL) and row names are taken from
the row names of dummyHierarchy.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[1:9, ]
hi &lt;- FindHierarchies(z[, c("geo", "eu", "age", "year")])
dhi &lt;- DummyHierarchies(hi, inputInOutput = TRUE)
DataDummyHierarchies(z, dhi, colNamesFromData = TRUE)
</code></pre>

<hr>
<h2 id='DataFrameToMatrix'>DataFrameToMatrix</h2><span id='topic+DataFrameToMatrix'></span>

<h3>Description</h3>

<p>DataFrameToMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataFrameToMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataFrameToMatrix_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='DimList2Hierarchy'>DimList2Hierarchy</h2><span id='topic+DimList2Hierarchy'></span>

<h3>Description</h3>

<p>From hierarchy/dimList as in sdcTable to to-from coded hierarchy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimList2Hierarchy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DimList2Hierarchy_+3A_x">x</code></td>
<td>
<p>An element of a dimList as in sdcTable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with to-from coded hierarchy
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>, <code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First generate a dimList element 
x &lt;- FindDimLists(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu")], , total = "Europe")[[1]]
x

DimList2Hierarchy(x)

</code></pre>

<hr>
<h2 id='DimList2Hrc'>DimList2Hrc/Hrc2DimList</h2><span id='topic+DimList2Hrc'></span><span id='topic+Hrc2DimList'></span>

<h3>Description</h3>

<p>Conversion between hierarchies/dimList as in sdcTable and TauArgus coded hierarchies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimList2Hrc(dimList)

Hrc2DimList(hrc, total = "Total")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DimList2Hrc_+3A_dimlist">dimList</code></td>
<td>
<p>List of data frames according to the specifications in sdcTable</p>
</td></tr>
<tr><td><code id="DimList2Hrc_+3A_hrc">hrc</code></td>
<td>
<p>List of character vectors</p>
</td></tr>
<tr><td><code id="DimList2Hrc_+3A_total">total</code></td>
<td>
<p>String used to name totals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See Arguments
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+Hierarchy2Formula">Hierarchy2Formula</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First generate dimList
dimList &lt;- FindDimLists(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")])
dimList
hrc &lt;- DimList2Hrc(dimList)
hrc
dimList2 &lt;- Hrc2DimList(hrc)
identical(dimList, dimList2)
</code></pre>

<hr>
<h2 id='dummy_aggregate'><code>aggregate_multiple_fun</code> using a dummy matrix</h2><span id='topic+dummy_aggregate'></span>

<h3>Description</h3>

<p>Wrapper to <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>
that uses a dummy matrix instead of the <code>by</code> parameter.
Functionality for non-dummy  matrices as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_aggregate(
  data,
  x,
  vars,
  fun = NULL,
  dummy = TRUE,
  when_non_dummy = warning,
  keep_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_aggregate_+3A_data">data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_vars">vars</code></td>
<td>
<p>A named vector or list of variable names in <code>data</code>. The elements are named by the names of <code>fun</code>.
All the pairs of variable names and function names thus define all the result variables to be generated.
</p>

<ul>
<li><p> Parameter <code>vars</code> will converted to an internal standard by the function <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>.
Thus, function names and also output variable names can be coded in different ways.
Multiple output variable names can be coded using <code>multi_sep</code>.
See examples and examples in <code><a href="#topic+fix_vars_amf">fix_vars_amf</a></code>. Indices instead of variable names are allowed.
</p>
</li>
<li><p> Omission of (some) names is possible since names can be omitted for one function (see <code>fun</code> below).
</p>
</li>
<li><p> A special possible feature is the combination of a single unnamed variable and all functions named.
In this case, all functions are run and output variable names will be identical to the function names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_fun">fun</code></td>
<td>
<p>A named list of functions. These names will be used as suffixes in output variable names. Name can be omitted for one function.
A vector of function as strings is also possible. When unnamed, these function names will be used directly.
See the examples of <code><a href="#topic+fix_fun_amf">fix_fun_amf</a></code>, which is the function used to convert <code>fun</code>.
Without specifying <code>fun</code>, the functions, as strings, are taken from the function names coded in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_dummy">dummy</code></td>
<td>
<p>When <code>TRUE</code>, only 0s and 1s are assumed in <code>x</code>.
When <code>FALSE</code>, non-0s in <code>x</code> are passed as an additional first input parameter to the <code>fun</code> functions.
Thus, the same result as matrix multiplication is achieved with <code>fun = function(x, y) sum(x * y)</code>.
In this case, the data will not be subjected to <code>unlist</code>. See <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_when_non_dummy">when_non_dummy</code></td>
<td>
<p>Function to be called when <code>dummy</code> is <code>TRUE</code> and when <code>x</code> is non-dummy.  Supply <code>NULL</code> to do nothing.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_keep_names">keep_names</code></td>
<td>
<p>When <code>TRUE</code>, output row names are inherited from column names in <code>x</code>.</p>
</td></tr>
<tr><td><code id="dummy_aggregate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>aggregate_multiple_fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally this function make use of the <code>ind</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Code that generates output similar to the 
# last example in aggregate_multiple_fun

d2 &lt;- SSBtoolsData("d2")
set.seed(12)
d2$y &lt;- round(rnorm(nrow(d2)), 2)
d &lt;- d2[sample.int(nrow(d2), size = 20), ]

x &lt;- ModelMatrix(d, formula = ~main_income:k_group - 1)

# with specified output variable names
my_range &lt;- function(x) c(min = min(x), max = max(x))
dummy_aggregate(
   data = d, 
   x = x, 
   vars = list("freq", "y", 
               `freqmin,freqmax` = list(ra = "freq"), 
                yWmean  = list(wmean  = c("y", "freq"))),
   fun = c(sum, ra = my_range, wmean = weighted.mean))


# Make a non-dummy matrix 
x2 &lt;- x
x2[17, 2:5] &lt;- c(-1, 3, 0, 10)
x2[, 4] &lt;- 0

# Now warning 
# Result is not same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, vars = "freq", fun = sum)

# Now same as t(x2) %*% d[["freq"]]
dummy_aggregate(data = d, x = x2, 
                vars = "freq", dummy = FALSE,
                fun = function(x, y) sum(x * y))


# Same as t(x2) %*% d[["freq"]]  + t(x2^2) %*% d[["y"]] 
dummy_aggregate(data = d, x = x2, 
                vars = list(c("freq", "y")), dummy = FALSE,
                fun = function(x, y1, y2) {sum(x * y1) + sum(x^2 * y2)})
                
</code></pre>

<hr>
<h2 id='DummyApply'>Apply a function to subsets defined by a dummy matrix</h2><span id='topic+DummyApply'></span>

<h3>Description</h3>

<p>For each column, <code>i</code>,  of the matrix <code>x</code> of zeros and ones, the output value is equivalent to <code>FUN(y[x[, i] != 0])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyApply(x, y, FUN = sum, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DummyApply_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_y">y</code></td>
<td>
<p>Vector of input values</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_fun">FUN</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="DummyApply_+3A_simplify">simplify</code></td>
<td>
<p>Parameter to <code><a href="stats.html#topic+aggregate">aggregate</a></code>. When <code>FALSE</code>, list output is ensured.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a dummy <code>x</code> and <code>FUN = sum</code>, output is equivalent to <code>z = t(x) %*% y</code>.
</p>


<h3>Value</h3>

<p>Vector of output values or a matrix when multiple outputs from <code>FUN</code>  (see examples).
List output is also possible (ensured when <code>simplify = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

a &lt;- ModelMatrix(z, formula = ~age + geo, crossTable = TRUE)

cbind(as.data.frame(a$crossTable), 
      sum1 = (t(a$modelMatrix) %*% z$ths_per)[,1],
      sum2 = DummyApply(a$modelMatrix, z$ths_per, sum),
       max = DummyApply(a$modelMatrix, z$ths_per, max))
       
DummyApply(a$modelMatrix, z$ths_per, range)
DummyApply(a$modelMatrix, z$ths_per, range, simplify = FALSE)  

a$modelMatrix[, c(3, 5)] &lt;- 0   # Introduce two empty columns. 
DummyApply(a$modelMatrix, z$ths_per, function(x){ 
  c(min = min(x), 
    max = max(x), 
    mean = mean(x), 
    median = median(x), 
    n = length(x))})   
    
DummyApply(a$modelMatrix, z$ths_per, function(x) x, simplify = FALSE)          

</code></pre>

<hr>
<h2 id='DummyDuplicated'>Duplicated columns in dummy matrix</h2><span id='topic+DummyDuplicated'></span>

<h3>Description</h3>

<p>The algorithm is based on <code>crossprod(x)</code> or <code>crossprod(x, u)</code> where <code>u</code> is a vector of random numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyDuplicated(x, idx = FALSE, rows = FALSE, rnd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DummyDuplicated_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_idx">idx</code></td>
<td>
<p>Indices returned when TRUE</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_rows">rows</code></td>
<td>
<p>Duplicated rows instead when TRUE</p>
</td></tr>
<tr><td><code id="DummyDuplicated_+3A_rnd">rnd</code></td>
<td>
<p>Algorithm based on cross product with random numbers when TRUE (dummy matrix not required)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The efficiency of the default algorithm depends on the sparsity of <code>crossprod(x)</code>.
The random values are generated locally within the function without affecting the random value stream in R.
</p>


<h3>Value</h3>

<p>Logical vectors specifying duplicated columns or vector of indices (first match)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1, rbind(diag(2), diag(2)), diag(4)[, 1:2])
z &lt;- Matrix(x[c(1:4, 2:3), c(1, 2, 1:5, 5, 2)])

DummyDuplicated(z)
which(DummyDuplicated(z, rows = TRUE))

# Four ways to obtain the same result
DummyDuplicated(z, idx = TRUE)
DummyDuplicated(z, idx = TRUE, rnd = TRUE)
DummyDuplicated(t(z), idx = TRUE, rows = TRUE)
DummyDuplicated(t(z), idx = TRUE, rows = TRUE, rnd = TRUE)

# The unique values in four ways 
which(!DummyDuplicated(z), )
which(!DummyDuplicated(z, rnd = TRUE))
which(!DummyDuplicated(t(z), rows = TRUE))
which(!DummyDuplicated(t(z), rows = TRUE, rnd = TRUE))
</code></pre>

<hr>
<h2 id='DummyHierarchy'>Converting hierarchy specifications to a (signed) dummy matrix</h2><span id='topic+DummyHierarchy'></span><span id='topic+DummyHierarchies'></span>

<h3>Description</h3>

<p>A matrix for mapping input codes (columns) to output codes (rows) are created.
The elements of the matrix specify how columns contribute to rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DummyHierarchy(
  mapsFrom,
  mapsTo,
  sign,
  level,
  mapsInput = NULL,
  inputInOutput = FALSE,
  keepCodes = mapsFrom[integer(0)],
  unionComplement = FALSE,
  reOrder = FALSE
)

DummyHierarchies(
  hierarchies,
  data = NULL,
  inputInOutput = FALSE,
  unionComplement = FALSE,
  reOrder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DummyHierarchy_+3A_mapsfrom">mapsFrom</code></td>
<td>
<p>Character vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_mapsto">mapsTo</code></td>
<td>
<p>Character vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_sign">sign</code></td>
<td>
<p>Numeric vector of either 1 or -1 from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_level">level</code></td>
<td>
<p>Numeric vector from hierarchy table</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_mapsinput">mapsInput</code></td>
<td>
<p>All codes in mapsFrom not in mapsTo (created automatically when NULL) and possibly other codes in input data.</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>When FALSE all output rows represent codes in mapsTo</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_keepcodes">keepCodes</code></td>
<td>
<p>To prevent some codes to be removed when inputInOutput = FALSE</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>When TRUE, sign means union and complement instead of addition or subtraction (see note)</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (FALSE is default) output codes are ordered differently, more similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="DummyHierarchy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DummyHierarchies</code> is a user-friendly wrapper for the original function <code>DummyHierarchy</code>.
Then, the logical input parameters are vectors (possibly recycled).
<code>mapsInput</code> and <code>keepCodes</code> can be supplied as attributes.
<code>mapsInput</code> will be generated when <code>data</code> is non-NULL.
</p>


<h3>Value</h3>

<p>A sparse matrix with row and column and names
</p>


<h3>Note</h3>

<p>With unionComplement = FALSE (default), the sign of each mapping specifies the contribution as addition or subtraction.
Thus, values above one and negative values in output can occur.
With unionComplement = TRUE,  positive is treated as union and negative as complement. Then 0 and 1 are the only possible elements in the output matrix.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A hierarchy table
h &lt;- SSBtoolsData("FIFA2018ABCD")

DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level)
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level, inputInOutput = TRUE)
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level, keepCodes = c("Portugal", "Spain"))

# Extend the hierarchy table to illustrate the effect of unionComplement
h2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Schengen"), mapsTo = "EUandSchengen", 
                       sign = 1, level = 3), h)

DummyHierarchy(h2$mapsFrom, h2$mapsTo, h2$sign, h2$level)
DummyHierarchy(h2$mapsFrom, h2$mapsTo, h2$sign, h2$level, unionComplement = TRUE)

# Extend mapsInput - leading to zero columns.
DummyHierarchy(h$mapsFrom, h$mapsTo, h$sign, h$level,
               mapsInput = c(h$mapsFrom[!(h$mapsFrom %in% h$mapsTo)], "Norway", "Finland"))

# DummyHierarchies
DummyHierarchies(FindHierarchies(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")]), 
                 inputInOutput = c(FALSE, TRUE))
</code></pre>

<hr>
<h2 id='Extend0'>Add zero frequency rows</h2><span id='topic+Extend0'></span>

<h3>Description</h3>

<p>Microdata or tabular frequency data is extended to contain all combinations of unique rows
of (hierarchical) groups of dimensional variables. Extra variables are extended by <code>NA</code>'s or <code>0</code>'s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend0(
  data,
  freqName = "freq",
  hierarchical = TRUE,
  varGroups = NULL,
  dimVar = NULL,
  extraVar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extend0_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Extend0_+3A_freqname">freqName</code></td>
<td>
<p>Name of (existing) frequency variable</p>
</td></tr>
<tr><td><code id="Extend0_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Hierarchical variables treated atomatically when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Extend0_+3A_vargroups">varGroups</code></td>
<td>
<p>List of variable groups, possibly with data (see details and examples).</p>
</td></tr>
<tr><td><code id="Extend0_+3A_dimvar">dimVar</code></td>
<td>
<p>The dimensional variables</p>
</td></tr>
<tr><td><code id="Extend0_+3A_extravar">extraVar</code></td>
<td>
<p>Extra variables as variable names, TRUE (all remaining) or FALSE (none).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With no frequency variable in input (microdata), the frequency variable in output  consists of ones and zeros.
By default, all variables, except the frequencies, are considered as dimensional variables.
By default, the grouping of dimensional variables is based on hierarchical relationships (<code>hierarchical = TRUE</code>).
With <code>varGroups = NULL</code> and <code>hierarchical = FALSE</code>,
each dimensional variable forms a separate group (as <code>as.list(dimVar)</code>).
Parameter <code>extraVar</code> can be specified as variable names.
<code>TRUE</code> means all remaining variables and <code>FALSE</code> no variables.
</p>
<p>When the contents of <code>varGroups[[i]]</code> is variable names, the data frame <code>unique(data[varGroups[[i]]])</code> will be made as a
building block within the function. A possibility is to supply such a data frame instead of variable names.
Then, the building block will be <code>unique(varGroups[[i]])</code>. Names and data frames can be mixed.
</p>


<h3>Value</h3>

<p>Extended data frame
</p>


<h3>See Also</h3>

<p>Advanced possibilities by varGroups-attribute. See <code><a href="#topic+Extend0rnd1">Extend0rnd1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[c(1, 4:6, 8, 11:15), ]
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

Extend0(z[, -4])
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"))
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"), extraVar = "year")
Extend0(z, hierarchical = FALSE, dimVar = c("age", "geo", "eu"), extraVar = FALSE)
Extend0(z, varGroups = list(c("age", "geo", "year"), "eu"))
Extend0(MakeFreq(z[c(1, 1, 1, 2, 2, 3:10), -4]))
Extend0(z, "ths_per")

# varGroups with data frames (same result as with names above)
Extend0(z, varGroups = list(z[c("age", "geo", "year")], z["eu"]))

# varGroups with both names and data frame
Extend0(z, varGroups = list(c("year", "geo", "eu"), data.frame(age = c("middle", "old"))))
</code></pre>

<hr>
<h2 id='Extend0rnd1'>varGroups-attribute to Extend0, Example functions</h2><span id='topic+Extend0rnd1'></span><span id='topic+Extend0rnd2'></span><span id='topic+Extend0rnd1b'></span>

<h3>Description</h3>

<p>Setting <code>attr(varGroups, "FunctionExtend0")</code> to a function
makes <code>Extend0</code> behave differently
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend0rnd1(data, varGroups, k = 1, rndSeed = 123)

Extend0rnd2(...)

Extend0rnd1b(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extend0rnd1_+3A_data">data</code></td>
<td>
<p>data.frame within <code><a href="#topic+Extend0">Extend0</a></code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_vargroups">varGroups</code></td>
<td>
<p>argument to <code><a href="#topic+Extend0">Extend0</a></code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_k">k</code></td>
<td>
<p>Number of rows generated is approx. <code>k*nrow(data)</code></p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_rndseed">rndSeed</code></td>
<td>
<p>Internal random seed to be used</p>
</td></tr>
<tr><td><code id="Extend0rnd1_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point is to create a function that takes <code>data</code> and <code>varGroups</code> as input
and that returns a data frame with a limited number of combinations of the elements in <code>varGroups</code>.
The example function here is limited to two varGroups elements.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[c(1, 5, 8, 14), ]
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

varGroups &lt;- list(c("year", "geo", "eu"), data.frame(age = c("middle", "old")))
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd1
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd1b
Extend0(z, varGroups = varGroups)

attr(varGroups, "FunctionExtend0") &lt;- Extend0rnd2
Extend0(z, varGroups = varGroups)

# To see what's going on internally. Data used only via nrow 
varGroups &lt;- list(data.frame(ab = rep(c("a", "b"), each = 4), abcd = c("a", "b", "c", "d")), 
                  data.frame(AB = rep(c("A", "B"), each = 3), ABC = c("A", "B", "C"))) 
a &lt;- Extend0rnd1(data.frame(1:5), varGroups)
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd1b(data.frame(1:5), varGroups)
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd2(data.frame(1:5), varGroups[2:1])
table(a[[1]], a[[2]])
table(a[[3]], a[[4]])
a &lt;- Extend0rnd1(data.frame(1:100), varGroups)
table(a[[1]], a[[2]]) # Maybe smaller numbers than expected since duplicates were removed
table(a[[3]], a[[4]])
</code></pre>

<hr>
<h2 id='FactorLevCorr'>Factor level correlation</h2><span id='topic+FactorLevCorr'></span>

<h3>Description</h3>

<p>A sort of correlation matrix useful to detect (hierarchical) relationships between the levels of factor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorLevCorr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FactorLevCorr_+3A_x">x</code></td>
<td>
<p>Input matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a sort of correlation matrix.
</p>
<p>Here we refer to ni as the number of present levels of variable i (the number of unique elements) and we refer to mij as the number
of present levels obtained by crossing variable i and variable j (the number unique rows of x[,c(i,j)]).
</p>
<p>The diagonal elements of the output matrix contains the number of present levels of each variable (=ni).
</p>
<p>The absolute values of off-diagonal elements:
</p>
<table>
<tr><td><code>0</code></td>
<td>
<p>when mij = ni*nj</p>
</td></tr>
<tr><td><code>1</code></td>
<td>
<p>when mij = max(ni,nj)</p>
</td></tr>
<tr><td><code>Other values</code></td>
<td>
<p>Computed as (ni*nj-mij)/(ni*nj-max(ni,nj))</p>
</td></tr>
</table>
<p>So 0 means that all possible level combinations exist in the data and 1 means that the two variables are
hierarchically related.
</p>
<p>The sign of off-diagonal elements:
</p>
<table>
<tr><td><code>positive</code></td>
<td>
<p>when ni&lt;nj</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>when ni&gt;nj</p>
</td></tr>
</table>
<p>In cases where ni=nj elements will be positive above the diagonal and negative below.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c("A","B","C"),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep="")
 m &lt;- cbind(x,y,z,zy)
 FactorLevCorr(m)

</code></pre>

<hr>
<h2 id='FindCommonCells'>Finding commonCells</h2><span id='topic+FindCommonCells'></span>

<h3>Description</h3>

<p>Finding lists defining common cells as needed for the input parameter
commonCells to the function protectLinkedTables in package sdcTable.
The function handles two tables based on the same main variables
but possibly different aggregating variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindCommonCells(dimList1, dimList2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindCommonCells_+3A_dimlist1">dimList1</code></td>
<td>
<p>As input parameter dimList to the function makeProblem in package sdcTable.</p>
</td></tr>
<tr><td><code id="FindCommonCells_+3A_dimlist2">dimList2</code></td>
<td>
<p>Another dimList with the same names and using the same level names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list according to the specifications in sdcTable.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 fg &lt;- FindTableGroup(m,findLinked=TRUE)
 dimLists &lt;- FindDimLists(m,fg$groupVarInd)
 # Using table1 and table2 in this example cause error,
 # but in other cases this may work well
 try(FindCommonCells(dimLists[fg$table$table1],dimLists[fg$table$table2]))
 FindCommonCells(dimLists[c(1,2)],dimLists[c(1,3)])
</code></pre>

<hr>
<h2 id='FindDimLists'>Finding dimList</h2><span id='topic+FindDimLists'></span>

<h3>Description</h3>

<p>Finding lists of level-hierarchy as needed for the input parameter
dimList to the function makeProblem in package sdcTable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDimLists(
  x,
  groupVarInd = HierarchicalGroups(x = x),
  addName = FALSE,
  sep = ".",
  xReturn = FALSE,
  total = "Total"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindDimLists_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables (micro data or cell counts data).</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_groupvarind">groupVarInd</code></td>
<td>
<p>List of vectors of indices defining the hierarchical variable groups.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_addname">addName</code></td>
<td>
<p>When TRUE the variable name is added to the level names, except for variables with most levels.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when addName apply.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_xreturn">xReturn</code></td>
<td>
<p>When TRUE x is also in output, possibly changed according to addName.</p>
</td></tr>
<tr><td><code id="FindDimLists_+3A_total">total</code></td>
<td>
<p>String used to name totals. A vector of length <code>ncol(x)</code> is also possible (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list according to the specifications in sdcTable.
When xReturn is TRUE output has an extra list level and x is the first element.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
FindDimLists(dataset[1:2])
FindDimLists(dataset[2:3])
FindDimLists(dataset[1:4])

FindDimLists(SSBtoolsData("magnitude1")[1:4], 
                total = c("TOTAL", "unused1", "Europe", "unused2"))
                
 x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 FindDimLists(m)
 FindDimLists(m, total = paste0("A", 1:4))
</code></pre>

<hr>
<h2 id='FindDisclosiveCells'>Find directly disclosive cells</h2><span id='topic+FindDisclosiveCells'></span>

<h3>Description</h3>

<p>Function for determining which cells in a frequency table can lead to
direct disclosure of an identifiable individual, assuming an attacker has the
background knowledge to place themselves (or a coalition) in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDisclosiveCells(
  data,
  freq,
  crossTable,
  primaryDims = names(crossTable),
  unknowns = rep(NA, length(primaryDims)),
  total = rep("Total", length(primaryDims)),
  unknown.threshold = 0,
  coalition = 1,
  suppressSmallCells = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindDisclosiveCells_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_freq">freq</code></td>
<td>
<p>vector containing frequencies</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_crosstable">crossTable</code></td>
<td>
<p>cross table of key variables produced by ModelMatrix
in parent function</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_primarydims">primaryDims</code></td>
<td>
<p>dimensions to be considered for direct disclosure.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_unknowns">unknowns</code></td>
<td>
<p>vector of unknown values for each of the primary dimensions.
If a primary dimension does not contain unknown values, NA should be passed.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_total">total</code></td>
<td>
<p>string name for marginal values</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_unknown.threshold">unknown.threshold</code></td>
<td>
<p>numeric for specifying a percentage for calculating
safety of cells. A cell is &quot;safe&quot; in a row if the number of unknowns exceeds
<code>unknown.threshold</code> percent of the row total.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_coalition">coalition</code></td>
<td>
<p>maximum number of units in a possible coalition, default 1</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_suppresssmallcells">suppressSmallCells</code></td>
<td>
<p>logical variable which determines whether small cells (&lt;= coalition) or large cells should be suppressed. Default FALSE.</p>
</td></tr>
<tr><td><code id="FindDisclosiveCells_+3A_...">...</code></td>
<td>
<p>parameters from main suppression method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not work on data containing hierarchical variables.
</p>


<h3>Value</h3>

<p>list with two named elements, the first ($primary) being a logical vector
marking directly disclosive cells, the second ($numExtra) a data.frame containing
information regarding the dimensions in which the cells are directly disclosive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extable &lt;- data.frame(v1 = rep(c('a', 'b', 'c'), times = 4),
            v2 = c('i','i', 'i','h','h','h','i','i','i','h','h','h'),
            v3 = c('y', 'y', 'y', 'y', 'y', 'y','z','z', 'z', 'z', 'z', 'z'),
            freq = c(0,0,5,0,2,3,1,0,3,1,1,2))
ex_freq &lt;- c(18,10,8,9,5,4,9,5,4,2,0,2,1,0,1,1,0,1,3,2,1,3,2,1,0,0,0,13,8,5,
             5,3,2,8,5,3)
cross &lt;- ModelMatrix(extable,
                     dimVar = 1:3,
                     crossTable = TRUE)$crossTable

FindDisclosiveCells(extable, ex_freq, cross) 
</code></pre>

<hr>
<h2 id='FindHierarchies'>Finding hierarchies automatically from data</h2><span id='topic+FindHierarchies'></span>

<h3>Description</h3>

<p><code><a href="#topic+FindDimLists">FindDimLists</a></code> and <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code> wrapped into a single function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindHierarchies(data, total = "Total")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindHierarchies_+3A_data">data</code></td>
<td>
<p>Matrix or data frame containing the variables (micro data or cell counts data).</p>
</td></tr>
<tr><td><code id="FindHierarchies_+3A_total">total</code></td>
<td>
<p>String used to name totals. A vector of length <code>ncol(data)</code> is also possible (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of hierarchies
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
FindHierarchies(dataset[1:2])
FindHierarchies(dataset[2:3])
FindHierarchies(dataset[1:4])

FindHierarchies(SSBtoolsData("magnitude1")[1:4], 
                total = c("TOTAL", "unused1", "Europe", "unused2"))

x &lt;- rep(c("A", "B", "C"), 3)
y &lt;- rep(c(11, 22, 11), 3)
z &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3)
zy &lt;- paste(z, y, sep = "")
m &lt;- cbind(x, y, z, zy)
FindHierarchies(m)
FindHierarchies(m, total = paste0("A", 1:4))
</code></pre>

<hr>
<h2 id='FindTableGroup'>Finding table(s) of hierarchical variable groups</h2><span id='topic+FindTableGroup'></span>

<h3>Description</h3>

<p>A single table or two linked tables are found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindTableGroup(
  x = NULL,
  findLinked = FALSE,
  mainName = TRUE,
  fCorr = FactorLevCorr(x),
  CheckHandling = warning
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindTableGroup_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_findlinked">findLinked</code></td>
<td>
<p>When TRUE, two linked tables can be in output</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_mainname">mainName</code></td>
<td>
<p>When TRUE the groupVarInd ouput is named according to first variable in group.</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_fcorr">fCorr</code></td>
<td>
<p>When non-null x is not needed as input.</p>
</td></tr>
<tr><td><code id="FindTableGroup_+3A_checkhandling">CheckHandling</code></td>
<td>
<p>Function (warning or stop) to be used in problematic situations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list with items
</p>
<table>
<tr><td><code>groupVarInd</code></td>
<td>
<p>List defining the hierarchical variable groups. First variable has most levels.</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>List containing one or two tables. These tables are coded as indices referring to elements of groupVarInd.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rep(c('A','B','C'),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep='')
 m &lt;- cbind(x,y,z,zy)
 FindTableGroup(m)
 FindTableGroup(m,findLinked=TRUE)
</code></pre>

<hr>
<h2 id='fix_fun_amf'>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code></h2><span id='topic+fix_fun_amf'></span>

<h3>Description</h3>

<p>Fix <code>fun</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_fun_amf(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_fun_amf_+3A_fun">fun</code></td>
<td>
<p>fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identical(fix_fun_amf("median"), c(median = median))

identical(fix_fun_amf(c("sum", "median")), c(sum = sum, median = median))

ff &lt;- c("sum", "median", "cor")
names(ff) &lt;- c("", NA, "Correlation")
identical(fix_fun_amf(ff), c(sum, median = median, Correlation = cor))

identical(fix_fun_amf(structure("median", names = "")), fix_fun_amf(median))
</code></pre>

<hr>
<h2 id='fix_vars_amf'>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code></h2><span id='topic+fix_vars_amf'></span>

<h3>Description</h3>

<p>Fix <code>vars</code> parameter to <code>aggregate_multiple_fun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_vars_amf(
  vars,
  name_sep = "_",
  seve_sep = ":",
  multi_sep = ",",
  names_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_vars_amf_+3A_vars">vars</code></td>
<td>
<p>vars</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_name_sep">name_sep</code></td>
<td>
<p>A character string used when output variable names are generated.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_seve_sep">seve_sep</code></td>
<td>
<p>A character string used when output variable names are generated from functions of several variables.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_multi_sep">multi_sep</code></td>
<td>
<p>A character string used when multiple output variable names are sent as input.</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_names_data">names_data</code></td>
<td>
<p><code>names(data)</code> to convert numeric input (indices)</p>
</td></tr>
<tr><td><code id="fix_vars_amf_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vars
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- fix_vars_amf

f(c("freq", "y", median = "freq", median = "y", e1 = "freq"))

v1 &lt;- list(sum = "a", sum = "w", q = c("a", "w"), mean = c("b", "w"))
v2 &lt;- list(c(fun = "sum", "a"), c(fun = "sum", "w"), c(fun = "q", "a", "w"), 
           c(fun = "mean", "b", "w"))
v3 &lt;- list(sum = "a", sum = "w", q = c(name = "a:w_q", "a", "w"), 
           `b:w_mean` = list(mean = c("b", "w")))
v4 &lt;- list(c(name = "a_sum", fun = "sum", "a"), 
           c(name = "w_sum", fun = "sum", "w"), 
           c(name = "a:w_q", fun = "q", "a", "w"), 
           c(name = "b:w_mean", fun = "mean", "b", "w"))
v5 &lt;- list(a_sum = c(fun = "sum", "a"), 
           w_sum = c(fun = "sum", "w"), 
           `a:w_q` = c(fun = "q", "a", "w"), 
           `b:w_mean` = c(fun = "mean", "b", "w"))

identical(f(v1), f(v2))
identical(f(v1), f(v3))
identical(f(v1), f(v4))
identical(f(v1), f(v5))

identical(f(v1), f(f(v1)))
identical(f(v1), v4)
</code></pre>

<hr>
<h2 id='ForceCharacterDataFrame'>ForceCharacterDataFrame</h2><span id='topic+ForceCharacterDataFrame'></span>

<h3>Description</h3>

<p>ForceCharacterDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceCharacterDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ForceCharacterDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='ForceFactorDataFrame'>ForceFactorDataFrame</h2><span id='topic+ForceFactorDataFrame'></span>

<h3>Description</h3>

<p>ForceFactorDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceFactorDataFrame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ForceFactorDataFrame_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='FormulaSelection'>Limit matrix or data frame to selected model terms</h2><span id='topic+FormulaSelection'></span><span id='topic+formula_selection'></span>

<h3>Description</h3>

<p>For use with output from <code><a href="#topic+ModelMatrix">ModelMatrix</a></code> or data frames derived from such output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormulaSelection(x, formula, intercept = NA)

formula_selection(x, formula, intercept = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormulaSelection_+3A_x">x</code></td>
<td>
<p>Model matrix or a data frame</p>
</td></tr>
<tr><td><code id="FormulaSelection_+3A_formula">formula</code></td>
<td>
<p>Formula representing the limitation
or character string(s) to be converted to a formula (see details)</p>
</td></tr>
<tr><td><code id="FormulaSelection_+3A_intercept">intercept</code></td>
<td>
<p>Parameter that specifies whether a possible intercept term (overall total) should be included in the output.
Default is <code>TRUE</code> when a formula is input. Otherwise, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection is based on <code>startCol</code> or <code>startRow</code> attribute in input <code>x</code>.
</p>
<p>With <strong>formula as character</strong>:
</p>

<ul>
<li> <p><strong><code>~</code></strong> is included:
Input is converted by <code>as.formula</code> and default intercept is <code>TRUE</code>.
</p>
</li>
<li> <p><strong><code>~</code></strong> is not included:
Internally, input data is converted to a formula by adding <code>~</code> and possibly <code>+</code>'s when the length is <code style="white-space: pre;">&#8288;&gt;1&#8288;</code>.
Default intercept is <code>FALSE</code> unless <code>"1"</code> or <code>"(Intercept)"</code> (is changed internally to <code>"1"</code>) is included.
</p>
</li></ul>



<h3>Value</h3>

<p>Limited model matrix or a data frame
</p>


<h3>Note</h3>

<p><code>formula_selection</code> and <code>FormulaSelection</code> are identical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

x &lt;- ModelMatrix(z, formula = ~age * year)

FormulaSelection(x, "age")
FormulaSelection(x, ~year)
FormulaSelection(x, ~year:age)

# x1, x2, x3, x4 and x4 are identical
x1 &lt;- FormulaSelection(x, ~age)
x2 &lt;- FormulaSelection(x, "~age")
x3 &lt;- FormulaSelection(x, "age", intercept = TRUE)
x4 &lt;- FormulaSelection(x, c("1", "age"))
x5 &lt;- FormulaSelection(x, c("(Intercept)", "age"))


a &lt;- ModelMatrix(z, formula = ~age * geo + year, crossTable = TRUE)
b &lt;- cbind(as.data.frame(a$crossTable), 
           sum = (t(a$modelMatrix) %*% z$ths_per)[, 1], 
           max = DummyApply(a$modelMatrix, 
           z$ths_per, max))
rownames(b) &lt;- NULL
attr(b, "startRow") &lt;- attr(a$modelMatrix, "startCol", exact = TRUE)

FormulaSelection(b, ~geo * age)
FormulaSelection(b, "age:geo")
FormulaSelection(b, ~year - 1)
</code></pre>

<hr>
<h2 id='FormulaSums'>Sums (aggregates) and/or sparse model matrix with possible cross table</h2><span id='topic+FormulaSums'></span><span id='topic+Formula2ModelMatrix'></span>

<h3>Description</h3>

<p>By default this function return sums if the formula contains a response part and a model matrix otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormulaSums(
  data,
  formula,
  makeNames = TRUE,
  crossTable = FALSE,
  total = "Total",
  printInc = FALSE,
  dropResponse = FALSE,
  makeModelMatrix = NULL,
  sep = "-",
  sepCross = ":",
  avoidHierarchical = FALSE,
  includeEmpty = FALSE,
  ...
)

Formula2ModelMatrix(data, formula, dropResponse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormulaSums_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_makenames">makeNames</code></td>
<td>
<p>Column/row names made when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_total">total</code></td>
<td>
<p>String used to name totals</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when TRUE</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_dropresponse">dropResponse</code></td>
<td>
<p>When TRUE response part of formula ignored.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_makemodelmatrix">makeModelMatrix</code></td>
<td>
<p>Make model matrix when TRUE. NULL means automatic.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_sep">sep</code></td>
<td>
<p>String to separate when creating column names</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_sepcross">sepCross</code></td>
<td>
<p>String to separate when creating column names involving crossing</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_avoidhierarchical">avoidHierarchical</code></td>
<td>
<p>Whether to avoid treating of hierarchical variables. Instead of logical, variables can be specified.</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_includeempty">includeEmpty</code></td>
<td>
<p>When <code>TRUE</code>, empty columns of the model matrix (only zeros) are included.
This is not implemented when a response term is included in the formula and <code>dropResponse = FALSE</code> (error will be produced).</p>
</td></tr>
<tr><td><code id="FormulaSums_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>FormulaSums</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model matrix is constructed by calling fac2sparse() repeatedly. The sums are computed by calling aggregate() repeatedly.
Hierarchical variables handled when constructing cross table.
Column names constructed from the cross table.
The returned model matrix includes the attribute <code>startCol</code> (see last example line).
</p>


<h3>Value</h3>

<p>A matrix of sums, a sparse model matrix or a list of two or three elements (model matrix and cross table and sums when relevant).
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_withEU")

FormulaSums(x, ths_per ~ year*geo + year*eu)
FormulaSums(x, ~ year*age*eu)
FormulaSums(x, ths_per ~ year*age*geo + year*age*eu, crossTable = TRUE, makeModelMatrix = TRUE)
FormulaSums(x, ths_per ~ year:age:geo -1)
m &lt;- Formula2ModelMatrix(x, ~ year*geo + year*eu)
print(m[1:3, ], col.names = TRUE)
attr(m, "startCol")
</code></pre>

<hr>
<h2 id='GaussIndependent'>Linearly independent rows and columns by Gaussian elimination</h2><span id='topic+GaussIndependent'></span><span id='topic+GaussRank'></span>

<h3>Description</h3>

<p>The function is written primarily for large sparse matrices with integers
and even more correctly it is primarily written for dummy matrices (0s and 1s in input matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussIndependent(
  x,
  printInc = FALSE,
  tolGauss = (.Machine$double.eps)^(1/2),
  testMaxInt = 0,
  allNumeric = FALSE
)

GaussRank(x, printInc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussIndependent_+3A_x">x</code></td>
<td>
<p>A (sparse) matrix</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when <code>TRUE</code></p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_tolgauss">tolGauss</code></td>
<td>
<p>A tolerance parameter for sparse Gaussian elimination and linear dependency. This parameter is used only in cases where integer calculation cannot be used.</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_testmaxint">testMaxInt</code></td>
<td>
<p>Parameter for testing: The Integer overflow situation will be forced when testMaxInt is exceeded</p>
</td></tr>
<tr><td><code id="GaussIndependent_+3A_allnumeric">allNumeric</code></td>
<td>
<p>Parameter for testing: All calculations use numeric algorithm (as integer overflow) when TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GaussRank returns the rank
</p>


<h3>Value</h3>

<p>List of logical vectors specifying independent rows and columns
</p>


<h3>Note</h3>

<p>The main algorithm is based on integers and exact calculations. When integers cannot be used (because of input or overflow), the algorithm switches.
With <code>printInc = TRUE</code> as a parameter, <code>.....</code> change to <code style="white-space: pre;">&#8288;-----&#8288;</code> when switching to numeric algorithm.
With numeric algorithm, a kind of tolerance for linear dependency is included.
This tolerance is designed having in mind that the input matrix is a dummy matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ModelMatrix(SSBtoolsData("z2"), formula = ~fylke + kostragr * hovedint - 1)

GaussIndependent(x)
GaussRank(x)
GaussRank(t(x))

## Not run: 
# For comparison, qr-based rank may not work
rankMatrix(x, method = "qr")

# Dense qr works 
qr(as.matrix(x))$rank

## End(Not run)
</code></pre>

<hr>
<h2 id='GaussIterationFunction'>An <code>iFunction</code> argument to <code><a href="#topic+GaussSuppression">GaussSuppression</a></code></h2><span id='topic+GaussIterationFunction'></span>

<h3>Description</h3>

<p>Use this function as <code>iFunction</code> or write your own using the same seven first parameters and also using <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussIterationFunction(i, I, j, J, true, false, na, filename = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussIterationFunction_+3A_i">i</code></td>
<td>
<p>Number of candidates processed (columns of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_i">I</code></td>
<td>
<p>Total number of candidates to be processed (columns of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_j">j</code></td>
<td>
<p>Number of eliminated dimensions (rows of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_j">J</code></td>
<td>
<p>Total number of dimensions (rows of <code>x</code>)</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_true">true</code></td>
<td>
<p>Candidates decided to be suppressed</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_false">false</code></td>
<td>
<p>Candidates decided to be not suppressed</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_na">na</code></td>
<td>
<p>Candidates not decided</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_filename">filename</code></td>
<td>
<p>When non-NULL, the above arguments will be saved to this file.
Note that <code>GaussSuppression</code> passes this parameter via <code>...</code>.</p>
</td></tr>
<tr><td><code id="GaussIterationFunction_+3A_...">...</code></td>
<td>
<p>Extra parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of candidates decided (<code>true</code> and <code>false</code>) may differ from the number of candidates processed (<code>i</code>) due to parameter <code>removeDuplicated</code>
and because the decision for some unprocessed candidates can be found due to empty columns.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='GaussSuppression'>Secondary suppression by Gaussian elimination</h2><span id='topic+GaussSuppression'></span>

<h3>Description</h3>

<p>Sequentially the secondary suppression candidates (columns in x) are used to reduce the x-matrix by Gaussian elimination.
Candidates who completely eliminate one or more primary suppressed cells (columns in x) are omitted and made secondary suppressed.
This ensures that the primary suppressed cells do not depend linearly on the non-suppressed cells.
How to order the input candidates is an important choice.
The singleton problem and the related problem of zeros are also handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSuppression(
  x,
  candidates = 1:ncol(x),
  primary = NULL,
  forced = NULL,
  hidden = NULL,
  singleton = rep(FALSE, nrow(x)),
  singletonMethod = "anySum",
  printInc = TRUE,
  tolGauss = (.Machine$double.eps)^(1/2),
  whenEmptySuppressed = warning,
  whenEmptyUnsuppressed = message,
  whenPrimaryForced = warning,
  removeDuplicated = TRUE,
  iFunction = GaussIterationFunction,
  iWait = Inf,
  xExtraPrimary = NULL,
  unsafeAsNegative = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSuppression_+3A_x">x</code></td>
<td>
<p>Matrix that relates cells to be published or suppressed to inner cells. yPublish = crossprod(x,yInner)</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_candidates">candidates</code></td>
<td>
<p>Indices of candidates for secondary suppression</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_primary">primary</code></td>
<td>
<p>Indices of primary suppressed cells</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_forced">forced</code></td>
<td>
<p>Indices forced to be not suppressed. <code>forced</code> has precedence over <code>primary</code>. See <code>whenPrimaryForced</code> below.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_hidden">hidden</code></td>
<td>
<p>Indices to be removed from the above <code>candidates</code> input (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_singleton">singleton</code></td>
<td>
<p>Logical or integer vector of length <code>nrow(x)</code> specifying inner cells for singleton handling.
Normally, for frequency tables, this means cells with 1s when 0s are non-suppressed and cells with 0s when 0s are suppressed.
For some singleton methods, integer values representing the unique magnitude table contributors are needed.
For all other singleton methods, only the values after conversion with <code>as.logical</code> matter.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p>Method for handling the problem of singletons and zeros:
<code>"anySum"</code> (default), <code>"anySum0"</code>, <code>"anySumNOTprimary"</code>, <code>"subSum"</code>, <code>"subSpace"</code>, <code>"sub2Sum"</code>, <code>"none"</code>
or a <code><a href="#topic+NumSingleton">NumSingleton</a></code> method (see details).</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when TRUE</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_tolgauss">tolGauss</code></td>
<td>
<p>A tolerance parameter for sparse Gaussian elimination and linear dependency. This parameter is used only in cases where integer calculation cannot be used.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenemptysuppressed">whenEmptySuppressed</code></td>
<td>
<p>Function to be called when empty input to primary suppressed cells is problematic. Supply NULL to do nothing.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenemptyunsuppressed">whenEmptyUnsuppressed</code></td>
<td>
<p>Function to be called when empty input to candidate cells may be problematic. Supply NULL to do nothing.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_whenprimaryforced">whenPrimaryForced</code></td>
<td>
<p>Function to be called if any forced cells are primary suppressed (suppression will be ignored). Supply NULL to do nothing.
The same function will also be called when there are forced cells marked as singletons (will be ignored).</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_removeduplicated">removeDuplicated</code></td>
<td>
<p>Whether to remove duplicated columns in <code>x</code> before running the main algorithm.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_ifunction">iFunction</code></td>
<td>
<p>A function to be called during the iterations. See the default function, <code><a href="#topic+GaussIterationFunction">GaussIterationFunction</a></code>, for description of parameters.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_iwait">iWait</code></td>
<td>
<p>The minimum number of seconds between each call to <code>iFunction</code>.
Whenever <code>iWait&lt;Inf</code>, <code>iFunction</code> will also be called after last iteration.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_xextraprimary">xExtraPrimary</code></td>
<td>
<p>Extra x-matrix that defines extra primary suppressed cells in addition to those defined by other inputs.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_unsafeasnegative">unsafeAsNegative</code></td>
<td>
<p>When <code>TRUE</code>, unsafe primary cells due to forced cells are included in the output vector as negative indices.</p>
</td></tr>
<tr><td><code id="GaussSuppression_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to specify too many (all) indices as <code>candidates</code>.
Indices specified as <code>primary</code> or <code>hidded</code> will be removed.
Hidden indices (not candidates or primary) refer to cells that will not be published, but do not need protection.
</p>

<ul>
<li> <p><strong>Singleton methods for frequency tables:</strong>
All singleton methods, except <code>"sub2Sum"</code> and the <code><a href="#topic+NumSingleton">NumSingleton</a></code> methods, have been implemented with frequency tables in mind.
The singleton method <code>"subSum"</code> makes new imaginary primary suppressed cells, which are the sum of the singletons
within each group. The <code>"subSpace"</code> method is conservative and ignores the singleton dimensions when looking for
linear dependency. The default method, <code>"anySum"</code>, is between the other two. Instead of making imaginary cells of
sums within groups, the aim is to handle all possible sums, also across groups. In addition, <code>"subSumSpace"</code>  and
<code>"subSumAny"</code> are possible methods, primarily for testing. These methods are similar to <code>"subSpace"</code> and <code>"anySum"</code>,
and additional cells are created as in <code>"subSum"</code>. It is believed that the extra cells are redundant.
Note that in order to give information about unsafe cells, <code>"anySum"</code>  is internally changed to <code>"subSumAny"</code> when there are forced cells.
All the above methods assume that any published singletons are primary suppressed.
If this is not the case, either <code>"anySumNOTprimary"</code> or <code>"anySum0"</code> must be used.
Notably, <code>"anySum0"</code> is an enhancement of <code>"anySumNOTprimary"</code> for situations where zeros are singletons.
Using that method avoids suppressing a zero marginal along with only one of its children.
</p>
</li>
<li> <p><strong>Singleton methods for magnitude tables:</strong>
The singleton method <code>"sub2Sum"</code> makes new imaginary primary suppressed cells, which are the sum of two inner cells.
This is done when a group contains exactly two primary suppressed inner cells provided that at least one of them is singleton.
This was the first method implemented. Other magnitude methods follow the coding according to <code><a href="#topic+NumSingleton">NumSingleton</a></code>.
The <code>"sub2Sum"</code> method is equivalent to <code>"numFFT"</code>.
Also note that <code>"num"</code>, <code>"numFFF"</code> and <code>"numFTF"</code> are equivalent to <code>"none"</code>.
</p>
</li>
<li> <p><strong>Combined:</strong>
For advanced use, <code>singleton</code> can be a two-element list with names <code>"freq"</code> and <code>"num"</code>.
Then <code>singletonMethod</code> must be a corresponding named two-element vector.
For example: <code>singletonMethod = c(freq = "anySumNOTprimary", num = "sub2Sum")</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Secondary suppression indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Input data
df &lt;- data.frame(values = c(1, 1, 1, 5, 5, 9, 9, 9, 9, 9, 0, 0, 0, 7, 7), 
                 var1 = rep(1:3, each = 5), 
                 var2 = c("A", "B", "C", "D", "E"), stringsAsFactors = FALSE)

# Make output data frame and x 
fs &lt;- FormulaSums(df, values ~ var1 * var2, crossTable = TRUE, makeModelMatrix = TRUE)
x &lt;- fs$modelMatrix
datF &lt;- data.frame(fs$crossTable, values = as.vector(fs$allSums))

# Add primary suppression 
datF$primary &lt;- datF$values
datF$primary[datF$values &lt; 5 &amp; datF$values &gt; 0] &lt;- NA
datF$suppressedA &lt;- datF$primary
datF$suppressedB &lt;- datF$primary
datF$suppressedC &lt;- datF$primary

# zero secondary suppressed
datF$suppressedA[GaussSuppression(x, primary = is.na(datF$primary))] &lt;- NA

# zero not secondary suppressed by first in ordering
datF$suppressedB[GaussSuppression(x, c(which(datF$values == 0), which(datF$values &gt; 0)), 
                            primary = is.na(datF$primary))] &lt;- NA

# with singleton
datF$suppressedC[GaussSuppression(x, c(which(datF$values == 0), which(datF$values &gt; 0)), 
                            primary = is.na(datF$primary), singleton = df$values == 1)] &lt;- NA

datF

</code></pre>

<hr>
<h2 id='HierarchicalGroups'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups'></span>

<h3>Description</h3>

<p>According to the (factor) levels of the variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups(
  x = NULL,
  mainName = TRUE,
  eachName = FALSE,
  fCorr = FactorLevCorr(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchicalGroups_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_mainname">mainName</code></td>
<td>
<p>When TRUE output list is named according to first variable in group.</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_eachname">eachName</code></td>
<td>
<p>When TRUE variable names in output instead of indices.</p>
</td></tr>
<tr><td><code id="HierarchicalGroups_+3A_fcorr">fCorr</code></td>
<td>
<p>When non-null, x is not needed as input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list containing the groups. First variable has most levels.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("example1")
HierarchicalGroups(dataset[1:2], eachName = TRUE)
HierarchicalGroups(dataset[2:3])
HierarchicalGroups(dataset[1:4], eachName = TRUE)

HierarchicalGroups(SSBtoolsData("magnitude1")[1:4])

 x &lt;- rep(c("A","B","C"),3)
 y &lt;- rep(c(11,22,11),3)
 z &lt;- c(1,1,1,2,2,2,3,3,3)
 zy &lt;- paste(z,y,sep="")
 m &lt;- cbind(x,y,z,zy)
 HierarchicalGroups(m)
</code></pre>

<hr>
<h2 id='HierarchicalGroups2'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups2'></span>

<h3>Description</h3>

<p>As HierarchicalGroups() with eachName = TRUE, but output belonging to same mainName are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchicalGroups2_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the groups.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='HierarchicalGroups3'>Finding hierarchical variable groups</h2><span id='topic+HierarchicalGroups3'></span>

<h3>Description</h3>

<p>As HierarchicalGroups() with eachName = FALSE, but output belonging to same mainName are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalGroups3(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchicalGroups3_+3A_x">x</code></td>
<td>
<p>Matrix or data frame containing the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the groups.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='HierarchicalWildcardGlobbing'>Find variable combinations by advanced wildcard/globbing specifications.</h2><span id='topic+HierarchicalWildcardGlobbing'></span>

<h3>Description</h3>

<p>Find combinations present in an input data frame or, when input is a list,
find all possible combinations that meet the requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchicalWildcardGlobbing(
  z,
  wg,
  useUnique = NULL,
  useFactor = FALSE,
  makeWarning = TRUE,
  printInfo = FALSE,
  useMatrixToDataFrame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_z">z</code></td>
<td>
<p>list or data.frame</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_wg">wg</code></td>
<td>
<p>data.frame with data globbing and wildcards</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_useunique">useUnique</code></td>
<td>
<p>Logical variable about recoding within the algorithm. By default (NULL) an automatic decision is made.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_usefactor">useFactor</code></td>
<td>
<p>When TRUE, internal factor recoding is used.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_makewarning">makeWarning</code></td>
<td>
<p>When TRUE, warning is made in cases of unused variables. Only variables common to z and wg are used.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_printinfo">printInfo</code></td>
<td>
<p>When TRUE, information is printed during the process.</p>
</td></tr>
<tr><td><code id="HierarchicalWildcardGlobbing_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>When TRUE, special functions (DataFrameToMatrix/MatrixToDataFrame)
for improving speed and memory is utilized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The final variable combinations must meet the requirements in each positive sign group
and must not match the requirements in the negative sign groups.The function is implemented by
calling <code><a href="#topic+WildcardGlobbing">WildcardGlobbing</a></code> several times within an algorithm that uses
hierarchical clustering (<code><a href="stats.html#topic+hclust">hclust</a></code>).
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                  
# useUnique=NULL betyr valg ut fra antall rader i kombinasjonsfil
data(precip)
data(mtcars)
codes &lt;- as.character(c(100, 200, 300, 600, 700, 101, 102, 103, 104, 134, 647, 783, 
                        13401, 13402, 64701, 64702))


# Create list input
zList &lt;- list(car = rownames(mtcars), wt = as.character(1000 * mtcars$wt), 
              city = names(precip), code = codes)

# Create data.frame input
m &lt;- cbind(car = rownames(mtcars), wt = as.character(1000 * mtcars$wt))
zFrame &lt;- data.frame(m[rep(1:NROW(m), each = 35), ], 
                     city = names(precip), code = codes, stringsAsFactors = FALSE)

# Create globbing/wildcards input
wg &lt;- data.frame(rbind(c("Merc*", ""    , ""    , "?00"  ), 
                       c("F*"   , ""    , ""    , "?????"), 
                       c(""     , "???0", "C*"  , ""     ), 
                       c(""     , ""    , "!Co*", ""     ), 
                       c(""     , ""    , "?i*" , "????2"), 
                       c(""     , ""    , "?h*" , "????1")), 
           sign = c("+", "+", "+", "+", "-", "-"), stringsAsFactors = FALSE)
names(wg)[1:4] &lt;- names(zList)



# =================================================================== 
#   Finding unique combinations present in the input data frame
# ===================================================================


# Using first row of wg. Combinations of car starting with Merc 
# and three-digit code ending with 00
HierarchicalWildcardGlobbing(zFrame[, c(1, 4)], wg[1, c(1, 4, 5)])

# Using first row of wg. Combinations of all four variables
HierarchicalWildcardGlobbing(zFrame, wg[1, ])

# More combinations when using second row also
HierarchicalWildcardGlobbing(zFrame, wg[1:2, ])

# Less combinations when using third row also 
# since last digit of wt must be 0 and only cities starting with C
HierarchicalWildcardGlobbing(zFrame, wg[1:3, ])


# Less combinations when using fourth row also since city cannot start with Co
HierarchicalWildcardGlobbing(zFrame, wg[1:4, ])

# Less combinations when using fourth row also 
# since specific combinations of city and code are removed
HierarchicalWildcardGlobbing(zFrame, wg)


# =================================================================== 
#  Using list input to create all possible combinations
# ===================================================================

dim(HierarchicalWildcardGlobbing(zList, wg))

# same result with as.list since same unique values of each variable
dim(HierarchicalWildcardGlobbing(as.list(zFrame), wg))
</code></pre>

<hr>
<h2 id='Hierarchies2ModelMatrix'>Model matrix representing crossed hierarchies</h2><span id='topic+Hierarchies2ModelMatrix'></span>

<h3>Description</h3>

<p>Make a model matrix, x, that corresponds to data and represents all hierarchies crossed.
This means that aggregates corresponding to numerical variables can be computed as
<code>t(x) %*% y</code>, where  <code>y</code> is a matrix with one column for each numerical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hierarchies2ModelMatrix(
  data,
  hierarchies,
  inputInOutput = TRUE,
  crossTable = FALSE,
  total = "Total",
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  unionComplement = FALSE,
  reOrder = TRUE,
  select = NULL,
  removeEmpty = FALSE,
  selectionByMultiplicationLimit = 10^7,
  makeColnames = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.
Also see note.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_total">total</code></td>
<td>
<p>See <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code></p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code></p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (default) output codes are ordered in a way similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output
or a named list specifying code selections for each variable (see details).</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When TRUE and when <code>select</code> is not a data frame, empty columns (only zeros) are not included in output.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_selectionbymultiplicationlimit">selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>select</code> and when the number of elements in the model matrix exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_makecolnames">makeColnames</code></td>
<td>
<p>Colnames included when TRUE (default).</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td></tr>
<tr><td><code id="Hierarchies2ModelMatrix_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>
and <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>  via  <code><a href="#topic+HierarchyComputeDummy">HierarchyComputeDummy</a></code>.
Since the dummy matrix is transposed in comparison to <code>HierarchyCompute</code>, the parameter <code>rowSelect</code> is renamed to <code>select</code>
and  <code>makeRownames</code> is renamed to <code>makeColnames</code>.
</p>
<p>The select parameter as a list can be partially specified in the sense that not all hierarchy names have to be included.
The parameter <code>inputInOutput</code> will only apply to hierarchies that are not in the <code>select</code> list (see note).
</p>


<h3>Value</h3>

<p>A sparse model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Note</h3>

<p>The <code>select</code> as a list is run via a special coding of the <code>inputInOutput</code> parameter.
This parameter is converted into a list (<code>as.list</code>) and <code>select</code> elements are inserted into this list.
This is also an additional option for users of the function.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>, <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sprt_emp_withEU")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]


# First example has list output
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE, 
                        crossTable = TRUE)


m1 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE)
m2 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList))
m3 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = ""),
                              inputInOutput = FALSE)
m4 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = "allYears"), 
                              inputInOutput = c(FALSE, FALSE, TRUE))

# Illustrate the effect of unionComplement, geoHier2 as in the examples of HierarchyCompute
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  SSBtoolsData("sprt_emp_geoHier")[, -4])
m5 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE)  # Spain is counted twice
m6 &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoHier2, year = "allYears"), 
                              inputInOutput = FALSE, unionComplement = TRUE)


# Compute aggregates
ths_per &lt;- as.matrix(z[, "ths_per", drop = FALSE])  # matrix with the values to be aggregated
t(m1) %*% ths_per  # crossprod(m1, ths_per) is equivalent and faster
t(m2) %*% ths_per
t(m3) %*% ths_per
t(m4) %*% ths_per
t(m5) %*% ths_per
t(m6) %*% ths_per


# Example using the select parameter as a data frame
select &lt;- data.frame(age = c("Y15-64", "Y15-29", "Y30-64"), geo = c("EU", "nonEU", "Spain"))
m2a &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), select = select)

# Same result by slower alternative
m2B &lt;- Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), crossTable = TRUE)
m2b &lt;- m2B$modelMatrix[, Match(select, m2B$crossTable), drop = FALSE]
t(m2b) %*% ths_per

# Examples using the select parameter as a list
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       inputInOutput = FALSE, 
       select = list(geo = c("nonEU", "Portugal")))
Hierarchies2ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
       select = list(geo = c("nonEU", "Portugal"), age = c("Y15-64", "Y15-29")))

</code></pre>

<hr>
<h2 id='HierarchiesAndFormula2ModelMatrix'>Model matrix representing crossed hierarchies according to a formula</h2><span id='topic+HierarchiesAndFormula2ModelMatrix'></span>

<h3>Description</h3>

<p>How to cross the hierarchies are defined by a formula. The formula is automatically simplified when totals are involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchiesAndFormula2ModelMatrix(
  data,
  hierarchies,
  formula,
  inputInOutput = TRUE,
  makeColNames = TRUE,
  crossTable = FALSE,
  total = "Total",
  simplify = TRUE,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  unionComplement = FALSE,
  removeEmpty = FALSE,
  reOrder = TRUE,
  sep = "-",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_makecolnames">makeColNames</code></td>
<td>
<p>Colnames included when TRUE (default).</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_total">total</code></td>
<td>
<p>Vector of total codes (possibly recycled) used when running <code><a href="#topic+Hrc2DimList">Hrc2DimList</a></code></p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_simplify">simplify</code></td>
<td>
<p>When TRUE (default) the model can be simplified when total codes are found in the hierarchies (see examples).</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code></p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When TRUE, empty columns (only zeros) are not included in output.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (default) output codes are ordered in a way similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_sep">sep</code></td>
<td>
<p>String to separate when creating column names</p>
</td></tr>
<tr><td><code id="HierarchiesAndFormula2ModelMatrix_+3A_...">...</code></td>
<td>
<p>Extra unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>, <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sprt_emp_withEU")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]

# Shorter function name
H &lt;- HierarchiesAndFormula2ModelMatrix

# Small dataset example. Two dimensions.
s &lt;- z[z$geo == "Spain", ]
geoYear &lt;- list(geo = geoDimList, year = "")
m &lt;- H(s, geoYear, ~geo * year, inputInOutput = c(FALSE, TRUE))
print(m, col.names = TRUE)
attr(m, "total")     # Total code 'Europe' is found
attr(m, "startCol")  # Two model terms needed

# Another model and with crossTable in output
H(s, geoYear, ~geo + year, crossTable = TRUE)

# Without empty columns  
H(s, geoYear, ~geo + year, crossTable = TRUE, removeEmpty = TRUE)

# Three dimensions
ageGeoYear &lt;- list(age = ageHier, geo = geoDimList, year = "allYears")
m &lt;- H(z, ageGeoYear, ~age * geo + geo * year)
head(colnames(m))
attr(m, "total")
attr(m, "startCol")

# With simplify = FALSE
m &lt;- H(z, ageGeoYear, ~age * geo + geo * year, simplify = FALSE)
head(colnames(m))
attr(m, "total")
attr(m, "startCol")

# Compute aggregates
m &lt;- H(z, ageGeoYear, ~geo * age, inputInOutput = c(TRUE, FALSE, TRUE))
t(m) %*% z$ths_per

# Without hierarchies. Only factors.
ageGeoYearFactor &lt;- list(age = "", geo = "", year = "")
t(H(z, ageGeoYearFactor, ~geo * age + year:geo))
</code></pre>

<hr>
<h2 id='Hierarchy2Formula'>Hierarchy2Formula</h2><span id='topic+Hierarchy2Formula'></span><span id='topic+Formula2Hierarchy'></span><span id='topic+Hierarchies2Formulas'></span>

<h3>Description</h3>

<p>Conversion between to-from coded hierarchy and formulas written with =, - and +.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hierarchy2Formula(
  x,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level")
)

Formula2Hierarchy(s)

Hierarchies2Formulas(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hierarchy2Formula_+3A_x">x</code></td>
<td>
<p>Data frame with to-from coded hierarchy</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_s">s</code></td>
<td>
<p>Character vector of formulas written with =, - and +.</p>
</td></tr>
<tr><td><code id="Hierarchy2Formula_+3A_...">...</code></td>
<td>
<p>Extra parameters. Only <code>hierarchyVarNames</code> is relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See Arguments
</p>


<h3>Note</h3>

<p><code>Hierarchies2Formulas</code> is a wrapper for <code>lapply(x, Hierarchy2Formula, ...)</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimList2Hierarchy">DimList2Hierarchy</a></code>, <code><a href="#topic+DimList2Hrc">DimList2Hrc</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_geoHier")
s &lt;- Hierarchy2Formula(x)
s
Formula2Hierarchy(s)

# Demonstrate Hierarchies2Formulas and problems 
hi &lt;- FindHierarchies(SSBtoolsData("sprt_emp_withEU")[, c("geo", "eu", "age")])
hi
Hierarchies2Formulas(hi) # problematic formula since minus sign in coding 
AutoHierarchies(Hierarchies2Formulas(hi)) # Not same as hi because of problems 

# Change coding to avoid problems 
hi$age$mapsFrom &lt;- gsub("-", "_", hi$age$mapsFrom)
hi
Hierarchies2Formulas(hi)
AutoHierarchies(Hierarchies2Formulas(hi))

</code></pre>

<hr>
<h2 id='HierarchyCompute'>Hierarchical Computations</h2><span id='topic+HierarchyCompute'></span>

<h3>Description</h3>

<p>This function computes aggregates by crossing several hierarchical specifications and factorial variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyCompute(
  data,
  hierarchies,
  valueVar,
  colVar = NULL,
  rowSelect = NULL,
  colSelect = NULL,
  select = NULL,
  inputInOutput = FALSE,
  output = "data.frame",
  autoLevel = TRUE,
  unionComplement = FALSE,
  constantsInOutput = NULL,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  selectionByMultiplicationLimit = 10^7,
  colNotInDataWarning = TRUE,
  useMatrixToDataFrame = TRUE,
  handleDuplicated = "sum",
  asInput = FALSE,
  verbose = FALSE,
  reOrder = FALSE,
  reduceData = TRUE,
  makeRownames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchyCompute_+3A_data">data</code></td>
<td>
<p>The input data frame</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_hierarchies">hierarchies</code></td>
<td>
<p>A named (names in <code>data</code>) list with hierarchies. Variables can also be coded by <code>"rowFactor"</code> and <code>"colFactor"</code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_valuevar">valueVar</code></td>
<td>
<p>Name of the variable(s) to be aggregated.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colvar">colVar</code></td>
<td>
<p>When non-NULL, the function <code><a href="#topic+HierarchyCompute2">HierarchyCompute2</a></code> is called. See its documentation for more information.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_rowselect">rowSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is not included.
In addition <code>rowSelect="removeEmpty"</code> removes combinations corresponding to empty rows (only zeros) of <code>dataDummyHierarchy</code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colselect">colSelect</code></td>
<td>
<p>Vector specifying categories of the colFactor variable for output.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output. The colFactor variable is included.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_output">output</code></td>
<td>
<p>One of &quot;data.frame&quot; (default), &quot;dummyHierarchies&quot;, &quot;outputMatrix&quot;, &quot;dataDummyHierarchy&quot;, &quot;valueMatrix&quot;, &quot;fromCrossCode&quot;,
&quot;toCrossCode&quot;, &quot;crossCode&quot; (as toCrossCode), &quot;outputMatrixWithCrossCode&quot;, &quot;matrixComponents&quot;,
&quot;dataDummyHierarchyWithCodeFrame&quot;, &quot;dataDummyHierarchyQuick&quot;.
The latter two do not require <code>valueVar</code> (<code>reduceData</code> set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_autolevel">autoLevel</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, level is computed by automatic method as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_unioncomplement">unionComplement</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
When TRUE, sign means union and complement instead of addition or subtraction as in <code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code>.
Values corresponding to <code>"rowFactor"</code> and <code>"colFactor"</code> are ignored.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_constantsinoutput">constantsInOutput</code></td>
<td>
<p>A single row data frame to be combine by the other output.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>Variable names in the hierarchy tables as in <code><a href="#topic+HierarchyFix">HierarchyFix</a></code>.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_selectionbymultiplicationlimit">selectionByMultiplicationLimit</code></td>
<td>
<p>With non-NULL <code>rowSelect</code> and when the number of elements in <code>dataDummyHierarchy</code> exceeds this limit,
the computation is performed by a slower but more memory efficient algorithm.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_colnotindatawarning">colNotInDataWarning</code></td>
<td>
<p>When TRUE, warning produced when elements of <code>colSelect</code> are not in data.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_usematrixtodataframe">useMatrixToDataFrame</code></td>
<td>
<p>When TRUE (default) special functionality for saving time and memory is used.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_handleduplicated">handleDuplicated</code></td>
<td>
<p>Handling of duplicated code rows in data. One of: &quot;sum&quot; (default), &quot;sumByAggregate&quot;, &quot;sumWithWarning&quot;, &quot;stop&quot; (error), &quot;single&quot; or &quot;singleWithWarning&quot;.
With no colFactor sum and sumByAggregate/sumWithWarning are different (original values or aggregates in &quot;valueMatrix&quot;).
When single, only one of the values is used (by matrix subsetting).</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_asinput">asInput</code></td>
<td>
<p>When TRUE (FALSE is default) output matrices match input data. Thus
<code>valueMatrix</code> <code>=</code> <code>Matrix(data[, valueVar],ncol=1)</code>. Only possible when no colFactor.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations. FALSE is default.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_reorder">reOrder</code></td>
<td>
<p>When TRUE (FALSE is default) output codes are ordered differently, more similar to a usual model matrix ordering.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_reducedata">reduceData</code></td>
<td>
<p>When TRUE (default) unnecessary (for the aggregated result) rows of <code>valueMatrix</code> are allowed to be removed.</p>
</td></tr>
<tr><td><code id="HierarchyCompute_+3A_makerownames">makeRownames</code></td>
<td>
<p>When TRUE <code>dataDummyHierarchy</code> contains rownames. By default, this is decided based on the parameter <code>output</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A key element of this function is the matrix multiplication:
<code>outputMatrix</code> <code>=</code> <code>dataDummyHierarchy</code> <code>%*%</code> <code>valueMatrix</code>.
The matrix, <code>valueMatrix</code> is a re-organized version of the valueVar vector from input. In particular,
if a variable is selected as <code>colFactor</code>, there is one column for each level of that variable.
The matrix, <code>dataDummyHierarchy</code> is constructed by crossing dummy coding of hierarchies (<code><a href="#topic+DummyHierarchy">DummyHierarchy</a></code>) and factorial variables
in a way that matches <code>valueMatrix</code>.  The code combinations corresponding to rows and columns of <code>dataDummyHierarchy</code>
can be obtained as <code>toCrossCode</code> and <code>fromCrossCode</code>.  In the default data frame output, the <code>outputMatrix</code> is stacked
to one column and combined with the code combinations of all variables.
</p>


<h3>Value</h3>

<p>As specified by the parameter <code>output</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data and hierarchies used in the examples
x &lt;- SSBtoolsData("sprt_emp")  # Employment in sport in thousand persons from Eurostat database
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

# Two hierarchies and year as rowFactor
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per")

# Same result with year as colFactor (but columns ordered differently)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per")

# Internally the computations are different as seen when output='matrixComponents'
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 output = "matrixComponents")
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")


# Include input age groups by setting inputInOutput = TRUE for this variable
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 inputInOutput = c(TRUE, FALSE))

# Only input age groups by switching to rowFactor
HierarchyCompute(x, list(age = "rowFactor", geo = geoHier, year = "colFactor"), "ths_per")

# Select some years (colFactor) including a year not in input data (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 colSelect = c("2014", "2016", "2018"))

# Select combinations of geo and age including a code not in data or hierarchy (zeros produced)
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
                 rowSelect = data.frame(geo = "EU", age = c("Y0-100", "Y15-64", "Y15-29")))
                 
# Select combinations of geo, age and year 
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per", 
     select = data.frame(geo = c("EU", "Spain"), age = c("Y15-64", "Y15-29"), year = 2015))

# Extend the hierarchy table to illustrate the effect of unionComplement 
# Omit level since this is handled by autoLevel
geoHier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), mapsTo = "EUandSpain", sign = 1), 
                  geoHier[, -4])

# Spain is counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per")

# Can be seen in the dataDummyHierarchy matrix
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 output = "matrixComponents")

# With unionComplement=TRUE Spain is not counted twice
HierarchyCompute(x, list(age = ageHier, geo = geoHier2, year = "colFactor"), "ths_per", 
                 unionComplement = TRUE)

# With constantsInOutput
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "colFactor"), "ths_per",
                 constantsInOutput = data.frame(c1 = "AB", c2 = "CD"))
                 
# More that one valueVar
x$y &lt;- 10*x$ths_per
HierarchyCompute(x, list(age = ageHier, geo = geoHier), c("y", "ths_per"))
</code></pre>

<hr>
<h2 id='HierarchyCompute2'>Extended Hierarchical Computations</h2><span id='topic+HierarchyCompute2'></span>

<h3>Description</h3>

<p>Extended variant of <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code> with several column variables (not just <code>"colFactor"</code>).
Parameter colVar splits the hierarchy variables in two groups and this variable overrides the difference between <code>"rowFactor"</code> and <code>"colFactor"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyCompute2(
  data,
  hierarchies,
  valueVar,
  colVar,
  rowSelect = NULL,
  colSelect = NULL,
  select = NULL,
  output = "data.frame",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchyCompute2_+3A_data">data</code></td>
<td>
<p>The input data frame</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_hierarchies">hierarchies</code></td>
<td>
<p>A named list with hierarchies</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_valuevar">valueVar</code></td>
<td>
<p>Name of the variable(s) to be aggregated</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_colvar">colVar</code></td>
<td>
<p>Name of the column variable(s)</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_rowselect">rowSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_colselect">colSelect</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_output">output</code></td>
<td>
<p>One of &quot;data.frame&quot; (default), &quot;outputMatrix&quot;, &quot;matrixComponents&quot;.</p>
</td></tr>
<tr><td><code id="HierarchyCompute2_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within this function, <code>HierarchyCompute</code> is called two times.
By specifying output as <code>"matrixComponents"</code>,
output from the two runs are retuned as a list with elements <code>hcRow</code> and <code>hcCol</code>.
The matrix multiplication in HierarchyCompute is extended to
<code>outputMatrix</code> <code>=</code> <code>hcRow$dataDummyHierarchy</code>
<code>%*%</code> <code>hcRow$valueMatrix</code>
<code>%*%</code> <code>t(hcCol$dataDummyHierarchy)</code>.
This is modified in cases with more than a single <code>valueVar</code>.
</p>


<h3>Value</h3>

<p>As specified by the parameter <code>output</code>
</p>


<h3>Note</h3>

<p>There is no need to call <code>HierarchyCompute2</code> directly.
The main function <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code>  can be used instead.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp")
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")

HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "year"))
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per",
                 colVar = c("age", "geo"))
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "year"), output = "matrixComponents")
HierarchyCompute(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), "ths_per", 
                 colVar = c("age", "geo"), output = "matrixComponents")

</code></pre>

<hr>
<h2 id='HierarchyComputeDummy'>HierarchyComputeDummy</h2><span id='topic+HierarchyComputeDummy'></span>

<h3>Description</h3>

<p>From hierarchies to a sparse model matrix with possible cross table by wrapping HierarchyCompute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyComputeDummy(
  data,
  hierarchies,
  inputInOutput = TRUE,
  crossTable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchyComputeDummy_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_hierarchies">hierarchies</code></td>
<td>
<p>hierarchies</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="HierarchyComputeDummy_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a special wrapper of <code><a href="#topic+HierarchyCompute">HierarchyCompute</a></code> and the input argument hierarchies is specified the same way.
That is, variables can also be coded by <code>"rowFactor"</code>  ( but not colFactor).
</p>


<h3>Value</h3>

<p>A sparse model matrix or a list of model matrix and cross table
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data and hierarchies used in the examples
x &lt;- SSBtoolsData("sprt_emp")  # Employment in sport in thousand persons from Eurostat database
geoHier &lt;- SSBtoolsData("sprt_emp_geoHier")
ageHier &lt;- SSBtoolsData("sprt_emp_ageHier")
HierarchyComputeDummy(x, list(age = ageHier, geo = geoHier, year = "rowFactor"), 
                      inputInOutput = FALSE, crossTable = TRUE)
</code></pre>

<hr>
<h2 id='HierarchyFix'>Change the hierarchy table to follow the standard</h2><span id='topic+HierarchyFix'></span>

<h3>Description</h3>

<p>Make sure that variable names and sign coding follow an internal standard. Level may be computed automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyFix(
  hierarchy,
  hierarchyVarNames = c(mapsFrom = "mapsFrom", mapsTo = "mapsTo", sign = "sign", level =
    "level"),
  autoLevel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchyFix_+3A_hierarchy">hierarchy</code></td>
<td>
<p>data frame with hierarchy table</p>
</td></tr>
<tr><td><code id="HierarchyFix_+3A_hierarchyvarnames">hierarchyVarNames</code></td>
<td>
<p>variable names</p>
</td></tr>
<tr><td><code id="HierarchyFix_+3A_autolevel">autoLevel</code></td>
<td>
<p>When TRUE, level is computed by automatic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with hierarchy table
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make input data by changing variable names and sign coding.
h &lt;- SSBtoolsData("FIFA2018ABCD")[, 1:3]
names(h)[1:2] &lt;- c("from", "to")
minus &lt;- h$sign &lt; 0
h$sign &lt;- "+"
h$sign[minus] &lt;- "-"

# Run HierarchyFix - Two levels created
HierarchyFix(h, c(mapsFrom = "from", mapsTo = "to", sign = "sign"))

# Extend the hierarchy table
h2 &lt;- rbind(data.frame(from = c("Oceania", "Asia", "Africa", "America", "Europe"),
                       to = "World", sign = "+"),
           data.frame(from = c("World", "Europe"),
                      to = "nonEurope", sign = c("+", "-")), h)

# Run HierarchyFix - Three levels created
HierarchyFix(h2, c(mapsFrom = "from", mapsTo = "to", sign = "sign"))

</code></pre>

<hr>
<h2 id='inc_default'>Default progress indicator function</h2><span id='topic+inc_default'></span>

<h3>Description</h3>

<p>Default progress indicator function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_default(i = 0L, n = 0L, steps = 25L, dot = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inc_default_+3A_i">i</code></td>
<td>
<p>i in &quot;i out of n&quot;</p>
</td></tr>
<tr><td><code id="inc_default_+3A_n">n</code></td>
<td>
<p>n in &quot;i out of n&quot;</p>
</td></tr>
<tr><td><code id="inc_default_+3A_steps">steps</code></td>
<td>
<p>Number of dots to print</p>
</td></tr>
<tr><td><code id="inc_default_+3A_dot">dot</code></td>
<td>
<p>dot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in 1:5) inc_default(i, 5)
cat("\n")
for (i in 1:100) inc_default(i, 100)
cat("\n")
for (i in 1:1000) inc_default(i, 1000)
cat("\n")
for (i in 1:1000) inc_default(i, 1000, steps = 10)
cat("\n")
for (i in 1:10) inc_default()
cat("\n")
</code></pre>

<hr>
<h2 id='LSfitNonNeg'>Non-negative regression fits with a sparse overparameterized model matrix</h2><span id='topic+LSfitNonNeg'></span>

<h3>Description</h3>

<p>Assuming  <code>z = t(x) %*% y  + noise</code>, a non-negatively modified least squares estimate of <code>t(x) %*% y</code> is made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSfitNonNeg(x, z, limit = 1e-10, viaQR = FALSE, printInc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LSfitNonNeg_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_z">z</code></td>
<td>
<p>A single column matrix</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_limit">limit</code></td>
<td>
<p>Lower limit for non-zero fits. Set to <code>NULL</code> or <code>-Inf</code> to avoid the non-zero restriction.</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_viaqr">viaQR</code></td>
<td>
<p>Least squares fits obtained using <code><a href="Matrix.html#topic+qr">qr</a></code> when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LSfitNonNeg_+3A_printinc">printInc</code></td>
<td>
<p>Printing &quot;...&quot; to console when <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The problem is first reduced by elimination some rows of <code>x</code>  (elements of <code>y</code>) using <code><a href="#topic+GaussIndependent">GaussIndependent</a></code>.
Thereafter least squares fits are obtained using <code><a href="Matrix.html#topic+solve">solve</a></code> or <code><a href="Matrix.html#topic+qr">qr</a></code>.
Possible negative fits will be forced to zero in the next estimation iteration(s).
</p>


<h3>Value</h3>

<p>A fitted version of <code>z</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data2 &lt;- SSBtoolsData("z2")
x &lt;- ModelMatrix(data2, formula = ~fylke + kostragr * hovedint - 1)
z &lt;- t(x) %*% data2$ant + rnorm(ncol(x), sd = 3)
LSfitNonNeg(x, z)
LSfitNonNeg(x, z, limit = NULL)

## Not run: 
mf &lt;- ~region*mnd + hovedint*mnd + fylke*hovedint*mnd + kostragr*hovedint*mnd
data4 &lt;- SSBtoolsData("sosialFiktiv")
x &lt;- ModelMatrix(data4, formula = mf)
z &lt;- t(x) %*% data4$ant + rnorm(ncol(x), sd = 3)
zFit &lt;- LSfitNonNeg(x, z)

## End(Not run)
</code></pre>

<hr>
<h2 id='MakeFreq'>Microdata frequency data conversion</h2><span id='topic+MakeFreq'></span><span id='topic+MakeMicro'></span>

<h3>Description</h3>

<p>Microdata frequency data conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeFreq(x, freqName = "freq", all = FALSE, hierarchies = FALSE)

MakeMicro(x, freqVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeFreq_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_freqname">freqName</code></td>
<td>
<p>Name of new frequency variable in output data</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_all">all</code></td>
<td>
<p>Whether to include level combinations not in microdata (zero frequency)</p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_hierarchies">hierarchies</code></td>
<td>
<p>Whether to treat hierarchical variables automatically when  <code>all=TRUE</code></p>
</td></tr>
<tr><td><code id="MakeFreq_+3A_freqvar">freqVar</code></td>
<td>
<p>The frequency variable in input data, name or number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp")[c(1, 2, 4, 7:12, 15, 17, 18), -4]
z$eu &lt;- z$geo != "Iceland"
z

MakeFreq(z)
MakeFreq(z[, -2])
MakeFreq(z[, -(2:3)])
MakeFreq(z[, -1])
MakeFreq(z[, -1], all = TRUE)

x &lt;- MakeFreq(z[, -1], all = TRUE, hierarchies = TRUE)
x

MakeMicro(x, "freq")
</code></pre>

<hr>
<h2 id='MakeHierFormula'>Make model formula from data taking into account hierarchical variables</h2><span id='topic+MakeHierFormula'></span>

<h3>Description</h3>

<p>Make model formula from data taking into account hierarchical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeHierFormula(
  data = NULL,
  hGroups = HierarchicalGroups2(data),
  n = length(hGroups),
  sim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeHierFormula_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_hgroups">hGroups</code></td>
<td>
<p>Output from HierarchicalGroups2()</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_n">n</code></td>
<td>
<p>Interaction level or 0 (all levels)</p>
</td></tr>
<tr><td><code id="MakeHierFormula_+3A_sim">sim</code></td>
<td>
<p>Include &quot;~&quot; when TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formula as character string
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SSBtoolsData("sprt_emp_withEU")[, -4]
MakeHierFormula(x)
MakeHierFormula(x, n = 2)
MakeHierFormula(x, n = 0)
</code></pre>

<hr>
<h2 id='Match'>Matching rows in data frames</h2><span id='topic+Match'></span>

<h3>Description</h3>

<p>The algorithm is based on converting variable combinations to whole numbers.
The final matching is performed using <code><a href="base.html#topic+match">match</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Match(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Match_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Match_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the result of multiplying together the number of unique values in each column of x exceeds 9E15
(largest value stored exactly by the numeric data type), the algorithm is recursive.
</p>


<h3>Value</h3>

<p>An integer vector giving the position in y of the first match if there is a match, otherwise NA.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- data.frame(x = c("a", "b", "c"), y = c("A", "B"), z = 1:6)
b &lt;- data.frame(x = c("b", "c"), y = c("B", "K", "A", "B"), z = c(2, 3, 5, 6))

Match(a, b)
Match(b, a)

# Slower alternative
match(data.frame(t(a), stringsAsFactors = FALSE), data.frame(t(b), stringsAsFactors = FALSE))
match(data.frame(t(b), stringsAsFactors = FALSE), data.frame(t(a), stringsAsFactors = FALSE))

# More comprehensive example (n, m and k may be changed)
n &lt;- 10^4
m &lt;- 10^3
k &lt;- 10^2
data(precip)
data(mtcars)
y &lt;- data.frame(car = sample(rownames(mtcars), n, replace = TRUE), 
                city = sample(names(precip), n, replace = TRUE),
                n = rep_len(1:k, n), a = rep_len(c("A", "B", "C", "D"), n),
                b = rep_len(as.character(rnorm(1000)), n),
                d = sample.int(k + 10, n, replace = TRUE),
                e = paste(sample.int(k * 2, n, replace = TRUE), 
                          rep_len(c("Green", "Red", "Blue"), n), sep = "_"),
                r = rnorm(k)^99)
x &lt;- y[sample.int(n, m), ]
row.names(x) &lt;- NULL
ix &lt;- Match(x, y)
</code></pre>

<hr>
<h2 id='matlabColon'>Simulate Matlab's ':'</h2><span id='topic+matlabColon'></span><span id='topic+SeqInc'></span>

<h3>Description</h3>

<p>Functions to generate increasing sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlabColon(from, to)

SeqInc(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matlabColon_+3A_from">from</code></td>
<td>
<p>numeric. The start value</p>
</td></tr>
<tr><td><code id="matlabColon_+3A_to">to</code></td>
<td>
<p>numeric. The end value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>matlabColon(a,b) returns a:b (R's version) unless a &gt; b, in which case it returns integer(0).
SeqInc(a,b) is similar, but results in error when the calculated length of the sequence (1+to-from) is negative.
</p>


<h3>Value</h3>

<p>A numeric vector, possibly empty.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik (matlabColon) and Øyvind Langsrud (SeqInc)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identical(3:5, matlabColon(3, 5)) ## =&gt; TRUE
3:1 ## =&gt; 3 2 1
matlabColon(3, 1) ## =&gt; integer(0)
try(SeqInc(3, 1)) ## =&gt; Error
SeqInc(3, 2)      ## =&gt; integer(0)
</code></pre>

<hr>
<h2 id='Matrix2list'>Convert matrix to sparse list</h2><span id='topic+Matrix2list'></span><span id='topic+Matrix2listInt'></span>

<h3>Description</h3>

<p>Convert matrix to sparse list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix2list(x)

Matrix2listInt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix2list_+3A_x">x</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the function, the input matrix is first converted to a dgTMatrix matrix (Matrix package).
</p>


<h3>Value</h3>

<p>A two-element list: List of row numbers (r) and a list of numeric or integer values (x)
</p>


<h3>Note</h3>

<p><code>Matrix2listInt</code> convers the values to integers by <code>as.integer</code>
and no checking is performed. Thus, zeros are possible.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix(c(0.5, 1.1, 3.14, 0, 0, 0, 0, 4, 5), 3, 3)
Matrix2list(m)
Matrix2listInt(m)
</code></pre>

<hr>
<h2 id='MatrixPaste'>Combining columns of a matrix</h2><span id='topic+MatrixPaste'></span><span id='topic+MatrixPaste1'></span>

<h3>Description</h3>

<p>Combining columns of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixPaste(x, sep = "_", forceCharacter = FALSE, stringEmpty = " ")

MatrixPaste1(x, stringEmpty = "1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixPaste_+3A_x">x</code></td>
<td>
<p>Matrix or vector</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_sep">sep</code></td>
<td>
<p>String used to combine columns</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_forcecharacter">forceCharacter</code></td>
<td>
<p>When FALSE single column input will keep to original class in output.</p>
</td></tr>
<tr><td><code id="MatrixPaste_+3A_stringempty">stringEmpty</code></td>
<td>
<p>String used when input is empty (can be set to NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in input will be combined to a single string using sep.
</p>


<h3>Value</h3>

<p>Character vector or possibly same vector as input
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MatrixPaste(matrix(1:12,3,4))
MatrixPaste(1:5)
MatrixPaste(1:5, forceCharacter=TRUE)
MatrixPaste(matrix(integer(0),3,0))
MatrixPaste(NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='MatrixToDataFrame'>MatrixToDataFrame</h2><span id='topic+MatrixToDataFrame'></span>

<h3>Description</h3>

<p>MatrixToDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixToDataFrame(x, forceStringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixToDataFrame_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="MatrixToDataFrame_+3A_forcestringsasfactors">forceStringsAsFactors</code></td>
<td>
<p>forceStringsAsFactors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='Mipf'>Iterative proportional fitting from matrix input</h2><span id='topic+Mipf'></span>

<h3>Description</h3>

<p>The linear equation, <code>z = t(x) %*% y</code>, is (hopefully)  solved for <code>y</code> by
iterative proportional fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mipf(
  x,
  z = NULL,
  iter = 100,
  yStart = matrix(1, nrow(x), 1),
  eps = 0.01,
  tol = 1e-10,
  reduceBy0 = FALSE,
  reduceByColSums = FALSE,
  reduceByLeverage = FALSE,
  returnDetails = FALSE,
  y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mipf_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="Mipf_+3A_z">z</code></td>
<td>
<p>a single column matrix</p>
</td></tr>
<tr><td><code id="Mipf_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="Mipf_+3A_ystart">yStart</code></td>
<td>
<p>a starting estimate of <code>y</code></p>
</td></tr>
<tr><td><code id="Mipf_+3A_eps">eps</code></td>
<td>
<p>stopping criterion. Maximum allowed value of <code>max(abs(z - t(x) %*% yHat))</code></p>
</td></tr>
<tr><td><code id="Mipf_+3A_tol">tol</code></td>
<td>
<p>Another stopping criterion. Maximum absolute difference between two iterations.</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reduceby0">reduceBy0</code></td>
<td>
<p>When TRUE, <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> used within the function</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reducebycolsums">reduceByColSums</code></td>
<td>
<p>Parameter to <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> (when TRUE)</p>
</td></tr>
<tr><td><code id="Mipf_+3A_reducebyleverage">reduceByLeverage</code></td>
<td>
<p>Parameter to <code><a href="#topic+Reduce0exact">Reduce0exact</a></code> (when TRUE)</p>
</td></tr>
<tr><td><code id="Mipf_+3A_returndetails">returnDetails</code></td>
<td>
<p>More output when TRUE.</p>
</td></tr>
<tr><td><code id="Mipf_+3A_y">y</code></td>
<td>
<p>It is possible to set <code>z</code> to NULL and supply original <code>y</code> instead  (<code>z = t(x) %*% y</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm will work similar to <code><a href="stats.html#topic+loglin">loglin</a></code> when the input x-matrix is a overparameterized model matrix
– as can be created by <code><a href="#topic+ModelMatrix">ModelMatrix</a></code> and <code><a href="#topic+FormulaSums">FormulaSums</a></code>. See Examples.
</p>


<h3>Value</h3>

<p><code>yHat</code>, the estimate of <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data2 &lt;- SSBtoolsData("z2")
x &lt;- ModelMatrix(data2, formula = ~fylke + kostragr * hovedint - 1)
z &lt;- t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z)

#############################
# loglm comparison  
#############################

if (require(MASS)){

# Increase accuracy
yHat &lt;- Mipf(x, z, eps = 1e-04)

# Run loglm and store fitted values in a data frame
outLoglm &lt;- loglm(ant ~ fylke + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Problem 1: Variable region not in output, but instead the variable .Within.  
# Problem 2: Extra zeros since hierarchy not treated. Impossible combinations in output.

# By sorting data, it becomes clear that the fitted values are the same.
max(abs(sort(dfLoglm$Freq, decreasing = TRUE)[1:nrow(data2)] - sort(yHat, decreasing = TRUE)))

# Modify so that region is in output. Problem 1 avoided.
x &lt;- ModelMatrix(data2, formula = ~region + kostragr * hovedint - 1)
z &lt;- t(x) %*% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat &lt;- Mipf(x, z, eps = 1e-04)
outLoglm &lt;- loglm(ant ~ region + kostragr * hovedint, data2, eps = 1e-04, iter = 100)
dfLoglm &lt;- as.data.frame.table(fitted(outLoglm))

# Now it is possible to merge data
merg &lt;- merge(cbind(data2, yHat), dfLoglm)

# Identical output
max(abs(merg$yHat - merg$Freq))

}

## End(Not run)

#############################
# loglin comparison  
#############################


# Generate input data for loglin
n &lt;- 5:9
tab &lt;- array(sample(1:prod(n)), n)

# Input parameters
iter &lt;- 20
eps &lt;- 1e-05

# Estimate yHat by loglin
out &lt;- loglin(tab, list(c(1, 2), c(1, 3), c(1, 4), c(1, 5), c(2, 3, 4), c(3, 4, 5)), 
              fit = TRUE, iter = iter, eps = eps)
yHatLoglin &lt;- matrix(((out$fit)), ncol = 1)

# Transform the data for input to Mipf
df &lt;- as.data.frame.table(tab)
names(df)[1:5] &lt;- c("A", "B", "C", "D", "E")
x &lt;- ModelMatrix(df, formula = ~A:B + A:C + A:D + A:E + B:C:D + C:D:E - 1)
z &lt;- t(x) %*% df$Freq

# Estimate yHat by Mipf
yHatPMipf &lt;- Mipf(x, z, iter = iter, eps = eps)

# Maximal absolute difference
max(abs(yHatPMipf - yHatLoglin))

# Note: loglin reports one iteration extra 

# Another example. Only one iteration needed.
max(abs(Mipf(x = FormulaSums(df, ~A:B + C - 1), 
             z = FormulaSums(df, Freq ~ A:B + C -1)) 
             - matrix(loglin(tab, list(1:2, 3), fit = TRUE)$fit, ncol = 1)))


#########################################
# Examples utilizing Reduce0exact 
#########################################

z3 &lt;- SSBtoolsData("z3")
x &lt;- ModelMatrix(z3, formula = ~region + kostragr * hovedint + region * mnd2 + fylke * mnd + 
                     mnd * hovedint + mnd2 * fylke * hovedint - 1)

# reduceBy0, but no iteration improvement. Identical results.
t &lt;- 360
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 0.1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 0.1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 0.1)
max(abs(a1 - a2))
max(abs(a1 - a3))


## Not run: 
# Improvement by reduceByColSums. Changing eps and iter give more similar results.
t &lt;- 402
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))


# Improvement by ReduceByLeverage. Changing eps and iter give more similar results.
t &lt;- 378
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1)
a4 &lt;- Mipf(x, z, reduceByLeverage = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))
max(abs(a1 - a4))


# Example with small eps and "Iteration stopped since tol reached"
t &lt;- 384
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z, eps = 1e-14)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE, eps = 1e-14)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE, eps = 1e-14)
max(abs(a1 - a2))
max(abs(a1 - a3))

## End(Not run)

# All y-data found by reduceByColSums (0 iterations). 
t &lt;- 411
y &lt;- z3$ant
y[round((1:t) * 432/t)] &lt;- 0
z &lt;- t(x) %*% y
a1 &lt;- Mipf(x, z)
a2 &lt;- Mipf(x, z, reduceBy0 = TRUE)
a3 &lt;- Mipf(x, z, reduceByColSums = TRUE)
max(abs(a1 - y))
max(abs(a2 - y))
max(abs(a3 - y))
</code></pre>

<hr>
<h2 id='model_aggregate'>Hierarchical aggregation via model specification</h2><span id='topic+model_aggregate'></span>

<h3>Description</h3>

<p>Internally a dummy/model matrix is created according to the model specification.
This model matrix is used in the aggregation process via matrix multiplication and/or the function <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_aggregate(
  data,
  sum_vars = NULL,
  fun_vars = NULL,
  fun = NULL,
  hierarchies = NULL,
  formula = NULL,
  dim_var = NULL,
  preagg_var = NULL,
  dummy = TRUE,
  pre_aggregate = dummy,
  list_return = FALSE,
  pre_return = FALSE,
  verbose = TRUE,
  mm_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_aggregate_+3A_data">data</code></td>
<td>
<p>A data frame containing data to be aggregated</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_sum_vars">sum_vars</code></td>
<td>
<p>Variables to be summed. This will be done via matrix multiplication.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_fun_vars">fun_vars</code></td>
<td>
<p>Variables to be aggregated by supplied functions.
This will be done via <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code> and <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code> and
<code>fun_vars</code> is specified as the parameter <code>vars</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_fun">fun</code></td>
<td>
<p>The <code>fun</code>         parameter to <code><a href="#topic+aggregate_multiple_fun">aggregate_multiple_fun</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_hierarchies">hierarchies</code></td>
<td>
<p>The <code>hierarchies</code> parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_formula">formula</code></td>
<td>
<p>The <code>formula</code>     parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_dim_var">dim_var</code></td>
<td>
<p>The <code>dimVar</code>      parameter to <code><a href="#topic+ModelMatrix">ModelMatrix</a></code></p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_preagg_var">preagg_var</code></td>
<td>
<p>Extra variables to be used as grouping elements in the pre-aggregate step</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_dummy">dummy</code></td>
<td>
<p>The <code>dummy</code>       parameter to <code><a href="#topic+dummy_aggregate">dummy_aggregate</a></code>.
When <code>TRUE</code>, only 0s and 1s are assumed in the generated model matrix.
When <code>FALSE</code>, non-0s in this matrix are passed as an additional first input parameter to the <code>fun</code> functions.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_pre_aggregate">pre_aggregate</code></td>
<td>
<p>Whether to pre-aggregate data to reduce the dimension of the model matrix.
Note that all original <code>fun_vars</code> observations are retained in the aggregated dataset and <code>pre_aggregate</code> does not affect the final result.
However, <code>pre_aggregate</code> must be set to <code>FALSE</code> when the <code>dummy_aggregate</code> parameter <code>dummy</code> is set to <code>FALSE</code>
since then <code><a href="base.html#topic+unlist">unlist</a></code> will not be run.
An exception to this is if the <code>fun</code> functions are written to handle list data.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_list_return">list_return</code></td>
<td>
<p>Whether to return a list of separate components including the model matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_pre_return">pre_return</code></td>
<td>
<p>Whether to return the pre-aggregate data as a two-component list. Can also be combined with <code>list_return</code> (see examples).</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information during calculations.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_mm_args">mm_args</code></td>
<td>
<p>List of further arguments passed to <code>ModelMatrix</code>.</p>
</td></tr>
<tr><td><code id="model_aggregate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>dummy_aggregate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With formula input, limited output can be achieved by <code><a href="#topic+formula_selection">formula_selection</a></code> (see example).
An attribute called <code>startCol</code> has been added to the output data frame to make this functionality work.
</p>


<h3>Value</h3>

<p>A data frame or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"
names(z)[names(z) == "ths_per"] &lt;- "ths"
z$y &lt;- 1:18

my_range &lt;- function(x) c(min = min(x), max = max(x))

out &lt;- model_aggregate(z, 
   formula = ~age:year + geo, 
   sum_vars = c("y", "ths"), 
   fun_vars = c(sum = "ths", mean = "y", med = "y", ra = "ths"), 
   fun = c(sum = sum, mean = mean, med = median, ra = my_range))

out

# Limited output can be achieved by formula_selection
formula_selection(out, ~geo)


# Using the single unnamed variable feature.
model_aggregate(z, formula = ~age, fun_vars = "y", 
                fun = c(sum = sum, mean = mean, med = median, n = length))


# To illustrate list_return and pre_return 
for (pre_return in c(FALSE, TRUE)) for (list_return in c(FALSE, TRUE)) {
  cat("\n=======================================\n")
  cat("list_return =", list_return, ", pre_return =", pre_return, "\n\n")
  out &lt;- model_aggregate(z, formula = ~age:year, 
                         sum_vars = c("ths", "y"), 
                         fun_vars = c(mean = "y", ra = "y"), 
                         fun = c(mean = mean, ra = my_range), 
                         list_return = list_return,
                         pre_return = pre_return)
  cat("\n")
  print(out)
}


# To illustrate preagg_var 
model_aggregate(z, formula = ~age:year, 
sum_vars = c("ths", "y"), 
fun_vars = c(mean = "y", ra = "y"), 
fun = c(mean = mean, ra = my_range), 
preagg_var = "eu",
pre_return = TRUE)[["pre_data"]]


# To illustrate hierarchies 
geo_hier &lt;- SSBtoolsData("sprt_emp_geoHier")
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"))

####  Special non-dummy cases illustrated below  ####

# Extend the hierarchy to make non-dummy model matrix  
geo_hier2 &lt;- rbind(data.frame(mapsFrom = c("EU", "Spain"), 
                              mapsTo = "EUandSpain", sign = 1), geo_hier[, -4])

# Warning since non-dummy
# y and y_sum are different 
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"))

# No warning since dummy since unionComplement = TRUE (see ?HierarchyCompute)
# y and y_sum are equal   
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum = "y"),
                mm_args = list(unionComplement = TRUE))

# Non-dummy again, but no warning since dummy = FALSE
# Then pre_aggregate is by default set to FALSE (error when TRUE) 
# fun with extra argument needed (see ?dummy_aggregate)
# y and y_sum2 are equal
model_aggregate(z, hierarchies = list(age = "All", geo = geo_hier2), 
                sum_vars = "y", 
                fun_vars = c(sum2 = "y"),
                fun = c(sum2 = function(x, y) sum(x * y)),
                dummy = FALSE) 
                
</code></pre>

<hr>
<h2 id='Model_Matrix'>Overparameterized model matrix</h2><span id='topic+Model_Matrix'></span>

<h3>Description</h3>

<p>All factor levels included
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model_Matrix(
  formula,
  data = NULL,
  mf = model.frame(formula, data = data),
  allFactor = TRUE,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model_Matrix_+3A_formula">formula</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_mf">mf</code></td>
<td>
<p>model frame (alternative input instead of data)</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_allfactor">allFactor</code></td>
<td>
<p>When TRUE all variables are coerced to factor</p>
</td></tr>
<tr><td><code id="Model_Matrix_+3A_sparse">sparse</code></td>
<td>
<p>When TRUE sparse matrix created by sparse.model.matrix()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example:
</p>
<p><code>z &lt;- SSBtoolsData("sp_emp_withEU")</code>
</p>
<p><code>SSBtools:::Model_Matrix(~age*year + geo, z)</code>
</p>


<h3>Value</h3>

<p>model matrix created via model.matrix() or sparse.model.matrix()
</p>

<hr>
<h2 id='ModelMatrix'>Model matrix from hierarchies and/or a formula</h2><span id='topic+ModelMatrix'></span><span id='topic+NamesFromModelMatrixInput'></span>

<h3>Description</h3>

<p>A common interface to <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> and <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelMatrix(
  data,
  hierarchies = NULL,
  formula = NULL,
  inputInOutput = TRUE,
  crossTable = FALSE,
  sparse = TRUE,
  viaOrdinary = FALSE,
  total = "Total",
  removeEmpty = !is.null(formula) &amp; is.null(hierarchies),
  modelMatrix = NULL,
  dimVar = NULL,
  select = NULL,
  ...
)

NamesFromModelMatrixInput(
  data = NULL,
  hierarchies = NULL,
  formula = NULL,
  dimVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ModelMatrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with data containing codes of relevant variables</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_crosstable">crossTable</code></td>
<td>
<p>Cross table in output when TRUE</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Sparse matrix in output when TRUE (default)</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_viaordinary">viaOrdinary</code></td>
<td>
<p>When TRUE, output is generated by <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> or <code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code>.
Since these functions omit a factor level, an empty factor level is first added.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_total">total</code></td>
<td>
<p>String(s) used to name totals</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When <code>TRUE</code>, empty columns (only zeros) are not included in output.
Default is <code>TRUE</code> with formula input without hierarchy and otherwise <code>FALSE</code> (see details).</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_modelmatrix">modelMatrix</code></td>
<td>
<p>The model matrix as input (same as output)</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_select">select</code></td>
<td>
<p>Data frame specifying variable combinations for output
or a named list specifying code selections for each variable (see details).</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_...">...</code></td>
<td>
<p>Further arguments to  <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code>, <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> or <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>removeEmpty</code> corresponds to the default settings of the underlying functions.
The functions <code><a href="#topic+Hierarchies2ModelMatrix">Hierarchies2ModelMatrix</a></code> and <code><a href="#topic+HierarchiesAndFormula2ModelMatrix">HierarchiesAndFormula2ModelMatrix</a></code>
have <code>removeEmpty</code> as an explicit parameter with <code>FALSE</code> as default.
The function <code><a href="#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code> is a wrapper for <code><a href="#topic+FormulaSums">FormulaSums</a></code>,
which has a parameter <code>includeEmpty</code> with <code>FALSE</code> as default.
Thus, <code>ModelMatrix</code> makes a call to <code>Formula2ModelMatrix</code> with <code>includeEmpty = !removeEmpty</code>.
</p>
<p><code>NamesFromModelMatrixInput</code> returns the names of the data columns involved in creating the model matrix.
Note that <code>data</code> must be non-NULL to convert dimVar as indices to names.
</p>
<p>The <code>select</code> parameter is forwarded to <code>Hierarchies2ModelMatrix</code> unless <code>removeEmpty = TRUE</code> is combined with <code>select</code> as a data frame.
In all other cases, <code>select</code> is handled outside the underlying functions by making selections in the result.
Empty columns can be added to the model matrix when <code>removeEmpty = FALSE</code> (with warning).
</p>


<h3>Value</h3>

<p>A (sparse) model matrix or a list of two elements (model matrix and cross table)
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some input
z &lt;- SSBtoolsData("sp_emp_withEU")
ageHier &lt;- data.frame(mapsFrom = c("young", "old"), mapsTo = "Total", sign = 1)
geoDimList &lt;- FindDimLists(z[, c("geo", "eu")], total = "Europe")[[1]]

# Small dataset example. Two dimensions.
s &lt;- z[z$geo == "Spain" &amp; z$year != 2016, ]
rownames(s) &lt;- NULL
s

# via Hierarchies2ModelMatrix() and converted to ordinary matrix (not sparse)
ModelMatrix(s, list(age = ageHier, year = ""), sparse = FALSE)

# Hierarchies generated automatically. Then via Hierarchies2ModelMatrix()
ModelMatrix(s[, c(1, 4)])

# via Formula2ModelMatrix()
ModelMatrix(s, formula = ~age + year)

# via model.matrix() after adding empty factor levels
ModelMatrix(s, formula = ~age + year, sparse = FALSE, viaOrdinary = TRUE)

# via sparse.model.matrix() after adding empty factor levels
ModelMatrix(s, formula = ~age + year, viaOrdinary = TRUE)

# via HierarchiesAndFormula2ModelMatrix() and using different data and parameter settings
ModelMatrix(s, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * geo + year, 
            inputInOutput = FALSE, removeEmpty = TRUE, crossTable = TRUE)
ModelMatrix(s, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * geo + year, 
            inputInOutput = c(TRUE, FALSE), removeEmpty = FALSE, crossTable = TRUE)
ModelMatrix(z, list(age = ageHier, geo = geoDimList, year = ""), formula = ~age * year + geo, 
            inputInOutput = c(FALSE, TRUE), crossTable = TRUE)
            
# via Hierarchies2ModelMatrix() using unnamed list element. See AutoHierarchies.             
colnames(ModelMatrix(z, list(age = ageHier, c(Europe = "geo", Allyears = "year", "eu"))))
colnames(ModelMatrix(z, list(age = ageHier, c("geo", "year", "eu")), total = c("t1", "t2")))

# Example using the select parameter as a data frame
select &lt;- data.frame(age = c("Total", "young", "old"), geo = c("EU", "nonEU", "Spain"))
ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
            select = select, crossTable = TRUE)$crossTable
            
# Examples using the select parameter as a list
ModelMatrix(z, list(age = ageHier, geo = geoDimList), inputInOutput = FALSE, 
            select = list(geo = c("nonEU", "Portugal")), crossTable = TRUE)$crossTable
ModelMatrix(z, list(age = ageHier, geo = geoDimList), 
            select = list(geo = c("nonEU", "Portugal"), age = c("Total", "young")), 
            crossTable = TRUE)$crossTable

</code></pre>

<hr>
<h2 id='Number'>Adding leading zeros</h2><span id='topic+Number'></span>

<h3>Description</h3>

<p>Adding leading zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Number(n, width = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Number_+3A_n">n</code></td>
<td>
<p>numeric vector of whole numbers</p>
</td></tr>
<tr><td><code id="Number_+3A_width">width</code></td>
<td>
<p>width</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Number(1:3)
</code></pre>

<hr>
<h2 id='NumSingleton'>Decoding of <code>singletonMethod</code></h2><span id='topic+NumSingleton'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> <code>singletonMethod</code> starting with <code>"num"</code> is decoded into separate characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumSingleton(singletonMethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NumSingleton_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p>String to be decoded. If necessary, the input string is extended with <code>F</code>'s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>F</code> means the feature is turned off.
Other characters have the following meaning:
</p>

<ol>
<li> <p><code>singleton2Primary</code> (1st character):
</p>

<ul>
<li> <p><code>T</code>: All singletons are forced to be primary suppressed.
</p>
</li>
<li> <p><code>t</code>: Non-published singletons are primary suppressed.
</p>
</li></ul>

</li>
<li> <p><code>integerUnique</code> (2nd character):
</p>

<ul>
<li> <p><code>T</code>: Integer values representing the unique contributors are utilized.  Error if <code>singleton</code> not supplied as integer.
</p>
</li>
<li> <p><code>t</code>: As <code>T</code> above, but instead of error, the feature is turned off  (as <code>F</code>) if <code>singleton</code> is not supplied as integer.
</p>
</li></ul>

</li>
<li> <p><code>sum2</code> (3rd character):
</p>

<ul>
<li> <p><code>T</code>: Imaginary primary suppressed cells are made,
which are the sum of some suppressed inner cells and which can be divided into two components.
At least one component is singleton contributor. The other component may be an inner cell.
</p>
</li>
<li> <p><code>H</code>: As <code>T</code> above. And in addition, the other component can be any primary suppressed published cell.
This method may be computationally demanding for big data.
</p>
</li></ul>

</li>
<li> <p><code>elimination</code> (4th character):
</p>

<ul>
<li> <p><code>t</code>: The singleton problem will be handled by methodology implemented as a part of the Gaussian elimination algorithm.
</p>
</li>
<li> <p><code>m</code>: As <code>t</code> above. And in addition, a message will be printed to inform about problematic singletons.
Actual reveals will be calculated when <code>singleton2Primary = T</code> (1st character)
and when <code>singleton2Primary = t</code> yield the same result as <code>singleton2Primary = T</code>.
Problematic singletons can appear since the algorithm is not perfect in the sense that the elimination of rows may cause problems.
Such problems can be a reason not to switch off <code>sum2</code>.
</p>
</li>
<li> <p><code>w</code>: As <code>m</code> above, but <code>warning</code> instead of <code>message</code>.
</p>
</li>
<li> <p><code>T</code>, <code>M</code> and <code>W</code>: As <code>t</code>, <code>m</code> and <code>w</code> above.
In addition, the gauss elimination routine is allowed to run in parallel with different sortings
so that the problem of eliminated singleton rows is reduced.
</p>
</li>
<li> <p><code>f</code>: As <code>F</code>, which means that the elimination feature is turned off.
However, when possible, a message will provide information about actual reveals, similar to <code>m</code> above.
</p>
</li></ul>

</li>
<li> <p><code>combinations</code> (5th character):
</p>

<ul>
<li> <p><code>T</code>: This is a sort of extension of <code>singleton2Primary</code> which is relevant when both <code>integerUnique</code> and <code>elimination</code> are used.
For each unique singleton contributor, the method seeks to protect all linear combinations of singleton cells from the unique contributor.
Instead of construction new primary cells, protection is achieved as a part of the elimination procedure.
Technically this is implemented by extending the above <code>elimination</code> method.
It cannot be guaranteed that all problems are solved, and this is a reason not to turn off <code>singleton2Primary</code>.
Best performance is achieved when <code>elimination</code> is <code>T</code>, <code>M</code> or <code>W</code>.
</p>
</li>
<li> <p><code>t</code>:  As <code>T</code>, but without the added singleton protection.
This means that protected linear combinations cannot be calculated linearly from non-suppressed cells.
However, other contributors may still be able to recalculate these combinations using their own suppressed values.
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>A character vector or <code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NumSingleton("numTFF")
NumSingleton("numFtT")
NumSingleton("numttH")
NumSingleton("numTTFTT")
</code></pre>

<hr>
<h2 id='quantile_weighted'>Weighted quantiles</h2><span id='topic+quantile_weighted'></span>

<h3>Description</h3>

<p>The default method (<code>type=2</code>) corresponds to weighted percentiles in SAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_weighted(
  x,
  probs = (0:4)/4,
  weights = rep(1, length(x)),
  type = 2,
  eps = 1e-09
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_weighted_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_type">type</code></td>
<td>
<p>An integer, <code>2</code> (default) or <code>5</code>. Similar to types 2 and 5 in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="quantile_weighted_+3A_eps">eps</code></td>
<td>
<p>Precision parameter used when <code>type=2</code> so that numerical inaccuracy is accepted (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type=2</code>, averaging is used in case of equal of probabilities.
Equal probabilities (<code>p[j]==probs[i]</code>) is determined by
<code>abs(1-p[j]/probs[i])&lt;eps</code>
with <code>p=cumsum(w)/sum(w)</code>
where <code>w=weights[order(x)]</code>.
</p>
<p>With zero length of <code>x</code>, <code>NA</code>s are returned.
</p>
<p>When all weights are zero and when when all <code>x</code>'s are not equal,
<code>NaN</code>s are returned except for the 0% and 100% quantiles.
</p>


<h3>Value</h3>

<p>Quantiles as a named numeric vector.
</p>


<h3>Note</h3>

<p>Type 2 similar to type 5 in <code>DescTools::Quantile</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(27)/5 + 1:27
w &lt;- (1:27)/27

quantile_weighted(x, (0:5)/5, weights = w)
quantile_weighted(x, (0:5)/5, weights = w, type = 5)

quantile_weighted(x) - quantile(x, type = 2)
quantile_weighted(x, type = 5) - quantile(x, type = 5)

</code></pre>

<hr>
<h2 id='RbindAll'>Combining several data frames when the columns don't match</h2><span id='topic+RbindAll'></span>

<h3>Description</h3>

<p>Combining several data frames when the columns don't match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RbindAll(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RbindAll_+3A_...">...</code></td>
<td>
<p>Several data frames as several input parameters or a list of data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single data frame
</p>


<h3>Note</h3>

<p>The function is an extended version of rbind.all.columns at
<a href="https://amywhiteheadresearch.wordpress.com/2013/05/13/combining-dataframes-when-the-columns-dont-match/">https://amywhiteheadresearch.wordpress.com/2013/05/13/combining-dataframes-when-the-columns-dont-match/</a>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CbindIdMatch">CbindIdMatch</a></code> (same example data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zA &lt;- data.frame(idA = 1:10, idB = rep(10 * (1:5), 2), idC = rep(c(100, 200), 5), 
                 idC2 = c(100, rep(200, 9)), idC3 = rep(100, 10), 
                 idD = 99, x = round(rnorm(10), 3), xA = round(runif(10), 2))
zB &lt;- data.frame(idB = 10 * (1:5), x = round(rnorm(5), 3), xB = round(runif(5), 2))
zC &lt;- data.frame(idC = c(100, 200), x = round(rnorm(2), 3), xC = round(runif(2), 2))
zD &lt;- data.frame(idD = 99, x = round(rnorm(1), 3), xD = round(runif(1), 2))
RbindAll(zA, zB, zC, zD)
RbindAll(list(zA, zB, zC, zD))
</code></pre>

<hr>
<h2 id='Reduce0exact'>Reducing a non-negative regression problem</h2><span id='topic+Reduce0exact'></span>

<h3>Description</h3>

<p>The linear equation problem, <code>z = t(x) %*% y</code> with y non-negative and x as a design (dummy) matrix,
is reduced to a smaller problem by identifying elements of <code>y</code> that can be found exactly from <code>x</code> and <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reduce0exact(
  x,
  z = NULL,
  reduceByColSums = FALSE,
  reduceByLeverage = FALSE,
  leverageLimit = 0.999999,
  digitsRoundWhole = 9,
  y = NULL,
  yStart = NULL,
  printInc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reduce0exact_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_z">z</code></td>
<td>
<p>A single column matrix</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_reducebycolsums">reduceByColSums</code></td>
<td>
<p>See Details</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_reducebyleverage">reduceByLeverage</code></td>
<td>
<p>See Details</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_leveragelimit">leverageLimit</code></td>
<td>
<p>Limit to determine perfect fit</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_digitsroundwhole">digitsRoundWhole</code></td>
<td>
<p><code><a href="#topic+RoundWhole">RoundWhole</a></code> parameter for fitted values (when <code>leverageLimit</code> and <code>y</code> not in input)</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_y">y</code></td>
<td>
<p>A single column matrix. With <code>y</code> in input, <code>z</code> in input can be omitted and estimating <code>y</code> (when <code>leverageLimit</code>) is avoided.</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_ystart">yStart</code></td>
<td>
<p>A starting estimate when this function is combined with iterative proportional fitting. Zeros in yStart will be used to reduce the problem.</p>
</td></tr>
<tr><td><code id="Reduce0exact_+3A_printinc">printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact elements can be identified in three ways in an iterative manner:
</p>

<ol>
<li><p> By zeros in <code>z</code>. This is always done.
</p>
</li>
<li><p> By columns in x with a singe nonzero value. Done when <code>reduceByColSums</code> or <code>reduceByLeverage</code> is <code>TRUE</code>.
</p>
</li>
<li><p> By exact linear regression fit (when leverage is one). Done when <code>reduceByLeverage</code> is <code>TRUE</code>.
The leverages are computed by <code>hat(as.matrix(x), intercept = FALSE)</code>, which can be very time and memory consuming.
Furthermore, without <code>y</code> in input, known values will be computed by <code><a href="MASS.html#topic+ginv">ginv</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A list of five elements:
</p>

<ul>
<li> <p><code>x</code>: A reduced version of input <code>x</code>
</p>
</li>
<li> <p><code>z</code>: Corresponding reduced <code>z</code>
</p>
</li>
<li> <p><code>yKnown</code>: Logical, specifying known values of <code>y</code>
</p>
</li>
<li> <p><code>y</code>: A version of <code>y</code> with known values correct and others zero
</p>
</li>
<li> <p><code>zSkipped</code>: Logical, specifying omitted columns of <code>x</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a special data set
d &lt;- SSBtoolsData("sprt_emp")
d$ths_per &lt;- round(d$ths_per)
d &lt;- rbind(d, d)
d$year &lt;- as.character(rep(2014:2019, each = 6))
to0 &lt;- rep(TRUE, 36)
to0[c(6, 14, 17, 18, 25, 27, 30, 34, 36)] &lt;- FALSE
d$ths_per[to0] &lt;- 0

# Values as a single column matrix
y &lt;- Matrix(d$ths_per, ncol = 1)

# A model matrix using a special year hierarchy
x &lt;- Hierarchies2ModelMatrix(d, hierarchies = list(geo = "", age = "", year = 
    c("y1418 = 2014+2015+2016+2017+2018", "y1519 = 2015+2016+2017+2018+2019", 
      "y151719 = 2015+2017+2019", "yTotal = 2014+2015+2016+2017+2018+2019")), 
      inputInOutput = FALSE)

# Aggregates 
z &lt;- t(x) %*% y
sum(z == 0)  # 5 zeros

# From zeros in z
a &lt;- Reduce0exact(x, z)
sum(a$yKnown)   # 17 zeros in y is known
dim(a$x)        # Reduced x, without known y and z with zeros 
dim(a$z)        # Corresponding reduced z 
sum(a$zSkipped) # 5 elements skipped 
t(a$y)          # Just zeros (known are 0 and unknown set to 0) 

# It seems that three additional y-values can be found directly from z
sum(colSums(a$x) == 1)

# But it is the same element of y (row 18)
a$x[18, colSums(a$x) == 1]

# Make use of ones in colSums
a2 &lt;- Reduce0exact(x, z, reduceByColSums = TRUE)
sum(a2$yKnown)          # 18 values in y is known
dim(a2$x)               # Reduced x
dim(a2$z)               # Corresponding reduced z
a2$y[which(a2$yKnown)]  # The known values of y (unknown set to 0)

# Six ones in leverage values 
# Thus six extra elements in y can be found by linear estimation
hat(as.matrix(a2$x), intercept = FALSE)

# Make use of ones in leverages (hat-values)
a3 &lt;- Reduce0exact(x, z, reduceByLeverage = TRUE)
sum(a3$yKnown)          # 26 values in y is known (more than 6 extra)
dim(a3$x)               # Reduced x
dim(a3$z)               # Corresponding reduced z
a3$y[which(a3$yKnown)]  # The known values of y (unknown set to 0)

# More than 6 extra is caused by iteration 
# Extra checking of zeros in z after reduction by leverages 
# Similar checking performed also after reduction by colSums

</code></pre>

<hr>
<h2 id='RoundWhole'>Round values that are close two whole numbers</h2><span id='topic+RoundWhole'></span>

<h3>Description</h3>

<p>Round values that are close two whole numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoundWhole(x, digits = 9, onlyZeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoundWhole_+3A_x">x</code></td>
<td>
<p>vector or matrix</p>
</td></tr>
<tr><td><code id="RoundWhole_+3A_digits">digits</code></td>
<td>
<p>parameter to <code><a href="base.html#topic+round">round</a></code></p>
</td></tr>
<tr><td><code id="RoundWhole_+3A_onlyzeros">onlyZeros</code></td>
<td>
<p>Only round values close to zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>digits</code> is <code>NA</code>, <code>Inf</code> or <code>NULL</code>, input is returned unmodified.
When there is more than one element in <code>digits</code> or <code>onlyZeros</code>,
rounding is performed column-wise.
</p>


<h3>Value</h3>

<p>Modified x
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.0002, 1.00003, 3.00014)
RoundWhole(x)     # No values rounded
RoundWhole(x, 4)  # One value rounded
RoundWhole(x, 3)  # All values rounded
RoundWhole(x, NA) # No values rounded (always)
RoundWhole(x, 3, TRUE)  # One value rounded
RoundWhole(cbind(x, x, x), digits = c(3, 4, NA))
RoundWhole(cbind(x, x), digits = 3, onlyZeros = c(FALSE, TRUE))
</code></pre>

<hr>
<h2 id='RowGroups'>Create numbering according to unique rows</h2><span id='topic+RowGroups'></span>

<h3>Description</h3>

<p>Create numbering according to unique rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RowGroups(x, returnGroups = FALSE, returnGroupsId = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RowGroups_+3A_x">x</code></td>
<td>
<p>Data frame or matrix</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_returngroups">returnGroups</code></td>
<td>
<p>When TRUE unique rows are returned</p>
</td></tr>
<tr><td><code id="RowGroups_+3A_returngroupsid">returnGroupsId</code></td>
<td>
<p>When TRUE Index of unique rows are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the numbering or, according to the arguments,
a list with more output.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(x = c("a", "b"), y = c("A", "B", "A"), z = rep(1:4, 3))
RowGroups(a)
RowGroups(a, TRUE)
RowGroups(a[, 1:2], TRUE, TRUE)
RowGroups(a[, 1, drop = FALSE], TRUE)
</code></pre>

<hr>
<h2 id='SortRows'>Sorting rows of a matrix or data frame</h2><span id='topic+SortRows'></span>

<h3>Description</h3>

<p>Sorting rows of a matrix or data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SortRows(m, cols = 1:dim(m)[2], index.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SortRows_+3A_m">m</code></td>
<td>
<p>matrix or data frame</p>
</td></tr>
<tr><td><code id="SortRows_+3A_cols">cols</code></td>
<td>
<p>Indexes of columns, in the desired order, used for sorting.</p>
</td></tr>
<tr><td><code id="SortRows_+3A_index.return">index.return</code></td>
<td>
<p>logical indicating if the ordering index vector should be
returned instead of sorted input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted <code>m</code> or a row index vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- SSBtoolsData("d2w")
SortRows(d[4:7])
SortRows(d, cols = 4:7)
SortRows(d, cols = c(2, 4))

SortRows(matrix(sample(1:3,15,TRUE),5,3))
</code></pre>

<hr>
<h2 id='sosialFiktiv'>Fictitious datasets returned by SSBtoolsData()</h2><span id='topic+sosialFiktiv'></span><span id='topic+z1'></span><span id='topic+z1micro'></span><span id='topic+z1w'></span><span id='topic+z2'></span><span id='topic+z2w'></span><span id='topic+z3'></span><span id='topic+z3w'></span><span id='topic+z3wb'></span>

<h3>Description</h3>

<p>The most comprehensive dataset, <code>sosialFiktiv</code>, contains three dimensions.
The first dimension is 'region' which is grouped in two ways, 'fylke' and
'kostragr'. The other two are 'hovedint' and 'mnd'. In 'mnd2' two of the
three categories in 'mnd' are merged.
The other datasets (<code>z1</code>, <code>z1w</code>, <code>z2</code>, <code>z2w</code>, <code>z3</code>,
<code>z3w</code>, <code>z3wb</code>) are smaller subdatasets.
Datasets marked with '<code>w</code>' are unstacked and several variables are holding counts.
</p>

<hr>
<h2 id='SSBtoolsData'>Function that returns a dataset</h2><span id='topic+SSBtoolsData'></span>

<h3>Description</h3>

<p>Function that returns a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSBtoolsData(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSBtoolsData_+3A_dataset">dataset</code></td>
<td>
<p>Name of data set within the SSBtools package</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>FIFA2018ABCD:</strong> A hierarchy table based on
countries within groups A-D in the football championship, 2018 FIFA World Cup.
</p>
<p><strong>sprt_emp:</strong> Employment in sport in thousand persons. Data from Eurostat database.
</p>
<p><strong>sprt_emp_geoHier:</strong>  Country hierarchy for the employment in sport data.
</p>
<p><strong>sprt_emp_ageHier:</strong>  Age hierarchy for the employment in sport data.
</p>
<p><strong>sprt_emp_withEU:</strong> The data set sprt_emp extended with a EU variable.
</p>
<p><strong>sp_emp_withEU:</strong> As <code>sprt_emp_withEU</code>, but coded differently.
</p>
<p><strong>example1</strong> Example data similar to <code>sp_emp_withEU</code>.
</p>
<p><strong>magnitude1:</strong> Example data for magnitude tabulation. Same countries as above.
</p>
<p><strong>my_km2:</strong> Fictitious grid data.
</p>
<p><strong>mun_accidents:</strong> Fictitious traffic accident by municipality data.
</p>
<p><strong>sosialFiktiv, z1, z1w, z2, z2w, z3, z3w, z3wb:</strong> See <code><a href="#topic+sosialFiktiv">sosialFiktiv</a></code>.
</p>
<p><strong>d4, d1, d1w, d2, d2w, d3, d3w, d3wb:</strong> English translation of the datasets above.
</p>
<p><strong>d2s, d2ws:</strong> <code>d2</code> and <code>d2w</code> modified to smaller/easier data.
</p>
<p><strong>power10to1, power10to2, <code class="reqn">\ldots</code>:</strong> <code>power10to</code><code class="reqn">i</code> is hierarchical data with <code class="reqn">10^i</code> rows and <code class="reqn">2*i</code> columns.
Tip: Try <code>FindDimLists(SSBtoolsData("power10to3"))</code>
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Daniel Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SSBtoolsData("FIFA2018ABCD")
SSBtoolsData("sprt_emp")
SSBtoolsData("sprt_emp_geoHier")
SSBtoolsData("sprt_emp_ageHier")
SSBtoolsData("sprt_emp_withEU")
SSBtoolsData("d1w")
</code></pre>

<hr>
<h2 id='Stack'>Stack columns from a data frame and include variables.</h2><span id='topic+Stack'></span>

<h3>Description</h3>

<p>Stack columns from a data frame and include variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stack(
  data,
  stackVar = 1:NCOL(data),
  blockVar = integer(0),
  rowData = data.frame(stackVar)[, integer(0), drop = FALSE],
  valueName = "values",
  indName = "ind"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stack_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Stack_+3A_stackvar">stackVar</code></td>
<td>
<p>Indices of variables to be stacked</p>
</td></tr>
<tr><td><code id="Stack_+3A_blockvar">blockVar</code></td>
<td>
<p>Indices of variables to be replicated</p>
</td></tr>
<tr><td><code id="Stack_+3A_rowdata">rowData</code></td>
<td>
<p>A separate data frame where NROW(rowData)=length(stackVar)
such that each row may contain multiple information of each stackVar variable.
The output data frame will contain an extended variant of rowData.</p>
</td></tr>
<tr><td><code id="Stack_+3A_valuename">valueName</code></td>
<td>
<p>Name of the stacked/concatenated output variable</p>
</td></tr>
<tr><td><code id="Stack_+3A_indname">indName</code></td>
<td>
<p>Name of the output variable with information of which vector in x the observation originated.
When indName is NULL this variable is not included in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where the variable ordering corresponds to: blockVar, rowData, valueName, indName
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Unstack">Unstack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 z &lt;- data.frame(n=c(10,20,30), ssb=c('S','S','B'),
 Ayes=1:3,Ano=4:6,Byes=7:9,Bno=10:12)
 zRow &lt;- data.frame(letter=c('A','A','B','B'),answer=c('yes','no','yes','no') )
 
 x &lt;- Stack(z,3:6,1:2,zRow)
 
 Unstack(x,6,3:4,numeric(0),1:2)
 Unstack(x,6,5,numeric(0),1:2)
 Unstack(x,6,3:4,5,1:2)
</code></pre>

<hr>
<h2 id='UniqueSeq'>Sequence within unique values</h2><span id='topic+UniqueSeq'></span>

<h3>Description</h3>

<p>Sequence within unique values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniqueSeq(x, sortdata = matrix(1L, length(x), 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniqueSeq_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="UniqueSeq_+3A_sortdata">sortdata</code></td>
<td>
<p>matrix or vector to determine sequence order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1:4 within A and 1:2 within B
UniqueSeq(c("A", "A", "B", "B", "A", "A"))

# Ordered differently
UniqueSeq(c("A", "A", "B", "B", "A", "A"), c(4, 5, 20, 10, 3, 0))
</code></pre>

<hr>
<h2 id='unmatrix'>Transform data frame with embedded matrices</h2><span id='topic+unmatrix'></span>

<h3>Description</h3>

<p>Transform data frame with embedded matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmatrix(data, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmatrix_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="unmatrix_+3A_sep">sep</code></td>
<td>
<p>A character string used when variable names are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- aggregate(1:6, list(rep(1:3, 2)), range)
b &lt;- unmatrix(a)

a
b

dim(a)
dim(b)

names(a)
names(b)

class(a[, 2])
class(b[, 2])
</code></pre>

<hr>
<h2 id='Unstack'>Unstack a column from a data frame and include additional variables.</h2><span id='topic+Unstack'></span>

<h3>Description</h3>

<p>Unstack a column from a data frame and include additional variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unstack(
  data,
  mainVar = 1,
  stackVar = (1:NCOL(data))[-mainVar],
  extraVar = integer(0),
  blockVar = integer(0),
  sep = "_",
  returnRowData = TRUE,
  sorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Unstack_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="Unstack_+3A_mainvar">mainVar</code></td>
<td>
<p>Index of the variable to be unstacked</p>
</td></tr>
<tr><td><code id="Unstack_+3A_stackvar">stackVar</code></td>
<td>
<p>Index of variables defining the unstack grouping</p>
</td></tr>
<tr><td><code id="Unstack_+3A_extravar">extraVar</code></td>
<td>
<p>Indices of within-replicated variables to be added to the rowData output</p>
</td></tr>
<tr><td><code id="Unstack_+3A_blockvar">blockVar</code></td>
<td>
<p>Indices of between-replicated variables to be added to the data output</p>
</td></tr>
<tr><td><code id="Unstack_+3A_sep">sep</code></td>
<td>
<p>A character string to separate when creating variable names</p>
</td></tr>
<tr><td><code id="Unstack_+3A_returnrowdata">returnRowData</code></td>
<td>
<p>When FALSE output is no list, but only data</p>
</td></tr>
<tr><td><code id="Unstack_+3A_sorted">sorted</code></td>
<td>
<p>When TRUE the created variables is in sorted order. Otherwise input order is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When returnRowData=TRUE output is list of two elements.
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>Unstacked data</p>
</td></tr>
<tr><td><code>rowData</code></td>
<td>
<p>A separate data frame with one row for each unstack grouping composed of the stackVar variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Stack">Stack</a></code>  (examples)
</p>

<hr>
<h2 id='WildcardGlobbing'>Row selection by wildcard/globbing</h2><span id='topic+WildcardGlobbing'></span>

<h3>Description</h3>

<p>The selected rows match combined requirements for all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WildcardGlobbing(x, wg, sign = TRUE, invert = "!")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WildcardGlobbing_+3A_x">x</code></td>
<td>
<p>data.frame with character data</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_wg">wg</code></td>
<td>
<p>data.frame with wildcard/globbing</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_sign">sign</code></td>
<td>
<p>When FALSE, the result is inverted.</p>
</td></tr>
<tr><td><code id="WildcardGlobbing_+3A_invert">invert</code></td>
<td>
<p>Character to invert each single selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+HierarchicalWildcardGlobbing">HierarchicalWildcardGlobbing</a></code>
and <code><a href="#topic+WildcardGlobbingVector">WildcardGlobbingVector</a></code> and make use of
<code><a href="base.html#topic+grepl">grepl</a></code> and <code><a href="utils.html#topic+glob2rx">glob2rx</a></code>.
</p>


<h3>Value</h3>

<p>Logical vector defining subset of rows.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create data input
data(precip)
data(mtcars)
x &lt;- data.frame(car = rownames(mtcars)[rep(1:NROW(mtcars), each = 35)], city = names(precip), 
                stringsAsFactors = FALSE)

# Create globbing/wildcards input
wg &lt;- data.frame(rbind(c("Merc*", "C*"), c("F*", "??????"), c("!?????????*", "!???????*")), 
                 stringsAsFactors = FALSE)
names(wg) &lt;- names(x)

# Select the following combinations:
# - Cars starting with Merc and cities starting with C
# - Cars starting with F and six-letter cities 
# - Cars with less than nine letters and cities with less than seven letters
x[WildcardGlobbing(x, wg), ]
</code></pre>

<hr>
<h2 id='WildcardGlobbingVector'>Selection of elements by wildcard/globbing</h2><span id='topic+WildcardGlobbingVector'></span>

<h3>Description</h3>

<p>Selection of elements by wildcard/globbing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WildcardGlobbingVector(x, wg, negSign = "-", invert = "!")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WildcardGlobbingVector_+3A_x">x</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_wg">wg</code></td>
<td>
<p>Character vector with wildcard/globbing</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_negsign">negSign</code></td>
<td>
<p>Character representing selection to be removed</p>
</td></tr>
<tr><td><code id="WildcardGlobbingVector_+3A_invert">invert</code></td>
<td>
<p>Character to invert each single selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with selected elements of x
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(precip)
x &lt;- names(precip)

# Select the cities starting with B, C and Sa.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*"))

# Remove from the selection cities with o and t in position 2 and 4, respectively.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*", "-?o*", "-???t*"))

# Add to the selection cities not having six or more letters.
WildcardGlobbingVector(x, c("B*", "C*", "Sa*", "-?o*", "-???t*", "!??????*"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
