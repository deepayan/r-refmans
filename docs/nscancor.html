<!DOCTYPE html><html><head><title>Help for package nscancor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nscancor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acor'><p>Additional Explained Correlation</p></a></li>
<li><a href='#colCardinalities'><p>Cardinality of Column Vectors</p></a></li>
<li><a href='#macor'><p>Multi-Domain Additional Explained Correlation</p></a></li>
<li><a href='#mcancor'><p>Non-Negative and Sparse Multi-Domain CCA</p></a></li>
<li><a href='#nscancor'><p>Non-Negative and Sparse CCA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7.0-6</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Negative and Sparse CCA</td>
</tr>
<tr>
<td>Description:</td>
<td>Two implementations of canonical correlation analysis
        (CCA) that are based on iterated regression. By choosing the
        appropriate regression algorithm for each data domain, it is
        possible to enforce sparsity, non-negativity or other kinds of
        constraints on the projection vectors. Multiple canonical
        variables are computed sequentially using a generalized
        deflation scheme, where the additional correlation not
        explained by previous variables is maximized. nscancor() is
        used to analyze paired data from two domains, and has the same
        interface as cancor() from the 'stats' package (plus some extra
        parameters). mcancor() is appropriate for analyzing data from
        three or more domains. See
        <a href="https://sigg-iten.ch/learningbits/2014/01/20/canonical-correlation-analysis-under-constraints/">https://sigg-iten.ch/learningbits/2014/01/20/canonical-correlation-analysis-under-constraints/</a>
        and Sigg et al. (2007) &lt;<a href="https://doi.org/10.1109%2FMLSP.2007.4414315">doi:10.1109/MLSP.2007.4414315</a>&gt; for more
        details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sigg-iten.ch/research/">https://sigg-iten.ch/research/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chrsigg/nscancor/issues">https://github.com/chrsigg/nscancor/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CCA, glmnet, MASS, roxygen2, testthat (&ge; 0.8), V8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-30 14:57:18 UTC; chrsigg</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Sigg <a href="https://orcid.org/0000-0003-1067-9224"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  R Core team [cph, ctb] (cancor() interface and documentation)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Sigg &lt;christian@sigg-iten.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acor'>Additional Explained Correlation</h2><span id='topic+acor'></span>

<h3>Description</h3>

<p><code>acor</code> computes the additional standard correlation explained by each
canonical variable, taking into account the possible non-conjugacy of the
canonical vectors. The result of the analysis is returned as a list of class
<code>nscancor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acor(
  x,
  xcoef,
  y,
  ycoef,
  xcenter = TRUE,
  ycenter = TRUE,
  xscale = FALSE,
  yscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acor_+3A_x">x</code></td>
<td>
<p>a numeric matrix which provides the data from the first domain</p>
</td></tr>
<tr><td><code id="acor_+3A_xcoef">xcoef</code></td>
<td>
<p>a numeric data matrix with the canonical vectors related to
<code>x</code> as its columns.</p>
</td></tr>
<tr><td><code id="acor_+3A_y">y</code></td>
<td>
<p>a numeric matrix which provides the data from the second domain</p>
</td></tr>
<tr><td><code id="acor_+3A_ycoef">ycoef</code></td>
<td>
<p>a numeric data matrix with the canonical vectors related to
<code>y</code> as its columns.</p>
</td></tr>
<tr><td><code id="acor_+3A_xcenter">xcenter</code></td>
<td>
<p>a logical value indicating whether the empirical mean of (each
column of) <code>x</code> should be subtracted. Alternatively, a vector of length
equal to the number of columns of <code>x</code> can be supplied. The value is
passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="acor_+3A_ycenter">ycenter</code></td>
<td>
<p>analogous to <code>xcenter</code></p>
</td></tr>
<tr><td><code id="acor_+3A_xscale">xscale</code></td>
<td>
<p>a logical value indicating whether the columns of <code>x</code>
should be scaled to have unit variance before the analysis takes place. The
default is <code>FALSE</code> for consistency with <code>cancor</code>. Alternatively,
a vector of length equal to the number of columns of <code>x</code> can be
supplied. The value is passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="acor_+3A_yscale">yscale</code></td>
<td>
<p>analogous to <code>xscale</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additional correlation is measured after projecting the corresponding
canonical vectors to the ortho-complement space spanned by the previous
canonical variables. This procedure ensures that the correlation explained by
non-conjugate canonical vectors is not counted multiple times. See Mackey
(2009) for a presentation of generalized deflation in the context of
principal component analysis (PCA), which was adapted here to CCA.
</p>
<p><code>acor</code> is also useful to build a partial CCA model, to be completed with
additional canonical variables computed using <code><a href="#topic+nscancor">nscancor</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>nscancor</code> containing the
following elements: </p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>the additional correlation explained by each
pair of canonical variables</p>
</td></tr> <tr><td><code>xcoef</code></td>
<td>
<p>copied from the
input arguments</p>
</td></tr>  <tr><td><code>ycoef</code>, <code>ycenter</code>, <code>yscale</code></td>
<td>
<p>copied from the input
arguments</p>
</td></tr> <tr><td><code>xp</code></td>
<td>
<p>the deflated data matrix corresponding to <code>x</code></p>
</td></tr>
<tr><td><code>yp</code></td>
<td>
<p>analogous to <code>xp</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Mackey, L. (2009) Deflation Methods for Sparse PCA. In
<em>Advances in Neural Information Processing Systems</em> (pp. 1017&ndash;1024).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nutrimouse, package = "CCA")

x &lt;- nutrimouse$gene[ , 1:5]
y &lt;- nutrimouse$lipid
cc &lt;- cancor(x, y)

# Re-compute explained correlation
ac &lt;- acor(x, cc$xcoef, y, cc$ycoef)

# Results should agree
print(cc$cor)
print(ac$cor)

</code></pre>

<hr>
<h2 id='colCardinalities'>Cardinality of Column Vectors</h2><span id='topic+colCardinalities'></span>

<h3>Description</h3>

<p>Computes the cardinality (the number of non-zero elements) of each column of
the matrix <code class="reqn">\mathbf{w}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCardinalities(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colCardinalities_+3A_w">w</code></td>
<td>
<p>a numeric matrix, e.g. <code>xcoef</code> as returned by <code><a href="#topic+nscancor">nscancor</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the number of non-zero elements of each column of <code>w</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns c(2, 1)
colCardinalities(matrix(c(1, 0, 2, -1, 0, 0), ncol = 2))


</code></pre>

<hr>
<h2 id='macor'>Multi-Domain Additional Explained Correlation</h2><span id='topic+macor'></span>

<h3>Description</h3>

<p><code>macor</code> generalizes <code><a href="#topic+acor">acor</a></code> to the case of more than two data
domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>macor(x, coef, center = TRUE, scale_ = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="macor_+3A_x">x</code></td>
<td>
<p>a list of numeric matrices which contain the data from the different
domains</p>
</td></tr>
<tr><td><code id="macor_+3A_coef">coef</code></td>
<td>
<p>a list of matrices containing the canonical vectors related to
each data domain. Each matrix contains the respective canonical vectors as
its columns.</p>
</td></tr>
<tr><td><code id="macor_+3A_center">center</code></td>
<td>
<p>a list of logical values indicating whether the empirical mean
of (each column of) the corresponding data matrix should be subtracted.
Alternatively, a list of vectors can be supplied, where each vector
specifies the mean to be subtracted from the corresponding data matrix.
Each list element is passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="macor_+3A_scale_">scale_</code></td>
<td>
<p>a list of logical values indicating whether the columns of the
corresponding data matrix should be scaled to have unit variance before the
analysis takes place. The default is <code>FALSE</code> for consistency with
<code>acor</code>. Alternatively, a list of vectors can be supplied, where each
vector specifies the standard deviations used to rescale the columns of the
corresponding data matrix. Each list element is passed to
<code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>mcancor</code> with the
following elements: </p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a multi-dimensional array containing the
additional correlations explained by each pair of canonical variables. The
first two dimensions correspond to the domains, and the third dimension
corresponds to the different canonical variables per domain.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>copied from the input arguments</p>
</td></tr> <tr><td><code>center</code></td>
<td>
<p>the list of
empirical means used to center the data matrices</p>
</td></tr> <tr><td><code>scale</code></td>
<td>
<p>the list of
empirical standard deviations used to scale the data matrices</p>
</td></tr><tr><td><code>xp</code></td>
<td>
<p>the
list of deflated data matrices corresponding to <code>x</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(10*5), 10)
y &lt;- matrix(runif(10*5), 10)
z &lt;- matrix(runif(10*5), 10)

xcoef &lt;- matrix(rnorm(2*5), 5)
ycoef &lt;- matrix(rnorm(2*5), 5)
zcoef &lt;- matrix(rnorm(2*5), 5)

# Explained multi-domain correlation
macor(list(x, y, z), list(xcoef, ycoef, zcoef))$cor
</code></pre>

<hr>
<h2 id='mcancor'>Non-Negative and Sparse Multi-Domain CCA</h2><span id='topic+mcancor'></span>

<h3>Description</h3>

<p>Performs a canonical correlation analysis (CCA) on multiple data domains,
where constraints such as non-negativity or sparsity are enforced on the
canonical vectors. The result
of the analysis is returned as a list of class <code>mcancor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcancor(
  x,
  center = TRUE,
  scale_ = FALSE,
  nvar = min(sapply(x, dim)),
  predict,
  cor_tol = NULL,
  nrestart = 10,
  iter_tol = 0,
  iter_max = 50,
  partial_model = NULL,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcancor_+3A_x">x</code></td>
<td>
<p>a list of numeric matrices which contain the data from the different
domains</p>
</td></tr>
<tr><td><code id="mcancor_+3A_center">center</code></td>
<td>
<p>a list of logical values indicating whether the empirical mean
of (each column of) the corresponding data matrix should be subtracted.
Alternatively, a list of vectors can be supplied, where each vector
specifies the mean to be subtracted from the corresponding data matrix.
Each list element is passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_scale_">scale_</code></td>
<td>
<p>a list of logical values indicating whether the columns of the
corresponding data matrix should be scaled to have unit variance before the
analysis takes place. The default is <code>FALSE</code> for consistency with
<code>nscancor</code>. Alternatively, a list of vectors can be supplied, where
each vector specifies the standard deviations used to rescale the columns
of the corresponding data matrix. Each list element is passed to
<code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_nvar">nvar</code></td>
<td>
<p>the number of canonical variables to be computed for each domain.
With the default setting, canonical variables are computed until at least
one data matrix is fully deflated.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_predict">predict</code></td>
<td>
<p>a list of regression functions to predict the sum of the
canonical variables of all other domains. The formal arguments for each
regression function are the design matrix <code>x</code> corresponding to the
data from the current domain, the regression target <code>sc</code> as the sum of
the canonical variables for all other domains, and <code>cc</code> as a counter
of which canonical variable is currently computed (e.g. for enforcing
different constraints for subsequent canonical vectors of a given domain).
See the examples for an illustration.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_cor_tol">cor_tol</code></td>
<td>
<p>a threshold indicating the magnitude below which canonical
variables should be omitted. Variables are omitted if the sum of all their
correlations are less than or equal to <code>cor_tol</code> times the sum of all
correlations of the first canonical variables of all domains. With the
default <code>NULL</code> setting, no variables are omitted.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_nrestart">nrestart</code></td>
<td>
<p>the number of random restarts for computing the canonical
variables via iterated regression steps. The solution achieving maximum
explained correlation over all random restarts is kept. A value greater
than one can help to avoid poor local maxima.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_iter_tol">iter_tol</code></td>
<td>
<p>If the relative change of the objective is less than
<code>iter_tol</code> between iterations, the procedure is assumed to have
converged to a local optimum.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_iter_max">iter_max</code></td>
<td>
<p>the maximum number of iterations to be performed. The
procedure is terminated if either the <code>iter_tol</code> or the
<code>iter_max</code> criterion is satisfied.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_partial_model">partial_model</code></td>
<td>
<p><code>NULL</code> or an object of class <code>mcancor</code>. The
computation can be continued from a partial model by providing an
<code>mcancor</code> object (either from a previous run of this function or from
<code><a href="#topic+macor">macor</a></code>) and setting <code>nvar</code> to a value greater than the
number of canonical variables contained in the partial model. See the
examples for an illustration.</p>
</td></tr>
<tr><td><code id="mcancor_+3A_verbosity">verbosity</code></td>
<td>
<p>an integer specifying the verbosity level. Greater values
result in more output, the default is to be quiet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcancor</code> generalizes <code><a href="#topic+nscancor">nscancor</a></code> to the case where more than
two data domains are available for an analysis. Its objective is to maximize
the sum of all pairwise correlations of the canonical variables.
</p>


<h3>Value</h3>

<p><code>mcancor</code> returns a list of class <code>mcancor</code> with the following elements:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>a multi-dimensional array containing the additional correlations
explained by each pair of canonical variables. The first two dimensions
correspond to the domains, and the third dimension corresponds to the
different canonical variables per domain (see also <code><a href="#topic+macor">macor</a></code>).</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>a list of matrices containing the canonical vectors related to
each data domain. The canonical vectors are stored as the columns of each
matrix.</p>
</td></tr> <tr><td><code>center</code></td>
<td>
<p>the list of empirical means used to center the data
matrices</p>
</td></tr> <tr><td><code>scale</code></td>
<td>
<p>the list of empirical standard deviations used to
scale the data matrices</p>
</td></tr> <tr><td><code>xp</code></td>
<td>
<p>the list of deflated
data matrices corresponding to <code>x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+macor">macor</a></code>, <code><a href="#topic+nscancor">nscancor</a></code>, <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# As of version 1.2.1 of the PMA package, breastdata.rda is no longer
# contained in the package and needs to be downloaded separately
breastdata_url &lt;- "https://statweb.stanford.edu/~tibs/PMA/breastdata.rda"
breastdata_file &lt;- tempfile("breastdata_", fileext = ".rda")
status &lt;- download.file(breastdata_url, breastdata_file, mode = "wb")
if (status &gt; 0)
  stop("Unable to download from", breastdata_url)
load(breastdata_file)

# Three data domains: a subset of genes, and CGH spots for the first and
# second chromosome
x &lt;- with(
  breastdata,
  list(t(rna)[ , 1:100], t(dna)[ , chrom == 1], t(dna)[ , chrom == 2])
)

# Sparse regression functions with different cardinalities for different domains
generate_predict &lt;- function(dfmax) {
  force(dfmax)
  return(
    function(x, sc, cc) {
      en &lt;- glmnet::glmnet(x, sc, alpha = 0.05, intercept = FALSE, dfmax = dfmax)
      W &lt;- coef(en)
      return(W[2:nrow(W), ncol(W)])
    }
  )
}
predict &lt;- lapply(c(20, 10, 10), generate_predict)

# Compute two canonical variables per domain
mcc &lt;- mcancor(x, predict = predict, nvar = 2)

# Compute another canonical variable for each domain
mcc &lt;- mcancor(x, predict = predict, nvar = 3, partial_model = mcc)
mcc$cor


</code></pre>

<hr>
<h2 id='nscancor'>Non-Negative and Sparse CCA</h2><span id='topic+nscancor'></span>

<h3>Description</h3>

<p>Performs a canonical correlation analysis (CCA) where constraints such as
non-negativity or  sparsity are enforced on the canonical vectors. The result
of the analysis is returned as a list of class <code>nscancor</code>, which
contains a superset of the elements returned by <code><a href="stats.html#topic+cancor">cancor</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nscancor(
  x,
  y,
  xcenter = TRUE,
  ycenter = TRUE,
  xscale = FALSE,
  yscale = FALSE,
  nvar = min(dim(x), dim(y)),
  xpredict,
  ypredict,
  cor_tol = NULL,
  nrestart = 10,
  iter_tol = 0,
  iter_max = 50,
  partial_model = NULL,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nscancor_+3A_x">x</code></td>
<td>
<p>a numeric matrix which provides the data from the first domain</p>
</td></tr>
<tr><td><code id="nscancor_+3A_y">y</code></td>
<td>
<p>a numeric matrix which provides the data from the second domain</p>
</td></tr>
<tr><td><code id="nscancor_+3A_xcenter">xcenter</code></td>
<td>
<p>a logical value indicating whether the empirical mean of (each
column of) <code>x</code> should be subtracted. Alternatively, a vector of length
equal to the number of columns of <code>x</code> can be supplied. The value is
passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_ycenter">ycenter</code></td>
<td>
<p>analogous to <code>xcenter</code></p>
</td></tr>
<tr><td><code id="nscancor_+3A_xscale">xscale</code></td>
<td>
<p>a logical value indicating whether the columns of <code>x</code>
should be scaled to have unit variance before the analysis takes place. The
default is <code>FALSE</code> for consistency with <code>cancor</code>. Alternatively,
a vector of length equal to the number of columns of <code>x</code> can be
supplied. The value is passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_yscale">yscale</code></td>
<td>
<p>analogous to <code>xscale</code></p>
</td></tr>
<tr><td><code id="nscancor_+3A_nvar">nvar</code></td>
<td>
<p>the number of canonical variables to be computed for each domain.
With the default setting, canonical variables are computed until either
<code>x</code> or <code>y</code> is fully deflated.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_xpredict">xpredict</code></td>
<td>
<p>the regression function to predict the canonical variable for
<code>x</code>, given <code>y</code>. The formal arguments are the design matrix
<code>y</code>, the regression target <code>xc</code> as the current canonical variable
for <code>x</code>, and <code>cc</code> as a counter of the current pair of canonical
variables (e.g. for enforcing different constraints for different canonical
vectors). See the examples for an illustration.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_ypredict">ypredict</code></td>
<td>
<p>analogous to <code>xpredict</code></p>
</td></tr>
<tr><td><code id="nscancor_+3A_cor_tol">cor_tol</code></td>
<td>
<p>a threshold indicating the magnitude below which canonical
variables should be omitted. Variables are omitted if their explained
correlations are less than or equal to <code>cor_tol</code> times the correlation
of the first pair of canonical variables. With the default <code>NULL</code>
setting, no variables are omitted.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_nrestart">nrestart</code></td>
<td>
<p>the number of random restarts for computing the canonical
variables via iterated regression steps. The solution achieving maximum
explained correlation over all random restarts is kept. A value greater
than one can help to avoid poor local maxima.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_iter_tol">iter_tol</code></td>
<td>
<p>If the relative change of the objective is less than
<code>iter_tol</code> between iterations, the procedure is assumed to have
converged to a local optimum.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_iter_max">iter_max</code></td>
<td>
<p>the maximum number of iterations to be performed. The
procedure is terminated if either the <code>iter_tol</code> or the
<code>iter_max</code> criterion is satisfied.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_partial_model">partial_model</code></td>
<td>
<p><code>NULL</code> or an object of class <code>nscancor</code>. The
computation can be continued from a partial model by providing an
<code>nscancor</code> object (either from a previous run of this function or from
<code><a href="#topic+acor">acor</a></code>) and setting <code>nvar</code> to a value greater than the
number of canonical variables contained in the partial model. See the
examples for an illustration.</p>
</td></tr>
<tr><td><code id="nscancor_+3A_verbosity">verbosity</code></td>
<td>
<p>an integer specifying the verbosity level. Greater values
result in more output, the default is to be quiet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nscancor</code> computes the canonical vectors (called <code>xcoef</code> and
<code>ycoef</code>) using iterated regression steps, where the constraints suitable
for each domain are enforced by choosing the appropriate regression method.
See Sigg et al. (2007) for an early application of the principle (not yet
including generalized deflation).
</p>
<p>Because constrained canonical vectors no longer correspond to true
eigenvectors of the cross-covariance matrix and are usually not pairwise
conjugate (i.e. the canonical variables are not uncorrelated), special
attention needs to be paid when computing more than a single pair of
canonical vectors. <code>nscancor</code> implements a generalized deflation (GD)
scheme which builds on GD for PCA as proposed by Mackey (2009). For each
domain, a basis of the space spanned by the previous canonical variables is
computed. Then, the correlation of the current pair of canonical variables is
maximized after projecting each current canonical vector to the
ortho-complement space of its respective basis. This procedure maximizes the
additional correlation not explained by previous canonical variables, and is
identical to standard CCA if the canonical vectors are the eigenvectors of
the cross-covariance matrix.
</p>
<p>See the references for further details.
</p>


<h3>Value</h3>

<p>A list of class <code>nscancor</code> containing
the following elements: </p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>the additional correlation explained by
each pair of canonical variables, see <code><a href="#topic+acor">acor</a></code>.</p>
</td></tr> <tr><td><code>xcoef</code></td>
<td>
<p>the
matrix containing the canonical vectors related to <code>x</code> as its columns</p>
</td></tr>
<tr><td><code>ycoef</code></td>
<td>
<p>analogous to <code>xcoef</code></p>
</td></tr> <tr><td><code>xcenter</code></td>
<td>
<p>if <code>xcenter</code> is
<code>TRUE</code> the centering vector, else the zero vector (in accordance with
<code>cancor</code>)</p>
</td></tr> <tr><td><code>ycenter</code></td>
<td>
<p>analogous to <code>xcenter</code></p>
</td></tr>
<tr><td><code>xscale</code></td>
<td>
<p>if <code>xscale</code> is <code>TRUE</code> the scaling vector, else
FALSE </p>
</td></tr> <tr><td><code>yscale</code></td>
<td>
<p>analogous to <code>xscale</code></p>
</td></tr> <tr><td><code>xp</code></td>
<td>
<p>the deflated
data matrix corresponding to <code>x</code></p>
</td></tr> <tr><td><code>yp</code></td>
<td>
<p>analogous to <code>xp</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Sigg, C. and Fischer, B. and Ommer, B. and Roth, V. and Buhmann,
J. (2007) Nonnegative CCA for Audiovisual Source Separation. In
<em>Proceedings of the 2007 IEEE Workshop on Machine Learning for Signal
Processing</em> (pp. 253&ndash;258).
</p>
<p>Mackey, L. (2009) Deflation Methods for Sparse PCA. In
<em>Advances in Neural Information Processing Systems</em> (pp. 1017&ndash;1024).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acor">acor</a></code>, <code><a href="stats.html#topic+cancor">cancor</a></code>, <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(nutrimouse, package = "CCA")
set.seed(1)

###
# Unconstrained CCA, produces results close to calling
# cancor(nutrimouse$gene[ , 1:5], nutrimouse$lipid)

ypredict &lt;- function(x, yc, cc) {
  return(MASS::ginv(x)%*%yc)
}
xpredict &lt;- function(y, xc, cc) {
  return(MASS::ginv(y)%*%xc)
}
cc &lt;- nscancor(nutrimouse$gene[ , 1:5], nutrimouse$lipid, xpredict = xpredict,
               ypredict = ypredict)
print(cc$cor)

###
# Non-negative sparse CCA using glmnet() as the regression function, where
# different regularizers are enforced on the different data domains and pairs
# of canonical variables.

dfmax_w &lt;- c(40, 15, 10)
ypredict &lt;- function(x, yc, cc) {
  en &lt;- glmnet::glmnet(x, yc, alpha = 0.5, intercept = FALSE,
                       dfmax = dfmax_w[cc], lower.limits = 0)
  W &lt;- coef(en)
  return(W[2:nrow(W), ncol(W)])
}
dfmax_v &lt;- c(7, 5, 5)
xpredict &lt;- function(y, xc, cc) {
  en &lt;- glmnet::glmnet(y, xc, alpha = 0.5, intercept = FALSE,
                       dfmax = dfmax_v[cc])
  V &lt;- coef(en)
  return(V[2:nrow(V), ncol(V)])
}
nscc &lt;- nscancor(nutrimouse$gene, nutrimouse$lipid, nvar = 2,
                 xpredict = xpredict, ypredict = ypredict)

# continue the computation of canonical variables from a partial model
nscc &lt;- nscancor(nutrimouse$gene, nutrimouse$lipid, nvar = 3,
                 xpredict = xpredict, ypredict = ypredict,
                 partial_model = nscc)
print(nscc$cor)
print(nscc$xcoef)
print(nscc$ycoef)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
