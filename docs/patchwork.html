<!DOCTYPE html><html lang="en"><head><title>Help for package patchwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {patchwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#patchwork-package'><p>patchwork: The Composer of Plots</p></a></li>
<li><a href='#align_plots'><p>Deprecated functions</p></a></li>
<li><a href='#area'><p>Specify a plotting area in a layout</p></a></li>
<li><a href='#free'><p>Free a plot from various alignments</p></a></li>
<li><a href='#guide_area'><p>Add an area to hold collected guides</p></a></li>
<li><a href='#inset_element'><p>Create an inset to be added on top of the previous plot</p></a></li>
<li><a href='#multipage_align'><p>Align plots across multiple pages</p></a></li>
<li><a href='#patchGrob'><p>Get a grob describing the content of a patch object</p></a></li>
<li><a href='#patchworkGrob'><p>Convert a patchwork to a gtable</p></a></li>
<li><a href='#plot_annotation'><p>Annotate the final patchwork</p></a></li>
<li><a href='#plot_arithmetic'><p>Plot arithmetic</p></a></li>
<li><a href='#plot_layout'><p>Define the grid to compose plots in</p></a></li>
<li><a href='#plot_spacer'><p>Add a completely blank area</p></a></li>
<li><a href='#wrap_elements'><p>Wrap arbitrary graphics in a patchwork-compliant patch</p></a></li>
<li><a href='#wrap_ggplot_grob'><p>Make a gtable created from a ggplot object patchwork compliant</p></a></li>
<li><a href='#wrap_plots'><p>Wrap plots into a patchwork</p></a></li>
<li><a href='#wrap_table'><p>Wrap a table in a patchwork compliant patch</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Composer of Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'ggplot2' package provides a strong API for sequentially 
    building up a plot, but does not concern itself with composition of multiple
    plots. 'patchwork' is a package that expands the API to allow for 
    arbitrarily complex composition of plots by, among others, providing 
    mathematical operators for combining multiple plots. Other packages that try 
    to address this need (but with a different approach) are 'gridExtra' and 
    'cowplot'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.0.0), gtable, grid, stats, grDevices, utils,
graphics, rlang (&ge; 1.0.0), cli, farver</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://patchwork.data-imaginist.com">https://patchwork.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/patchwork">https://github.com/thomasp85/patchwork</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/patchwork/issues">https://github.com/thomasp85/patchwork/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, gridGraphics, gridExtra, ragg, testthat (&ge;
2.1.0), vdiffr, covr, png, gt (&ge; 0.11.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>gifski</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-16 08:14:08 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-16 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='patchwork-package'>patchwork: The Composer of Plots</h2><span id='topic+patchwork'></span><span id='topic+patchwork-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The 'ggplot2' package provides a strong API for sequentially building up a plot, but does not concern itself with composition of multiple plots. 'patchwork' is a package that expands the API to allow for arbitrarily complex composition of plots by, among others, providing mathematical operators for combining multiple plots. Other packages that try to address this need (but with a different approach) are 'gridExtra' and 'cowplot'.
</p>


<h3>Overview</h3>

<p>The use and premise of <code>patchwork</code> is simple: Just add <code>ggplot2</code> plots
together to compose multiplot layouts. Because of this simplicity there is
not much more to say. Still, a few functions allow you to modify the
behaviour, e.g.:
</p>

<ul>
<li> <p><code><a href="#topic+plot_layout">plot_layout()</a></code> allows you to define the grid that plots are put into
</p>
</li>
<li> <p><code><a href="#topic+plot_annotation">plot_annotation()</a></code> allows you to add titles, tags etc.
</p>
</li></ul>



<h3>Learn more</h3>

<p>The guides below will teach you all about what you can do with patchwork.
</p>

<ul>
<li> <p><a href="https://patchwork.data-imaginist.com/articles/patchwork.html">Getting Started</a>
</p>
</li>
<li> <p><a href="https://patchwork.data-imaginist.com/articles/guides/assembly.html">Assembling Plots</a>
</p>
</li>
<li> <p><a href="https://patchwork.data-imaginist.com/articles/guides/layout.html">Defining Layouts</a>
</p>
</li>
<li> <p><a href="https://patchwork.data-imaginist.com/articles/guides/annotation.html">Adding Annotation</a>
</p>
</li>
<li> <p><a href="https://patchwork.data-imaginist.com/articles/guides/multipage.html">Aligning across pages</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://patchwork.data-imaginist.com">https://patchwork.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/patchwork">https://github.com/thomasp85/patchwork</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/patchwork/issues">https://github.com/thomasp85/patchwork/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
# You can add plots saved to variables

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))

p1 + p2

# Or build it up in one step
ggplot(mtcars) +
  geom_point(aes(mpg, disp)) +
  ggplot(mtcars) +
  geom_boxplot(aes(gear, disp, group = gear))

</code></pre>

<hr>
<h2 id='align_plots'>Deprecated functions</h2><span id='topic+align_plots'></span>

<h3>Description</h3>

<p>These functions are deprecated and should not be used.
</p>

<hr>
<h2 id='area'>Specify a plotting area in a layout</h2><span id='topic+area'></span>

<h3>Description</h3>

<p>This is a small helper used to specify a single area in a rectangular grid
that should contain a plot. Objects constructed with <code>area()</code> can be
concatenated together with <code>c()</code> in order to specify multiple areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area(t, l, b = t, r = l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="area_+3A_t">t</code>, <code id="area_+3A_b">b</code></td>
<td>
<p>The top and bottom bounds of the area in the grid</p>
</td></tr>
<tr><td><code id="area_+3A_l">l</code>, <code id="area_+3A_r">r</code></td>
<td>
<p>The left and right bounds of the area int the grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grid that the areas are specified in reference to enumerate rows from top
to bottom, and coloumns from left to right. This means that <code>t</code> and <code>l</code>
should always be less or equal to <code>b</code> and <code>r</code> respectively. Instead of
specifying area placement with a combination of <code>area()</code> calls, it is
possible to instead pass in a single string
</p>
<div class="sourceCode"><pre>areas &lt;- c(area(1, 1, 2, 1),
           area(2, 3, 3, 3))
</pre></div>
<p>is equivalent to
</p>
<div class="sourceCode"><pre>areas &lt; -"A##
          A#B
          ##B"
</pre></div>
<p>For an example of this, see the <code><a href="#topic+plot_layout">plot_layout()</a></code> examples.
</p>


<h3>Value</h3>

<p>A <code>patch_area</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)

layout &lt;- c(
  area(1, 1),
  area(1, 3, 3),
  area(3, 1, 3, 2)
)

# Show the layout to make sure it looks as it should
plot(layout)

# Apply it to a patchwork
p1 + p2 + p3 + plot_layout(design = layout)

</code></pre>

<hr>
<h2 id='free'>Free a plot from various alignments</h2><span id='topic+free'></span>

<h3>Description</h3>

<p>While the purpose of patchwork is often to align plots by their various parts,
sometimes this doesn't cut it and we want to compose plots without alignment.
The <code>free()</code> function tells patchwork to treat the content (which can either
be a ggplot or a patchwork) specially and not align it with the remaining
plots in the composition. <code>free()</code> has various modes to control what type of
&quot;non-alignment&quot; is applied (see Details). Further you can control which side
of the plot the non-alignment is applied to. You can stack <code>free()</code> calls if
you e.g. want the top part to not align to the panel and the left part to not
align to the labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>free(x, type = c("panel", "label", "space"), side = "trbl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="free_+3A_x">x</code></td>
<td>
<p>A ggplot or patchwork object</p>
</td></tr>
<tr><td><code id="free_+3A_type">type</code></td>
<td>
<p>Which type of freeing should be applied. See the Details section</p>
</td></tr>
<tr><td><code id="free_+3A_side">side</code></td>
<td>
<p>Which side should the freeing be applied to. A string containing
one or more of &quot;t&quot;, &quot;r&quot;, &quot;b&quot;, and &quot;l&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>free()</code> has multiple modes depending on what you are needing:
</p>
<p>The default <code>"panel"</code> will allow the panel area to ignore alginment with the
remaining plots and expand as much as needed to fill any empty space.
</p>
<p>The <code>"label"</code> type will instead free the axis label to keep its proximity to
the axis, even if a longer axis text from another plot would push them apart.
</p>
<p>The <code>"space"</code> type also keeps axis and title together, but will instead not
reserve any space for it. This allows the axis to occupy space in an
otherwise empty area without making additional space available for itself.
</p>


<h3>Value</h3>

<p>A modified version of <code>x</code> with a <code>free_plot</code> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sometimes you have a plot that defies good composition alginment, e.g. due
# to long axis labels
library(ggplot2)
p1 &lt;- ggplot(mtcars) +
  geom_bar(aes(y = factor(gear), fill = factor(gear))) +
  scale_y_discrete(
    "",
    labels = c("3 gears are often enough",
               "But, you know, 4 is a nice number",
               "I would def go with 5 gears in a modern car")
  )

# When combined with other plots it ends up looking bad
p2 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))

p1 / p2

# We can fix this be using free (here, with the default "panel" type)
free(p1) / p2

# If we still want the panels to be aligned to the right, we can choose to
# free only the left side
free(p1, side = "l") / p2

# We can still collect guides like before
free(p1) / p2 + plot_layout(guides = "collect")

# We could use "label" to fix the layout in a different way
p1 / free(p2, "label")

# Another issue is that long labels are not using already available free
# space.
plot_spacer() + p1 + p2 + p2

# This can be fixed with the "space" type
plot_spacer() + free(p1, "space", "l") + p2 + p2

</code></pre>

<hr>
<h2 id='guide_area'>Add an area to hold collected guides</h2><span id='topic+guide_area'></span>

<h3>Description</h3>

<p>Using the <code>guides</code> argument in <code><a href="#topic+plot_layout">plot_layout()</a></code> you can collect and collapse
guides from plots. By default these guides will be put on the side like with
regular plots, but by adding a <code>guide_area()</code> to the plot you can tell
patchwork to place the guides in that area instead. If guides are not
collected or no guides exists to collect it behaves as a standard
<code><a href="#topic+plot_spacer">plot_spacer()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_area()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp, colour = factor(gear)))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)

# Guides are by default kept beeside their plot
p1 + p2 + p3

# They can be collected and placed on the side (according to the patchwork
# theme)
p1 + p2 + p3 + plot_layout(guides = 'collect', ncol = 2)

# Using guide_area() you can also designate an empty area for this
p1 + p2 + p3 + guide_area() + plot_layout(guides = 'collect')

</code></pre>

<hr>
<h2 id='inset_element'>Create an inset to be added on top of the previous plot</h2><span id='topic+inset_element'></span>

<h3>Description</h3>

<p>The standard approach of patchwork is to place plots next to each other based
on the provided layout. However, it may sometimes be beneficial to place one
or several plots or graphic elements freely on top or below another plot. The
<code>inset_element()</code> function provides a way to create such insets and gives you
full control over placement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inset_element(
  p,
  left,
  bottom,
  right,
  top,
  align_to = "panel",
  on_top = TRUE,
  clip = TRUE,
  ignore_tag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inset_element_+3A_p">p</code></td>
<td>
<p>A grob, ggplot, patchwork, formula, raster, nativeRaster, or gt object
to add as an inset</p>
</td></tr>
<tr><td><code id="inset_element_+3A_left">left</code>, <code id="inset_element_+3A_bottom">bottom</code>, <code id="inset_element_+3A_right">right</code>, <code id="inset_element_+3A_top">top</code></td>
<td>
<p>numerics or units giving the location of the
outer bounds. If given as numerics they will be converted to <code>npc</code> units.</p>
</td></tr>
<tr><td><code id="inset_element_+3A_align_to">align_to</code></td>
<td>
<p>Specifies what <code>left</code>, <code>bottom</code>, etc should be relative to.
Either <code>'panel'</code> (default), <code>'plot'</code>, or <code>'full'</code>.</p>
</td></tr>
<tr><td><code id="inset_element_+3A_on_top">on_top</code></td>
<td>
<p>Logical. Should the inset be placed on top of the other plot or
below (but above the background)?</p>
</td></tr>
<tr><td><code id="inset_element_+3A_clip">clip</code></td>
<td>
<p>Logical. Should clipping be performed on the inset?</p>
</td></tr>
<tr><td><code id="inset_element_+3A_ignore_tag">ignore_tag</code></td>
<td>
<p>Logical. Should autotagging ignore the inset?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>inset_path</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))

# Basic use
p1 + inset_element(p2, 0.6, 0.6, 1, 1)

# Align to the full area instead
p1 + inset_element(p2, 0, 0.6, 0.4, 1, align_to = 'full')

# Grobs and other objects can be added as insets as well
p1 + inset_element(grid::circleGrob(), 0.4, 0.4, 0.6, 0.6)

if (requireNamespace('png', quietly = TRUE)) {
  logo &lt;- system.file('help', 'figures', 'logo.png', package = 'patchwork')
  logo &lt;- png::readPNG(logo, native = TRUE)
  p1 + inset_element(logo, 0.8, 0.8, 1, 1, align_to = 'full')
}

# Just as expected insets are still amenable to changes after the fact
p1 +
  inset_element(p2, 0.6, 0.6, 1, 1) +
  theme_classic()

# Tagging also continues to work as expected
p1 +
  inset_element(p2, 0.6, 0.6, 1, 1) +
  plot_annotation(tag_levels = '1')

# but can be turned off, like for wrapped plots
p1 +
  inset_element(p2, 0.6, 0.6, 1, 1, ignore_tag = TRUE) +
  plot_annotation(tag_levels = '1')

</code></pre>

<hr>
<h2 id='multipage_align'>Align plots across multiple pages</h2><span id='topic+multipage_align'></span><span id='topic+get_dim'></span><span id='topic+set_dim'></span><span id='topic+get_max_dim'></span><span id='topic+align_patches'></span>

<h3>Description</h3>

<p>Sometimes it is necessary to make sure that separate plots are aligned, with
each other, but still exists as separate plots. That could e.g. be if they
need to be part of a slideshow and you don't want titles and panels jumping
around as you switch between slides. patchwork provides a range of utilities
to achieve that. Currently it is only possible to align ggplots, but aligning
patchworks will be supported in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dim(plot)

set_dim(plot, dim)

get_max_dim(...)

align_patches(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multipage_align_+3A_plot">plot</code></td>
<td>
<p>A ggplot object</p>
</td></tr>
<tr><td><code id="multipage_align_+3A_dim">dim</code></td>
<td>
<p>A plot_dimension object as created by <code>get_dim()</code></p>
</td></tr>
<tr><td><code id="multipage_align_+3A_...">...</code></td>
<td>
<p>ggplot objects or a single list of them</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_dim()</code> and <code>get_max_dim()</code> return a plot_dimension object.
<code>set_dim()</code> returns a modified ggplot object with fixed outer dimensions and
<code>align_patches()</code> return a list of such. The modified ggplots still behaves
like a standard ggplot and new layers, scales, etc can be added to them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
p1 &lt;- ggplot(mtcars) +
  geom_point(aes(mpg, disp)) +
  ggtitle('Plot 1')

p2 &lt;- ggplot(mtcars) +
  geom_boxplot(aes(gear, disp, group = gear)) +
  ggtitle('Plot 2')

p3 &lt;- ggplot(mtcars) +
  geom_point(aes(hp, wt, colour = mpg)) +
  ggtitle('Plot 3')

p4 &lt;- ggplot(mtcars) +
  geom_bar(aes(gear)) +
  facet_wrap(~cyl) +
  ggtitle('Plot 4')

# Align a plot to p4
p4_dim &lt;- get_dim(p4)
set_dim(p1, p4_dim)

# Align a plot to the maximum dimensions of a list of plots
max_dims &lt;- get_max_dim(p1, p2, p3, p4)
set_dim(p2, max_dims)

# Align a list of plots with each other
aligned_plots &lt;- align_patches(p1, p2, p3, p4)
aligned_plots[[3]]

# Aligned plots still behave like regular ggplots
aligned_plots[[3]] + theme_bw()

</code></pre>

<hr>
<h2 id='patchGrob'>Get a grob describing the content of a patch object</h2><span id='topic+patchGrob'></span>

<h3>Description</h3>

<p>Methods for this generic should be defined for all <code>patch</code> subclasses
and should return a compliant <code>gtable</code> object ready to be combined with
regular plot objects. In general it is best to call <code>patch_table()</code> on the
object and add grobs to this as <code>patch_table()</code> will return a compliant
<code>gtable</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchGrob(x, guides = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchGrob_+3A_x">x</code></td>
<td>
<p>An <code>patch</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gtable</code> object
</p>

<hr>
<h2 id='patchworkGrob'>Convert a patchwork to a gtable</h2><span id='topic+patchworkGrob'></span>

<h3>Description</h3>

<p>This function is the patchwork analogue of <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code> in that it
takes an unevaluated patchwork object and fixate it into a gtable object to
further manipulate directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchworkGrob(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patchworkGrob_+3A_x">x</code></td>
<td>
<p>A <code>patchwork</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gtable</code> object
</p>

<hr>
<h2 id='plot_annotation'>Annotate the final patchwork</h2><span id='topic+plot_annotation'></span>

<h3>Description</h3>

<p>The result of this function can be added to a patchwork using <code>+</code> in the same
way as <code><a href="#topic+plot_layout">plot_layout()</a></code>, but unlike <code><a href="#topic+plot_layout">plot_layout()</a></code> it will only have an
effect on the top level plot. As the name suggests it controls different
aspects of the annotation of the final plot, such as titles and tags. Already
added annotations can be removed by setting the relevant argument to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_annotation(
  title = waiver(),
  subtitle = waiver(),
  caption = waiver(),
  tag_levels = waiver(),
  tag_prefix = waiver(),
  tag_suffix = waiver(),
  tag_sep = waiver(),
  theme = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_annotation_+3A_title">title</code>, <code id="plot_annotation_+3A_subtitle">subtitle</code>, <code id="plot_annotation_+3A_caption">caption</code></td>
<td>
<p>Text strings to use for the various plot
annotations.</p>
</td></tr>
<tr><td><code id="plot_annotation_+3A_tag_levels">tag_levels</code></td>
<td>
<p>A character vector defining the enumeration format to use
at each level. Possible values are <code>'a'</code> for lowercase letters, <code>'A'</code> for
uppercase letters, <code>'1'</code> for numbers, <code>'i'</code> for lowercase Roman numerals, and
<code>'I'</code> for uppercase Roman numerals. It can also be a list containing
character vectors defining arbitrary tag sequences. If any element in the
list is a scalar and one of <code>'a'</code>, <code>'A'</code>, <code>'1'</code>, <code style="white-space: pre;">&#8288;'i&#8288;</code>, or <code>'I'</code>, this level
will be expanded to the expected sequence.</p>
</td></tr>
<tr><td><code id="plot_annotation_+3A_tag_prefix">tag_prefix</code>, <code id="plot_annotation_+3A_tag_suffix">tag_suffix</code></td>
<td>
<p>Strings that should appear before or after the
tag.</p>
</td></tr>
<tr><td><code id="plot_annotation_+3A_tag_sep">tag_sep</code></td>
<td>
<p>A separator between different tag levels</p>
</td></tr>
<tr><td><code id="plot_annotation_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme specification to use for the plot. Only elements
related to the titles as well as plot margin and background is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tagging of subplots is done automatically and following the order of the
plots as they are added. When the plot contains nested layouts the
<code>tag_level</code> argument in the nested <a href="#topic+plot_layout">plot_layout</a> will define whether
enumeration should continue as usual or add a new level. The format of the
levels are defined with <code>tag_levels</code> argument in <code>plot_annotation</code>
</p>


<h3>Value</h3>

<p>A <code>plot_annotation</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)

# Add title, etc. to a patchwork
p1 + p2 + plot_annotation('This is a title', caption = 'made with patchwork')

# Change styling of patchwork elements
p1 + p2 +
  plot_annotation(
    title = 'This is a title',
    caption = 'made with patchwork',
    theme = theme(plot.title = element_text(size = 16))
  )

# Add tags to plots
p1 / (p2 | p3) +
  plot_annotation(tag_levels = 'A')

# Add multilevel tagging to nested layouts
p1 / ((p2 | p3) + plot_layout(tag_level = 'new')) +
  plot_annotation(tag_levels = c('A', '1'))

# Use a custom tag sequence (mixed with a standard one)
p1 / ((p2 | p3) + plot_layout(tag_level = 'new')) +
  plot_annotation(tag_levels = list(c('&amp;', '%'), '1'))

</code></pre>

<hr>
<h2 id='plot_arithmetic'>Plot arithmetic</h2><span id='topic+plot_arithmetic'></span><span id='topic+-.ggplot'></span><span id='topic++2F.ggplot'></span><span id='topic++7C.ggplot'></span><span id='topic++2A.gg'></span><span id='topic++26.gg'></span>

<h3>Description</h3>

<p>In addition to the <code>+</code> operator known in <code>ggplot2</code>, <code>patchwork</code> defines logic
for some of the other operators that aids in building up your plot
composition and reduce code-reuse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplot'
e1 - e2

## S3 method for class 'ggplot'
e1 / e2

## S3 method for class 'ggplot'
e1 | e2

## S3 method for class 'gg'
e1 * e2

## S3 method for class 'gg'
e1 &amp; e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_arithmetic_+3A_e1">e1</code></td>
<td>
<p>A <code>ggplot</code> or <code>patchwork</code> object</p>
</td></tr>
<tr><td><code id="plot_arithmetic_+3A_e2">e2</code></td>
<td>
<p>A <code>ggplot</code> or <code>patchwork</code> object in case of <code>/</code>, or a <code>gg</code> object
such as a geom or theme specification in case of <code>*</code> and <code>&amp;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>patchwork</code> augment the <code>+</code> operator from <code>ggplot2</code> and allows the user to
add full <code>ggplot</code> objects together in order to compose them into the same
view. The last added plot is always the active one where new geoms etc. are
added to. Another operator that is much like it, but not quite, is <code>-</code>. It
also adds plots together but instead of adding the right hand side to the
patchwork defined in the left hand side, it puts the left hand side besides
the right hand side in a patchwork. This might sound confusing, but in
essence <code>-</code> ensures that the right and left side are put in the same nesting
level (<code>+</code> puts the right side <em>into</em> the left side). Using <code>-</code> might seem
unintuitive if you think of the operator as &quot;subtract&quot;, but look at it as a
hyphen instead (the underlying reason is that <code>-</code> is the only operator in the
same precedence group as <code>+</code>). An alternative and more explicit way to get
the same effect as <code>-</code> is to use <code>merge()</code> on the left hand side.
</p>
<p>Often you are interested in creating single column or single row layouts.
<code>patchwork</code> provides <code>|</code> (besides) and <code>/</code> (over) operators to support
stacking and packing of plots. See the examples for their use.
</p>
<p>In order to reduce code repetition <code>patchwork</code> provides two operators for
adding ggplot elements (geoms, themes, facets, etc.) to multiple/all plots in
a patchwork. <code>*</code> will add the element to all plots in the current nesting
level, while <code>&amp;</code> will recurse into nested patches.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)
p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb))

# Standard addition vs division
p1 + p2 + p3 + plot_layout(ncol = 1)
p1 + p2 - p3 + plot_layout(ncol = 1)

# Stacking and packing
(p1 | p2 | p3) /
      p4

# Add elements to the same nesting level
(p1 + (p2 + p3) + p4 + plot_layout(ncol = 1)) * theme_bw()

# Recurse into nested plots as well
(p1 + (p2 + p3) + p4 + plot_layout(ncol = 1)) &amp; theme_bw()

</code></pre>

<hr>
<h2 id='plot_layout'>Define the grid to compose plots in</h2><span id='topic+plot_layout'></span>

<h3>Description</h3>

<p>To control how different plots are laid out, you need to add a
layout specification. If you are nesting grids, the layout is scoped to the
current nesting level. An already set value can be removed by setting it to
<code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_layout(
  ncol = waiver(),
  nrow = waiver(),
  byrow = waiver(),
  widths = waiver(),
  heights = waiver(),
  guides = waiver(),
  tag_level = waiver(),
  design = waiver(),
  axes = waiver(),
  axis_titles = axes
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_layout_+3A_ncol">ncol</code>, <code id="plot_layout_+3A_nrow">nrow</code></td>
<td>
<p>The dimensions of the grid to create - if both are <code>NULL</code> it
will use the same logic as <a href="ggplot2.html#topic+facet_wrap">facet_wrap()</a> to set the
dimensions</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_byrow">byrow</code></td>
<td>
<p>Analogous to <code>byrow</code> in <a href="base.html#topic+matrix">matrix()</a>. If <code>FALSE</code> the
plots will be filled in in column-major order</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_widths">widths</code>, <code id="plot_layout_+3A_heights">heights</code></td>
<td>
<p>The relative widths and heights of each column and row
in the grid. Will get repeated to match the dimensions of the grid. The
special value of <code>NA</code>/<code style="white-space: pre;">&#8288;-1null&#8288;</code> will behave as <code style="white-space: pre;">&#8288;1null&#8288;</code> unless a fixed aspect
plot is inserted in which case it will allow the dimension to expand or
contract to match the aspect ratio of the content</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_guides">guides</code></td>
<td>
<p>A string specifying how guides should be treated in the layout.
<code>'collect'</code> will collect guides below to the given nesting level, removing
duplicates. <code>'keep'</code> will stop collection at this level and let guides be
placed alongside their plot. <code>auto</code> will allow guides to be collected if a
upper level tries, but place them alongside the plot if not.  If you modify
default guide &quot;position&quot; with <a href="ggplot2.html#topic+theme">theme(legend.position=...)</a>
while also collecting guides you must apply that change to the overall
patchwork (see example).</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_tag_level">tag_level</code></td>
<td>
<p>A string (<code>'keep'</code> or <code>'new'</code>) to indicate how
auto-tagging should behave. See <code><a href="#topic+plot_annotation">plot_annotation()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_design">design</code></td>
<td>
<p>Specification of the location of areas in the layout. Can either
be specified as a text string or by concatenating calls to <code><a href="#topic+area">area()</a></code> together.
See the examples for further information on use.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_axes">axes</code></td>
<td>
<p>A string specifying how axes should be treated. <code>'keep'</code> will
retain all axes in individual plots. <code>'collect'</code> will remove duplicated
axes when placed in the same run of rows or columns of the layout.
<code>'collect_x'</code> and <code>'collect_y'</code> will remove duplicated x-axes in the columns
or duplicated y-axes in the rows respectively.</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_axis_titles">axis_titles</code></td>
<td>
<p>A string specifying how axis titltes should be treated.
<code>'keep'</code> will retain all axis titles in individual plots. <code>'collect'</code> will
remove duplicated titles in one direction and merge titles in the opposite
direction. <code>'collect_x'</code> and <code>'collect_y'</code> control this for x-axis titles
and y-axis titles respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>plot_layout</code> object to be added to a <code>ggassmble</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)
p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb))
p5 &lt;- ggplot(mtcars) + geom_violin(aes(cyl, mpg, group = cyl))

# The plots are layed out automatically by default
p1 + p2 + p3 + p4 + p5

# Use byrow to change how the grid is filled out
p1 + p2 + p3 + p4 + p5 + plot_layout(byrow = FALSE)

# Change the grid dimensions
p1 + p2 + p3 + p4 + p5 + plot_layout(ncol = 2, widths = c(1, 2))

# Define layout at different nesting levels
p1 +
  p2 +
  (p3 +
     p4 +
     plot_layout(ncol = 1)
  ) +
  p5 +
  plot_layout(widths = c(2, 1))

# Complex layouts can be created with the `design` argument
design &lt;- c(
  area(1, 1, 2),
  area(1, 2, 1, 3),
  area(2, 3, 3),
  area(3, 1, 3, 2),
  area(2, 2)
)
p1 + p2 + p3 + p4 + p5 + plot_layout(design = design)


# The same can be specified as a character string:
design &lt;- "
  122
  153
  443
"
p1 + p2 + p3 + p4 + p5 + plot_layout(design = design)

# When using strings to define the design `#` can be used to denote empty
# areas
design &lt;- "
  1##
  123
  ##3
"
p1 + p2 + p3 + plot_layout(design = design)

# Use guides="collect" to remove duplicate guides
p6 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp, color=cyl))
p7 &lt;- ggplot(mtcars) + geom_point(aes(mpg, hp, color=cyl))
p6 + p7 + plot_layout(guides='collect')

# Guide position must be applied to entire patchwork
p6 + p7 + plot_layout(guides='collect') &amp;
  theme(legend.position='bottom')
</code></pre>

<hr>
<h2 id='plot_spacer'>Add a completely blank area</h2><span id='topic+plot_spacer'></span>

<h3>Description</h3>

<p>This simple wrapper creates an empty transparent patch that can be added to
push your other plots apart. The patch responds to adding
<a href="ggplot2.html#topic+theme">theme()</a> specifications, but only <code>plot.background</code> will
have an effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spacer()
</code></pre>


<h3>Value</h3>

<p>A <code>ggplot</code> object containing an empty plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))

p1 + plot_spacer() + p2


# To have more control over spacing, you can use the `plot.margin`
# parameter for `theme()` on each individual plot.

(p1 + theme(plot.margin = unit(c(0,30,0,0), "pt"))) +
(p2 + theme(plot.margin = unit(c(0,0,0,30), "pt")))

</code></pre>

<hr>
<h2 id='wrap_elements'>Wrap arbitrary graphics in a patchwork-compliant patch</h2><span id='topic+wrap_elements'></span>

<h3>Description</h3>

<p>In order to add non-ggplot2 element to a patchwork they can be
converted to a compliant representation using the <code>wrap_elements()</code> function.
This allows you to position either grobs, ggplot objects, patchwork
objects, or even base graphics (if passed as a formula) in either the full
area, the full plotting area (anything between and
including the axis label), or the panel area (only the actual area where data
is drawn). Further you can still add title, subtitle, tag, and caption using
the same approach as with normal ggplots (using
<a href="ggplot2.html#topic+labs">ggtitle()</a> and <a href="ggplot2.html#topic+labs">labs()</a>) as well as styling
using <a href="ggplot2.html#topic+theme">theme()</a>. For the latter, only the theme elements
targeting plot margins and background as well as title, subtitle, etc styling
will have an effect. If a patchwork or ggplot object is wrapped, it will be
fixated in its state and will no longer respond to addition of styling,
geoms, etc.. When grobs and formulas are added directly, they will implicitly
be converted to <code>wrap_elements(full = x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_elements(
  panel = NULL,
  plot = NULL,
  full = NULL,
  clip = TRUE,
  ignore_tag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_elements_+3A_panel">panel</code>, <code id="wrap_elements_+3A_plot">plot</code>, <code id="wrap_elements_+3A_full">full</code></td>
<td>
<p>A grob, ggplot, patchwork, formula, raster,
nativeRaster, or gt object to add to the respective area.</p>
</td></tr>
<tr><td><code id="wrap_elements_+3A_clip">clip</code></td>
<td>
<p>Should the grobs be clipped if expanding outside its area</p>
</td></tr>
<tr><td><code id="wrap_elements_+3A_ignore_tag">ignore_tag</code></td>
<td>
<p>Should tags be ignored for this patch. This is relevant
when using automatic tagging of plots and the content of the patch does not
qualify for a tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wrapped_patch object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(grid)

# Combine grobs with each other
wrap_elements(panel = textGrob('Here are some text')) +
  wrap_elements(
    panel = rectGrob(gp = gpar(fill = 'steelblue')),
    full = rectGrob(gp = gpar(fill = 'goldenrod'))
  )

# wrapped elements can still get titles etc like ggplots
wrap_elements(panel = textGrob('Here are some text')) +
  wrap_elements(
    panel = rectGrob(gp = gpar(fill = 'steelblue')),
    full = rectGrob(gp = gpar(fill = 'goldenrod'))
  ) +
  ggtitle('Title for the amazing rectangles')

# You can also pass in ggplots or patchworks to e.g. have it fill out the
# panel area
p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p1 + wrap_elements(panel = p1 + ggtitle('Look at me shrink'))

# You can even add base graphics if you pass it as a formula (requires gridGraphics package)
if (requireNamespace("gridGraphics", quietly = TRUE)) {
  p1 + wrap_elements(full = ~ plot(mtcars$mpg, mtcars$disp))

  # Adding a grob or formula directly is equivalent to placing it in `full`
  p1 + ~ plot(mtcars$mpg, mtcars$disp)
}

</code></pre>

<hr>
<h2 id='wrap_ggplot_grob'>Make a gtable created from a ggplot object patchwork compliant</h2><span id='topic+wrap_ggplot_grob'></span>

<h3>Description</h3>

<p>This function converts a gtable, as produced by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code> and
makes it ready to be added to a patchwork. In contrast to passing
the gtable to <code><a href="#topic+wrap_elements">wrap_elements()</a></code>, <code>wrap_ggplot_grob()</code> ensures proper
alignment as expected. On the other hand major restructuring of the gtable
will result in an object that doesn't work properly with
<code>wrap_ggplot_grob()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_ggplot_grob(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_ggplot_grob_+3A_x">x</code></td>
<td>
<p>A gtable as produced by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>table_patch</code> object to be added to a patchwork
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)
library(gtable)
library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp)) + ggtitle('disp and mpg seems connected')
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))

# Convert p2 so we can add new stuff to it
p2_table &lt;- ggplotGrob(p2)
stamp &lt;- textGrob('TOP SECRET', rot = 35,
  gp = gpar(fontsize = 72, fontface = 'bold')
)
p2_table &lt;- gtable_add_grob(p2_table, stamp,
  t = 1, l = 1, b = nrow(p2_table), r = ncol(p2_table)
)

# Adding it directly will loose alignment
p1 + p2_table

# Use wrap_ggplot_grob to keep alignment
p1 + wrap_ggplot_grob(p2_table)

</code></pre>

<hr>
<h2 id='wrap_plots'>Wrap plots into a patchwork</h2><span id='topic+wrap_plots'></span>

<h3>Description</h3>

<p>While the use of <code>+</code> is a natural way to add plots together, it can be
difficult to string together multiple plots programmatically if the number
of plots is not known beforehand. <code>wrap_plots</code> makes it easy to take a list
of plots and add them into one composition, along with layout specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_plots(
  ...,
  ncol = NULL,
  nrow = NULL,
  byrow = NULL,
  widths = NULL,
  heights = NULL,
  guides = NULL,
  tag_level = NULL,
  design = NULL,
  axes = NULL,
  axis_titles = axes
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_plots_+3A_...">...</code></td>
<td>
<p>multiple <code>ggplot</code>s or a list containing <code>ggplot</code> objects</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_ncol">ncol</code>, <code id="wrap_plots_+3A_nrow">nrow</code></td>
<td>
<p>The dimensions of the grid to create - if both are <code>NULL</code> it
will use the same logic as <a href="ggplot2.html#topic+facet_wrap">facet_wrap()</a> to set the
dimensions</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_byrow">byrow</code></td>
<td>
<p>Analogous to <code>byrow</code> in <a href="base.html#topic+matrix">matrix()</a>. If <code>FALSE</code> the
plots will be filled in in column-major order</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_widths">widths</code>, <code id="wrap_plots_+3A_heights">heights</code></td>
<td>
<p>The relative widths and heights of each column and row
in the grid. Will get repeated to match the dimensions of the grid. The
special value of <code>NA</code>/<code style="white-space: pre;">&#8288;-1null&#8288;</code> will behave as <code style="white-space: pre;">&#8288;1null&#8288;</code> unless a fixed aspect
plot is inserted in which case it will allow the dimension to expand or
contract to match the aspect ratio of the content</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_guides">guides</code></td>
<td>
<p>A string specifying how guides should be treated in the layout.
<code>'collect'</code> will collect guides below to the given nesting level, removing
duplicates. <code>'keep'</code> will stop collection at this level and let guides be
placed alongside their plot. <code>auto</code> will allow guides to be collected if a
upper level tries, but place them alongside the plot if not.  If you modify
default guide &quot;position&quot; with <a href="ggplot2.html#topic+theme">theme(legend.position=...)</a>
while also collecting guides you must apply that change to the overall
patchwork (see example).</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_tag_level">tag_level</code></td>
<td>
<p>A string (<code>'keep'</code> or <code>'new'</code>) to indicate how
auto-tagging should behave. See <code><a href="#topic+plot_annotation">plot_annotation()</a></code>.</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_design">design</code></td>
<td>
<p>Specification of the location of areas in the layout. Can either
be specified as a text string or by concatenating calls to <code><a href="#topic+area">area()</a></code> together.
See the examples for further information on use.</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_axes">axes</code></td>
<td>
<p>A string specifying how axes should be treated. <code>'keep'</code> will
retain all axes in individual plots. <code>'collect'</code> will remove duplicated
axes when placed in the same run of rows or columns of the layout.
<code>'collect_x'</code> and <code>'collect_y'</code> will remove duplicated x-axes in the columns
or duplicated y-axes in the rows respectively.</p>
</td></tr>
<tr><td><code id="wrap_plots_+3A_axis_titles">axis_titles</code></td>
<td>
<p>A string specifying how axis titltes should be treated.
<code>'keep'</code> will retain all axis titles in individual plots. <code>'collect'</code> will
remove duplicated titles in one direction and merge titles in the opposite
direction. <code>'collect_x'</code> and <code>'collect_y'</code> control this for x-axis titles
and y-axis titles respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>design</code> is specified as a text string <em>and</em> the plots are named (e.g.
<code>wrap_plots(A = p1, ...)</code>) <em>and</em> all plot names are single characters
represented in the design layout string, the plots will be matched to their
respective area by name. Otherwise the areas will be filled out
sequentially in the same manner as using the <code>+</code> operator. See the examples
for more.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))
p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))
p3 &lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)
p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb))
p5 &lt;- ggplot(mtcars) + geom_violin(aes(cyl, mpg, group = cyl))

# Either add the plots as single arguments
wrap_plots(p1, p2, p3, p4, p5)

# Or add them as a list...
plots &lt;- list(p1, p2, p3, p4, p5)
wrap_plots(plots)

# Match plots to areas by name
design &lt;- "#BB
           AA#"
wrap_plots(B = p1, A = p2, design = design)

# Compare to not using named plot arguments
wrap_plots(p1, p2, design = design)

</code></pre>

<hr>
<h2 id='wrap_table'>Wrap a table in a patchwork compliant patch</h2><span id='topic+wrap_table'></span>

<h3>Description</h3>

<p>This function works much like <code><a href="#topic+wrap_elements">wrap_elements()</a></code> in that it turns the input
into patchwork compliant objects that can be added to a composition. However,
<code>wrap_table()</code> uses the knowledge that the input is a table to provide some
very nifty layout options that makes it generally better to use than
<code><a href="#topic+wrap_elements">wrap_elements()</a></code> for this type of object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_table(
  table,
  panel = c("body", "full", "rows", "cols"),
  space = c("free", "free_x", "free_y", "fixed"),
  ignore_tag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_table_+3A_table">table</code></td>
<td>
<p>A gt table or an object coercible to a data frame</p>
</td></tr>
<tr><td><code id="wrap_table_+3A_panel">panel</code></td>
<td>
<p>what portion of the table should be aligned with the panel
region? <code>"body"</code> means that any column and row headers will be placed outside
the panel region, i.e. the topleft corner of the panel region will be aligned
with the topleft data cell. <code>"full"</code> means that the whole table will be
placed inside the panel region. <code>"rows"</code> means that all rows (including column
headers) will be placed inside the panel region but row headers will be
placed to the left. <code>"cols"</code> is the opposite, placing all columns within the
panel region but keeping the column header on top of it. If this is set to
<code>"body"</code> or <code>"cols"</code> and <code>space</code> is set to <code>"fixed"</code> or <code>"free_x"</code> then any
footnotes or source notes in the table will be placed outside the bottom of
the panel region.</p>
</td></tr>
<tr><td><code id="wrap_table_+3A_space">space</code></td>
<td>
<p>How should the dimension of the table influence the final
composition? <code>"fixed"</code> means that the table width will set the width of the
column it occupies and the table height will set the height of the row it
occupies. <code>"free"</code> is the opposite meaning that the table dimension will not
have any influence on the sizing. <code>"free_x"</code> and <code>"free_y"</code> allows you to
free either direction while keeping the remaining fixed. Do note that if you
set a specific width or height in <code><a href="#topic+plot_layout">plot_layout()</a></code> it will have higher
priority than the table dimensions</p>
</td></tr>
<tr><td><code id="wrap_table_+3A_ignore_tag">ignore_tag</code></td>
<td>
<p>Should tags be ignored for this patch. This is relevant
when using automatic tagging of plots and the content of the patch does not
qualify for a tag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wrapped_table object
</p>


<h3>Note</h3>

<p>This functionality requires v0.11.0 or higher of the gt package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
library(gt)

p1 &lt;- ggplot(airquality) +
  geom_line(aes(x = Day, y = Temp, colour = month.name[Month])) +
  labs(colour = "Month")

table &lt;- data.frame(
  Month = month.name[5:9],
  "Mean temp." = tapply(airquality$Temp, airquality$Month, mean),
  "Min temp." = tapply(airquality$Temp, airquality$Month, min),
  "Max temp." = tapply(airquality$Temp, airquality$Month, max)
)
gt_tab &lt;- gt(table, rowname_col = "Month")

# Default addition usees wrap_table
p1 + gt_tab

# Default places column and row headers outside panel area. Use wrap_table
# to control this
p1 + wrap_table(gt_tab, panel = "full")

# Tables generally have fixed dimensions and these can be used to control
# the size of the area they occupy
p2 &lt;- ggplot(airquality) +
  geom_boxplot(aes(y = month.name[Month], x = Temp)) +
  scale_y_discrete(name = NULL, limits = month.name[9:5], guide = "none")

wrap_table(gt_tab, space = "fixed") + p2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
