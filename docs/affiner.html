<!DOCTYPE html><html lang="en"><head><title>Help for package affiner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {affiner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#affiner-package'><p>affiner: A Finer Way to Render 3D Illustrated Objects in 'grid' Using Affine Transformations</p></a></li>
<li><a href='#abs.Coord1D'><p>Compute Euclidean norm</p></a></li>
<li><a href='#affine_settings'><p>Compute <code>grid</code> affine transformation feature viewports and transformation functions</p></a></li>
<li><a href='#affineGrob'><p>Affine transformation grob</p></a></li>
<li><a href='#affiner_options'><p>Get affiner options</p></a></li>
<li><a href='#angle'><p>Angle vectors</p></a></li>
<li><a href='#angle-methods'><p>Implemented base methods for angle vectors</p></a></li>
<li><a href='#angular_unit'><p>Get/set angular unit of angle vectors</p></a></li>
<li><a href='#as_angle'><p>Cast to angle vector</p></a></li>
<li><a href='#as_coord1d'><p>Cast to coord1d object</p></a></li>
<li><a href='#as_coord2d'><p>Cast to coord2d object</p></a></li>
<li><a href='#as_coord3d'><p>Cast to coord3d object</p></a></li>
<li><a href='#as_line2d'><p>Cast to Line2D object</p></a></li>
<li><a href='#as_plane3d'><p>Cast to Plane3D object</p></a></li>
<li><a href='#as_point1d'><p>Cast to Point1D object</p></a></li>
<li><a href='#as_transform1d'><p>Cast to 1D affine transformation matrix</p></a></li>
<li><a href='#as_transform2d'><p>Cast to 2D affine transformation matrix</p></a></li>
<li><a href='#as_transform3d'><p>Cast to 3D affine transformation matrix</p></a></li>
<li><a href='#bounding_ranges'><p>Compute axis-aligned ranges</p></a></li>
<li><a href='#centroid'><p>Compute centroids of coordinates</p></a></li>
<li><a href='#convex_hull2d'><p>Compute 2D convex hulls</p></a></li>
<li><a href='#Coord1D'><p>1D coordinate vector R6 Class</p></a></li>
<li><a href='#Coord2D'><p>2D coordinate vector R6 Class</p></a></li>
<li><a href='#Coord3D'><p>3D coordinate vector R6 Class</p></a></li>
<li><a href='#cross_product3d'><p>Compute 3D vector cross product</p></a></li>
<li><a href='#distance1d'><p>1D Euclidean distances</p></a></li>
<li><a href='#distance2d'><p>2D Euclidean distances</p></a></li>
<li><a href='#distance3d'><p>3D Euclidean distances</p></a></li>
<li><a href='#graphics'><p>Plot coordinates, points, lines, and planes</p></a></li>
<li><a href='#inverse-trigonometric-functions'><p>Angle vector aware inverse trigonometric functions</p></a></li>
<li><a href='#is_angle'><p>Test whether an object is an angle vector</p></a></li>
<li><a href='#is_congruent'><p>Test whether two objects are congruent</p></a></li>
<li><a href='#is_coord1d'><p>Test whether an object has a Coord1D class</p></a></li>
<li><a href='#is_coord2d'><p>Test whether an object has a Coord2D class</p></a></li>
<li><a href='#is_coord3d'><p>Test whether an object has a Coord3D class</p></a></li>
<li><a href='#is_line2d'><p>Test whether an object has a Line2D class</p></a></li>
<li><a href='#is_plane3d'><p>Test whether an object has a Plane3D class</p></a></li>
<li><a href='#is_point1d'><p>Test whether an object has a Point1D class</p></a></li>
<li><a href='#is_transform1d'><p>Test if 1D affine transformation matrix</p></a></li>
<li><a href='#is_transform2d'><p>Test if 2D affine transformation matrix</p></a></li>
<li><a href='#is_transform3d'><p>Test if 3D affine transformation matrix</p></a></li>
<li><a href='#isocubeGrob'><p>Isometric cube grob</p></a></li>
<li><a href='#Line2D'><p>2D lines R6 Class</p></a></li>
<li><a href='#normal2d'><p>2D normal vectors</p></a></li>
<li><a href='#normal3d'><p>3D normal vectors</p></a></li>
<li><a href='#Plane3D'><p>3D planes R6 Class</p></a></li>
<li><a href='#Point1D'><p>1D points R6 Class</p></a></li>
<li><a href='#rotate3d_to_AA'><p>Convert from 3D rotation matrix to axis-angle representation.</p></a></li>
<li><a href='#transform1d'><p>1D affine transformation matrices</p></a></li>
<li><a href='#transform2d'><p>2D affine transformation matrices</p></a></li>
<li><a href='#transform3d'><p>3D affine transformation matrices</p></a></li>
<li><a href='#trigonometric-functions'><p>Angle vector aware trigonometric functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Finer Way to Render 3D Illustrated Objects in 'grid' Using
Affine Transformations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Dilate, permute, project, reflect, rotate, shear, and translate 2D and 3D points.  Supports parallel projections including oblique projections such as the cabinet projection as well as axonometric projections such as the isometric projection.  Use 'grid's "affine transformation" feature to render illustrated flat surfaces.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/R/affiner/">https://trevorldavis.com/R/affiner/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trevorld/affiner/issues">https://github.com/trevorld/affiner/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, grid, R6, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>aRtsy, ggplot2, gridpattern, gtable, knitr, ragg (&ge; 1.3.3),
rgl, rlang, rmarkdown, stats, testthat (&ge; 3.0.0), vdiffr,
withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, ragg, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-02 06:12:41 UTC; trevorld</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L. Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L. Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='affiner-package'>affiner: A Finer Way to Render 3D Illustrated Objects in 'grid' Using Affine Transformations</h2><span id='topic+affiner'></span><span id='topic+affiner-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Dilate, permute, project, reflect, rotate, shear, and translate 2D and 3D points. Supports parallel projections including oblique projections such as the cabinet projection as well as axonometric projections such as the isometric projection. Use 'grid's &quot;affine transformation&quot; feature to render illustrated flat surfaces.
</p>


<h3>Package options</h3>

<p>The following affiner function arguments may be set globally via <code><a href="base.html#topic+options">base::options()</a></code>:
</p>

<dl>
<dt>affiner_angular_unit</dt><dd><p>The default for the <code>unit</code> argument used by <code><a href="#topic+angle">angle()</a></code> and <code><a href="#topic+as_angle">as_angle()</a></code>.
The default for this option is &quot;degrees&quot;.</p>
</dd>
<dt>affiner_grid_unit</dt><dd><p>The default for the <code>unit</code> argument used by <code><a href="#topic+affine_settings">affine_settings()</a></code>.
The default for this option is &quot;inches&quot;.</p>
</dd>
</dl>

<p>The following <code>cli</code> options may also be of interest:
</p>

<dl>
<dt>cli.unicode</dt><dd><p>Whether UTF-8 character support should be assumed.
Along with <code><a href="base.html#topic+l10n_info">l10n_info()</a></code> used to determine the default of the
<code>use_unicode</code> argument of <code><a href="#topic+format.angle">format.angle()</a></code> and <code><a href="#topic+print.angle">print.angle()</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Trevor L. Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> (<a href="https://orcid.org/0000-0001-6341-4639">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://trevorldavis.com/R/affiner/">https://trevorldavis.com/R/affiner/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/trevorld/affiner/issues">https://github.com/trevorld/affiner/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abs.Coord1D'>Compute Euclidean norm</h2><span id='topic+abs.Coord1D'></span><span id='topic+abs.Coord2D'></span><span id='topic+abs.Coord3D'></span>

<h3>Description</h3>

<p><code>abs()</code> computes the Euclidean norm for <a href="#topic+Coord2D">Coord2D</a> class objects and <a href="#topic+Coord3D">Coord3D</a> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Coord1D'
abs(x)

## S3 method for class 'Coord2D'
abs(x)

## S3 method for class 'Coord3D'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs.Coord1D_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord2D">Coord2D</a> class object or <a href="#topic+Coord2D">Coord2D</a> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z &lt;- complex(real = 1:4, imaginary = 1:4)
  p &lt;- as_coord2d(z)
  abs(p) # Euclidean norm
  # Less efficient ways to calculate same Euclidean norms
  sqrt(p * p) # `*` dot product
  distance2d(p, as_coord2d(0, 0, 0))

  # In {base} R `abs()` calculates Euclidean norm of complex numbers
  all.equal(abs(p), abs(z))
  all.equal(Mod(p), Mod(z))

  p3 &lt;- as_coord3d(x = 1:4, y = 1:4, z = 1:4)
  abs(p3)
</code></pre>

<hr>
<h2 id='affine_settings'>Compute <code>grid</code> affine transformation feature viewports and transformation functions</h2><span id='topic+affine_settings'></span>

<h3>Description</h3>

<p><code>affine_settings()</code> computes <code>grid</code> group affine transformation feature viewport and transformation
function settings given the (x,y) coordinates of the corners of the
affine transformed &quot;viewport&quot; one wishes to draw in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affine_settings(
  xy = data.frame(x = c(0, 0, 1, 1), y = c(1, 0, 0, 1)),
  unit = getOption("affiner_grid_unit", "inches")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affine_settings_+3A_xy">xy</code></td>
<td>
<p>An R object with named elements <code>x</code> and <code>y</code> representing the (x,y) coordinates
of the affine transformed &quot;viewport&quot; one wishes to draw in.
The (x,y) coordinates of the &quot;viewport&quot; should be in
&quot;upper left&quot;, &quot;lower left&quot;, &quot;lower right&quot;, and &quot;upper right&quot; order
(this ordering should be from the perspective of <strong>before</strong>
the &quot;affine transformation&quot; of the &quot;viewport&quot;).</p>
</td></tr>
<tr><td><code id="affine_settings_+3A_unit">unit</code></td>
<td>
<p>Which <code><a href="grid.html#topic+unit">grid::unit()</a></code> to assume the <code>xy</code> &quot;x&quot; and &quot;y&quot; coordinates are expressed in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following group affine transformation feature viewport
and functions settings:</p>

<dl>
<dt>transform</dt><dd><p>An affine transformation function to pass to <code><a href="#topic+affineGrob">affineGrob()</a></code> or <code><a href="grid.html#topic+useGrob">useGrob()</a></code>.
If <code>getRversion()</code> is less than <code>"4.2.0"</code> will instead be <code>NULL</code>.</p>
</dd>
<dt>vp</dt><dd><p>A <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> object to pass to <code><a href="#topic+affineGrob">affineGrob()</a></code> or <code><a href="grid.html#topic+useGrob">useGrob()</a></code>.</p>
</dd>
<dt>sx</dt><dd><p>x-axis sx factor</p>
</dd>
<dt>flipX</dt><dd><p>whether the affine transformed &quot;viewport&quot; is &quot;flipped&quot; horizontally</p>
</dd>
<dt>x</dt><dd><p>x-coordinate for viewport</p>
</dd>
<dt>y</dt><dd><p>y-coordinate for viewport</p>
</dd>
<dt>width</dt><dd><p>Width of viewport</p>
</dd>
<dt>height</dt><dd><p>Height of viewport</p>
</dd>
<dt>default.units</dt><dd><p>Default <code><a href="grid.html#topic+unit">grid::unit()</a></code> for viewport</p>
</dd>
<dt>angle</dt><dd><p>angle for viewport</p>
</dd>
</dl>



<h3>Usage in other packages</h3>

<p>To avoid taking a dependency on <code>affiner</code> you may copy the source of <code>affine_settings()</code>
into your own package under the permissive Unlicense.  Either use
<code>usethis::use_standalone("trevorld/affiner", "standalone-affine-settings.r")</code> or
copy the file <code>standalone-affine-settings.r</code> into your <code>R</code> directory and add <code>grid</code>
to the <code>Imports</code> of your <code>DESCRIPTION</code> file.
</p>


<h3>See Also</h3>

<p>Intended for use with <code><a href="#topic+affineGrob">affineGrob()</a></code> and <code><a href="grid.html#topic+grid.group">grid::useGrob()</a></code>.
See <a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html">https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html</a>
for more information about the group affine transformation feature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grid")) {
  grob &lt;- grobTree(rectGrob(gp = gpar(fill = "blue", col = NA)),
                   circleGrob(gp=gpar(fill="yellow", col = NA)),
                   textGrob("RSTATS", gp=gpar(fontsize=32)))
  grid.newpage()
  pushViewport(viewport(width=unit(4, "in"), height=unit(2, "in")))
  grid.draw(grob)
  popViewport()
}
if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
  # Only works if active graphics device supports affine transformations
  # such as `png(type="cairo")` on R 4.2+
  vp_define &lt;- viewport(width=unit(2, "in"), height=unit(2, "in"))
  settings &lt;- affine_settings(xy = list(x = c(1/3, 0/3, 2/3, 3/3),
                                        y = c(2/3, 1/3, 1/3, 2/3)),
                              unit = "snpc")
  affine &lt;- affineGrob(grob,
                       vp_define=vp_define,
                       transform = settings$transform,
                       vp_use = settings$vp)
  grid.newpage()
  grid.draw(affine)
}
if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
  # Only works if active graphics device supports affine transformations
  # such as `png(type="cairo")` on R 4.2+
  settings &lt;- affine_settings(xy = list(x = c(3/3, 2/3, 0/3, 1/3),
                                        y = c(2/3, 1/3, 1/3, 2/3)),
                              unit = "snpc")
  affine &lt;- affineGrob(grob,
                       vp_define=vp_define,
                       transform = settings$transform,
                       vp_use = settings$vp)
  grid.newpage()
  grid.draw(affine)
}
</code></pre>

<hr>
<h2 id='affineGrob'>Affine transformation grob</h2><span id='topic+affineGrob'></span><span id='topic+grid.affine'></span>

<h3>Description</h3>

<p><code>affineGrob()</code> is a grid grob function to facilitate
using the group affine transformation features introduced in R 4.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affineGrob(
  grob,
  vp_define = NULL,
  transform = NULL,
  vp_use = NULL,
  name = NULL,
  gp = grid::gpar(),
  vp = NULL
)

grid.affine(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affineGrob_+3A_grob">grob</code></td>
<td>
<p>A grid grob to perform affine transformations on.  Passed to <code><a href="grid.html#topic+grid.group">grid::defineGrob()</a></code> as its <code>src</code> argument.</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_vp_define">vp_define</code></td>
<td>
<p><code><a href="grid.html#topic+viewport">grid::viewport()</a></code> to define grid group in.  Passed to <code><a href="grid.html#topic+grid.group">grid::defineGrob()</a></code> as its <code>vp</code> argument.
This will cumulative with the current viewport and the <code>vp</code> argument (if any),
if this cumulative viewport falls outside the graphics device drawing area this
grob may be clipped on certain graphics devices.</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_transform">transform</code></td>
<td>
<p>An affine transformation function.
If <code>NULL</code> default to <code><a href="grid.html#topic+viewportTransform">grid::viewportTransform()</a></code>.
Passed to <code><a href="grid.html#topic+grid.group">grid::useGrob()</a></code> as its <code>transform</code> argument.</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_vp_use">vp_use</code></td>
<td>
<p><code><a href="grid.html#topic+viewport">grid::viewport()</a></code> passed to <code><a href="grid.html#topic+grid.group">grid::useGrob()</a></code> as its <code>vp</code> argument.</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid).</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_gp">gp</code></td>
<td>
<p>A <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> object.</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_vp">vp</code></td>
<td>
<p>A <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="affineGrob_+3A_...">...</code></td>
<td>
<p>Passed to <code>affineGrob()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all graphics devices provided by <code>grDevices</code> or other R packages support the <a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html">affine transformation feature introduced in R 4.2</a>.
If <code>isTRUE(getRversion() &gt;= '4.2.0')</code> then the active graphics device should support this feature if <code>isTRUE(grDevices::dev.capabilities()$transformations)</code>.
In particular the following graphics devices should support the affine transformation feature:
</p>

<ul>
<li><p> R's <code><a href="grDevices.html#topic+pdf">grDevices::pdf()</a></code> device
</p>
</li>
<li><p> R's 'cairo' devices e.g. <code><a href="grDevices.html#topic+cairo">grDevices::cairo_pdf()</a></code>, <code>grDevices::png(type = 'cairo')</code>, <code><a href="grDevices.html#topic+cairo">grDevices::svg()</a></code>, <code>grDevices::x11(type = 'cairo')</code>, etc. If <code>isTRUE(capabilities('cairo'))</code> then R was compiled with support for the 'cairo' devices .
</p>
</li>
<li><p> R's 'quartz' devices (since R 4.3.0) e.g. <code><a href="grDevices.html#topic+quartz">grDevices::quartz()</a></code>, <code>grDevices::png(type = 'quartz')</code>, etc. If <code>isTRUE(capabilities('aqua'))</code> then R was compiled with support for the 'quartz' devices (generally only <code>TRUE</code> on macOS systems).
</p>
</li>
<li> <p><code>ragg</code>'s devices (since v1.3.0) e.g. <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code>, <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>, etc.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="grid.html#topic+grid.grob">grid::gTree()</a></code> (grob) object of class &quot;affine&quot;.
As a side effect <code>grid.affine()</code> draws to the active graphics device.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+affine_settings">affine_settings()</a></code> for computing good <code>transform</code> and <code>vp_use</code> settings.
See <a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html">https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html</a>
for more information about the group affine transformation feature.
See <code><a href="#topic+isocubeGrob">isocubeGrob()</a></code> which wraps this function to render isometric cubes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grid")) {
  grob &lt;- grobTree(rectGrob(gp = gpar(fill = "blue", col = NA)),
                   circleGrob(gp=gpar(fill="yellow", col = NA)),
                   textGrob("RSTATS", gp=gpar(fontsize=32)))
  grid.newpage()
  pushViewport(viewport(width=unit(4, "in"), height=unit(2, "in")))
  grid.draw(grob)
  popViewport()
}

if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
  # Only works if active graphics device supports affine transformations
  # such as `png(type="cairo")` on R 4.2+
  vp_define &lt;- viewport(width=unit(2, "in"), height=unit(2, "in"))
  affine &lt;- affineGrob(grob, vp_define=vp_define)
  grid.newpage()
  pushViewport(viewport(width=unit(4, "in"), height=unit(2, "in")))
  grid.draw(affine)
  popViewport()
}
if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
  # Only works if active graphics device supports affine transformations
  # such as `png(type="cairo")` on R 4.2+
  settings &lt;- affine_settings(xy = list(x = c(3/3, 2/3, 0/3, 1/3),
                                        y = c(2/3, 1/3, 1/3, 2/3)),
                              unit = "snpc")
  affine &lt;- affineGrob(grob,
                       vp_define = vp_define,
                       transform = settings$transform,
                       vp_use = settings$vp)
  grid.newpage()
  grid.draw(affine)
}
</code></pre>

<hr>
<h2 id='affiner_options'>Get affiner options</h2><span id='topic+affiner_options'></span>

<h3>Description</h3>

<p><code>affiner_options()</code> returns the <code>affiner</code> package's global options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affiner_options(..., default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affiner_options_+3A_...">...</code></td>
<td>
<p><code>affiner</code> package options using <code>name = value</code>.
The return list will use any of these instead of the current/default values.</p>
</td></tr>
<tr><td><code id="affiner_options_+3A_default">default</code></td>
<td>
<p>If <code>TRUE</code> return the default values instead of current values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of option values.
Note this function <strong>does not</strong> set option values itself but
this list can be passed to <code><a href="base.html#topic+options">options()</a></code>, <code><a href="withr.html#topic+with_options">withr::local_options()</a></code>, or <code><a href="withr.html#topic+with_options">withr::with_options()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+affiner">affiner</a> for a high-level description of relevant global options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  affiner_options()

  affiner_options(default = TRUE)

  affiner_options(affiner_angular_unit = "pi-radians")
</code></pre>

<hr>
<h2 id='angle'>Angle vectors</h2><span id='topic+angle'></span><span id='topic+degrees'></span><span id='topic+gradians'></span><span id='topic+pi_radians'></span><span id='topic+radians'></span><span id='topic+turns'></span>

<h3>Description</h3>

<p><code>angle()</code> creates angle vectors with user specified angular unit.
around <code><a href="#topic+as_angle">as_angle()</a></code> for those angular units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle(x = numeric(), unit = getOption("affiner_angular_unit", "degrees"))

degrees(x)

gradians(x)

pi_radians(x)

radians(x)

turns(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle_+3A_x">x</code></td>
<td>
<p>An angle vector or an object to convert to it (such as a numeric vector)</p>
</td></tr>
<tr><td><code id="angle_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class &quot;angle&quot;.
Its &quot;unit&quot; attribute is a standardized string of the specified angular unit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_angle">as_angle()</a></code>, <code><a href="#topic+angular_unit">angular_unit()</a></code>, and <a href="#topic+angle-methods">angle-methods</a>.
<a href="https://en.wikipedia.org/wiki/Angle#Units">https://en.wikipedia.org/wiki/Angle#Units</a> for more information about angular units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Different representations of the "same" angle
  angle(180, "degrees")
  angle(pi, "radians")
  angle(0.5, "turns")
  angle(200, "gradians")
  pi_radians(1)

  a1 &lt;- angle(180, "degrees")
  angular_unit(a1)
  is_angle(a1)
  as.numeric(a1, "radians")
  cos(a1)

  a2 &lt;- as_angle(a1, "radians")
  angular_unit(a2)
  is_congruent(a1, a2)
</code></pre>

<hr>
<h2 id='angle-methods'>Implemented base methods for angle vectors</h2><span id='topic+angle-methods'></span><span id='topic+as.double.angle'></span><span id='topic+as.complex.angle'></span><span id='topic+format.angle'></span><span id='topic+print.angle'></span><span id='topic+abs.angle'></span>

<h3>Description</h3>

<p>We implemented methods for several base generics for the <code><a href="#topic+angle">angle()</a></code> vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angle'
as.double(x, unit = angular_unit(x), ...)

## S3 method for class 'angle'
as.complex(x, modulus = 1, ...)

## S3 method for class 'angle'
format(x, unit = angular_unit(x), ..., use_unicode = is_utf8_output())

## S3 method for class 'angle'
print(x, unit = angular_unit(x), ..., use_unicode = is_utf8_output())

## S3 method for class 'angle'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle-methods_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+angle">angle()</a></code> vector</p>
</td></tr>
<tr><td><code id="angle-methods_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="angle-methods_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+print.default">print.default()</a></code></p>
</td></tr>
<tr><td><code id="angle-methods_+3A_modulus">modulus</code></td>
<td>
<p>Numeric vector representing the complex numbers' modulus</p>
</td></tr>
<tr><td><code id="angle-methods_+3A_use_unicode">use_unicode</code></td>
<td>
<p>If <code>TRUE</code> use Unicode symbols as appropriate.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Mathematical <a href="base.html#topic+Ops">Ops</a> (in particular <code>+</code> and <code>-</code>)
for two angle vectors will (if necessary)
set the second vector's <code><a href="#topic+angular_unit">angular_unit()</a></code> to match the first.
</p>
</li>
<li> <p><code><a href="base.html#topic+as.numeric">as.numeric()</a></code> takes a <code>unit</code> argument which can be used to convert angles into other angular units
e.g. <code>angle(x, "degrees") |&gt; as.numeric("radians")</code> to cast a numeric vector <code>x</code> from degrees to radians.
</p>
</li>
<li> <p><code><a href="base.html#topic+abs">abs()</a></code> will calculate the angle modulo full turns.
</p>
</li>
<li><p> Use <code><a href="#topic+is_congruent">is_congruent()</a></code> to test if two angles are congruent instead of <code>==</code> or <code>all.equal()</code>.
</p>
</li>
<li><p> Not all implemented methods are documented here and since <code><a href="#topic+angle">angle()</a></code> is a
<code><a href="base.html#topic+numeric">numeric()</a></code> class many other S3 generics
besides the explicitly implemented ones should also work with it.
</p>
</li></ul>



<h3>Value</h3>

<p>Typical values as usually returned by these base generics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Two "congruent" angles
  a1 &lt;- angle(180, "degrees")
  a2 &lt;- angle(pi, "radians")

  print(a1)
  print(a1, unit = "radians")
  print(a1, unit = "pi-radians")

  cos(a1)
  sin(a1)
  tan(a1)

  # mathematical operations will coerce second `angle()` object to
  # same `angular_unit()` as the first one
  a1 + a2
  a1 - a2

  as.numeric(a1)
  as.numeric(a1, "radians")
  as.numeric(a1, "turns")

  # Use `is_congruent()` to check if two angles are "congruent"
  a1 == a2
  isTRUE(all.equal(a1, a2))
  is_congruent(a1, a2)
  is_congruent(a1, a2, mod_turns = FALSE)
  a3 &lt;- angle(-180, "degrees") # Only congruent modulus full turns
  a1 == a3
  isTRUE(all.equal(a1, a2))
  is_congruent(a1, a3)
  is_congruent(a1, a3, mod_turns = FALSE)

</code></pre>

<hr>
<h2 id='angular_unit'>Get/set angular unit of angle vectors</h2><span id='topic+angular_unit'></span><span id='topic+angular_unit+3C-'></span>

<h3>Description</h3>

<p><code>angular_unit()</code> gets/sets the angular unit of <code><a href="#topic+angle">angle()</a></code> vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular_unit(x)

angular_unit(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angular_unit_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+angle">angle()</a></code> vector</p>
</td></tr>
<tr><td><code id="angular_unit_+3A_value">value</code></td>
<td>
<p>A string of the desired angular unit.  See <code><a href="#topic+angle">angle()</a></code> for supported strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>angular_unit()</code> returns a string of <code>x</code>'s angular unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- angle(seq(0, 360, by = 90), "degrees")
angular_unit(a)
print(a)
angular_unit(a) &lt;- "turns"
angular_unit(a)
print(a)
</code></pre>

<hr>
<h2 id='as_angle'>Cast to angle vector</h2><span id='topic+as_angle'></span><span id='topic+as_angle.angle'></span><span id='topic+as_angle.character'></span><span id='topic+as_angle.complex'></span><span id='topic+as_angle.Coord2D'></span><span id='topic+as_angle.Coord3D'></span><span id='topic+as_angle.Line2D'></span><span id='topic+as_angle.Plane3D'></span><span id='topic+as_angle.numeric'></span>

<h3>Description</h3>

<p><code>as_angle()</code> casts to an <code><a href="#topic+angle">angle()</a></code> vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'angle'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'character'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'complex'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'Coord2D'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'Coord3D'
as_angle(
  x,
  unit = getOption("affiner_angular_unit", "degrees"),
  type = c("azimuth", "inclination"),
  ...
)

## S3 method for class 'Line2D'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)

## S3 method for class 'Plane3D'
as_angle(
  x,
  unit = getOption("affiner_angular_unit", "degrees"),
  type = c("azimuth", "inclination"),
  ...
)

## S3 method for class 'numeric'
as_angle(x, unit = getOption("affiner_angular_unit", "degrees"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_angle_+3A_x">x</code></td>
<td>
<p>An R object to convert to a <code><a href="#topic+angle">angle()</a></code> vector</p>
</td></tr>
<tr><td><code id="as_angle_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_angle_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="as_angle_+3A_type">type</code></td>
<td>
<p>Use &quot;azimuth&quot; to calculate the azimuthal angle and &quot;inclination&quot; to calculate the inclination angle aka polar angle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+angle">angle()</a></code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_angle(angle(pi, "radians"), "pi-radians")
as_angle(complex(real = 0, imaginary = 1), "degrees")
as_angle(as_coord2d(x = 0, y = 1), "turns")
as_angle(200, "gradians")

</code></pre>

<hr>
<h2 id='as_coord1d'>Cast to coord1d object</h2><span id='topic+as_coord1d'></span><span id='topic+as_coord1d.character'></span><span id='topic+as_coord1d.Coord2D'></span><span id='topic+as_coord1d.data.frame'></span><span id='topic+as_coord1d.list'></span><span id='topic+as_coord1d.matrix'></span><span id='topic+as_coord1d.numeric'></span><span id='topic+as_coord1d.Coord1D'></span><span id='topic+as_coord1d.Point1D'></span>

<h3>Description</h3>

<p><code>as_coord1d()</code> casts to a <a href="#topic+Coord1D">Coord1D</a> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coord1d(x, ...)

## S3 method for class 'character'
as_coord1d(x, ...)

## S3 method for class 'Coord2D'
as_coord1d(
  x,
  permutation = c("xy", "yx"),
  ...,
  line = as_line2d("x-axis"),
  scale = 0
)

## S3 method for class 'data.frame'
as_coord1d(x, ...)

## S3 method for class 'list'
as_coord1d(x, ...)

## S3 method for class 'matrix'
as_coord1d(x, ...)

## S3 method for class 'numeric'
as_coord1d(x, ...)

## S3 method for class 'Coord1D'
as_coord1d(x, ...)

## S3 method for class 'Point1D'
as_coord1d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_coord1d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a <a href="#topic+Coord1D">Coord1D</a> class object
such as a numeric vector of x-coordinates.</p>
</td></tr>
<tr><td><code id="as_coord1d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="as_coord1d_+3A_permutation">permutation</code></td>
<td>
<p>Either &quot;xy&quot; (no permutation) or &quot;yx&quot; (permute x and y axes)</p>
</td></tr>
<tr><td><code id="as_coord1d_+3A_line">line</code></td>
<td>
<p>A <a href="#topic+Line2D">Line2D</a> object of length one representing the line
you with to reflect across or project to or an object coercible to one by <code>as_line2d(line, ...)</code>
such as &quot;x-axis&quot; or &quot;y-axis&quot;.</p>
</td></tr>
<tr><td><code id="as_coord1d_+3A_scale">scale</code></td>
<td>
<p>Oblique projection scale factor.
A degenerate <code>0</code> value indicates an orthogonal projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord1D">Coord1D</a> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_coord1d(x = rnorm(10))
</code></pre>

<hr>
<h2 id='as_coord2d'>Cast to coord2d object</h2><span id='topic+as_coord2d'></span><span id='topic+as_coord2d.angle'></span><span id='topic+as_coord2d.character'></span><span id='topic+as_coord2d.complex'></span><span id='topic+as_coord2d.Coord3D'></span><span id='topic+as_coord2d.data.frame'></span><span id='topic+as_coord2d.list'></span><span id='topic+as_coord2d.matrix'></span><span id='topic+as_coord2d.numeric'></span><span id='topic+as_coord2d.Coord2D'></span>

<h3>Description</h3>

<p><code>as_coord2d()</code> casts to a <a href="#topic+Coord2D">Coord2D</a> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coord2d(x, ...)

## S3 method for class 'angle'
as_coord2d(x, radius = 1, ...)

## S3 method for class 'character'
as_coord2d(x, ...)

## S3 method for class 'complex'
as_coord2d(x, ...)

## S3 method for class 'Coord3D'
as_coord2d(
  x,
  permutation = c("xyz", "xzy", "yxz", "yzx", "zyx", "zxy"),
  ...,
  plane = as_plane3d("xy-plane"),
  scale = 0,
  alpha = angle(45, "degrees")
)

## S3 method for class 'data.frame'
as_coord2d(x, ...)

## S3 method for class 'list'
as_coord2d(x, ...)

## S3 method for class 'matrix'
as_coord2d(x, ...)

## S3 method for class 'numeric'
as_coord2d(x, y = rep_len(0, length(x)), ...)

## S3 method for class 'Coord2D'
as_coord2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_coord2d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a <a href="#topic+Coord2D">Coord2D</a> class object
such as a matrix or data frame of coordinates.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_radius">radius</code></td>
<td>
<p>A numeric vector of radial distances.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_permutation">permutation</code></td>
<td>
<p>Either &quot;xyz&quot; (no permutation), &quot;xzy&quot; (permute y and z axes),
&quot;yxz&quot; (permute x and y axes), &quot;yzx&quot; (x becomes z, y becomes x, z becomes y),
&quot;zxy&quot; (x becomes y, y becomes z, z becomes x), &quot;zyx&quot; (permute x and z axes).
This permutation is applied before the (oblique) projection.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_plane">plane</code></td>
<td>
<p>A <a href="#topic+Plane3D">Plane3D</a> class object representing the plane
you wish to project to or an object coercible to one using <code>as_plane3d(plane, ...)</code>
such as &quot;xy-plane&quot;, &quot;xz-plane&quot;, or &quot;yz-plane&quot;.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening scale factor.
A (degenerate) <code>0</code> value indicates an orthographic projection.
A value of <code>0.5</code> is used by a &ldquo;cabinet projection&rdquo;
while a value of <code>1.0</code> is used by a &ldquo;cavalier projection&rdquo;.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_alpha">alpha</code></td>
<td>
<p>Oblique projection angle (the angle the third axis is projected going off at).
An <code><a href="#topic+angle">angle()</a></code> object or one coercible to one with <code>as_angle(alpha, ...)</code>.
Popular angles are 45 degrees, 60 degrees, and <code>arctangent(2)</code> degrees.</p>
</td></tr>
<tr><td><code id="as_coord2d_+3A_y">y</code></td>
<td>
<p>Numeric vector of y-coordinates to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord2D">Coord2D</a> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = sample.int(10, 3),
                 y = sample.int(10, 3))
as_coord2d(df)
as_coord2d(complex(real = 3, imaginary = 2))
as_coord2d(angle(90, "degrees"), radius = 2)
as_coord2d(as_coord3d(1, 2, 2), alpha = degrees(90), scale = 0.5)
</code></pre>

<hr>
<h2 id='as_coord3d'>Cast to coord3d object</h2><span id='topic+as_coord3d'></span><span id='topic+as_coord3d.angle'></span><span id='topic+as_coord3d.character'></span><span id='topic+as_coord3d.data.frame'></span><span id='topic+as_coord3d.list'></span><span id='topic+as_coord3d.matrix'></span><span id='topic+as_coord3d.numeric'></span><span id='topic+as_coord3d.Coord3D'></span><span id='topic+as_coord3d.Coord2D'></span>

<h3>Description</h3>

<p><code>as_coord3d()</code> casts to a <a href="#topic+Coord3D">Coord3D</a> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coord3d(x, ...)

## S3 method for class 'angle'
as_coord3d(x, radius = 1, inclination = NULL, z = NULL, ...)

## S3 method for class 'character'
as_coord3d(x, ...)

## S3 method for class 'data.frame'
as_coord3d(x, ..., z = NULL)

## S3 method for class 'list'
as_coord3d(x, ..., z = NULL)

## S3 method for class 'matrix'
as_coord3d(x, ...)

## S3 method for class 'numeric'
as_coord3d(x, y = rep_len(0, length(x)), z = rep_len(0, length(x)), ...)

## S3 method for class 'Coord3D'
as_coord3d(x, ...)

## S3 method for class 'Coord2D'
as_coord3d(x, z = rep_len(0, length(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_coord3d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a <a href="#topic+Coord3D">Coord3D</a> class object
such as a matrix or data frame of coordinates.</p>
</td></tr>
<tr><td><code id="as_coord3d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="as_coord3d_+3A_radius">radius</code></td>
<td>
<p>A numeric vector.  If <code>inclination</code> is not <code>NULL</code> represents spherical distances
of spherical coordinates and if <code>z</code> is not <code>NULL</code> represents
radial distances of cylindrical coordinates.</p>
</td></tr>
<tr><td><code id="as_coord3d_+3A_inclination">inclination</code></td>
<td>
<p>Spherical coordinates inclination angle aka polar angle.
<code>x</code> represents the azimuth aka azimuthal angle.</p>
</td></tr>
<tr><td><code id="as_coord3d_+3A_z">z</code></td>
<td>
<p>Numeric vector of z-coordinates to be used</p>
</td></tr>
<tr><td><code id="as_coord3d_+3A_y">y</code></td>
<td>
<p>Numeric vector of y-coordinates to be used
if <code>hasName(x, "z")</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord3D">Coord3D</a> class object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_coord3d(x = 1, y = 2, z = 3)
df &lt;- data.frame(x = sample.int(10, 3),
                 y = sample.int(10, 3),
                 z = sample.int(10, 3))
as_coord3d(df)
# Cylindrical coordinates
as_coord3d(degrees(90), z = 1, radius = 1)
# Spherical coordinates
as_coord3d(degrees(90), inclination = degrees(90), radius = 1)
</code></pre>

<hr>
<h2 id='as_line2d'>Cast to Line2D object</h2><span id='topic+as_line2d'></span><span id='topic+as_line2d.numeric'></span><span id='topic+as_line2d.angle'></span><span id='topic+as_line2d.character'></span><span id='topic+as_line2d.Coord2D'></span><span id='topic+as_line2d.Line2D'></span><span id='topic+as_line2d.Point1D'></span>

<h3>Description</h3>

<p><code>as_line2d()</code> casts to a <a href="#topic+Line2D">Line2D</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_line2d(...)

## S3 method for class 'numeric'
as_line2d(a, b, c, ...)

## S3 method for class 'angle'
as_line2d(theta, p1 = as_coord2d("origin"), ...)

## S3 method for class 'character'
as_line2d(x, ...)

## S3 method for class 'Coord2D'
as_line2d(normal, p1 = as_coord3d("origin"), p2, ...)

## S3 method for class 'Line2D'
as_line2d(line, ...)

## S3 method for class 'Point1D'
as_line2d(point, b = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_line2d_+3A_...">...</code></td>
<td>
<p>Passed to other function such as <code>as_coord2d()</code>.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_a">a</code>, <code id="as_line2d_+3A_b">b</code>, <code id="as_line2d_+3A_c">c</code></td>
<td>
<p>Numeric vectors that parameterize the line via the equation <code>a * x + b * y + c = 0</code>.
Note if <code>y = m * x + b</code> then <code>m * x + 1 * y + -b = 0</code>.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_theta">theta</code></td>
<td>
<p>Angle of the line represented by an <code><a href="#topic+angle">angle()</a></code> vector.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_p1">p1</code></td>
<td>
<p>Point on the line represented by a <a href="#topic+Coord2D">Coord2D</a> class object.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_x">x</code></td>
<td>
<p>A (character) vector to be cast to a <a href="#topic+Line2D">Line2D</a> object</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_normal">normal</code></td>
<td>
<p>Normal vector to the line represented by a <a href="#topic+Coord2D">Coord2D</a> class object. <code>p2</code> should be missing.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_p2">p2</code></td>
<td>
<p>Another point on the line represented by a <a href="#topic+Coord2D">Coord2D</a> class object.</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_line">line</code></td>
<td>
<p>A <a href="#topic+Line2D">Line2D</a> object</p>
</td></tr>
<tr><td><code id="as_line2d_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+Point1D">Point1D</a> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as_coord2d(x = 5, y = 10)
p2 &lt;- as_coord2d(x = 7, y = 12)
theta &lt;- degrees(45)
as_line2d(theta, p1)
as_line2d(p1, p2)
</code></pre>

<hr>
<h2 id='as_plane3d'>Cast to Plane3D object</h2><span id='topic+as_plane3d'></span><span id='topic+as_plane3d.numeric'></span><span id='topic+as_plane3d.character'></span><span id='topic+as_plane3d.Coord3D'></span><span id='topic+as_plane3d.Plane3D'></span><span id='topic+as_plane3d.Point1D'></span><span id='topic+as_plane3d.Line2D'></span>

<h3>Description</h3>

<p><code>as_plane3d()</code> casts to a <a href="#topic+Plane3D">Plane3D</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_plane3d(...)

## S3 method for class 'numeric'
as_plane3d(a, b, c, d, ...)

## S3 method for class 'character'
as_plane3d(x, ...)

## S3 method for class 'Coord3D'
as_plane3d(normal, p1 = as_coord3d("origin"), p2, p3, ...)

## S3 method for class 'Plane3D'
as_plane3d(plane, ...)

## S3 method for class 'Point1D'
as_plane3d(point, b = 0, c = 0, ...)

## S3 method for class 'Line2D'
as_plane3d(line, c = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_plane3d_+3A_...">...</code></td>
<td>
<p>Passed to other function such as <code>as_coord2d()</code>.</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_a">a</code>, <code id="as_plane3d_+3A_b">b</code>, <code id="as_plane3d_+3A_c">c</code>, <code id="as_plane3d_+3A_d">d</code></td>
<td>
<p>Numeric vectors that parameterize the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_x">x</code></td>
<td>
<p>A (character) vector to be cast to a <a href="#topic+Plane3D">Plane3D</a> object</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_normal">normal</code></td>
<td>
<p>Normal vector to the plane represented by a <a href="#topic+Coord3D">Coord3D</a> class object. <code>p2</code> and <code>p3</code> should be missing.</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_p1">p1</code></td>
<td>
<p>Point on the plane represented by a <a href="#topic+Coord3D">Coord3D</a> class object.</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_p2">p2</code>, <code id="as_plane3d_+3A_p3">p3</code></td>
<td>
<p>Points on the plane represented by <a href="#topic+Coord3D">Coord3D</a> class objects.  <code>normal</code> should be missing.</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_plane">plane</code></td>
<td>
<p>A <a href="#topic+Plane3D">Plane3D</a> object</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+Point1D">Point1D</a> object</p>
</td></tr>
<tr><td><code id="as_plane3d_+3A_line">line</code></td>
<td>
<p>A <a href="#topic+Line2D">Line2D</a> object</p>
</td></tr>
</table>

<hr>
<h2 id='as_point1d'>Cast to Point1D object</h2><span id='topic+as_point1d'></span><span id='topic+as_point1d.numeric'></span><span id='topic+as_point1d.character'></span><span id='topic+as_point1d.Coord1D'></span><span id='topic+as_point1d.Point1D'></span>

<h3>Description</h3>

<p><code>as_point1d()</code> casts to a <a href="#topic+Point1D">Point1D</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_point1d(...)

## S3 method for class 'numeric'
as_point1d(a, b, ...)

## S3 method for class 'character'
as_point1d(x, ...)

## S3 method for class 'Coord1D'
as_point1d(normal, ...)

## S3 method for class 'Point1D'
as_point1d(point, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_point1d_+3A_...">...</code></td>
<td>
<p>Passed to other function such as <code>as_coord2d()</code>.</p>
</td></tr>
<tr><td><code id="as_point1d_+3A_a">a</code>, <code id="as_point1d_+3A_b">b</code></td>
<td>
<p>Numeric vectors that parameterize the point via the equation <code>a * x + b = 0</code>.
Note this means that <code>x = -b / a</code>.</p>
</td></tr>
<tr><td><code id="as_point1d_+3A_x">x</code></td>
<td>
<p>A (character) vector to be cast to a <a href="#topic+Point1D">Point1D</a> object</p>
</td></tr>
<tr><td><code id="as_point1d_+3A_normal">normal</code></td>
<td>
<p><a href="#topic+Coord1D">Coord1D</a> class object.</p>
</td></tr>
<tr><td><code id="as_point1d_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+Point1D">Point1D</a> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as_point1d(a = 1, b = 0)
</code></pre>

<hr>
<h2 id='as_transform1d'>Cast to 1D affine transformation matrix</h2><span id='topic+as_transform1d'></span><span id='topic+as_transform1d.transform1d'></span><span id='topic+as_transform1d.default'></span>

<h3>Description</h3>

<p><code>as_transform1d()</code> casts to a <code><a href="#topic+transform1d">transform1d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_transform1d(x, ...)

## S3 method for class 'transform1d'
as_transform1d(x, ...)

## Default S3 method:
as_transform1d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_transform1d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a</p>
</td></tr>
<tr><td><code id="as_transform1d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+transform1d">transform1d()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- diag(2L)
as_transform1d(m)
</code></pre>

<hr>
<h2 id='as_transform2d'>Cast to 2D affine transformation matrix</h2><span id='topic+as_transform2d'></span><span id='topic+as_transform2d.transform2d'></span><span id='topic+as_transform2d.default'></span>

<h3>Description</h3>

<p><code>as_transform2d()</code> casts to a <code><a href="#topic+transform2d">transform2d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_transform2d(x, ...)

## S3 method for class 'transform2d'
as_transform2d(x, ...)

## Default S3 method:
as_transform2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_transform2d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a</p>
</td></tr>
<tr><td><code id="as_transform2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+transform2d">transform2d()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- diag(3L)
as_transform2d(m)
</code></pre>

<hr>
<h2 id='as_transform3d'>Cast to 3D affine transformation matrix</h2><span id='topic+as_transform3d'></span><span id='topic+as_transform3d.transform3d'></span><span id='topic+as_transform3d.default'></span>

<h3>Description</h3>

<p><code>as_transform3d()</code> casts to a <code><a href="#topic+transform3d">transform3d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_transform3d(x, ...)

## S3 method for class 'transform3d'
as_transform3d(x, ...)

## Default S3 method:
as_transform3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_transform3d_+3A_x">x</code></td>
<td>
<p>An object that can be cast to a</p>
</td></tr>
<tr><td><code id="as_transform3d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+transform3d">transform3d()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- diag(4L)
as_transform3d(m)
</code></pre>

<hr>
<h2 id='bounding_ranges'>Compute axis-aligned ranges</h2><span id='topic+bounding_ranges'></span><span id='topic+range.Coord1D'></span><span id='topic+range.Coord2D'></span><span id='topic+range.Coord3D'></span>

<h3>Description</h3>

<p><code>range()</code> computes axis-aligned ranges for
<a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, and <a href="#topic+Coord3D">Coord3D</a> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Coord1D'
range(..., na.rm = FALSE)

## S3 method for class 'Coord2D'
range(..., na.rm = FALSE)

## S3 method for class 'Coord3D'
range(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounding_ranges_+3A_...">...</code></td>
<td>
<p><a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, or <a href="#topic+Coord3D">Coord3D</a> object(s)</p>
</td></tr>
<tr><td><code id="bounding_ranges_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code>NA</code>'s should be omitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, or <a href="#topic+Coord3D">Coord3D</a> object of length two.
The first element will have the minimum x/y(/z) coordinates
and the second element will have the maximum x/y(/z) coordinates
of the axis-aligned ranges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>range(as_coord2d(rnorm(5), rnorm(5)))
range(as_coord3d(rnorm(5), rnorm(5), rnorm(5)))
</code></pre>

<hr>
<h2 id='centroid'>Compute centroids of coordinates</h2><span id='topic+centroid'></span><span id='topic+mean.Coord1D'></span><span id='topic+mean.Coord2D'></span><span id='topic+mean.Coord3D'></span>

<h3>Description</h3>

<p><code>mean()</code>computes centroids for <a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, and <a href="#topic+Coord3D">Coord3D</a> class objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Coord1D'
mean(x, ...)

## S3 method for class 'Coord2D'
mean(x, ...)

## S3 method for class 'Coord3D'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, or <a href="#topic+Coord3D">Coord3D</a> object</p>
</td></tr>
<tr><td><code id="centroid_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+mean">base::mean()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, or <a href="#topic+Coord3D">Coord3D</a> class object of length one
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = 1:4, y = 1:4)
print(mean(p))
print(sum(p) / length(p)) # less efficient alternative

p &lt;- as_coord3d(x = 1:4, y = 1:4, z = 1:4)
print(mean(p))
</code></pre>

<hr>
<h2 id='convex_hull2d'>Compute 2D convex hulls</h2><span id='topic+convex_hull2d'></span><span id='topic+convex_hull2d.Coord2D'></span>

<h3>Description</h3>

<p><code>convex_hull2d()</code> is a S3 generic for computing the convex hull of an object.
There is an implemented method supporting <a href="#topic+Coord2D">Coord2D</a> class objects
using <code><a href="grDevices.html#topic+chull">grDevices::chull()</a></code> to compute the convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex_hull2d(x, ...)

## S3 method for class 'Coord2D'
convex_hull2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convex_hull2d_+3A_x">x</code></td>
<td>
<p>An object representing object to compute convex hull of such as a <a href="#topic+Coord2D">Coord2D</a> class object.</p>
</td></tr>
<tr><td><code id="convex_hull2d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of same class as <code>x</code> representing just the subset of points on the convex hull.
The method for <a href="#topic+Coord2D">Coord2D</a> class objects returns these points in counter-clockwise order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = rnorm(25), y = rnorm(25))
print(convex_hull2d(p))

# Equivalent to following caculation using `grDevices::chull()`
all.equal(convex_hull2d(p),
          p[rev(grDevices::chull(as.list(p)))])
</code></pre>

<hr>
<h2 id='Coord1D'>1D coordinate vector R6 Class</h2><span id='topic+Coord1D'></span>

<h3>Description</h3>

<p><code>Coord1D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing two-dimensional points
represented by Cartesian Coordinates.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xw</code></dt><dd><p>A two-column matrix representing the homogeneous coordinates.
The first column is the &quot;x&quot; coordinates
and the second column is all ones.</p>
</dd>
<dt><code>x</code></dt><dd><p>A numeric vector of x-coordinates.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Coord1D-new"><code>Coord1D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-print"><code>Coord1D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-project"><code>Coord1D$project()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-reflect"><code>Coord1D$reflect()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-scale"><code>Coord1D$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-translate"><code>Coord1D$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-transform"><code>Coord1D$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord1D-clone"><code>Coord1D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Coord1D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$new(xw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xw</code></dt><dd><p>A matrix with three columns representing (homogeneous) coordinates.
The first column represents x coordinates and
the last column is all ones.
Column names should be &quot;x&quot; and &quot;w&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of coordinates to print. If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-project"></a>



<h4>Method <code>project()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$project(point = as_point1d("origin"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A <a href="#topic+Point1D">Point1D</a> object of length one representing the point
you with to reflect across or project to or an object coercible to one by <code>as_point1d(point, ...)</code>
such as &quot;origin&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+project1d">project1d()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-reflect"></a>



<h4>Method <code>reflect()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$reflect(point = as_point1d("origin"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A <a href="#topic+Point1D">Point1D</a> object of length one representing the point
you with to reflect across or project to or an object coercible to one by <code>as_point1d(point, ...)</code>
such as &quot;origin&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+reflect1d">reflect1d()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-scale"></a>



<h4>Method <code>scale()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$scale(x_scale = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_scale</code></dt><dd><p>Scaling factor to apply to x coordinates</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-translate"></a>



<h4>Method <code>translate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$translate(x = as_coord1d(0), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A <a href="#topic+Coord1D">Coord1D</a> object of length one or an object coercible to one by <code>as_coord1d(x, ...)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code>as_coord1d(x, ...)</code> if <code>x</code> is not a <a href="#topic+Coord1D">Coord1D</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-transform"></a>



<h4>Method <code>transform()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord1D$transform(mat = transform1d())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A 2x2 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 1x1 matrix we'll quietly add a final column/row equal to <code>c(0, 1)</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord1D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coord1D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord1d(x = rnorm(100, 2))
print(p, n = 10L)
pc &lt;- mean(p) # Centroid
# method chained affine transformation matrices are auto-pre-multiplied
p$
  translate(-pc)$
  reflect("origin")$
  print(n = 10L)
</code></pre>

<hr>
<h2 id='Coord2D'>2D coordinate vector R6 Class</h2><span id='topic+Coord2D'></span>

<h3>Description</h3>

<p><code>Coord2D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing two-dimensional points
represented by Cartesian Coordinates.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xyw</code></dt><dd><p>A three-column matrix representing the homogeneous coordinates.
The first two columns are &quot;x&quot; and &quot;y&quot; coordinates
and the third column is all ones.</p>
</dd>
<dt><code>x</code></dt><dd><p>A numeric vector of x-coordinates.</p>
</dd>
<dt><code>y</code></dt><dd><p>A numeric vector of y-coordinates.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Coord2D-new"><code>Coord2D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-permute"><code>Coord2D$permute()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-print"><code>Coord2D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-project"><code>Coord2D$project()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-reflect"><code>Coord2D$reflect()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-rotate"><code>Coord2D$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-scale"><code>Coord2D$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-shear"><code>Coord2D$shear()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-translate"><code>Coord2D$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-transform"><code>Coord2D$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord2D-clone"><code>Coord2D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Coord2D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$new(xyw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xyw</code></dt><dd><p>A matrix with three columns representing (homogeneous) coordinates.
The first two columns represent x and y coordinates and
the last column is all ones.
Column names should be &quot;x&quot;, &quot;y&quot;, and &quot;w&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-permute"></a>



<h4>Method <code>permute()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$permute(permutation = c("xy", "yx"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>permutation</code></dt><dd><p>Either &quot;xy&quot; (no permutation) or &quot;yx&quot; (permute x and y axes)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of coordinates to print.  If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-project"></a>



<h4>Method <code>project()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$project(line = as_line2d("x-axis"), ..., scale = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>A <a href="#topic+Line2D">Line2D</a> object of length one representing the line
you with to reflect across or project to or an object coercible to one by <code>as_line2d(line, ...)</code>
such as &quot;x-axis&quot; or &quot;y-axis&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+project2d">project2d()</a></code></p>
</dd>
<dt><code>scale</code></dt><dd><p>Oblique projection scale factor.
A degenerate <code>0</code> value indicates an orthogonal projection.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-reflect"></a>



<h4>Method <code>reflect()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$reflect(line = as_line2d("x-axis"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>A <a href="#topic+Line2D">Line2D</a> object of length one representing the line
you with to reflect across or project to or an object coercible to one by <code>as_line2d(line, ...)</code>
such as &quot;x-axis&quot; or &quot;y-axis&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+reflect2d">reflect2d()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-rotate"></a>



<h4>Method <code>rotate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$rotate(theta = angle(0), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>An <code><a href="#topic+angle">angle()</a></code> object of length one or an object coercible to one by <code>as_angle(theta, ...)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+as_angle">as_angle()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-scale"></a>



<h4>Method <code>scale()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$scale(x_scale = 1, y_scale = x_scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_scale</code></dt><dd><p>Scaling factor to apply to x coordinates</p>
</dd>
<dt><code>y_scale</code></dt><dd><p>Scaling factor to apply to y coordinates</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-shear"></a>



<h4>Method <code>shear()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$shear(xy_shear = 0, yx_shear = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xy_shear</code></dt><dd><p>Horizontal shear factor: <code>x = x + xy_shear * y</code></p>
</dd>
<dt><code>yx_shear</code></dt><dd><p>Vertical shear factor: <code>y = yx_shear * x + y</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-translate"></a>



<h4>Method <code>translate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$translate(x = as_coord2d(0, 0), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A <a href="#topic+Coord2D">Coord2D</a> object of length one or an object coercible to one by <code>as_coord2d(x, ...)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code>as_coord2d(x, ...)</code> if <code>x</code> is not a <a href="#topic+Coord2D">Coord2D</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-transform"></a>



<h4>Method <code>transform()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord2D$transform(mat = transform2d())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A 3x3 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 2x2 matrix (such as a 2x2 post-multiplied 2D rotation matrix)
we'll quietly add a final column/row equal to <code>c(0, 0, 1)</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord2D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coord2D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = rnorm(100, 2), y = rnorm(100, 2))
print(p, n = 10)
pc &lt;- mean(p) # Centroid
# method chained affine transformation matrices are auto-pre-multiplied
p$
  translate(-pc)$
  shear(x = 1, y = 0)$
  reflect("x-axis")$
  rotate(90, "degrees")$
  print(n = 10)
</code></pre>

<hr>
<h2 id='Coord3D'>3D coordinate vector R6 Class</h2><span id='topic+Coord3D'></span>

<h3>Description</h3>

<p><code>Coord3D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing three-dimensional points
represented by Cartesian Coordinates.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xyzw</code></dt><dd><p>A four-column matrix representing the homogeneous coordinates.
The first three columns are &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; coordinates
and the fourth column is all ones.</p>
</dd>
<dt><code>x</code></dt><dd><p>A numeric vector of x-coordinates.</p>
</dd>
<dt><code>y</code></dt><dd><p>A numeric vector of y-coordinates.</p>
</dd>
<dt><code>z</code></dt><dd><p>A numeric vector of z-coordinates.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Coord3D-new"><code>Coord3D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-permute"><code>Coord3D$permute()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-print"><code>Coord3D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-project"><code>Coord3D$project()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-reflect"><code>Coord3D$reflect()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-rotate"><code>Coord3D$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-scale"><code>Coord3D$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-shear"><code>Coord3D$shear()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-translate"><code>Coord3D$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-transform"><code>Coord3D$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Coord3D-clone"><code>Coord3D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Coord3D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$new(xyzw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xyzw</code></dt><dd><p>A matrix with four columns representing (homogeneous) coordinates.
The first three columns represent x, y, and z coordinates and
the last column is all ones.
Column names should be &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, and &quot;w&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-permute"></a>



<h4>Method <code>permute()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$permute(permutation = c("xyz", "xzy", "yxz", "yzx", "zyx", "zxy"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>permutation</code></dt><dd><p>Either &quot;xyz&quot; (no permutation), &quot;xzy&quot; (permute y and z axes),
&quot;yxz&quot; (permute x and y axes), &quot;yzx&quot; (x becomes z, y becomes x, z becomes y),
&quot;zxy&quot; (x becomes y, y becomes z, z becomes x), &quot;zyx&quot; (permute x and z axes)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of coordinates to print.  If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-project"></a>



<h4>Method <code>project()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$project(
  plane = as_plane3d("xy-plane"),
  ...,
  scale = 0,
  alpha = angle(45, "degrees")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plane</code></dt><dd><p>A <a href="#topic+Plane3D">Plane3D</a> object of length one representing the plane
you wish to reflect across or project to or an object coercible to one using <code>as_plane3d(plane, ...)</code>
such as &quot;xy-plane&quot;, &quot;xz-plane&quot;, or &quot;yz-plane&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+project3d">project3d()</a></code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Oblique projection foreshortening scale factor.
A (degenerate) <code>0</code> value indicates an orthographic projection.
A value of <code>0.5</code> is used by a &ldquo;cabinet projection&rdquo;
while a value of <code>1.0</code> is used by a &ldquo;cavalier projection&rdquo;.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Oblique projection angle (the angle the third axis is projected going off at).
An <code><a href="#topic+angle">angle()</a></code> object or one coercible to one with <code>as_angle(alpha, ...)</code>.
Popular angles are 45 degrees, 60 degrees, and <code>arctangent(2)</code> degrees.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-reflect"></a>



<h4>Method <code>reflect()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$reflect(plane = as_plane3d("xy-plane"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plane</code></dt><dd><p>A <a href="#topic+Plane3D">Plane3D</a> object of length one representing the plane
you wish to reflect across or project to or an object coercible to one using <code>as_plane3d(plane, ...)</code>
such as &quot;xy-plane&quot;, &quot;xz-plane&quot;, or &quot;yz-plane&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+reflect3d">reflect3d()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-rotate"></a>



<h4>Method <code>rotate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$rotate(axis = as_coord3d("z-axis"), theta = angle(0), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>axis</code></dt><dd><p>A <a href="#topic+Coord3D">Coord3D</a> class object or one that can coerced to one by <code>as_coord3d(axis, ...)</code>.
The <code>axis</code> represents the axis to be rotated around.</p>
</dd>
<dt><code>theta</code></dt><dd><p>An <code><a href="#topic+angle">angle()</a></code> object of length one or an object coercible to one by <code>as_angle(theta, ...)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="#topic+rotate3d">rotate3d()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-scale"></a>



<h4>Method <code>scale()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$scale(x_scale = 1, y_scale = x_scale, z_scale = x_scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_scale</code></dt><dd><p>Scaling factor to apply to x coordinates</p>
</dd>
<dt><code>y_scale</code></dt><dd><p>Scaling factor to apply to y coordinates</p>
</dd>
<dt><code>z_scale</code></dt><dd><p>Scaling factor to apply to z coordinates</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-shear"></a>



<h4>Method <code>shear()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$shear(
  xy_shear = 0,
  xz_shear = 0,
  yx_shear = 0,
  yz_shear = 0,
  zx_shear = 0,
  zy_shear = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xy_shear</code></dt><dd><p>Shear factor: <code>x = x + xy_shear * y + xz_shear * z</code></p>
</dd>
<dt><code>xz_shear</code></dt><dd><p>Shear factor: <code>x = x + xy_shear * y + xz_shear * z</code></p>
</dd>
<dt><code>yx_shear</code></dt><dd><p>Shear factor: <code>y = yx_shear * x + y + yz_shear * z</code></p>
</dd>
<dt><code>yz_shear</code></dt><dd><p>Shear factor: <code>y = yx_shear * x + y + yz_shear * z</code></p>
</dd>
<dt><code>zx_shear</code></dt><dd><p>Shear factor: <code>z = zx_shear * x + zy_shear * y + z</code></p>
</dd>
<dt><code>zy_shear</code></dt><dd><p>Shear factor: <code>z = zx_shear * x + zy_shear * y + z</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-translate"></a>



<h4>Method <code>translate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$translate(x = as_coord3d(0, 0, 0), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A <a href="#topic+Coord3D">Coord3D</a> object of length one or an object coercible to one by <code>as_coord3d(x, ...)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code>as_coord3d(x, ...)</code> if <code>x</code> is not a <a href="#topic+Coord3D">Coord3D</a> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-transform"></a>



<h4>Method <code>transform()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Coord3D$transform(mat = transform3d())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A 4x4 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 0, 0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 0, 0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 3x3 matrix (such as a 3x3 post-multiplied 3D rotation matrix)
we'll quietly add a final column/row equal to <code>c(0, 0, 0, 1)</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Coord3D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coord3D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord3d(x = rnorm(100, 2), y = rnorm(100, 2), z = rnorm(100, 2))
print(p, n = 10)
pc &lt;- mean(p) # Centroid
# method chained affine transformation matrices are auto-pre-multiplied
p$
  translate(-pc)$
  reflect("xy-plane")$
  rotate("z-axis", degrees(90))$
  print(n = 10)
</code></pre>

<hr>
<h2 id='cross_product3d'>Compute 3D vector cross product</h2><span id='topic+cross_product3d'></span>

<h3>Description</h3>

<p><code>cross_product3d()</code> computes the cross product of two <a href="#topic+Coord3D">Coord3D</a> class vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_product3d(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_product3d_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord3D">Coord3D</a> class vector.</p>
</td></tr>
<tr><td><code id="cross_product3d_+3A_y">y</code></td>
<td>
<p>A <a href="#topic+Coord3D">Coord3D</a> class vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord3D">Coord3D</a> class vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_coord3d(2, 3, 4)
y &lt;- as_coord3d(5, 6, 7)
cross_product3d(x, y)
</code></pre>

<hr>
<h2 id='distance1d'>1D Euclidean distances</h2><span id='topic+distance1d'></span>

<h3>Description</h3>

<p><code>distance1d()</code> computes 1D Euclidean distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance1d(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance1d_+3A_x">x</code></td>
<td>
<p>Either a <a href="#topic+Coord1D">Coord1D</a> or <a href="#topic+Point1D">Point1D</a> class object</p>
</td></tr>
<tr><td><code id="distance1d_+3A_y">y</code></td>
<td>
<p>Either a <a href="#topic+Coord1D">Coord1D</a> or <a href="#topic+Point1D">Point1D</a> class object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord1d(x = 1:4)
distance1d(p, as_coord1d(0))
</code></pre>

<hr>
<h2 id='distance2d'>2D Euclidean distances</h2><span id='topic+distance2d'></span>

<h3>Description</h3>

<p><code>distance2d()</code> computes 2D Euclidean distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance2d(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance2d_+3A_x">x</code></td>
<td>
<p>Either a <a href="#topic+Coord2D">Coord2D</a> or <a href="#topic+Line2D">Line2D</a> class object</p>
</td></tr>
<tr><td><code id="distance2d_+3A_y">y</code></td>
<td>
<p>Either a <a href="#topic+Coord2D">Coord2D</a> or <a href="#topic+Line2D">Line2D</a> class object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = 1:4, y = 1:4)
distance2d(p, as_coord2d(0, 0))
</code></pre>

<hr>
<h2 id='distance3d'>3D Euclidean distances</h2><span id='topic+distance3d'></span>

<h3>Description</h3>

<p><code>distance3d()</code> computes 3D Euclidean distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance3d(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance3d_+3A_x">x</code></td>
<td>
<p>Either a <a href="#topic+Coord3D">Coord3D</a> or <a href="#topic+Plane3D">Plane3D</a> class object</p>
</td></tr>
<tr><td><code id="distance3d_+3A_y">y</code></td>
<td>
<p>Either a <a href="#topic+Coord3D">Coord3D</a> or <a href="#topic+Plane3D">Plane3D</a> class object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord3d(x = 1:4, y = 1:4, z = 1:4)
distance3d(p, as_coord3d("origin"))
</code></pre>

<hr>
<h2 id='graphics'>Plot coordinates, points, lines, and planes</h2><span id='topic+graphics'></span><span id='topic+plot.Coord1D'></span><span id='topic+points.Coord1D'></span><span id='topic+lines.Point1D'></span><span id='topic+plot.Coord2D'></span><span id='topic+points.Coord2D'></span><span id='topic+lines.Line2D'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+plot">plot()</a></code> plots <a href="#topic+Coord1D">Coord1D</a> and <a href="#topic+Coord2D">Coord2D</a> class objects while
<code><a href="graphics.html#topic+points">points()</a></code> draws <a href="#topic+Coord1D">Coord1D</a> and <a href="#topic+Coord2D">Coord2D</a> class objects
and <code><a href="graphics.html#topic+lines">lines()</a></code> draws <a href="#topic+Point1D">Point1D</a> and <a href="#topic+Line2D">Line2D</a> class objects to an existing plot.
If the suggested <a href="ggplot2.html#topic+ggplot2-package">ggplot2</a> and <a href="rgl.html#topic+rgl-package">rgl</a> packages are available we also register <code><a href="ggplot2.html#topic+autolayer">ggplot2::autolayer()</a></code> methods for <a href="#topic+Coord1D">Coord1D</a>, <a href="#topic+Coord2D">Coord2D</a>, <a href="#topic+Point1D">Point1D</a>, and <a href="#topic+Line2D">Line2D</a> class objects and a <code><a href="rgl.html#topic+plot3d">rgl::plot3d()</a></code> method for <a href="#topic+Coord3D">Coord3D</a> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Coord1D'
plot(x, ...)

## S3 method for class 'Coord1D'
points(x, ...)

## S3 method for class 'Point1D'
lines(x, ...)

## S3 method for class 'Coord2D'
plot(x, ...)

## S3 method for class 'Coord2D'
points(x, ...)

## S3 method for class 'Line2D'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphics_+3A_x">x</code></td>
<td>
<p>A supported object to plot.</p>
</td></tr>
<tr><td><code id="graphics_+3A_...">...</code></td>
<td>
<p>Passed to the underlying plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for its side effect of drawing to the graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- as_coord2d(x = 0, y = 1:10)
l &lt;- as_line2d(a = 1, b = -1, c = 0) # y = x
c2 &lt;- c1$clone()$reflect(l)
plot(c1, xlim = c(-1, 11), ylim = c(-1, 11),
     main = "2D reflection across a line")
lines(l)
points(c2, col = "red")

c1 &lt;- as_coord2d(x = 1:10, y = 1:10)
l &lt;- as_line2d(a = -1, b = 0, c = 0) # x = 0
c2 &lt;- c1$clone()$project(l)
if (require("ggplot2", quietly = TRUE,
            include.only = c("ggplot", "autolayer", "labs"))) {
  ggplot() +
      autolayer(c1) +
      autolayer(l) +
      autolayer(c2, color = "red") +
      labs(title = "2D projection onto a line")
}

c1 &lt;- as_coord1d(x = seq.int(-4, -1))
pt &lt;- as_point1d(a = 1, b = 0) # x = 0
c2 &lt;- c1$clone()$reflect(pt)
plot(c1, xlim = c(-5, 5), main = "1D reflection across a point")
lines(pt)
points(c2, col = "red")

# 3D reflection across a plane
c1 &lt;- as_coord3d(x = 1:10, y = 1:10, z = 1:10)
pl &lt;- as_plane3d(a = 0, b = 0, c = -1, d = 2) # z = 2
c2 &lt;- c1$clone()$reflect(pl)
if (require("rgl", quietly = TRUE, 
            include.only = c("plot3d", "planes3d", "points3d"))) {
  plot3d(c1, size = 8)
  planes3d(as.data.frame(pl), d =  pl$d, color = "grey", alpha = 0.6)
  points3d(as.data.frame(c2), col = "red", size = 8)
}
</code></pre>

<hr>
<h2 id='inverse-trigonometric-functions'>Angle vector aware inverse trigonometric functions</h2><span id='topic+inverse-trigonometric-functions'></span><span id='topic+arcsine'></span><span id='topic+arccosine'></span><span id='topic+arctangent'></span><span id='topic+arcsecant'></span><span id='topic+arccosecant'></span><span id='topic+arccotangent'></span>

<h3>Description</h3>

<p><code>arcsine()</code>, <code>arccosine()</code>, <code>arctangent()</code>,
<code>arcsecant()</code>, <code>arccosecant()</code>, and <code>arccotangent()</code> are
inverse trigonometric functions that return <code><a href="#topic+angle">angle()</a></code> vectors
with a user chosen angular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsine(
  x,
  unit = getOption("affiner_angular_unit", "degrees"),
  tolerance = sqrt(.Machine$double.eps)
)

arccosine(
  x,
  unit = getOption("affiner_angular_unit", "degrees"),
  tolerance = sqrt(.Machine$double.eps)
)

arctangent(x, unit = getOption("affiner_angular_unit", "degrees"), y = NULL)

arcsecant(x, unit = getOption("affiner_angular_unit", "degrees"))

arccosecant(x, unit = getOption("affiner_angular_unit", "degrees"))

arccotangent(x, unit = getOption("affiner_angular_unit", "degrees"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse-trigonometric-functions_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="inverse-trigonometric-functions_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="inverse-trigonometric-functions_+3A_tolerance">tolerance</code></td>
<td>
<p>If <code>x</code> greater than 1 (or less than -1) but is within a <code>tolerance</code>
of 1 (or -1) then it will be treated as 1 (or -1)</p>
</td></tr>
<tr><td><code id="inverse-trigonometric-functions_+3A_y">y</code></td>
<td>
<p>A numeric vector or <code>NULL</code>.
If <code>NULL</code> (default) we compute the 1-argument arctangent
else we compute the 2-argument arctangent.
For positive coordinates <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> then <code>arctangent(x = y/x) == arctangent(x = x, y = y)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+angle">angle()</a></code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arccosine(-1, "degrees")
arcsine(0, "turns")
arctangent(0, "gradians")
arccosecant(-1, "degrees")
arcsecant(1, "degrees")
arccotangent(1, "half-turns")

# `base::atan2(y, x)` computes the angle of the vector from origin to (x, y)
as_angle(as_coord2d(x = 1, y = 1), "degrees")
</code></pre>

<hr>
<h2 id='is_angle'>Test whether an object is an angle vector</h2><span id='topic+is_angle'></span>

<h3>Description</h3>

<p><code>is_angle()</code> tests whether an object is an angle vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_angle(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_angle_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- angle(180, "degrees")
is_angle(a)
is_angle(pi)
</code></pre>

<hr>
<h2 id='is_congruent'>Test whether two objects are congruent</h2><span id='topic+is_congruent'></span><span id='topic+is_congruent.numeric'></span><span id='topic+is_congruent.angle'></span>

<h3>Description</h3>

<p><code>is_congruent()</code> is a S3 generic that tests whether two different objects are &ldquo;congruent&rdquo;.
The <code>is_congruent()</code> method for <code><a href="#topic+angle">angle()</a></code> classes tests whether two angles are congruent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_congruent(x, y, ...)

## S3 method for class 'numeric'
is_congruent(x, y, ..., tolerance = sqrt(.Machine$double.eps))

## S3 method for class 'angle'
is_congruent(
  x,
  y,
  ...,
  mod_turns = TRUE,
  tolerance = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_congruent_+3A_x">x</code>, <code id="is_congruent_+3A_y">y</code></td>
<td>
<p>Two objects to test whether they are &ldquo;&quot;congruent&quot;&rdquo;.</p>
</td></tr>
<tr><td><code id="is_congruent_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="is_congruent_+3A_tolerance">tolerance</code></td>
<td>
<p>Angles (coerced to half-turns) or numerics with differences smaller
than <code>tolerance</code> will be considered &ldquo;congruent&rdquo;.</p>
</td></tr>
<tr><td><code id="is_congruent_+3A_mod_turns">mod_turns</code></td>
<td>
<p>If <code>TRUE</code> angles that are congruent modulo full turns will be considered &ldquo;congruent&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use `is_congruent()` to check if two angles are "congruent"
  a1 &lt;- angle(180, "degrees")
  a2 &lt;- angle(pi, "radians")
  a3 &lt;- angle(-180, "degrees") # Only congruent modulus full turns
  a1 == a2
  isTRUE(all.equal(a1, a2))
  is_congruent(a1, a2)
  is_congruent(a1, a2, mod_turns = FALSE)
  a1 == a3
  isTRUE(all.equal(a1, a3))
  is_congruent(a1, a3)
  is_congruent(a1, a3, mod_turns = FALSE)

</code></pre>

<hr>
<h2 id='is_coord1d'>Test whether an object has a Coord1D class</h2><span id='topic+is_coord1d'></span>

<h3>Description</h3>

<p><code>is_coord1d()</code> tests whether an object has a &quot;Coord1D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_coord1d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_coord1d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord1d(x = sample.int(10, 3))
is_coord1d(p)
</code></pre>

<hr>
<h2 id='is_coord2d'>Test whether an object has a Coord2D class</h2><span id='topic+is_coord2d'></span>

<h3>Description</h3>

<p><code>is_coord2d()</code> tests whether an object has a &quot;Coord2D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_coord2d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_coord2d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = sample.int(10, 3), y = sample.int(10, 3))
is_coord2d(p)
</code></pre>

<hr>
<h2 id='is_coord3d'>Test whether an object has a Coord3D class</h2><span id='topic+is_coord3d'></span>

<h3>Description</h3>

<p><code>is_coord3d()</code> tests whether an object has a &quot;Coord3D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_coord3d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_coord3d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord3d(x = sample.int(10, 3),
                y = sample.int(10, 3),
                z = sample.int(10, 3))
is_coord3d(p)
</code></pre>

<hr>
<h2 id='is_line2d'>Test whether an object has a Line2D class</h2><span id='topic+is_line2d'></span>

<h3>Description</h3>

<p><code>is_line2d()</code> tests whether an object has a &quot;Line2D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_line2d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_line2d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- as_line2d(a = 1, b = 2, c = 3)
is_line2d(l)
</code></pre>

<hr>
<h2 id='is_plane3d'>Test whether an object has a Plane3D class</h2><span id='topic+is_plane3d'></span>

<h3>Description</h3>

<p><code>is_plane3d()</code> tests whether an object has a &quot;Plane3D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_plane3d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_plane3d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_plane3d(a = 1, b = 2, c = 3, 4)
is_plane3d(p)
</code></pre>

<hr>
<h2 id='is_point1d'>Test whether an object has a Point1D class</h2><span id='topic+is_point1d'></span>

<h3>Description</h3>

<p><code>is_point1d()</code> tests whether an object has a &quot;Point1D&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_point1d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_point1d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_point1d(a = 1, b = 5)
is_point1d(p)
</code></pre>

<hr>
<h2 id='is_transform1d'>Test if 1D affine transformation matrix</h2><span id='topic+is_transform1d'></span>

<h3>Description</h3>

<p><code>is_transform1d()</code> tests if object is a <code><a href="#topic+transform1d">transform1d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_transform1d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_transform1d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- transform1d(diag(2L))
is_transform1d(m)
is_transform1d(diag(2L))
</code></pre>

<hr>
<h2 id='is_transform2d'>Test if 2D affine transformation matrix</h2><span id='topic+is_transform2d'></span>

<h3>Description</h3>

<p><code>is_transform2d()</code> tests if object is a <code><a href="#topic+transform2d">transform2d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_transform2d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_transform2d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- transform2d(diag(3L))
is_transform2d(m)
is_transform2d(diag(3L))
</code></pre>

<hr>
<h2 id='is_transform3d'>Test if 3D affine transformation matrix</h2><span id='topic+is_transform3d'></span>

<h3>Description</h3>

<p><code>is_transform3d()</code> tests if object is a <code><a href="#topic+transform3d">transform3d()</a></code> affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_transform3d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_transform3d_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- transform3d(diag(4L))
is_transform3d(m)
is_transform3d(diag(4L))
</code></pre>

<hr>
<h2 id='isocubeGrob'>Isometric cube grob</h2><span id='topic+isocubeGrob'></span><span id='topic+grid.isocube'></span>

<h3>Description</h3>

<p><code>isometricCube()</code> is a grid grob function to render
isometric cube faces by automatically wrapping around <code>affineGrob()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isocubeGrob(
  top,
  right,
  left,
  gp_border = grid::gpar(col = "black", lwd = 12),
  name = NULL,
  gp = grid::gpar(),
  vp = NULL
)

grid.isocube(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isocubeGrob_+3A_top">top</code></td>
<td>
<p>A grid grob object to use as the top side of the cube.  ggplot2 objects will be coerced by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_right">right</code></td>
<td>
<p>A grid grob object to use as the right side of the cube.  ggplot2 objects will be coerced by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_left">left</code></td>
<td>
<p>A grid grob object to use as the left side of the cube.  ggplot2 objects will be coerced by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_gp_border">gp_border</code></td>
<td>
<p>A <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> object for the <code><a href="grid.html#topic+polygonGrob">polygonGrob()</a></code> used to draw borders around
the cube faces.</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid).</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_gp">gp</code></td>
<td>
<p>A <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> object.</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_vp">vp</code></td>
<td>
<p>A <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="isocubeGrob_+3A_...">...</code></td>
<td>
<p>Passed to <code>isocubeGrob()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>ggplot2</code> objects are coerced to grobs by <code><a href="ggplot2.html#topic+ggplotGrob">ggplot2::ggplotGrob()</a></code>.  Depending on what you'd like
to do you may want to instead manually convert a ggplot2 object <code>gg</code> to a grob with <code>gtable::gtable_filter(ggplot2::ggplotGrob(gg), "panel")</code>.
</p>
<p>Not all graphics devices provided by <code>grDevices</code> or other R packages support the <a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html">affine transformation feature introduced in R 4.2</a>.
If <code>isTRUE(getRversion() &gt;= '4.2.0')</code> then the active graphics device should support this feature if <code>isTRUE(grDevices::dev.capabilities()$transformations)</code>.
In particular the following graphics devices should support the affine transformation feature:
</p>

<ul>
<li><p> R's <code><a href="grDevices.html#topic+pdf">grDevices::pdf()</a></code> device
</p>
</li>
<li><p> R's 'cairo' devices e.g. <code><a href="grDevices.html#topic+cairo">grDevices::cairo_pdf()</a></code>, <code>grDevices::png(type = 'cairo')</code>, <code><a href="grDevices.html#topic+cairo">grDevices::svg()</a></code>, <code>grDevices::x11(type = 'cairo')</code>, etc. If <code>isTRUE(capabilities('cairo'))</code> then R was compiled with support for the 'cairo' devices .
</p>
</li>
<li><p> R's 'quartz' devices (since R 4.3.0) e.g. <code><a href="grDevices.html#topic+quartz">grDevices::quartz()</a></code>, <code>grDevices::png(type = 'quartz')</code>, etc. If <code>isTRUE(capabilities('aqua'))</code> then R was compiled with support for the 'quartz' devices (generally only <code>TRUE</code> on macOS systems).
</p>
</li>
<li> <p><code>ragg</code>'s devices (since v1.3.0) e.g. <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code>, <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>, etc.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="grid.html#topic+grid.grob">grid::gTree()</a></code> (grob) object of class &quot;isocube&quot;.
As a side effect <code>grid.isocube()</code> draws to the active graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
  # Only works if active graphics device supports affine transformations
  # such as `png(type="cairo")` on R 4.2+
  grid.newpage()
  gp_text &lt;- gpar(fontsize = 72)
  grid.isocube(top = textGrob("top", gp = gp_text), 
               right = textGrob("right", gp = gp_text),
               left = textGrob("left", gp = gp_text))
}
if (require("grid") &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)) {
    colors &lt;- c("#D55E00", "#009E73", "#56B4E9")
    spacings &lt;- c(0.25, 0.2, 0.25)
    texts &lt;- c("pkgname", "left\nface", "right\nface")
    rots &lt;- c(45, 0, 0)
    fontsizes &lt;- c(52, 80, 80)
    sides &lt;- c("top", "left", "right")
    types &lt;- gridpattern::names_polygon_tiling[c(5, 7, 9)]
    l_grobs &lt;- list()
    grid.newpage()
    for (i in 1:3) {
        if (requireNamespace("gridpattern", quietly = TRUE)) {
            bg &lt;- gridpattern::grid.pattern_polygon_tiling(
                       colour = "grey80",
                       fill = c(colors[i], "white"),
                       type = types[i],
                       spacing = spacings[i],
                       draw = FALSE)
        } else {
            bg &lt;- rectGrob(gp = gpar(col = NA, fill = colors[i]))
        }
        text &lt;- textGrob(texts[i], rot = rots[i],
                         gp = gpar(fontsize = fontsizes[i]))
        l_grobs[[sides[i]]] &lt;- grobTree(bg, text)
    }
  grid.newpage()
  grid.isocube(top = l_grobs$top, 
               right = l_grobs$right,
               left = l_grobs$left)
}
# May take more than 5 seconds on CRAN machines
if (require("aRtsy") &amp;&amp;
    require("grid") &amp;&amp;
    require("ggplot2") &amp;&amp;
    requireNamespace("gtable", quietly = TRUE) &amp;&amp;
    getRversion() &gt;= "4.2.0" &amp;&amp;
    isTRUE(dev.capabilities()$transformations)
    ) {
  gg &lt;- canvas_planet(colorPalette("lava"), threshold = 3) +
    scale_x_continuous(expand=c(0, 0)) +
    scale_y_continuous(expand=c(0, 0))
grob &lt;- ggplotGrob(gg)
grob &lt;- gtable::gtable_filter(grob, "panel") # grab just the panel
grid.newpage()
grid.isocube(top = grob, left = grob, right = grob,
             gp_border = grid::gpar(col = "darkorange", lwd = 12))

}

</code></pre>

<hr>
<h2 id='Line2D'>2D lines R6 Class</h2><span id='topic+Line2D'></span>

<h3>Description</h3>

<p><code>Line2D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing two-dimensional lines.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
<dt><code>c</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Line2D-new"><code>Line2D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Line2D-print"><code>Line2D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Line2D-clone"><code>Line2D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Line2D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Line2D$new(a, b, c)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
<dt><code>c</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b * y + c = 0</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Line2D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Line2D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of lines to print.  If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Line2D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line2D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as_coord2d(x = 5, y = 10)
p2 &lt;- as_coord2d(x = 7, y = 12)
theta &lt;- degrees(45)
as_line2d(theta, p1)
as_line2d(p1, p2)
</code></pre>

<hr>
<h2 id='normal2d'>2D normal vectors</h2><span id='topic+normal2d'></span><span id='topic+normal2d.Coord2D'></span><span id='topic+normal2d.Line2D'></span>

<h3>Description</h3>

<p><code>normal2d()</code> is an S3 generic that computes a 2D normal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal2d(x, ...)

## S3 method for class 'Coord2D'
normal2d(x, ..., normalize = TRUE)

## S3 method for class 'Line2D'
normal2d(x, ..., normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal2d_+3A_x">x</code></td>
<td>
<p>Object to compute a 2D normal vector for
such as a <a href="#topic+Line2D">Line2D</a> object.</p>
</td></tr>
<tr><td><code id="normal2d_+3A_...">...</code></td>
<td>
<p>Passed to or from other methods.</p>
</td></tr>
<tr><td><code id="normal2d_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> coerce to a normalize vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord2D">Coord2D</a> (normal) vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  p &lt;- as_coord2d(x = 2, y = 3)
  normal2d(p)
  normal2d(p, normalize = FALSE)
</code></pre>

<hr>
<h2 id='normal3d'>3D normal vectors</h2><span id='topic+normal3d'></span><span id='topic+normal3d.Coord3D'></span><span id='topic+normal3d.character'></span><span id='topic+normal3d.Plane3D'></span>

<h3>Description</h3>

<p><code>normal3d()</code> is an S3 generic that computes a 3D normal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal3d(x, ...)

## S3 method for class 'Coord3D'
normal3d(x, cross, ..., normalize = TRUE)

## S3 method for class 'character'
normal3d(x, ..., normalize = TRUE)

## S3 method for class 'Plane3D'
normal3d(x, ..., normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal3d_+3A_x">x</code></td>
<td>
<p>Object to compute a 3D normal vector for
such as a <a href="#topic+Plane3D">Plane3D</a> object</p>
</td></tr>
<tr><td><code id="normal3d_+3A_...">...</code></td>
<td>
<p>Passed to other methods such as <code><a href="#topic+as_coord3d">as_coord3d()</a></code>.</p>
</td></tr>
<tr><td><code id="normal3d_+3A_cross">cross</code></td>
<td>
<p>A <a href="#topic+Coord3D">Coord3D</a> vector.
We'll compute the normal of <code>x</code> and <code>cross</code> by taking their cross product.</p>
</td></tr>
<tr><td><code id="normal3d_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> normalize to a unit vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Coord3D">Coord3D</a> (normal) vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal3d("xy-plane")
normal3d(as_coord3d(2, 0, 0), cross = as_coord3d(0, 2, 0))
</code></pre>

<hr>
<h2 id='Plane3D'>3D planes R6 Class</h2><span id='topic+Plane3D'></span>

<h3>Description</h3>

<p><code>Plane3D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing three-dimensional planes.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>c</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>d</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Plane3D-new"><code>Plane3D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Plane3D-print"><code>Plane3D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Plane3D-clone"><code>Plane3D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Plane3D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Plane3D$new(a, b, c, d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>c</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
<dt><code>d</code></dt><dd><p>Numeric vector that parameterizes the plane via the equation <code>a * x + b * y + c * z + d = 0</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plane3D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Plane3D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of lines to print.  If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plane3D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plane3D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Point1D'>1D points R6 Class</h2><span id='topic+Point1D'></span>

<h3>Description</h3>

<p><code>Point1D</code> is an <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code> object representing one-dimensional points.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the point via the equation <code>a * x + b = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the point via the equation <code>a * x + b = 0</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Point1D-new"><code>Point1D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Point1D-print"><code>Point1D$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Point1D-clone"><code>Point1D$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Point1D-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Point1D$new(a, b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b = 0</code>.</p>
</dd>
<dt><code>b</code></dt><dd><p>Numeric vector that parameterizes the line via the equation <code>a * x + b = 0</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Point1D-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Point1D$print(n = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of lines to print.  If <code>NULL</code> print all of them.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code><a href="base.html#topic+format.default">format.default()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Point1D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Point1D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as_point1d(a = 1, b = 5)
</code></pre>

<hr>
<h2 id='rotate3d_to_AA'>Convert from 3D rotation matrix to axis-angle representation.</h2><span id='topic+rotate3d_to_AA'></span>

<h3>Description</h3>

<p><code>rotate3d_to_AA()</code> converts from (post-multiplied) rotation matrix
to an axis-angle representation of 3D rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate3d_to_AA(
  mat = diag(4),
  unit = getOption("affiner_angular_unit", "degrees")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate3d_to_AA_+3A_mat">mat</code></td>
<td>
<p>3D rotation matrix (post-multiplied).
If you have a pre-multiplied rotation matrix
simply transpose it with <code><a href="base.html#topic+t">t()</a></code> to get a post-multiplied rotation matrix.</p>
</td></tr>
<tr><td><code id="rotate3d_to_AA_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://en.wikipedia.org/wiki/Axis-angle_representation">https://en.wikipedia.org/wiki/Axis-angle_representation</a> for more details
about the Axis-angle representation of 3D rotations.
<code><a href="#topic+rotate3d">rotate3d()</a></code> can be used to convert from an axis-angle representation to a rotation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # axis-angle representation of 90 degree rotation about the x-axis
 rotate3d_to_AA(rotate3d("x-axis", 90, unit = "degrees"))

 # find Axis-Angle representation of first rotating about x-axis 180 degrees
 # and then rotating about z-axis 45 degrees
 R &lt;- rotate3d("x-axis", 180, unit = "degrees") %*%
        rotate3d("z-axis", 45, unit = "degrees")
 AA &lt;- rotate3d_to_AA(R)

 # Can use `rotate3d()` to convert back to rotation matrix representation
 all.equal(R, do.call(rotate3d, AA))

</code></pre>

<hr>
<h2 id='transform1d'>1D affine transformation matrices</h2><span id='topic+transform1d'></span><span id='topic+project1d'></span><span id='topic+reflect1d'></span><span id='topic+scale1d'></span><span id='topic+translate1d'></span>

<h3>Description</h3>

<p><code>transform1d()</code>, <code>reflect1d()</code>, <code>scale2d()</code>,
and <code>translate1d()</code> create 1D affine transformation matrix objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform1d(mat = diag(2L))

project1d(point = as_point1d("origin"), ...)

reflect1d(point = as_point1d("origin"), ...)

scale1d(x_scale = 1)

translate1d(x = as_coord1d(0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform1d_+3A_mat">mat</code></td>
<td>
<p>A 2x2 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 1x1 matrix we'll quietly add a final column/row equal to <code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="transform1d_+3A_point">point</code></td>
<td>
<p>A <a href="#topic+Point1D">Point1D</a> object of length one representing the point
you with to reflect across or project to or an object coercible to one by <code>as_point1d(point, ...)</code>
such as &quot;origin&quot;.</p>
</td></tr>
<tr><td><code id="transform1d_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+as_coord1d">as_coord1d()</a></code>.</p>
</td></tr>
<tr><td><code id="transform1d_+3A_x_scale">x_scale</code></td>
<td>
<p>Scaling factor to apply to x coordinates</p>
</td></tr>
<tr><td><code id="transform1d_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord1D">Coord1D</a> object of length one or an object coercible to one by <code>as_coord1d(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>transform1d()</code></dt><dd><p>User supplied (post-multiplied) affine transformation matrix</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>reflect1d()</code></dt><dd><p>Reflections across a point.</p>
</dd>
<dt><code>scale1d()</code></dt><dd><p>Scale the x-coordinates by multiplicative scale factors.</p>
</dd>
<dt><code>translate1d()</code></dt><dd><p>Translate the coordinates by a <a href="#topic+Coord1D">Coord1D</a> class object parameter.</p>
</dd>
</dl>

<p><code>transform1d()</code> 1D affine transformation matrix objects are meant to be
post-multiplied and therefore should <strong>not</strong> be multiplied in reverse order.
Note the <a href="#topic+Coord1D">Coord1D</a> class object methods auto-pre-multiply affine transformations
when &quot;method chaining&quot; so pre-multiplying affine transformation matrices
to do a single cumulative transformation instead of a method chain of multiple transformations
will not improve performance as much as as it does in other R packages.
</p>
<p>To convert a pre-multiplied 1D affine transformation matrix to a post-multiplied one
simply compute its transpose using <code><a href="base.html#topic+t">t()</a></code>.  To get an inverse transformation matrix
from an existing transformation matrix that does the opposite transformations
simply compute its inverse using <code><a href="base.html#topic+solve">solve()</a></code>.
</p>


<h3>Value</h3>

<p>A 2x2 post-multiplied affine transformation matrix with classes &quot;transform1d&quot; and &quot;at_matrix&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord1d(x = sample(1:10, 3))

# {affiner} affine transformation matrices are post-multiplied
# and therefore should **not** go in reverse order
mat &lt;- transform1d(diag(2)) %*%
         scale1d(2) %*%
         translate1d(x = -1)
p1 &lt;- p$
  clone()$
  transform(mat)

# The equivalent result appyling affine transformations via method chaining
p2 &lt;- p$
  clone()$
  transform(diag(2))$
  scale(2)$
  translate(x = -1)

all.equal(p1, p2)
</code></pre>

<hr>
<h2 id='transform2d'>2D affine transformation matrices</h2><span id='topic+transform2d'></span><span id='topic+permute2d'></span><span id='topic+project2d'></span><span id='topic+reflect2d'></span><span id='topic+rotate2d'></span><span id='topic+scale2d'></span><span id='topic+shear2d'></span><span id='topic+translate2d'></span>

<h3>Description</h3>

<p><code>transform2d()</code>, <code>project2d()</code>, <code>reflect2d()</code>, <code>rotate2d()</code>, <code>scale2d()</code>, <code>shear2d()</code>,
and <code>translate2d()</code> create 2D affine transformation matrix objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform2d(mat = diag(3L))

permute2d(permutation = c("xy", "yx"))

project2d(line = as_line2d("x-axis"), ..., scale = 0)

reflect2d(line = as_line2d("x-axis"), ...)

rotate2d(theta = angle(0), ...)

scale2d(x_scale = 1, y_scale = x_scale)

shear2d(xy_shear = 0, yx_shear = 0)

translate2d(x = as_coord2d(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform2d_+3A_mat">mat</code></td>
<td>
<p>A 3x3 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 2x2 matrix (such as a 2x2 post-multiplied 2D rotation matrix)
we'll quietly add a final column/row equal to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="transform2d_+3A_permutation">permutation</code></td>
<td>
<p>Either &quot;xy&quot; (no permutation) or &quot;yx&quot; (permute x and y axes)</p>
</td></tr>
<tr><td><code id="transform2d_+3A_line">line</code></td>
<td>
<p>A <a href="#topic+Line2D">Line2D</a> object of length one representing the line
you with to reflect across or project to or an object coercible to one by <code>as_line2d(line, ...)</code>
such as &quot;x-axis&quot; or &quot;y-axis&quot;.</p>
</td></tr>
<tr><td><code id="transform2d_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+as_angle">as_angle()</a></code> or <code><a href="#topic+as_coord2d">as_coord2d()</a></code>.</p>
</td></tr>
<tr><td><code id="transform2d_+3A_scale">scale</code></td>
<td>
<p>Oblique projection scale factor.
A degenerate <code>0</code> value indicates an orthogonal projection.</p>
</td></tr>
<tr><td><code id="transform2d_+3A_theta">theta</code></td>
<td>
<p>An <code><a href="#topic+angle">angle()</a></code> object of length one or an object coercible to one by <code>as_angle(theta, ...)</code>.</p>
</td></tr>
<tr><td><code id="transform2d_+3A_x_scale">x_scale</code></td>
<td>
<p>Scaling factor to apply to x coordinates</p>
</td></tr>
<tr><td><code id="transform2d_+3A_y_scale">y_scale</code></td>
<td>
<p>Scaling factor to apply to y coordinates</p>
</td></tr>
<tr><td><code id="transform2d_+3A_xy_shear">xy_shear</code></td>
<td>
<p>Horizontal shear factor: <code>x = x + xy_shear * y</code></p>
</td></tr>
<tr><td><code id="transform2d_+3A_yx_shear">yx_shear</code></td>
<td>
<p>Vertical shear factor: <code>y = yx_shear * x + y</code></p>
</td></tr>
<tr><td><code id="transform2d_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord2D">Coord2D</a> object of length one or an object coercible to one by <code>as_coord2d(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>transform2d()</code></dt><dd><p>User supplied (post-multiplied) affine transformation matrix</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>project2d()</code></dt><dd><p>Oblique vector projections onto a line parameterized by
an oblique projection scale factor.
A (degenerate) scale factor of zero results in an orthogonal projection.</p>
</dd>
<dt><code>reflect2d()</code></dt><dd><p>Reflections across a line.
To &quot;flip&quot; across both the x-axis and the y-axis use <code>scale2d(-1)</code>.</p>
</dd>
<dt><code>rotate2d()</code></dt><dd><p>Rotations around the origin parameterized by an <code><a href="#topic+angle">angle()</a></code>.</p>
</dd>
<dt><code>scale2d()</code></dt><dd><p>Scale the x-coordinates and/or the y-coordinates by multiplicative scale factors.</p>
</dd>
<dt><code>shear2d()</code></dt><dd><p>Shear the x-coordinates and/or the y-coordinates using shear factors.</p>
</dd>
<dt><code>translate2d()</code></dt><dd><p>Translate the coordinates by a <a href="#topic+Coord2D">Coord2D</a> class object parameter.</p>
</dd>
</dl>

<p><code>transform2d()</code> 2D affine transformation matrix objects are meant to be
post-multiplied and therefore should <strong>not</strong> be multiplied in reverse order.
Note the <a href="#topic+Coord2D">Coord2D</a> class object methods auto-pre-multiply affine transformations
when &quot;method chaining&quot; so pre-multiplying affine transformation matrices
to do a single cumulative transformation instead of a method chain of multiple transformations
will not improve performance as much as as it does in other R packages.
</p>
<p>To convert a pre-multiplied 2D affine transformation matrix to a post-multiplied one
simply compute its transpose using <code><a href="base.html#topic+t">t()</a></code>.  To get an inverse transformation matrix
from an existing transformation matrix that does the opposite transformations
simply compute its inverse using <code><a href="base.html#topic+solve">solve()</a></code>.
</p>


<h3>Value</h3>

<p>A 3x3 post-multiplied affine transformation matrix with classes &quot;transform2d&quot; and &quot;at_matrix&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord2d(x = sample(1:10, 3), y = sample(1:10, 3))

# {affiner} affine transformation matrices are post-multiplied
# and therefore should **not** go in reverse order
mat &lt;- transform2d(diag(3)) %*%
         reflect2d(as_coord2d(-1, 1)) %*%
         rotate2d(90, "degrees") %*%
         scale2d(1, 2) %*%
         shear2d(0.5, 0.5) %*%
         translate2d(x = -1, y = -1)
p1 &lt;- p$
  clone()$
  transform(mat)

# The equivalent result appyling affine transformations via method chaining
p2 &lt;- p$
  clone()$
  transform(diag(3L))$
  reflect(as_coord2d(-1, 1))$
  rotate(90, "degrees")$
  scale(1, 2)$
  shear(0.5, 0.5)$
  translate(x = -1, y = -1)

all.equal(p1, p2)

</code></pre>

<hr>
<h2 id='transform3d'>3D affine transformation matrices</h2><span id='topic+transform3d'></span><span id='topic+permute3d'></span><span id='topic+project3d'></span><span id='topic+reflect3d'></span><span id='topic+rotate3d'></span><span id='topic+scale3d'></span><span id='topic+shear3d'></span><span id='topic+translate3d'></span>

<h3>Description</h3>

<p><code>transform3d()</code>, <code>project3d()</code>, <code>reflect3d()</code>, <code>rotate3d()</code>, <code>scale3d()</code>, <code>shear3d()</code>,
and <code>translate3d()</code> create 3D affine transformation matrix objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform3d(mat = diag(4L))

permute3d(permutation = c("xyz", "xzy", "yxz", "yzx", "zyx", "zxy"))

project3d(
  plane = as_plane3d("xy-plane"),
  ...,
  scale = 0,
  alpha = angle(45, "degrees")
)

reflect3d(plane = as_plane3d("xy-plane"), ...)

rotate3d(axis = as_coord3d("z-axis"), theta = angle(0), ...)

scale3d(x_scale = 1, y_scale = x_scale, z_scale = x_scale)

shear3d(
  xy_shear = 0,
  xz_shear = 0,
  yx_shear = 0,
  yz_shear = 0,
  zx_shear = 0,
  zy_shear = 0
)

translate3d(x = as_coord3d(0, 0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform3d_+3A_mat">mat</code></td>
<td>
<p>A 4x4 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 0, 0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 0, 0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 3x3 matrix (such as a 3x3 post-multiplied 3D rotation matrix)
we'll quietly add a final column/row equal to <code>c(0, 0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_permutation">permutation</code></td>
<td>
<p>Either &quot;xyz&quot; (no permutation), &quot;xzy&quot; (permute y and z axes),
&quot;yxz&quot; (permute x and y axes), &quot;yzx&quot; (x becomes z, y becomes x, z becomes y),
&quot;zxy&quot; (x becomes y, y becomes z, z becomes x), &quot;zyx&quot; (permute x and z axes)</p>
</td></tr>
<tr><td><code id="transform3d_+3A_plane">plane</code></td>
<td>
<p>A <a href="#topic+Plane3D">Plane3D</a> object of length one representing the plane
you wish to reflect across or project to or an object coercible to one using <code>as_plane3d(plane, ...)</code>
such as &quot;xy-plane&quot;, &quot;xz-plane&quot;, or &quot;yz-plane&quot;.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+as_angle">as_angle()</a></code> or <code><a href="#topic+as_coord3d">as_coord3d()</a></code>.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening scale factor.
A (degenerate) <code>0</code> value indicates an orthographic projection.
A value of <code>0.5</code> is used by a &ldquo;cabinet projection&rdquo;
while a value of <code>1.0</code> is used by a &ldquo;cavalier projection&rdquo;.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_alpha">alpha</code></td>
<td>
<p>Oblique projection angle (the angle the third axis is projected going off at).
An <code><a href="#topic+angle">angle()</a></code> object or one coercible to one with <code>as_angle(alpha, ...)</code>.
Popular angles are 45 degrees, 60 degrees, and <code>arctangent(2)</code> degrees.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_axis">axis</code></td>
<td>
<p>A <a href="#topic+Coord3D">Coord3D</a> class object or one that can coerced to one by <code>as_coord3d(axis, ...)</code>.
The <code>axis</code> represents the axis to be rotated around.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_theta">theta</code></td>
<td>
<p>An <code><a href="#topic+angle">angle()</a></code> object of length one or an object coercible to one by <code>as_angle(theta, ...)</code>.</p>
</td></tr>
<tr><td><code id="transform3d_+3A_x_scale">x_scale</code></td>
<td>
<p>Scaling factor to apply to x coordinates</p>
</td></tr>
<tr><td><code id="transform3d_+3A_y_scale">y_scale</code></td>
<td>
<p>Scaling factor to apply to y coordinates</p>
</td></tr>
<tr><td><code id="transform3d_+3A_z_scale">z_scale</code></td>
<td>
<p>Scaling factor to apply to z coordinates</p>
</td></tr>
<tr><td><code id="transform3d_+3A_xy_shear">xy_shear</code></td>
<td>
<p>Shear factor: <code>x = x + xy_shear * y + xz_shear * z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_xz_shear">xz_shear</code></td>
<td>
<p>Shear factor: <code>x = x + xy_shear * y + xz_shear * z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_yx_shear">yx_shear</code></td>
<td>
<p>Shear factor: <code>y = yx_shear * x + y + yz_shear * z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_yz_shear">yz_shear</code></td>
<td>
<p>Shear factor: <code>y = yx_shear * x + y + yz_shear * z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_zx_shear">zx_shear</code></td>
<td>
<p>Shear factor: <code>z = zx_shear * x + zy_shear * y + z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_zy_shear">zy_shear</code></td>
<td>
<p>Shear factor: <code>z = zx_shear * x + zy_shear * y + z</code></p>
</td></tr>
<tr><td><code id="transform3d_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Coord3D">Coord3D</a> object of length one or an object coercible to one by <code>as_coord3d(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>transform3d()</code></dt><dd><p>User supplied (post-multiplied) affine transformation matrix</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>scale3d()</code></dt><dd><p>Scale the x-coordinates and/or the y-coordinates and/or the z-coordinates
by multiplicative scale factors.</p>
</dd>
<dt><code>shear3d()</code></dt><dd><p>Shear the x-coordinates and/or the y-coordinates
and/or the z-coordinates using shear factors.</p>
</dd>
<dt><code>translate3d()</code></dt><dd><p>Translate the coordinates by a <a href="#topic+Coord3D">Coord3D</a> class object parameter.</p>
</dd>
</dl>

<p><code>transform3d()</code> 3D affine transformation matrix objects are meant to be
post-multiplied and therefore should <strong>not</strong> be multiplied in reverse order.
Note the <a href="#topic+Coord3D">Coord3D</a> class object methods auto-pre-multiply affine transformations
when &quot;method chaining&quot; so pre-multiplying affine transformation matrices
to do a single cumulative transformation instead of a method chain of multiple transformations
will not improve performance as much as as it does in other R packages.
</p>
<p>To convert a pre-multiplied 3D affine transformation matrix to a post-multiplied one
simply compute its transpose using <code><a href="base.html#topic+t">t()</a></code>.  To get an inverse transformation matrix
from an existing transformation matrix that does the opposite transformations
simply compute its inverse using <code><a href="base.html#topic+solve">solve()</a></code>.
</p>


<h3>Value</h3>

<p>A 4x4 post-multiplied affine transformation matrix with classes &quot;transform3d&quot; and &quot;at_matrix&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as_coord3d(x = sample(1:10, 3), y = sample(1:10, 3), z = sample(1:10, 3))

# {affiner} affine transformation matrices are post-multiplied
# and therefore should **not** go in reverse order
mat &lt;- transform3d(diag(4L)) %*%
         rotate3d("z-axis", degrees(90)) %*%
         scale3d(1, 2, 1) %*%
         translate3d(x = -1, y = -1, z = -1)
p1 &lt;- p$
  clone()$
  transform(mat)

# The equivalent result appyling affine transformations via method chaining
p2 &lt;- p$
  clone()$
  transform(diag(4L))$
  rotate("z-axis", degrees(90))$
  scale(1, 2, 1)$
  translate(x = -1, y = -1, z = -1)

all.equal(p1, p2)

</code></pre>

<hr>
<h2 id='trigonometric-functions'>Angle vector aware trigonometric functions</h2><span id='topic+trigonometric-functions'></span><span id='topic+sine'></span><span id='topic+cosine'></span><span id='topic+tangent'></span><span id='topic+secant'></span><span id='topic+cosecant'></span><span id='topic+cotangent'></span>

<h3>Description</h3>

<p><code>sine()</code>, <code>cosine()</code>, <code>tangent()</code>, <code>secant()</code>, <code>cosecant()</code>, and <code>cotangent()</code> are
<code><a href="#topic+angle">angle()</a></code> aware trigonometric functions that allow for a user chosen angular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine(x, unit = getOption("affiner_angular_unit", "degrees"))

cosine(x, unit = getOption("affiner_angular_unit", "degrees"))

tangent(x, unit = getOption("affiner_angular_unit", "degrees"))

secant(x, unit = getOption("affiner_angular_unit", "degrees"))

cosecant(x, unit = getOption("affiner_angular_unit", "degrees"))

cotangent(x, unit = getOption("affiner_angular_unit", "degrees"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trigonometric-functions_+3A_x">x</code></td>
<td>
<p>An angle vector or an object to convert to it (such as a numeric vector)</p>
</td></tr>
<tr><td><code id="trigonometric-functions_+3A_unit">unit</code></td>
<td>
<p>A string of the desired angular unit.  Supports the following strings
(note we ignore any punctuation and space characters as well as any trailing <code>s</code>'s
e.g. &quot;half turns&quot; will be treated as equivalent to &quot;halfturn&quot;):
</p>

<ul>
<li><p> &quot;deg&quot; or &quot;degree&quot;
</p>
</li>
<li><p> &quot;half-revolution&quot;, &quot;half-turn&quot;, or &quot;pi-radian&quot;
</p>
</li>
<li><p> &quot;gon&quot;, &quot;grad&quot;, &quot;grade&quot;, or &quot;gradian&quot;
</p>
</li>
<li><p> &quot;rad&quot; or &quot;radian&quot;
</p>
</li>
<li><p> &quot;rev&quot;, &quot;revolution&quot;, &quot;tr&quot;, or &quot;turn&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sine(pi, "radians")
cosine(180, "degrees")
tangent(0.5, "turns")

a &lt;- angle(0.5, "turns")
secant(a)
cosecant(a)
cotangent(a)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
