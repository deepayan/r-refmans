<!DOCTYPE html><html><head><title>Help for package samr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {samr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#runSAM'><p>Run the sam webapp</p></a></li>
<li><a href='#SAM'><p>Significance analysis of microarrays - simple user interface</p></a></li>
<li><a href='#samr'><p>Significance analysis of microarrays</p></a></li>
<li><a href='#samr-internal'><p>Internal samr functions</p></a></li>
<li><a href='#samr.assess.samplesize'><p>Assess the sample size for a SAM analysis</p></a></li>
<li><a href='#samr.assess.samplesize.plot'><p>Make a plot of the results from samr.assess.samplesize</p></a></li>
<li><a href='#samr.compute.delta.table'><p>Compute delta table for SAM analysis</p></a></li>
<li><a href='#samr.compute.siggenes.table'><p>Compute significant genes table</p></a></li>
<li><a href='#samr.estimate.depth'><p>estimate the sequencing depth</p></a></li>
<li><a href='#samr.missrate'><p>Estimate the  miss rate table for a SAM analysis</p></a></li>
<li><a href='#samr.norm.data'><p>output normalized sequencing data</p></a></li>
<li><a href='#samr.plot'><p>Make Q-Q plot for SAM analysis</p></a></li>
<li><a href='#samr.pvalues.from.perms'><p>Report estimated p-values for each gene, from a  SAM analysis</p></a></li>
<li><a href='#samr.tail.strength'><p>Estimate tail strength for a dataset, from a SAM analysis</p></a></li>
<li><a href='#SAMseq'><p>Significance analysis of sequencing data - simple user interface</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>SAM: Significance Analysis of Microarrays</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Author:</td>
<td>R. Tibshirani, Michael J. Seo, G. Chu, Balasubramanian Narasimhan, Jun Li</td>
</tr>
<tr>
<td>Description:</td>
<td>Significance Analysis of Microarrays for differential expression analysis, RNAseq data and related problems.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Tibshirani &lt;tibs@stanford.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>impute, matrixStats, shiny, shinyFiles, openxlsx, GSA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statweb.stanford.edu/~tibs/SAM">https://statweb.stanford.edu/~tibs/SAM</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-16 00:56:47 UTC; tibs</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-16 10:00:03 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='runSAM'>Run the sam webapp</h2><span id='topic+runSAM'></span>

<h3>Description</h3>

<p>Runs the sam web application for a graphical user interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSAM()
</code></pre>


<h3>Details</h3>

<p>Uses shiny to create a graphical user interface for SAM</p>


<h3>Author(s)</h3>

<p>Michael J. Seo</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001):
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: runSAM()
</code></pre>

<hr>
<h2 id='SAM'>Significance analysis of microarrays - simple user interface</h2><span id='topic+SAM'></span>

<h3>Description</h3>

<p>Correlates a large number of features (eg genes) with an outcome
variable, such as a group indicator, quantitative variable or survival time.
This is a simple user interface for the samr function applied to array data.
For sequencing data applications, see the function SAMseq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAM(x,y=NULL,censoring.status=NULL,
resp.type=c("Quantitative","Two class unpaired","Survival","Multiclass",
"One class", "Two class paired","Two class unpaired timecourse",
"One class timecourse","Two class paired timecourse", "Pattern discovery"),
geneid = NULL,
genenames = NULL,
s0=NULL, 
s0.perc=NULL, 
nperms=100, 
center.arrays=FALSE, 
testStatistic=c("standard","wilcoxon"), 
time.summary.type=c("slope","signed.area"), 
regression.method=c("standard","ranks"), 
return.x=TRUE, 
knn.neighbors=10, 
random.seed=NULL,
logged2 = FALSE,
fdr.output = 0.20,
eigengene.number = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SAM_+3A_x">x</code></td>
<td>
<p>Feature matrix: p (number of features) by n (number of samples),
one observation per column (missing values allowed)</p>
</td></tr>
<tr><td><code id="SAM_+3A_y">y</code></td>
<td>
<p>n-vector of outcome measurements</p>
</td></tr>
<tr><td><code id="SAM_+3A_censoring.status">censoring.status</code></td>
<td>
<p>n-vector of censoring censoring.status (1= died or event occurred, 0=survived, or event was censored), needed for a censored survival outcome</p>
</td></tr>
<tr><td><code id="SAM_+3A_resp.type">resp.type</code></td>
<td>
<p>Problem type:
&quot;Quantitative&quot; for a continuous parameter;
&quot;Two class unpaired&quot;; 
&quot;Survival&quot; for censored survival outcome; 
&quot;Multiclass&quot;: more than 2 groups;  
&quot;One class&quot; for a single group; 
&quot;Two class paired&quot; for two classes with paired observations;
&quot;Two class unpaired timecourse&quot;, 
&quot;One class time course&quot;,
&quot;Two class.paired timecourse&quot;,
&quot;Pattern discovery&quot;</p>
</td></tr>
<tr><td><code id="SAM_+3A_geneid">geneid</code></td>
<td>
<p>Optional character vector of geneids for output.</p>
</td></tr>
<tr><td><code id="SAM_+3A_genenames">genenames</code></td>
<td>
<p>Optional character vector of genenames for output.</p>
</td></tr>
<tr><td><code id="SAM_+3A_s0">s0</code></td>
<td>
<p>Exchangeability factor  for denominator of test statistic; Default
is automatic choice. Only used for array data.</p>
</td></tr>
<tr><td><code id="SAM_+3A_s0.perc">s0.perc</code></td>
<td>
<p>Percentile of standard  deviation values to use for s0; default is
automatic choice; -1 means s0=0 (different from s0.perc=0, meaning
s0=zeroeth percentile of  standard  deviation values= min of sd values.
Only used for array data.</p>
</td></tr>
<tr><td><code id="SAM_+3A_nperms">nperms</code></td>
<td>
<p>Number of permutations used to estimate false discovery rates</p>
</td></tr>
<tr><td><code id="SAM_+3A_center.arrays">center.arrays</code></td>
<td>
<p>Should the data for each sample (array) be median centered
at the outset? Default =FALSE. Only used for array data.</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="SAM_+3A_teststatistic">testStatistic</code></td>
<td>
<p>Test statistic to use in two class unpaired case.Either
&quot;standard&quot; (t-statistic) or ,&quot;wilcoxon&quot; (Two-sample wilcoxon or Mann-Whitney
test). Only used for array data.</p>
</td></tr> 
<tr><td><code id="SAM_+3A_time.summary.type">time.summary.type</code></td>
<td>
<p>Summary measure for each time course: &quot;slope&quot;, or &quot;signed.area&quot;). Only used for array data.</p>
</td></tr> 
<tr><td><code id="SAM_+3A_regression.method">regression.method</code></td>
<td>
<p>Regression method for quantitative case:
&quot;standard&quot;, (linear least squares) or &quot;ranks&quot; (linear least squares 
on ranked data). Only used for array data.</p>
</td></tr>
<tr><td><code id="SAM_+3A_return.x">return.x</code></td>
<td>
<p>Should the matrix of feature values be returned?
Only useful for time course data, where x contains summaries of the features
over time. Otherwise x is the same as the input data data\$x</p>
</td></tr>
<tr><td><code id="SAM_+3A_knn.neighbors">knn.neighbors</code></td>
<td>
<p>Number of nearest neighbors to use for imputation
of missing features values. Only used for array data.</p>
</td></tr>
<tr><td><code id="SAM_+3A_random.seed">random.seed</code></td>
<td>
<p>Optional initial seed for random number generator (integer)</p>
</td></tr>
<tr><td><code id="SAM_+3A_logged2">logged2</code></td>
<td>
<p>Has the data been transformed by log (base 2)? This information is used only 
for computing fold changes </p>
</td></tr>
<tr><td><code id="SAM_+3A_fdr.output">fdr.output</code></td>
<td>
<p>(Approximate) False Discovery Rate cutoff for output in significant genes table</p>
</td></tr>
<tr><td><code id="SAM_+3A_eigengene.number">eigengene.number</code></td>
<td>
<p>Eigengene to be used  (just for resp.type=&quot;Pattern discovery&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple, user-friendly interface to the samr package used on array data.
It calls samr, samr.compute.delta.table and samr.compute.siggenes.table.
samr detects differential expression for  microarray data,
and sequencing data,
and other data with a large number of features. samr is the R package
that is called by the &quot;official&quot; SAM Excel Addin.
The format of the response vector y and the calling sequence
is illustrated in the examples below. A more complete  description
is given in the SAM manual
at http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>samr.obj</code></td>
<td>
<p>Output of samr. See documentation for samr for details.</p>
</td></tr>
<tr><td><code>siggenes.table</code></td>
<td>
<p>Table of significant genes, output of  samr.compute.siggenes.table.
This has components: genes.up&mdash; matrix of significant genes having positive correlation with the outcome and
genes.lo&mdash;matrix of significant genes having negative correlation with the outcome.
For survival data, genes.up are those genes having positive correlation with risk-
that is, increased expression corresponds to higher risk (shorter survival)
genes.lo are those whose increased expression corresponds to lower risk (longer survival).</p>
</td></tr>
<tr><td><code>delta.table</code></td>
<td>
<p>Output of  samr.compute.delta.table.</p>
</td></tr>
<tr><td><code>del</code></td>
<td>
<p>Value of delta (distance from 45 degree line in SAM plot) for 
used for creating delta.table and siggenes.table. Changing the input value fdr.output
will change the resulting del.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The calling sequence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response  PNAS 2001 98: 5116-5121, (Apr 24). 
http://www-stat.stanford.edu/~tibs/SAM
</p>
<p>Li, Jun and Tibshirani, R. (2011). Finding consistent patterns: a nonparametric
approach for identifying differential expression in
RNA-Seq data. To appear, Statistical Methods in Medical Research.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######### two class unpaired comparison
# y must take values 1,2

set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u
y&lt;-c(rep(1,10),rep(2,10))

samfit&lt;-SAM(x,y,resp.type="Two class unpaired")

# examine significant gene list

print(samfit)

# plot results
plot(samfit)

########### two class paired

# y must take values  -1, 1, -2,2 etc, with (-k,k) being a pair

set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y=c(-(1:10),1:10)



samfit&lt;-SAM(x,y, resp.type="Two class paired",fdr.output=.25)




#############quantitative response


set.seed(30)
p=1000
x&lt;-matrix(rnorm(p*20),ncol=20)
y&lt;-rnorm(20)
x[1:20,y&gt;0]=x[1:20,y&gt;0]+4
a&lt;-SAM(x,y,resp.type="Quantitative",nperms=50,fdr.output=.5)






###########survival data
# y is numeric; censoring.status=1 for failures, and 0 for censored

set.seed(84048)
x=matrix(rnorm(1000*50),ncol=50)
x[1:50,26:50]= x[1:50,26:50]+2
x[51:100,26:50]= x[51:100,26:50]-2

y=abs(rnorm(50))
y[26:50]=y[26:50]+2
censoring.status &lt;- sample(c(0,1),size=50,replace=TRUE)

a&lt;-SAM(x,y,censoring.status=censoring.status,resp.type="Survival",
nperms=20)



################multi-class example
# y takes values 1,2,3,...k where k= number of classes

set.seed(84048)
x=matrix(rnorm(1000*10),ncol=10)

y=c(rep(1,3),rep(2,3),rep(3,4))
x[1:50,y==3]=x[1:50,y==3]+5

a &lt;- SAM(x,y,resp.type="Multiclass",nperms=50)






##################### pattern discovery
# here there is no outcome y; the desired eigengene is indicated by 
# the argument eigengene.numbe in the data object

set.seed(32)
x=matrix(rnorm(1000*9),ncol=9)
mu=c(3,2,1,0,0,0,1,2,3)
b=3*runif(100)+.5
x[1:100,]=x[1:100,]+ b



d=list(x=x,eigengene.number=1,
geneid=as.character(1:nrow(x)),genenames=paste("gene", as.character(1:nrow(x))))


a &lt;- SAM(x, resp.type="Pattern discovery", nperms=50)


#################### timecourse data

# elements of y are of the form  kTimet  where k is the class label and t
# is the time; in addition, the   suffixes Start or End indicate the first
# and last observation in a given time course
# the class label can be that for a two class unpaired, one class or
# two class paired problem

set.seed(8332)
y=paste(c(rep(1,15),rep(2,15)),"Time",rep(c(1,2,3,4,5,1.1,2.5, 3.7, 4.1,5.5),3),
sep="")
start=c(1,6,11,16,21,26)
for(i in start){
y[i]=paste(y[i],"Start",sep="")
}
for(i in  start+4){
y[i]=paste(y[i],"End",sep="")
}
x=matrix(rnorm(1000*30),ncol=30)
x[1:50,16:20]=x[1:50,16:20]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[1:50,21:25]=x[1:50,21:25]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[1:50,26:30]=x[1:50,26:30]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)

x[51:100,16:20]=x[51:100,16:20]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[51:100,21:25]=x[51:100,21:25]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[51:100,26:30]=x[51:100,26:30]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)

a&lt;- SAM(x,y,  resp.type="Two class unpaired timecourse",
 nperms=100, time.summary.type="slope")


</code></pre>

<hr>
<h2 id='samr'>Significance analysis of microarrays</h2><span id='topic+samr'></span>

<h3>Description</h3>

<p>Correlates a large number of features (eg genes) with an outcome
variable, such as a group indicator, quantitative variable or  survival time.
NOTE: for most users, the interface function SAM&mdash; which calls samr&ndash; will be more 
convenient for array data, and the interface function SAMseq&ndash; which also calls samr&ndash;
will be more convenient for sequencing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr(data, resp.type=c("Quantitative","Two class unpaired",
"Survival","Multiclass", "One class", "Two class paired",
"Two class unpaired timecourse", "One class timecourse",
"Two class paired timecourse", "Pattern discovery"),
assay.type=c("array","seq"), s0=NULL, s0.perc=NULL, nperms=100, 
center.arrays=FALSE, testStatistic=c("standard","wilcoxon"), 
time.summary.type=c("slope","signed.area"), 
regression.method=c("standard","ranks"), return.x=FALSE, 
knn.neighbors=10, random.seed=NULL, nresamp=20,nresamp.perm=NULL, 
xl.mode=c("regular","firsttime","next20","lasttime"), 
xl.time=NULL,  xl.prevfit=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr_+3A_data">data</code></td>
<td>
<p>Data object with components x- p by n matrix of features,
one observation per column (missing values allowed); y- n-vector of outcome measurements;
censoring.status- n-vector of censoring censoring.status (1= died or event occurred, 0=survived, or event was censored), needed
for a censored survival outcome</p>
</td></tr>
<tr><td><code id="samr_+3A_resp.type">resp.type</code></td>
<td>
<p>Problem type:
&quot;Quantitative&quot; for a continuous parameter (Available for both array and sequencing data);
&quot;Two class unpaired&quot; (for both array and sequencing data); 
&quot;Survival&quot; for censored survival outcome (for both array and sequencing data); 
&quot;Multiclass&quot;: more than 2 groups (for both array and sequencing data);  
&quot;One class&quot; for a single group (only for array data); 
&quot;Two class paired&quot; for two classes with paired observations (for both array and sequencing data);
&quot;Two class unpaired timecourse&quot; (only for array data), 
&quot;One class time course&quot; (only for array data),
&quot;Two class.paired timecourse&quot; (only for array data),
or &quot;Pattern discovery&quot; (only for array data)</p>
</td></tr>
<tr><td><code id="samr_+3A_assay.type">assay.type</code></td>
<td>
<p>Assay type: &quot;array&quot; for microarray data, &quot;seq&quot; for counts from sequencing</p>
</td></tr>
<tr><td><code id="samr_+3A_s0">s0</code></td>
<td>
<p>Exchangeability factor  for denominator of test statistic; Default
is automatic choice. Only used for array data.</p>
</td></tr>
<tr><td><code id="samr_+3A_s0.perc">s0.perc</code></td>
<td>
<p>Percentile of standard  deviation values to use for s0; default is
automatic choice; -1 means s0=0 (different from s0.perc=0, meaning
s0=zeroeth percentile of  standard  deviation values= min of sd values.
Only used for array data.</p>
</td></tr>
<tr><td><code id="samr_+3A_nperms">nperms</code></td>
<td>
<p>Number of permutations used to estimate false discovery rates</p>
</td></tr>
<tr><td><code id="samr_+3A_center.arrays">center.arrays</code></td>
<td>
<p>Should the data for each sample (array) be median centered
at the outset? Default =FALSE. Only used for array data.</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="samr_+3A_teststatistic">testStatistic</code></td>
<td>
<p>Test statistic to use in two class unpaired case.Either
&quot;standard&quot; (t-statistic) or ,&quot;wilcoxon&quot; (Two-sample wilcoxon or Mann-Whitney
test). Only used for array data.</p>
</td></tr> 
<tr><td><code id="samr_+3A_time.summary.type">time.summary.type</code></td>
<td>
<p>Summary measure for each time course: &quot;slope&quot;, or &quot;signed.area&quot;). Only used for array data.</p>
</td></tr> 
<tr><td><code id="samr_+3A_regression.method">regression.method</code></td>
<td>
<p>Regression method for quantitative case:
&quot;standard&quot;, (linear least squares) or &quot;ranks&quot; (linear least squares 
on ranked data). Only used for array data.</p>
</td></tr>
<tr><td><code id="samr_+3A_return.x">return.x</code></td>
<td>
<p>Should the matrix of feature values be returned?
Only useful for time course data, where x contains summaries of the features
over time. Otherwise x is the same as the input data data\$x</p>
</td></tr>
<tr><td><code id="samr_+3A_knn.neighbors">knn.neighbors</code></td>
<td>
<p>Number of nearest neighbors to use for imputation
of missing features values. Only used for array data.</p>
</td></tr>
<tr><td><code id="samr_+3A_random.seed">random.seed</code></td>
<td>
<p>Optional initial seed for random number generator (integer)</p>
</td></tr>
<tr><td><code id="samr_+3A_nresamp">nresamp</code></td>
<td>
<p>For assay.type=&quot;seq&quot;, number of resamples used to construct test statistic. Default 20. Only used for sequencing data.</p>
</td></tr>
<tr><td><code id="samr_+3A_nresamp.perm">nresamp.perm</code></td>
<td>
<p>For assay.type=&quot;seq&quot;, number of resamples used to construct test statistic for permutations. Default is equal to nresamp and it must be at most nresamp. Only used for sequencing data.</p>
</td></tr>
<tr><td><code id="samr_+3A_xl.mode">xl.mode</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="samr_+3A_xl.time">xl.time</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
<tr><td><code id="samr_+3A_xl.prevfit">xl.prevfit</code></td>
<td>
<p>Used by Excel interface</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Carries out a SAM analysis. Applicable to microarray data,
sequencing data,
and other data with a large number of features. This is the R package
that is called by the &quot;official&quot; SAM Excel package v2.0.
The format of the response vector y and the calling sequence
is illustrated in the examples below. A more complete  description
is given in the SAM manual
at http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Data matrix p by n (p=\# genes or features). Equal to the  matrix data\$x  in the original call to samr except
for (1) time course analysis, where is contains the summarized data
or (2) quantitative outcome with rank regression, where it contains
the data transformed to ranks. Hence it is null except for in time course analysis. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Vector of n outcome values. equal the values data\$y in the original call to samr, except
for (1) time course analysis, where is contains the summarized y 
or (2) quantitative outcome with rank regression, where it contains
the y values transformed to ranks</p>
</td></tr>
<tr><td><code>argy</code></td>
<td>
<p>The  values data\$y in the original call to samr</p>
</td></tr> 
<tr><td><code>censoring.status</code></td>
<td>
<p>Censoring status indicators if applicable</p>
</td></tr>
<tr><td><code>testStatistic</code></td>
<td>
<p>Test Statistic used</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code>nperms</code></td>
<td>
<p>Number of permutations requested</p>
</td></tr>
<tr><td><code>nperms.act</code></td>
<td>
<p>Number of permutations actually used. Will be &lt;
nperms when \# of possible permutations  &lt;= nperms (in which case
all permutations are done)</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>tt=numer/sd, the  vector of p test statistics for original data</p>
</td></tr>
<tr><td><code>numer</code></td>
<td>
<p>Numerators for tt</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Denominators for tt. Equal to standard deviation for feature plus s0</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>Computed  exchangeability factor</p>
</td></tr>
<tr><td><code>s0.perc</code></td>
<td>
<p>Computed percentile of standard deviation values.
s0= s0.perc percentile of the gene standard deviations</p>
</td></tr>
<tr><td><code>eva</code></td>
<td>
<p>p-vector of expected values for tt under permutation sampling</p>
</td></tr>
<tr><td><code>perms</code></td>
<td>
<p>nperms.act by n matrix  of permutations used. Each row is 
a permutation of 1,2...n</p>
</td></tr>
<tr><td><code>permsy</code></td>
<td>
<p>nperms.act by n matrix  of permutations used. Each row is
a permutation of y1,y2,...yn. Only one of perms or permys is non-Null, depending on resp.type</p>
</td></tr> 
<tr><td><code>all.perms.flag</code></td>
<td>
<p>Were all possible permutations used?</p>
</td></tr>
<tr><td><code>ttstar</code></td>
<td>
<p>p by nperms.aca matrix t of test statistics from permuted data. Each column if sorted in descending order</p>
</td></tr>
<tr><td><code>ttstar0</code></td>
<td>
<p>p by nperms.act matrix  of test statistics from permuted data. Columns are in order of data</p>
</td></tr>
<tr><td><code>eigengene.number</code></td>
<td>
<p>The number of the eigengene (eg 1,2,..) that was requested for Pattern discovery</p>
</td></tr>
<tr><td><code>eigengene</code></td>
<td>
<p>Computed eigengene</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>Estimated proportion of non-null features (genes)</p>
</td></tr>
<tr><td><code>foldchange</code></td>
<td>
<p>p-vector of foldchanges for original data</p>
</td></tr>
<tr><td><code>foldchange.star</code></td>
<td>
<p>p by nperms.act matrix estimated foldchanges from permuted data</p>
</td></tr>
<tr><td><code>sdstar.keep</code></td>
<td>
<p>n by nperms.act matrix of standard deviations
from each permutation</p>
</td></tr>
<tr><td><code>censoring.status.star.keep</code></td>
<td>
<p>n by nperms.act matrix of 
censoring.status indicators from each permutation</p>
</td></tr>
<tr><td><code>resp.type</code></td>
<td>
<p>The response type used. Same as resp.type.arg, except for
time course data, where time data is summarized and then treated as non-time course. Eg if resp.type.arg=&quot;oneclass.timecourse&quot; then  resp.type=&quot;oneclass&quot;</p>
</td></tr>
<tr><td><code>resp.type.arg</code></td>
<td>
<p>The response type requested in the call to samr</p>
</td></tr>
<tr><td><code>stand.contrasts</code></td>
<td>
<p>For multiclass data, p by nclass matrix of  standardized differences
between the class mean and the overall mean</p>
</td></tr>
<tr><td><code>stand.contrasts.star</code></td>
<td>
<p>For multiclass data, p by nclass by nperms.act array of standardized contrasts for permuted datasets</p>
</td></tr>
<tr><td><code>stand.contrasts.95</code></td>
<td>
<p>For multiclass data, 2.5
of standardized contrasts. Useful for determining which class contrast
for significant genes, are large</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>For array.type=&quot;seq&quot;, estimated sequencing depth for each sample.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>calling sequence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response  PNAS 2001 98: 5116-5121, (Apr 24). 
http://www-stat.stanford.edu/~tibs/SAM
</p>
<p>Li, Jun and Tibshirani, R. (2011). Finding consistent patterns: a nonparametric
approach for identifying differential expression in
RNA-Seq data. To appear, Statistical Methods in Medical Research.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######### two class unpaired comparison
# y must take values 1,2

set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u
y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

delta=.4
samr.plot(samr.obj,delta)

delta.table &lt;- samr.compute.delta.table(samr.obj)

siggenes.table&lt;-samr.compute.siggenes.table(samr.obj,delta, data, delta.table)

# sequence data

set.seed(3)
x&lt;-abs(100*matrix(rnorm(1000*20),ncol=20))
x=trunc(x)
y&lt;- c(rep(1,10),rep(2,10))
x[1:50,y==2]=x[1:50,y==2]+50
data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""))

samr.obj&lt;-samr(data,  resp.type="Two class unpaired",assay.type="seq",  nperms=100)

delta=5
samr.plot(samr.obj,delta)

delta.table &lt;- samr.compute.delta.table(samr.obj)

siggenes.table&lt;-samr.compute.siggenes.table(samr.obj,delta, data, delta.table)





########### two class paired

# y must take values  -1, 1, -2,2 etc, with (-k,k) being a pair

set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u
y=c(-(1:10),1:10)


d=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(d,  resp.type="Two class paired", nperms=100)




#############quantitative response

# y must take numeric values

set.seed(84048)
x=matrix(rnorm(1000*9),ncol=9)

mu=c(3,2,1,0,0,0,1,2,3)
b=runif(100)+.5
x[1:100,]=x[1:100,]+ b

y=mu

d=list(x=x,y=y, 
geneid=as.character(1:nrow(x)),genenames=paste("gene", as.character(1:nrow(x))))

samr.obj =samr(d,  resp.type="Quantitative", nperms=50)



########### oneclass
# y is a vector of ones

set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,20))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)

samr.obj&lt;-samr(data,  resp.type="One class", nperms=100)



###########survival data
# y is numeric; censoring.status=1 for failures, and 0 for censored

set.seed(84048)
x=matrix(rnorm(1000*50),ncol=50)
x[1:50,26:50]= x[1:50,26:50]+2
x[51:100,26:50]= x[51:100,26:50]-2

y=abs(rnorm(50))
y[26:50]=y[26:50]+2
censoring.status=sample(c(0,1),size=50,replace=TRUE)
d=list(x=x,y=y,censoring.status=censoring.status,
geneid=as.character(1:1000),genenames=paste("gene", as.character(1:1000)))

samr.obj=samr(d,  resp.type="Survival", nperms=20)


################multi-class example
# y takes values 1,2,3,...k where k= number of classes

set.seed(84048)
x=matrix(rnorm(1000*10),ncol=10)
x[1:50,6:10]= x[1:50,6:10]+2
x[51:100,6:10]= x[51:100,6:10]-2

y=c(rep(1,3),rep(2,3),rep(3,4))
d=list(x=x,y=y,geneid=as.character(1:1000),
genenames=paste("gene", as.character(1:1000))) 

samr.obj &lt;- samr(d,  resp.type="Multiclass")



#################### timecourse data

# elements of y are of the form  kTimet  where k is the class label and t
# is the time; in addition, the   suffixes Start or End indicate the first
# and last observation in a given time course
# the class label can be that for a two class unpaired, one class or
# two class paired problem

set.seed(8332)
y=paste(c(rep(1,15),rep(2,15)),"Time",rep(c(1,2,3,4,5,1.1,2.5, 3.7, 4.1,5.5),3),
sep="")
start=c(1,6,11,16,21,26)
for(i in start){
y[i]=paste(y[i],"Start",sep="")
}
for(i in  start+4){
y[i]=paste(y[i],"End",sep="")
}
x=matrix(rnorm(1000*30),ncol=30)
x[1:50,16:20]=x[1:50,16:20]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[1:50,21:25]=x[1:50,21:25]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[1:50,26:30]=x[1:50,26:30]+matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)

x[51:100,16:20]=x[51:100,16:20]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[51:100,21:25]=x[51:100,21:25]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)
x[51:100,26:30]=x[51:100,26:30]-matrix(3*c(0,1,2,3,4),ncol=5,nrow=50,byrow=TRUE)

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)

samr.obj&lt;- samr(data,  resp.type="Two class unpaired timecourse",
 nperms=100, time.summary.type="slope")


##################### pattern discovery
# here there is no outcome y; the desired eigengene is indicated by 
# the argument eigengene.numbe in the data object

set.seed(32)
x=matrix(rnorm(1000*9),ncol=9)
mu=c(3,2,1,0,0,0,1,2,3)
b=3*runif(100)+.5
x[1:100,]=x[1:100,]+ b



d=list(x=x,eigengene.number=1,
geneid=as.character(1:nrow(x)),genenames=paste("gene", as.character(1:nrow(x))))


samr.obj=samr(d,  resp.type="Pattern discovery", nperms=50)


</code></pre>

<hr>
<h2 id='samr-internal'>Internal samr functions</h2><span id='topic+ttest.func'></span><span id='topic+wilcoxon.func'></span><span id='topic+onesample.ttest.func'></span><span id='topic+paired.ttest.func'></span><span id='topic+cox.func'></span><span id='topic+multiclass.func'></span><span id='topic+quantitative.func'></span><span id='topic+patterndiscovery.func'></span><span id='topic+timearea.func'></span><span id='topic+sumlengths'></span><span id='topic+detec.slab'></span><span id='topic+detec.horiz'></span><span id='topic+localfdr'></span><span id='topic+predictlocalfdr'></span><span id='topic+qvalue.func'></span><span id='topic+foldchange.twoclass'></span><span id='topic+foldchange.paired'></span><span id='topic+est.s0'></span><span id='topic+permute'></span><span id='topic+permute.rows'></span><span id='topic+sample.perms'></span><span id='topic+insert.value'></span><span id='topic+integer.base.b'></span><span id='topic+varr'></span><span id='topic+mysvd'></span><span id='topic+getperms'></span><span id='topic+compute.block.perms'></span><span id='topic+parse.block.labels.for.2classes'></span><span id='topic+parse.time.labels.and.summarize.data'></span><span id='topic+check.format'></span><span id='topic+samr.const.quantitative.response'></span><span id='topic+samr.const.twoclass.unpaired.response'></span><span id='topic+samr.const.survival.response'></span><span id='topic+samr.const.multiclass.response'></span><span id='topic+samr.const.oneclass.response'></span><span id='topic+samr.const.twoclass.paired.response'></span><span id='topic+samr.const.twoclass.unpaired.timecourse.response'></span><span id='topic+samr.const.twoclass.paired.timecourse.response'></span><span id='topic+samr.const.oneclass.timecourse.response'></span><span id='topic+samr.const.patterndiscovery.response'></span><span id='topic+resample'></span><span id='topic+wilcoxon.unpaired.seq.func'></span><span id='topic+wilcoxon.paired.seq.func'></span><span id='topic+multiclass.seq.func'></span><span id='topic+quantitative.seq.func'></span><span id='topic+cox.seq.func'></span><span id='topic+rankcol'></span><span id='topic+samr.compute.delta.table.seq'></span><span id='topic+samr.seq.null.err'></span><span id='topic+samr.seq.detec.slabs'></span><span id='topic+generate.dels'></span><span id='topic+foldchange.seq.twoclass.paired'></span><span id='topic+foldchange.seq.twoclass.unpaired'></span><span id='topic+samr.compute.delta.table.array'></span><span id='topic+plot.SAMoutput'></span><span id='topic+print.SAMoutput'></span>

<h3>Description</h3>

<p>Internal samr functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttest.func(x, y, s0 = 0, sd=NULL)
wilcoxon.func(x, y, s0 = 0)
onesample.ttest.func(x, y, s0 = 0, sd=NULL)
paired.ttest.func(x, y, s0 = 0, sd=NULL)
cox.func(x, y, censoring.status, s0 = 0)
multiclass.func(x, y, s0 = 0)
quantitative.func(x, y, s0 = 0)
patterndiscovery.func(x,s0=0, eigengene.number=1)
timearea.func(x, y, s0 = 0)
sumlengths(aa)
detec.slab(samr.obj, del, min.foldchange)
detec.horiz(samr.obj, cutlow, cutup, min.foldchange)
localfdr(samr.obj, min.foldchange, perc = 0.01, df = 10)
predictlocalfdr(smooth.object, d)
qvalue.func(samr.obj, sig, delta.table)
foldchange.twoclass(x, y, logged2)
foldchange.paired(x, y, logged2)
est.s0(tt, sd, s0.perc = seq(0, 1, by = 0.05))
permute(elem)
sample.perms(elem, nperms)
permute.rows(x)
insert.value(vec, newval, pos)
integer.base.b(x, b = 2)
varr(x, meanx = NULL)
mysvd(x, n.components=NULL)
getperms(y, nperms)
compute.block.perms(y, blocky, nperms)
parse.block.labels.for.2classes(y)
parse.time.labels.and.summarize.data(x, y, resp.type,time.summary.type)

check.format(y, resp.type, censoring.status = NULL)
samr.const.quantitative.response
samr.const.twoclass.unpaired.response
samr.const.survival.response
samr.const.multiclass.response
samr.const.oneclass.response
samr.const.twoclass.paired.response
samr.const.twoclass.unpaired.timecourse.response
samr.const.twoclass.paired.timecourse.response
samr.const.oneclass.timecourse.response
samr.const.patterndiscovery.response
resample(x, d, nresamp=20)
wilcoxon.unpaired.seq.func(xresamp, y)
wilcoxon.paired.seq.func(xresamp, y)
multiclass.seq.func(xresamp, y)
quantitative.seq.func(xresamp, y)
cox.seq.func(xresamp, y, censoring.status)
rankcol(x)
samr.compute.delta.table.seq(samr.obj, min.foldchange=0, dels=NULL)
samr.seq.null.err(samr.obj, min.foldchange, cutup, cutlow)
samr.seq.detec.slabs(samr.obj, dels, min.foldchange)
generate.dels(samr.obj, min.foldchange=0)
foldchange.seq.twoclass.paired(x, y, depth)
foldchange.seq.twoclass.unpaired(x, y, depth)
samr.compute.delta.table.array(samr.obj, min.foldchange=0, dels=NULL, nvals=50)
## S3 method for class 'SAMoutput'
plot(x, ...)
## S3 method for class 'SAMoutput'
print(x, ...)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>

<hr>
<h2 id='samr.assess.samplesize'>Assess the sample size for a SAM analysis</h2><span id='topic+samr.assess.samplesize'></span>

<h3>Description</h3>

<p>Estimate the false discovery rate, 
false negative rate, power and type I error for a SAM
analysis. Currently
implemented only for two class (unpaired or paired), one-sample and survival problems). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.assess.samplesize(samr.obj, data, dif, samplesize.factors=c(1,2,3,5), 
min.genes = 10, max.genes = nrow(data$x)/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.assess.samplesize_+3A_samr.obj">samr.obj</code></td>
<td>
<p> Object returned from call to samr</p>
</td></tr>
<tr><td><code id="samr.assess.samplesize_+3A_data">data</code></td>
<td>
<p>Data list, same as that passed to samr.train</p>
</td></tr> 
<tr><td><code id="samr.assess.samplesize_+3A_dif">dif</code></td>
<td>
<p>Change in  gene expression between groups 1 and 2, for genes that
are differentially expressed. For log base 2 data, a value of 1 means
a 2-fold change. For One-sample problems, dif is the number of units away from
zero for differentially expressed genes. For survival data, dif is the numerator of the Cox score statistic (this info is provided in the output of samr).</p>
</td></tr>
<tr><td><code id="samr.assess.samplesize_+3A_samplesize.factors">samplesize.factors</code></td>
<td>
<p>Integer vector of length 4, indicating the
sample sizes to be examined.
The values are factors that multiply the original sample size.
So the value 1 means a sample size of ncol(data$x), 2 means a sample size of ncol(data$x), etc.</p>
</td></tr>
<tr><td><code id="samr.assess.samplesize_+3A_min.genes">min.genes</code></td>
<td>
<p>Minimum number of genes that are assumed to truly changed  in the population</p>
</td></tr>
<tr><td><code id="samr.assess.samplesize_+3A_max.genes">max.genes</code></td>
<td>
<p>Maximum number of genes that are assumed to truly changed  in the population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates  false discovery rate,
false negative rate, power and type I error for a SAM
analysis. The argument samplesize.factor allows the use to assess the
effect of  varying the 
sample size (total number of samples).  A  detailed  description
of this calculation
is given in the SAM manual
at http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>Results</code></td>
<td>
<p>A matrix with columns: number of genes- both  the number differentially expressed genes in the population and number called significant;
cutpoint- the threshold used for the absolute  SAM score d; FDR, 1-power- the median
false discovery rate, also equal to the power for each gene; FDR-90perc-
the
upper 90th percentile of the FDR; FNR, Type 1 error- the false negative rate, also equal to 
the type I error for each gene; FNR-90perc- the upper 90th percentile of the FNR </p>
</td></tr>
<tr><td><code>dif.call</code></td>
<td>
<p>Change in  gene expression between groups 1 and 2, that was provided in the
call to samr.assess.samplesize</p>
</td></tr>
<tr><td><code>difm</code></td>
<td>
<p>The average difference in SAM score d for the genes
differentially expressed vs unexpressed</p>
</td></tr>
<tr><td><code>samplesize.factor</code></td>
<td>
<p>The  samplesize.factor that was passed to  samr.assess.samplesiz</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of samples in input data (i.e. ncol of x component in data)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001):
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam
</p>
<p>Taylor, J., Tibshirani, R. and Efron. B. (2005). 
The &ldquo;Miss rate&rdquo; for the analysis of gene expression data.  Biostatistics 2005 6(1):111-117. 
</p>
<p>A more complete  description
is given in the SAM manual
at http://www-stat.stanford.edu/~tibs/SAM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)

log2=function(x){log(x)/log(2)}

# run SAM first
samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

# assess current sample size (20), assuming 1.5fold difference on log base 2 scale

samr.assess.samplesize.obj&lt;- samr.assess.samplesize(samr.obj, data, log2(1.5))

# assess the effect of doubling the sample size

samr.assess.samplesize.obj2&lt;- samr.assess.samplesize(samr.obj, data, log2(1.5))

</code></pre>

<hr>
<h2 id='samr.assess.samplesize.plot'>Make a plot of the results from samr.assess.samplesize</h2><span id='topic+samr.assess.samplesize.plot'></span>

<h3>Description</h3>

<p>Plots of the results from samr.assess.samplesize
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.assess.samplesize.plot(samr.assess.samplesize.obj, logx=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.assess.samplesize.plot_+3A_samr.assess.samplesize.obj">samr.assess.samplesize.obj</code></td>
<td>
<p> Object returned from call to samr.assess.samplesize</p>
</td></tr>
<tr><td><code id="samr.assess.samplesize.plot_+3A_logx">logx</code></td>
<td>
<p>Should logs be used on the horizontal (\# of genes) axis? Default TRUE</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Plots results: FDR (or 1-power) and FNR (or 1-type 1 error) from samr.assess.samplesize</p>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001):
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)

log2=function(x){log(x)/log(2)}

# run SAM first
samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

# assess current sample size (20), assuming 1.5fold difference on the log base 2 scale

samr.assess.samplesize.obj&lt;- samr.assess.samplesize(samr.obj, data, log2(1.5))

samr.assess.samplesize.plot(samr.assess.samplesize.obj)
</code></pre>

<hr>
<h2 id='samr.compute.delta.table'>Compute delta table for SAM analysis</h2><span id='topic+samr.compute.delta.table'></span>

<h3>Description</h3>

<p>Computes tables of thresholds, cutpoints and corresponding
False Discovery rates for SAM (Significance analysis of microarrays)
analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
samr.compute.delta.table(samr.obj, min.foldchange=0, dels=NULL, nvals=50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.compute.delta.table_+3A_samr.obj">samr.obj</code></td>
<td>
<p> Object returned from call to samr</p>
</td></tr>
<tr><td><code id="samr.compute.delta.table_+3A_min.foldchange">min.foldchange</code></td>
<td>
<p>The minimum fold change desired; should be &gt;1;
default is zero, meaning no fold change criterion is applied</p>
</td></tr>
<tr><td><code id="samr.compute.delta.table_+3A_dels">dels</code></td>
<td>
<p>vector of delta values used. 
Delta is the vertical distance from the 45 degree line to the upper and lower
parallel lines that define the SAM threshold rule.
By default, for array data, 50 values
are chosen in the relevant operating change for delta.
For sequencing data, the maximum number of effective delta values
are chosen automatically according to the data.
</p>
</td></tr>
<tr><td><code id="samr.compute.delta.table_+3A_nvals">nvals</code></td>
<td>
<p>Number of delta values used. 
For array data, the default value is 50. For sequencing data,
the value will be chosen automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a table of the FDR and upper and lower cutpoints for various values of
delta, for a SAM analysis.
</p>


<h3>Author(s)</h3>

<p> Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=50)

delta.table&lt;- samr.compute.delta.table(samr.obj)

</code></pre>

<hr>
<h2 id='samr.compute.siggenes.table'>Compute significant genes table</h2><span id='topic+samr.compute.siggenes.table'></span>

<h3>Description</h3>

<p>Computes significant genes table, starting with samr object &quot;samr.obj&quot; and  delta.table &quot;delta.table&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.compute.siggenes.table(samr.obj, del, data, delta.table, 
min.foldchange=0, all.genes=FALSE, compute.localfdr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.compute.siggenes.table_+3A_samr.obj">samr.obj</code></td>
<td>
<p> Object returned from call to samr</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_del">del</code></td>
<td>
<p>Value of delta to define cutoff rule</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_data">data</code></td>
<td>
<p>Data object, same as that used in call to samr</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_delta.table">delta.table</code></td>
<td>
<p> Object returned from call to
samr.compute.delta.table</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_min.foldchange">min.foldchange</code></td>
<td>
<p>The minimum fold change desired; should be &gt;1;
default is zero, meaning no fold change criterion is applied</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_all.genes">all.genes</code></td>
<td>
<p>Should all genes be listed? Default FALSE</p>
</td></tr>
<tr><td><code id="samr.compute.siggenes.table_+3A_compute.localfdr">compute.localfdr</code></td>
<td>
<p>Should the local fdrs be computed (this can take some time)? Default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return(list(genes.up=res.up,
genes.lo=res.lo, 
color.ind.for.multi=color.ind.for.multi, 
ngenes.up=ngenes.up, 
ngenes.lo=ngenes.lo))
</p>
<table>
<tr><td><code>genes.up</code></td>
<td>
<p>Matrix of significant genes having posative correlation with the outcome.
For survival data, genes.up are those genes having positive correlation with risk-
that is, increased expression corresponds to higher risk (shorter survival).</p>
</td></tr>
<tr><td><code>genes.lo</code></td>
<td>
<p>Matrix of significant genes having negative correlation with the outcome.
For survival data,genes. lo are those whose increased expression corresponds to lower risk (longer survival).</p>
</td></tr>
<tr><td><code>color.ind.for.multi</code></td>
<td>
<p>For multiclass response: a matrix with entries +1
if the class mean is larger  than the overall mean at the 95
levels, -1 if less, and zero otehrwise. This is useful in 
determining which class or classes causes a feature to be significant</p>
</td></tr>
<tr><td><code>ngenes.up</code></td>
<td>
<p>Number of significant genes with  positive correlation</p>
</td></tr>
<tr><td><code>ngenes.lo</code></td>
<td>
<p>Number of significant genes with  negative correlation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001):
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

delta.table&lt;-samr.compute.delta.table(samr.obj)
del&lt;- 0.3
siggenes.table&lt;- samr.compute.siggenes.table(samr.obj, del, data, delta.table)


</code></pre>

<hr>
<h2 id='samr.estimate.depth'>estimate the sequencing depth</h2><span id='topic+samr.estimate.depth'></span>

<h3>Description</h3>

<p>Estimate the sequencing depth of each experiment for sequencing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.estimate.depth(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.estimate.depth_+3A_x">x</code></td>
<td>
<p>the original count matrix. p by n matrix of features, one observation per column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>normalize the data matrix so that each number looks roughly like
Gaussian distributed and each experiment has the same sequencing depth.
To do this, we first use Anscombe transformation to stablize the variance
and makes each number look like Gaussian,
and then divide each experiment by the square root of the sequencing depth.</p>


<h3>Value</h3>

<table>
<tr><td><code>depth</code></td>
<td>
<p>sequencing depth of each experiment. a vector of length n.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response  PNAS 2001 98: 5116-5121, (Apr 24). 
http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
mu &lt;- matrix(100, 1000, 20)
mu[1:100, 11:20] &lt;- 200
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- c(rep(1, 10), rep(2, 10))
data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""))
depth &lt;- samr.estimate.depth(data$x)
</code></pre>

<hr>
<h2 id='samr.missrate'>Estimate the  miss rate table for a SAM analysis</h2><span id='topic+samr.missrate'></span>

<h3>Description</h3>

<p>Estimates the  miss rate table, showing the local false negative rate, for a SAM
analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.missrate(samr.obj, del, delta.table, quant=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.missrate_+3A_samr.obj">samr.obj</code></td>
<td>
<p> Object returned from call to samr</p>
</td></tr>
<tr><td><code id="samr.missrate_+3A_del">del</code></td>
<td>
<p>Value of delta to define cutoff rule</p>
</td></tr>
<tr><td><code id="samr.missrate_+3A_delta.table">delta.table</code></td>
<td>
<p> Object returned from call to samr.compute.delta.table</p>
</td></tr>
<tr><td><code id="samr.missrate_+3A_quant">quant</code></td>
<td>
<p>Optional vector of quantiles to used in the miss rate calculation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001):
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam
</p>
<p>Taylor, J., Tibshirani, R. and Efron. B. (2005). 
The &ldquo;Miss rate&rdquo; for the analysis of gene expression data.  Biostatistics 2005 6(1):111-117. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

delta.table&lt;-samr.compute.delta.table(samr.obj)
del&lt;- 0.3
siggenes.table&lt;- samr.compute.siggenes.table(samr.obj, del, data, delta.table)


samr.missrate(samr.obj, del, delta.table)
</code></pre>

<hr>
<h2 id='samr.norm.data'>output normalized sequencing data</h2><span id='topic+samr.norm.data'></span>

<h3>Description</h3>

<p>Output a normalized sequencing data matrix from the original count matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.norm.data(x, depth=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.norm.data_+3A_x">x</code></td>
<td>
<p>the original count matrix. p by n matrix of features, one observation per column.</p>
</td></tr>
<tr><td><code id="samr.norm.data_+3A_depth">depth</code></td>
<td>
<p>sequencing depth of each experiment. a vector of length n.
This function will estimate the sequencing depth if it is not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>normalize the data matrix so that each number looks roughly like
Gaussian distributed and each experiment has the same sequencing depth.
To do this, we first use Anscombe transformation to stablize the variance
and makes each number look like Gaussian,
and then divide each experiment by the square root of the sequencing depth.</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>the normalized data matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response  PNAS 2001 98: 5116-5121, (Apr 24). 
http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
mu &lt;- matrix(100, 1000, 20)
mu[1:100, 11:20] &lt;- 200
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- c(rep(1, 10), rep(2, 10))
data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""))
x.norm &lt;- samr.norm.data(data$x)
</code></pre>

<hr>
<h2 id='samr.plot'>Make Q-Q plot for SAM analysis</h2><span id='topic+samr.plot'></span>

<h3>Description</h3>

<p>Makes the Q-Q plot for a SAM analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.plot(samr.obj, del, min.foldchange=0) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.plot_+3A_samr.obj">samr.obj</code></td>
<td>
<p> Object returned from call to samr</p>
</td></tr>
<tr><td><code id="samr.plot_+3A_del">del</code></td>
<td>
<p>Value of delta to use. 
Delta is the  vertical  distance from the 45 degree line to the upper and lower
parallel lines that define the SAM threshold rule.</p>
</td></tr>
<tr><td><code id="samr.plot_+3A_min.foldchange">min.foldchange</code></td>
<td>
<p>The minimum fold change desired; should be &gt;1;
default is zero, meaning no fold change criterion is applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates the Q-Q plot fro a SAm analysis, marking features (genes)
that are significant, ie. lie outside a slab around teh 45 degreee line of
width delta. A gene must also pass the  min.foldchange criterion 
to be called significant, if this criterion is specified in the call.
</p>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response&quot;  PNAS 2001 98: 5116-5121, (Apr 24).
http://www-stat.stanford.edu/~tibs/sam</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)


samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=50)


samr.plot(samr.obj, del=.3)
</code></pre>

<hr>
<h2 id='samr.pvalues.from.perms'>Report estimated p-values for each gene, from a  SAM analysis</h2><span id='topic+samr.pvalues.from.perms'></span>

<h3>Description</h3>

<p>Report estimated p-values for each gene, from set of
permutations in a SAM analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.pvalues.from.perms(tt, ttstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.pvalues.from.perms_+3A_tt">tt</code></td>
<td>
<p>Vector of gene scores, returned by samr in component tt</p>
</td></tr>
<tr><td><code id="samr.pvalues.from.perms_+3A_ttstar">ttstar</code></td>
<td>
<p>Matrix of gene scores (p by nperm) from nperm permutations.
Returned by samr in component ttstar</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Taylor, J. and Tibshirani, R.   (2005):
A tail strength measure for assessing the overall significance in a dataset.
Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)
samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

pv=samr.pvalues.from.perms(samr.obj$tt, samr.obj$ttstar)
</code></pre>

<hr>
<h2 id='samr.tail.strength'>Estimate tail strength for a dataset, from a SAM analysis</h2><span id='topic+samr.tail.strength'></span>

<h3>Description</h3>

<p>Estimate tail strength for a dataset, from a SAM analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samr.tail.strength(samr.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samr.tail.strength_+3A_samr.obj">samr.obj</code></td>
<td>
<p>Object returned by samr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>ts</code></td>
<td>
<p>Estimated tail strength. A number less than or equal to 1.
Zero means all genes are null; 1 means all genes are differentially expressed.</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code>se.ts</code></td>
<td>
<p>Estimated standard error of tail strength.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Taylor, J. and Tibshirani, R.   (2005):
A tail strength measure for assessing the overall significance in a dataset.
Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate some example data
set.seed(100)
x&lt;-matrix(rnorm(1000*20),ncol=20)
dd&lt;-sample(1:1000,size=100)

u&lt;-matrix(2*rnorm(100),ncol=10,nrow=100)
x[dd,11:20]&lt;-x[dd,11:20]+u

y&lt;-c(rep(1,10),rep(2,10))

data=list(x=x,y=y, geneid=as.character(1:nrow(x)),
genenames=paste("g",as.character(1:nrow(x)),sep=""), logged2=TRUE)

samr.obj&lt;-samr(data,  resp.type="Two class unpaired", nperms=100)

samr.tail.strength(samr.obj)

</code></pre>

<hr>
<h2 id='SAMseq'>Significance analysis of sequencing data - simple user interface</h2><span id='topic+SAMseq'></span>

<h3>Description</h3>

<p>Correlates a large number of features (eg. genes) with an outcome
variable, such as a group indicator, quantitative variable or survival time.
This is a simple user interface for the samr function applied to sequencing data.
For array data applications, see the function SAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAMseq(x, y, censoring.status = NULL, 
resp.type = c("Quantitative", "Two class unpaired", 
"Survival", "Multiclass", "Two class paired"), 
geneid = NULL, genenames = NULL, nperms = 100, 
random.seed = NULL, nresamp = 20, fdr.output = 0.20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SAMseq_+3A_x">x</code></td>
<td>
<p>Feature matrix: p (number of features) by n (number of samples),
one observation per column (missing values allowed)</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_y">y</code></td>
<td>
<p>n-vector of outcome measurements</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_censoring.status">censoring.status</code></td>
<td>
<p>n-vector of censoring censoring.status (1=died or event occurred, 0=survived, or event was censored), needed for a censored survival outcome</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_resp.type">resp.type</code></td>
<td>
<p>Problem type:
&quot;Quantitative&quot; for a continuous parameter;
&quot;Two class unpaired&quot; for two classes with unpaired observations; 
&quot;Survival&quot; for censored survival outcome; 
&quot;Multiclass&quot;: more than 2 groups;  
&quot;Two class paired&quot; for two classes with paired observations.</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_geneid">geneid</code></td>
<td>
<p>Optional character vector of geneids for output.</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_genenames">genenames</code></td>
<td>
<p>Optional character vector of genenames for output.</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_nperms">nperms</code></td>
<td>
<p>Number of permutations used to estimate false discovery rates</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_random.seed">random.seed</code></td>
<td>
<p>Optional initial seed for random number generator (integer)</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_nresamp">nresamp</code></td>
<td>
<p>Number of resamples used to construct test statistic. Default 20.</p>
</td></tr>
<tr><td><code id="SAMseq_+3A_fdr.output">fdr.output</code></td>
<td>
<p>(Approximate) False Discovery Rate cutoff for output in significant genes table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple, user-friendly interface to the samr package used on sequencing data.
It automatically disables arguments/features that do not apply to sequencing data.
It calls samr, samr.compute.delta.table and samr.compute.siggenes.table.
samr detects differential expression for microarray data,
and sequencing data,
and other data with a large number of features. samr is the R package
that is called by the &quot;official&quot; SAM Excel Addin.
The format of the response vector y and the calling sequence
is illustrated in the examples below. A more complete description
is given in the SAM manual
at http://www-stat.stanford.edu/~tibs/SAM</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>samr.obj</code></td>
<td>
<p>Output of samr. See documentation for samr for details </p>
</td></tr>
<tr><td><code>siggenes.table</code></td>
<td>
<p>Table of significant genes, output of  samr.compute.siggenes.table.
This has components: genes.up&mdash;matrix of significant genes having positive correlation with the outcome and
genes.lo&mdash;matrix of significant genes having negative correlation with the outcome.
For survival data, genes.up are those genes having positive correlation with risk-
that is, increased expression corresponds to higher risk (shorter survival)
genes.lo are those whose increased expression corresponds to lower risk (longer survival).</p>
</td></tr>
<tr><td><code>delta.table</code></td>
<td>
<p>Output of  samr.compute.delta.table.</p>
</td></tr>
<tr><td><code>del</code></td>
<td>
<p>Value of delta (distance from 45 degree line in SAM plot) for 
used for creating delta.table and siggenes.table. Changing the input value fdr.output
will change the resulting del.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The calling sequence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Li and Balasubrimanian Narasimhan and Robert Tibshirani</p>


<h3>References</h3>

<p>Tusher, V.,  Tibshirani, R.  and Chu, G. (2001): 
Significance analysis of microarrays applied to the ionizing radiation response  PNAS 2001 98: 5116-5121, (Apr 24). 
http://www-stat.stanford.edu/~tibs/SAM
</p>
<p>Li, Jun and Tibshirani, R. (2011). Finding consistent patterns: a nonparametric
approach for identifying differential expression in
RNA-Seq data. To appear, Statistical Methods in Medical Research.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######### two class unpaired comparison
set.seed(100)
mu &lt;- matrix(100, 1000, 20)
mu[1:100, 11:20] &lt;- 200
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- c(rep(1, 10), rep(2, 10))

samfit &lt;- SAMseq(x, y, resp.type = "Two class unpaired") 

# examine significant gene list
print(samfit)

# plot results
plot(samfit)

######### two class paired comparison
set.seed(100)
mu &lt;- matrix(100, 1000, 20)
mu[1:100, 11:20] &lt;- 200
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- c(-(1:10), 1:10)

samfit &lt;- SAMseq(x, y, resp.type = "Two class paired") 

# examine significant gene list
print(samfit)

# plot results
plot(samfit)

######### Multiclass comparison
set.seed(100)
mu &lt;- matrix(100, 1000, 20)
mu[1:20, 1:5] &lt;- 120
mu[21:50, 6:10] &lt;- 80
mu[51:70, 11:15] &lt;- 150
mu[71:100, 16:20] &lt;- 60
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- c(rep(1:4, rep(5, 4)))

samfit &lt;- SAMseq(x, y, resp.type = "Multiclass") 

# examine significant gene list
print(samfit)

# plot results
plot(samfit)

######### Quantitative comparison
set.seed(100)
mu &lt;- matrix(100, 1000, 20)
y &lt;- runif(20, 1, 3)
mu[1 : 100, ] &lt;- matrix(rep(100 * y, 100), ncol=20, byrow=TRUE)
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
samfit &lt;- SAMseq(x, y, resp.type = "Quantitative")

# examine significant gene list
print(samfit)

# plot results
plot(samfit)

######### Survival comparison
set.seed(100)
mu &lt;- matrix(100, 1000, 20)
y &lt;- runif(20, 1, 3)
mu[1 : 100, ] &lt;- matrix(rep(100 * y, 100), ncol=20, byrow=TRUE)
mu &lt;- scale(mu, center=FALSE, scale=runif(20, 0.5, 1.5))
x &lt;- matrix(rpois(length(mu), mu), 1000, 20)
y &lt;- y + runif(20, -0.5, 0.5)
censoring.status &lt;- as.numeric(y &lt; 2.3)
y[y &gt;= 2.3] &lt;- 2.3
samfit &lt;- SAMseq(x, y, censoring.status = censoring.status, 
resp.type = "Survival")

# examine significant gene list
print(samfit)

# plot results
plot(samfit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
