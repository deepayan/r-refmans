<!DOCTYPE html><html><head><title>Help for package yyjsonr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {yyjsonr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#opts_read_geojson'><p>Options for reading in GeoJSON</p></a></li>
<li><a href='#opts_read_json'><p>Create named list of options for parsing R from JSON</p></a></li>
<li><a href='#opts_write_geojson'><p>Options for writing from <code>sf</code> object to <code>GeoJSON</code></p></a></li>
<li><a href='#opts_write_json'><p>Create named list of options for serializing R to JSON</p></a></li>
<li><a href='#read_geojson_str'><p>Load GeoJSON as <code>sf</code> object</p></a></li>
<li><a href='#read_json_conn'><p>Parse JSON from an R connection object.</p></a></li>
<li><a href='#read_json_file'><p>Convert JSON to R</p></a></li>
<li><a href='#read_json_raw'><p>Convert JSON in a raw vector to R</p></a></li>
<li><a href='#read_json_str'><p>Convert JSON in a character string to R</p></a></li>
<li><a href='#read_ndjson_file'><p>Parse an NDJSON file to a data.frame or list</p></a></li>
<li><a href='#read_ndjson_str'><p>Parse an NDJSON file to a data.frame or list</p></a></li>
<li><a href='#validate_json_file'><p>Validate JSON in file or string</p></a></li>
<li><a href='#write_geojson_str'><p>Write SF to GeoJSON string</p></a></li>
<li><a href='#write_json_file'><p>Convert R object to JSON file</p></a></li>
<li><a href='#write_json_str'><p>Convert R object to JSON string</p></a></li>
<li><a href='#write_ndjson_file'><p>Write list or data.frame object to NDJSON in a file</p></a></li>
<li><a href='#write_ndjson_str'><p>Write list or data.frame object to NDJSON in a string</p></a></li>
<li><a href='#yyjson_read_flag'><p>Advanced: Values for setting internal options directly on YYJSON library</p></a></li>
<li><a href='#yyjson_version'><p>Version number of 'yyjson' C library</p></a></li>
<li><a href='#yyjson_write_flag'><p>Advanced: Values for setting internal options directly on YYJSON library</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast 'JSON', 'NDJSON' and 'GeoJSON' Parser and Generator</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Cheng &lt;mikefc@coolbutuseless.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast 'JSON' parser, generator and validator which converts 'JSON', 
    'NDJSON' (Newline Delimited 'JSON') and 'GeoJSON' (Geographic 'JSON') data 
    to/from R objects.  The standard R data types are 
    supported (e.g. logical, numeric, integer) with configurable handling of NULL 
    and NA values. Data frames, atomic vectors and lists are all supported as data 
    containers translated to/from 'JSON'.  'GeoJSON' data is read in as
    'simple features' objects.
    This implementation wraps the 'yyjson' 'C' library which 
    is available from <a href="https://github.com/ibireme/yyjson">https://github.com/ibireme/yyjson</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/coolbutuseless/yyjsonr">https://github.com/coolbutuseless/yyjsonr</a>,
<a href="https://coolbutuseless.github.io/package/yyjsonr/">https://coolbutuseless.github.io/package/yyjsonr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/coolbutuseless/yyjsonr/issues">https://github.com/coolbutuseless/yyjsonr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, knitr, rmarkdown, jsonlite, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The included 'yyjson' code is Copyright (c) 2020 YaoYuan.
See 'COPYRIGHTS' for LICENSE for inclued code.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-10 11:31:12 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Cheng [aut, cre, cph],
  Yao Yuan [aut, cph] (Author of bundled yyjson)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-10 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='opts_read_geojson'>Options for reading in GeoJSON</h2><span id='topic+opts_read_geojson'></span>

<h3>Description</h3>

<p>Options for reading in GeoJSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_read_geojson(
  type = c("sf", "sfc"),
  property_promotion = c("string", "list"),
  property_promotion_lgl = c("integer", "string")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_read_geojson_+3A_type">type</code></td>
<td>
<p>'sf' or 'sfc'</p>
</td></tr>
<tr><td><code id="opts_read_geojson_+3A_property_promotion">property_promotion</code></td>
<td>
<p>What is the most general container type to use when
properties differ across a FEATURECOLLECTION?  E.g. if the property
exists both as a numeric and a string, should all values be promoted
to a 'string', or contained as different types in a 'list'.
Default: 'string' will behave like <code>geojsonsf</code> package.</p>
</td></tr>
<tr><td><code id="opts_read_geojson_+3A_property_promotion_lgl">property_promotion_lgl</code></td>
<td>
<p>when <code>property_promotion = "string"</code>
should logical values become words (i.e. <code>"TRUE"</code>/<code>"FALSE"</code>)
or integers (i.e. <code>"1"</code>/<code>"0"</code>).
Default: &quot;integer&quot; in order to match <code>geojsonsf</code> package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of options specific to reading GeoJSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a set of options to use when reading geojson
opts_read_geojson()
</code></pre>

<hr>
<h2 id='opts_read_json'>Create named list of options for parsing R from JSON</h2><span id='topic+opts_read_json'></span>

<h3>Description</h3>

<p>Create named list of options for parsing R from JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_read_json(
  promote_num_to_string = FALSE,
  df_missing_list_elem = NULL,
  obj_of_arrs_to_df = TRUE,
  arr_of_objs_to_df = TRUE,
  str_specials = c("string", "special"),
  num_specials = c("special", "string"),
  int64 = c("string", "double", "bit64"),
  length1_array_asis = FALSE,
  yyjson_read_flag = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_read_json_+3A_promote_num_to_string">promote_num_to_string</code></td>
<td>
<p>Should numeric values be promoted to strings
when they occur within an array with other string values?  Default: FALSE
means to keep numerics as numeric value and promote the <em>container</em> to
be a <code>list</code> rather than an atomic vector when types are mixed.  If <code>TRUE</code>
then array of mixed string/numeric types will be promoted to all
string values and returned as an atomic character vector.  Set this to <code>TRUE</code>
if you want to emulate the behaviour of <code>jsonlite::fromJSON()</code></p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_df_missing_list_elem">df_missing_list_elem</code></td>
<td>
<p>R value to use when elements are missing in list
columns in data.frames. Default: NULL</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_obj_of_arrs_to_df">obj_of_arrs_to_df</code></td>
<td>
<p>logical. Should a named list of equal-length
vectors be promoted to a data.frame?  Default: TRUE.  If FALSE, then
result will be left as a list.</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_arr_of_objs_to_df">arr_of_objs_to_df</code></td>
<td>
<p>logical. Should an array or objects be promoted to a
a data.frame? Default: TRUE. If FALSE, then results will be read as a
list-of-lists.</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_str_specials">str_specials</code></td>
<td>
<p>Should <code>'NA'</code> in a JSON string be converted to the <code>'special'</code>
<code>NA</code> value in R, or left as a <code>'string'</code>.  Default: 'string'</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_num_specials">num_specials</code></td>
<td>
<p>Should JSON strings 'NA'/'Inf'/'NaN' in a numeric context
be converted to the <code>'special'</code> R numeric values
<code>NA, Inf, NaN</code>, or left as a <code>'string'</code>. Default: 'special'</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_int64">int64</code></td>
<td>
<p>how to encode large integers which do not fit into R's integer
type.  'string' imports them as a character vector. 'double' will
convert the integer to a double precision numeric value. 'bit64' will
use the 'integer64' type from the 'bit64' package.  Note that the
'integer64' type is a <em>signed</em> integer type, and a warning will
be issued if JSON contains an <em>unsigned</em> integer which cannot
be stored in this type.</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_length1_array_asis">length1_array_asis</code></td>
<td>
<p>logical. Should JSON arrays with length = 1 be
marked with class <code>AsIs</code>.  Default: FALSE</p>
</td></tr>
<tr><td><code id="opts_read_json_+3A_yyjson_read_flag">yyjson_read_flag</code></td>
<td>
<p>integer vector of internal <code>yyjson</code>
options.  See <code>yyjson_read_flag</code> in this package, and read
the yyjson API documentation for more information.  This is considered
an advanced option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of options for reading JSON
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yyjson_read_flag">yyjson_read_flag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts_read_json()
</code></pre>

<hr>
<h2 id='opts_write_geojson'>Options for writing from <code>sf</code> object to <code>GeoJSON</code></h2><span id='topic+opts_write_geojson'></span>

<h3>Description</h3>

<p>Currently no options available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_write_geojson()
</code></pre>


<h3>Value</h3>

<p>Named list of options specific to writing GeoJSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a set of options to use when writing geojson
opts_write_geojson()
</code></pre>

<hr>
<h2 id='opts_write_json'>Create named list of options for serializing R to JSON</h2><span id='topic+opts_write_json'></span>

<h3>Description</h3>

<p>Create named list of options for serializing R to JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_write_json(
  digits = -1,
  pretty = FALSE,
  auto_unbox = FALSE,
  dataframe = c("rows", "columns"),
  factor = c("string", "integer"),
  name_repair = c("none", "minimal"),
  num_specials = c("null", "string"),
  str_specials = c("null", "string"),
  fast_numerics = FALSE,
  yyjson_write_flag = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_write_json_+3A_digits">digits</code></td>
<td>
<p>decimal places to keep for floating point numbers. Default: -1.
Positive values specify number of decimal places. Using zero will
write the numeric value as an integer. Values less than zero mean that
the floating point value should be written as-is (the default).</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_pretty">pretty</code></td>
<td>
<p>Logical value indicating if the created JSON string should have
whitespace for indentation and linebreaks. Default: FALSE.
Note: this option is equivalent to <code>yyjson_write_flag = write_flag$YYJSON_WRITE_PRETTY</code></p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_auto_unbox">auto_unbox</code></td>
<td>
<p>automatically unbox all atomic vectors of length 1 such that
they appear as atomic elements in JSON rather than arrays of length 1.</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_dataframe">dataframe</code></td>
<td>
<p>how to encode data.frame objects. Options 'rows' or
columns'.  Default: 'rows'</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_factor">factor</code></td>
<td>
<p>how to encode factor objects: must be one of 'string' or 'integer'
Default: 'string'</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_name_repair">name_repair</code></td>
<td>
<p>How should unnamed items in a partially named list be handled?
'none' means to leave their names blank in JSON (which may not be valid JSON).
'minimal' means to use the integer position index of the item as its name if
it is missing.  Default: 'none'</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_num_specials">num_specials</code></td>
<td>
<p>Should special numeric values (i.e. NA, NaN, Inf) be
converted to a JSON <code>null</code> value or converted to a string
representation e.g. &quot;NA&quot;/&quot;NaN&quot; etc.   Default: 'null'</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_str_specials">str_specials</code></td>
<td>
<p>Should a special value of <code>NA</code> in a character vector
be converted to a
JSON <code>null</code> value, or converted to a string &quot;NA&quot;?  Default: 'null'</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_fast_numerics">fast_numerics</code></td>
<td>
<p>Does the user guarantee that there are no NA, NaN or Inf
values in the numeric vectors?  Default: FALSE.  If <code>TRUE</code> then
numeric and integer vectors will be written to JSON using a faster method.
Note: if there are NA, NaN or Inf values, an error will be thrown.
Expert users are invited to also consider the
<code>YYJSON_WRITE_ALLOW_INF_AND_NAN</code> and
<code>YYJSON_WRITE_INF_AND_NAN_AS_NULL</code> options for <code>yyjson_write_flags</code>
and should consult the <code>yyjson</code> API documentation for
further details.</p>
</td></tr>
<tr><td><code id="opts_write_json_+3A_yyjson_write_flag">yyjson_write_flag</code></td>
<td>
<p>integer vector corresponding to internal <code>yyjson</code>
options.  See <code>yyjson_write_flag</code> in this package, and read
the yyjson API documentation for more information.  This is considered
an advanced option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of options for writing JSON
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yyjson_write_flag">yyjson_write_flag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>write_json_str(head(iris, 3), opts = opts_write_json(factor = 'integer'))
</code></pre>

<hr>
<h2 id='read_geojson_str'>Load GeoJSON as <code>sf</code> object</h2><span id='topic+read_geojson_str'></span><span id='topic+read_geojson_file'></span>

<h3>Description</h3>

<p>Load GeoJSON as <code>sf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_geojson_str(str, opts = list(), ..., json_opts = list())

read_geojson_file(filename, opts = list(), ..., json_opts = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_geojson_str_+3A_str">str</code></td>
<td>
<p>Single string containing GeoJSON</p>
</td></tr>
<tr><td><code id="read_geojson_str_+3A_opts">opts</code></td>
<td>
<p>Named list of GeoJSON-specific options. Usually created
with <code>opts_read_geojson()</code>.
Default: empty <code>list()</code> to use the default options.</p>
</td></tr>
<tr><td><code id="read_geojson_str_+3A_...">...</code></td>
<td>
<p>Any extra named options override those in GeoJSON-specific options
- <code>opts</code></p>
</td></tr>
<tr><td><code id="read_geojson_str_+3A_json_opts">json_opts</code></td>
<td>
<p>Named list of vanilla JSON options as used by <code>read_json_str()</code>.
This is usually created with <code>opts_read_json()</code>.  Default value is
an empty <code>list()</code> which means to use all the default JSON parsing
options which is usually the correct thing to do when reading GeoJSON.</p>
</td></tr>
<tr><td><code id="read_geojson_str_+3A_filename">filename</code></td>
<td>
<p>Filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geojson_file &lt;- system.file("geojson-example.json", package = 'yyjsonr')
read_geojson_file(geojson_file)
</code></pre>

<hr>
<h2 id='read_json_conn'>Parse JSON from an R connection object.</h2><span id='topic+read_json_conn'></span>

<h3>Description</h3>

<p>Currently, this is not very efficient as the entire contents of the connection are
read into R as a string and then the JSON parsed from there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json_conn(conn, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_conn_+3A_conn">conn</code></td>
<td>
<p>connection object.  e.g. <code>url('https://jsonplaceholder.typicode.com/todos/1')</code></p>
</td></tr>
<tr><td><code id="read_json_conn_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_json_conn_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For plain text files it is faster to use
<code>read_json_file()</code>.
</p>


<h3>Value</h3>

<p>R object
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_file">read_json_file</a>()</code>,
<code><a href="#topic+read_json_raw">read_json_raw</a>()</code>,
<code><a href="#topic+read_json_str">read_json_str</a>()</code>,
<code><a href="#topic+read_ndjson_file">read_ndjson_file</a>()</code>,
<code><a href="#topic+read_ndjson_str">read_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  read_json_conn(url("https://api.github.com/users/hadley/repos"))
}


</code></pre>

<hr>
<h2 id='read_json_file'>Convert JSON to R</h2><span id='topic+read_json_file'></span>

<h3>Description</h3>

<p>Convert JSON to R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json_file(filename, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_file_+3A_filename">filename</code></td>
<td>
<p>full path to text file containing JSON.</p>
</td></tr>
<tr><td><code id="read_json_file_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_json_file_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_conn">read_json_conn</a>()</code>,
<code><a href="#topic+read_json_raw">read_json_raw</a>()</code>,
<code><a href="#topic+read_json_str">read_json_str</a>()</code>,
<code><a href="#topic+read_ndjson_file">read_ndjson_file</a>()</code>,
<code><a href="#topic+read_ndjson_str">read_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_json_file(head(iris, 3), tmp)
read_json_file(tmp)
</code></pre>

<hr>
<h2 id='read_json_raw'>Convert JSON in a raw vector to R</h2><span id='topic+read_json_raw'></span>

<h3>Description</h3>

<p>Convert JSON in a raw vector to R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json_raw(raw_vec, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_raw_+3A_raw_vec">raw_vec</code></td>
<td>
<p>raw vector</p>
</td></tr>
<tr><td><code id="read_json_raw_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_json_raw_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_conn">read_json_conn</a>()</code>,
<code><a href="#topic+read_json_file">read_json_file</a>()</code>,
<code><a href="#topic+read_json_str">read_json_str</a>()</code>,
<code><a href="#topic+read_ndjson_file">read_ndjson_file</a>()</code>,
<code><a href="#topic+read_ndjson_str">read_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_str &lt;- as.raw(utf8ToInt('[1, 2, 3, "four"]'))
read_json_raw(raw_str)
</code></pre>

<hr>
<h2 id='read_json_str'>Convert JSON in a character string to R</h2><span id='topic+read_json_str'></span>

<h3>Description</h3>

<p>Convert JSON in a character string to R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json_str(str, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_str_+3A_str">str</code></td>
<td>
<p>a single character string</p>
</td></tr>
<tr><td><code id="read_json_str_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_json_str_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_conn">read_json_conn</a>()</code>,
<code><a href="#topic+read_json_file">read_json_file</a>()</code>,
<code><a href="#topic+read_json_raw">read_json_raw</a>()</code>,
<code><a href="#topic+read_ndjson_file">read_ndjson_file</a>()</code>,
<code><a href="#topic+read_ndjson_str">read_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_json_str("4294967297", opts = opts_read_json(int64 = 'string'))
</code></pre>

<hr>
<h2 id='read_ndjson_file'>Parse an NDJSON file to a data.frame or list</h2><span id='topic+read_ndjson_file'></span>

<h3>Description</h3>

<p>If reading as data.frame, each row of NDJSON becomes a row in the data.frame.
If reading as a list, then each row becomes an element in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ndjson_file(
  filename,
  type = c("df", "list"),
  nread = -1,
  nskip = 0,
  nprobe = 100,
  opts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ndjson_file_+3A_filename">filename</code></td>
<td>
<p>Path to file containing NDJSON data. May e a vanilla text
file or a gzipped file</p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_type">type</code></td>
<td>
<p>The type of R object the JSON should be parsed into. Valid
values are 'df' or 'list'.  Default: 'df' (data.frame)</p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_nread">nread</code></td>
<td>
<p>Number of records to read. Default: -1 (reads all JSON strings)</p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_nskip">nskip</code></td>
<td>
<p>Number of records to skip before starting to read. Default: 0
(skip no data)</p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_nprobe">nprobe</code></td>
<td>
<p>Number of lines to read to determine types for data.frame
columns.  Default: 100.   Use <code>-1</code> to probe entire file.</p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_ndjson_file_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parsing NDJSON to a data.frame it is usually better if the json objects
are consistent from line-to-line.  Type inference for the data.frame is done
during initialisation by reading through <code>nprobe</code> lines.  Warning: if
there is a type-mismatch further into the file than it is probed, then you
will get missing values in the data.frame, or JSON values not captured in
the R data.
</p>
<p>No flattening of the namespace is done i.e. nested object remain nested.
</p>


<h3>Value</h3>

<p>NDJSON data read into R as list or data.frame depending
on <code>'type'</code> argument
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_conn">read_json_conn</a>()</code>,
<code><a href="#topic+read_json_file">read_json_file</a>()</code>,
<code><a href="#topic+read_json_raw">read_json_raw</a>()</code>,
<code><a href="#topic+read_json_str">read_json_str</a>()</code>,
<code><a href="#topic+read_ndjson_str">read_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_ndjson_file(head(mtcars), tmp)
read_ndjson_file(tmp)

</code></pre>

<hr>
<h2 id='read_ndjson_str'>Parse an NDJSON file to a data.frame or list</h2><span id='topic+read_ndjson_str'></span>

<h3>Description</h3>

<p>If reading as data.frame, each row of NDJSON becomes a row in the data.frame.
If reading as a list, then each row becomes an element in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ndjson_str(
  x,
  type = c("df", "list"),
  nread = -1,
  nskip = 0,
  nprobe = 100,
  opts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ndjson_str_+3A_x">x</code></td>
<td>
<p>string containing NDJSON</p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_type">type</code></td>
<td>
<p>The type of R object the JSON should be parsed into. Valid
values are 'df' or 'list'.  Default: 'df' (data.frame)</p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_nread">nread</code></td>
<td>
<p>Number of records to read. Default: -1 (reads all JSON strings)</p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_nskip">nskip</code></td>
<td>
<p>Number of records to skip before starting to read. Default: 0
(skip no data)</p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_nprobe">nprobe</code></td>
<td>
<p>Number of lines to read to determine types for data.frame
columns.  Default: 100.   Use <code>-1</code> to probe entire file.</p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="read_ndjson_str_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parsing NDJSON to a data.frame it is usually better if the json objects
are consistent from line-to-line.  Type inference for the data.frame is done
during initialisation by reading through <code>nprobe</code> lines.  Warning: if
there is a type-mismatch further into the file than it is probed, then you
will get missing values in the data.frame, or JSON values not captured in
the R data.
</p>
<p>No flattening of the namespace is done i.e. nested object remain nested.
</p>


<h3>Value</h3>

<p>NDJSON data read into R as list or data.frame depending
on <code>'type'</code> argument
</p>


<h3>See Also</h3>

<p>Other JSON Parsers: 
<code><a href="#topic+read_json_conn">read_json_conn</a>()</code>,
<code><a href="#topic+read_json_file">read_json_file</a>()</code>,
<code><a href="#topic+read_json_raw">read_json_raw</a>()</code>,
<code><a href="#topic+read_json_str">read_json_str</a>()</code>,
<code><a href="#topic+read_ndjson_file">read_ndjson_file</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
json &lt;- write_ndjson_str(head(mtcars))
read_ndjson_str(json, type = 'list')

</code></pre>

<hr>
<h2 id='validate_json_file'>Validate JSON in file or string</h2><span id='topic+validate_json_file'></span><span id='topic+validate_json_str'></span>

<h3>Description</h3>

<p>Validate JSON in file or string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_json_file(filename, verbose = FALSE, opts = list(), ...)

validate_json_str(str, verbose = FALSE, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_json_file_+3A_filename">filename</code></td>
<td>
<p>path to file containing JSON</p>
</td></tr>
<tr><td><code id="validate_json_file_+3A_verbose">verbose</code></td>
<td>
<p>logical. If the JSON is not valid, should a warning be
shown giving details?</p>
</td></tr>
<tr><td><code id="validate_json_file_+3A_opts">opts</code></td>
<td>
<p>Named list of options for parsing. Usually created by <code>opts_read_json()</code></p>
</td></tr>
<tr><td><code id="validate_json_file_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_read_json">opts_read_json()</a></code></p>
</td></tr>
<tr><td><code id="validate_json_file_+3A_str">str</code></td>
<td>
<p>character string containing JSON</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value. TRUE if JSON validates as OK, otherwise FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_json_file(head(iris, 3), tmp)
validate_json_file(tmp)
str &lt;- write_json_str(iris)
validate_json_str(str)
</code></pre>

<hr>
<h2 id='write_geojson_str'>Write SF to GeoJSON string</h2><span id='topic+write_geojson_str'></span><span id='topic+write_geojson_file'></span>

<h3>Description</h3>

<p>Write SF to GeoJSON string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_geojson_str(x, opts = list(), ..., json_opts = list())

write_geojson_file(x, filename, opts = list(), ..., json_opts = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_geojson_str_+3A_x">x</code></td>
<td>
<p><code>sf</code> object. Supports <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="write_geojson_str_+3A_opts">opts</code></td>
<td>
<p>named list of options. Usually created with <code>opts_write_geojson()</code>.
Default: empty <code>list()</code> to use the default options.</p>
</td></tr>
<tr><td><code id="write_geojson_str_+3A_...">...</code></td>
<td>
<p>any extra named options override those in <code>opts</code></p>
</td></tr>
<tr><td><code id="write_geojson_str_+3A_json_opts">json_opts</code></td>
<td>
<p>Named list of vanilla JSON options as used by <code>write_json_str()</code>.
This is usually created with <code>opts_write_json()</code>.  Default value is
an empty <code>list()</code> which means to use all the default JSON writing
options which is usually the correct thing to do when writing GeoJSON.</p>
</td></tr>
<tr><td><code id="write_geojson_str_+3A_filename">filename</code></td>
<td>
<p>filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string containing GeoJSON, or <code>NULL</code> if GeoJSON
written to file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geojson_file &lt;- system.file("geojson-example.json", package = 'yyjsonr')
sf &lt;- read_geojson_file(geojson_file)
cat(write_geojson_str(sf, json_opts = opts_write_json(pretty = TRUE)))
</code></pre>

<hr>
<h2 id='write_json_file'>Convert R object to JSON file</h2><span id='topic+write_json_file'></span>

<h3>Description</h3>

<p>Convert R object to JSON file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_json_file(x, filename, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_json_file_+3A_x">x</code></td>
<td>
<p>the object to be encoded</p>
</td></tr>
<tr><td><code id="write_json_file_+3A_filename">filename</code></td>
<td>
<p>filename</p>
</td></tr>
<tr><td><code id="write_json_file_+3A_opts">opts</code></td>
<td>
<p>Named list of serialization options. Usually created by <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
<tr><td><code id="write_json_file_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p>Other JSON Serializer: 
<code><a href="#topic+write_json_str">write_json_str</a>()</code>,
<code><a href="#topic+write_ndjson_file">write_ndjson_file</a>()</code>,
<code><a href="#topic+write_ndjson_str">write_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_json_file(head(iris, 3), tmp)
read_json_file(tmp)
</code></pre>

<hr>
<h2 id='write_json_str'>Convert R object to JSON string</h2><span id='topic+write_json_str'></span>

<h3>Description</h3>

<p>Convert R object to JSON string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_json_str(x, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_json_str_+3A_x">x</code></td>
<td>
<p>the object to be encoded</p>
</td></tr>
<tr><td><code id="write_json_str_+3A_opts">opts</code></td>
<td>
<p>Named list of serialization options. Usually created by <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
<tr><td><code id="write_json_str_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single string containing JSON
</p>


<h3>See Also</h3>

<p>Other JSON Serializer: 
<code><a href="#topic+write_json_file">write_json_file</a>()</code>,
<code><a href="#topic+write_ndjson_file">write_ndjson_file</a>()</code>,
<code><a href="#topic+write_ndjson_str">write_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>write_json_str(head(iris, 3), pretty = TRUE)
</code></pre>

<hr>
<h2 id='write_ndjson_file'>Write list or data.frame object to NDJSON in a file</h2><span id='topic+write_ndjson_file'></span>

<h3>Description</h3>

<p>For <code>list</code> input, each element of the list is written as a single JSON string.
For <code>data.frame</code> input, each row of the <code>data.frame</code> is written
as aJSON string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_ndjson_file(x, filename, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_ndjson_file_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or <code>list</code> to be written as multiple JSON strings</p>
</td></tr>
<tr><td><code id="write_ndjson_file_+3A_filename">filename</code></td>
<td>
<p>JSON strings will be written to this file one-line-per-JSON string.</p>
</td></tr>
<tr><td><code id="write_ndjson_file_+3A_opts">opts</code></td>
<td>
<p>Named list of serialization options. Usually created by <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
<tr><td><code id="write_ndjson_file_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p>Other JSON Serializer: 
<code><a href="#topic+write_json_file">write_json_file</a>()</code>,
<code><a href="#topic+write_json_str">write_json_str</a>()</code>,
<code><a href="#topic+write_ndjson_str">write_ndjson_str</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_ndjson_file(head(mtcars), tmp)
read_ndjson_file(tmp)
</code></pre>

<hr>
<h2 id='write_ndjson_str'>Write list or data.frame object to NDJSON in a string</h2><span id='topic+write_ndjson_str'></span>

<h3>Description</h3>

<p>For <code>list</code> input, each element of the list is written as a single JSON string.
For <code>data.frame</code> input, each row of the <code>data.frame</code> is written
as aJSON string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_ndjson_str(x, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_ndjson_str_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or <code>list</code> to be written as multiple JSON strings</p>
</td></tr>
<tr><td><code id="write_ndjson_str_+3A_opts">opts</code></td>
<td>
<p>Named list of serialization options. Usually created by <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
<tr><td><code id="write_ndjson_str_+3A_...">...</code></td>
<td>
<p>Other named options can be used to override any options in <code>opts</code>.
The valid named options are identical to arguments to <code><a href="#topic+opts_write_json">opts_write_json()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>String containing multiple JSON strings separated by newlines.
</p>


<h3>See Also</h3>

<p>Other JSON Serializer: 
<code><a href="#topic+write_json_file">write_json_file</a>()</code>,
<code><a href="#topic+write_json_str">write_json_str</a>()</code>,
<code><a href="#topic+write_ndjson_file">write_ndjson_file</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>write_ndjson_str(head(mtcars))
</code></pre>

<hr>
<h2 id='yyjson_read_flag'>Advanced: Values for setting internal options directly on YYJSON library</h2><span id='topic+yyjson_read_flag'></span>

<h3>Description</h3>

<p>This is a list of integer values used for setting flags on the <code>yyjson</code>
code directly.  This is an ADVANCED option and should be used with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yyjson_read_flag
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>


<h3>Details</h3>

<p>Some of these settings overlap and conflict with code needed to handle
the translation of JSON values to R.
</p>
<p><code>opts_read_json(yyjson_read_flag = c(yyjson_read_flag$x, yyjson_read_flag$y, ...))</code>
</p>

<dl>
<dt>YYJSON_READ_NOFLAG</dt><dd>
<p>Default option (RFC 8259 compliant):
</p>

<ul>
<li><p>Read positive integer as uint64_t.
</p>
</li>
<li><p>Read negative integer as int64_t.
</p>
</li>
<li><p>Read floating-point number as double with round-to-nearest mode.
</p>
</li>
<li><p>Read integer which cannot fit in uint64_t or int64_t as double.
</p>
</li>
<li><p>Report error if double number is infinity.
</p>
</li>
<li><p>Report error if string contains invalid UTF-8 character or BOM.
</p>
</li>
<li><p>Report error on trailing commas, comments, inf and nan literals.
</p>
</li></ul>

</dd>
<dt>YYJSON_READ_INSITU</dt><dd>
<p>Read the input data in-situ.
This option allows the reader to modify and use input data to store string
values, which can increase reading speed slightly.
The caller should hold the input data before free the document.
The input data must be padded by at least <code>YYJSON_PADDING_SIZE</code> bytes.
For example: <code>"[1,2]"</code> should be <code>"[1,2]\0\0\0\0"</code>, input length should be 5.
</p>
</dd>
<dt>YYJSON_READ_STOP_WHEN_DONE</dt><dd>
<p>Stop when done instead of issuing an error if there's additional content
after a JSON document. This option may be used to parse small pieces of JSON
in larger data, such as &quot;NDJSON&quot;
</p>
</dd>
<dt>YYJSON_READ_ALLOW_TRAILING_COMMAS</dt><dd>
<p>Allow single trailing comma at the end of an object or array,
such as <code>"[1,2,3,]"</code>
</p>
</dd>
<dt>YYJSON_READ_ALLOW_COMMENTS</dt><dd>
<p>Allow C-style single line and multiple line comments (non-standard).
</p>
</dd>
<dt>YYJSON_READ_ALLOW_INF_AND_NAN</dt><dd>
<p>Allow inf/nan number and literal, case-insensitive,
such as 1e999, NaN, inf, -Infinity (non-standard).
</p>
</dd>
<dt>YYJSON_READ_NUMBER_AS_RAW</dt><dd>
<p>Read all numbers as raw strings (value with &quot;YYJSON_TYPE_RAW&quot; type),
inf/nan literal is also read as raw with &quot;ALLOW_INF_AND_NAN&quot; flag.
</p>
</dd>
<dt>YYJSON_READ_ALLOW_INVALID_UNICODE</dt><dd>
<p>Allow reading invalid unicode when parsing string values (non-standard).
Invalid characters will be allowed to appear in the string values, but
invalid escape sequences will still be reported as errors.
This flag does not affect the performance of correctly encoded strings.
WARNING: Strings in JSON values may contain incorrect encoding when this
option is used, you need to handle these strings carefully to avoid security
risks.
</p>
</dd>
<dt>YYJSON_READ_BIGNUM_AS_RAW</dt><dd>
<p>Read big numbers as raw strings. These big numbers include integers that
cannot be represented by &quot;int64_t&quot; and &quot;uint64_t&quot;, and floating-point
numbers that cannot be represented by finite &quot;double&quot;.
The flag will be overridden by &quot;YYJSON_READ_NUMBER_AS_RAW&quot; flag.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>read_json_str(
   '[12.3]', 
   opts = opts_read_json(yyjson_read_flag = yyjson_read_flag$YYJSON_READ_ALLOW_TRAILING_COMMAS)
 )
</code></pre>

<hr>
<h2 id='yyjson_version'>Version number of 'yyjson' C library</h2><span id='topic+yyjson_version'></span>

<h3>Description</h3>

<p>Version number of 'yyjson' C library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yyjson_version()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>yyjson_version()
</code></pre>

<hr>
<h2 id='yyjson_write_flag'>Advanced: Values for setting internal options directly on YYJSON library</h2><span id='topic+yyjson_write_flag'></span>

<h3>Description</h3>

<p>This is a list of integer values used for setting flags on the <code>yyjson</code>
code directly.  This is an ADVANCED option and should be used with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yyjson_write_flag
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>


<h3>Details</h3>

<p>Some of these settings overlap and conflict with code needed to handle
the translation of JSON values to R.
</p>
<p><code>opts_write_json(yyjson_write_flag = c(write_flag$x, write_flag$y, ...))</code>
</p>

<dl>
<dt>YYJSON_WRITE_NOFLAG</dt><dd>
<p>Default value.
</p>

<ul>
<li><p>Write JSON minify.
</p>
</li>
<li><p>Report error on inf or nan number.
</p>
</li>
<li><p>Report error on invalid UTF-8 string.
</p>
</li>
<li><p>Do not escape unicode or slash.
</p>
</li></ul>

</dd>
<dt>YYJSON_WRITE_PRETTY</dt><dd><p>Write JSON pretty with 4 space indent.</p>
</dd>
<dt>YYJSON_WRITE_ESCAPE_UNICODE</dt><dd><p>Escape unicode as <code>uXXXX</code>, make the
output ASCII only.</p>
</dd>
<dt>YYJSON_WRITE_ESCAPE_SLASHES</dt><dd><p>Escape '/' as '\/'.</p>
</dd>
<dt>YYJSON_WRITE_ALLOW_INF_AND_NAN</dt><dd><p>Write inf and nan number as 'Infinity'
and 'NaN' literal (non-standard).</p>
</dd>
<dt>YYJSON_WRITE_INF_AND_NAN_AS_NULL</dt><dd><p>Write inf and nan number as null literal.
This flag will override <code>YYJSON_WRITE_ALLOW_INF_AND_NAN</code> flag.</p>
</dd>
<dt>YYJSON_WRITE_ALLOW_INVALID_UNICODE</dt><dd><p>Allow invalid unicode when encoding
string values (non-standard).
Invalid characters in string value will be copied byte by byte.
If <code>YYJSON_WRITE_ESCAPE_UNICODE</code> flag is also set, invalid character will be
escaped as <code>U+FFFD</code> (replacement character).
This flag does not affect the performance of correctly encoded strings.</p>
</dd>
<dt>YYJSON_WRITE_PRETTY_TWO_SPACES</dt><dd><p>Write JSON pretty with 2 space indent.
This flag will override <code>YYJSON_WRITE_PRETTY</code> flag.</p>
</dd>
<dt>YYJSON_WRITE_NEWLINE_AT_END</dt><dd><p>Adds a newline character
at the end of the JSON. This can be helpful for text editors or NDJSON</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>write_json_str("hello/there", opts = opts_write_json(
  yyjson_write_flag = yyjson_write_flag$YYJSON_WRITE_ESCAPE_SLASHES
))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
