<!DOCTYPE html><html><head><title>Help for package nanotime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nanotime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all.equal.nanoduration'><p>Test if Two Objects are (Nearly) Equal</p></a></li>
<li><a href='#all.equal.nanoival'><p>Test if Two Objects are (Nearly) Equal</p></a></li>
<li><a href='#all.equal.nanoperiod'><p>Test if Two Objects are (Nearly) Equal</p></a></li>
<li><a href='#all.equal.nanotime'><p>Test if Two Objects are (Nearly) Equal</p></a></li>
<li><a href='#intersect,nanoival,nanoival-method'><p>Set operations</p></a></li>
<li><a href='#is.unsorted,nanoival-method'><p>Test if a <code>nanoival</code> vector is Not Sorted</p></a></li>
<li><a href='#nano_ceiling'><p>Rounding down or up a <code>nanotime</code> type</p></a></li>
<li><a href='#nano_wday'><p>Get a component of a date time</p></a></li>
<li><a href='#nanoduration-class'><p>Duration type with nanosecond precision</p></a></li>
<li><a href='#nanoival-class'><p>Interval type with nanosecond precision</p></a></li>
<li><a href='#nanoperiod-class'><p>Period type with nanosecond precision</p></a></li>
<li><a href='#nanoperiod.month,nanoperiod-method'><p>Nanoperiod accessors</p></a></li>
<li><a href='#nanotime-class'><p>Nanosecond resolution datetime functionality</p></a></li>
<li><a href='#rep,nanoduration-method'><p>Replicate Elements</p></a></li>
<li><a href='#rep,nanoival-method'><p>Replicate Elements</p></a></li>
<li><a href='#rep,nanoperiod-method'><p>Replicate Elements</p></a></li>
<li><a href='#rep,nanotime-method'><p>Replicate Elements</p></a></li>
<li><a href='#seq,nanoival-method'><p>Sequence Generation</p></a></li>
<li><a href='#seq.nanoduration'><p>Sequence Generation</p></a></li>
<li><a href='#seq.nanotime'><p>Sequence Generation</p></a></li>
<li><a href='#sort,nanoival-method'><p>Sorting or Ordering Vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nanosecond-Resolution Time Support for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel and Leonardo Silvestri</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Full 64-bit resolution date and time functionality with
 nanosecond granularity is provided, with easy transition to and from
 the standard 'POSIXct' type. Three additional classes offer interval,
 period and duration functionality for nanosecond-resolution timestamps.</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, bit64, RcppCCTZ (&ge; 0.2.9), zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, data.table, xts</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppCCTZ, RcppDate</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eddelbuettel/nanotime">https://github.com/eddelbuettel/nanotime</a>,
<a href="https://eddelbuettel.github.io/nanotime/">https://eddelbuettel.github.io/nanotime/</a>,
<a href="https://dirk.eddelbuettel.com/code/nanotime.html">https://dirk.eddelbuettel.com/code/nanotime.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/nanotime/issues">https://github.com/eddelbuettel/nanotime/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'nanotime.R' 'nanoival.R' 'nanoduration.R' 'nanoperiod.R'
'RcppExports.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-24 00:26:28 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-24 07:02:51 UTC</td>
</tr>
</table>
<hr>
<h2 id='all.equal.nanoduration'>Test if Two Objects are (Nearly) Equal</h2><span id='topic+all.equal.nanoduration'></span><span id='topic+all.equal+2Cnanoduration-method'></span>

<h3>Description</h3>

<p>Compare <code>target</code> and <code>current</code> testing &lsquo;near
equality&rsquo;.  If they are different, comparison is still made to
some extent, and a report of the differences is returned.  Do not
use <code>all.equal</code> directly in <code>if</code> expressions&mdash;either
use <code>isTRUE(all.equal(....))</code> or <code><a href="base.html#topic+identical">identical</a></code> if
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoduration'
all.equal(
  target,
  current,
  tolerance = sqrt(.Machine$double.eps),
  scale = NULL,
  countEQ = FALSE,
  formatFUN = function(err, what) format(err),
  ...,
  check.attributes = TRUE
)

## S4 method for signature 'nanoduration'
all.equal(
  target,
  current,
  tolerance = sqrt(.Machine$double.eps),
  scale = NULL,
  countEQ = FALSE,
  formatFUN = function(err, what) format(err),
  ...,
  check.attributes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.nanoduration_+3A_target">target</code>, <code id="all.equal.nanoduration_+3A_current">current</code></td>
<td>
<p><code>nanoduration</code> arguments to be compared</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0. Differences smaller than
<code>tolerance</code> are not reported.  The default value is close
to <code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_scale">scale</code></td>
<td>
<p><code>NULL</code> or numeric &gt; 0, typically of length 1 or
<code>length(target)</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_counteq">countEQ</code></td>
<td>
<p>logical indicating if the <code>target == current</code> cases should be
counted when computing the mean (absolute or relative)
differences.  The default, <code>FALSE</code> may seem misleading in
cases where <code>target</code> and <code>current</code> only differ in a few
places; see the extensive example.</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_formatfun">formatFUN</code></td>
<td>
<p>a <code>function</code> of two arguments, <code>err</code>, the relative, absolute
or scaled error, and <code>what</code>, a character string indicating
the _kind_ of error; maybe used, e.g., to format relative and
absolute errors differently.</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_...">...</code></td>
<td>
<p>further arguments for different methods</p>
</td></tr>
<tr><td><code id="all.equal.nanoduration_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the <code>attributes</code> of <code>target</code>
and <code>current</code> (other than the names) should be compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>, <code><a href="base.html#topic+isTRUE">isTRUE</a></code>,
<code><a href="base.html#topic++3D+3D">==</a></code>, and <code><a href="base.html#topic+all">all</a></code> for exact equality
testing.
</p>

<hr>
<h2 id='all.equal.nanoival'>Test if Two Objects are (Nearly) Equal</h2><span id='topic+all.equal.nanoival'></span><span id='topic+all.equal+2Cnanoival-method'></span>

<h3>Description</h3>

<p>Compare <code>target</code> and <code>current</code> testing &lsquo;near
equality&rsquo;.  If they are different, comparison is still made to
some extent, and a report of the differences is returned.  Do not
use <code>all.equal</code> directly in <code>if</code> expressions&mdash;either
use <code>isTRUE(all.equal(....))</code> or <code><a href="base.html#topic+identical">identical</a></code> if
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoival'
all.equal(target, current, ..., check.attributes = TRUE)

## S4 method for signature 'nanoival'
all.equal(target, current, ..., check.attributes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.nanoival_+3A_target">target</code>, <code id="all.equal.nanoival_+3A_current">current</code></td>
<td>
<p><code>nanoival</code> arguments to be compared</p>
</td></tr>
<tr><td><code id="all.equal.nanoival_+3A_...">...</code></td>
<td>
<p>further arguments for different methods</p>
</td></tr>
<tr><td><code id="all.equal.nanoival_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the
<code>attributes</code> of <code>target</code> and <code>current</code> (other than
the names) should be compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>, <code><a href="base.html#topic+isTRUE">isTRUE</a></code>,
<code><a href="base.html#topic++3D+3D">==</a></code>, and <code><a href="base.html#topic+all">all</a></code> for exact equality
testing.
</p>

<hr>
<h2 id='all.equal.nanoperiod'>Test if Two Objects are (Nearly) Equal</h2><span id='topic+all.equal.nanoperiod'></span><span id='topic+all.equal+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p>Compare <code>target</code> and <code>current</code> testing &lsquo;near
equality&rsquo;.  If they are different, comparison is still made to
some extent, and a report of the differences is returned.  Do not
use <code>all.equal</code> directly in <code>if</code> expressions&mdash;either
use <code>isTRUE(all.equal(....))</code> or <code><a href="base.html#topic+identical">identical</a></code> if
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoperiod'
all.equal(target, current, ..., check.attributes = TRUE)

## S4 method for signature 'nanoperiod'
all.equal(target, current, ..., check.attributes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.nanoperiod_+3A_target">target</code>, <code id="all.equal.nanoperiod_+3A_current">current</code></td>
<td>
<p><code>nanoperiod</code> arguments to be compared</p>
</td></tr>
<tr><td><code id="all.equal.nanoperiod_+3A_...">...</code></td>
<td>
<p>further arguments for different methods</p>
</td></tr>
<tr><td><code id="all.equal.nanoperiod_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the
<code>attributes</code> of <code>target</code> and <code>current</code> (other than
the names) should be compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>, <code><a href="base.html#topic+isTRUE">isTRUE</a></code>,
<code><a href="base.html#topic++3D+3D">==</a></code>, and <code><a href="base.html#topic+all">all</a></code> for exact equality
testing.
</p>

<hr>
<h2 id='all.equal.nanotime'>Test if Two Objects are (Nearly) Equal</h2><span id='topic+all.equal.nanotime'></span><span id='topic+all.equal+2Cnanotime-method'></span>

<h3>Description</h3>

<p>Compare <code>target</code> and <code>current</code> testing &lsquo;near
equality&rsquo;.  If they are different, comparison is still made to
some extent, and a report of the differences is returned.  Do not
use <code>all.equal</code> directly in <code>if</code> expressions&mdash;either
use <code>isTRUE(all.equal(....))</code> or <code><a href="base.html#topic+identical">identical</a></code> if
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanotime'
all.equal(
  target,
  current,
  tolerance = sqrt(.Machine$double.eps),
  scale = NULL,
  countEQ = FALSE,
  formatFUN = function(err, what) format(err),
  ...,
  check.attributes = TRUE
)

## S4 method for signature 'nanotime'
all.equal(
  target,
  current,
  tolerance = sqrt(.Machine$double.eps),
  scale = NULL,
  countEQ = FALSE,
  formatFUN = function(err, what) format(err),
  ...,
  check.attributes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.nanotime_+3A_target">target</code>, <code id="all.equal.nanotime_+3A_current">current</code></td>
<td>
<p><code>nanotime</code> arguments to be compared</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0. Differences smaller than
<code>tolerance</code> are not reported.  The default value is close
to <code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_scale">scale</code></td>
<td>
<p><code>NULL</code> or numeric &gt; 0, typically of length 1 or
<code>length(target)</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_counteq">countEQ</code></td>
<td>
<p>logical indicating if the <code>target == current</code> cases should be
counted when computing the mean (absolute or relative)
differences.  The default, <code>FALSE</code> may seem misleading in
cases where <code>target</code> and <code>current</code> only differ in a few
places; see the extensive example.</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_formatfun">formatFUN</code></td>
<td>
<p>a <code>function</code> of two arguments, <code>err</code>, the relative, absolute
or scaled error, and <code>what</code>, a character string indicating
the _kind_ of error; maybe used, e.g., to format relative and
absolute errors differently.</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_...">...</code></td>
<td>
<p>further arguments for different methods</p>
</td></tr>
<tr><td><code id="all.equal.nanotime_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the <code>attributes</code> of <code>target</code>
and <code>current</code> (other than the names) should be compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>, <code><a href="base.html#topic+isTRUE">isTRUE</a></code>,
<code><a href="base.html#topic++3D+3D">==</a></code>, and <code><a href="base.html#topic+all">all</a></code> for exact equality
testing.
</p>

<hr>
<h2 id='intersect+2Cnanoival+2Cnanoival-method'>Set operations</h2><span id='topic+intersect+2Cnanoival+2Cnanoival-method'></span><span id='topic+union+2Cnanoival+2Cnanoival-method'></span><span id='topic+setdiff+2Cnanoival+2Cnanoival-method'></span><span id='topic+intersect.idx+2Cnanotime+2Cnanoival-method'></span><span id='topic+intersect.idx'></span><span id='topic++25in+25.nanotime'></span><span id='topic++25in+25+2Cnanotime+2Cnanoival-method'></span><span id='topic+intersect+2Cnanotime+2Cnanoival-method'></span><span id='topic+setdiff+2Cnanotime+2Cnanoival-method'></span><span id='topic+setdiff.idx+2Cnanotime+2Cnanoival-method'></span><span id='topic+setdiff.idx'></span><span id='topic+intersect+2Cnanotime+2Cnanotime-method'></span><span id='topic+union+2Cnanotime+2Cnanotime-method'></span><span id='topic+setdiff+2Cnanotime+2Cnanotime-method'></span>

<h3>Description</h3>

<p>Performs set intersection, union and difference between vectors of
temporal types from the <code>nanotime</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoival,nanoival'
intersect(x, y)

## S4 method for signature 'nanoival,nanoival'
union(x, y)

## S4 method for signature 'nanoival,nanoival'
setdiff(x, y)

## S4 method for signature 'nanotime,nanoival'
intersect.idx(x, y)

## S3 method for class 'nanotime'
x %in% table

## S4 method for signature 'nanotime,nanoival'
x %in% table

## S4 method for signature 'nanotime,nanoival'
intersect(x, y)

## S4 method for signature 'nanotime,nanoival'
setdiff(x, y)

## S4 method for signature 'nanotime,nanoival'
setdiff.idx(x, y)

## S4 method for signature 'nanotime,nanotime'
intersect(x, y)

## S4 method for signature 'nanotime,nanotime'
union(x, y)

## S4 method for signature 'nanotime,nanotime'
setdiff(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect+2B2Cnanoival+2B2Cnanoival-method_+3A_x">x</code>, <code id="intersect+2B2Cnanoival+2B2Cnanoival-method_+3A_y">y</code></td>
<td>
<p>a temporal type</p>
</td></tr>
<tr><td><code id="intersect+2B2Cnanoival+2B2Cnanoival-method_+3A_table">table</code></td>
<td>
<p><code>nanoival</code>: used in <code>%in%</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set operations between <code>nanoival</code> operands allow the
construction of complex interval vectors (i.e. a <code>nanoival</code>
vector can specify any number of inclusions and exclusions of
time). Set operations between <code>nanotime</code> and <code>nanoival</code>
allow to subset time vectors with interval vectors. In addition to
the generic set functions, the function <code>intersect.idx</code> is
defined which returns the indices of the intersection, and the
operator <code>%in%</code> is overloaded for <code>nanotime-nanoival</code>
which returns a logical vector that indicates which elements
belong to the interval vector.
</p>


<h3>Value</h3>

<p><code>intersect</code>, <code>union</code>, <code>setdiff</code> return
temporal types that are the result of the intersection. For
instance, set operations on two <code>nanoival</code> return a
<code>nanoival</code>, whereas intersection between a
<code>nanoival</code> and a <code>nanotime</code> returns a
<code>nanotime</code>. <code>intersect.idx</code> return a list of vectors
representing the element indices that intersect and
<code>setdiff.idx</code> returns a vector representing the element
indices to be removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## a vector of 'nanotime' can be subsetted by a 'nanoival' which is equivalent to 'intersect':
one_second &lt;- 1e9
a &lt;- seq(nanotime("2012-12-12 12:12:12+00:00"), length.out=10, by=one_second)
idx &lt;- c(as.nanoival("-2012-12-12 12:12:10+00:00 -&gt; 2012-12-12 12:12:14+00:00-"),
         as.nanoival("+2012-12-12 12:12:18+00:00 -&gt; 2012-12-12 12:12:20+00:00+"))
a[idx]
intersect(a, idx)

## 'nanoival' also has the set operations 'union', 'intersect', 'setdiff':
a &lt;- seq(nanotime("2012-12-12 12:12:12+00:00"), length.out=10, by=one_second)
i &lt;- as.nanoival("-2012-12-12 12:12:14+00:00 -&gt; 2012-12-12 12:12:18+00:00-")
setdiff(a, i)

i1 &lt;- as.nanoival("+2012-12-12 12:12:14+00:00 -&gt; 2012-12-12 12:12:17+00:00-")
i2 &lt;- as.nanoival("+2012-12-12 12:12:16+00:00 -&gt; 2012-12-12 12:12:18+00:00-")
union(i1, i2)

## 'intersect.idx' returns the indices of the intersection:
a &lt;- seq(nanotime("2012-12-12 12:12:12+00:00"), length.out=10, by=one_second)
idx &lt;- as.nanoival("+2012-12-12 12:12:14+00:00 -&gt; 2012-12-12 12:12:19+00:00+")
idx_intersect &lt;- intersect.idx(a, idx)

## Intersection can be performed using these indices:
a[idx_intersect$x]

## which is equivalent to:
a[idx]

## The logical vector indicating intersection can be obtained like this:
a %in% idx

## End(Not run)
</code></pre>

<hr>
<h2 id='is.unsorted+2Cnanoival-method'>Test if a <code>nanoival</code> vector is Not Sorted</h2><span id='topic+is.unsorted+2Cnanoival-method'></span>

<h3>Description</h3>

<p>Test if an object is not sorted (in increasing order), without the
cost of sorting it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoival'
is.unsorted(x, na.rm = FALSE, strictly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.unsorted+2B2Cnanoival-method_+3A_x">x</code></td>
<td>
<p>a <code>nanoival</code> vector</p>
</td></tr>
<tr><td><code id="is.unsorted+2B2Cnanoival-method_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values be removed before
checking?</p>
</td></tr>
<tr><td><code id="is.unsorted+2B2Cnanoival-method_+3A_strictly">strictly</code></td>
<td>
<p>logical indicating if the check should be for
_strictly_ increasing values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>
</p>

<hr>
<h2 id='nano_ceiling'>Rounding down or up a <code>nanotime</code> type</h2><span id='topic+nano_ceiling'></span><span id='topic+nano_floor'></span><span id='topic+nano_ceiling+2Cnanotime+2Cnanoduration-method'></span><span id='topic+nano_floor+2Cnanotime+2Cnanoduration-method'></span><span id='topic+nano_ceiling+2Cnanotime+2Cnanoperiod-method'></span><span id='topic+nano_floor+2Cnanotime+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p>The functions <code>nano_floor</code> and <code>nano_ceiling</code> round down or up, respectively. Although
the underlying implementation of <code>nanotime</code> has negative numbers for values before
1970-01-01 UTC, the rounding is always done backward in time for <code>nano_floor</code> and forward
in time for <code>nano_ceiling</code>. The functions take a <code>nanotime</code> argument <code>x</code> which is
the instance to round, together with a second argument <code>precision</code> which indicates an
arbitrary precision to which the rounding should be performed. This argument can be either a
<code>nanoduration</code> or or a <code>nanoperiod</code>. In the latter case, the argument <code>tz</code> must
also be specified in order to give the <code>nanoperiod</code> a meaning. Finally, the <code>nanotime</code>
argument <code>origin</code> can be optionally specified to fix the rounding to a specific point in
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nano_ceiling(x, precision, ...)

nano_floor(x, precision, ...)

## S4 method for signature 'nanotime,nanoduration'
nano_ceiling(x, precision, origin = nanotime())

## S4 method for signature 'nanotime,nanoduration'
nano_floor(x, precision, origin = nanotime())

## S4 method for signature 'nanotime,nanoperiod'
nano_ceiling(x, precision, origin = nanotime(), tz)

## S4 method for signature 'nanotime,nanoperiod'
nano_floor(x, precision, origin = nanotime(), tz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nano_ceiling_+3A_x">x</code></td>
<td>
<p>a <code>nanotime</code> object which must be sorted</p>
</td></tr>
<tr><td><code id="nano_ceiling_+3A_precision">precision</code></td>
<td>
<p>a <code>nanoduration</code> or <code>nanoperiod</code> object
indicating the rounding precision</p>
</td></tr>
<tr><td><code id="nano_ceiling_+3A_...">...</code></td>
<td>
<p>for future additional arguments</p>
</td></tr>
<tr><td><code id="nano_ceiling_+3A_origin">origin</code></td>
<td>
<p>a <code>nanotime</code> scalar indicating the origin at which the rounding is considered</p>
</td></tr>
<tr><td><code id="nano_ceiling_+3A_tz">tz</code></td>
<td>
<p>a <code>character</code> scalar indicating the time zone in which to conduct the rounding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This flexible rounding must be understood in the context of a vector. The rounding precision can
then be considered as an interval that defines a grid over which the elements are either
assigned to the starting value of the interval to which they belong (<code>nano_floor</code>) or the
ending value of the interval to which they belong (<code>nano_ceiling</code>). This allows for a
grouping of a <code>nanotime</code> vector on which a statistic may then be run. In the examples
below, such a use case is shown in the context of a <code>data.table</code> object.
</p>
<p>If &quot;business&quot; concepts such as month or days are needed, the <code>argument</code> precision must be
of type <code>period</code>. It is then mandatory to specify the timezone argument <code>tz</code> as this
ensures timezone correctness of the intervals including for example for the rare hourly
transitions of some countries going from a timezone with a whole hour difference with UTC to one
with a fractional hour difference. In the case of a <code>period</code>, the functions align the
rounding if the precision is an integer divisor of a larger quantity. For instance, if one
specifies a rounding of 6 hours, a divisor of a day, the hours are aligned on days and the
rounding is made to a grid at hours 0, 6, 12 and 18 in the specified timezone. If the precision
is not a divisor, the grid is aligned to the nearest hour before the first element of the vector
to round.
</p>
<p>The argument <code>origin</code> controls the reference point of the rounding, allowing arbitrary
specification of the reference point of the rounding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## "classic" rounding:
nano_floor(as.nanotime("2010-10-10 11:12:15 UTC"), as.nanoduration("01:00:00"))
## rounding with arbitrary precision:
nano_floor(as.nanotime("2010-10-10 11:12:15 UTC"), as.nanoduration("06:00:00"))
nano_floor(as.nanotime("2010-10-10 11:23:15 UTC"), as.nanoduration("00:15:00"))
nano_ceiling(as.nanotime("2010-10-10 11:23:15 UTC"), as.nanoduration("01:15:23"))
## controlling the reference point via the 'origin' argument:
nano_ceiling(as.nanotime("2010-10-10 11:23:15 UTC"),
             as.nanoduration("01:15:23"),
             origin=as.nanotime("2010-10-10 11:23:15 UTC"))
## using business concepts and rounding across a daylight saving change:
v &lt;- seq(as.nanotime("2020-03-08 America/New_York"),
         by=as.nanoperiod("06:00:00"), length.out=8, tz="America/New_York")
print(nano_floor(v, as.nanoperiod("1d"), tz="America/New_York"), tz="America/New_York")
## using the concept in a 'data.table':
library(data.table)
n &lt;- 3 * 24
idx &lt;- seq(as.nanotime("2020-03-07 America/New_York"),
           by=as.nanoperiod("01:00:00"), length.out=n, tz="America/New_York")
dt &lt;- data.table(idx, a=1:n, b=2:(n+1))
dt_mean &lt;- dt[, list(mean = mean(a)),
              by=nano_ceiling(idx, as.nanoperiod("1d"), tz="America/New_York")]

## End(Not run)

</code></pre>

<hr>
<h2 id='nano_wday'>Get a component of a date time</h2><span id='topic+nano_wday'></span><span id='topic+nano_wday+2Cnanotime-method'></span><span id='topic+nano_mday+2Cnanotime-method'></span><span id='topic+nano_month+2Cnanotime-method'></span><span id='topic+nano_year+2Cnanotime-method'></span><span id='topic+nano_mday'></span><span id='topic+nano_month'></span><span id='topic+nano_year'></span>

<h3>Description</h3>

<p>Get a component of a date time. <code>nano_wday</code> returns the
numeric position in a week, with Sunday == 0. <code>nano_mday</code>
returns the numeric day (i.e. a value from 1 to
31). <code>nano_month</code> returns the month (i.e. a value from 1 to
12). <code>nano_year</code> returns the year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nano_wday(x, tz)

nano_mday(x, tz)

nano_month(x, tz)

nano_year(x, tz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nano_wday_+3A_x">x</code></td>
<td>
<p>a <code>nanotime</code> object</p>
</td></tr>
<tr><td><code id="nano_wday_+3A_tz">tz</code></td>
<td>
<p><code>character</code> a string representing a timezone</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>tz</code> parameter is mandatory because the day
boundary is different depending on the time zone and
<code>nanotime</code> does not store the timezone as it is just an
offset in nanoseconds from the epoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nano_wday(as.nanotime("2020-03-14 23:32:00-04:00"), "America/New_York")
nano_wday(as.nanotime("2020-03-14 23:32:00 America/New_York"), "Europe/Paris")
nano_mday(as.nanotime("2020-03-14 23:32:00-04:00"), "America/New_York")
nano_mday(as.nanotime("2020-03-14 23:32:00 America/New_York"), "Europe/Paris")
nano_month(as.nanotime("2020-12-31 23:32:00-04:00"), "America/New_York")
nano_month(as.nanotime("2020-12-31 23:32:00 America/New_York"), "Europe/Paris")
nano_year(as.nanotime("2020-12-31 23:32:00-04:00"), "America/New_York")
nano_year(as.nanotime("2020-12-31 23:32:00 America/New_York"), "Europe/Paris")

## End(Not run)

</code></pre>

<hr>
<h2 id='nanoduration-class'>Duration type with nanosecond precision</h2><span id='topic+nanoduration-class'></span><span id='topic+nanoduration'></span><span id='topic++2A+2CANY+2Cnanoduration-method'></span><span id='topic++2A+2Cnanoduration+2CANY-method'></span><span id='topic++2A+2Cnanoduration+2Cnanoduration-method'></span><span id='topic++2B+2CANY+2Cnanoduration-method'></span><span id='topic++2F+2CANY+2Cnanoduration-method'></span><span id='topic++2F+2Cnanoduration+2CANY-method'></span><span id='topic+Complex+2Cnanoduration-method'></span><span id='topic+Logic+2CANY+2Cnanoduration-method'></span><span id='topic+Logic+2Cnanoduration+2CANY-method'></span><span id='topic+Logic+2Cnanoduration+2Cnanoduration-method'></span><span id='topic+Math2+2Cnanoduration-method'></span><span id='topic+Math+2Cnanoduration-method'></span><span id='topic+Summary+2Cnanoduration-method'></span><span id='topic+as.nanoduration+2Ccharacter-method'></span><span id='topic+as.nanoduration'></span><span id='topic+as.nanoduration+2Cinteger64-method'></span><span id='topic+as.nanoduration+2Cnumeric-method'></span><span id='topic+as.nanoduration+2Cinteger-method'></span><span id='topic+as.nanoduration+2Cdifftime-method'></span><span id='topic+as.nanoduration+2CNULL-method'></span><span id='topic+as.nanoduration+2Cmissing-method'></span><span id='topic+show+2Cnanoduration-method'></span><span id='topic+print+2Cnanoduration-method'></span><span id='topic+format.nanoduration'></span><span id='topic+as.integer64.nanoduration'></span><span id='topic+as.character+2Cnanoduration-method'></span><span id='topic+is.na+2Cnanoduration-method'></span><span id='topic+-+2Cnanoduration+2Cnanoduration-method'></span><span id='topic+-+2Cnanoduration+2Cinteger64-method'></span><span id='topic+-+2Cnanoduration+2Cinteger-method'></span><span id='topic+-+2Cnanoduration+2Cnumeric-method'></span><span id='topic+-+2Cnanoduration+2Cdifftime-method'></span><span id='topic+-+2Cnanoduration+2CANY-method'></span><span id='topic+-+2Cnanotime+2Cnanoduration-method'></span><span id='topic+-+2Cnanotime+2Cdifftime-method'></span><span id='topic+-+2Cinteger64+2Cnanoduration-method'></span><span id='topic+-+2Cinteger+2Cnanoduration-method'></span><span id='topic+-+2Cnumeric+2Cnanoduration-method'></span><span id='topic+-+2Cdifftime+2Cnanoduration-method'></span><span id='topic+-+2CANY+2Cnanoduration-method'></span><span id='topic++2B+2Cnanoduration+2CANY-method'></span><span id='topic++2B+2Cnanoduration+2Cnanoduration-method'></span><span id='topic++2B+2Cnanoduration+2Cinteger64-method'></span><span id='topic++2B+2Cnanoduration+2Cnumeric-method'></span><span id='topic++2B+2Cnanoduration+2Cdifftime-method'></span><span id='topic++2B+2Cnanotime+2Cnanoduration-method'></span><span id='topic++2B+2Cnanotime+2Cdifftime-method'></span><span id='topic++2B+2Cnanoduration+2Cnanotime-method'></span><span id='topic++2B+2Cdifftime+2Cnanotime-method'></span><span id='topic++2B+2Cnanoival+2Cnanoduration-method'></span><span id='topic+-+2Cnanoival+2Cnanoduration-method'></span><span id='topic++2B+2Cnanoduration+2Cnanoival-method'></span><span id='topic++2B+2Cnanoival+2Cdifftime-method'></span><span id='topic+-+2Cnanoival+2Cdifftime-method'></span><span id='topic++2B+2Cdifftime+2Cnanoival-method'></span><span id='topic++2B+2Cinteger64+2Cnanoduration-method'></span><span id='topic++2B+2Cnumeric+2Cnanoduration-method'></span><span id='topic++2B+2Cdifftime+2Cnanoduration-method'></span><span id='topic++2A+2Cnanoduration+2Cnumeric-method'></span><span id='topic++2A+2Cnanoduration+2Cinteger64-method'></span><span id='topic++2A+2Cnumeric+2Cnanoduration-method'></span><span id='topic++2A+2Cinteger64+2Cnanoduration-method'></span><span id='topic++2F+2Cnanoduration+2Cnanoduration-method'></span><span id='topic++2F+2Cnanoduration+2Cinteger64-method'></span><span id='topic++2F+2Cnanoduration+2Cnumeric-method'></span><span id='topic+Arith+2Cnanoduration+2CANY-method'></span><span id='topic+Compare+2Cnanoduration+2Ccharacter-method'></span><span id='topic+Compare+2Ccharacter+2Cnanoduration-method'></span><span id='topic+Compare+2Cnanoduration+2CANY-method'></span><span id='topic+abs+2Cnanoduration-method'></span><span id='topic+sign+2Cnanoduration-method'></span><span id='topic+sum+2Cnanoduration-method'></span><span id='topic+min+2Cnanoduration-method'></span><span id='topic+max+2Cnanoduration-method'></span><span id='topic+range+2Cnanoduration-method'></span><span id='topic++5B+5B+2Cnanoduration-method'></span><span id='topic++5B+2Cnanoduration+2Cnumeric-method'></span><span id='topic++5B+2Cnanoduration+2Clogical-method'></span><span id='topic++5B+2Cnanoduration+2Ccharacter-method'></span><span id='topic++5B+2Cnanoduration+2CANY-method'></span><span id='topic++5B+3C-+2Cnanoduration+2CANY+2CANY+2CANY-method'></span><span id='topic+c.nanoduration'></span><span id='topic+NA_nanoduration_'></span>

<h3>Description</h3>

<p>The type <code>nanoduration</code> is a length of time (implemented as
an S4 class) with nanosecond precision. It is a count of
nanoseconds and may be negative. The expected arithmetic
operations are provided, including sequence generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoduration(hours = 0L, minutes = 0L, seconds = 0L, nanoseconds = 0L)

## S4 method for signature 'character'
as.nanoduration(x)

## S4 method for signature 'integer64'
as.nanoduration(x)

## S4 method for signature 'numeric'
as.nanoduration(x)

## S4 method for signature 'integer'
as.nanoduration(x)

## S4 method for signature 'difftime'
as.nanoduration(x)

## S4 method for signature ''NULL''
as.nanoduration(x)

## S4 method for signature 'missing'
as.nanoduration(x)

## S4 method for signature 'nanoduration'
show(object)

## S4 method for signature 'nanoduration'
print(x, quote = FALSE, ...)

## S3 method for class 'nanoduration'
format(x, ...)

## S3 method for class 'nanoduration'
as.integer64(x, ...)

## S4 method for signature 'nanoduration'
as.character(x)

## S4 method for signature 'nanoduration'
is.na(x)

## S4 method for signature 'nanoduration,nanoduration'
e1 - e2

## S4 method for signature 'nanoduration,integer64'
e1 - e2

## S4 method for signature 'nanoduration,integer'
e1 - e2

## S4 method for signature 'nanoduration,numeric'
e1 - e2

## S4 method for signature 'nanoduration,difftime'
e1 - e2

## S4 method for signature 'nanoduration,ANY'
e1 - e2

## S4 method for signature 'nanotime,nanoduration'
e1 - e2

## S4 method for signature 'nanotime,difftime'
e1 - e2

## S4 method for signature 'integer64,nanoduration'
e1 - e2

## S4 method for signature 'integer,nanoduration'
e1 - e2

## S4 method for signature 'numeric,nanoduration'
e1 - e2

## S4 method for signature 'difftime,nanoduration'
e1 - e2

## S4 method for signature 'ANY,nanoduration'
e1 - e2

## S4 method for signature 'nanoduration,ANY'
e1 + e2

## S4 method for signature 'nanoduration,nanoduration'
e1 + e2

## S4 method for signature 'nanoduration,integer64'
e1 + e2

## S4 method for signature 'nanoduration,numeric'
e1 + e2

## S4 method for signature 'nanoduration,difftime'
e1 + e2

## S4 method for signature 'nanotime,nanoduration'
e1 + e2

## S4 method for signature 'nanotime,difftime'
e1 + e2

## S4 method for signature 'nanoduration,nanotime'
e1 + e2

## S4 method for signature 'difftime,nanotime'
e1 + e2

## S4 method for signature 'nanoival,nanoduration'
e1 + e2

## S4 method for signature 'nanoival,nanoduration'
e1 - e2

## S4 method for signature 'nanoduration,nanoival'
e1 + e2

## S4 method for signature 'nanoival,difftime'
e1 + e2

## S4 method for signature 'nanoival,difftime'
e1 - e2

## S4 method for signature 'difftime,nanoival'
e1 + e2

## S4 method for signature 'integer64,nanoduration'
e1 + e2

## S4 method for signature 'numeric,nanoduration'
e1 + e2

## S4 method for signature 'difftime,nanoduration'
e1 + e2

## S4 method for signature 'nanoduration,numeric'
e1 * e2

## S4 method for signature 'nanoduration,integer64'
e1 * e2

## S4 method for signature 'numeric,nanoduration'
e1 * e2

## S4 method for signature 'integer64,nanoduration'
e1 * e2

## S4 method for signature 'nanoduration,nanoduration'
e1 / e2

## S4 method for signature 'nanoduration,integer64'
e1 / e2

## S4 method for signature 'nanoduration,numeric'
e1 / e2

## S4 method for signature 'nanoduration,ANY'
Arith(e1, e2)

## S4 method for signature 'nanoduration,character'
Compare(e1, e2)

## S4 method for signature 'character,nanoduration'
Compare(e1, e2)

## S4 method for signature 'nanoduration,ANY'
Compare(e1, e2)

## S4 method for signature 'nanoduration'
abs(x)

## S4 method for signature 'nanoduration'
sign(x)

## S4 method for signature 'nanoduration'
sum(x, ..., na.rm = FALSE)

## S4 method for signature 'nanoduration'
min(x, ..., na.rm = FALSE)

## S4 method for signature 'nanoduration'
max(x, ..., na.rm = FALSE)

## S4 method for signature 'nanoduration'
range(x, ..., na.rm = FALSE)

## S4 method for signature 'nanoduration'
x[[i, j, ..., drop = FALSE]]

## S4 method for signature 'nanoduration,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoduration,logical'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoduration,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoduration,ANY'
x[i, j, ..., drop = FALSE]

## S4 replacement method for signature 'nanoduration,ANY,ANY,ANY'
x[i, j, ...] &lt;- value

## S3 method for class 'nanoduration'
c(...)

NA_nanoduration_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoduration-class_+3A_hours">hours</code></td>
<td>
<p>number of hours</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_minutes">minutes</code></td>
<td>
<p>number of minutes</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_seconds">seconds</code></td>
<td>
<p>number of seconds</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_nanoseconds">nanoseconds</code></td>
<td>
<p>number of nanoseconds</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_x">x</code></td>
<td>
<p>a <code>nanoduration</code> object</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_object">object</code></td>
<td>
<p>argument for method <code>show</code></p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_quote">quote</code></td>
<td>
<p>indicates if the output of <code>print</code> should be
quoted</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_e1">e1</code></td>
<td>
<p>Operand of class <code>nanoival</code></p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_e2">e2</code></td>
<td>
<p>Operand of class <code>nanoival</code></p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> NA values are removed for the
computation</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_i">i</code></td>
<td>
<p>index specifying elements to extract or replace.</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_j">j</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_drop">drop</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanoduration-class_+3A_value">value</code></td>
<td>
<p>argument for <code>nanoduration-class</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>nanoduration</code> of length 1.
</p>


<h3>Details</h3>

<p>A <code>nanoduration</code> can be constructed with the function
<code>as.nanoduration</code> which can take the types <code>integer64</code>,
<code>integer</code> and <code>numeric</code> (all indicating the count in
nanosecond units) or the type <code>character</code>.
</p>
<p>It can also be constructed by specifying with individual arguments
the hours, minutes, seconds and nanoseconds with a call to
<code>nanoduration</code>.
</p>
<p>A <code>nanoduration</code> is displayed as hours, minutes, seconds and
nanoseconds like this: <code>110:12:34.123_453_001</code>. The nanosecond
precision displayed is adjusted as necessary, so e.g. 1 second is
displayed as <code>00:00:01</code>.
</p>


<h3>Value</h3>

<p>A nanoduration object
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>
<p>Leonardo Silvestri
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nanotime">nanotime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## constructors:
nanoduration(hours=10, minutes=3, seconds=2, nanoseconds=999999999)
as.nanoduration("10:03:02.999_999_999")
as.nanoduration(36182999999999)

## arithmetic:
as.nanoduration(10e9) - as.nanoduration(9e9)
as.nanoduration(10e9) + as.nanoduration(-9e9)
as.nanoduration("24:00:00") / 2
as.nanoduration("24:00:00") / as.nanoduration("12:00:00")

## comparison:
as.nanoduration("10:03:02.999_999_999") == 36182999999999
as.nanoduration("10:03:02.999_999_999") &gt; as.nanoduration("10:03:02.999_999_998")
as.nanoduration("10:03:02.999_999_998") &lt; "10:03:02.999_999_999"

</code></pre>

<hr>
<h2 id='nanoival-class'>Interval type with nanosecond precision</h2><span id='topic+nanoival-class'></span><span id='topic+nanoival'></span><span id='topic++2B+2CANY+2Cnanoival-method'></span><span id='topic++2B+2Cnanoival+2CANY-method'></span><span id='topic++2B+2Cnanoival+2Cnanoival-method'></span><span id='topic+-+2CANY+2Cnanoival-method'></span><span id='topic+-+2Cnanoival+2CANY-method'></span><span id='topic+-+2Cnanoival+2Cnanoival-method'></span><span id='topic+Arith+2Cnanoival+2CANY-method'></span><span id='topic+Compare+2Cnanoival+2CANY-method'></span><span id='topic+Complex+2Cnanoival-method'></span><span id='topic+Logic+2CANY+2Cnanoival-method'></span><span id='topic+Logic+2Cnanoival+2CANY-method'></span><span id='topic+Logic+2Cnanoival+2Cnanoival-method'></span><span id='topic+Math2+2Cnanoival-method'></span><span id='topic+Math+2Cnanoival-method'></span><span id='topic+Summary+2Cnanoival-method'></span><span id='topic+nanoival.start+2Cnanoival-method'></span><span id='topic+nanoival.start'></span><span id='topic+nanoival.end+2Cnanoival-method'></span><span id='topic+nanoival.end'></span><span id='topic+nanoival.sopen+2Cnanoival-method'></span><span id='topic+nanoival.sopen'></span><span id='topic+nanoival.eopen+2Cnanoival-method'></span><span id='topic+nanoival.eopen'></span><span id='topic+format.nanoival'></span><span id='topic+print+2Cnanoival-method'></span><span id='topic+show+2Cnanoival-method'></span><span id='topic+as.nanoival+2Ccharacter-method'></span><span id='topic+as.nanoival'></span><span id='topic+as.nanoival+2CNULL-method'></span><span id='topic+as.nanoival+2Cmissing-method'></span><span id='topic+is.na+2Cnanoival-method'></span><span id='topic+is.na+3C-+2Cnanoival-method'></span><span id='topic++3C+2Cnanoival+2Cnanoival-method'></span><span id='topic++3C+3D+2Cnanoival+2Cnanoival-method'></span><span id='topic++3E+2Cnanoival+2Cnanoival-method'></span><span id='topic++3E+3D+2Cnanoival+2Cnanoival-method'></span><span id='topic++3D+3D+2Cnanoival+2Cnanoival-method'></span><span id='topic++21+3D+2Cnanoival+2Cnanoival-method'></span><span id='topic+-+2Cnanoival+2Cinteger64-method'></span><span id='topic+-+2Cnanoival+2Cnumeric-method'></span><span id='topic++2B+2Cnanoival+2Cinteger64-method'></span><span id='topic++2B+2Cnanoival+2Cnumeric-method'></span><span id='topic++2B+2Cinteger64+2Cnanoival-method'></span><span id='topic++2B+2Cnumeric+2Cnanoival-method'></span><span id='topic++5B+5B+2Cnanoival-method'></span><span id='topic++5B+2Cnanoival+2Clogical-method'></span><span id='topic++5B+2Cnanoival+2Cnumeric-method'></span><span id='topic++5B+2Cnanoival+2Ccharacter-method'></span><span id='topic++5B+2Cnanoival+2CANY-method'></span><span id='topic++5B+3C-+2Cnanoival+2Clogical+2CANY+2Cnanoival-method'></span><span id='topic+c.nanoival'></span><span id='topic+t+2Cnanoival-method'></span><span id='topic++5B+2Cnanotime+2Cnanoival-method'></span><span id='topic+NA_nanoival_'></span><span id='topic+as.character.nanoival'></span>

<h3>Description</h3>

<p><code>nanoival</code> is a time interval type (an S4 class) with
nanosecond precision. One of its purposes is to allow quick
subsetting of a <code>nanotime</code> vector. <code>nanoival</code> is
composed of a <code>nanotime</code> pair which defines the start and end
of the time interval. Additionally, it has a pair of logical
values which determine if the start and end of the time interval
are open (true) or closed (false).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoival(start, end, sopen = FALSE, eopen = TRUE)

## S4 method for signature 'nanoival'
nanoival.start(x)

## S4 method for signature 'nanoival'
nanoival.end(x)

## S4 method for signature 'nanoival'
nanoival.sopen(x)

## S4 method for signature 'nanoival'
nanoival.eopen(x)

## S3 method for class 'nanoival'
format(x, ...)

## S4 method for signature 'nanoival'
print(x, quote = FALSE, ...)

## S4 method for signature 'nanoival'
show(object)

## S4 method for signature 'character'
as.nanoival(from, format = "", tz = "")

## S4 method for signature ''NULL''
as.nanoival(from, format = "", tz = "")

## S4 method for signature 'missing'
as.nanoival(from, format = "", tz = "")

## S4 method for signature 'nanoival'
is.na(x)

## S4 replacement method for signature 'nanoival'
is.na(x) &lt;- value

## S4 method for signature 'nanoival,nanoival'
e1 &lt; e2

## S4 method for signature 'nanoival,nanoival'
e1 &lt;= e2

## S4 method for signature 'nanoival,nanoival'
e1 &gt; e2

## S4 method for signature 'nanoival,nanoival'
e1 &gt;= e2

## S4 method for signature 'nanoival,nanoival'
e1 == e2

## S4 method for signature 'nanoival,nanoival'
e1 != e2

## S4 method for signature 'nanoival,integer64'
e1 - e2

## S4 method for signature 'nanoival,numeric'
e1 - e2

## S4 method for signature 'nanoival,integer64'
e1 + e2

## S4 method for signature 'nanoival,numeric'
e1 + e2

## S4 method for signature 'integer64,nanoival'
e1 + e2

## S4 method for signature 'numeric,nanoival'
e1 + e2

## S4 method for signature 'nanoival'
x[[i, j, ..., drop = FALSE]]

## S4 method for signature 'nanoival,logical'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoival,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoival,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoival,ANY'
x[i, j, ..., drop = FALSE]

## S4 replacement method for signature 'nanoival,logical,ANY,nanoival'
x[i, j, ...] &lt;- value

## S3 method for class 'nanoival'
c(...)

## S4 method for signature 'nanoival'
t(x)

## S4 method for signature 'nanotime,nanoival'
x[i, j, ..., drop = TRUE]

NA_nanoival_

## S3 method for class 'nanoival'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoival-class_+3A_start">start</code></td>
<td>
<p><code>nanotime</code> start of interval</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_end">end</code></td>
<td>
<p><code>nanotime</code> end of interval</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_sopen">sopen</code></td>
<td>
<p>logical indicating if the start of the interval is open</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_eopen">eopen</code></td>
<td>
<p>logical indicating if the end of the interval is open</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_x">x</code>, <code id="nanoival-class_+3A_from">from</code></td>
<td>
<p>a <code>nanoival</code> object</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_quote">quote</code></td>
<td>
<p>indicates if the output of <code>print</code> should be
quoted</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_object">object</code></td>
<td>
<p>argument for method <code>show</code></p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_format">format</code></td>
<td>
<p>A character string. Can also be set via
<code>options("nanotimeFormat")</code> and uses
&lsquo;%Y-%m-%dT%H:%M:%E9S%Ez&rsquo; as a default and
fallback</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_tz">tz</code></td>
<td>
<p><code>character</code> indicating a timezone</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_value">value</code></td>
<td>
<p>argument for <code>nanoival-class</code></p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_e1">e1</code></td>
<td>
<p>Operand of class <code>nanoival</code></p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_e2">e2</code></td>
<td>
<p>Operand of class <code>nanoival</code></p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_i">i</code></td>
<td>
<p>index specifying elements to extract or replace.</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_j">j</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanoival-class_+3A_drop">drop</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>nanoival</code> of length 1.
</p>


<h3>Details</h3>

<p>An interval object can be constructed with the constructor
<code>nanoival</code> which takes as arguments two <code>nanotime</code>
objects that define the start and the end of the interval,
together with two <code>logical</code> arguments that define if the
start and the end of the interval are open (true) or closed
(false) (note that these objects can all be vector, and therefore
the interval object is not necessarily scalar). Alternatively, an
interval can be constructed with a <code>character</code>: the format
follows that of <code>nanotime</code>; the start time is preceeded by
either <code>-</code> or <code>+</code> indicating if the interval start is
open (-) or closed (+); the start and end times are separated by
an arrow <code>-&gt;</code>; the end is folloed by either <code>-</code> or
<code>+</code> which have the same semantics as the start time.
</p>
<p>The most important set of methods defined for <code>interval</code> are
set functions <code>intersect</code>, <code>union</code> and <code>setdiff</code>.
</p>
<p>Additionally, <code>interval</code> allows the subsetting into a
<code>nanotime</code> vector. Note that subsetting is allowed only if
the <code>nanotime</code> vector is sorted.
</p>
<p>Finally, accessors are provided to get the interval start
(<code>start</code>), the end (<code>end</code>), the open/close status of the
start (<code>sopen</code>) and the open/close status of the end
(<code>eopen</code>). The former return a <code>nanotime</code> while the
latter return a <code>logical</code>.
</p>


<h3>Value</h3>

<p>A nanoival object
</p>


<h3>Output Format</h3>

<p>Formatting and character conversion for <code>nanoival</code> objects is
identical to <code>nanotime</code> objects. The default format is
ISO3339 compliant: <code>%Y-%m-%dT%H:%M:%E9S%Ez</code>. It
specifies a standard ISO 8601 part for date and time &mdash; as well
as nine digits of precision for fractional seconds (down to
nanoseconds) and on offset (typically zero as we default to UTC).
It can be overriden by using <code>options()</code> with the key of
<code>nanotimeFormat</code> and a suitable value. Similarly,
<code>nanotimeTz</code> can be used to select a different timezone.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>
<p>Leonardo Silvestri
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.idx">intersect.idx</a></code>, <code><a href="#topic+setdiff.idx">setdiff.idx</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## creating a \code{nanoival}, with the start time included ('+') and the end
## time excluded ('-')
as.nanoival("+2012-03-01T21:21:00.000000001+00:00-&gt;2015-01-01T21:22:00.000000999+04:00-")

## a \code{nanoival} can also be created with a pair of \code{nanotime} objects, a start
## and an end, and optionally two logicals determining if the interval start(end) are open
## or closed; by default the start is closed and end is open:
start &lt;- nanotime("2012-03-01T21:21:00.000000001+00:00")
end &lt;- nanotime("2013-03-01T21:21:00.000000001+00:00")
nanoival(start, end)

## a vector of 'nanotime' can be subsetted by a 'nanoival':
one_second &lt;- 1e9
a &lt;- seq(nanotime("2012-12-12 12:12:12+00:00"), length.out=10, by=one_second)
idx &lt;- c(as.nanoival("-2012-12-12 12:12:10+00:00 -&gt; 2012-12-12 12:12:14+00:00-"),
         as.nanoival("+2012-12-12 12:12:18+00:00 -&gt; 2012-12-12 12:12:20+00:00+"))
a[idx]

## End(Not run)
</code></pre>

<hr>
<h2 id='nanoperiod-class'>Period type with nanosecond precision</h2><span id='topic+nanoperiod-class'></span><span id='topic+nanoperiod'></span><span id='topic+Compare+2CANY+2Cnanoperiod-method'></span><span id='topic+Compare+2Cnanoperiod+2CANY-method'></span><span id='topic+-+2CANY+2Cnanoperiod-method'></span><span id='topic+-+2Cnanoperiod+2Cnanotime-method'></span><span id='topic+-+2Cnanotime+2Cnanoperiod-method'></span><span id='topic++2F+2CANY+2Cnanoperiod-method'></span><span id='topic++2F+2Cnanoperiod+2CANY-method'></span><span id='topic+Complex+2Cnanoperiod-method'></span><span id='topic+Math+2Cnanoperiod-method'></span><span id='topic+Math2+2Cnanoperiod-method'></span><span id='topic+Summary+2Cnanoperiod-method'></span><span id='topic+minus+2Cnanoperiod+2Cnanoival+2Ccharacter-method'></span><span id='topic+as.nanoperiod+2Ccharacter-method'></span><span id='topic+as.nanoperiod'></span><span id='topic+as.nanoperiod+2Cinteger64-method'></span><span id='topic+as.nanoperiod+2Cnumeric-method'></span><span id='topic+as.nanoperiod+2Cinteger-method'></span><span id='topic+as.nanoperiod+2Cnanoduration-method'></span><span id='topic+as.nanoperiod+2CNULL-method'></span><span id='topic+as.nanoperiod+2Cmissing-method'></span><span id='topic+show+2Cnanoperiod-method'></span><span id='topic+print+2Cnanoperiod-method'></span><span id='topic+format.nanoperiod'></span><span id='topic+as.character+2Cnanoperiod-method'></span><span id='topic+is.na+2Cnanoperiod-method'></span><span id='topic+is.na+3C-+2Cnanoperiod-method'></span><span id='topic++5B+5B+2Cnanoperiod-method'></span><span id='topic++5B+2Cnanoperiod+2Cnumeric-method'></span><span id='topic++5B+2Cnanoperiod+2Clogical-method'></span><span id='topic++5B+2Cnanoperiod+2Ccharacter-method'></span><span id='topic++5B+2Cnanoperiod+2CANY-method'></span><span id='topic++5B+3C-+2Cnanoperiod+2CANY+2CANY+2CANY-method'></span><span id='topic+c.nanoperiod'></span><span id='topic+names+2Cnanoperiod-method'></span><span id='topic+names+3C-+2Cnanoperiod-method'></span><span id='topic+-+2Cnanoperiod+2CANY-method'></span><span id='topic+-+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic+-+2Cnanoperiod+2Cnanoduration-method'></span><span id='topic+-+2Cnanoperiod+2Cinteger64-method'></span><span id='topic+-+2Cnanoperiod+2Cnumeric-method'></span><span id='topic+-+2Cnanoduration+2Cnanoperiod-method'></span><span id='topic+-+2Cinteger64+2Cnanoperiod-method'></span><span id='topic+-+2Cnumeric+2Cnanoperiod-method'></span><span id='topic++2B+2Cnanoperiod+2CANY-method'></span><span id='topic++2B+2CANY+2Cnanoperiod-method'></span><span id='topic++2B+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic++2B+2Cnanoperiod+2Cnanoduration-method'></span><span id='topic++2B+2Cnanoperiod+2Cinteger64-method'></span><span id='topic++2B+2Cnanoperiod+2Cnanotime-method'></span><span id='topic++2B+2Cnanoival+2Cnanoperiod-method'></span><span id='topic++2B+2Cnanoperiod+2Cnanoival-method'></span><span id='topic++2B+2Cnanotime+2Cnanoperiod-method'></span><span id='topic++2B+2Cnanoperiod+2Cnumeric-method'></span><span id='topic++2B+2Cnanoduration+2Cnanoperiod-method'></span><span id='topic++2B+2Cinteger64+2Cnanoperiod-method'></span><span id='topic++2B+2Cnumeric+2Cnanoperiod-method'></span><span id='topic++2A+2Cnanoperiod+2Cinteger64-method'></span><span id='topic++2A+2Cnanoperiod+2CANY-method'></span><span id='topic++2A+2CANY+2Cnanoperiod-method'></span><span id='topic++2A+2Cnanoperiod+2Cnumeric-method'></span><span id='topic++2A+2Cinteger64+2Cnanoperiod-method'></span><span id='topic++2A+2Cnumeric+2Cnanoperiod-method'></span><span id='topic++2F+2Cnanoperiod+2Cinteger64-method'></span><span id='topic++2F+2Cnanoperiod+2Cnumeric-method'></span><span id='topic++3D+3D+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic++21+3D+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic+plus+2Cnanotime+2Cnanoperiod+2Ccharacter-method'></span><span id='topic+plus'></span><span id='topic+plus+2Cnanoperiod+2Cnanotime+2Ccharacter-method'></span><span id='topic+minus+2Cnanotime+2Cnanoperiod+2Ccharacter-method'></span><span id='topic+minus'></span><span id='topic+minus+2Cnanoperiod+2Cnanotime+2Ccharacter-method'></span><span id='topic+plus+2Cnanoival+2Cnanoperiod+2Ccharacter-method'></span><span id='topic+plus+2Cnanoperiod+2Cnanoival+2Ccharacter-method'></span><span id='topic+minus+2Cnanoival+2Cnanoperiod+2Ccharacter-method'></span><span id='topic+NA_nanoperiod_'></span>

<h3>Description</h3>

<p><code>nanoperiod</code> is a length of time type (implemented as an S4
class) with nanosecond precision. It differs from
<code>nanoduration</code> because it is capable of representing calendar
months and days. It can thus represent years (12 months) and weeks
(7 days). A period is a somewhat abstract representation of time:
it is only when anchored to a point in time and in a specific time
zone that it is possible to convert it to a specific
duration. This means that many of the operations involving periods
need the additional argument <code>tz</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoperiod(months = 0, days = 0, duration = as.nanoduration(0))

## S4 method for signature 'character'
as.nanoperiod(x)

## S4 method for signature 'integer64'
as.nanoperiod(x)

## S4 method for signature 'numeric'
as.nanoperiod(x)

## S4 method for signature 'integer'
as.nanoperiod(x)

## S4 method for signature 'nanoduration'
as.nanoperiod(x)

## S4 method for signature ''NULL''
as.nanoperiod(x)

## S4 method for signature 'missing'
as.nanoperiod(x)

## S4 method for signature 'nanoperiod'
show(object)

## S4 method for signature 'nanoperiod'
print(x, quote = FALSE, ...)

## S3 method for class 'nanoperiod'
format(x, ...)

## S4 method for signature 'nanoperiod'
as.character(x)

## S4 method for signature 'nanoperiod'
is.na(x)

## S4 replacement method for signature 'nanoperiod'
is.na(x) &lt;- value

## S4 method for signature 'nanoperiod'
x[[i, j, ..., drop = FALSE]]

## S4 method for signature 'nanoperiod,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoperiod,logical'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoperiod,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanoperiod,ANY'
x[i, j, ..., drop = FALSE]

## S4 replacement method for signature 'nanoperiod,ANY,ANY,ANY'
x[i, j, ...] &lt;- value

## S3 method for class 'nanoperiod'
c(...)

## S4 method for signature 'nanoperiod'
names(x)

## S4 replacement method for signature 'nanoperiod'
names(x) &lt;- value

## S4 method for signature 'nanoperiod,ANY'
e1 - e2

## S4 method for signature 'nanoperiod,nanoperiod'
e1 - e2

## S4 method for signature 'nanoperiod,nanoduration'
e1 - e2

## S4 method for signature 'nanoperiod,integer64'
e1 - e2

## S4 method for signature 'nanoperiod,numeric'
e1 - e2

## S4 method for signature 'nanoduration,nanoperiod'
e1 - e2

## S4 method for signature 'integer64,nanoperiod'
e1 - e2

## S4 method for signature 'numeric,nanoperiod'
e1 - e2

## S4 method for signature 'nanoperiod,ANY'
e1 + e2

## S4 method for signature 'nanoperiod,nanoperiod'
e1 + e2

## S4 method for signature 'nanoperiod,nanoduration'
e1 + e2

## S4 method for signature 'nanoperiod,integer64'
e1 + e2

## S4 method for signature 'nanoperiod,nanotime'
e1 + e2

## S4 method for signature 'nanoival,nanoperiod'
e1 + e2

## S4 method for signature 'nanoperiod,nanoival'
e1 + e2

## S4 method for signature 'nanotime,nanoperiod'
e1 + e2

## S4 method for signature 'nanoperiod,numeric'
e1 + e2

## S4 method for signature 'nanoduration,nanoperiod'
e1 + e2

## S4 method for signature 'integer64,nanoperiod'
e1 + e2

## S4 method for signature 'numeric,nanoperiod'
e1 + e2

## S4 method for signature 'nanoperiod,integer64'
e1 * e2

## S4 method for signature 'nanoperiod,numeric'
e1 * e2

## S4 method for signature 'integer64,nanoperiod'
e1 * e2

## S4 method for signature 'numeric,nanoperiod'
e1 * e2

## S4 method for signature 'nanoperiod,integer64'
e1 / e2

## S4 method for signature 'nanoperiod,numeric'
e1 / e2

## S4 method for signature 'nanoperiod,nanoperiod'
e1 == e2

## S4 method for signature 'nanoperiod,nanoperiod'
e1 != e2

## S4 method for signature 'nanotime,nanoperiod,character'
plus(e1, e2, tz)

## S4 method for signature 'nanoperiod,nanotime,character'
plus(e1, e2, tz)

## S4 method for signature 'nanotime,nanoperiod,character'
minus(e1, e2, tz)

## S4 method for signature 'nanoperiod,nanotime,character'
minus(e1, e2, tz)

## S4 method for signature 'nanoival,nanoperiod,character'
plus(e1, e2, tz)

## S4 method for signature 'nanoperiod,nanoival,character'
plus(e1, e2, tz)

## S4 method for signature 'nanoival,nanoperiod,character'
minus(e1, e2, tz)

NA_nanoperiod_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoperiod-class_+3A_months">months</code></td>
<td>
<p>Used in the constructor to indicate the number of
months of the <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_days">days</code></td>
<td>
<p>Used in the constructor to indicate the number of
days of the <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_duration">duration</code></td>
<td>
<p>Used in the constructor to indicate the duration
component of the <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_x">x</code>, <code id="nanoperiod-class_+3A_value">value</code></td>
<td>
<p>An object of class <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_object">object</code></td>
<td>
<p>argument for method <code>show</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_quote">quote</code></td>
<td>
<p>indicates if the output of <code>print</code> should be
quoted</p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_i">i</code></td>
<td>
<p>index specifying elements to extract or replace.</p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_j">j</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_drop">drop</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_e1">e1</code></td>
<td>
<p>Operand of class <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_e2">e2</code></td>
<td>
<p>Operand of class <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="nanoperiod-class_+3A_tz">tz</code></td>
<td>
<p><code>character</code> indicating a timezone</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>nanoperiod</code> of length 1.
</p>


<h3>Constructors</h3>

<p>The true constructor is
</p>


<h3>Output Format</h3>

<p>A <code>nanoperiod</code> is displayed as months, days, and <code>nanoduration</code>
like this: <code>10m2d/10:12:34.123_453_000</code>.
</p>


<h3>Details</h3>

<p>Adding or subtracting <code>nanoperiod</code> and <code>nanotime</code>
require a timezone as third argument. For this reason it is not
possible to use the binary operator 'code+'. Instead the
functions '<code>plus</code>' and '<code>minus</code>' are defined. These
functions attempt to keep the same offset within a day in the
specified timezone: this means for instance that adding a day when
that day crosses a time zone adjustment such as a daylight saving
time, results in a true time increment of less or more than 24
hours to preserve the offset. Preserving the offset works for
increments that are smaller than a day too, provided the increment
results in a datetime where the timezone adjustment is valid. When
this is not the case, adding a 'nanoperiod' behaves in the same
way as adding a 'nanoduration'.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>
<p>Leonardo Silvestri
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nanotime">nanotime</a></code>, <code><a href="#topic+nanoduration">nanoduration</a></code>,
<code><a href="#topic+nanoival">nanoival</a></code>, <code><a href="#topic+nanoperiod.month+2Cnanoperiod-method">nanoperiod.month,nanoperiod-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p &lt;- nanoperiod(months=12, days=7, duration="01:00:00")
print(p)

#  when adding a \code{nanoperiod} to a \code{nanotime} or to a
# \code{nanoival}, a time zone must be specified:
y &lt;- nanotime("1970-01-01T00:00:00+00:00")
plus(y, p, tz="America/Chicago")

## End(Not run)

</code></pre>

<hr>
<h2 id='nanoperiod.month+2Cnanoperiod-method'>Nanoperiod accessors</h2><span id='topic+nanoperiod.month+2Cnanoperiod-method'></span><span id='topic+nanoperiod.month'></span><span id='topic+nanoperiod.day'></span><span id='topic+nanoperiod.nanoduration'></span><span id='topic+nanoperiod.day+2Cnanoperiod-method'></span><span id='topic+nanoperiod.nanoduration+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p>These functions allow access to the components of a <code>nanoperiod</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoperiod'
nanoperiod.month(x)

## S4 method for signature 'nanoperiod'
nanoperiod.day(x)

## S4 method for signature 'nanoperiod'
nanoperiod.nanoduration(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoperiod.month+2B2Cnanoperiod-method_+3A_x">x</code></td>
<td>
<p>A <code>nanoperiod</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nanoperiod.month</code> and <code>nanoperiod.day</code> return
an <code>integer64</code> whereas <code>nanoperiod.nanoduration</code>
returns a <code>nanoduration</code>
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>
<p>Leonardo Silvestri
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nanoduration">nanoduration</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as.nanoperiod("2y1m1d/12:00:00")
nanoperiod.month(p)
nanoperiod.day(p)
nanoperiod.nanoduration(p)
</code></pre>

<hr>
<h2 id='nanotime-class'>Nanosecond resolution datetime functionality</h2><span id='topic+nanotime-class'></span><span id='topic+nanotime'></span><span id='topic+as.nanotime'></span><span id='topic+nanotime+2Ccharacter-method'></span><span id='topic+as.nanotime+2Ccharacter-method'></span><span id='topic+nanotime.matrix'></span><span id='topic+nanotime+2CPOSIXct-method'></span><span id='topic+as.nanotime+2CPOSIXct-method'></span><span id='topic+nanotime+2CPOSIXlt-method'></span><span id='topic+as.nanotime+2CPOSIXlt-method'></span><span id='topic+nanotime+2CDate-method'></span><span id='topic+as.nanotime+2CDate-method'></span><span id='topic+print+2Cnanotime-method'></span><span id='topic+show+2Cnanotime-method'></span><span id='topic+format.nanotime'></span><span id='topic+index2char.nanotime'></span><span id='topic+as.POSIXct.nanotime'></span><span id='topic+as.POSIXlt.nanotime'></span><span id='topic+as.Date.nanotime'></span><span id='topic+as.data.frame.nanotime'></span><span id='topic+as.integer64.nanotime'></span><span id='topic+-+2Cnanotime+2Ccharacter-method'></span><span id='topic+-+2Cnanotime+2Cnanotime-method'></span><span id='topic+-+2Cnanotime+2Cinteger64-method'></span><span id='topic+-+2Cnanotime+2Cnumeric-method'></span><span id='topic+-+2CANY+2Cnanotime-method'></span><span id='topic+-+2Cnanotime+2CANY-method'></span><span id='topic++2B+2Cnanotime+2CANY-method'></span><span id='topic++2B+2Cnanotime+2Cinteger64-method'></span><span id='topic++2B+2Cnanotime+2Cnumeric-method'></span><span id='topic++2B+2CANY+2Cnanotime-method'></span><span id='topic++2B+2Cinteger64+2Cnanotime-method'></span><span id='topic++2B+2Cnumeric+2Cnanotime-method'></span><span id='topic++2B+2Cnanotime+2Cnanotime-method'></span><span id='topic+Arith+2Cnanotime+2Cnanotime-method'></span><span id='topic+Arith+2Cnanotime+2CANY-method'></span><span id='topic+Arith+2CANY+2Cnanotime-method'></span><span id='topic+Compare+2Cnanotime+2Ccharacter-method'></span><span id='topic+Compare+2Ccharacter+2Cnanotime-method'></span><span id='topic+Compare+2Cnanotime+2CPOSIXt-method'></span><span id='topic+Compare+2CPOSIXt+2Cnanotime-method'></span><span id='topic+Compare+2Cnanotime+2CANY-method'></span><span id='topic+Logic+2Cnanotime+2CANY-method'></span><span id='topic+Logic+2CANY+2Cnanotime-method'></span><span id='topic+Math+2Cnanotime-method'></span><span id='topic+Math2+2Cnanotime-method'></span><span id='topic+Summary+2Cnanotime-method'></span><span id='topic+min+2Cnanotime-method'></span><span id='topic+max+2Cnanotime-method'></span><span id='topic+range+2Cnanotime-method'></span><span id='topic+Complex+2Cnanotime-method'></span><span id='topic++5B+5B+2Cnanotime-method'></span><span id='topic++5B+2Cnanotime+2Cnumeric-method'></span><span id='topic++5B+2Cnanotime+2Clogical-method'></span><span id='topic++5B+2Cnanotime+2Ccharacter-method'></span><span id='topic++5B+2Cnanotime+2CANY-method'></span><span id='topic++5B+3C-+2Cnanotime+2CANY+2CANY+2CANY-method'></span><span id='topic+c.nanotime'></span><span id='topic+nanotime-package'></span><span id='topic+names+3C-+2Cnanotime-method'></span><span id='topic+is.na+2Cnanotime-method'></span><span id='topic+NA_nanotime_'></span><span id='topic+as.character.nanotime'></span><span id='topic+as.data.frame.nanoduration'></span>

<h3>Description</h3>

<p>Functions to operate on nanosecond time resolution using integer64
bit representation. Conversion functions for several standard R
types are provided, and more will be added as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanotime(from, ...)

as.nanotime(from, ...)

## S4 method for signature 'character'
nanotime(from, format = "", tz = "")

## S4 method for signature 'character'
as.nanotime(from, format = "", tz = "")

nanotime.matrix(x)

## S4 method for signature 'POSIXct'
nanotime(from)

## S4 method for signature 'POSIXct'
as.nanotime(from)

## S4 method for signature 'POSIXlt'
nanotime(from)

## S4 method for signature 'POSIXlt'
as.nanotime(from)

## S4 method for signature 'Date'
nanotime(from)

## S4 method for signature 'Date'
as.nanotime(from)

## S4 method for signature 'nanotime'
print(x, format = "", tz = "", quote = FALSE, ...)

## S4 method for signature 'nanotime'
show(object)

## S3 method for class 'nanotime'
format(x, format = "", tz = "", ...)

## S3 method for class 'nanotime'
index2char(x, ...)

## S3 method for class 'nanotime'
as.POSIXct(x, tz = "", ...)

## S3 method for class 'nanotime'
as.POSIXlt(x, tz = "", ...)

## S3 method for class 'nanotime'
as.Date(x, ...)

## S3 method for class 'nanotime'
as.data.frame(x, ...)

## S3 method for class 'nanotime'
as.integer64(x, ...)

## S4 method for signature 'nanotime,character'
e1 - e2

## S4 method for signature 'nanotime,nanotime'
e1 - e2

## S4 method for signature 'nanotime,integer64'
e1 - e2

## S4 method for signature 'nanotime,numeric'
e1 - e2

## S4 method for signature 'ANY,nanotime'
e1 - e2

## S4 method for signature 'nanotime,ANY'
e1 - e2

## S4 method for signature 'nanotime,ANY'
e1 + e2

## S4 method for signature 'nanotime,integer64'
e1 + e2

## S4 method for signature 'nanotime,numeric'
e1 + e2

## S4 method for signature 'ANY,nanotime'
e1 + e2

## S4 method for signature 'integer64,nanotime'
e1 + e2

## S4 method for signature 'numeric,nanotime'
e1 + e2

## S4 method for signature 'nanotime,nanotime'
e1 + e2

## S4 method for signature 'nanotime,nanotime'
Arith(e1, e2)

## S4 method for signature 'nanotime,ANY'
Arith(e1, e2)

## S4 method for signature 'ANY,nanotime'
Arith(e1, e2)

## S4 method for signature 'nanotime,character'
Compare(e1, e2)

## S4 method for signature 'character,nanotime'
Compare(e1, e2)

## S4 method for signature 'nanotime,POSIXt'
Compare(e1, e2)

## S4 method for signature 'POSIXt,nanotime'
Compare(e1, e2)

## S4 method for signature 'nanotime,ANY'
Compare(e1, e2)

## S4 method for signature 'nanotime,ANY'
Logic(e1, e2)

## S4 method for signature 'ANY,nanotime'
Logic(e1, e2)

## S4 method for signature 'nanotime'
Math(x)

## S4 method for signature 'nanotime'
Math2(x, digits)

## S4 method for signature 'nanotime'
Summary(x, ..., na.rm = FALSE)

## S4 method for signature 'nanotime'
min(x, ..., na.rm = FALSE)

## S4 method for signature 'nanotime'
max(x, ..., na.rm = FALSE)

## S4 method for signature 'nanotime'
range(x, ..., na.rm = FALSE)

## S4 method for signature 'nanotime'
Complex(z)

## S4 method for signature 'nanotime'
x[[i, j, ..., drop = FALSE]]

## S4 method for signature 'nanotime,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanotime,logical'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanotime,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'nanotime,ANY'
x[i, j, ..., drop = FALSE]

## S4 replacement method for signature 'nanotime,ANY,ANY,ANY'
x[i, j, ...] &lt;- value

## S3 method for class 'nanotime'
c(...)

## S4 replacement method for signature 'nanotime'
names(x) &lt;- value

## S4 method for signature 'nanotime'
is.na(x)

NA_nanotime_

## S3 method for class 'nanotime'
as.character(x, ...)

## S3 method for class 'nanoduration'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanotime-class_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_format">format</code></td>
<td>
<p>A character string. Can also be set via
<code>options("nanotimeFormat")</code> and uses
&lsquo;%Y-%m-%dT%H:%M:%E9S%Ez&rsquo; as a default and
fallback</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_tz">tz</code></td>
<td>
<p>character specifying a timezone which is required for
<code>as.POSIXct</code>, <code>as.POSIXlt</code> and can be specified for
<code>as.nanotime</code>, <code>format</code> and <code>print</code>; it can
also be set via <code>options("nanotimeTz")</code> and uses
&lsquo;UTC&rsquo; as a default and fallback</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_x">x</code>, <code id="nanotime-class_+3A_from">from</code></td>
<td>
<p><code>nanotime</code> objects</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_quote">quote</code></td>
<td>
<p>indicates if the output of <code>print</code> should be
quoted</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_object">object</code></td>
<td>
<p>argument for method <code>show</code></p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_e1">e1</code></td>
<td>
<p>Operand of class <code>nanotime</code></p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_e2">e2</code></td>
<td>
<p>Operand of class <code>nanotime</code></p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_digits">digits</code></td>
<td>
<p>Required for <code>Math2</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_z">z</code></td>
<td>
<p>Required for <code>Complex</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_i">i</code></td>
<td>
<p>index specifying elements to extract or replace.</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_j">j</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_drop">drop</code></td>
<td>
<p>Required for <code>[</code> signature but ignored here</p>
</td></tr>
<tr><td><code id="nanotime-class_+3A_value">value</code></td>
<td>
<p>argument for <code>nanotime-class</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>nanotime</code> of length 1.
</p>


<h3>Details</h3>

<p>Notice that the conversion from POSIXct explicitly sets the last
three digits to zero. Nanosecond time stored in a 64-bit integer
has nineteen digits precision where doubles (which are used
internally for POSIXct as well) only have sixteen digits.  So
rather than showing three more (essentially <em>random</em>) digits
it is constructed such that these three additional digits are
zeros.
</p>


<h3>Value</h3>

<p>A nanotime object
</p>


<h3>Caveats</h3>

<p>Working with dates and times is <em>difficult</em>. One needs a
representation of both <em>time points</em> and <em>time
duration</em>. In R, think of <code>Date</code> or <code>POSIXct</code> objects
for the former, and <code>difftime</code> for the later. Here we have
time points <code>nanotime</code>, an interval type <code>nanoival</code> and
two flavors of duration which are a simple count of nanoseconds
<code>nanoduration</code> and a calendar duration that is able to track
concepts such as months and days <code>nanoperiod</code>. Point in time
and intervals are all based on durations relative to the epoch of
January 1, 1970.
</p>


<h3>Input and Output Format</h3>

<p>Formatting and character conversion for <code>nanotime</code> objects is
done by functions from the <code><a href="RcppCCTZ.html#topic+RcppCCTZ">RcppCCTZ</a></code> package relying
on code from its embedded <code>CCTZ</code> library. The default format
is ISO3339 compliant: <code>%Y-%m-%dT%H:%M:%E9S%Ez</code>. It
specifies a standard ISO 8601 part for date and time &mdash; as well
as nine digits of precision for fractional seconds (down to
nanoseconds) and on offset (typically zero as we default to UTC).
It can be overriden by using <code>options()</code> with the key of
<code>nanotimeFormat</code> and a suitable value. Similarly,
<code>nanotimeTz</code> can be used to select a different timezone.
</p>
<p>For input, some slack it cut, and various shortened formats are
accepted by default such as <code>2020-03-10</code> or <code>2020-03-10
18:16:00</code>, or <code>2020-03-10 18:16:00.001</code> (and the &lsquo;T&rsquo;
separator is optional.
</p>


<h3><code>tz</code> parameter usage in constructors</h3>

<p>The <code>tz</code> parameter is allowed only when constructing a
<code>nanotime</code> from a <code>character</code>. This is because any
<code>numeric</code>, <code>Date</code> and <code>POSIXct</code> is de facto
considered an offset since the epoch. On the contrary, a
<code>character</code> is considered interpretable and hence if it does
not contain a timezone in its representation, it is possible to
specify the <code>tz</code> argument to specify in which timezone it
should be interpreted. This is useful in particular if one wants
to convert a <code>Date</code> to be aligned to the beginning of the day
in a specific timezone; in this case one should convert the
<code>Date</code> to a <code>character</code> before calling the
<code>nanotime</code> constructor with the desired timezone.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>
<p>Leonardo Silvestri
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nanoival">nanoival</a></code>, <code><a href="#topic+nanoduration">nanoduration</a></code>,
<code><a href="#topic+nanoperiod">nanoperiod</a></code>, <code><a href="#topic+seq.nanotime">seq.nanotime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- nanotime(1)
print(x)
as.nanotime("1970-01-01T00:00:00.000000001+00:00")
as.nanotime("2020-03-10 Europe/Berlin")
as.nanotime("2020-03-10 18:31:23.001", tz="America/New_York")
x &lt;- x + 1
print(x)
format(x)
x &lt;- x + 10
print(x)
format(x)
nanotime(Sys.time()) + 1:3  # three elements each 1 ns apart
seq(x, by=as.nanoperiod("1d"), length.out=5, tz="Asia/Tokyo")

## End(Not run)
</code></pre>

<hr>
<h2 id='rep+2Cnanoduration-method'>Replicate Elements</h2><span id='topic+rep+2Cnanoduration-method'></span>

<h3>Description</h3>

<p>Replicates the values in 'x' similarly to the default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoduration'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep+2B2Cnanoduration-method_+3A_x">x</code></td>
<td>
<p>a vector of <code>nanoduration</code></p>
</td></tr>
<tr><td><code id="rep+2B2Cnanoduration-method_+3A_...">...</code></td>
<td>
<p>further arguments:
</p>
<p>'times' an integer-valued vector giving the (non-negative)
number of times to repeat each element if of length
'length(x)', or to repeat the whole vector if of length
1. Negative or 'NA' values are an error. A 'double'
vector is accepted, other inputs being coerced to an
integer or double vector.
</p>
<p>'length.out' non-negative integer. The desired length of the
output vector. Other inputs will be coerced to a double
vector and the first element taken. Ignored if 'NA' or
invalid.
</p>
<p>'each' non-negative integer. Each element of 'x' is repeated
'each' times.  Other inputs will be coerced to an integer
or double vector and the first element taken. Treated as
'1' if 'NA' or invalid.</p>
</td></tr>
</table>

<hr>
<h2 id='rep+2Cnanoival-method'>Replicate Elements</h2><span id='topic+rep+2Cnanoival-method'></span>

<h3>Description</h3>

<p>Replicates the values in 'x' similarly to the default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoival'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep+2B2Cnanoival-method_+3A_x">x</code></td>
<td>
<p>a vector of <code>nanoival</code></p>
</td></tr>
<tr><td><code id="rep+2B2Cnanoival-method_+3A_...">...</code></td>
<td>
<p>further arguments:
</p>
<p>'times' an integer-valued vector giving the (non-negative)
number of times to repeat each element if of length
'length(x)', or to repeat the whole vector if of length
1. Negative or 'NA' values are an error. A 'double'
vector is accepted, other inputs being coerced to an
integer or double vector.
</p>
<p>'length.out' non-negative integer. The desired length of the
output vector. Other inputs will be coerced to a double
vector and the first element taken. Ignored if 'NA' or
invalid.
</p>
<p>'each' non-negative integer. Each element of 'x' is repeated
'each' times.  Other inputs will be coerced to an integer
or double vector and the first element taken. Treated as
'1' if 'NA' or invalid.</p>
</td></tr>
</table>

<hr>
<h2 id='rep+2Cnanoperiod-method'>Replicate Elements</h2><span id='topic+rep+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p>Replicates the values in 'x' similarly to the default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoperiod'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep+2B2Cnanoperiod-method_+3A_x">x</code></td>
<td>
<p>a vector of <code>nanoperiod</code></p>
</td></tr>
<tr><td><code id="rep+2B2Cnanoperiod-method_+3A_...">...</code></td>
<td>
<p>further arguments:
</p>
<p>'times' an integer-valued vector giving the (non-negative)
number of times to repeat each element if of length
'length(x)', or to repeat the whole vector if of length
1. Negative or 'NA' values are an error. A 'double'
vector is accepted, other inputs being coerced to an
integer or double vector.
</p>
<p>'length.out' non-negative integer. The desired length of the
output vector. Other inputs will be coerced to a double
vector and the first element taken. Ignored if 'NA' or
invalid.
</p>
<p>'each' non-negative integer. Each element of 'x' is repeated
'each' times.  Other inputs will be coerced to an integer
or double vector and the first element taken. Treated as
'1' if 'NA' or invalid.</p>
</td></tr>
</table>

<hr>
<h2 id='rep+2Cnanotime-method'>Replicate Elements</h2><span id='topic+rep+2Cnanotime-method'></span>

<h3>Description</h3>

<p>Replicates the values in 'x' similarly to the default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanotime'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep+2B2Cnanotime-method_+3A_x">x</code></td>
<td>
<p>a vector of <code>nanotime</code></p>
</td></tr>
<tr><td><code id="rep+2B2Cnanotime-method_+3A_...">...</code></td>
<td>
<p>further arguments:
</p>
<p>'times' an integer-valued vector giving the (non-negative)
number of times to repeat each element if of length
'length(x)', or to repeat the whole vector if of length
1. Negative or 'NA' values are an error. A 'double'
vector is accepted, other inputs being coerced to an
integer or double vector.
</p>
<p>'length.out' non-negative integer. The desired length of the
output vector. Other inputs will be coerced to a double
vector and the first element taken. Ignored if 'NA' or
invalid.
</p>
<p>'each' non-negative integer. Each element of 'x' is repeated
'each' times.  Other inputs will be coerced to an integer
or double vector and the first element taken. Treated as
'1' if 'NA' or invalid.</p>
</td></tr>
</table>

<hr>
<h2 id='seq+2Cnanoival-method'>Sequence Generation</h2><span id='topic+seq+2Cnanoival-method'></span>

<h3>Description</h3>

<p>Generate a sequence of <code>nanoival</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoival'
seq(from, to = NULL, by = NULL, length.out = NULL, along.with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq+2B2Cnanoival-method_+3A_from">from</code>, <code id="seq+2B2Cnanoival-method_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end values of the
sequence</p>
</td></tr>
<tr><td><code id="seq+2B2Cnanoival-method_+3A_by">by</code></td>
<td>
<p><code>nanoduration</code> or <code>nanoperiod</code> increment of
the sequence; note that if the class is <code>nanoperiod</code> the
additional argument <code>tz</code> must be speficied and is of
<code>character</code> type indicating a timezone</p>
</td></tr>
<tr><td><code id="seq+2B2Cnanoival-method_+3A_length.out">length.out</code></td>
<td>
<p>an integer desired length of the sequence</p>
</td></tr>
<tr><td><code id="seq+2B2Cnanoival-method_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="seq+2B2Cnanoival-method_+3A_...">...</code></td>
<td>
<p>arguments passed to or from methods; the only
interesting additional argument is <code>tz</code> where the
<code>to</code> argument is of type <code>nanoperiod</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
from &lt;- as.nanoival("-2018-01-14T13:00:00+00:00 -&gt; 2018-01-14T15:00:00+00:00+")
seq(from, by=as.nanoperiod("1m"), length.out=5, tz="America/New_York")

## End(Not run)
</code></pre>

<hr>
<h2 id='seq.nanoduration'>Sequence Generation</h2><span id='topic+seq.nanoduration'></span>

<h3>Description</h3>

<p>Generate a sequence of <code>nanoduration</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoduration'
seq(from, to = NULL, by = NULL, length.out = NULL, along.with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq.nanoduration_+3A_from">from</code>, <code id="seq.nanoduration_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end values of the
sequence</p>
</td></tr>
<tr><td><code id="seq.nanoduration_+3A_by">by</code></td>
<td>
<p>the increment of the sequence</p>
</td></tr>
<tr><td><code id="seq.nanoduration_+3A_length.out">length.out</code></td>
<td>
<p>integer indicating the desired length of the sequence</p>
</td></tr>
<tr><td><code id="seq.nanoduration_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="seq.nanoduration_+3A_...">...</code></td>
<td>
<p>arguments passed to or from methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>seq(from=as.nanoduration(0), by=as.nanoduration("01:00:00"), length.out=10)
</code></pre>

<hr>
<h2 id='seq.nanotime'>Sequence Generation</h2><span id='topic+seq.nanotime'></span><span id='topic+seq+2Cnanotime-method'></span>

<h3>Description</h3>

<p>Generate a sequence of <code>nanotime</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanotime'
seq(from, to = NULL, by = NULL, length.out = NULL, along.with = NULL, ...)

## S4 method for signature 'nanotime'
seq(from, to = NULL, by = NULL, length.out = NULL, along.with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq.nanotime_+3A_from">from</code>, <code id="seq.nanotime_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end values of the
sequence</p>
</td></tr>
<tr><td><code id="seq.nanotime_+3A_by">by</code></td>
<td>
<p><code>nanoduration</code> or <code>nanoperiod</code> increment of
the sequence; note that if the class is <code>nanoperiod</code> the
additional argument <code>tz</code> must be speficied and is of
<code>character</code> type indicating a timezone</p>
</td></tr>
<tr><td><code id="seq.nanotime_+3A_length.out">length.out</code></td>
<td>
<p>integer indicating the desired length of the sequence</p>
</td></tr>
<tr><td><code id="seq.nanotime_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="seq.nanotime_+3A_...">...</code></td>
<td>
<p>arguments passed to or from methods; the only
interesting additional argument is <code>tz</code> where the
<code>to</code> argument is of type <code>nanoperiod</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
from &lt;- as.nanotime("2018-01-14T12:44:00+00:00")
to   &lt;- as.nanotime("2019-01-14T12:44:00+00:00")
seq(from, to, by=as.nanoperiod("1m"), tz="America/New_York")
seq(from, by=as.nanoperiod("1y"), length.out=4, tz="Europe/London")

## End(Not run)
</code></pre>

<hr>
<h2 id='sort+2Cnanoival-method'>Sorting or Ordering Vectors</h2><span id='topic+sort+2Cnanoival-method'></span>

<h3>Description</h3>

<p>Sort (or _order_) a vector of <code>nanoival</code> into ascending or
descending order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nanoival'
sort(x, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort+2B2Cnanoival-method_+3A_x">x</code></td>
<td>
<p>a vector of <code>nanoival</code></p>
</td></tr>
<tr><td><code id="sort+2B2Cnanoival-method_+3A_decreasing">decreasing</code></td>
<td>
<p>logical.  Should the sort be increasing or
decreasing?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.unsorted">is.unsorted</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
