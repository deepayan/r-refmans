<!DOCTYPE html><html><head><title>Help for package Rsfar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rsfar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rsfar-package'><p>Rsfar: A Package for Seasonal Functional Autoregressive Models.</p></a></li>
<li><a href='#Bdiag'><p>Create block diagonal matrix</p></a></li>
<li><a href='#invsqrt'><p>Return inverse square root of square positive-definite matrix.</p></a></li>
<li><a href='#predict.sfar'><p>Prediction of an SFAR model</p></a></li>
<li><a href='#rsfar'><p>Simulation of a Seasonal Functional Autoregressive SFAR(1) process.</p></a></li>
<li><a href='#sfar'><p>Estimation of an SFAR(1) Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seasonal Functional Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a collection of functions designed for simulating, estimating and forecasting seasonal functional autoregressive time series of order one. These methods are addressed in the manuscript: <a href="https://www.monash.edu/business/ebs/research/publications/ebs/wp16-2019.pdf">https://www.monash.edu/business/ebs/research/publications/ebs/wp16-2019.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/haghbinh/Rsfar">https://github.com/haghbinh/Rsfar</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>fda</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-07 20:27:35 UTC; Haghbin</td>
</tr>
<tr>
<td>Author:</td>
<td>Hossein Haghbin <a href="https://orcid.org/0000-0001-8416-2354"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rob Hyndman [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hossein Haghbin &lt;haghbinh@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-10 08:02:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rsfar-package'>Rsfar: A Package for Seasonal Functional Autoregressive Models.</h2><span id='topic+Rsfar-package'></span>

<h3>Description</h3>

<p>The Rsfar package provides the collection of necessary
functions for simulating, estimating and forecasting seasonal functional
autoregressive time series of order one.
</p>


<h3>Details</h3>

<p>Functional autoregressive models are popular for functional time series analysis, but
the standard formulation fails to address seasonal behavior in functional time series data.
To overcome this shortcoming, we introduce seasonal functional autoregressive time series
models. For the model of order one, we provide estimation, prediction and simulation methods.
</p>


<h3>References</h3>

<p>Atefeh Z., Hossein H., Maryam H., and R.J Hyndman (2021).
Seasonal functional autoregressive models. Manuscript submitted for publication.
<a href="https://robjhyndman.com/publications/sfar/">https://robjhyndman.com/publications/sfar/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfar">sfar</a></code>, <code><a href="#topic+predict.sfar">predict.sfar</a></code>,
</p>

<hr>
<h2 id='Bdiag'>Create block diagonal matrix</h2><span id='topic+Bdiag'></span>

<h3>Description</h3>

<p>Create block diagonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bdiag(A, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bdiag_+3A_a">A</code></td>
<td>
<p>a numeric matrix forming each block.</p>
</td></tr>
<tr><td><code id="Bdiag_+3A_k">k</code></td>
<td>
<p>an integer value indicating the number of blocks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a block diagonal matrix from the matrix A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bdiag(matrix(1:4,2,2), 3)
</code></pre>

<hr>
<h2 id='invsqrt'>Return inverse square root of square positive-definite matrix.</h2><span id='topic+invsqrt'></span>

<h3>Description</h3>

<p>Return inverse square root of square positive-definite matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invsqrt(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invsqrt_+3A_a">A</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inverse square root of square positive-definite matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Rsfar)
X &lt;- Bdiag(matrix(1:4,2,2), 3)
invsqrt(t(X) %*% X)
</code></pre>

<hr>
<h2 id='predict.sfar'>Prediction of an SFAR model</h2><span id='topic+predict.sfar'></span>

<h3>Description</h3>

<p>Compute h-step-ahead prediction for an SFAR(1) model. Only the h-step
predicted function is returned, not the predictions for 1,2,...,h.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfar'
predict(object, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sfar_+3A_object">object</code></td>
<td>
<p>an 'sfar' object containing a fitted SFAR(1) model.</p>
</td></tr>
<tr><td><code id="predict.sfar_+3A_h">h</code></td>
<td>
<p>number of steps ahead to predict.</p>
</td></tr>
<tr><td><code id="predict.sfar_+3A_...">...</code></td>
<td>
<p>Other parameters, not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fda</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate Brownian motion noise
N &lt;- 300 # the length of the series
n &lt;- 200 # the sample rate that each function will be sampled
u &lt;- seq(0, 1, length.out = n) # argvalues of the functions
d &lt;- 45 # the number of bases
basis &lt;- create.fourier.basis(c(0, 1), d) # the basis system
sigma &lt;- 0.05 # the std of noise norm
Z0 &lt;- matrix(rnorm(N * n, 0, sigma), nrow = n, nc = N)
Z0[, 1] &lt;- 0
Z_mat &lt;- apply(Z0, 2, cumsum) # N standard Brownian motion
Z &lt;- smooth.basis(u, Z_mat, basis)$fd

# Simulate random SFAR(1) data
kr &lt;- function(x, y) {
  (2 - (2 * x - 1)^2 - (2 * y - 1)^2) / 2
}
s &lt;- 5 # the period number
X &lt;- rsfar(kr, s, Z)
plot(X)

# SFAR(1) model parameter estimation:
Model1 &lt;- sfar(X, seasonal = s, kn = 1)

# Forecasting 3 steps ahead
fc &lt;- predict(Model1, h = 3)
plot(fc)
</code></pre>

<hr>
<h2 id='rsfar'>Simulation of a Seasonal Functional Autoregressive SFAR(1) process.</h2><span id='topic+rsfar'></span>

<h3>Description</h3>

<p>Simulation of a SFAR(1) process on a Hilbert space of L2[0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsfar(phi, seasonal, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsfar_+3A_phi">phi</code></td>
<td>
<p>a kernel function corresponding to the seasonal autoregressive operator.</p>
</td></tr>
<tr><td><code id="rsfar_+3A_seasonal">seasonal</code></td>
<td>
<p>a positive integer variable specifying the seasonal period.</p>
</td></tr>
<tr><td><code id="rsfar_+3A_z">Z</code></td>
<td>
<p>the functional noise object of the class 'fd'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sample of functional time series from a SFAR(1) model of the class 'fd'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up Brownian motion noise process
N &lt;- 300 # the length of the series
n &lt;- 200 # the sample rate that each function will be sampled
u &lt;- seq(0, 1, length.out = n) # argvalues of the functions
d &lt;- 15 # the number of basis functions
basis &lt;- create.fourier.basis(c(0, 1), d) # the basis system
sigma &lt;- 0.05 # the stdev of noise norm
Z0 &lt;- matrix(rnorm(N * n, 0, sigma), nr = n, nc = N)
Z0[, 1] &lt;- 0
Z_mat &lt;- apply(Z0, 2, cumsum) # N standard Brownian motion
Z &lt;- smooth.basis(u, Z_mat, basis)$fd

# Compute the standardized constant of a kernel function with respect to a given HS norm.
gamma0 &lt;- function(norm, kr) {
  f &lt;- function(x) {
    g &lt;- function(y) {
      kr(x, y)^2
    }
    return(integrate(g, 0, 1)$value)
  }
  f &lt;- Vectorize(f)
  A &lt;- integrate(f, 0, 1)$value
  return(norm / A)
}
# Definition of parabolic integral kernel:
norm &lt;- 0.99
kr &lt;- function(x, y) {
  2 - (2 * x - 1)^2 - (2 * y - 1)^2
}
c0 &lt;- gamma0(norm, kr)
phi &lt;- function(x, y) {
  c0 * kr(x, y)
}

# Simulating a path from an SFAR(1) process
s &lt;- 5 # the period number
X &lt;- rsfar(phi, s, Z)
plot(X)
</code></pre>

<hr>
<h2 id='sfar'>Estimation of an SFAR(1) Model</h2><span id='topic+sfar'></span>

<h3>Description</h3>

<p>Estimate a seasonal functional autoregressive (SFAR) model of order 1 for a given functional time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfar(
  X,
  seasonal,
  cpv = 0.85,
  kn = NULL,
  method = c("MME", "ULSE", "KOE"),
  a = ncol(Coefs)^(-1/6)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfar_+3A_x">X</code></td>
<td>
<p>a functional time series.</p>
</td></tr>
<tr><td><code id="sfar_+3A_seasonal">seasonal</code></td>
<td>
<p>a positive integer variable specifying the seasonality parameter.</p>
</td></tr>
<tr><td><code id="sfar_+3A_cpv">cpv</code></td>
<td>
<p>a numeric with values in [0,1] which determines the cumulative proportion variance explained by the first kn eigencomponents.</p>
</td></tr>
<tr><td><code id="sfar_+3A_kn">kn</code></td>
<td>
<p>an integer variable specifying the number of eigencomponents.</p>
</td></tr>
<tr><td><code id="sfar_+3A_method">method</code></td>
<td>
<p>a character string giving the method of estimation. The following values are possible:
&quot;MME&quot; for Method of Moments, &quot;ULSE&quot; for Unconditional Least Square Estimation Method, and &quot;KOE&quot; for Kargin-Ontaski Estimation.</p>
</td></tr>
<tr><td><code id="sfar_+3A_a">a</code></td>
<td>
<p>a numeric with value in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size p*p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate Brownian motion noise
N &lt;- 300 # the length of the series
n &lt;- 200 # the sample rate that each function will be sampled
u &lt;- seq(0, 1, length.out = n) # argvalues of the functions
d &lt;- 45 # the number of bases
basis &lt;- create.fourier.basis(c(0, 1), d) # the basis system
sigma &lt;- 0.05 # the std of noise norm
Z0 &lt;- matrix(rnorm(N * n, 0, sigma), nrow = n, nc = N)
Z0[, 1] &lt;- 0
Z_mat &lt;- apply(Z0, 2, cumsum) # N standard Brownian motion
Z &lt;- smooth.basis(u, Z_mat, basis)$fd

# Simulate random SFAR(1) data
kr &lt;- function(x, y) {
 (2 - (2 * x - 1)^2 - (2 * y - 1)^2) / 2
}
s &lt;- 5 # the period number
X &lt;- rsfar(kr, s, Z)
plot(X)

# SFAR(1) model parameter estimation:
Model1 &lt;- sfar(X, seasonal = s, kn = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
