<!DOCTYPE html><html><head><title>Help for package DCG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DCG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.SimilarityMatrix'><p>Convert a matrix to a similarity matrix.</p>
<code>as.SimilarityMatrix</code> convert an adjacency matrix to a similarity matrix.</a></li>
<li><a href='#as.symmetricAdjacencyMatrix'><p>convert to a symmetric adjacency matrix</p></a></li>
<li><a href='#getEigenvalueList'><p>generate eigenvalues for all ensemble matrices</p>
<code>getEigenvalueList</code> get eigenvalues from ensemble matrices</a></li>
<li><a href='#getEns'><p>generate ensemble matrix</p>
<code>getEns</code> get ensemble matrix from given similarity matrix and temperature</a></li>
<li><a href='#getEnsList'><p>generating a list of ensemble matrices based on the similarity matrix and temperatures</p></a></li>
<li><a href='#GetSim'><p><code>GetSim</code> get similarity matrix from a distance matrix</p></a></li>
<li><a href='#monkeyGrooming'><p>Grooming network data</p></a></li>
<li><a href='#plotCLUSTERS'><p>generate tree plots for each ensemble matrix</p>
<code>plotCLUSTERS</code> plot all cluster trees</a></li>
<li><a href='#plotMultiEigenvalues'><p>plot eigenvalues</p>
<code>plotMultiEigenvalues</code> plot eigenvalues to determine number of communities by finding the elbow point</a></li>
<li><a href='#plotTheCluster'><p>generate tree plots for selected ensemble matrix</p>
<code>plotTrees</code> plot one cluster tree</a></li>
<li><a href='#temperatureSample'><p>generate temperatures</p>
<code>temperatureSample</code> generate tempatures based on either random or fixed intervals</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Cloud Geometry (DCG): Using Random Walks to Find Community
Structure in Social Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-03</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Data cloud geometry (DCG) applies random walks in finding community structures for social networks. 
    Fushing, VanderWaal, McCowan, &amp; Koehl (2013) (&lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0056259">doi:10.1371/journal.pone.0056259</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Fushing Lab &amp; McCowan Lab, University of California, Davis</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, devtools, lattice, png</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-02 17:19:15 UTC; Jessica</td>
</tr>
<tr>
<td>Author:</td>
<td>Chen Chen [aut],
  Jian Jin [aut],
  Jessica Vandeleest [aut, cre],
  Brianne Beisner [aut],
  Brenda McCowan [aut, cph],
  Hsieh Fushing [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jessica Vandeleest &lt;vandelee@ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-09 21:36:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.SimilarityMatrix'>Convert a matrix to a similarity matrix.
<code>as.SimilarityMatrix</code> convert an adjacency matrix to a similarity matrix.</h2><span id='topic+as.SimilarityMatrix'></span>

<h3>Description</h3>

<p>Convert a matrix to a similarity matrix.
<code>as.SimilarityMatrix</code> convert an adjacency matrix to a similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SimilarityMatrix(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SimilarityMatrix_+3A_mat">mat</code></td>
<td>
<p>a symmetric adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a similarity matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")
similarityMatrix &lt;- as.SimilarityMatrix(symmetricMatrix)

</code></pre>

<hr>
<h2 id='as.symmetricAdjacencyMatrix'>convert to a symmetric adjacency matrix</h2><span id='topic+as.symmetricAdjacencyMatrix'></span>

<h3>Description</h3>

<p><code>as.symmetricAdjacencyMatrix</code> convert an edgelist or a raw matrix to a symmetric adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.symmetricAdjacencyMatrix(Data, weighted = FALSE, rule = "weak")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.symmetricAdjacencyMatrix_+3A_data">Data</code></td>
<td>
<p>either a dataframe or a matrix, representing raw interactions
using either an edgelist or a matrix.
Frequency of interactions for each dyad can be represented either
by multiple occurrences of the dyad for a 2-column edgelist, or
by a third column specifying the frequency of the interaction
for a 3-column edgelist.</p>
</td></tr>
<tr><td><code id="as.symmetricAdjacencyMatrix_+3A_weighted">weighted</code></td>
<td>
<p>If the edgelist is a 3-column edgelist in which weight was
specified by frequency, use <code>weighted = TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.symmetricAdjacencyMatrix_+3A_rule">rule</code></td>
<td>
<p>a character vector of length 1, being one of &quot;<code>weak</code>&quot;,
&quot;<code>strong</code>&quot;, &quot;<code>upper</code>&quot;, or &quot;<code>lower</code>&quot;.
Ways of symmetrizing the matrix. See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are ways of symmetrizing a matrix.
The &quot;<code>weak</code>&quot; rule symmetrize the matrix by building an edge
between nodes <code>[i, j]</code> and <code>[j, i]</code> if there is an edge
either from <code>i</code> to <code>j</code> OR from <code>j</code> to <code>i</code>.
The &quot;<code>strong</code>&quot; rule symmetrize the matrix by building an edge
between nodes <code>[i, j]</code> and <code>[j, i]</code> if there is an edge
BOTH from <code>i</code> to <code>j</code> AND from <code>j</code> to <code>i</code>.
The &quot;<code>upper</code>&quot; and the &quot;<code>lower</code>&quot; rule symmetrize the matrix
by using the &quot;<code>upper</code>&quot; or the &quot;<code>lower</code>&quot; triangle respectively.
</p>
<p>Note, when using a 3-column edgelist (e.g. a weighted edgelist) to
represent raw interactions, each dyad must be unique.
If more than one rows are found with the same Initiator and recipient,
sum of the frequencies will be taken to represent the freqency of
interactions between this unique dyad.
A warning message will prompt your attention to the accuracy of your
raw data when duplicated dyads were found in a three-column edgelist.
</p>


<h3>Value</h3>

<p>a named matrix with the <code>[i,j]</code>th entry equal to the
number of times <code>i</code> grooms <code>j</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")

</code></pre>

<hr>
<h2 id='getEigenvalueList'>generate eigenvalues for all ensemble matrices
<code>getEigenvalueList</code> get eigenvalues from ensemble matrices</h2><span id='topic+getEigenvalueList'></span>

<h3>Description</h3>

<p>generate eigenvalues for all ensemble matrices
<code>getEigenvalueList</code> get eigenvalues from ensemble matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEigenvalueList(EnsList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEigenvalueList_+3A_enslist">EnsList</code></td>
<td>
<p>a list of ensemble matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>eigenvalues</code> for each of the ensemble matrix in the ensemble matrices list.
</p>

<hr>
<h2 id='getEns'>generate ensemble matrix
<code>getEns</code> get ensemble matrix from given similarity matrix and temperature</h2><span id='topic+getEns'></span>

<h3>Description</h3>

<p>generate ensemble matrix
<code>getEns</code> get ensemble matrix from given similarity matrix and temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEns(simMat, temperature, MaxIt = 1000, m = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEns_+3A_simmat">simMat</code></td>
<td>
<p>a similarity matrix</p>
</td></tr>
<tr><td><code id="getEns_+3A_temperature">temperature</code></td>
<td>
<p>a numeric vector of length 1, indicating the temperature used to transform the similarity matrix to ensemble matrix</p>
</td></tr>
<tr><td><code id="getEns_+3A_maxit">MaxIt</code></td>
<td>
<p>number of iterations for regulated random walks</p>
</td></tr>
<tr><td><code id="getEns_+3A_m">m</code></td>
<td>
<p>maxiumnum number of time a node can be visited during random walks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function involves two steps.
It first generate similarity matrices of different variances
by taking the raw similarity matrix to the power of each
temperature. Then it called the function <code>EstClust</code> to perform random walks in the network to identify clusters.
</p>


<h3>Value</h3>

<p>a matrix.
</p>

<hr>
<h2 id='getEnsList'>generating a list of ensemble matrices based on the similarity matrix and temperatures</h2><span id='topic+getEnsList'></span>

<h3>Description</h3>

<p><code>getEnsList</code> get ensemble matrices from given similarity matrix at all temperatures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnsList(simMat, temperatures, MaxIt = 1000, m = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEnsList_+3A_simmat">simMat</code></td>
<td>
<p>a similarity matrix</p>
</td></tr>
<tr><td><code id="getEnsList_+3A_temperatures">temperatures</code></td>
<td>
<p>temperatures selected</p>
</td></tr>
<tr><td><code id="getEnsList_+3A_maxit">MaxIt</code></td>
<td>
<p>number of iterations for regulated random walks</p>
</td></tr>
<tr><td><code id="getEnsList_+3A_m">m</code></td>
<td>
<p>maxiumnum number of time a node can be visited during random walks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step is crucial in finding community structure based on the similarity matrix of the social network.
For each <code>temperatures</code>, the similarity matrix was taken to the power of <code>temperature</code> as saved as a new similarity matrix.
This allows the random walk to explore the similarity matrix at various variations.
Random walks are then performed in similarity matrices of various temperatures.
In order to prevent random walks being stucked in a locale, the parameter <code>m</code> was set (to <code>5</code> by default) to remove a node after <code>m</code> times of visits of the node.
An ensemble matrix is generated at each temperature in which values represent likelihood of two nodes being in the same community.
</p>


<h3>Value</h3>

<p>a list of ensemble matrices
</p>


<h3>References</h3>

<p>Fushing, H., &amp; McAssey, M. P. (2010).
Time, temperature, and data cloud geometry.
Physical Review E, 82(6), 061110.
</p>
<p>Chen, C., &amp; Fushing, H. (2012).
Multiscale community geometry in a network and its application.
Physical Review E, 86(4), 041120.
</p>
<p>Fushing, H., Wang, H., VanderWaal, K., McCowan, B., &amp; Koehl, P. (2013).
Multi-scale clustering by building a robust and self correcting ultrametric topology on data points.
PloS one, 8(2), e56259.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")
Sim &lt;- as.SimilarityMatrix(symmetricMatrix)
temperatures &lt;- temperatureSample(start = 0.01, end = 20, n = 20, method = 'random')
## Not run: 
# Note: It takes a while to run the getEnsList example.
Ens_list &lt;- getEnsList(Sim, temperatures, MaxIt = 1000, m = 5)

## End(Not run)


</code></pre>

<hr>
<h2 id='GetSim'><code>GetSim</code> get similarity matrix from a distance matrix</h2><span id='topic+GetSim'></span>

<h3>Description</h3>

<p><code>GetSim</code> get similarity matrix from a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSim(D, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSim_+3A_d">D</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="GetSim_+3A_t">T</code></td>
<td>
<p>Temperature. <code><a href="#topic+temperatureSample">temperatureSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>the similarity matrix is calculated at each temperature <code>T</code>.
</p>


<h3>References</h3>

<p>Fushing, H., &amp; McAssey, M. P. (2010).
Time, temperature, and data cloud geometry.
Physical Review E, 82(6), 061110.
</p>
<p>Chen, C., &amp; Fushing, H. (2012).
Multiscale community geometry in a network and its application.
Physical Review E, 86(4), 041120.
</p>
<p>Fushing, H., Wang, H., VanderWaal, K., McCowan, B., &amp; Koehl, P. (2013).
Multi-scale clustering by building a robust and self correcting ultrametric topology on data points.
PloS one, 8(2), e56259.
</p>

<hr>
<h2 id='monkeyGrooming'>Grooming network data</h2><span id='topic+monkeyGrooming'></span>

<h3>Description</h3>

<p>A dataset containing grooming edgelist among monkeys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monkeyGrooming
</code></pre>


<h3>Format</h3>

<p>A data frame with 1595 rows and 2 variables:
</p>

<dl>
<dt>Initiator</dt><dd><p>Grooming Initiator ID</p>
</dd>
<dt>Recipient</dt><dd><p>Grooming Recipient ID</p>
</dd>
<dt>Groom</dt><dd><p>Grooming Frequency</p>
</dd>
</dl>
<p>...
</p>

<hr>
<h2 id='plotCLUSTERS'>generate tree plots for each ensemble matrix
<code>plotCLUSTERS</code> plot all cluster trees</h2><span id='topic+plotCLUSTERS'></span>

<h3>Description</h3>

<p>generate tree plots for each ensemble matrix
<code>plotCLUSTERS</code> plot all cluster trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCLUSTERS(EnsList, mfrow, mar = c(1, 1, 1, 1), line = -1.5,
  cex = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCLUSTERS_+3A_enslist">EnsList</code></td>
<td>
<p>a list in which elements are ensemble matrices.</p>
</td></tr>
<tr><td><code id="plotCLUSTERS_+3A_mfrow">mfrow</code></td>
<td>
<p>A vector of the form <code>c(nr, nc)</code> passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotCLUSTERS_+3A_mar">mar</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotCLUSTERS_+3A_line">line</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotCLUSTERS_+3A_cex">cex</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotCLUSTERS_+3A_...">...</code></td>
<td>
<p>further plotting parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotCLUSTERS</code> plots all cluster trees with each tree corresponding to each ensemble matrix in the list of ens_list.
<code>EnsList</code> is the output from <code>getEnsList</code>.
</p>
<p><code>mfrow</code> determines the arrangement of multiple plots. It takes the form of
<code>c(nr, nc)</code> with the first parameter being the number of rows and
the second parameter being the number of columns. When deciding parameters for mfrow,
one should take into considerations size of the plotting device and number of cluster plots.
For example, there are 20 cluster plots, mfrow can be set to <code>c(4, 5)</code> or <code>c(2, 10)</code>
depending on the size and shape of the plotting area.
</p>


<h3>Value</h3>

<p>a graph containing all tree plots with each tree plot corresponding to the community structure from each of the ensemble matrix.
</p>


<h3>References</h3>

<p>Fushing, H., &amp; McAssey, M. P. (2010).
Time, temperature, and data cloud geometry.
Physical Review E, 82(6), 061110.
</p>
<p>Chen, C., &amp; Fushing, H. (2012).
Multiscale community geometry in a network and its application.
Physical Review E, 86(4), 041120.
</p>
<p>Fushing, H., Wang, H., VanderWaal, K., McCowan, B., &amp; Koehl, P. (2013).
Multi-scale clustering by building a robust and self correcting ultrametric topology on data points.
PloS one, 8(2), e56259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEnsList">getEnsList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")
Sim &lt;- as.SimilarityMatrix(symmetricMatrix)
temperatures &lt;- temperatureSample(start = 0.01, end = 20, n = 20, method = 'random')
## Not run: 
# for illustration only. skip CRAN check because it ran forever.
Ens_list &lt;- getEnsList(Sim, temperatures, MaxIt = 1000, m = 5)

## End(Not run)

plotCLUSTERS(EnsList = Ens_list, mfrow = c(2, 10), mar = c(1, 1, 1, 1))
</code></pre>

<hr>
<h2 id='plotMultiEigenvalues'>plot eigenvalues
<code>plotMultiEigenvalues</code> plot eigenvalues to determine number of communities by finding the elbow point</h2><span id='topic+plotMultiEigenvalues'></span>

<h3>Description</h3>

<p>plot eigenvalues
<code>plotMultiEigenvalues</code> plot eigenvalues to determine number of communities by finding the elbow point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMultiEigenvalues(Ens_list, mfrow, mar = c(2, 2, 2, 2), line = -1.5,
  cex = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMultiEigenvalues_+3A_ens_list">Ens_list</code></td>
<td>
<p>a list in which elements are numeric vectors representing eigenvalues.</p>
</td></tr>
<tr><td><code id="plotMultiEigenvalues_+3A_mfrow">mfrow</code></td>
<td>
<p>A vector of the form <code>c(nr, nc)</code> passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotMultiEigenvalues_+3A_mar">mar</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotMultiEigenvalues_+3A_line">line</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotMultiEigenvalues_+3A_cex">cex</code></td>
<td>
<p>plotting parameters with useful defaults (<code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotMultiEigenvalues_+3A_...">...</code></td>
<td>
<p>further plotting parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotMultiEigenvalues</code> plot multiple eigenvalue plots. The dark blue colored dots indicate eigenvalue greater than 0.
Each of the ensemble matrices is decomposed into eigenvalues which is used to determine appropriate number of communities.
Plotting out eigenvalues allow us to see where the elbow point is.
The curve starting from the elbow point flatten out. The number of points above (excluding) the elbow point indicates number of communities.
</p>
<p><code>mfrow</code> determines the arrangement of multiple plots. It takes the form of
<code>c(nr, nc)</code> with the first parameter being the number of rows and
the second parameter being the number of columns. When deciding parameters for mfrow,
one should take into considerations size of the plotting device and number of plots.
For example, there are 20 plots, mfrow can be set to <code>c(4, 5)</code> or <code>c(2, 10)</code>
depending on the size and shape of the plotting area.
</p>


<h3>Value</h3>

<p>a <code>pdf</code> file in the working directory containing all eigenvalue plots
</p>


<h3>References</h3>

<p>Fushing, H., &amp; McAssey, M. P. (2010).
Time, temperature, and data cloud geometry.
Physical Review E, 82(6), 061110.
</p>
<p>Chen, C., &amp; Fushing, H. (2012).
Multiscale community geometry in a network and its application.
Physical Review E, 86(4), 041120.
</p>
<p>Fushing, H., Wang, H., VanderWaal, K., McCowan, B., &amp; Koehl, P. (2013).
Multi-scale clustering by building a robust and self correcting ultrametric topology on data points.
PloS one, 8(2), e56259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCLUSTERS">plotCLUSTERS</a></code>, <code><a href="#topic+getEnsList">getEnsList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")
Sim &lt;- as.SimilarityMatrix(symmetricMatrix)
temperatures &lt;- temperatureSample(start = 0.01, end = 20, n = 20, method = 'random')
## Not run: 
# for illustration only. skip CRAN check because it ran forever.
Ens_list &lt;- getEnsList(Sim, temperatures, MaxIt = 1000, m = 5)

## End(Not run)


plotMultiEigenvalues(Ens_list = Ens_list, mfrow = c(10, 2), mar = c(1, 1, 1, 1))

</code></pre>

<hr>
<h2 id='plotTheCluster'>generate tree plots for selected ensemble matrix
<code>plotTrees</code> plot one cluster tree</h2><span id='topic+plotTheCluster'></span>

<h3>Description</h3>

<p>generate tree plots for selected ensemble matrix
<code>plotTrees</code> plot one cluster tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTheCluster(EnsList, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTheCluster_+3A_enslist">EnsList</code></td>
<td>
<p>a list in which elements are ensemble matrices.</p>
</td></tr>
<tr><td><code id="plotTheCluster_+3A_index">index</code></td>
<td>
<p>an integer. index of which ensemble matrix you want to plot.</p>
</td></tr>
<tr><td><code id="plotTheCluster_+3A_...">...</code></td>
<td>
<p>plotting parameters passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tree plot
</p>

<hr>
<h2 id='temperatureSample'>generate temperatures
<code>temperatureSample</code> generate tempatures based on either random or fixed intervals</h2><span id='topic+temperatureSample'></span>

<h3>Description</h3>

<p>generate temperatures
<code>temperatureSample</code> generate tempatures based on either random or fixed intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperatureSample(start = 0.01, end = 20, n = 20,
  method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temperatureSample_+3A_start">start</code></td>
<td>
<p>a numeric vector of length 1, indicating the lowest temperature</p>
</td></tr>
<tr><td><code id="temperatureSample_+3A_end">end</code></td>
<td>
<p>a numeric vector of length 1, indicating the highest temperature</p>
</td></tr>
<tr><td><code id="temperatureSample_+3A_n">n</code></td>
<td>
<p>an integer between 10 to 30, indicating the number of temperatures (more explanations on what temperatures are).</p>
</td></tr>
<tr><td><code id="temperatureSample_+3A_method">method</code></td>
<td>
<p>a character vector indicating the method used in selecting temperatures.
It should take either 'random' or 'fixedInterval', case-sensitive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In using random walks to find community structure, each normalized similarity matrix is evaluated at different temperatures.
This allows greater variations in the normalized similarity matrices.
It is recommended to try out 20 - 30 temperatures to allow for a thorough exploration of the matrices.
A range of temperatures which lead to stable community structures should be considered as reliable. The temperature in the middle of the range should be selected.
</p>


<h3>Value</h3>

<p>a numeric vector of length n representing temperatures sampled.
</p>


<h3>References</h3>

<p>Fushing, H., &amp; McAssey, M. P. (2010).
Time, temperature, and data cloud geometry.
Physical Review E, 82(6), 061110.
</p>
<p>Chen, C., &amp; Fushing, H. (2012).
Multiscale community geometry in a network and its application.
Physical Review E, 86(4), 041120.
</p>
<p>Fushing, H., Wang, H., VanderWaal, K., McCowan, B., &amp; Koehl, P. (2013).
Multi-scale clustering by building a robust and self correcting ultrametric topology on data points.
PloS one, 8(2), e56259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEnsList">getEnsList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricMatrix &lt;- as.symmetricAdjacencyMatrix(monkeyGrooming, weighted = TRUE, rule = "weak")
Sim &lt;- as.SimilarityMatrix(symmetricMatrix)
temperatures &lt;- temperatureSample(start = 0.01, end = 20, n = 20, method = 'random')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
