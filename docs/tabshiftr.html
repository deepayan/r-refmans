<!DOCTYPE html><html><head><title>Help for package tabshiftr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tabshiftr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.eval_find'><p>Evaluate .find constructs</p></a></li>
<li><a href='#.eval_sum'><p>Evaluate .sum constructs</p></a></li>
<li><a href='#.expect_valid_table'><p>Test for a valid table</p></a></li>
<li><a href='#.find'><p>Determine row or column on the fly</p></a></li>
<li><a href='#.sum'><p>Summarise groups of rows or columns</p></a></li>
<li><a href='#.tidyVars'><p>Match variables</p></a></li>
<li><a href='#.updateFormat'><p>Update the formating of a table</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#getClusterVar'><p>Extract cluster variables</p></a></li>
<li><a href='#getData'><p>Extract summarised data</p></a></li>
<li><a href='#getGroupVar'><p>Extract cluster group variable</p></a></li>
<li><a href='#getIDVars'><p>Extract identifying variables</p></a></li>
<li><a href='#getObsVars'><p>Extract observed variables</p></a></li>
<li><a href='#reorganise'><p>Reorganise a table</p></a></li>
<li><a href='#schema_default'><p>Default template of a schema description</p></a></li>
<li><a href='#schema-class'><p>The <code>schema</code> class (S4) and its methods</p></a></li>
<li><a href='#setCluster'><p>Set where the clusters are</p></a></li>
<li><a href='#setFilter'><p>Set filters</p></a></li>
<li><a href='#setFormat'><p>Set the specific format of a table</p></a></li>
<li><a href='#setGroups'><p>Set Groups</p></a></li>
<li><a href='#setIDVar'><p>Set an identifying variable</p></a></li>
<li><a href='#setObsVar'><p>Set an observed variable</p></a></li>
<li><a href='#show,schema-method'><p>Print the <code>schema</code></p></a></li>
<li><a href='#tabs2shift'><p>List of table types</p></a></li>
<li><a href='#validateSchema'><p>Check and update schema descriptions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Reshape Disorganised Messy Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Helps the user to build and register schema descriptions of 
    disorganised (messy) tables. Disorganised tables are tables that are 
    not in a topologically coherent form, where packages such as 'tidyr' could 
    be used for reshaping. The schema description documents the arrangement of 
    input tables and is used to reshape them into a standardised (tidy) output 
    format.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/luckinet/tabshiftr">https://github.com/luckinet/tabshiftr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luckinet/tabshiftr/issues">https://github.com/luckinet/tabshiftr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-gb</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, rlang, tibble, dplyr, tidyr, magrittr, tidyselect,
testthat, crayon, methods, purrr, stringr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown, readr, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-31 11:54:27 UTC; steff</td>
</tr>
<tr>
<td>Author:</td>
<td>Steffen Ehrmann <a href="https://orcid.org/0000-0002-2958-0796"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tsvetelina Tomova [ctb],
  Carsten Meyer <a href="https://orcid.org/0000-0003-3927-5856"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Abdualmaged Alhemiary [ctb],
  Amelie Haas [ctb],
  Annika Ertel [ctb],
  Arne RÃ¼mmler <a href="https://orcid.org/0000-0001-8637-9071"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Caroline Busse [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steffen Ehrmann &lt;steffen.ehrmann@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-31 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.eval_find'>Evaluate .find constructs</h2><span id='topic+.eval_find'></span>

<h3>Description</h3>

<p>Evaluate .find constructs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eval_find(input = NULL, col = NULL, row = NULL, clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".eval_find_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
<tr><td><code id=".eval_find_+3A_col">col</code></td>
<td>
<p>[<code>list(2)</code>]<br /> the output of the respective .find construct
used to match in columns.</p>
</td></tr>
<tr><td><code id=".eval_find_+3A_row">row</code></td>
<td>
<p>[<code>list(2)</code>]<br /> the output of the respective .find construct
used to match in rows.</p>
</td></tr>
<tr><td><code id=".eval_find_+3A_clusters">clusters</code></td>
<td>
<p>[<code>list(7)</code>]<br /> the cluster slot of the schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the columns or rows of the evaluated position
</p>

<hr>
<h2 id='.eval_sum'>Evaluate .sum constructs</h2><span id='topic+.eval_sum'></span>

<h3>Description</h3>

<p>Evaluate .sum constructs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eval_sum(input = NULL, groups = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".eval_sum_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
<tr><td><code id=".eval_sum_+3A_groups">groups</code></td>
<td>
<p>[<code>list(3)</code>]<br /> the groups-slot from a schema.</p>
</td></tr>
<tr><td><code id=".eval_sum_+3A_data">data</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> the cell column or row that should be
adapted to groupings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the position of the evaluated position
</p>

<hr>
<h2 id='.expect_valid_table'>Test for a valid table</h2><span id='topic+.expect_valid_table'></span>

<h3>Description</h3>

<p>This function is a collection of expectations which ensure that the output of
<code><a href="#topic+reorganise">reorganise</a></code> is formally and contentwise correct. It is used in
the tests of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.expect_valid_table(
  x = NULL,
  units = 1,
  variables = NULL,
  groups = FALSE,
  flags = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".expect_valid_table_+3A_x">x</code></td>
<td>
<p>a table to test.</p>
</td></tr>
<tr><td><code id=".expect_valid_table_+3A_units">units</code></td>
<td>
<p>the number of units in the output table (from 1 to 3)</p>
</td></tr>
<tr><td><code id=".expect_valid_table_+3A_variables">variables</code></td>
<td>
<p>the variables that should be in the output table (either
&quot;harvested&quot; or &quot;production&quot;)</p>
</td></tr>
<tr><td><code id=".expect_valid_table_+3A_groups">groups</code></td>
<td>
<p>whether or not groups are in the test table.</p>
</td></tr>
<tr><td><code id=".expect_valid_table_+3A_flags">flags</code></td>
<td>
<p>whether or not flags are in the test table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either an error message of the invalid expectations, or the output of
the last successful expectation.
</p>

<hr>
<h2 id='.find'>Determine row or column on the fly</h2><span id='topic+.find'></span>

<h3>Description</h3>

<p>Find the location of a variable not based on it's columns/rows, but based on
a regular expression or function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find(
  fun = NULL,
  pattern = NULL,
  col = NULL,
  row = NULL,
  invert = FALSE,
  relative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".find_+3A_fun">fun</code></td>
<td>
<p>[<code>character(1)</code>]<br /> function to identify columns or rows in
the input table on the fly.</p>
</td></tr>
<tr><td><code id=".find_+3A_pattern">pattern</code></td>
<td>
<p>[<code>character(1)</code>]<br /> character string containing a regular
expression to identify columns or rows in the input table on the fly.</p>
</td></tr>
<tr><td><code id=".find_+3A_col">col</code></td>
<td>
<p>[<code>integerish(1)</code>]<br /> optionally, in case this function should
only be applied to certain columns, provides this here.</p>
</td></tr>
<tr><td><code id=".find_+3A_row">row</code></td>
<td>
<p>[<code>integerish(1)</code>]<br /> optionally, in case this function should
only be applied to certain rows, provides this here.</p>
</td></tr>
<tr><td><code id=".find_+3A_invert">invert</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> whether or not the identified columns or
rows should be inverted, i.e., all other columns or rows should be
selected.</p>
</td></tr>
<tr><td><code id=".find_+3A_relative">relative</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> whether or not the values provided in
<code>col</code> or <code>row</code> are relative to the cluster position(s) or whether
they are absolute positions, i.e, refer to the overall table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is basically a wild-card for when columns or rows are
not known ad-hoc, but have to be assigned on the fly. This can be very
helpful when several tables contain the same variables, but the arrangement
may be slightly different.
</p>


<h3>Value</h3>

<p>the index values where the target was found.
</p>


<h3>How does this work</h3>

<p>The first step in using any schema is validating
it via the function <code><a href="#topic+validateSchema">validateSchema</a></code>. This happens by default
in <code><a href="#topic+reorganise">reorganise</a></code>, but can also be done manually, for example
when debugging complicated schema descriptions.
</p>
<p>In case that function encounters a schema that wants to find columns or
rows on the fly via <code>.find</code>, it combines all cells of columns and all
cells of rows into one character string and matches the regular expression
or function on those. Columns/rows that have a match are returned as the
respective column/row value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use regular expressions to find cell positions
(input &lt;- tabs2shift$clusters_messy)

schema &lt;- setCluster(id = "territories",
                     left = .find(pattern = "comm*"), top = .find(pattern = "comm*")) %&gt;%
  setIDVar(name = "territories", columns = c(1, 1, 4), rows = c(2, 9, 9)) %&gt;%
  setIDVar(name = "year", columns = 4, rows = c(3:6), distinct = TRUE) %&gt;%
  setIDVar(name = "commodities", columns = c(1, 1, 4)) %&gt;%
  setObsVar(name = "harvested", columns = c(2, 2, 5)) %&gt;%
  setObsVar(name = "production", columns = c(3, 3, 6))

schema
validateSchema(schema = schema, input = input)

# use a function to find rows
(input &lt;- tabs2shift$messy_rows)

schema &lt;-
  setFilter(rows = .find(fun = is.numeric, col = 1, invert = TRUE)) %&gt;%
  setIDVar(name = "territories", columns = 1) %&gt;%
  setIDVar(name = "year", columns = 2) %&gt;%
  setIDVar(name = "commodities", columns = 3) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

reorganise(schema = schema, input = input)
</code></pre>

<hr>
<h2 id='.sum'>Summarise groups of rows or columns</h2><span id='topic+.sum'></span>

<h3>Description</h3>

<p>Summarise groups of rows or columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sum(..., character = NULL, numeric = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sum_+3A_...">...</code></td>
<td>
<p>[<code>integerish(1)</code>]<br /> columns or rows that shall be combined.
If there are several items provided, they will be summarised into one group
that is combined according to its type and the respective function provided
in <code>character</code> or <code>numeric</code>.</p>
</td></tr>
<tr><td><code id=".sum_+3A_character">character</code></td>
<td>
<p>[<code>function(1)</code>]<br /> function by which character columns
or rows shall be combined.</p>
</td></tr>
<tr><td><code id=".sum_+3A_numeric">numeric</code></td>
<td>
<p>[<code>function(1)</code>]<br /> function by which numeric columns or
rows shall be combined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>character</code> values are summarised with the function
<code>paste0(na.omit(x), collapse = "-/-")</code> and <code>numeric</code> values with
the function <code>sum(x, na.rm = TRUE)</code>. To avoid un-intuitive behavior,
it is wisest to explicitly specify how all exceptions, such as NA-values,
shall be handled and thus to provide a new function.
</p>


<h3>Value</h3>

<p>the index values where the target was found.
</p>

<hr>
<h2 id='.tidyVars'>Match variables</h2><span id='topic+.tidyVars'></span>

<h3>Description</h3>

<p>This function matches id and observed variables and reshapes them accordingly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tidyVars(ids = NULL, obs = NULL, clust = NULL, grp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".tidyVars_+3A_ids">ids</code></td>
<td>
<p>list of id variables</p>
</td></tr>
<tr><td><code id=".tidyVars_+3A_obs">obs</code></td>
<td>
<p>list of observed variables</p>
</td></tr>
<tr><td><code id=".tidyVars_+3A_clust">clust</code></td>
<td>
<p>list of cluster variables</p>
</td></tr>
<tr><td><code id=".tidyVars_+3A_grp">grp</code></td>
<td>
<p>list of group variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric list of variables (all with the same dimensions)
</p>

<hr>
<h2 id='.updateFormat'>Update the formating of a table</h2><span id='topic+.updateFormat'></span>

<h3>Description</h3>

<p>This function updates the format of a table by applying a schema description
to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.updateFormat(input = NULL, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".updateFormat_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
<tr><td><code id=".updateFormat_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the schema description of
<code>input</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='getClusterVar'>Extract cluster variables</h2><span id='topic+getClusterVar'></span>

<h3>Description</h3>

<p>This function extracts the cluster variable from a table by applying a schema
description to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterVar(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterVar_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the (validated) schema description of
<code>input</code>.</p>
</td></tr>
<tr><td><code id="getClusterVar_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list per cluster with values of the cluster variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- tabs2shift$clusters_nested
schema &lt;- setCluster(id = "sublevel",
                     group = "territories", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 15)) %&gt;%
  setIDVar(name = "territories", columns = 1, rows = c(2, 14)) %&gt;%
  setIDVar(name = "sublevel", columns = 1, rows = c(3, 8, 15)) %&gt;%
  setIDVar(name = "year", columns = 7) %&gt;%
  setIDVar(name = "commodities", columns = 2) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

validateSchema(schema = schema, input = input) %&gt;%
   getClusterVar(input = input)
</code></pre>

<hr>
<h2 id='getData'>Extract summarised data</h2><span id='topic+getData'></span>

<h3>Description</h3>

<p>This function extracts data from a table that are summarised by applying a
schema description to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the (validated) schema description of
<code>input</code>.</p>
</td></tr>
<tr><td><code id="getData_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table where columns and rows are summarised
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- tabs2shift$clusters_nested
schema &lt;- setCluster(id = "sublevel",
                     group = "territories", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 15)) %&gt;%
  setIDVar(name = "territories", columns = 1, rows = c(2, 14)) %&gt;%
  setIDVar(name = "sublevel", columns = 1, rows = c(3, 8, 15)) %&gt;%
  setIDVar(name = "year", columns = 7) %&gt;%
  setIDVar(name = "commodities", columns = 2) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

validateSchema(schema = schema, input = input) %&gt;%
   getData(input = input)
</code></pre>

<hr>
<h2 id='getGroupVar'>Extract cluster group variable</h2><span id='topic+getGroupVar'></span>

<h3>Description</h3>

<p>This function extracts the cluster grouping variable from a table by applying
a schema description to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupVar(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroupVar_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the schema description of
<code>input</code>.</p>
</td></tr>
<tr><td><code id="getGroupVar_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list per cluster with values of the grouping variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- tabs2shift$clusters_nested
schema &lt;- setCluster(id = "sublevel",
                     group = "territories", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 15)) %&gt;%
  setIDVar(name = "territories", columns = 1, rows = c(2, 14)) %&gt;%
  setIDVar(name = "sublevel", columns = 1, rows = c(3, 8, 15)) %&gt;%
  setIDVar(name = "year", columns = 7) %&gt;%
  setIDVar(name = "commodities", columns = 2) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

validateSchema(schema = schema, input = input) %&gt;%
   getGroupVar(input = input)
</code></pre>

<hr>
<h2 id='getIDVars'>Extract identifying variables</h2><span id='topic+getIDVars'></span>

<h3>Description</h3>

<p>This function extracts the identifying variables from a table by applying a
schema description to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIDVars(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIDVars_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the (validated) schema description of
<code>input</code>.</p>
</td></tr>
<tr><td><code id="getIDVars_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list per cluster with values of the identifying variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- tabs2shift$clusters_nested
schema &lt;- setCluster(id = "sublevel",
                     group = "territories", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 15)) %&gt;%
  setIDVar(name = "territories", columns = 1, rows = c(2, 14)) %&gt;%
  setIDVar(name = "sublevel", columns = 1, rows = c(3, 8, 15)) %&gt;%
  setIDVar(name = "year", columns = 7) %&gt;%
  setIDVar(name = "commodities", columns = 2) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

validateSchema(schema = schema, input = input) %&gt;%
   getIDVars(input = input)
</code></pre>

<hr>
<h2 id='getObsVars'>Extract observed variables</h2><span id='topic+getObsVars'></span>

<h3>Description</h3>

<p>This function extracts the observed variables from a table by applying a
schema description to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObsVars(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getObsVars_+3A_schema">schema</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the (validated) schema description of
<code>input</code>.</p>
</td></tr>
<tr><td><code id="getObsVars_+3A_input">input</code></td>
<td>
<p>[<code>character(1)</code>]<br /> table to reorganise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list per cluster with values of the observed variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- tabs2shift$clusters_nested
schema &lt;- setCluster(id = "sublevel",
                     group = "territories", member = c(1, 1, 2),
                     left = 1, top = c(3, 8, 15)) %&gt;%
  setIDVar(name = "territories", columns = 1, rows = c(2, 14)) %&gt;%
  setIDVar(name = "sublevel", columns = 1, rows = c(3, 8, 15)) %&gt;%
  setIDVar(name = "year", columns = 7) %&gt;%
  setIDVar(name = "commodities", columns = 2) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

validateSchema(schema = schema, input = input) %&gt;%
   getObsVars(input = input)
</code></pre>

<hr>
<h2 id='reorganise'>Reorganise a table</h2><span id='topic+reorganise'></span>

<h3>Description</h3>

<p>This function takes a disorganised messy table and rearranges columns and
rows into a tidy table based on a schema description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorganise(input = NULL, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorganise_+3A_input">input</code></td>
<td>
<p>[<code>data.frame(1)</code>]<br /> table to reorganise.</p>
</td></tr>
<tr><td><code id="reorganise_+3A_schema">schema</code></td>
<td>
<p>[<code>symbol(1)</code>]<br /> the schema description of <code>input</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (tidy) table which is the result of reorganising <code>input</code> based
on <code>schema</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a rather disorganised table with messy clusters and a distinct variable
(input &lt;- tabs2shift$clusters_messy)

# put together schema description by ...
# ... identifying cluster positions
schema &lt;- setCluster(id = "territories", left = c(1, 1, 4), top = c(1, 8, 8))

# ... specifying the cluster ID as id variable (obligatory)
schema &lt;- schema %&gt;%
    setIDVar(name = "territories", columns = c(1, 1, 4), rows = c(2, 9, 9))

# ... specifying the distinct variable (explicit position)
schema &lt;- schema %&gt;%
    setIDVar(name = "year", columns = 4, rows = c(3:6), distinct = TRUE)

# ... specifying a tidy variable (by giving the column values)
schema &lt;- schema %&gt;%
    setIDVar(name = "commodities", columns = c(1, 1, 4))

# ... identifying the (tidy) observed variables
schema &lt;- schema %&gt;%
    setObsVar(name = "harvested", columns = c(2, 2, 5)) %&gt;%
    setObsVar(name = "production", columns = c(3, 3, 6))

# get the tidy output
reorganise(input, schema)

</code></pre>

<hr>
<h2 id='schema_default'>Default template of a schema description</h2><span id='topic+schema_default'></span>

<h3>Description</h3>

<p>Default template of a schema description
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schema_default
</code></pre>


<h3>Format</h3>

<p>The object of class <code>schema</code> describes at which position in a
table which information can be found. It contains the four slots
<code>clusters</code>, <code>format</code>, <code>filter</code> and <code>variables</code>.
</p>
<p>The default schema description contains all slots and fields that are
required by default and identifying and observed variables are added to it
into the <code>variables</code> slot.
</p>

<hr>
<h2 id='schema-class'>The <code>schema</code> class (S4) and its methods</h2><span id='topic+schema-class'></span><span id='topic+schema'></span>

<h3>Description</h3>

<p>A <code>schema</code> stores the information of where which information is stored
in a table of data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cluster</code></dt><dd><p>[<code>list(1)</code>]<br /> description of
<code><a href="#topic+setCluster">clusters</a></code> in the table.</p>
</dd>
<dt><code>format</code></dt><dd><p>[<code>list(1)</code>]<br /> description of the table
<code><a href="#topic+setFormat">format</a></code></p>
</dd>
<dt><code>variables</code></dt><dd><p>[<code>named list(.)</code>]<br /> description of
<code><a href="#topic+setIDVar">identifying</a></code> and <code><a href="#topic+setObsVar">observed</a></code>
variables.</p>
</dd>
</dl>


<h3>Setting up schema descriptions</h3>

<p>This section outlines the currently
recommended strategy for setting up schema descriptions. For example tables
and the respective schemas, see the vignette.
</p>
 <ol>
<li> <p><em>Variables</em>: Clarify which are the identifying
variables and which are the observed variables. Make sure not to mistake a
listed observed variable as identifying variable.
</p>
</li>
<li> <p><em>Clusters</em>: Determine whether there are clusters and if so, find
the origin (top left cell) of each cluster and provide the required
information in <code><a href="#topic+setCluster">setCluster</a>(top = ..., left =
  ...)</code>. It is advised to treat a table that contains meta-data in the top
rows as cluster, as this is often the case with implicit variables. All
variables need to be specified in each cluster (in case clusters are all
organised in the same arrangement), or <code>relative = TRUE</code> can be used.
Data may be organised into clusters a) whenever a set of variables occurs
more than once in the same table, nested into another variable, or b) when
the data are organised into separate spreadsheets or files according to one
of the variables (depending on the context, these issues can also be solved
differently). In both cases the variable responsible for clustering (the
cluster ID) can be either an identifying variable, or a categorical
observed variable: </p>

<ul>
<li><p> in case the cluster ID is an identifying variable, provide its name
in <code><a href="#topic+setCluster">setCluster(id = ...)</a></code> and specify it as an
identifying variable (<code><a href="#topic+setIDVar">setIDVar</a></code>)
</p>
</li>
<li><p> in case it is a observed variable, provide simply
<code><a href="#topic+setCluster">setCluster</a>(..., id = "observed")</code>. </p>
</li></ul>

</li>
<li> <p><em>Meta-data</em>: Provide potentially information about the format
(<code><a href="#topic+setFormat">setFormat</a></code>).
</p>
</li>
<li> <p><em>Identifying variables</em>: Determine the following: </p>

<ul>
<li><p> is the variable available at all? This is particularly important when
the data are split up into tables that are in spreadsheets or files. Often
the variable that splits up the data (and thus identifies the clusters) is
not explicitly available in the table anymore. In such a case, provide the
value in <code><a href="#topic+setIDVar">setIDVar</a>(..., value = ...)</code>.
</p>
</li>
<li><p> all columns in which the variable values sit.
</p>
</li>
<li><p> in case the variable is in several columns, determine additionally
the row in which its values sit. In this case, the values will look like
they are part of a header.
</p>
</li>
<li><p> in case the variable must be split off of another column, provide a
regular expression that results in the target subset via
<code><a href="#topic+setIDVar">setIDVar</a>(..., split = ...)</code>.
</p>
</li>
<li><p> in case the variable is distinct from the main table, provide the
explicit (non-relative) position and set
<code><a href="#topic+setIDVar">setIDVar</a>(..., distinct = TRUE)</code>. </p>
</li></ul>

</li>
<li> <p><em>Observed variable</em>: Determine the following: </p>

<ul>
<li><p> all columns in which the values of the variable sit.
</p>
</li>
<li><p> the unit and conversion factor.
</p>
</li>
<li><p> in case the variable is not tidy, go through the following cases one
after the other: </p>

<ul>
<li><p> in case the variable is nested in a wide identifying variable,
determine in addition to the columns in which the values sit also the rows
in which the <em>variable name</em> sits.
</p>
</li>
<li><p> in case the names of the variable are given as a value of an
identifying variable, give the column name as
<code><a href="#topic+setObsVar">setObsVar</a>(..., key = ...)</code>, together with the name
of the respective observed variable (as it appears in the table) in
<code>values</code>.
</p>
</li>
<li><p> in case the name of the variable is the ID of clusters, specify
<code><a href="#topic+setObsVar">setObsVar</a>(..., key = "cluster", value = ...)</code>,
where <code>values</code> has the cluster number the variable refers to. </p>
</li></ul>
 </li></ul>
 </li></ol>


<hr>
<h2 id='setCluster'>Set where the clusters are</h2><span id='topic+setCluster'></span>

<h3>Description</h3>

<p>There is hardly any limit to how data can be arranged in a spreadsheet, apart
from the apparent organisation into a lattice of cells. However, it is often
the case that data are gathered into topologically coherent chunks. Those
chunks are what is called 'cluster' in <code>tabshiftr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCluster(
  schema = NULL,
  id = NULL,
  group = NULL,
  member = NULL,
  left = NULL,
  top = NULL,
  width = NULL,
  height = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCluster_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setCluster_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br /> When data are clustered, it is typically
the case that the data are segregated according to a categorical variables
of interest. In such cases, this variable needs to be registered as cluster
ID.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_group">group</code></td>
<td>
<p>[<code>character(1)</code>]<br /> When clusters themselves are
clustered, they are typically nested into another categorical variable,
which needs to be registered as group ID.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_member">member</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> For each cluster, specify here to
which group it belongs. Clusters are enumerated from left to right and
from top to bottom.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_left">left</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The horizontal cell value of the
top-left cell of each cluster. This can also be a vector of values in case
there are several clusters.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_top">top</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The vertical cell values of the top-left
cell of each cluster. This can also be a vector of values in case there are
several clusters.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_width">width</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The width of each cluster in cells.
This can also be a vector of values in case there are several clusters.</p>
</td></tr>
<tr><td><code id="setCluster_+3A_height">height</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The height of each cluster in cells.
This can also be a vector of values in case there are several clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the currently suggested strategy to set
up a <a href="#topic+schema">schema description</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setFilter">setFilter</a>()</code>,
<code><a href="#topic+setFormat">setFormat</a>()</code>,
<code><a href="#topic+setGroups">setGroups</a>()</code>,
<code><a href="#topic+setIDVar">setIDVar</a>()</code>,
<code><a href="#topic+setObsVar">setObsVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># please check the vignette for examples
</code></pre>

<hr>
<h2 id='setFilter'>Set filters</h2><span id='topic+setFilter'></span>

<h3>Description</h3>

<p>This function allows to specify additional rules to filter certain rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFilter(schema = NULL, rows = NULL, columns = NULL, operator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFilter_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setFilter_+3A_rows">rows</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> rows that are mentioned here are kept.</p>
</td></tr>
<tr><td><code id="setFilter_+3A_columns">columns</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> columns that are mentioned here are
kept.</p>
</td></tr>
<tr><td><code id="setFilter_+3A_operator">operator</code></td>
<td>
<p>[<code>function(1)</code>]<br /> <code><a href="base.html#topic+Logic">Logic</a></code> operators
by which the current filter should be combined with the directly preceeding
filter; hence this argument is not used in case no other filter was defined
before it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setCluster">setCluster</a>()</code>,
<code><a href="#topic+setFormat">setFormat</a>()</code>,
<code><a href="#topic+setGroups">setGroups</a>()</code>,
<code><a href="#topic+setIDVar">setIDVar</a>()</code>,
<code><a href="#topic+setObsVar">setObsVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(input &lt;- tabs2shift$messy_rows)

# select rows where there is 'unit 2' in column 1 or 'year 2' in column 2
schema &lt;-
  setFilter(rows = .find(pattern = "unit 2", col = 1)) %&gt;%
  setFilter(rows = .find(pattern = "year 2", col = 2), operator = `|`) %&gt;%
  setIDVar(name = "territories", columns = 1) %&gt;%
  setIDVar(name = "year", columns = 2) %&gt;%
  setIDVar(name = "commodities", columns = 3) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

reorganise(schema = schema, input = input)
</code></pre>

<hr>
<h2 id='setFormat'>Set the specific format of a table</h2><span id='topic+setFormat'></span>

<h3>Description</h3>

<p>Any table makes some assumptions about the data, but they are mostly not
explicitly recorded in the commonly available table format. This concerns,
for example, the symbol(s) that signal &quot;not available&quot; values or the symbol
that is used as decimal sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFormat(
  schema = NULL,
  decimal = NULL,
  thousand = NULL,
  na_values = NULL,
  flags = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFormat_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setFormat_+3A_decimal">decimal</code></td>
<td>
<p>[<code>character(1)</code>]<br /> The symbols that should be
interpreted as decimal separator.</p>
</td></tr>
<tr><td><code id="setFormat_+3A_thousand">thousand</code></td>
<td>
<p>[<code>character(1)</code>]<br /> The symbols that should be
interpreted as thousand separator.</p>
</td></tr>
<tr><td><code id="setFormat_+3A_na_values">na_values</code></td>
<td>
<p>[<code>character(.)</code>]<br /> The symbols that should be
interpreted as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="setFormat_+3A_flags">flags</code></td>
<td>
<p>[<code>data.frame(2)</code>]<br /> The typically character based flags
that should be shaved off of observed variables to make them identifiable
as numeric values. This must be a data.frame with two columns with names
<code>flag</code> and <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the currently suggested strategy to set
up a <a href="#topic+schema">schema description</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setCluster">setCluster</a>()</code>,
<code><a href="#topic+setFilter">setFilter</a>()</code>,
<code><a href="#topic+setGroups">setGroups</a>()</code>,
<code><a href="#topic+setIDVar">setIDVar</a>()</code>,
<code><a href="#topic+setObsVar">setObsVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># please check the vignette for examples
</code></pre>

<hr>
<h2 id='setGroups'>Set Groups</h2><span id='topic+setGroups'></span>

<h3>Description</h3>

<p>This function allows to set groups for rows, columns or clusters that shall
be summarised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGroups(schema = NULL, rows = NULL, columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGroups_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setGroups_+3A_rows">rows</code></td>
<td>
<p>[<code>list(3)</code>]<br /> the output of <code><a href="#topic+.sum">.sum</a></code> indicating
the rows and a function according to which those rows should be summarised.</p>
</td></tr>
<tr><td><code id="setGroups_+3A_columns">columns</code></td>
<td>
<p>[<code>list(3)</code>]<br /> the output of <code><a href="#topic+.sum">.sum</a></code>
indicating the columns and a function according to which those columns
should be summarised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setCluster">setCluster</a>()</code>,
<code><a href="#topic+setFilter">setFilter</a>()</code>,
<code><a href="#topic+setFormat">setFormat</a>()</code>,
<code><a href="#topic+setIDVar">setIDVar</a>()</code>,
<code><a href="#topic+setObsVar">setObsVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># please check the vignette for examples
</code></pre>

<hr>
<h2 id='setIDVar'>Set an identifying variable</h2><span id='topic+setIDVar'></span>

<h3>Description</h3>

<p>Identifying variables are those variables that describe the (qualitative)
properties that make each observation (as described by the
<code><a href="#topic+setObsVar">observed variables</a></code>) unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIDVar(
  schema = NULL,
  name = NULL,
  value = NULL,
  columns = NULL,
  rows = NULL,
  split = NULL,
  merge = NULL,
  distinct = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setIDVar_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Name of the new identifying variable.</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_value">value</code></td>
<td>
<p>[<code>character(1)</code>]<br /> In case the variable is an implicit
variable (i.e., which is not in the origin table), specify it here.</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_columns">columns</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The column(s) in which the
<em>values</em> of the new variable are recorded.</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_rows">rows</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> In case the variable is in several
columns, specify here additionally the row in which the <em>names</em> are
recorded.</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_split">split</code></td>
<td>
<p>[<code>character(1)</code>]<br /> In case the variable is part of a
compound value, this should be a regular expression that splits the
respective value off of that compound value. See
<code><a href="tidyr.html#topic+extract">extract</a></code> on how to set up the regular expression.</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_merge">merge</code></td>
<td>
<p>[<code>character(1)</code>]<br /> In case a variable is made up of
several columns, this should be the character string that would connect the
two columns (e.g., an empty space <code>" "</code>).</p>
</td></tr>
<tr><td><code id="setIDVar_+3A_distinct">distinct</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> whether or not the variable is
distinct from a cluster. This is the case when the variable is not
systematically available for all clusters and thus needs to be registered
separately from clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the currently suggested strategy to set
up a <a href="#topic+schema">schema description</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setCluster">setCluster</a>()</code>,
<code><a href="#topic+setFilter">setFilter</a>()</code>,
<code><a href="#topic+setFormat">setFormat</a>()</code>,
<code><a href="#topic+setGroups">setGroups</a>()</code>,
<code><a href="#topic+setObsVar">setObsVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># please check the vignette for examples
</code></pre>

<hr>
<h2 id='setObsVar'>Set an observed variable</h2><span id='topic+setObsVar'></span>

<h3>Description</h3>

<p>Observed variables are those variables that contain the (quantitative)
observed/measured values of each unique unit (as described by the
<code><a href="#topic+setIDVar">identifying variables</a></code>). There may be several of them
and in a tidy table they'd be recorded as separate columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setObsVar(
  schema = NULL,
  name = NULL,
  columns = NULL,
  top = NULL,
  distinct = FALSE,
  unit = NULL,
  factor = 1,
  key = NULL,
  value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setObsVar_+3A_schema">schema</code></td>
<td>
<p>[<code>schema(1)</code>]<br /> In case this information is added to an
already existing schema, provide that schema here (overwrites previous
information).</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br /> Name of the new measured variable.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_columns">columns</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> The column(s) in which the
<em>values</em> of the new variable are recorded.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_top">top</code></td>
<td>
<p>[<code>integerish(.)</code>]<br /> In case the variable is nested in a wide
identifying variable, specify here additionally the topmost row in which
the variable <em>name</em> sits.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_distinct">distinct</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> Whether or not the variable is
distinct from a cluster. This is the case when the variable is recorded
somewhere 'on the side' and thus not explicitly included in all clusters.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_unit">unit</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the unit of this variable.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_factor">factor</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> the factor that needs to be multiplied
with the values to convert to <code>unit</code>, defaults to 1. For instance, if
values are recorded in acres, but shall be recorded in hectare, the factor
would be 0.40468.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_key">key</code></td>
<td>
<p>[<code>integerish(1)</code>]<br /> If the variable is recorded (together
with other variables) so that the variable names are listed in one column
and the respective values are listed in another column, give here the
number of the column that contains the variable names. Can alternatively be
&quot;cluster&quot;, in case observed variables are the cluster ID.</p>
</td></tr>
<tr><td><code id="setObsVar_+3A_value">value</code></td>
<td>
<p>[<code>character(1)</code>]<br /> If the variable is recorded (together
with other variables) so that the variable names are listed in one column
and the respective values are listed in another column, give here the level
in the names column that refer to the values of this variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the currently suggested strategy to set
up a <a href="#topic+schema">schema description</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+schema">schema</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions to describe table arrangement: 
<code><a href="#topic+setCluster">setCluster</a>()</code>,
<code><a href="#topic+setFilter">setFilter</a>()</code>,
<code><a href="#topic+setFormat">setFormat</a>()</code>,
<code><a href="#topic+setGroups">setGroups</a>()</code>,
<code><a href="#topic+setIDVar">setIDVar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># please check the vignette for examples
</code></pre>

<hr>
<h2 id='show+2Cschema-method'>Print the <code>schema</code></h2><span id='topic+show+2Cschema-method'></span>

<h3>Description</h3>

<p>Print the <code>schema</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'schema'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cschema-method_+3A_object">object</code></td>
<td>
<p>[<code>schema</code>]<br /> the schema to print.</p>
</td></tr>
</table>

<hr>
<h2 id='tabs2shift'>List of table types</h2><span id='topic+tabs2shift'></span>

<h3>Description</h3>

<p>List of table types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabs2shift
</code></pre>


<h3>Format</h3>

<p>The object of class <code>list</code> contains 20 different types of tables
that are used throughout the unit-tests and examples/vignette.
</p>

<hr>
<h2 id='validateSchema'>Check and update schema descriptions</h2><span id='topic+validateSchema'></span>

<h3>Description</h3>

<p>This function takes a raw schema description and updates values that were
only given as wildcard or implied values. It is automatically called by
<code>reorganise</code>, but can also be used in concert with the getters to debug
a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateSchema(schema = NULL, input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateSchema_+3A_schema">schema</code></td>
<td>
<p>[<code>symbol(1)</code>]<br /> the schema description.</p>
</td></tr>
<tr><td><code id="validateSchema_+3A_input">input</code></td>
<td>
<p>[<code>data.frame(1)</code>]<br /> an input for which to check a schema
description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core idea of a schema description is that it can be written in a
very generic way, as long as it describes sufficiently where in a table
what variable can be found. A very generic way can be via using the
function <code><a href="#topic+.find">.find</a></code> to identify the initially unknown
cell-locations of a variable on-the-fly, for example when it is merely
known that a variable must be in the table, but not where it is.
</p>
<p><code>validateSchema</code> matches a schema with an input table and inserts the
accordingly evaluated positions (of clusters, filters and variables),
adapts some of the meta-data and ensures formal consistency of the schema.
</p>


<h3>Value</h3>

<p>An updated schema description
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a schema for an already tidy table
(tidyTab &lt;- tabs2shift$tidy)

schema &lt;-
  setIDVar(name = "territories", col = 1) %&gt;%
  setIDVar(name = "year", col = .find(pattern = "period")) %&gt;%
  setIDVar(name = "commodities", col = 3) %&gt;%
  setObsVar(name = "harvested", col = 5) %&gt;%
  setObsVar(name = "production", col = 6)

# before ...
schema

# ... after
validateSchema(schema = schema, input = tidyTab)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
