<!DOCTYPE html><html><head><title>Help for package tvReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tvReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tvReg-package'><p>tvReg: Time-Varying Coefficient for Single and Multi-Equation Regressions</p></a></li>
<li><a href='#.tvLM.ci'><p>tvReg internal and secondary functions</p></a></li>
<li><a href='#bw'><p>Bandwidth Selection by Cross-Validation</p></a></li>
<li><a href='#bwCov'><p>Covariance Bandwidth Calculation by Cross-Validation</p>
<em>bwCov</em> calculates a single bandwidth to estimate the time-varying variance-
covariance matrix.</a></li>
<li><a href='#CEES'><p>Standarised rates from a currency portfolio.</p></a></li>
<li><a href='#confint.tvlm'><p>Confidence Intervals for Objects in tvReg</p></a></li>
<li><a href='#FF5F'><p>Fama and French portfolio daily returns and factors for international markets.</p></a></li>
<li><a href='#forecast'><p>Forecast Methods for Objects in tvReg.</p></a></li>
<li><a href='#OECD'><p>Variables related to the problem of healthcare spending.</p></a></li>
<li><a href='#plot.tvsure'><p>Plot Methods for Objects in tvReg</p></a></li>
<li><a href='#predict.tvlm'><p>Predict Methods for Objects in tvReg.</p></a></li>
<li><a href='#print.tvlm'><p>Print results of functions in tvReg</p></a></li>
<li><a href='#RV'><p>Daily realized variance</p></a></li>
<li><a href='#summary.tvlm'><p>Print results of functions in tvReg</p></a></li>
<li><a href='#tvAcoef'><p>Time-Varying Coefficient Arrays of the Lagged Endogenous Variables of a TVVAR (no intercept).</p></a></li>
<li><a href='#tvAR'><p>Time-Varying Autoregressive Model</p></a></li>
<li><a href='#tvBcoef'><p>Coefficient Array of an Estimated tvVAR</p></a></li>
<li><a href='#tvCor'><p>Time-varying Correlation Estimation</p></a></li>
<li><a href='#tvCov'><p>Time-varying Variance-Covariance Estimation</p></a></li>
<li><a href='#tvFE'><p>Time-Varying Fixed Effects Estimation</p></a></li>
<li><a href='#tvGLS'><p>Time-Varying Generalised Least Squares</p></a></li>
<li><a href='#tvIRF'><p>Time-Varying Impulse Response Function</p></a></li>
<li><a href='#tvLM'><p>Time-Varying Coefficients Linear Models</p></a></li>
<li><a href='#tvOLS'><p>Time-Varying Ordinary Least Squares</p></a></li>
<li><a href='#tvPhi'><p>Time-Varying Coefficient Arrays of the MA Represention</p></a></li>
<li><a href='#tvPLM'><p>Time-Varying Coefficients Panel Data Models</p></a></li>
<li><a href='#tvPsi'><p>Time-Varying Coefficient Arrays of the Orthogonalised MA Represention</p></a></li>
<li><a href='#tvRE'><p>Time-Varying Random Effects Estimation</p></a></li>
<li><a href='#tvSURE'><p>Time-Varying Seemingly Unrelated Regression Equations Model</p></a></li>
<li><a href='#tvVAR'><p>Time-varying Vector Autoregressive Models</p></a></li>
<li><a href='#update.tvlm'><p>Update and Re-fit the Models of package tvReg</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time-Varying Coefficient for Single and Multi-Equation
Regressions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting time-varying coefficient models for single and multi-equation regressions, using kernel smoothing techniques.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), Matrix, graphics, stats (&ge; 2.14.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>systemfit (&ge; 1.1-20), MASS, vars, bvarsv, plm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/icasas/tvReg">https://github.com/icasas/tvReg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/icasas/tvReg/issues">https://github.com/icasas/tvReg/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Isabel Casas [aut, cre],
  Ruben Fernandez-Casal [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Isabel Casas &lt;casasis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-01 10:49:55 UTC; ysa</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-01 11:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='tvReg-package'>tvReg: Time-Varying Coefficient for Single and Multi-Equation Regressions</h2><span id='topic+tvReg-package'></span><span id='topic+tvReg'></span>

<h3>Description</h3>

<p>This package covers a large range of semiparametric regression methods with 
time-varying coefficients using nonparametric kernel smoothing for the estimation.
</p>


<h3>Main functions</h3>

<p>The five basic functions in this package are <code><a href="#topic+tvLM">tvLM</a></code>, <code><a href="#topic+tvAR">tvAR</a></code>, 
<code><a href="#topic+tvSURE">tvSURE</a></code>, <code><a href="#topic+tvPLM">tvPLM</a></code>, <code><a href="#topic+tvVAR">tvVAR</a></code> and <code><a href="#topic+tvIRF">tvIRF</a></code>. 
Moreover, this package provides the <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, 
<code><a href="#topic+forecast">forecast</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="base.html#topic+print">print</a></code>, 
<code><a href="stats.html#topic+resid">resid</a></code> and <code><a href="#topic+summary">summary</a></code> methods adapted to the class attributes 
of the <code>tvReg</code>. 
In addition, it includes bandwidth selection methods, time-varying variance-covariance 
estimators and four estimation procedures: the time-varying ordinary least squares, 
which are implemented in the <code><a href="#topic+tvOLS">tvOLS</a></code> methods, the time-varying 
generalised least squares for a list of equations, which is implemented in the 
<code><a href="#topic+tvGLS">tvGLS</a></code> methods, time-varying pooled and random effects estimators for 
panel data, which are implemented in the <code><a href="#topic+tvRE">tvRE</a></code> and the time-varying 
fixed effects estimator, which is implemente in the <code><a href="#topic+tvFE">tvFE</a></code>.
</p>


<h3>Further information</h3>

<p>Details on the theory and applications to finance and macroeconomics can be found 
in Casas and Fernandez-Casal (2019, <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526</a>),
and in the package vignette <a href="https://icasas.github.io/tvReg/articles/tvReg.html">https://icasas.github.io/tvReg/articles/tvReg.html</a>.
</p>


<h3>Acknowledgments</h3>

<p>Funded by the Horizon 2020. Framework Programme of the European Union.
</p>


<h3>Author(s)</h3>

<p>Isabel Casas (<a href="mailto:casasis@gmail.com">casasis@gmail.com</a>),
Ruben Fernandez-Casal (<a href="mailto:rubenfcasal@gmail.com">rubenfcasal@gmail.com</a>).
</p>


<h3>References</h3>

<p>Casas, I. and Fernandez-Casal, R., <em>tvReg: Time-varying Coefficient Linear 
Regression for Single and Multi-Equations in R</em> (April 1, 2019). 
Available at SSRN: <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526</a>.
</p>

<hr>
<h2 id='.tvLM.ci'>tvReg internal and secondary functions</h2><span id='topic+.tvLM.ci'></span><span id='topic+.tvSURE.ci'></span><span id='topic+tvReg-internals'></span><span id='topic+.kernel'></span><span id='topic+.univariatePlot'></span><span id='topic+.tvCov.cv'></span><span id='topic+.tvFE.cv'></span><span id='topic+.tvIRF'></span><span id='topic+.tvOLS.cv'></span><span id='topic+.tvRE.cv'></span><span id='topic+tvreg.control'></span>

<h3>Description</h3>

<p>Listed below are supporting functions for the major methods in tvReg.
</p>
<p>Create a list of control pararameters for the <code><a href="#topic+tvSURE">tvSURE</a></code> and
<code><a href="#topic+tvPLM">tvPLM</a></code> methods.
All control parameters that are not passed to this function are set to
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tvLM.ci(x, yboot)

.tvSURE.ci(x, yboot)

.kernel(x, bw, tkernel = "Triweight")

.univariatePlot(x, vars = NULL, ylim = NULL, ...)

.tvCov.cv(
  bw,
  x,
  z = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)

.tvFE.cv(
  bw,
  x,
  y,
  z = NULL,
  neq,
  obs,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)

.tvIRF(
  x,
  impulse,
  response,
  y.names,
  n.ahead,
  ortho,
  ortho.cov,
  bw.cov,
  cumulative
)

.tvOLS.cv(
  bw,
  x,
  y,
  z = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE
)

.tvRE.cv(
  bw,
  x,
  y,
  z = NULL,
  neq,
  obs,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)

tvreg.control(maxiter = 100, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".tvLM.ci_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_bw">bw</code></td>
<td>
<p>A scalar.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_z">z</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_est">est</code></td>
<td>
<p>A character, either &quot;lc&quot; or &quot;ll&quot; for local constant or local linear.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for the iterative FGLS
estimations.</p>
</td></tr>
<tr><td><code id=".tvLM.ci_+3A_tol">tol</code></td>
<td>
<p>tolerance level indicating when to stop the iteration for the iterative FGLS estimations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>.kernel calculates the kernel values of a vector and a given bandwidth
</p>
<p>If the estimation is iterative FGLS with <code>maxiter</code>&gt;1, the convergence criterion is
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{ \frac{ \sum_{i, j}
(B_{i,j,g} - B{i, j, g-1})^2 }{ \sum_{i, j} B_{i, j, g-1}^2 }} &lt; \code{tol}</code>
</p>

<p>(<code class="reqn">B_{i, j,g}</code> is the ith, jth coefficient of the gth iteration step).
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>
<p>A scalar with the mean squared error.
</p>
<p>A list of the above components.
</p>

<hr>
<h2 id='bw'>Bandwidth Selection by Cross-Validation</h2><span id='topic+bw'></span><span id='topic+bw.default'></span><span id='topic+bw.list'></span><span id='topic+bw.tvlm'></span><span id='topic+bw.tvar'></span><span id='topic+bw.tvvar'></span><span id='topic+bw.tvsure'></span><span id='topic+bw.tvplm'></span><span id='topic+bw.pdata.frame'></span>

<h3>Description</h3>

<p>Calculate bandwidth(s) by cross-validation for functions tvSURE, tvVAR and tvLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw(x, ...)

## Default S3 method:
bw(
  x,
  y,
  z = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE,
  ...
)

## S3 method for class 'list'
bw(
  x,
  y,
  z = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE,
  ...
)

## S3 method for class 'tvlm'
bw(x, ...)

## S3 method for class 'tvar'
bw(x, ...)

## S3 method for class 'tvvar'
bw(x, ...)

## S3 method for class 'tvsure'
bw(x, ...)

## S3 method for class 'tvplm'
bw(x, ...)

## S3 method for class 'pdata.frame'
bw(
  x,
  z = NULL,
  method,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="bw_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
<tr><td><code id="bw_+3A_y">y</code></td>
<td>
<p>A matrix or vector with the dependent variable(s).</p>
</td></tr>
<tr><td><code id="bw_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="bw_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave-one block-out cross-validation.
By default 'cv.block=0' meaning leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="bw_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="bw_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="bw_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
<tr><td><code id="bw_+3A_method">method</code></td>
<td>
<p>A character with the choice of panel model/estimation method:
If method = <code>tvPOLS</code> (default) then the data is pooled estimated with time-varying OLS. 
No individual or time effects are estimated
If method = <code>tvFE</code> then individual effects which might be correlated with 
the regressors are estimated.
If method = <code>tvRE</code> then individual effects are considered random and independent
of the regressors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bw</code> returns a vector or a scalar with the bandwith to estimate the mean or the covariance
residuals, fitted values.
</p>
<p>A scalar or a vector of scalars.
</p>
<p>A scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate data
tau &lt;- seq(1:200)/200
beta &lt;- data.frame(beta1 = sin(2*pi*tau), beta2 =  2*tau)
X &lt;- data.frame(X1 = rnorm(200), X2 =  rchisq(200, df = 4))
error &lt;- rt(200, df = 10)
y &lt;- apply(X*beta, 1, sum) + error

##Select bandwidth by cross-validation
bw &lt;- bw(X, y, est = "ll", tkernel = "Gaussian")

data( Kmenta, package = "systemfit" )

## x is a list of matrices containing the regressors, one matrix for each equation
x &lt;- list()
x[[1]] &lt;- Kmenta[, c("price", "income")]
x[[2]] &lt;- Kmenta[, c("price", "farmPrice", "trend")]

## 'y' is a matrix with one column for each equation
y &lt;- cbind(Kmenta$consump, Kmenta$consump)

## Select bandwidth by cross-validation
bw &lt;- bw(x = x, y = y)

##One bandwidth per equation
print(bw)

</code></pre>

<hr>
<h2 id='bwCov'>Covariance Bandwidth Calculation by Cross-Validation
<em>bwCov</em> calculates a single bandwidth to estimate the time-varying variance-
covariance matrix.</h2><span id='topic+bwCov'></span>

<h3>Description</h3>

<p>Covariance Bandwidth Calculation by Cross-Validation
<em>bwCov</em> calculates a single bandwidth to estimate the time-varying variance-
covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwCov(
  x,
  z = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwCov_+3A_x">x</code></td>
<td>
<p>A matrix or a data frame.</p>
</td></tr>
<tr><td><code id="bwCov_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="bwCov_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave-one block-out cross-validation.
By default 'cv.block=0' meaning leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="bwCov_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="bwCov_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CEES)
## Using a shorter set for a quick example. Variable "Date" is removed.
mydata &lt;- tail (CEES[, -1], 50)
bw.cov &lt;- bwCov(mydata)
Sigma.hat &lt;- tvCov(mydata, bw = bw.cov)

</code></pre>

<hr>
<h2 id='CEES'>Standarised rates from a currency portfolio.</h2><span id='topic+CEES'></span>

<h3>Description</h3>

<p>Aslanidis and Casas (2013) consider a portfolio of daily US dollar exchange rates of the Australian
dollar (AUS), Swiss franc (CHF), euro (EUR), British pound (GBP), South African rand (RAND),
Brazilian real (REALB), and Japanese yen (YEN) over the period from January 1, 1999
until May 7, 2010 (T = 2856 observations). This dataset contains the standarised rates after
&quot;devolatilisation&quot;, i.e. standarising the rates using a GARCH(1,1) estimate of the volatility.
</p>


<h3>Format</h3>

<p>A data frame with 2855 rows and 8 variables. Below the standarised rates of daily US dollar
exchange rates of
</p>

<dl>
<dt>Date</dt><dd><p>Daily data from Jan 6, 1999 until May 7, 2010 - without
weekends and days off</p>
</dd>
<dt>AUS</dt><dd><p>Australian dollar</p>
</dd>
<dt>CHF</dt><dd><p>Swiss franc</p>
</dd>
<dt>EUR</dt><dd><p>Euro</p>
</dd>
<dt>GBP</dt><dd><p>British pound</p>
</dd>
<dt>RAND</dt><dd><p>South African rand</p>
</dd>
<dt>REALB</dt><dd><p>Brazilian real</p>
</dd>
<dt>YEN</dt><dd><p>Japanese yen</p>
</dd>
</dl>



<h3>References</h3>

<p>Aslanidis, N. and Casas, I. (2013) Nonparametric correlation models for portfolio allocation,
<em>Journal of Banking and Finance</em>, 37, 2268 - 2283.
</p>

<hr>
<h2 id='confint.tvlm'>Confidence Intervals for Objects in tvReg</h2><span id='topic+confint.tvlm'></span><span id='topic+confint.tvar'></span><span id='topic+confint.tvsure'></span><span id='topic+confint.tvvar'></span><span id='topic+confint.tvirf'></span><span id='topic+confint.tvplm'></span>

<h3>Description</h3>

<p>confint is used to estimate the bootstrap confidence intervals for objects with class
attribute <code>tvlm</code>, <code>tvar</code>, <code>tvirf</code>, <code>tvsure</code> and <code>tvplm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvlm'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)

## S3 method for class 'tvar'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)

## S3 method for class 'tvsure'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)

## S3 method for class 'tvvar'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)

## S3 method for class 'tvirf'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)

## S3 method for class 'tvplm'
confint(
  object,
  parm,
  level = 0.95,
  runs = 100,
  tboot = c("wild", "wild2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.tvlm_+3A_object">object</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="confint.tvlm_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence intervals, 
either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.tvlm_+3A_level">level</code></td>
<td>
<p>Numeric, the confidence level required (between 0 and 1).</p>
</td></tr>
<tr><td><code id="confint.tvlm_+3A_runs">runs</code></td>
<td>
<p>(optional) Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="confint.tvlm_+3A_tboot">tboot</code></td>
<td>
<p>Type of wild bootstrap, choices 'wild'(default), 'wild2'. Option 'wild' uses the
distribution suggested by Mammen (1993) in the wild resampling, while 'wild2' uses the standard
normal.</p>
</td></tr>
<tr><td><code id="confint.tvlm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>tvsure</code> with BOOT, Lower and Upper different from NULL.
</p>


<h3>References</h3>

<p>Chen, X. B., Gao, J., Li, D., and Silvapulle, P (2017) Nonparametric estimation and 
forecasting for time-varying coefficient realized volatility models,
<em>Journal of Business and Economic Statistics</em>, 36, 88-100.
</p>
<p>Mammen, E (1993) Bootstrap and wild bootstrap for high dimensional linear models,
<em> Annals of Statistics</em>, 21, 255-285.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tvLM">tvLM</a></code>, <code><a href="#topic+tvAR">tvAR</a></code>, <code><a href="#topic+tvVAR">tvVAR</a></code>,
<code><a href="#topic+tvSURE">tvSURE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Calculation of confidence intervals for a TVLM model

##Generation of time-varying coefficients linear model
set.seed(42)
tau &lt;- seq(1:200)/200
beta &lt;- data.frame(beta1 = sin(2*pi*tau), beta2= 2*tau)
X1 &lt;- rnorm(200)
X2 &lt;- rchisq(200, df = 4)
error &lt;- rt(200, df = 10)
y &lt;- apply(cbind(X1, X2)*beta, 1, sum) + error
data &lt;- data.frame(y = y, X1 = X1, X2 = X2)

##Fitting the model and confidence interval calculation
model.tvlm &lt;-  tvLM(y ~ 0 + X1 + X2, data = data, bw = 0.29)
tvci &lt;- confint(model.tvlm, level = 0.95, runs = 20)

##If a second confidence interval on the "same" object is calculated, 
##for example with a different level, the calculation is faster
tvci.80 &lt;- confint(tvci, level = 0.8)

## End(Not run)
</code></pre>

<hr>
<h2 id='FF5F'>Fama and French portfolio daily returns and factors for international markets.</h2><span id='topic+FF5F'></span>

<h3>Description</h3>

<p>A dataset containing the returns of four portfolios ordered by size and book-to-market. The
four portfolios are SMALL/LoBM, SMALL/HiBM, BIG/LoBM and BIG/HiBM in four international
markets: North America (NA), Japan (JP), Asia Pacific (AP) and Europe (EU). It also contains the
Fama/French 5 factors for each of the markets.
</p>


<h3>Format</h3>

<p>A data frame with 314 rows and 41 variables.
</p>

<dl>
<dt>Date</dt><dd><p>Date, months from July 1990 until August 2016</p>
</dd>
<dt>NA.SMALL.LoBM</dt><dd><p>Monthly returns of portfolio SMALL/LoBM in North American market</p>
</dd>
<dt>NA.SMALL.HiBM</dt><dd><p>Monthly returns of portfolio SMALL/HiBM in North American market</p>
</dd>
<dt>NA.BIG.LoBM</dt><dd><p>Monthly returns of portfolio BIG/LoBM in North American market</p>
</dd>
<dt>NA.BIG.HiBM</dt><dd><p>Monthly returns of portfolio BIG/HiBM in North American market</p>
</dd>
<dt>NA.Mkt.RF</dt><dd><p>North American market excess returns, i.e return of the 
market - market risk free rate</p>
</dd>
<dt>NA.SMB</dt><dd><p>SMB (Small Minus Big) for the North American market</p>
</dd>
<dt>NA.HML</dt><dd><p>HML (High Minus Low) for the North American market</p>
</dd>
<dt>NA.RMW</dt><dd><p>RMW (Robust Minus Weak) for the North American market</p>
</dd>
<dt>NA.CMA</dt><dd><p>CMA (Conservative Minus Aggressive) for the North American market</p>
</dd>
<dt>NA.RF</dt><dd><p>North American risk free rate</p>
</dd>
<dt>JP.SMALL.LoBM</dt><dd><p>Monthly returns of portfolio SMALL/LoBM in Japanese market</p>
</dd>
<dt>JP.SMALL.HiBM</dt><dd><p>Monthly returns of portfolio SMALL/HiBM in Japanese market</p>
</dd>
<dt>JP.BIG.LoBM</dt><dd><p>Monthly returns of portfolio BIG/LoBM in Japanese market</p>
</dd>
<dt>JP.BIG.HiBM</dt><dd><p>Monthly returns of portfolio BIG/HiBM in Japanese market</p>
</dd>
<dt>JP.Mkt.RF</dt><dd><p>Japanese market excess returns, i.e return of the 
market - market risk free rate</p>
</dd>
<dt>JP.SMB</dt><dd><p>SMB (Small Minus Big) for the Japanese market</p>
</dd>
<dt>JP.HML</dt><dd><p>HML (High Minus Low) for the Japanese market</p>
</dd>
<dt>JP.RMW</dt><dd><p>RMW (Robust Minus Weak) for the Japanese market</p>
</dd>
<dt>JP.CMA</dt><dd><p>CMA (Conservative Minus Aggressive) for the Japanese market</p>
</dd>
<dt>JP.RF</dt><dd><p>Japanese risk free rate</p>
</dd>
<dt>AP.SMALL.LoBM</dt><dd><p>Monthly returns of portfolio SMALL/LoBM in Asia Pacific market</p>
</dd>
<dt>AP.SMALL.HiBM</dt><dd><p>Monthly returns of portfolio SMALL/HiBM in Asia Pacific market</p>
</dd>
<dt>AP.BIG.LoBM</dt><dd><p>Monthly returns of portfolio BIG/LoBM in Asia Pacific market</p>
</dd>
<dt>AP.BIG.HiBM</dt><dd><p>Monthly returns of portfolio BIG/HiBM in Asia Pacific market</p>
</dd>
<dt>AP.Mkt.RF</dt><dd><p>Asia Pacific market excess returns, i.e return of the 
market - maket risk free rate</p>
</dd>
<dt>AP.SMB</dt><dd><p>SMB (Small Minus Big) for the Asia Pacific market</p>
</dd>
<dt>AP.HML</dt><dd><p>HML (High Minus Low) for the Asia Pacific market</p>
</dd>
<dt>AP.RMW</dt><dd><p>RMW (Robust Minus Weak) for the Asia Pacific market</p>
</dd>
<dt>AP.CMA</dt><dd><p>CMA (Conservative Minus Aggressive) for the Asia Pacific market</p>
</dd>
<dt>AP.RF</dt><dd><p>Asia Pacific risk free rate</p>
</dd>
<dt>EU.SMALL.LoBM</dt><dd><p>Excess return of portfolio SMALL/LoBM in European market</p>
</dd>
<dt>EU.SMALL.HiBM</dt><dd><p>Excess return of portfolio SMALL/HiBM in European market</p>
</dd>
<dt>EU.BIG.LoBM</dt><dd><p>Excess return of portfolio BIG/LoBM in European market</p>
</dd>
<dt>EU.BIG.HiBM</dt><dd><p>Excess return of portfolio BIG/HiBM in European market</p>
</dd>
<dt>EU.Mkt.RF</dt><dd><p>European market excess returns, i.e returns of the 
market - market risk free rate</p>
</dd>
<dt>EU.SMB</dt><dd><p>SMB (Small Minus Big) for the European market</p>
</dd>
<dt>EU.HML</dt><dd><p>HML (High Minus Low) for the European market</p>
</dd>
<dt>EU.RMW</dt><dd><p>RMW (Robust Minus Weak) for the European market</p>
</dd>
<dt>EU.CMA</dt><dd><p>CMA (Conservative Minus Aggressive) for the European market</p>
</dd>
<dt>EU.RF</dt><dd><p>European risk free rate</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>
</p>


<h3>References</h3>

<p>Kennet R. French - Data Library (2017) 
http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html#International
</p>
<p>Fama, E. and French, K. R (1993) Common risk factors in the returns on stocks and bonds,
<em>Journal of Financial Economics</em>, 3-56.
</p>
<p>Fama, E. F. and French, K. R (2015) A five-factor asset pricing model,
<em>Journal of Financial Economics</em>, 116, 1-22.
</p>

<hr>
<h2 id='forecast'>Forecast Methods for Objects in tvReg.</h2><span id='topic+forecast'></span><span id='topic+forecast.tvlm'></span><span id='topic+forecast.tvar'></span><span id='topic+forecast.tvvar'></span><span id='topic+forecast.tvsure'></span><span id='topic+forecast.tvplm'></span>

<h3>Description</h3>

<p><code>forecast</code> calculates the forecast for objects with class attribute <code>tvlm</code>, <code>tvar</code>, 
<code>tvvar</code>, <code>tvirf</code>, <code>tvsure</code> and <code>tvplm</code>. If the 
smoothing variable (z) in the model is non-NULL and it is a random 
variable then use function <code>predict</code> with parameter <code>newz</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(object, ...)

## S3 method for class 'tvlm'
forecast(object, newdata, n.ahead = 1, winsize = 0, ...)

## S3 method for class 'tvar'
forecast(object, n.ahead = 1, newz = NULL, newexogen = NULL, winsize = 0, ...)

## S3 method for class 'tvvar'
forecast(object, n.ahead = 1, newz = NULL, newexogen = NULL, winsize = 0, ...)

## S3 method for class 'tvsure'
forecast(object, newdata, n.ahead = 1, winsize = 0, ...)

## S3 method for class 'tvplm'
forecast(object, newdata, n.ahead = 1, winsize = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_+3A_object">object</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="forecast_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
<tr><td><code id="forecast_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data.frame with the values of the regressors to use
for forecasting.</p>
</td></tr>
<tr><td><code id="forecast_+3A_n.ahead">n.ahead</code></td>
<td>
<p>A scalar with the forecast horizon, value 1 by default.</p>
</td></tr>
<tr><td><code id="forecast_+3A_winsize">winsize</code></td>
<td>
<p>A scalar. If 0 then an 'increase window' forecasting is performed.
Otherwise a 'rolling window' forecasting is performed with window size given by 
'winsize'.</p>
</td></tr>
<tr><td><code id="forecast_+3A_newz">newz</code></td>
<td>
<p>A vector with the new values of the smoothing variable.</p>
</td></tr>
<tr><td><code id="forecast_+3A_newexogen">newexogen</code></td>
<td>
<p>A matrix or vector with the new values of the exogenous variables.
Only for predictions of *tvar* and *tvvar* objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class matrix or vector with the same dimensions than  the dependent 
variable of <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("RV")
RV2 &lt;- head(RV, 2001)
TVHAR &lt;- tvLM (RV ~ RV_lag + RV_week + RV_month, data = RV2, bw = 20)
newdata &lt;- cbind(RV$RV_lag[2002:2004], RV$RV_week[2002:2004],
              RV$RV_month[2002:2004])
forecast(TVHAR, newdata, n.ahead = 3)


data("RV")
exogen = RV[1:2001, c("RV_week", "RV_month")]
TVHAR2 &lt;- tvAR(RV$RV_lag[1:2001], p = 1, exogen = exogen, bw = 20)
newexogen &lt;- RV[2002:2004, c("RV_week", "RV_month")]
forecast(TVHAR2, n.ahead = 3, newexogen = newexogen)

data(usmacro, package = "bvarsv")
tvVAR.fit &lt;- tvVAR(usmacro, p = 6, type = "const", bw = c(1.8, 20, 20))
forecast(tvVAR.fit, n.ahead = 10)

data("Kmenta", package = "systemfit")
eqDemand &lt;- consump ~ price + income
eqSupply &lt;- consump ~ price + farmPrice 
system &lt;- list(demand = eqDemand, supply = eqSupply)
tvOLS.fit &lt;- tvSURE(system, data = Kmenta, est = "ll", bw = c(1.5, 1.5))
newdata &lt;- data.frame(price = c(90, 100, 103), farmPrice = c(70, 95, 103), 
income = c(82, 94, 115))
forecast(tvOLS.fit, newdata = newdata, n.ahead = 3)
data(OECD)
tvpols &lt;- tvPLM(lhe~lgdp+pop65+pop14+public, index = c("country", "year"), 
data = OECD, method = "pooling", bw =  8.9)
newdata &lt;- OECD[c(7, 9), 4:7]
forecast(tvpols, newdata = newdata, n.ahead = 2)
</code></pre>

<hr>
<h2 id='OECD'>Variables related to the problem of healthcare spending.</h2><span id='topic+OECD'></span>

<h3>Description</h3>

<p>Variables related to the problem of healthcare spending.
</p>


<h3>Format</h3>

<p>A data frame with 680 rows and 7 columns. 
</p>

<dl>
<dt>country</dt><dd></dd>
<dt>year</dt><dd></dd>
<dt>lhe</dt><dd><p>Log of country's healthcare spending</p>
</dd>
<dt>lgdp</dt><dd><p>log of country's gdp</p>
</dd>
<dt>pop65</dt><dd><p>Country's ratio of population greater than 65 years old</p>
</dd>
<dt>pop14</dt><dd><p>Country's ratio of population younger than 15 years old</p>
</dd>
<dt>public</dt><dd><p>Country's ratio of healthcare funding coming from the government</p>
</dd>
</dl>



<h3>References</h3>

<p>Casas, I., Gao, J., Peng, B. and Xie, S. (2021). Time-Varying Income Elasticities 
of Healthcare Expenditure for the OECD and Eurozone. 
<em>Journal of Applied Econometrics, 36, pp. 328-345</em>.
</p>

<hr>
<h2 id='plot.tvsure'>Plot Methods for Objects in tvReg</h2><span id='topic+plot.tvsure'></span><span id='topic+plot.tvlm'></span><span id='topic+plot.tvar'></span><span id='topic+plot.tvplm'></span><span id='topic+plot.tvvar'></span><span id='topic+plot.tvirf'></span>

<h3>Description</h3>

<p>Plot methods for objects with class attribute <code>tvlm</code>, <code>tvar</code>, <code>tvvar</code>,
<code>tvirf</code>, <code>tvsure</code> or <code>tvplm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvsure'
plot(x, eqs = NULL, vars = NULL, plot.type = c("multiple", "single"), ...)

## S3 method for class 'tvlm'
plot(x, ...)

## S3 method for class 'tvar'
plot(x, ...)

## S3 method for class 'tvplm'
plot(x, ...)

## S3 method for class 'tvvar'
plot(x, ...)

## S3 method for class 'tvirf'
plot(
  x,
  obs.index = NULL,
  impulse = NULL,
  response = NULL,
  plot.type = c("multiple", "single"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tvsure_+3A_x">x</code></td>
<td>
<p>An object used to select the method.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_eqs">eqs</code></td>
<td>
<p>A vector of integers. Equation(s) number(s) of the coefficients to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_vars">vars</code></td>
<td>
<p>A vector of integers. Variable number(s) of the coefficients to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_plot.type">plot.type</code></td>
<td>
<p>Character, if multiple all plots are drawn in a single device,
otherwise the plots are shown consecutively.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_obs.index">obs.index</code></td>
<td>
<p>Scalar (optional), the time at which the impulse response is plotted.
If left NULL, the mean over the whole period is plotted (this values should be similar to
the estimation using a non time-varying VAR method).</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_impulse">impulse</code></td>
<td>
<p>Character  vector (optional) of the impulses, default is all variables.</p>
</td></tr>
<tr><td><code id="plot.tvsure_+3A_response">response</code></td>
<td>
<p>Character vector (optional) of the responses, default is all variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tvLM">tvLM</a></code>, <code><a href="#topic+tvAR">tvAR</a></code>, <code><a href="#topic+tvVAR">tvVAR</a></code>,
<code><a href="#topic+tvSURE">tvSURE</a></code>, <code><a href="#topic+tvPLM">tvPLM</a></code>
</p>

<hr>
<h2 id='predict.tvlm'>Predict Methods for Objects in tvReg.</h2><span id='topic+predict.tvlm'></span><span id='topic+predict.tvar'></span><span id='topic+predict.tvvar'></span><span id='topic+predict.tvsure'></span><span id='topic+predict.tvplm'></span>

<h3>Description</h3>

<p>Predict methods for objects with class attribute <code>tvlm</code>, <code>tvar</code>, 
<code>tvvar</code>, <code>tvirf</code>, <code>tvsure</code> and <code>tvplm</code>. This function needs new values of 
variables y (response), x (regressors), exogen (exogenous variables, when used),
and  z (smoothing variable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvlm'
predict(object, newdata, newz, ...)

## S3 method for class 'tvar'
predict(object, newdata, newz, newexogen = NULL, ...)

## S3 method for class 'tvvar'
predict(object, newdata, newz, newexogen = NULL, ...)

## S3 method for class 'tvsure'
predict(object, newdata, newz, ...)

## S3 method for class 'tvplm'
predict(object, newdata, newz, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tvlm_+3A_object">object</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="predict.tvlm_+3A_newdata">newdata</code></td>
<td>
<p>A pdata.frame with new values of all regressors, with the
same name and order as they appear in argument 'data' from the 'tvplm'
object</p>
</td></tr>
<tr><td><code id="predict.tvlm_+3A_newz">newz</code></td>
<td>
<p>A vector with new values of the smoothing variable.</p>
</td></tr>
<tr><td><code id="predict.tvlm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="predict.tvlm_+3A_newexogen">newexogen</code></td>
<td>
<p>A matrix or vector with the new value of the exogenous variables.
Only for predictions of 'tvar' and 'tvvar' objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class matrix or vector with the prediction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example of TVLM prediction with coefficients as 
## functions of the realized quarticity

data("RV")
RV2 &lt;- head(RV, 2001)
z &lt;- RV2$RQ_lag_sqrt
TVHARQ &lt;- tvLM (RV ~ RV_lag + RV_week + RV_month, 
                 z = z, data = RV2, bw = 0.0062)
newdata &lt;- cbind(RV$RV_lag[2002:2004], RV$RV_week[2002:2004],
              RV$RV_month[2002:2004])
newz &lt;- RV$RQ_lag_sqrt[2002:2004]
predict(TVHARQ, newdata, newz)

## Example of TVAR prediction with coefficients as 
## functions of the realized quarticity
data("RV")
RV2 &lt;- head(RV, 2001)
exogen = RV2[, c("RV_week", "RV_month")]
TVHARQ2 &lt;- tvAR (RV2$RV, p = 1, exogen = exogen,  
                      z = RV2[, "RQ_lag_sqrt"], bw = 0.0062)
newylag &lt;- RV$RV[2002:2004]
newz &lt;- RV$RQ_lag_sqrt[2002:2004]
newexogen &lt;- RV[2002:2004, c("RV_week", "RV_month")]
predict(TVHARQ2, newylag,  newz, newexogen = newexogen)
## Example of TVVAR prediction with coefficients as 
## functions of a random ARMA (2,2) process

data(usmacro, package = "bvarsv")
smoothing &lt;- arima.sim(n = NROW(usmacro) + 3, 
list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)), 
sd = sqrt(0.1796))
smoothing &lt;- as.numeric(smoothing)
TVVAR.z &lt;- tvVAR(usmacro, p = 6, type = "const", 
               z = smoothing[1:NROW(usmacro)], bw = c(16.3, 16.3, 16.3))
newdata &lt;- data.frame(inf = c(2, 1, 6), une = c(5, 4, 9), tbi = c(1, 2.5, 3))
newz &lt;- c(0, 1.2, -0.2)
predict(TVVAR.z, newdata = newdata, newz = newz)

## Example of TVSURE prediction with coefficients as 
## functions of an ARMA(2,2) process
data("Kmenta", package = "systemfit")
nobs &lt;- NROW (Kmenta)
eqDemand &lt;- consump ~ price + income
eqSupply &lt;- consump ~ price + farmPrice 
system &lt;- list(demand = eqDemand, supply = eqSupply)
smoothing &lt;- arima.sim(n = nobs + 3, 
                       list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)), 
                       sd = sqrt(0.1796))
smoothing &lt;- as.numeric(smoothing)
TVOLS.z &lt;- tvSURE(system, data = Kmenta,  
                      z = smoothing[1:nobs],  bw = c(7, 1.8),
                      est = "ll")
newdata &lt;- data.frame(consump = c(95, 100, 102), price = c(90, 100, 103), 
                      farmPrice = c(70, 95, 103), income = c(82, 94, 115))
newz &lt;- tail(smoothing, 3)
predict(TVOLS.z, newdata = newdata, newz = newz)

data(OECD)
z &lt;- runif(length(levels(OECD$year)), 10, 15)
TVPOLS &lt;- tvPLM(lhe~lgdp+pop65+pop14+public, z = z,
index = c("country", "year"), data = OECD,  method ="pooling", bw =  2)
newdata &lt;- cbind(lgdp = c(10, 13), pop65 = c(9, 12), 
pop14 = c(17, 30), public = c(13, 20))  
newz &lt;- runif(2, 10, 15)
predict(TVPOLS, newdata = newdata, newz = newz)
</code></pre>

<hr>
<h2 id='print.tvlm'>Print results of functions in tvReg</h2><span id='topic+print.tvlm'></span><span id='topic+print.tvar'></span><span id='topic+print.tvplm'></span><span id='topic+print.tvsure'></span><span id='topic+print.tvvar'></span><span id='topic+print.tvirf'></span>

<h3>Description</h3>

<p>Print some results for objects with class attribute <code>tvlm</code>, <code>tvar</code>, <code>tvvar</code>,
<code>tvirf</code>, <code>tvsure</code> and <code>tvplm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvlm'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvar'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvplm'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvsure'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvvar'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvirf'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tvlm_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="print.tvlm_+3A_digits">digits</code></td>
<td>
<p>An integer, indicating the minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="print.tvlm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions print a few results from the time-varying estimated coefficients
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.tvlm">plot.tvlm</a></code>, <code><a href="#topic+plot.tvar">plot.tvar</a></code>, <code><a href="#topic+plot.tvvar">plot.tvvar</a></code>,
<code><a href="#topic+plot.tvirf">plot.tvirf</a></code>,<code><a href="#topic+plot.tvsure">plot.tvsure</a></code>, <code><a href="#topic+plot.tvplm">plot.tvplm</a></code>
</p>

<hr>
<h2 id='RV'>Daily realized variance</h2><span id='topic+RV'></span>

<h3>Description</h3>

<p>A dataset containing the daily realized variance, and some of its lags,
obtained from 1-minute close prices of the SP 500. Similar data has
been used in the HAR model in Corsi (2009), the HARQ and SHARQ models in
Bollerslev et al (2016) and the TVHARQ and TVSHARQ models in 
Casas et al (2018). The time period runs from Feb 1990 until 
Dec 2006.
</p>


<h3>Format</h3>

<p>A data frame with 4264 rows and 6 variables.
</p>

<dl>
<dt>Date</dt><dd><p>Daily data from Feb 1, 1990 until Dec 29, 2006 - without
weekends and days off</p>
</dd>
<dt>RV</dt><dd><p>Daily realized variance at time t</p>
</dd>
<dt>RV_lag</dt><dd><p>Daily realized variance at time t-1</p>
</dd>
<dt>RV_week</dt><dd><p>Weekly average realized variance at time t-5</p>
</dd>
<dt>RV_month</dt><dd><p>Monthly average realized variance at time t-22</p>
</dd>
<dt>RQ_lag_sqrt</dt><dd><p>Daily squared root of the realized quarticity at time t-1</p>
</dd>
</dl>



<h3>References</h3>

<p>Bollerslev, T., Patton, A. J. and Quaedvlieg, R. (2016) Exploiting the 
errors: A simple approach for improved volatility forecasting. 
<em>Journal of Econometrics</em>, 192, 1-18.
</p>
<p>Bollerslev, T., Tauchen, G. and Zhou, H. (2009) Expected stock returns 
and variance risk premia. <em>The Review of Financial Studies</em>, 22, 44-63.
</p>
<p>Casas, I., Mao, X. and Vega, H. (2018) Reexamining financial and economic 
predictability with new estimators of realized variance and variance 
risk premium. Url= http://pure.au.dk/portal/files/123066669/rp18_10.pdf
</p>
<p>Corsi, F. (2009) A simple approximate long-memory model of realized 
volatility. <em>Journal of Financial Econometrics</em>, 7, 174-196.
</p>

<hr>
<h2 id='summary.tvlm'>Print results of functions in tvReg</h2><span id='topic+summary.tvlm'></span><span id='topic+summary'></span><span id='topic+summary.tvar'></span><span id='topic+summary.tvplm'></span><span id='topic+summary.tvsure'></span><span id='topic+summary.tvvar'></span><span id='topic+summary.tvirf'></span>

<h3>Description</h3>

<p>Print some results for objects with class attribute <code>tvlm</code>, <code>tvar</code>, <code>tvvar</code>,
<code>tvirf</code>, <code>tvsure</code> and <code>tvplm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvlm'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvar'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvplm'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvsure'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvvar'
summary(object, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'tvirf'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tvlm_+3A_object">object</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="summary.tvlm_+3A_digits">digits</code></td>
<td>
<p>Integer, indicating the minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="summary.tvlm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions print a few results from the time-varying estimated coefficients
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.tvlm">plot.tvlm</a></code>, <code><a href="#topic+plot.tvvar">plot.tvvar</a></code>, <code><a href="#topic+plot.tvvar">plot.tvvar</a></code>,
<code><a href="#topic+plot.tvirf">plot.tvirf</a></code>,<code><a href="#topic+plot.tvsure">plot.tvsure</a></code>
</p>

<hr>
<h2 id='tvAcoef'>Time-Varying Coefficient Arrays of the Lagged Endogenous Variables of a TVVAR (no intercept).</h2><span id='topic+tvAcoef'></span>

<h3>Description</h3>

<p>Returns the estimated coefficients of the lagged endogenous variables as an array.
Given an estimated time varying VAR of the form:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\bold{y}}_t = \hat{A}_{1t} \bold{y}_{t-1} + \ldots + \hat{A}_{pt} \bold{y}_{t-p} + \hat{C}_tD_t</code>
</p>

<p>the function returns a list for each equation with <code class="reqn">\hat{A}_{1t} | \ldots | \hat{A}_{pt} | \hat{C}_t)</code>
set of arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvAcoef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvAcoef_+3A_x">x</code></td>
<td>
<p>An object of class <code>tvvar</code> generated by <code><a href="#topic+tvVAR">tvVAR</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with coefficient arrays for the lagged endogenous variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package="vars")
var.2p &lt;- vars::VAR(Canada, p = 2, type = "const")
tvvar.2p &lt;- tvVAR(Canada, p = 2, type = "const")
A &lt;- vars::Acoef(var.2p)
tvA &lt;- tvAcoef(tvvar.2p)

</code></pre>

<hr>
<h2 id='tvAR'>Time-Varying Autoregressive Model</h2><span id='topic+tvAR'></span><span id='topic+tvar-class'></span><span id='topic+tvar'></span>

<h3>Description</h3>

<p><code>tvAR</code> is used to fit an autorregressive model with time varying coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvAR(
  y,
  p = 1,
  z = NULL,
  ez = NULL,
  bw = NULL,
  cv.block = 0,
  type = c("const", "none"),
  exogen = NULL,
  fixed = NULL,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvAR_+3A_y">y</code></td>
<td>
<p>A vector with the dependent variable.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_p">p</code></td>
<td>
<p>A scalar indicating the number of lags in the model.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_z">z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_bw">bw</code></td>
<td>
<p>An opcional scalar or vector of length the number of equations. It represents
the bandwidth in the estimation of coefficients. If NULL, it is selected
by cross validation.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave one block out cross-validation.
By default 'cv.block=0' meaning leave one out cross-validation.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_type">type</code></td>
<td>
<p>A character 'const' if the model contains an intercept and 'none' otherwise.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_exogen">exogen</code></td>
<td>
<p>A matrix or data.frame with the exogenous variables (optional)</p>
</td></tr>
<tr><td><code id="tvAR_+3A_fixed">fixed</code></td>
<td>
<p>(optional) numeric vector of the same length as the total number of parameters. 
The order of the parameters is intercept (if type = &quot;const&quot;), lags in ascending order and 
exogenous variables. If supplied, only NA entries in fixed will be estimated.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a special case of linear model in which the regressors are lags of the
dependent variable. If any variable is included in the <code>xreg</code> term, these are added 
to the regressors matrix. A time-varying coefficients linear regression (with an
intercept if type = &quot;const&quot;) is fitted.
</p>


<h3>Value</h3>

<p>An object of class <code>tvar</code> with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A vector of dimension obs (obs = number of observations - number lags),
with the time-varying coefficients estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Estimation residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix of model data, with lagged y and exogenous variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector with the dependent data used in the model.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A vector with the smoothing variable in the model.</p>
</td></tr>
<tr><td><code>ez</code></td>
<td>
<p>A vector with the smoothing estimation values.</p>
</td></tr>
<tr><td><code>y.orig</code></td>
<td>
<p>A vector with the original variable y.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>Bandwidth of mean estimation.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Whether the model has a constant or not.</p>
</td></tr>
<tr><td><code>exogen</code></td>
<td>
<p>A matrix or data.frame with other exogenous variables.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Number of observations in estimation.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>Number of observations in the original set.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Confidence interval range.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code>tboot</code></td>
<td>
<p>Type of bootstrap.</p>
</td></tr>
<tr><td><code>BOOT</code></td>
<td>
<p>List with all bootstrap replications of <code>coefficients</code>, if done.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cai, Z. (2007) Trending time-varying coefficient time series with serially
correlated errors, <em>Journal of Econometrics</em>, 136, pp. 163-188.
</p>
<p>Casas, I., Mao, X. and Veiga, H. (2018) Reexamining financial and economic 
predictability with new estimators of realized variance and variance 
risk premium. Url= http://pure.au.dk/portal/files/123066669/rp18_10.pdf
</p>
<p>Chen, X. B., Gao, J., Li, D., and Silvapulle, P (2017) Nonparametric Estimation and 
Forecasting for Time-Varying Coefficient Realized Volatility Models.
<em>Journal of Business and Economic Statistics</em>, 36, 88-100.
</p>
<p>Corsi, F. (2009) A simple approximate long-memory model of realized 
volatility. <em>Journal of Financial Econometrics</em>, 7, 174-196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="#topic+tvLM">tvLM</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Estimate coefficients of different realized variance models
data("RV")
RV2 &lt;- head(RV, 2000)
RV &lt;- RV2$RV
RV_week &lt;- RV2$RV_week
RV_month &lt;- RV2$RV_month
RQ &lt;- RV2$RQ_lag_sqrt
##Corsi (2009) HAR model
HAR &lt;- arima(RV, order = c(1, 0, 0), xreg = cbind (RV_week, RV_month))
print(HAR)

##Chen et al (2017) TVCHAR model 
TVCHAR &lt;- tvAR (RV, p = 1, exogen = cbind (RV_week, RV_month), bw = 20)
print(TVCHAR)

##Casas et al (2018) TVHARQ model
TVHARQ &lt;- tvAR (RV, p = 1, exogen = cbind (RV_week, RV_month), 
z=RQ, bw = 0.0062)
print(TVHARQ)

</code></pre>

<hr>
<h2 id='tvBcoef'>Coefficient Array of an Estimated tvVAR</h2><span id='topic+tvBcoef'></span>

<h3>Description</h3>

<p>Returns the system estimated coefficients as an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvBcoef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvBcoef_+3A_x">x</code></td>
<td>
<p>An object of class 'tvvar', generated by <code><a href="#topic+tvVAR">tvVAR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an estimated time varying VAR of the form:
</p>
<p style="text-align: center;"><code class="reqn">\hat{{y}}_t = \hat{A}_{1t} {y}_{t-1} + \ldots + \hat{A}_{pt} {y}_{t-p} + \hat{C}_tD_t</code>
</p>

<p>the function returns a list for each equation with
<code class="reqn">(\hat{A}_{1t} | \ldots | \hat{A}_{pt} | \hat{C}_t )</code> set of arrays .
</p>


<h3>Value</h3>

<p>A list object with coefficient arrays for the lagged endogenous variables without including the intercept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada, package="vars")
var.2p &lt;- vars::VAR(Canada, p = 2, type = "const")
tvvar.2p &lt;- tvVAR(Canada, p=2, type= "const")
B &lt;- vars::Bcoef(var.2p)
tvB &lt;- tvBcoef(tvvar.2p)
</code></pre>

<hr>
<h2 id='tvCor'>Time-varying Correlation Estimation</h2><span id='topic+tvCor'></span>

<h3>Description</h3>

<p>Estimation of a time-varying/functional coefficients correlation matrix using the local constant or the local linear kernel
smoothing methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvCor(
  x,
  z = NULL,
  ez = NULL,
  bw = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvCor_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_bw">bw</code></td>
<td>
<p>(optional) A scalar.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave-one block-out cross-validation.
By default 'cv.block=0' meaning leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_est">est</code></td>
<td>
<p>A character, either &quot;lc&quot; or &quot;ll&quot; for local constant or local linear.</p>
</td></tr>
<tr><td><code id="tvCor_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight, &quot;Epa&quot; or &quot;Gaussian&quot; kernel functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension obs x neq x neq.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tvCov">tvCov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate two independent (uncorrelated series)
y &lt;- cbind(rnorm(100, sd = 4), rnorm(100, sd = 1))

##Estimation variance-variance matrix. If the bandwidth is unknown, it can
##calculated with function bwCov()
Rho.hat &lt;-  tvCor(y, bw = 1.4)

##The first time estimate
print(Rho.hat[,,1])
##The mean over time of all estimates
print(apply(Rho.hat, 1:2, mean))
##Generate two dependent variables
y &lt;- MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, -0.5), c(-0.5, 4)))

##Estimation variance-variance matrix
Rho.hat &lt;-  tvCor(y, bw = 3.2)
##The first time estimate
print(Rho.hat[,,1])

</code></pre>

<hr>
<h2 id='tvCov'>Time-varying Variance-Covariance Estimation</h2><span id='topic+tvCov'></span>

<h3>Description</h3>

<p>Estimation of a time-varying/funcional coefficients variance-covariance matrix using the local constant or the local linear kernel
smoothing methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvCov(
  x,
  z = NULL,
  ez = NULL,
  bw = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvCov_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_bw">bw</code></td>
<td>
<p>(Optional) A scalar.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave-one block-out cross-validation.
By default 'cv.block=0' meaning leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_est">est</code></td>
<td>
<p>A character, either &quot;lc&quot; or &quot;ll&quot; for local constant or local linear.</p>
</td></tr>
<tr><td><code id="tvCov_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight, &quot;Epa&quot; or &quot;Gaussian&quot; kernel functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension obs x neq x neq.
</p>


<h3>References</h3>

<p>Aslanidis, N. and Casas, I (2013) Nonparametric correlation models for portfolio
allocation. <em>Journal of Banking and Finance</em>, 37, 2268-2283
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bwCov">bwCov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate two independent (uncorrelated series)
y &lt;- cbind(rnorm(100, sd = 4), rnorm(100, sd = 1))

##Estimation variance-variance matrix. If the bandwidth is unknown, it can
##calculated with function bwCov()
Sigma.hat &lt;-  tvCov(y, bw = 1.4)

##The first time estimate
print(Sigma.hat[,,1])
##The mean over time of all estimates
print(apply(Sigma.hat, 1:2, mean))
##Generate two dependent variables
y &lt;- MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, -0.5), c(-0.5, 4)))

##Estimation variance-variance matrix
Sigma.hat &lt;-  tvCov(y, bw = 3.2)
##The first time estimate
print(Sigma.hat[,,1])

</code></pre>

<hr>
<h2 id='tvFE'>Time-Varying Fixed Effects Estimation</h2><span id='topic+tvFE'></span><span id='topic+tvFE.matrix'></span><span id='topic+tvFE.tvplm'></span>

<h3>Description</h3>

<p><code>tvFE</code> estimate time-varying coefficient of fixed effects 
panel data models using kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvFE(x, ...)

## S3 method for class 'matrix'
tvFE(
  x,
  y,
  z = NULL,
  ez = NULL,
  bw,
  neq,
  obs,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  ...
)

## S3 method for class 'tvplm'
tvFE(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvFE_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_y">y</code></td>
<td>
<p>A vector with dependent variable.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_bw">bw</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_neq">neq</code></td>
<td>
<p>A sclar with the number of equations</p>
</td></tr>
<tr><td><code id="tvFE_+3A_obs">obs</code></td>
<td>
<p>A scalar with the number of time observations</p>
</td></tr>
<tr><td><code id="tvFE_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvFE_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvFE</code> returns a list containing:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A vector of length obs, number of observations with
the time-varying estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>A vector of length obs with the fited values from the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A vector of length obs with the residuals from the estimation.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>A vector of length neq with the fixed effects.</p>
</td></tr>
</table>

<hr>
<h2 id='tvGLS'>Time-Varying Generalised Least Squares</h2><span id='topic+tvGLS'></span><span id='topic+tvGLS.list'></span><span id='topic+tvGLS.matrix'></span><span id='topic+tvGLS.tvsure'></span>

<h3>Description</h3>

<p><code>tvGLS</code> estimates time-varying coefficients of SURE using the kernel smoothing GLS.
</p>
<p><code>tvGLS</code> is used to estimate time-varying coefficients SURE using the kernel smoothing
generalised least square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvGLS(x, ...)

## S3 method for class 'list'
tvGLS(
  x,
  y,
  z = NULL,
  ez = NULL,
  bw,
  Sigma = NULL,
  R = NULL,
  r = NULL,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  ...
)

## S3 method for class 'matrix'
tvGLS(
  x,
  y,
  z = NULL,
  ez = NULL,
  bw,
  Sigma = NULL,
  R = NULL,
  r = NULL,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  ...
)

## S3 method for class 'tvsure'
tvGLS(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvGLS_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_y">y</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_z">z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_bw">bw</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_sigma">Sigma</code></td>
<td>
<p>An array.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_r">R</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_r">r</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvGLS_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical GLS estimator must be modified to generate a set of coefficients changing over time.
The <code>tvGLS</code> finds a GLS estimate at a given point in time <em>t</em> using the data near by.
The size of the data window used is given by the bandwidth. The closest a point is to <em>t</em>,
the larger is its effect on the estimation which is given by the kernel. In this programme,
the three possible kernels are the Triweight, Epanechnikov and Gaussian. As in the classical GLS, the covariance
matrix is involved in the estimation formula. If this matrix is NULL or the identity, then the
program returns the OLS estimates for time-varying coefficients.
</p>
<p>Note, that unless with the tvSURE, the tvGLS may run with one common bandwidth for all
equations or with a different bandwidths for each equation.
</p>


<h3>Value</h3>

<p><code>tvGLS</code> returns a list containing:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>An array of dimension obs x nvar x neq (obs = number of observations, nvar = number of variables
in each equation, neq = number of equations in the system) with the time-varying coefficients estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>A matrix of dimension obs x neq with the fitted values from the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix of dimension obs x neq with the residuals from the estimation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(FF5F)
x &lt;- list()
## SMALL/LoBM porfolios time-varying three factor model
x[[1]] &lt;- cbind(rep (1, 314), FF5F[, c("NA.Mkt.RF", "NA.SMB",  "NA.HML", "NA.RMW", "NA.CMA")])
x[[2]] &lt;- cbind(rep (1, 314), FF5F[, c("JP.Mkt.RF", "JP.SMB",  "JP.HML", "JP.RMW", "JP.CMA")])
x[[3]] &lt;- cbind(rep (1, 314), FF5F[, c("AP.Mkt.RF", "AP.SMB",  "AP.HML", "AP.RMW", "AP.CMA")])
x[[4]] &lt;- cbind(rep (1, 314), FF5F[, c("EU.Mkt.RF", "EU.SMB",  "EU.HML", "EU.RMW", "EU.CMA")])
##Returns
y &lt;- cbind(FF5F$NA.SMALL.LoBM, FF5F$JP.SMALL.LoBM, FF5F$AP.SMALL.LoBM, 
FF5F$EU.SMALL.LoBM) 
##Excess returns
y &lt;- y - cbind(FF5F$NA.RF, FF5F$JP.RF, FF5F$AP.RF, FF5F$EU.RF)
##I fit the data with one bandwidth for each equation
FF5F.fit &lt;- tvGLS(x = x, y = y, bw = c(1.03, 0.44, 0.69, 0.31))

</code></pre>

<hr>
<h2 id='tvIRF'>Time-Varying Impulse Response Function</h2><span id='topic+tvIRF'></span><span id='topic+tvirf-class'></span><span id='topic+tvirf.'></span>

<h3>Description</h3>

<p>Computes the time-varying impulse response coefficients of an object 
of class <code>tvvar</code>,  obtained with function <code>tvVAR</code> for <code>n.ahead</code> steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvIRF(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  ortho.cov = c("tv", "const"),
  bw.cov = NULL,
  cumulative = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvIRF_+3A_x">x</code></td>
<td>
<p>An object of class <code>tvvar</code>.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_impulse">impulse</code></td>
<td>
<p>A character vector of the impulses, default is all variables.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_response">response</code></td>
<td>
<p>A character vector of the responses, default is all variables.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_ortho">ortho</code></td>
<td>
<p>Logical, if TRUE (the default) the orthogonalised IRF is computed.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_ortho.cov">ortho.cov</code></td>
<td>
<p>A character indicating if the covariance matrix for the 
orthogonal tvIRF should be estimated as a constant or time varying. Either 
'const' or 'tv' (default). This parameter is used only when ortho = TRUE.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_bw.cov">bw.cov</code></td>
<td>
<p>A scalar (optional) with the bandwidth to estimate the errors
variance-covariance matrix. If left NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulated impulse response 
coefficients are computed. Default is FALSE.</p>
</td></tr>
<tr><td><code id="tvIRF_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvIRF</code> returns and object of class <code>tvirf</code> with the 
following components:
</p>
<table>
<tr><td><code>irf</code></td>
<td>
<p>A list of length the number of impulse variable(s). Each element
of the list is an array of dim = c(obs x number 
of response variables x n.ahead).</p>
</td></tr>
<tr><td><code>Lower</code></td>
<td>
<p>A list of length the number of impulse variable(s), containing
the lower confidence line, if calculated.</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>A list of length the number of impulse variable(s), containing
the upper confidence line, if calculated.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>A character, a number of a vector with the names or 
positions of the response(s) variable(s).</p>
</td></tr>
<tr><td><code>impulse</code></td>
<td>
<p>A character, a number of a vector with the names or 
positions of the impulse(s) variable(s).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A object of class <code>tvvar</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>n.ahead</code></td>
<td>
<p>Number of ahead impulse response functions.</p>
</td></tr>
<tr><td><code>ortho</code></td>
<td>
<p>Logical, orthogonal or not impuluse response function.</p>
</td></tr>
<tr><td><code>ortho.cov</code></td>
<td>
<p>Character, either 'const' or 'tv' (default). This 
parameter is used when the orthogonal TVIRF is calculated. The default 
is using an error time-varying variance-covariance.</p>
</td></tr>
<tr><td><code>bw.cov</code></td>
<td>
<p>A scalar with the bandwidth to estimate the errors 
variance-covariance matrix. If NULL, it is calculated by cross-validation.</p>
</td></tr>
<tr><td><code>cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulated impulse response 
coefficients are computed. Default is FALSE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="#topic+tvVAR">tvVAR</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Inflation rate, unemployment rate and treasury bill 
##interest rate for the US as in Primiceri (2005). 
data(usmacro, package = "bvarsv")
TVVAR &lt;- tvVAR(usmacro, p = 4, type = "const")

##Estimate a the tvIRF with time-varying covariance function
TVIRF &lt;- tvIRF(TVVAR)

##Cumulative impulse response function
TVIRF2 &lt;- tvIRF(TVVAR, cumulative = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='tvLM'>Time-Varying Coefficients Linear Models</h2><span id='topic+tvLM'></span><span id='topic+tvlm-class'></span><span id='topic+tvlm'></span>

<h3>Description</h3>

<p><code>tvLM</code> is used to fit a time-varying coefficients linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvLM(
  formula,
  z = NULL,
  ez = NULL,
  data,
  bw = NULL,
  cv.block = 0,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvLM_+3A_formula">formula</code></td>
<td>
<p>An object of class formula.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_z">z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_data">data</code></td>
<td>
<p>An optional data frame or matrix.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_bw">bw</code></td>
<td>
<p>An opcional scalar. It represents the bandwidth in
the estimation of trend coefficients. If NULL, it is selected by cross validation.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave one block out cross-validation.
By default 'cv.block=0' meaning leave one out cross-validation.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvLM_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>tvLM</code> are specified symbolically using the same formula
format than function <code>lm</code>. A typical model has the form <em>response</em> ~ <em>terms</em>
where response is the (numeric) response vector and terms is a series of terms which
specifies a linear predictor for response. A terms specification of the form
first + second indicates all the terms in first together with all the terms
in second with duplicates removed. A specification of the form first:second indicates
the set of terms obtained by taking the interactions of all terms in first with all
terms in second. The specification first*second indicates the cross of first and second.
This is the same as first + second + first:second.
</p>
<p>A formula has an implied intercept term. To remove this use either
y ~ x - 1 or y ~ 0 + x.
</p>


<h3>Value</h3>

<p>An object of class <code>tvlm</code>
The object of class <code>tvlm</code> have the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A matrix of dimensions</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Estimation residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix with the regressors data.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector with the dependent variable data.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code>ez</code></td>
<td>
<p>A vector with the smoothing estimation variable.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>Bandwidth of mean estimation.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Nonparametric estimation methodology.</p>
</td></tr>
<tr><td><code>tkernel</code></td>
<td>
<p>Kernel used in estimation.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Confidence interval range.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code>tboot</code></td>
<td>
<p>Type of bootstrap.</p>
</td></tr>
<tr><td><code>BOOT</code></td>
<td>
<p>List with all bootstrap replications of <code>coefficients</code>, if done.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bollerslev, T., Patton, A. J. and Quaedvlieg, R. (2016) Exploiting the 
errors: A simple approach for improved volatility forecasting. 
<em>Journal of Econometrics</em>, 192, 1-18.
</p>
<p>Casas, I., Mao, X. and Veiga, H. (2018) Reexamining financial and economic 
predictability with new estimators of realized variance and variance 
risk premium. Url= http://pure.au.dk/portal/files/123066669/rp18_10.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="#topic+tvAR">tvAR</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a linear process with time-varying coefficient
## as functions of scaled time.
set.seed(42)
tau &lt;- seq(1:200)/200
beta &lt;- data.frame(beta1 = sin(2*pi*tau), beta2= 2*tau)
X1 &lt;- rnorm(200)
X2 &lt;- rchisq(200, df = 4)
error &lt;- rt(200, df = 10)
y &lt;- apply(cbind(X1, X2)*beta, 1, sum) + error
data &lt;- data.frame(y = y, X1 = X1, X2 = X2)
## Estimate coefficients with lm and tvLM for comparison

coef.lm &lt;- stats::lm(y ~ 0 + X1 + X2, data = data)$coef
tvlm.fit &lt;- tvLM(y ~ 0 + X1 + X2, data = data, bw = 0.29)

## Estimate coefficients of different realized variance models
data("RV")
RV2 &lt;- head(RV, 2000)
##Bollerslev t al. (2016) HARQ model
HARQ &lt;- with(RV2, lm(RV ~ RV_lag + I(RV_lag * RQ_lag_sqrt) + RV_week + RV_month))

#Casas et al. (2018) TVHARQ model
TVHARQ &lt;- with(RV2, tvLM (RV ~ RV_lag + RV_week + RV_month, z = RQ_lag_sqrt, 
                         bw = 0.0061))
boxplot(data.frame(TVHARQ = TVHARQ$coefficients[,2] * RV2$RV_lag,
                   HARQ = (HARQ$coef[2] + HARQ$coef[3] * RV2$RQ_lag_sqrt)*RV2$RV_lag),
                   main = expression (RV[t-1]), outline = FALSE)
                 
</code></pre>

<hr>
<h2 id='tvOLS'>Time-Varying Ordinary Least Squares</h2><span id='topic+tvOLS'></span><span id='topic+tvOLS.matrix'></span><span id='topic+tvOLS.tvlm'></span><span id='topic+tvOLS.tvar'></span><span id='topic+tvOLS.tvvar'></span>

<h3>Description</h3>

<p><code>tvOLS</code> estimate time-varying coefficient of univariate 
linear models using the kernel smoothing OLS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvOLS(x, ...)

## S3 method for class 'matrix'
tvOLS(
  x,
  y,
  z = NULL,
  ez = NULL,
  bw,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE,
  ...
)

## S3 method for class 'tvlm'
tvOLS(x, ...)

## S3 method for class 'tvar'
tvOLS(x, ...)

## S3 method for class 'tvvar'
tvOLS(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvOLS_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_y">y</code></td>
<td>
<p>A vector with dependent variable.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_bw">bw</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvOLS_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvOLS</code> returns a list containing:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A vector of length obs, number of observations time observations.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>A vector of length obs with the fitted values from the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A vector of length obs with the residuals from the estimation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code> for bandwidth selection, <code><a href="#topic+tvLM">tvLM</a></code> and
<code><a href="#topic+tvAR">tvAR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- seq(1:500)/500
beta &lt;- data.frame(beta1 = sin(2*pi*tau), beta2 = 2*tau)
X &lt;- data.frame(X1 = rnorm(500), X2 = rchisq(500, df = 4))
error &lt;- rt(500, df = 10)
y &lt;- apply(X*beta, 1, sum) + error
coef.lm &lt;- stats::lm(y~0+X1+X2, data = X)$coef
coef.tvlm &lt;-  tvOLS(x = as.matrix(X), y = y, bw = 0.1)$coefficients
plot(tau, beta[, 1], type="l", main="", ylab = expression(beta[1]), xlab = expression(tau),
ylim = range(beta[,1], coef.tvlm[, 1]))
abline(h = coef.lm[1], col = 2)
lines(tau, coef.tvlm[, 1], col = 4)
legend("topright", c(expression(beta[1]), "lm", "tvlm"), col = c(1, 2, 4), bty="n", lty = 1)

</code></pre>

<hr>
<h2 id='tvPhi'>Time-Varying Coefficient Arrays of the MA Represention</h2><span id='topic+tvPhi'></span>

<h3>Description</h3>

<p>Returns the estimated time-varying coefficient arrays of the moving average representation
of a stable <code>tvvar</code> object obtained with function <code>tvVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvPhi(x, nstep = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvPhi_+3A_x">x</code></td>
<td>
<p>An object of class <code>tvvar</code>.</p>
</td></tr>
<tr><td><code id="tvPhi_+3A_nstep">nstep</code></td>
<td>
<p>An integer specifying the number of moving error coefficient matrices to be calculated.</p>
</td></tr>
<tr><td><code id="tvPhi_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>

<hr>
<h2 id='tvPLM'>Time-Varying Coefficients Panel Data Models</h2><span id='topic+tvPLM'></span><span id='topic+tvplm-class'></span><span id='topic+tvplm'></span>

<h3>Description</h3>

<p>Fits a balanced panel data model using the Time-Varying Pooled Ordinary Least 
Squares, the Time-Varying Random Effects and the Time-Varying Fixed Effects models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvPLM(
  formula,
  z = NULL,
  ez = NULL,
  data,
  index = NULL,
  bw = NULL,
  bw.cov = NULL,
  cv.block = 0,
  method = c("pooling", "random", "within"),
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  control = tvreg.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvPLM_+3A_formula">formula</code></td>
<td>
<p>An object of class formula.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_z">z</code></td>
<td>
<p>A vector containing the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_data">data</code></td>
<td>
<p>An optional data frame or matrix.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_index">index</code></td>
<td>
<p>Indicates the individual and time indexes.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_bw">bw</code></td>
<td>
<p>An opcional scalar. It represents the bandwidth in
the estimation of trend coefficients. If NULL, it is selected by cross validation.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_bw.cov">bw.cov</code></td>
<td>
<p>An optional scalar. It represents the bandwidth in the &quot;lc&quot; nonparametric estimation of the
time-varying covariance matrix. If NULL, it is selected by cross validation for method <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave one block out cross-validation.
By default 'cv.block=0' meaning leave one out cross-validation.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_method">method</code></td>
<td>
<p>A character with the choice of panel model/estimation method:
If <code>method = "pooling"</code> (default) then the data is pooled estimated with time-varying OLS. 
No individual or time effects are estimated
If <code>method = "random"</code> then individual effects are considered random and independent
of the regressors.
If <code>method = "within"</code> then individual effects which might be correlated with 
the regressors are estimated.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_control">control</code></td>
<td>
<p>list of control parameters.  The default is constructed by
the function <code><a href="#topic+tvreg.control">tvreg.control</a></code>.  See the documentation of
<code><a href="#topic+tvreg.control">tvreg.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="tvPLM_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps up the kernel smoothing time-varying coefficient pooled, random effects
and fixed effects estimators. 
</p>
<p>Bandwidth selection is of great importance in kernel smoothing methodologies and it is done
automatically by cross-validation. 
</p>
<p>A panel data model consists of &quot;neq&quot; elements in the cross-sectional dimention and
&quot;obs&quot; number of time observations for each cross-section. All variables are
the same for each equation which have common coefficients.
</p>


<h3>Value</h3>

<p><code>tvPLM</code> returns a list of the class <code>tvplm</code> containing the results of model, results of the estimation
and confidence instervals if chosen.
The object of class <code>tvplm</code> have the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>An array of dimension obs x nvar x neq (obs = number of observations, nvar = number of variables
in each equation, neq = number of equations in the system) with the time-varying coefficients estimates.</p>
</td></tr>
<tr><td><code>Lower</code></td>
<td>
<p>If <code>level</code> non equal zero, an array of dimension obs x nvar x neq containing the confidence 
interval lower band.</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>If <code>level</code> non equal zero, an array of dimension obs x nvar x neq containing the confidence 
interval upper band.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Estimation residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A list with the regressors data.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A matrix with the dependent variable data.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code>ez</code></td>
<td>
<p>A vector with the smoothing estimation values.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>A vector with the individual fixed effects, if chosen.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>Bandwidth of mean estimation.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>Integer specifying the total number of observations.</p>
</td></tr>
<tr><td><code>neq</code></td>
<td>
<p>Integer specifying the number of cross-section observations.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Integer specifying the number of time observations per cross-section.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Estimation method.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Nonparemtric estimation methodology.</p>
</td></tr>
<tr><td><code>tkernel</code></td>
<td>
<p>Kernel type.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Confidence interval range.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code>tboot</code></td>
<td>
<p>Type of bootstrap.</p>
</td></tr>
<tr><td><code>BOOT</code></td>
<td>
<p>List with all bootstrap replications of <code>coefficients</code>, if done.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Initial formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Casas, I., Gao, J., Peng, B. and Xie, S. (2021). Time-Varying Income Elasticities 
of Healthcare Expenditure for the OECD and Eurozone. 
<em>Journal of Applied Econometrics, 36, pp. 328-345</em>. 
</p>
<p>Sun, Y., Carrol, R.J and Li, D. (2009). Semiparametric Estimation of Fixed-Effects Panel Data 
Varying Coefficient Models. <em>Advances in Econometrics</em>, 25, pp. 101-129.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OECD)
##TVPOLS estimation of the model
tvpols &lt;- tvPLM(lhe~lgdp+pop65+pop14+public, index = c("country", "year"),
 data = OECD, method ="pooling", bw = 0.3)
## Not run: 
tvfe &lt;- tvPLM(lhe~lgdp+pop65+pop14+public, index = c("country", "year"),
 data = OECD, method ="within", bw = 0.8)
tvre &lt;- tvPLM(lhe~lgdp+pop65+pop14+public, index = c("country", "year"),
 data = OECD, method ="random", bw = 0.3)

## End(Not run)
</code></pre>

<hr>
<h2 id='tvPsi'>Time-Varying Coefficient Arrays of the Orthogonalised MA Represention</h2><span id='topic+tvPsi'></span>

<h3>Description</h3>

<p>Returns the estimated orthogonalised time-varying coefficient arrays of the
moving average representation of a stable <code>tvvar</code> object obtained with function <code>tvVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvPsi(x, nstep = 10, ortho.cov = "const", bw.cov = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvPsi_+3A_x">x</code></td>
<td>
<p>An object of class <code>tvvar</code>, generated by tvVAR().</p>
</td></tr>
<tr><td><code id="tvPsi_+3A_nstep">nstep</code></td>
<td>
<p>An integer specifying the number of othogonalised moving error coefficient
matrices to be calculated for each time t.</p>
</td></tr>
<tr><td><code id="tvPsi_+3A_ortho.cov">ortho.cov</code></td>
<td>
<p>A character either 'const' if the error cov matrix must be estimated by a constant
or 'tv' if it is estimated as a time-varying matrix. Default is 'const'.</p>
</td></tr>
<tr><td><code id="tvPsi_+3A_bw.cov">bw.cov</code></td>
<td>
<p>A scalar (optional) with the bandwidth to estimate the errors variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="tvPsi_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an array of dimensions (obs x neq x neq nstep + 1) holding the estimated
time varying coefficients of the moving average representation, and the bandwidth used to estimate
the covariance matrix (optional).
</p>

<hr>
<h2 id='tvRE'>Time-Varying Random Effects Estimation</h2><span id='topic+tvRE'></span><span id='topic+tvRE.matrix'></span><span id='topic+tvRE.tvplm'></span>

<h3>Description</h3>

<p><code>tvRE</code> estimate time-varying coefficient of a random effects 
panel data model using kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvRE(x, ...)

## S3 method for class 'matrix'
tvRE(
  x,
  y,
  z = NULL,
  ez = NULL,
  bw,
  Sigma = NULL,
  neq,
  obs,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  ...
)

## S3 method for class 'tvplm'
tvRE(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvRE_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_y">y</code></td>
<td>
<p>A vector with dependent variable.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_z">z</code></td>
<td>
<p>A vector with the variable over which coefficients are smooth over.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_bw">bw</code></td>
<td>
<p>A numeric vector with the bandwidth.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_sigma">Sigma</code></td>
<td>
<p>NULL (default) or a matrix of size obs x obs..</p>
</td></tr>
<tr><td><code id="tvRE_+3A_neq">neq</code></td>
<td>
<p>A scalar with the number of equations</p>
</td></tr>
<tr><td><code id="tvRE_+3A_obs">obs</code></td>
<td>
<p>A scalar with the number of time observations</p>
</td></tr>
<tr><td><code id="tvRE_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant
or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvRE_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tvRE</code> returns a list containing:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A vector of length obs, number of observations with
the time-varying estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>A vector of length obs with the fited values from the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A vector of length obs with the residuals from the estimation.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>A vector of length neq with the fixed effects.</p>
</td></tr>
</table>

<hr>
<h2 id='tvSURE'>Time-Varying Seemingly Unrelated Regression Equations Model</h2><span id='topic+tvSURE'></span><span id='topic+tvsure-class'></span><span id='topic+tvsure'></span>

<h3>Description</h3>

<p>Fits a set of balanced linear structural equations using Time-varying Ordinary Least 
Squares (tvOLS), Time-varying Seemingly Unrelated Regression (tvGLS), when the error 
variance-covariance matrix is known, or Time-varying Feasible Seemingly Unrelated 
Regression (tvFGLS), when the error variance-covariance matrix is unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvSURE(
  formula,
  z = NULL,
  ez = NULL,
  bw = NULL,
  cv.block = 0,
  data,
  method = c("tvOLS", "tvFGLS", "tvGLS"),
  Sigma = NULL,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  bw.cov = NULL,
  singular.ok = TRUE,
  R = NULL,
  r = NULL,
  control = tvreg.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvSURE_+3A_formula">formula</code></td>
<td>
<p>A list of formulas, one for each equation.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_z">z</code></td>
<td>
<p>A vector containing the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_bw">bw</code></td>
<td>
<p>An optional scalar or vector of length the number of equations. It represents the bandwidth in
the estimation of trend coefficients. If NULL, it is selected by cross validation.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave one block out cross-validation.
By default 'cv.block = 0' meaning leave one out cross-validation.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing variables in the formula.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_method">method</code></td>
<td>
<p>A character, a matrix of dimensions neq x neq or an array of dimensions obs x neq x neq, where
<code>obs</code> is the number of observations and <code>neq</code> is the number of equations.
If method = <code>identity</code> or <code>tvOLS</code> (default) then the method used is a time-varying OLS.
If method is a matrix (constant over time) or an array, then the <code>tvGLS</code> is called.
If method = <code>tvFGLS</code>, then the covariance matrix is estimated nonparametrically and the
estimation of the system is done as a whole.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_sigma">Sigma</code></td>
<td>
<p>A matrix of dimensions neq x neq or an array of dimensions neq x neq x obs
(neq = number of equations, obs = number of observations). It represents
the covariance matrix of the error term. Only necessary for method <code>tvGLS</code>.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_bw.cov">bw.cov</code></td>
<td>
<p>An optional scalar. It represents the bandwidth in the nonparametric estimation of the
varying covariance matrix. If NULL, it is selected by cross validation.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_r">R</code></td>
<td>
<p>An optional nrest x nvar x neq (nrest =  number of restrictions, nvar = number of variables in each equation,
neq = number of equations).</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_r">r</code></td>
<td>
<p>An optional vector of length the number of restrictions. By default it contains zeros.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_control">control</code></td>
<td>
<p>list of control parameters.  The default is constructed by
the function <code><a href="#topic+tvreg.control">tvreg.control</a></code>.  See the documentation of
<code><a href="#topic+tvreg.control">tvreg.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="tvSURE_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps up the kernel smoothing &quot;tvOLS&quot; and &quot;tvGLS&quot; estimators. The former is used when
equations are considered independent while the later assumes that the error term is correlated
amongst equations. This relation is given in matrix &quot;Sigma&quot; which is used in the estimation. When
&quot;Sigma&quot; is known, the estimates are calculated via the &quot;tvGLS&quot;, and via the &quot;tvFGLS&quot; when &quot;Sigma&quot;
is unknown and must be estimated.
</p>
<p>Bandwidth selection is of great importance in kernel smoothing methodologies and it is done
automatically by cross-validation. One important aspect in the current packages is that the
bandwidth is selected independently for each equation and then the average is taken to use the
same bandwidth for each equation. It has been shown in Casas et al. (2017) that using
different bandwidths for each equation is in general a bad practice, even for uncorrelated equations.
Even though, the user may be able to use different bandwidths calling functions <code><a href="#topic+bw">bw</a></code> and
<code><a href="#topic+tvGLS">tvGLS</a></code> separatedly.
</p>
<p>A system consists of &quot;neq&quot; number of equations with &quot;obs&quot; number of observations each and a number of
variables not necessarily equal for all equations. The matrix notation is:
</p>
<p style="text-align: center;"><code class="reqn">Y_{t} = X_t \beta_{t}+u_{t}</code>
</p>

<p>where <code class="reqn">Y_t  = (y_{1t}, y_{2t}, \ldots, y_{neq t})'</code>, <code class="reqn">X_t = diag (x_{1t}, x_{2t}, \ldots, x_{neq t})</code>
and <code class="reqn">\beta_{t} = \left(\beta _{1t}', \ldots, \beta _{neq t}'\right)'</code> is a vector of order the
total number of variables in the system. The error vector <code class="reqn">u_{t} = (u_{1t}, u_{2t}, \ldots, u_{neq t})'</code>
has zero mean and  covariance matrix <code class="reqn">E(u_t u_t') = \Sigma_t</code>.
</p>


<h3>Value</h3>

<p><code>tvSURE</code> returns a list of the class <code>tvsure</code> containing the results of the whole system, results of the estimation
and confidence instervals if chosen.
The object of class <code>tvsure</code> have the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>An array of dimension obs x nvar x neq (obs = number of observations, nvar = number of variables
in each equation, neq = number of equations in the system) with the time-varying coefficients estimates.</p>
</td></tr>
<tr><td><code>Lower</code></td>
<td>
<p>If <code>level</code> non equal zero, an array of dimension obs x nvar x neq containing the confidence 
interval lower band.</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>If <code>level</code> non equal zero, an array of dimension obs x nvar x neq containing the confidence 
interval upper band.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>An array of dimension obs x neq x neq with the estimates of the errors covariance matrix.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Estimation residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A list with the regressors data.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A matrix with the dependent variable data.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code>ez</code></td>
<td>
<p>A vector with the smoothing estimation values.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>Bandwidth of mean estimation.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Integer specifying the number of observations in each equation (balanced sample).</p>
</td></tr>
<tr><td><code>neq</code></td>
<td>
<p>Integer specifying the number of equations.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>Vector of integers specifying the number of variables in each equation.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Estimation method.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Nonparemtric estimation methodology.</p>
</td></tr>
<tr><td><code>tkernel</code></td>
<td>
<p>Kernel type.</p>
</td></tr>
<tr><td><code>bw.cov</code></td>
<td>
<p>Bandwidht of Sigma estimation.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Confidence interval range.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code>tboot</code></td>
<td>
<p>Type of bootstrap.</p>
</td></tr>
<tr><td><code>BOOT</code></td>
<td>
<p>List with all bootstrap replications of <code>coefficients</code>, if done.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Restrictions matrix.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Restrictions vector.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Initial formula.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Casas, I., Ferreira, E., and Orbe, S. (2017) Time-Varying Coefficient Estimation 
in SURE Models: Application to Portfolio Management. Available at SSRN: 
https://ssrn.com/abstract=3043137
</p>
<p>Chen, X. B., Gao, J., Li, D., and Silvapulle, P (2017) Nonparametric Estimation and 
Forecasting for Time-Varying Coefficient Realized Volatility Models.
<em>Journal of Business and Economic Statistics</em>, pp.1-13
</p>
<p>Granger, C. W (2008) Non-Linear Models: Where Do We Go Next - Time Varying
Parameter Models? <em>Studies in Nonlinear Dynamics and Econometrics</em>, 12, pp. 1-11.
</p>
<p>Kristensen, D (2012) Non-parametric detection and estimation of structural change.
<em>Econometrics Journal</em>, 15, pp. 420-461.
</p>
<p>Orbe, S., Ferreira, E., and Rodriguez-Poo, J (2004) On the estimation and testing of
time varying constraints in econometric models, <em>Statistica Sinica</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="#topic+tvCov">tvCov</a></code>,  <code><a href="#topic+tvVAR">tvVAR</a></code>, 
<code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("Kmenta", package = "systemfit")
eqDemand &lt;- consump ~ price + income
eqSupply &lt;- consump ~ price + farmPrice + trend
system &lt;- list(demand = eqDemand, supply = eqSupply)
eqSupply2 &lt;- consump ~  price + farmPrice 
system2 &lt;- list(demand = eqDemand, supply = eqSupply2)

##OLS estimation of a system
OLS &lt;- systemfit::systemfit(system, method = "OLS", data = Kmenta)
##tvOLS estimation of a system with the local linear estimator
##removing trend because it is included in the intercept changing over time
TVOLS &lt;- tvSURE(system2, data = Kmenta,  est = "ll")

##SUR/FGLS estimation
FGLS &lt;- systemfit::systemfit(system, data = Kmenta, method = "SUR")
##tvSURE estimation
TVFGLS &lt;- tvSURE(system, data = Kmenta, method = "tvFGLS")

## End(Not run)

</code></pre>

<hr>
<h2 id='tvVAR'>Time-varying Vector Autoregressive Models</h2><span id='topic+tvVAR'></span><span id='topic+tvvar-class'></span><span id='topic+tvvar'></span>

<h3>Description</h3>

<p>Fits a time-varying coefficients vector autorregressive model with p lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvVAR(
  y,
  p = 1,
  z = NULL,
  ez = NULL,
  bw = NULL,
  cv.block = 0,
  type = c("const", "none"),
  exogen = NULL,
  est = c("lc", "ll"),
  tkernel = c("Triweight", "Epa", "Gaussian"),
  singular.ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvVAR_+3A_y">y</code></td>
<td>
<p>A matrix with dimention obs x neq (obs = number of observations and
neq = number of equations)</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_p">p</code></td>
<td>
<p>A scalar indicating the number of lags in the model</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_z">z</code></td>
<td>
<p>A vector containing the smoothing variable.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_ez">ez</code></td>
<td>
<p>(optional) A scalar or vector with the smoothing values. If 
values are not included then the vector <code>z</code> is used instead.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_bw">bw</code></td>
<td>
<p>An optional scalar or vector of length the number of equations. It represents the bandwidth in
the estimation of trend coefficients. If NULL, it is selected by cross validation.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_cv.block">cv.block</code></td>
<td>
<p>A positive scalar with the size of the block in leave one block out cross-validation.
By default 'cv.block = 0' meaning leave one out cross-validation.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_type">type</code></td>
<td>
<p>A character 'const' if the model contains an intercept and 'none' otherwise.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_exogen">exogen</code></td>
<td>
<p>A matrix or data.frame with the exogenous variables (optional)</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_est">est</code></td>
<td>
<p>The nonparametric estimation method, one of &quot;lc&quot; (default) for linear constant or &quot;ll&quot; for local linear.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_tkernel">tkernel</code></td>
<td>
<p>A character, either &quot;Triweight&quot; (default), &quot;Epa&quot; or &quot;Gaussian&quot; kernel function.</p>
</td></tr>
<tr><td><code id="tvVAR_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical. If FALSE, a singular model is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'tvvar'
The object of class <code>tvvar</code> have the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>An array of dimension obs x neq (obs = number of observations,
neq = number of equations in the system) with the time-varying coefficients estimates.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Estimation residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A list with the regressors data and the dependent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A matrix with the dependent variable data.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A vector with the smoothing variable.</p>
</td></tr>
<tr><td><code>ez</code></td>
<td>
<p>A vector with the smoothing estimation values.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>Bandwidth of mean estimation.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Whether the model has a constant or not.</p>
</td></tr>
<tr><td><code>exogen</code></td>
<td>
<p>A matrix or data.frame with other exogenous variables.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code>neq</code></td>
<td>
<p>Number of equations</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Number of observations in estimation.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>Number of observations in the original set.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Casas, I., Ferreira, E., and Orbe, S. (2017) Time-Varying Coefficient Estimation 
in SURE Models: Application to Portfolio Management. Available at SSRN: 
https://ssrn.com/abstract=3043137
</p>
<p>Primiceri, G.E. (2005) Time varying structural vector autoregressions 
and monetary policy. <em>Review of Economic Studies</em>, 72, 821-852.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw">bw</a></code>, <code><a href="#topic+tvIRF">tvIRF</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Inflation rate, unemployment rate and treasury bill interest rate for 
##the US, as used in Primiceri (2005).
data(usmacro, package = "bvarsv")
VAR.fit &lt;- vars::VAR(usmacro, p = 6, type = "const")
tvVAR.fit &lt;- tvVAR(usmacro, p = 6, type = "const", bw = c(1.8, 20, 20))
plot(tvVAR.fit)

</code></pre>

<hr>
<h2 id='update.tvlm'>Update and Re-fit the Models of package tvReg</h2><span id='topic+update.tvlm'></span><span id='topic+update.tvar'></span><span id='topic+update.tvvar'></span><span id='topic+update.tvsure'></span><span id='topic+update.tvplm'></span>

<h3>Description</h3>

<p>Update and Re-fit the Models of package tvReg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tvlm'
update(object, ...)

## S3 method for class 'tvar'
update(object, ...)

## S3 method for class 'tvvar'
update(object, ...)

## S3 method for class 'tvsure'
update(object, ...)

## S3 method for class 'tvplm'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.tvlm_+3A_object">object</code></td>
<td>
<p>An object of any class in package tvReg.</p>
</td></tr>
<tr><td><code id="update.tvlm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class than the argument *object*.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
