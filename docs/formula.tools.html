<!DOCTYPE html><html><head><title>Help for package formula.tools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {formula.tools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.invert.single'><p>Invert multiple elements of a multiple element object</p></a></li>
<li><a href='#as.character.formula'><p>Converts a formula to character</p></a></li>
<li><a href='#env'><p>Get the environment</p></a></li>
<li><a href='#formula.parts'><p>Manipulate the component parts of formulas, expressions, calls, name/symbols</p>
and list and vectors of such objects.</a></li>
<li><a href='#get.vars'><p>Get variable (names) from various R objects</p></a></li>
<li><a href='#invert'><p>invert</p></a></li>
<li><a href='#is.one.sided'><p>Determine if an object is one- or two-sided.</p>
</p>
<p>Test whether a object (typically formula, call or expression) is one- (e.g.</p>
<code>~x</code>) or two-sided (e.g. <code>x~y</code>).</a></li>
<li><a href='#op.type'><p>Get the operator type used in an call, formula, expression, etc.</p></a></li>
<li><a href='#split_terms'><p>Split object into terms</p></a></li>
<li><a href='#terms.call'><p>terms</p></a></li>
<li><a href='#toggle.sign'><p>toggle the sign of an expression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Programmatic Utilities for Manipulating Formulas, Expressions,
Calls, Assignments and Other R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-22</td>
</tr>
<tr>
<td>Description:</td>
<td>These utilities facilitate the programmatic manipulations of
    formulas, expressions, calls, assignments and other R language objects. 
    These objects all share the same structure: a left-hand side, operator and 
    right-hand side. This packages provides methods for accessing and 
    modifying this structures as well as extracting and replacing names and 
    symbols from these objects.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>operator.tools(&ge; 1.4.0), utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/decisionpatterns/formula.tools">https://github.com/decisionpatterns/formula.tools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/decisionpatterns/formula.tools/issues">https://github.com/decisionpatterns/formula.tools/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'as.character.formula.R' 'env.R' 'get.vars.R' 'invert.R'
'is.one.sided.R' 'is.two.sided.R' 'lhs.vars.R' 'op.type.R'
'parts.R' 'parts.lhs.get.R' 'parts.lhs.set.R' 'parts.op.get.R'
'parts.op.set.R' 'parts.rhs.get.R' 'parts.rhs.set.R'
'rhs.vars.R' 'split.terms.R' 'terms.R' 'toggle.sign.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1.9000</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-01 07:53:43 UTC; cbrown</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Brown [aut, cre],
  Decision Patterns [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Brown &lt;chris.brown@decisionpatterns.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-01 12:56:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='.invert.single'>Invert multiple elements of a multiple element object</h2><span id='topic+.invert.single'></span><span id='topic+.invert.plural'></span>

<h3>Description</h3>

<p>Invert multiple elements of a multiple element object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.invert.single(x)

.invert.plural(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".invert.single_+3A_x">x</code></td>
<td>
<p>object to invert from</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>.invert.single
</p>

<hr>
<h2 id='as.character.formula'>Converts a formula to character</h2><span id='topic+as.character.formula'></span><span id='topic+as.character'></span>

<h3>Description</h3>

<p>Convers a formula to character representaion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.formula_+3A_x">x</code></td>
<td>
<p>formula object</p>
</td></tr>
<tr><td><code id="as.character.formula_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces formula to a character by deparsing.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+deparse">deparse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  as.character( y ~ mx +  b )

## The function is currently defined as
function(x)
  Reduce( paste, deparse(x) )
  
</code></pre>

<hr>
<h2 id='env'>Get the environment</h2><span id='topic+env'></span><span id='topic+env.formula'></span>

<h3>Description</h3>

<p>Get the environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env(x)

## S3 method for class 'formula'
env(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_+3A_x">x</code></td>
<td>
<p>object to get environoment from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>S3 returns the environment associated with an object.
</p>
<p>For a formula object, 'env' returns the environment in the '.Environment' 
attribute.
</p>


<h3>Value</h3>

<p>Environment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
env( lhs ~ rhs ) 

</code></pre>

<hr>
<h2 id='formula.parts'>Manipulate the component parts of formulas, expressions, calls, name/symbols 
and list and vectors of such objects.</h2><span id='topic+formula.parts'></span><span id='topic+lhs'></span><span id='topic+lhs+2Ccall-method'></span><span id='topic+lhs+2Cformula-method'></span><span id='topic+lhs+2C+3C--method'></span><span id='topic+lhs+2Cexpression-method'></span><span id='topic+lhs+2Clist-method'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-+2Ccall-method'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-+2Cformula-method'></span><span id='topic+lhs+3C-+2C+3C--method'></span><span id='topic++60lhs+3C-+60+2C+3C--method'></span><span id='topic+.replace.lhs.plural'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-+2Cexpression-method'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-+2Clist-method'></span><span id='topic+op'></span><span id='topic+op+2Cformula-method'></span><span id='topic+op+2Ccall-method'></span><span id='topic+op+2Cname-method'></span><span id='topic+op+2Cexpression-method'></span><span id='topic+op+2Clist-method'></span><span id='topic+op+2C+3C--method'></span><span id='topic+op+3C-'></span><span id='topic+op+3C-'></span><span id='topic+op+3C-+2Ccall-method'></span><span id='topic+op+3C-'></span><span id='topic+op+3C-+2Cformula-method'></span><span id='topic+op+3C-+2C+3C--method'></span><span id='topic+.replace.op.plural'></span><span id='topic+op+3C-'></span><span id='topic+op+3C-+2Cexpression-method'></span><span id='topic+op+3C-'></span><span id='topic+op+3C-+2Clist-method'></span><span id='topic+rhs'></span><span id='topic+.rhs.singular'></span><span id='topic+rhs+2Ccall-method'></span><span id='topic+rhs+2Cformula-method'></span><span id='topic+rhs+2C+3C--method'></span><span id='topic+rhs+2Cexpression-method'></span><span id='topic+rhs+2Clist-method'></span><span id='topic+rhs+3C-'></span><span id='topic+.replace.rhs.singular'></span><span id='topic+rhs+3C-'></span><span id='topic+rhs+3C-+2Ccall-method'></span><span id='topic+rhs+3C-'></span><span id='topic+rhs+3C-+2Cformula-method'></span><span id='topic+rhs+3C-+2C+3C--method'></span><span id='topic+.replace.rhs.plural'></span><span id='topic+.replace.ths.plural'></span><span id='topic+rhs+3C-'></span><span id='topic+rhs+3C-+2Cexpression-method'></span><span id='topic+rhs+3C-'></span><span id='topic+rhs+3C-+2Clist-method'></span>

<h3>Description</h3>

<p><code>lhs, rhs, op, and op.type </code> retrieve the various parts of R formulas, 
calls, expressions, names/symbols.  These functions were designed to 
greatly facilitate symbolic manupulation using native R objects.  Also 
provided are methods to handle list of these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs(x, ...)

## S4 method for signature 'call'
lhs(x)

## S4 method for signature 'formula'
lhs(x)



## S4 method for signature 'expression'
lhs(x, ...)

## S4 method for signature 'list'
lhs(x, ...)

lhs(x) &lt;- value

## S4 replacement method for signature 'call'
lhs(x) &lt;- value

## S4 replacement method for signature 'formula'
lhs(x) &lt;- value



.replace.lhs.plural(x, value)

## S4 replacement method for signature 'expression'
lhs(x) &lt;- value

## S4 replacement method for signature 'list'
lhs(x) &lt;- value

op(x)

## S4 method for signature 'formula'
op(x)

## S4 method for signature 'call'
op(x)

## S4 method for signature 'name'
op(x)

## S4 method for signature 'expression'
op(x)

## S4 method for signature 'list'
op(x)



op(x) &lt;- value

## S4 replacement method for signature 'call'
op(x) &lt;- value

## S4 replacement method for signature 'formula'
op(x) &lt;- value



.replace.op.plural(x, value)

## S4 replacement method for signature 'expression'
op(x) &lt;- value

## S4 replacement method for signature 'list'
op(x) &lt;- value

rhs(x, ...)

.rhs.singular(x)

## S4 method for signature 'call'
rhs(x)

## S4 method for signature 'formula'
rhs(x)



## S4 method for signature 'expression'
rhs(x, ...)

## S4 method for signature 'list'
rhs(x, ...)

rhs(x) &lt;- value

.replace.rhs.singular(x, value)

## S4 replacement method for signature 'call'
rhs(x) &lt;- value

## S4 replacement method for signature 'formula'
rhs(x) &lt;- value



.replace.rhs.plural(x, value)

## S4 replacement method for signature 'expression'
rhs(x) &lt;- value

## S4 replacement method for signature 'list'
rhs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.parts_+3A_x">x</code></td>
<td>
<p>object from where to get/set the lhs/rhs</p>
</td></tr>
<tr><td><code id="formula.parts_+3A_...">...</code></td>
<td>
<p>arguments passed to additional methods</p>
</td></tr>
<tr><td><code id="formula.parts_+3A_value">value</code></td>
<td>
<p>the value to set for the lhs/rhs</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lhs</code> retrieves the left-hand side 
<code>rhs</code> retrieves the right-hand side 
<code>op</code>  retrieves the operation 
<code>op.type</code> returns the type operator
</p>
<p>There are also functions <code>lhs.vars</code> and <code>rhs.vars</code>.  Like 
<code> <a href="base.html#topic+all.vars">all.vars</a> </code>, these functions interpret the variables on the 
left-hand and right-hand sides respectively.
</p>
<p>These are simple functions for extracting the left-hand side, right-hand 
side, operator and operator type from formulas, expressions, calls, 
names/symbols and list containing these objects.  lhs, rhs are only defined 
for formulas and calls ( and list and expressions ) that are defined with 
either one of the relational or tilde ('~') operators. If the object does 
not contain one of these operators, it will fail with a warning.
</p>
<p>The defined operator types are defined by the operator.tools package: See 
<code><a href="operator.tools.html#topic+operators">operators</a></code> and
<code><a href="operator.tools.html#topic+setOperator">setOperator</a></code>
</p>
<p>The <code>lhs.vars</code> and <code>rhs.vars</code> methods, return the variables used on
the lhs and rhs, respectively.  If special formula variables are used, such 
as '.', a data.frame or environment must also be provided such that the 
variable list may be properly infered.
</p>


<h3>Value</h3>

<p>Value depends on the argument.
</p>


<h3>Note</h3>

<p>Methods for the non-standard &quot;<code>&lt;-</code>&quot; class exist and are not included in 
the usage documentation because CRAN does not support S4 documentation for 
this class.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p>terms, all.vars, all.names, <code><a href="operator.tools.html#topic+operators">operators</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # FORMULA
  f &lt;- A + B ~ C + D
  lhs(f)
  lhs(f) &lt;- quote( E / F )

  rhs(f)
  rhs(f) &lt;- quote( G + H ) 
  op(f)
  op(rhs(f))
  op( quote(A) )  # NULL: 
  op.type(f)

  # ONE-SIDED FORMULA
  f &lt;- ~ A   # 
  lhs(f)     # NULL
  rhs(f)     # A


  # EXPRESSION
  e &lt;- expression( A + B == C + D )
  lhs(e)
  rhs(e)
  op(e)
  op.type(e)


  # CALL
  c &lt;- quote( A + B &gt; C + D )
  lhs(c)
  lhs(c) &lt;- quote(E)
  rhs(c)

  op(c)
  op.type(c)

  # ASSIGNMENT 
  a  &lt;- quote( A &lt;- B ) 
  lhs(a)
  rhs(a) 
  op(a)
  op.type(a) 

</code></pre>

<hr>
<h2 id='get.vars'>Get variable (names) from various R objects</h2><span id='topic+get.vars'></span><span id='topic+get.vars+2Cformula+2CANY-method'></span><span id='topic+get.vars+2Ccall+2CANY-method'></span><span id='topic+get.vars+2Cexpression+2Cmissing-method'></span><span id='topic+get.vars+2Cname+2CANY-method'></span><span id='topic+get.vars+2CANY+2CANY-method'></span><span id='topic+get.vars+2CANY+2CANY-methods'></span><span id='topic+get.vars+2CNULL+2CANY-method'></span><span id='topic+get.vars+2CNULL+2CANY-methods'></span><span id='topic+lhs.vars'></span><span id='topic+.lhs.vars'></span><span id='topic+lhs.vars+2Cformula-method'></span><span id='topic+lhs.vars+2Ccall-method'></span><span id='topic+lhs.vars+2Cexpression-method'></span><span id='topic+rhs.vars'></span><span id='topic+.rhs.vars'></span><span id='topic+rhs.vars+2Cformula-method'></span><span id='topic+rhs.vars+2Ccall-method'></span><span id='topic+rhs.vars+2Cexpression-method'></span>

<h3>Description</h3>

<p><code>get.vars</code> extracts variable names from various R objects such as
formulas, expressions, calls, symbols, etc.  It is very similar to
<code><a href="base.html#topic+all.vars">all.vars</a></code> except that all symbols, etc. are interpolated 
to the names of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vars(x, data = NULL, ...)

## S4 method for signature 'formula,ANY'
get.vars(x, data = NULL, ...)

## S4 method for signature 'call,ANY'
get.vars(x, data = NULL, ...)

## S4 method for signature 'expression,missing'
get.vars(x, data = NULL, ...)

## S4 method for signature 'name,ANY'
get.vars(x, data = NULL, ...)

## S4 method for signature 'ANY,ANY'
get.vars(x, data = NULL, ...)

## S4 method for signature ''NULL',ANY'
get.vars(x, data = NULL, ...)

lhs.vars(x, ...)

.lhs.vars(x, ..., data = NULL)

## S4 method for signature 'formula'
lhs.vars(x, ..., data = NULL)

## S4 method for signature 'call'
lhs.vars(x, ..., data = NULL)

## S4 method for signature 'expression'
lhs.vars(x, ...)

rhs.vars(x, ...)

.rhs.vars(x, ..., data = NULL)

## S4 method for signature 'formula'
rhs.vars(x, ..., data = NULL)

## S4 method for signature 'call'
rhs.vars(x, ..., data = NULL)

## S4 method for signature 'expression'
rhs.vars(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.vars_+3A_x">x</code></td>
<td>
<p>object to extract vars from.</p>
</td></tr>
<tr><td><code id="get.vars_+3A_data">data</code></td>
<td>
<p>data set/list or environment on which the names are defined</p>
</td></tr>
<tr><td><code id="get.vars_+3A_...">...</code></td>
<td>
<p>arguments passed to subsequent functions
</p>
<p><code>get.vars</code> and variant get the variables from objects optionally 
interpreting on <code>.</code> on the data.  This is useful, for example, when you 
wish to know what data is used based on a given formula.
</p>
<p>Methods/functions beginning with <code>.</code> are not exported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of variables names in order that they appear in
<code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.vars">all.vars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  get.vars( Species ~ ., iris )
  get.vars( quote( Sepal.Length * Sepal.Width ), iris )
  
</code></pre>

<hr>
<h2 id='invert'>invert</h2><span id='topic+invert'></span><span id='topic+invert+2Ccall-method'></span><span id='topic+invert+2Cexpression-method'></span>

<h3>Description</h3>

<p>Invert the operators in an object, usually a formula or expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert(x, ...)

## S4 method for signature 'call'
invert(x)

## S4 method for signature 'expression'
invert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_+3A_x">x</code></td>
<td>
<p>function for invert</p>
</td></tr>
<tr><td><code id="invert_+3A_...">...</code></td>
<td>
<p>additional arguments passed other functions
</p>
<p><code>invert</code> is a S4 generic method for inverting relational
operators, i.e. 
</p>
<p>functions prefixed with a <code>.</code> are not exported and should probably not 
be called directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The operand is returned with the relational operators inverted.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+op">op</a></code>, <code><a href="#topic+op.type">op.type</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  invert( quote( A &gt;  5 ) )
  invert( quote( A &gt;= 5 ) )
  invert( quote( A &lt;  5 ) )
  invert( quote( A &lt;= 5 ) )
  invert( quote( A == 5 ) )
  invert( quote( A != 5 ) )
  invert( quote( A %in% lettters[1:5] ) )
  invert( quote( A %!in% letters[1:5] ) )

</code></pre>

<hr>
<h2 id='is.one.sided'>Determine if an object is one- or two-sided.
Test whether a object (typically formula, call or expression) is one- (e.g. 
<code>~x</code>) or two-sided (e.g. <code>x~y</code>).</h2><span id='topic+is.one.sided'></span><span id='topic+is.one.sided+2Cformula-method'></span><span id='topic+is.one.sided+2Ccall-method'></span><span id='topic+is.one.sided+2C+3C--method'></span><span id='topic+is.one.sided+2Cexpression-method'></span><span id='topic+is.one.sided+2Clist-method'></span><span id='topic+is.one.sided+2CANY-method'></span><span id='topic+is.two.sided'></span><span id='topic+is.two.sided+2Cformula-method'></span><span id='topic+is.two.sided+2Ccall-method'></span><span id='topic+is.two.sided+2C+3C--method'></span><span id='topic+is.two.sided+2Cexpression-method'></span><span id='topic+is.two.sided+2Clist-method'></span><span id='topic+is.two.sided+2CANY-method'></span>

<h3>Description</h3>

<p>Determine if an object is one- or two-sided.
</p>
<p>Test whether a object (typically formula, call or expression) is one- (e.g. 
<code>~x</code>) or two-sided (e.g. <code>x~y</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.one.sided(x, ...)

## S4 method for signature 'formula'
is.one.sided(x, ...)

## S4 method for signature 'call'
is.one.sided(x, ...)



## S4 method for signature 'expression'
is.one.sided(x, ...)

## S4 method for signature 'list'
is.one.sided(x, ...)

## S4 method for signature 'ANY'
is.one.sided(x, ...)

is.two.sided(x, ...)

## S4 method for signature 'formula'
is.two.sided(x, ...)

## S4 method for signature 'call'
is.two.sided(x, ...)



## S4 method for signature 'expression'
is.two.sided(x, ...)

## S4 method for signature 'list'
is.two.sided(x, ...)

## S4 method for signature 'ANY'
is.two.sided(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.one.sided_+3A_x">x</code></td>
<td>
<p>object to test for one-sidedness.</p>
</td></tr>
<tr><td><code id="is.one.sided_+3A_...">...</code></td>
<td>
<p>arguments passed to called functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions detect whether the formula is single- (unary) or double-
sided. They work on formulas, expression, calls, assignments, etc.
</p>
<p><code>is.single.sided</code> and <code>is.unary</code> are alias for 
<code>is.single.sided</code>. <code>is.double.sided</code> and <code>is.binary</code> are 
aliases for <code>is.two.sided</code>.
</p>


<h3>Value</h3>

<p>logical; whether <code>x</code> is an object is one-sided or two-sided formula.
</p>


<h3>Note</h3>

<p>Methods for the &quot;<code>&lt;-</code>&quot; class exist and are not included in the usage 
documentation because CRAN does not support S4 documentation for this class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
form &lt;- y ~ x 

is.one.sided(form)
# is.single.sided(form)
# is.unary(form) 

is.two.sided(form)
# is.double.sided(form)
# is.binary(form)
                
</code></pre>

<hr>
<h2 id='op.type'>Get the operator type used in an call, formula, expression, etc.</h2><span id='topic+op.type'></span><span id='topic+op.type-methods'></span><span id='topic+op.type+2Ccall-method'></span><span id='topic+op.type+2Cformula-method'></span><span id='topic+op.type+2C+3C--method'></span><span id='topic+op.type+2CANY-method'></span><span id='topic+op.type+2Cexpression-method'></span><span id='topic+op.type+2Clist-method'></span>

<h3>Description</h3>

<p>Get the operator type used in an call, formula, expression, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op.type(x)

## S4 method for signature 'call'
op.type(x)

## S4 method for signature 'formula'
op.type(x)



## S4 method for signature 'ANY'
op.type(x)

## S4 method for signature 'expression'
op.type(x)

## S4 method for signature 'list'
op.type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op.type_+3A_x">x</code></td>
<td>
<p>object from which to extract the operator type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of the operator type(s)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+op">op</a></code>, <code><a href="operator.tools.html#topic+operator.type">operator.type</a></code>
</p>

<hr>
<h2 id='split_terms'>Split object into terms</h2><span id='topic+split_terms'></span>

<h3>Description</h3>

<p>Split formulas, call and expressions into terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_terms(x, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_terms_+3A_x">x</code></td>
<td>
<p>object to split terms from</p>
</td></tr>
<tr><td><code id="split_terms_+3A_recursive">recursive</code></td>
<td>
<p>logical; whether to split terms recursively in parenthetical
enclosed terms  (depth-first).  (Default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the [terms()] function, 'split_terms' does not use [stats::terms()]
and instead just splits 'x' into an **expression vector** of terms. (Terms 
are the mathematical notion of terms). The signs of the terms are preserved.
</p>
<p>If 'recursive' is 'TRUE', splitting occurs recursively, i.e. parsing of the 
input descends into parenthetical expressions '(...)'.  
</p>
<p>See **examples**.
</p>


<h3>Value</h3>

<p>experession vector of terms
</p>


<h3>References</h3>

<p>* [SO: How to split a formula](https://stackoverflow.com/questions/39155701/how-to-split-a-formula-in-r)
</p>


<h3>See Also</h3>

<p>* [terms()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  split_terms(1)                   # 1
  split_terms( quote(a) )          # a     
  split_terms( quote(-a) )         # -a   
  split_terms( quote(a+1) )        # a, 1
  split_terms( quote(1+a) )        # 1, a
  split_terms( quote(-1+a) )       # -1, a
  split_terms( quote(-1-a) )
  
  split_terms( quote(a+b+c) )      # a,b,c
  split_terms( quote((a+b)+1) )    # (a+b),1
  split_terms( quote((a+b)+1), recursive=TRUE )    # a,b,1
  split_terms( quote((a-b)+1), recursive=TRUE )    # a,-b,1
  split_terms( quote(-a) )         # -a
  
  split_terms( quote(a-1) )        # a, -1
  split_terms( quote(-a-1))        # -a, -1
  split_terms( quote( -(a+1) ) )   # -(a+1)
  split_terms( quote( -(a+1) ), recursive=TRUE )  # -a,-1
  
  split_terms( quote( ---a ))
  split_terms( quote( -(a+(b-(c+d)))), recursive=TRUE )
  
</code></pre>

<hr>
<h2 id='terms.call'>terms</h2><span id='topic+terms.call'></span><span id='topic+terms.expression'></span><span id='topic+terms'></span>

<h3>Description</h3>

<p>terms method for call and expression objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'call'
terms(x, ...)

## S3 method for class 'expression'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.call_+3A_x">x</code></td>
<td>
<p>A call object</p>
</td></tr>
<tr><td><code id="terms.call_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+terms.formula">terms.formula</a></code>
</p>
<p>This S3 method returns a terms object for a call methods using a dispatch to
<code> terms.formula </code>.
</p>
<p>The terms are generated by making a rhs only call to <code> terms.formula </code>.
</p>
<p><code>data</code> is only needed and must be explicitly specified, i.e.  <code>
data = </code> if there are special elements such as '.'.  Otherwise the
<code>data</code> argument is unused.
</p>
<p>Some edge cases may not be supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A terms object.  See <code><a href="stats.html#topic+terms.object">terms.object</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Christopher Brown
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+terms.object">stats::terms.object()</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+terms.formula">stats::terms.formula()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
    terms( quote( A + B ) )

    data(iris) 
    x &lt;- terms( quote( . - Species ) , data=iris ) 

</code></pre>

<hr>
<h2 id='toggle.sign'>toggle the sign of an expression</h2><span id='topic+toggle.sign'></span>

<h3>Description</h3>

<p>toggle the sign of an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toggle.sign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toggle.sign_+3A_x">x</code></td>
<td>
<p>expression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'toggle.sign' changes the sign of an expression for '+' tp '-' and 
visa-versa.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  toggle.sign(1:3)
  toggle.sign( quote(a) )
  toggle.sign( quote(-a) )
  
  exp &lt;- expression( a, -b, -(a-b) )
  toggle.sign(exp)
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
