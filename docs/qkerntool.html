<!DOCTYPE html><html lang="en"><head><title>Help for package qkerntool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qkerntool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.cndkernmatrix'><p>Assing cndkernmatrix class to matrix objects</p></a></li>
<li><a href='#as.qkernmatrix'><p>Assing qkernmatrix class to matrix objects</p></a></li>
<li><a href='#bases'><p>qKernel Functions</p></a></li>
<li><a href='#blkdiag'><p>Block diagonal concatenation of matrix</p></a></li>
<li><a href='#cndkernel-class'><p>Class &quot;cndkernel&quot; &quot;nonlkernel&quot; &quot;polykernel&quot; &quot;rbfkernel&quot; &quot;laplkernel&quot;</p></a></li>
<li><a href='#cndkernmatrix'><p>CND Kernel Matrix functions</p></a></li>
<li><a href='#cnds'><p>CND Kernel Functions</p></a></li>
<li><a href='#Eucdist'><p>Computes the Euclidean(square Euclidean) distance matrix</p></a></li>
<li><a href='#mfeat_pix'>
<p>mfeat_pix dataset</p></a></li>
<li><a href='#qkdbscan'><p>qKernel-DBSCAN density reachability and connectivity clustering</p></a></li>
<li><a href='#qkdbscan-class'><p>Class &quot;qkdbscan&quot;</p></a></li>
<li><a href='#qkernel-class'><p>Class &quot;qkernel&quot; &quot;rbfqkernel&quot; &quot;nonlqkernel&quot; &quot;laplqkernel&quot; &quot;ratiqkernel&quot;</p></a></li>
<li><a href='#qkernmatrix'><p>qKernel Matrix functions</p></a></li>
<li><a href='#qkgda'><p>qKernel Generalized Discriminant Analysis</p></a></li>
<li><a href='#qkgda-class'><p>Class &quot;qkgda&quot;</p></a></li>
<li><a href='#qkIsomap'>
<p>qKernel Isometric Feature Mapping</p></a></li>
<li><a href='#qkIsomap-class'><p>qKernel Isomap embedding</p></a></li>
<li><a href='#qkLLE'><p>qKernel Locally Linear Embedding</p></a></li>
<li><a href='#qkLLE-class'><p>Class &quot;qkLLE&quot;</p></a></li>
<li><a href='#qkMDS'>
<p>qKernel Metric Multi-Dimensional Scaling</p></a></li>
<li><a href='#qkMDS-class'><p>qKernel Metric Multi-Dimensional Scaling</p></a></li>
<li><a href='#qkpca'><p>qKernel Principal Components Analysis</p></a></li>
<li><a href='#qkpca-class'><p>Class &quot;qkpca&quot;</p></a></li>
<li><a href='#qkprc-class'><p>Class &quot;qkprc&quot;</p></a></li>
<li><a href='#qkspecc'><p>qkernel spectral Clustering</p></a></li>
<li><a href='#qkspecc-class'><p>Class &quot;qkspecc&quot;</p></a></li>
<li><a href='#qkspeclust'><p>qkernel spectral Clustering</p></a></li>
<li><a href='#qsammon'><p>qKernel Sammon Mapping</p></a></li>
<li><a href='#qsammon-class'><p>Class &quot;qsammon&quot;</p></a></li>
<li><a href='#qtSNE'><p>qKernel t-Distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#qtSNE-class'><p>Class &quot;qtSNE&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Q-Kernel-Based and Conditionally Negative Definite Kernel-Based
Machine Learning Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.19</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonlinear machine learning tool for classification, clustering
        and dimensionality reduction. It integrates 12 q-kernel functions and
        15 conditional negative definite kernel functions and includes the 
        q-kernel and conditional negative definite kernel version of
        density-based spatial clustering of applications with noise,
        spectral clustering, generalized discriminant analysis, principal
        component analysis, multidimensional scaling, locally linear embedding,
        sammon's mapping and t-Distributed stochastic neighbor embedding.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, class, graphics, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yusen Zhang &lt;yusenzhang@126.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-13 04:27:58 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Yusen Zhang <a href="https://orcid.org/0000-0003-3842-1153"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Daolin Pang [ctb],
  Jinghao Wang [ctb],
  Jialin Zhang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-13 23:02:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.cndkernmatrix'>Assing cndkernmatrix class to matrix objects</h2><span id='topic+cndkernmatrix-class'></span><span id='topic+as.cndkernmatrix'></span><span id='topic+as.cndkernmatrix-methods'></span><span id='topic+as.cndkernmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>as.cndkernmatrix</code> in package <span class="pkg">qkerntool</span> can be used
to create the cndkernmatrix class to matrix objects representing a
CND kernel matrix.  These matrices can then be used with the cndkernmatrix
interfaces which most of the functions in <span class="pkg">qkerntool</span> support.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
as.cndkernmatrix(x, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.cndkernmatrix_+3A_x">x</code></td>
<td>
<p>matrix to be assigned the <code>cndkernmatrix</code> class </p>
</td></tr>
<tr><td><code id="as.cndkernmatrix_+3A_center">center</code></td>
<td>
<p>center the cndkernel matrix in feature space (default: FALSE) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code>,<code><a href="#topic+qkernmatrix">qkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data
x &lt;- rbind(matrix(rnorm(10),,2),matrix(rnorm(10,mean=3),,2))
y &lt;- matrix(c(rep(1,5),rep(-1,5)))

### Use as.cndkernmatrix to label the cov. matrix as a CND kernel matrix
### which is eq. to using a linear kernel

K &lt;- as.cndkernmatrix(crossprod(t(x)))

K


</code></pre>

<hr>
<h2 id='as.qkernmatrix'>Assing qkernmatrix class to matrix objects</h2><span id='topic+qkernmatrix-class'></span><span id='topic+as.qkernmatrix'></span><span id='topic+as.qkernmatrix-methods'></span><span id='topic+as.qkernmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>as.qkernmatrix</code> in package <span class="pkg">qkerntool</span> can be used
to create the qkernmatrix class to matrix objects representing a
q kernel matrix.  These matrices can then be used with the qkernmatrix
interfaces which most of the functions in <span class="pkg">qkerntool</span> support.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
as.qkernmatrix(x, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.qkernmatrix_+3A_x">x</code></td>
<td>
<p>matrix to be assigned the <code>qkernmatrix</code> class </p>
</td></tr>
<tr><td><code id="as.qkernmatrix_+3A_center">center</code></td>
<td>
<p>center the kernel matrix in feature space (default: FALSE) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>,<code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data
x &lt;- rbind(matrix(rnorm(10),,2),matrix(rnorm(10,mean=3),,2))
y &lt;- matrix(c(rep(1,5),rep(-1,5)))

### Use as.qkernmatrix to label the cov. matrix as a qkernel matrix
### which is eq. to using a linear kernel

K &lt;- as.qkernmatrix(crossprod(t(x)))

K


</code></pre>

<hr>
<h2 id='bases'>qKernel Functions</h2><span id='topic+bases'></span><span id='topic+rbfbase'></span><span id='topic+nonlbase'></span><span id='topic+laplbase'></span><span id='topic+ratibase'></span><span id='topic+multbase'></span><span id='topic+invbase'></span><span id='topic+wavbase'></span><span id='topic+powbase'></span><span id='topic+logbase'></span><span id='topic+caubase'></span><span id='topic+chibase'></span><span id='topic+studbase'></span>

<h3>Description</h3>

<p>The kernel generating functions provided in qkerntool. <br />
The Non Linear Kernel <code class="reqn">k(x,y) = \frac{1}{2(1-q)}(q^{-\alpha||x||^2}+q^{-\alpha||y||^2}-2q^{-\alpha x'y}) </code>.<br />
The Gaussian kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (1-q^{(||x-y||^2/\sigma)})</code>.<br />
The Laplacian Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (1-q^{(||x-y||/\sigma)})</code>.<br />
</p>
<p>The Rational Quadratic Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (1-q^{\frac{||x-y||^2}{||x-y||^2+c}})</code>.<br />
The Multiquadric Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (q^c-q^{\sqrt{||x-y||^2+c}})</code>.<br />
The Inverse Multiquadric Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (q^{-\frac{1}{c}}-q^{-\frac{1}{\sqrt{||x-y||^2+c}}})</code>.<br />
The Wave Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (q^{-1}-q^{-\frac{\theta}{||x-y||}\sin{\frac{||x-y||}{\theta}}})</code>.<br />
The d Kernel <code class="reqn">k(x,y) = \frac{1}{1-q}[1-q^(||x-y||^d)] </code>.<br />
The Log Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} [1-q^ln(||x-y||^d+1)]</code>.<br />
The Cauchy Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (q^{-1}-q^{-\frac{1}{1+||x-y||^2/\sigma}})</code>.<br />
The Chi-Square Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (1-q^{\sum{2(x-y)^2/(x+y)} \gamma})</code>.<br />
The Generalized T-Student Kernel <code class="reqn">k(x,y) =\frac{1}{1-q} (q^{-1}-q^{-\frac{1}{1+||x-y||^d}})</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbfbase(sigma=1,q=0.8)
nonlbase(alpha = 1,q = 0.8)
laplbase(sigma = 1, q = 0.8)
ratibase(c = 1, q = 0.8)
multbase(c = 1, q = 0.8)
invbase(c = 1, q = 0.8)
wavbase(theta = 1,q = 0.8)
powbase(d = 2, q = 0.8)
logbase(d = 2, q = 0.8)
caubase(sigma = 1, q = 0.8)
chibase(gamma = 1, q = 0.8)
studbase(d = 2, q = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bases_+3A_q">q</code></td>
<td>
<p>for all the qkernel function.</p>
</td></tr>
<tr><td><code id="bases_+3A_sigma">sigma</code></td>
<td>
<p>for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.</p>
</td></tr>
<tr><td><code id="bases_+3A_alpha">alpha</code></td>
<td>
<p>for the Non Linear qkernel function &quot;nonlbase&quot;.</p>
</td></tr>
<tr><td><code id="bases_+3A_c">c</code></td>
<td>
<p>for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel
function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.</p>
</td></tr>
<tr><td><code id="bases_+3A_theta">theta</code></td>
<td>
<p>for the Wave qkernel function &quot;wavbase&quot;.</p>
</td></tr>
<tr><td><code id="bases_+3A_d">d</code></td>
<td>
<p>for the d qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot;
and the Generalized T-Student qkernel function &quot;studbase&quot;.</p>
</td></tr>
<tr><td><code id="bases_+3A_gamma">gamma</code></td>
<td>
<p>for the Chi-Square qkernel function &quot;chibase&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kernel generating functions are used to initialize a kernel
function
which calculates the kernel function value between two feature vectors in a
Hilbert Space. These functions can be passed as a <code>qkernel</code> argument on almost all
functions in <span class="pkg">qkerntool</span>(e.g., <code>qkgda</code>, <code>qkpca</code>  etc).
</p>


<h3>Value</h3>

<p>Return an S4 object of class <code>qkernel</code> which extents the
<code>function</code> class. The resulting function implements the given
kernel calculating the kernel function value between two vectors.
</p>
<table role = "presentation">
<tr><td><code>qpar</code></td>
<td>
<p>a list containing the kernel parameters (hyperparameters)
used.</p>
</td></tr>
</table>
<p>The kernel parameters can be accessed by the <code>qpar</code> function.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang<br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>qkfunc &lt;- rbfbase(sigma=1,q=0.8)
qkfunc

qpar(qkfunc)

## create two vectors
x &lt;- rnorm(10)
y &lt;- rnorm(10)

## calculate dot product
qkfunc(x,y)

</code></pre>

<hr>
<h2 id='blkdiag'>Block diagonal concatenation of matrix</h2><span id='topic+blkdiag'></span>

<h3>Description</h3>

<p>Y = BLKDIAG(A,B,...)  produces  diag(A,B,...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blkdiag(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blkdiag_+3A_x">x</code></td>
<td>
<p>a list of matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>E - Block diagonal concatenation of matrix
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a>
</p>

<hr>
<h2 id='cndkernel-class'>Class &quot;cndkernel&quot; &quot;nonlkernel&quot; &quot;polykernel&quot; &quot;rbfkernel&quot; &quot;laplkernel&quot;</h2><span id='topic+cndkernel-class'></span><span id='topic+qpar+2Ccndkernel-method'></span><span id='topic+show+2Ccndkernel-method'></span><span id='topic+nonlkernel-class'></span><span id='topic+polykernel-class'></span><span id='topic+rbfkernel-class'></span><span id='topic+laplkernel-class'></span><span id='topic+anokernel-class'></span><span id='topic+ratikernel-class'></span><span id='topic+multkernel-class'></span><span id='topic+invkernel-class'></span><span id='topic+wavkernel-class'></span><span id='topic+powkernel-class'></span><span id='topic+logkernel-class'></span><span id='topic+caukernel-class'></span><span id='topic+chikernel-class'></span><span id='topic+studkernel-class'></span><span id='topic+norkernel-class'></span>

<h3>Description</h3>

<p>  The built-in kernel classes in <span class="pkg">qkerntool</span></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("nonlkernel")</code>,
<code>new{"polykernel"}</code>, <code>new{"rbfkernel"}</code>,
<code>new{"laplkernel"}</code>, <code>new{"anokernel"}</code>,
<code>new{"ratikernel"}</code>, <code>new{"multkernel"}</code>,
<code>new{"invkernel"}</code>, <code>new{"wavkernel"}</code>,
<code>new{"powkernel"}</code>, <code>new{"logkernel"}</code>,
<code>new{"caukernel"}</code>, <code>new{"chikernel"}</code>,
<code>new{"studkernel"}</code>,<code>new{"norkernel"}</code>
</p>
<p>or by calling the <code>nonlcnd</code>,<code>polycnd</code>, <code>rbfcnd</code>,
<code>laplcnd</code>, <code>anocnd</code>, <code>raticnd</code>, <code>multcnd</code>,
<code>invcnd</code>, <code>wavcnd</code>, <code>powcnd</code>, <code>logcnd</code>,
<code>caucnd</code>, <code>chicnd</code>, <code>studcnd</code>, <code>norcnd</code>  functions etc..
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code> containing
the kernel function </p>
</dd>
<dt><code>qpar</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
kernel parameters </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cndkernmatrix</dt><dd><p><code>signature(kernel = "rbfkernel", x ="matrix")</code>: computes the kernel matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>,<code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cndkfunc &lt;- rbfcnd(gamma = 1)
cndkfunc

qpar(cndkfunc)

## create two vectors
x &lt;- rnorm(10)
y &lt;- rnorm(10)


cndkfunc(x,y)
</code></pre>

<hr>
<h2 id='cndkernmatrix'>CND Kernel Matrix functions</h2><span id='topic+cndkernmatrix'></span><span id='topic+cndkernmatrix+2Ccndkernel-method'></span><span id='topic+cndkernmatrix+2Canokernel-method'></span><span id='topic+cndkernmatrix+2Ccaukernel-method'></span><span id='topic+cndkernmatrix+2Cchikernel-method'></span><span id='topic+cndkernmatrix+2Cinvkernel-method'></span><span id='topic+cndkernmatrix+2Claplkernel-method'></span><span id='topic+cndkernmatrix+2Clogkernel-method'></span><span id='topic+cndkernmatrix+2Cmultkernel-method'></span><span id='topic+cndkernmatrix+2Cnonlkernel-method'></span><span id='topic+cndkernmatrix+2Cpowkernel-method'></span><span id='topic+cndkernmatrix+2Cratikernel-method'></span><span id='topic+cndkernmatrix+2Cstudkernel-method'></span><span id='topic+cndkernmatrix+2Cwavkernel-method'></span><span id='topic+cndkernmatrix+2Cpolykernel-method'></span><span id='topic+cndkernmatrix+2Crbfkernel-method'></span><span id='topic+cndkernmatrix+2Cnorkernel-method'></span><span id='topic+cndkernmatrix.anokernel'></span><span id='topic+cndkernmatrix.caukernel'></span><span id='topic+cndkernmatrix.chikernel'></span><span id='topic+cndkernmatrix.invkernel'></span><span id='topic+cndkernmatrix.laplkernel'></span><span id='topic+cndkernmatrix.logkernel'></span><span id='topic+cndkernmatrix.multkernel'></span><span id='topic+cndkernmatrix.nonlkernel'></span><span id='topic+cndkernmatrix.polykernel'></span><span id='topic+cndkernmatrix.powkernel'></span><span id='topic+cndkernmatrix.ratikernel'></span><span id='topic+cndkernmatrix.rbfkernel'></span><span id='topic+cndkernmatrix.studkernel'></span><span id='topic+cndkernmatrix.wavkernel'></span><span id='topic+cndkernmatrix.norkernel'></span>

<h3>Description</h3>

<p><code>cndkernmatrix</code> calculates the kernel matrix <code class="reqn">K_{ij} = k(x_i,x_j)</code> or <code class="reqn">K_{ij} =
    k(x_i,y_j)</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cndkernel'
cndkernmatrix(cndkernel, x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cndkernmatrix_+3A_cndkernel">cndkernel</code></td>
<td>
<p>the cndkernel function to be used to calculate the CND kernel
matrix.
This has to be a function of class <code>cndkernel</code>, i.e. which can be
generated either one of the build in
kernel generating functions (e.g., <code>rbfcnd</code> <code>nonlcnd</code> etc.) or a user defined
function of class <code>cndkernel</code> taking two vector arguments and returning a scalar.</p>
</td></tr>
<tr><td><code id="cndkernmatrix_+3A_x">x</code></td>
<td>
<p>a data matrix to be used to calculate the kernel matrix.</p>
</td></tr>
<tr><td><code id="cndkernmatrix_+3A_y">y</code></td>
<td>
<p>second data matrix to calculate the kernel matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common functions used during kernel based computations.<br />
The <code>cndkernel</code> parameter can be set to any function, of class
cndkernel, which computes the kernel function value in feature space between two
vector arguments. <span class="pkg">qkerntool</span> provides more than 10 CND kernel functions
which can be initialized by using the following
functions:
</p>

<ul>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial  cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code>  Gaussian cndkernel function
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code>  ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code>  Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code>  Wave  cndkernel function
</p>
</li>
<li> <p><code>powcnd</code>  d cndkernel function
</p>
</li>
<li> <p><code>logcnd</code>  Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code>  Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code>  Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>
<p>  (see example.)
</p>


<h3>Value</h3>

<p><code>cndkernmatrix</code> returns a conditionally negative definite matrix with a zero diagonal element.<br />
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlbase">nonlbase</a></code>, <code><a href="#topic+rbfbase">rbfbase</a></code>,
<code><a href="#topic+laplbase">laplbase</a></code>, <code><a href="#topic+ratibase">ratibase</a></code>, <code><a href="#topic+multbase">multbase</a></code>, <code><a href="#topic+invbase">invbase</a></code>,
<code><a href="#topic+wavbase">wavbase</a></code>, <code><a href="#topic+powbase">powbase</a></code>, <code><a href="#topic+logbase">logbase</a></code>, <code><a href="#topic+caubase">caubase</a></code>,
<code><a href="#topic+chibase">chibase</a></code>, <code><a href="#topic+studbase">studbase</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## use the iris data
data(iris)
dt &lt;- as.matrix(iris[ ,-5])

## initialize cndkernel function
lapl &lt;- laplcnd(gamma = 1)
lapl

## calculate cndkernel matrix
cndkernmatrix(lapl, dt)
</code></pre>

<hr>
<h2 id='cnds'>CND Kernel Functions</h2><span id='topic+cnds'></span><span id='topic+nonlcnd'></span><span id='topic+polycnd'></span><span id='topic+rbfcnd'></span><span id='topic+laplcnd'></span><span id='topic+anocnd'></span><span id='topic+raticnd'></span><span id='topic+multcnd'></span><span id='topic+invcnd'></span><span id='topic+wavcnd'></span><span id='topic+powcnd'></span><span id='topic+logcnd'></span><span id='topic+caucnd'></span><span id='topic+chicnd'></span><span id='topic+studcnd'></span><span id='topic+norcnd'></span>

<h3>Description</h3>

<p>The kernel generating functions provided in qkerntool. <br />
The Non Linear Kernel <code class="reqn">k(x,y) = [exp(\alpha ||x||^2)+exp(\alpha||y||^2)-2exp(\alpha x'y)]/2</code>.<br />
The Polynomial kernel <code class="reqn">k(x,y) = [(\alpha ||x||^2+c)^d+(\alpha ||y||^2+c)^d-2(\alpha x'y+c)^d]/2</code>.<br />
The Gaussian kernel <code class="reqn">k(x,y) = 1-exp(-||x-y||^2/\gamma)</code>.<br />
The Laplacian Kernel <code class="reqn">k(x,y) = 1-exp(-||x-y||/\gamma)</code>.<br />
The ANOVA Kernel  <code class="reqn">k(x,y) = n-\sum exp(-\sigma (x-y)^2)^d</code>. <br />
The Rational Quadratic Kernel <code class="reqn">k(x,y) = ||x-y||^2/(||x-y||^2+c)</code>. <br />
The Multiquadric Kernel <code class="reqn">k(x,y) = \sqrt{(||x-y||^2+c^2)-c}</code>. <br />
The Inverse Multiquadric Kernel <code class="reqn">k(x,y) = 1/c-1/\sqrt{||x-y||^2+c^2}</code>.<br />
The Wave Kernel <code class="reqn">k(x,y) = 1-\frac{\theta}{||x-y||}\sin\frac{||x-y||}{\theta}</code>.<br />
The d Kernel <code class="reqn">k(x,y) = ||x-y||^d</code>.<br />
The Log Kernel <code class="reqn">k(x,y) = \log(||x-y||^d+1)</code>.<br />
The Cauchy Kernel <code class="reqn">k(x,y) = 1-1/(1+||x-y||^2/\gamma)</code>.<br />
The Chi-Square Kernel <code class="reqn">k(x,y) = \sum{2(x-y)^2/(x+y)}</code>.<br />
The Generalized T-Student Kernel <code class="reqn">k(x,y) = 1-1/(1+||x-y||^d)</code>.<br />
The normal Kernel <code class="reqn">k(x,y) = ||x-y||^2</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonlcnd(alpha = 1)
polycnd(d = 2, alpha = 1, c = 1)
rbfcnd(gamma = 1)
laplcnd(gamma = 1)
anocnd(d = 2, sigma = 1)
raticnd(c = 1)
multcnd(c = 1)
invcnd(c = 1)
wavcnd(theta = 1)
powcnd(d = 2)
logcnd(d = 2)
caucnd(gamma = 1)
chicnd( )
studcnd(d = 2)
norcnd()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnds_+3A_alpha">alpha</code></td>
<td>
<p>for the Non Linear cndkernel function &quot;nonlcnd&quot; and the Polynomial cndkernel function &quot;polycnd&quot;.</p>
</td></tr>
<tr><td><code id="cnds_+3A_gamma">gamma</code></td>
<td>
<p>for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.</p>
</td></tr>
<tr><td><code id="cnds_+3A_sigma">sigma</code></td>
<td>
<p>for the ANOVA cndkernel function &quot;anocnd&quot;.</p>
</td></tr>
<tr><td><code id="cnds_+3A_theta">theta</code></td>
<td>
<p>for the Wave cndkernel function &quot;wavcnd&quot;.</p>
</td></tr>
<tr><td><code id="cnds_+3A_c">c</code></td>
<td>
<p>for the Rational Quadratic cndkernel function &quot;raticnd&quot;, the Polynomial cndkernel function &quot;polycnd&quot;, the Multiquadric
cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function  &quot;invcnd&quot;.</p>
</td></tr>
<tr><td><code id="cnds_+3A_d">d</code></td>
<td>
<p>for the Polynomial cndkernel function &quot;polycnd&quot;, the ANOVA cndkernel function &quot;anocnd&quot;, the cndkernel function &quot;powcnd&quot;, the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kernel generating functions are used to initialize a kernel
function which calculates the kernel function value between two feature vectors in a
Hilbert Space. These functions can be passed as a <code>qkernel</code> argument on almost all
functions in <span class="pkg">qkerntool</span>.
</p>


<h3>Value</h3>

<p>Return an S4 object of class <code>cndkernel</code> which extents the
<code>function</code> class. The resulting function implements the given
kernel calculating the kernel function value between two vectors.
</p>
<table role = "presentation">
<tr><td><code>qpar</code></td>
<td>
<p>a list containing the kernel parameters (hyperparameters)
used.</p>
</td></tr>
</table>
<p>The kernel parameters can be accessed by the <code>qpar</code> function.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang<br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code>, <code><a href="#topic+qkernmatrix">qkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cndkfunc &lt;- rbfcnd(gamma = 1)
cndkfunc

qpar(cndkfunc)

## create two vectors
x &lt;- rnorm(10)
y &lt;- rnorm(10)

## calculate dot product
cndkfunc(x,y)

</code></pre>

<hr>
<h2 id='Eucdist'>Computes the Euclidean(square Euclidean) distance matrix</h2><span id='topic+Eucdist'></span><span id='topic+Eucdist+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>Eucdist</code> Computes the Euclidean(square Euclidean) distance matrix.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Eucdist_+3A_x">x</code></td>
<td>
<p> (NxD) matrix  (N samples, D features)</p>
</td></tr>
<tr><td><code id="Eucdist_+3A_y">y</code></td>
<td>
<p> (MxD) matrix  (M samples, D features)</p>
</td></tr>
<tr><td><code id="Eucdist_+3A_seuclidean">sEuclidean</code></td>
<td>
<p>can be TRUE or FALSE, FALSE to Compute the Euclidean distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>E - (MxN) Euclidean (square Euclidean) distances between vectors in x and y
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>###
data(iris)
testset &lt;- sample(1:150,20)
x &lt;- as.matrix(iris[-testset,-5])
y &lt;- as.matrix(iris[testset,-5])

##
res0 &lt;- Eucdist(x)
res1 &lt;- Eucdist(x, x, sEuclidean = FALSE)
res2 &lt;- Eucdist(x, y = NULL, sEuclidean = FALSE)
res3 &lt;- Eucdist(x, x, sEuclidean = TRUE)
res4 &lt;- Eucdist(x, y = NULL)
res5 &lt;- Eucdist(x, sEuclidean = FALSE)
</code></pre>

<hr>
<h2 id='mfeat_pix'>
mfeat_pix dataset
</h2><span id='topic+mfeat_pix'></span>

<h3>Description</h3>

<p>This dataset consists of features of handwritten numerals (&lsquo;0&rsquo;&ndash;&lsquo;9&rsquo;) extracted from a collection of Dutch utility maps. 200 patterns per class (for a total of 2,000 patterns) have been digitized in binary images. This dataset is about 240 pixel averages in 2 x 3 windows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mfeat_pix")</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 observations on the following 240 variables.
</p>


<h3>Source</h3>

<p>https://archive.ics.uci.edu/ml/datasets/Multiple+Features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mfeat_pix)
</code></pre>

<hr>
<h2 id='qkdbscan'>qKernel-DBSCAN density reachability and connectivity clustering</h2><span id='topic+qkdbscan'></span><span id='topic+qkdbscan+2Cmatrix-method'></span><span id='topic+qkdbscan+2Ccndkernmatrix-method'></span><span id='topic+qkdbscan+2Cqkernmatrix-method'></span><span id='topic+print+2Cqkdbscan-method'></span><span id='topic+predict+2Cqkdbscan-method'></span>

<h3>Description</h3>

<p>Similiar to the Density-Based Spatial Clustering of Applications with Noise(or DBSCAN) algorithm,
qKernel-DBSCAN is a density-based clustering algorithm that can be applied under both linear and non-linear situations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkdbscan(x, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
eps = 0.25, MinPts = 5, hybrid = TRUE, seeds = TRUE,  showplot  = FALSE,
countmode = NULL, na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qkdbscan(x, eps = 0.25, MinPts = 5, seeds = TRUE,
showplot  = FALSE, countmode = NULL, ...)

## S4 method for signature 'qkernmatrix'
qkdbscan(x, eps = 0.25, MinPts = 5, seeds = TRUE,
showplot  = FALSE, countmode = NULL, ...)

## S4 method for signature 'qkdbscan'
predict(object, data, newdata = NULL, predict.max = 1000, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkdbscan_+3A_x">x</code></td>
<td>
<p>the data matrix indexed by row, or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the Power qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>power, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>power, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>power</code> for the Power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_eps">eps</code></td>
<td>
<p>reachability distance, see Ester et al. (1996). (default:0.25)</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_minpts">MinPts</code></td>
<td>
<p>reachability minimum number of points, see Ester et al.(1996).(default : 5) </p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_hybrid">hybrid</code></td>
<td>
<p>whether the algothrim expects raw data but calculates partial distance matrices, can be TRUE or FALSE</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_seeds">seeds</code></td>
<td>
<p>can be TRUE or FALSE, FALSE to not include the <code>isseed</code>-vector in the <code>dbscan</code>-object.</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_showplot">showplot</code></td>
<td>
<p>whether to show the plot or not, can be TRUE or FALSE</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_na.action">na.action</code></td>
<td>
<p>a function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases  are found.
(NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_countmode">countmode</code></td>
<td>
<p>NULL or vector of point numbers at which to report progress. </p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_object">object</code></td>
<td>
<p>object of class <code>dbscan</code>.</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_data">data</code></td>
<td>
<p>matrix or data.frame.</p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_newdata">newdata</code></td>
<td>
<p>matrix or data.frame with raw data to predict. </p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_predict.max">predict.max</code></td>
<td>
<p>max. batch size for predictions. </p>
</td></tr>
<tr><td><code id="qkdbscan_+3A_...">...</code></td>
<td>
<p>Further arguments transferred to plot methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data can be passed to the <code>qkdbscan</code> function in a <code>matrix</code>, in addition <code>qkdbscan</code> also supports input in the form of a kernel matrix of class <code>qkernmatrix</code> or class <code>cndkernmatrix</code>.
</p>


<h3>Value</h3>

<p><code>predict</code>(qkdbscan-method) gives out a vector of predicted clusters for the points in <code>newdata</code>.
</p>
<p><code>qkdbscan</code> gives out an S4 object which is a LIST with components
</p>
<table role = "presentation">
<tr><td><code>clust</code></td>
<td>
<p>integer vector coding cluster membership with noise observations (singletons) coded as 0 </p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>parameter eps</p>
</td></tr>
<tr><td><code>MinPts</code></td>
<td>
<p>parameter MinPts</p>
</td></tr>
<tr><td><code>kcall</code></td>
<td>
<p>the function call</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>the kernel function used</p>
</td></tr>
<tr><td><code>xmatrix</code></td>
<td>
<p>the original data matrix</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Note</h3>

<p>The predict function can be used to embed new data on the new space.</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Martin Ester, Hans-Peter Kriegel, Joerg Sander, Xiaowei Xu(1996).<br />
<em>A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</em><br />
Institute for Computer Science, University of Munich.<br />
<em>Proceedings of 2nd International Conference on Knowledge Discovery and Data Mining (KDD-96)</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code>cndkernmatrix</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple example using the iris
data(iris)
test &lt;- sample(1:150,20)
x&lt;- as.matrix(iris[-test,-5])
ds &lt;- qkdbscan (x,kernel="laplbase",qpar=list(sigma=3.5,q=0.8),eps=0.15,
MinPts=5,hybrid = FALSE)
plot(ds,x)
emb &lt;- predict(ds, x, as.matrix(iris[test,-5]))
points(iris[test,], col= as.integer(1+emb))

</code></pre>

<hr>
<h2 id='qkdbscan-class'>Class &quot;qkdbscan&quot;</h2><span id='topic+qkdbscan-class'></span><span id='topic+clust'></span><span id='topic+eps'></span><span id='topic+plot'></span><span id='topic+MinPts'></span><span id='topic+isseed'></span><span id='topic+clust+3C-'></span><span id='topic+eps+3C-'></span><span id='topic+MinPts+3C-'></span><span id='topic+isseed+3C-'></span><span id='topic+clust+2Cqkdbscan-method'></span><span id='topic+eps+2Cqkdbscan-method'></span><span id='topic+plot+2Cqkdbscan-method'></span><span id='topic+MinPts+2Cqkdbscan-method'></span><span id='topic+isseed+2Cqkdbscan-method'></span><span id='topic+clust+3C-+2Cqkdbscan-method'></span><span id='topic+eps+3C-+2Cqkdbscan-method'></span><span id='topic+MinPts+3C-+2Cqkdbscan-method'></span><span id='topic+isseed+3C-+2Cqkdbscan-method'></span>

<h3>Description</h3>

<p> The qkernel-DBSCAN class.</p>


<h3>Objects of class &quot;qkdbscan&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkdbscan", ...)</code>.
or by calling the <code>qkdbscan</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>clust</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the
cluster membership of the samples</p>
</dd>
<dt><code>eps</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
reachability distance</p>
</dd>
<dt><code>MinPts</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
reachability minimum number of points</p>
</dd>
<dt><code>isseed</code>:</dt><dd><p>Object of class <code>"logical"</code> containing the logical vector indicating
whether a point is a seed (not  border, not noise)</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>clust</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the cluster membership</p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the used kernel function</p>
</dd>
<dt>eps</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the reachability distance</p>
</dd>
<dt>MinPts</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the reachability minimum number of points</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "qkdbscan")</code>: embeds new data </p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkdbscan")</code>: returns the used data matrix </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a simple example using the iris data
x&lt;- as.matrix(iris[,-5])
ds &lt;- qkdbscan (x,kernel="laplbase",qpar=list(sigma=3.5,q=0.8),eps=0.15,
MinPts=5,hybrid = FALSE)
# print the results
clust(ds)
eps(ds)
MinPts(ds)
cndkernf(ds)
xmatrix(ds)
kcall(ds)

</code></pre>

<hr>
<h2 id='qkernel-class'>Class &quot;qkernel&quot; &quot;rbfqkernel&quot; &quot;nonlqkernel&quot; &quot;laplqkernel&quot; &quot;ratiqkernel&quot;</h2><span id='topic+qkernel-class'></span><span id='topic+qpar+2Cqkernel-method'></span><span id='topic+show+2Cqkernel-method'></span><span id='topic+rbfqkernel-class'></span><span id='topic+nonlqkernel-class'></span><span id='topic+laplqkernel-class'></span><span id='topic+ratiqkernel-class'></span><span id='topic+multqkernel-class'></span><span id='topic+invqkernel-class'></span><span id='topic+wavqkernel-class'></span><span id='topic+powqkernel-class'></span><span id='topic+logqkernel-class'></span><span id='topic+cauqkernel-class'></span><span id='topic+chiqkernel-class'></span><span id='topic+studqkernel-class'></span><span id='topic+kfunction-class'></span><span id='topic+input-class'></span>

<h3>Description</h3>

<p>The built-in kernel classes in <span class="pkg">qkerntool</span></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rbfqkernel")</code>,
<code>new{"nonlqkernel"}</code>, <code>new{"laplqkernel"}</code>,
<code>new{"ratiqkernel"}</code>, <code>new{"multqkernel"}</code>,
<code>new{"invqkernel"}</code>, <code>new{"wavqkernel"}</code>,
<code>new{"powqkernel"}</code>, <code>new{"logqkernel"}</code>,
<code>new{"cauqkernel"}</code>, <code>new{"chiqkernel"}</code>,
<code>new{"studqkernel"}</code>
</p>
<p>or by calling the <code>rbfbase</code>, <code>nonlbase</code>, <code>laplbase</code>, <code>ratibase</code>,
<code>multbase</code>, <code>invbase</code>, <code>wavbase</code>, <code>powbase</code>,
<code>logbase</code>, <code>caubase</code>, <code>chibase</code>, <code>studbase</code> functions etc..
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code> containing
the kernel function</p>
</dd>
<dt><code>qpar</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
kernel parameters </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>qkernmatrix</dt><dd><p><code>signature(kernel = "rbfqkernel", x =
	"matrix")</code>: computes the qkernel matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>,<code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>qkfunc &lt;- rbfbase(sigma=1,q=0.8)
qkfunc

qpar(qkfunc)

## create two vectors
x &lt;- rnorm(10)
y &lt;- rnorm(10)

## calculate dot product
qkfunc(x,y)

</code></pre>

<hr>
<h2 id='qkernmatrix'>qKernel Matrix functions</h2><span id='topic+qkernmatrix'></span><span id='topic+qkernmatrix+2Cqkernel-method'></span><span id='topic+qkernmatrix+2Crbfqkernel-method'></span><span id='topic+qkernmatrix+2Cnonlqkernel-method'></span><span id='topic+qkernmatrix+2Claplqkernel-method'></span><span id='topic+qkernmatrix+2Cratiqkernel-method'></span><span id='topic+qkernmatrix+2Cmultqkernel-method'></span><span id='topic+qkernmatrix+2Cinvqkernel-method'></span><span id='topic+qkernmatrix+2Cwavqkernel-method'></span><span id='topic+qkernmatrix+2Cpowqkernel-method'></span><span id='topic+qkernmatrix+2Clogqkernel-method'></span><span id='topic+qkernmatrix+2Ccauqkernel-method'></span><span id='topic+qkernmatrix+2Cchiqkernel-method'></span><span id='topic+qkernmatrix+2Cstudqkernel-method'></span><span id='topic+qkernmatrix.rbfqkernel'></span><span id='topic+qkernmatrix.nonlqkernel'></span><span id='topic+qkernmatrix.laplqkernel'></span><span id='topic+qkernmatrix.ratiqkernel'></span><span id='topic+qkernmatrix.multqkernel'></span><span id='topic+qkernmatrix.invqkernel'></span><span id='topic+qkernmatrix.wavqkernel'></span><span id='topic+qkernmatrix.powqkernel'></span><span id='topic+qkernmatrix.logqkernel'></span><span id='topic+qkernmatrix.cauqkernel'></span><span id='topic+qkernmatrix.chiqkernel'></span><span id='topic+qkernmatrix.studqkernel'></span>

<h3>Description</h3>

<p><code>qkernmatrix</code> calculates the qkernel matrix <code class="reqn">K_{ij} = k(x_i,x_j)</code> or <code class="reqn">K_{ij} =
    k(x_i,y_j)</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'qkernel'
qkernmatrix(qkernel, x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkernmatrix_+3A_qkernel">qkernel</code></td>
<td>
<p>the kernel function to be used to calculate the qkernel
matrix.
This has to be a function of class <code>qkernel</code>, i.e. which can be
generated either one of the build in
kernel generating functions (e.g., <code>rbfbase</code> etc.) or a user defined
function of class <code>qkernel</code> taking two vector arguments and returning a scalar.</p>
</td></tr>
<tr><td><code id="qkernmatrix_+3A_x">x</code></td>
<td>
<p>a data matrix to be used to calculate the kernel matrix</p>
</td></tr>
<tr><td><code id="qkernmatrix_+3A_y">y</code></td>
<td>
<p>second data matrix to calculate the kernel matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common functions used during kernel based computations.<br />
The <code>qkernel</code> parameter can be set to any function, of class
qkernel, which computes the kernel function value in feature space between two
vector arguments. <span class="pkg">qkerntool</span> provides more than 10 qkernel functions
which can be initialized by using the following
functions:
</p>

<ul>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>rbfbase</code>  Gaussian qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplacian qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code>  Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code>  Wave  qkernel function
</p>
</li>
<li> <p><code>powbase</code>  d qkernel function
</p>
</li>
<li> <p><code>logbase</code>  Log qkernel function
</p>
</li>
<li> <p><code>caubase</code>  Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code>  Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li></ul>
<p>  (see example.)
</p>


<h3>Value</h3>

<p><code>qkernmatrix</code> returns a conditionally negative definite matrix with a zero diagonal element.<br />
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlcnd">nonlcnd</a></code>, <code><a href="#topic+rbfcnd">rbfcnd</a></code>,<code><a href="#topic+polycnd">polycnd</a></code>,<code><a href="#topic+laplcnd">laplcnd</a></code>,
<code><a href="#topic+anocnd">anocnd</a></code>, <code><a href="#topic+raticnd">raticnd</a></code>, <code><a href="#topic+multcnd">multcnd</a></code>, <code><a href="#topic+invcnd">invcnd</a></code>,
<code><a href="#topic+wavcnd">wavcnd</a></code>, <code><a href="#topic+powcnd">powcnd</a></code>, <code><a href="#topic+logcnd">logcnd</a></code>, <code><a href="#topic+caucnd">caucnd</a></code>,
<code><a href="#topic+chicnd">chicnd</a></code>, <code><a href="#topic+studcnd">studcnd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
dt &lt;- as.matrix(iris[ ,-5])

## initialize kernel function
rbf &lt;- rbfbase(sigma = 1.4, q=0.8)
rbf

## calculate qkernel matrix
qkernmatrix(rbf, dt)


</code></pre>

<hr>
<h2 id='qkgda'>qKernel Generalized Discriminant Analysis</h2><span id='topic+qkgda'></span><span id='topic+qkgda+2Cmatrix-method'></span><span id='topic+qkgda+2Ccndkernmatrix-method'></span><span id='topic+qkgda+2Cqkernmatrix-method'></span><span id='topic+predict+2Cqkgda-method'></span>

<h3>Description</h3>

<p>The qkernel Generalized Discriminant Analysis is a method that deals with nonlinear discriminant analysis using kernel function operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkgda(x, label, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
          features = 0, th = 1e-4, na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qkgda(x, label, features = 0, th = 1e-4, na.action = na.omit, ...)
## S4 method for signature 'qkernmatrix'
qkgda(x, label, features = 0, th = 1e-4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkgda_+3A_x">x</code></td>
<td>
<p>the data matrix indexed by row, or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkgda_+3A_label">label</code></td>
<td>
<p>The original labels of the samples.</p>
</td></tr>
<tr><td><code id="qkgda_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkgda_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the Power qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the Power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkgda_+3A_features">features</code></td>
<td>
<p>Number of features (principal components) to
return. (default: 0 , all)</p>
</td></tr>
<tr><td><code id="qkgda_+3A_th">th</code></td>
<td>
<p>the value of the eigenvalue under which principal
components are ignored (only valid when features =  0). (default : 0.0001) </p>
</td></tr>
<tr><td><code id="qkgda_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkgda_+3A_...">...</code></td>
<td>
<p> additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qkernel Generalized Discriminant Analysis method provides a mapping of the input vectors into high dimensional feature space, generalizing the classical Linear Discriminant Analysis to non-linear discriminant analysis. <br />
The data can be passed to the <code>qkgda</code> function in a <code>matrix</code>, in addition <code>qkgda</code> also supports input in the form of a
kernel matrix of class <code>qkernmatrix</code> or class <code>cndkernmatrix</code>.
</p>


<h3>Value</h3>

<p>An S4 object containing the eigenvectors and their normalized projections, along with the
corresponding eigenvalues and the original function.
</p>
<table role = "presentation">
<tr><td><code>prj</code></td>
<td>
<p>The normalized projections on eigenvectors)</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>The corresponding eigenvalues</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>The corresponding eigenvectors</p>
</td></tr>
<tr><td><code>kcall</code></td>
<td>
<p>The formula of the function called</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>The kernel function used</p>
</td></tr>
<tr><td><code>xmatrix</code></td>
<td>
<p>The original data matrix</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Note</h3>

<p>The predict function can be used to embed new data on the new space</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>1.Baudat, G, and F. Anouar:<br />
<em>Generalized discriminant analysis using a kernel approach</em><br />
Neural Computation 12.10(2000),2385<br />
2.Deng Cai, Xiaofei He, and Jiawei Han:<br />
<em>Speed Up Kernel Discriminant Analysis</em><br />
The VLDB Journal,January,2011,vol.20, no.1,21-33.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Iris &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]), Sp = rep(c("1","2","3"), rep(50,3)))
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[-testset,-5])
test &lt;- as.matrix(iris[testset,-5])
Sp = rep(c("1","2","3"), rep(50,3))
labels &lt;-as.numeric(Sp)
trainlabel &lt;- labels[-testset]
testlabel &lt;- labels[testset]

kgda1 &lt;- qkgda(train, label=trainlabel, kernel = "ratibase", qpar = list(c=1,q=0.9),features = 2)

prj(kgda1)
eVal(kgda1)
eVec(kgda1)
kcall(kgda1)
# xmatrix(kgda1)

#print the principal component vectors
prj(kgda1)
#plot the data projection on the components
plot(kgda1@prj,col=as.integer(train), xlab="1st Principal Component",ylab="2nd Principal Component")

</code></pre>

<hr>
<h2 id='qkgda-class'>Class &quot;qkgda&quot;</h2><span id='topic+qkgda-class'></span><span id='topic+prj'></span><span id='topic+eVal'></span><span id='topic+eVec'></span><span id='topic+label'></span><span id='topic+prj+3C-'></span><span id='topic+eVal+3C-'></span><span id='topic+eVec+3C-'></span><span id='topic+label+3C-'></span><span id='topic+prj+2Cqkgda-method'></span><span id='topic+eVal+2Cqkgda-method'></span><span id='topic+eVec+2Cqkgda-method'></span><span id='topic+label+2Cqkgda-method'></span><span id='topic+prj+3C-+2Cqkgda-method'></span><span id='topic+eVal+3C-+2Cqkgda-method'></span><span id='topic+eVec+3C-+2Cqkgda-method'></span><span id='topic+label+3C-+2Cqkgda-method'></span>

<h3>Description</h3>

<p> The qkernel Generalized Discriminant Analysis class</p>


<h3>Objects of class &quot;qkgda&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkgda", ...)</code>.
or by calling the <code>qkgda</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prj</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the normalized projections on eigenvectors</p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the corresponding eigenvalues</p>
</dd>
<dt><code>eVec</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the corresponding eigenvectors</p>
</dd>
<dt><code>label</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the categorical variables that the categorical data be assigned to one of the categories</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>prj</dt><dd><p><code>signature(object = "qkgda")</code>: returns the normalized projections</p>
</dd>
<dt>eVal</dt><dd><p><code>signature(object = "qkgda")</code>: returns the eigenvalues</p>
</dd>
<dt>eVec</dt><dd><p><code>signature(object = "qkgda")</code>: returns the eigenvectors</p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkgda")</code>: returns the performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkgda")</code>: returns the used kernel function</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "qkgda")</code>: embeds new data</p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkgda")</code>: returns the used data matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Iris &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]), Sp = rep(c("1","2","3"), rep(50,3)))
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[-testset,-5])
test &lt;- as.matrix(iris[testset,-5])
Sp = rep(c("1","2","3"), rep(50,3))
labels &lt;-as.numeric(Sp)
trainlabel &lt;- labels[-testset]
testlabel &lt;- labels[testset]

kgda1 &lt;- qkgda(train, label=trainlabel, kernel = "ratibase", qpar = list(c=1,q=0.9),features = 2)

prj(kgda1)
eVal(kgda1)
eVec(kgda1)
cndkernf(kgda1)
kcall(kgda1)
</code></pre>

<hr>
<h2 id='qkIsomap'>
qKernel Isometric Feature Mapping
</h2><span id='topic+qkIsomap'></span><span id='topic+qkIsomap+2Cmatrix-method'></span><span id='topic+qkIsomap+2Ccndkernmatrix-method'></span><span id='topic+qkIsomap+2Cqkernmatrix-method'></span>

<h3>Description</h3>

<p>Computes the Isomap embedding as introduced in 2000 by Tenenbaum, de Silva and Langford.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkIsomap(x, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
dims = 2, k, mod = FALSE, plotResiduals = FALSE, verbose = TRUE, na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qkIsomap(x, dims = 2, k, mod = FALSE, plotResiduals = FALSE,
verbose = TRUE, na.action = na.omit, ...)

## S4 method for signature 'qkernmatrix'
qkIsomap(x, dims = 2, k, mod = FALSE, plotResiduals = FALSE,
verbose = TRUE, na.action = na.omit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkIsomap_+3A_x">x</code></td>
<td>

<p>N x D matrix (N samples, D features) or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the Power qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the Power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_dims">dims</code></td>
<td>
<p>vector containing the target space dimension(s)</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_k">k</code></td>
<td>
<p>	number of neighbours</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_mod">mod</code></td>
<td>
<p>	use modified Isomap algorithm</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_plotresiduals">plotResiduals</code></td>
<td>

<p>show a plot with the residuals between the high and the low dimensional data</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_verbose">verbose</code></td>
<td>
<p>show a summary of the embedding procedure at the end</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkIsomap_+3A_...">...</code></td>
<td>
<p> additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qkIsomap is a nonlinear dimension reduction technique, that preserves
global properties of the data. That means, that geodesic distances
between all samples are captured best in the low dimensional
embedding. <br />
This R version is based on the Matlab implementation by Tenenbaum and
uses Floyd's Algorithm to compute the neighbourhood graph of shortest
distances, when calculating the geodesic distances. <br />
A modified version of the original Isomap algorithm is included. It
respects nearest and farthest neighbours. <br />
To estimate the intrinsic dimension of the data, the function can plot
the residuals between the high and the low dimensional data for a
given range of dimensions.
</p>


<h3>Value</h3>

<p><code>qkIsomap</code> gives out an S4 object which is a LIST with components
</p>
<table role = "presentation">
<tr><td><code>prj</code></td>
<td>
<p>a N x dim matrix (N samples, dim features) with the reduced input data (list of several matrices if more than one dimension was specified). </p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>the dimension of the target space.</p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p>the residual variances for all dimensions.</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>the corresponding eigenvalues.</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>the corresponding eigenvectors.</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>the kernel function used.</p>
</td></tr>
<tr><td><code>kcall</code></td>
<td>
<p>The formula of the function called</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Tenenbaum, J. B. and de Silva, V. and Langford, J. C., &quot;A global geometric framework for nonlinear dimensionality reduction.&quot;, 2000;
Matlab code is available at http://waldron.stanford.edu/~isomap/
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # another example using the iris
  data(iris)
  testset &lt;- sample(1:150,20)
  train &lt;- as.matrix(iris[-testset,-5])
  labeltrain&lt;- as.integer(iris[-testset,5])
  test &lt;- as.matrix(iris[testset,-5])
  # ratibase(c=1,q=0.8)
  d_low = qkIsomap(train, kernel = "ratibase", qpar = list(c=1,q=0.8),
                    dims=2,  k=5, plotResiduals = TRUE)
  #plot the data projection on the components
  plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd  Principal Component")

  prj(d_low)
	dims(d_low)
	Residuals(d_low)
	eVal(d_low)
	eVec(d_low)
	kcall(d_low)
	cndkernf(d_low)
</code></pre>

<hr>
<h2 id='qkIsomap-class'>qKernel Isomap embedding</h2><span id='topic+qkIsomap-class'></span><span id='topic+dims'></span><span id='topic+connum'></span><span id='topic+Residuals'></span><span id='topic+dims+3C-'></span><span id='topic+connum+3C-'></span><span id='topic+Residuals+3C-'></span><span id='topic+prj+2CqkIsomap-method'></span><span id='topic+dims+2CqkIsomap-method'></span><span id='topic+connum+2CqkIsomap-method'></span><span id='topic+Residuals+2CqkIsomap-method'></span><span id='topic+eVal+2CqkIsomap-method'></span><span id='topic+eVec+2CqkIsomap-method'></span><span id='topic+prj+3C-+2CqkIsomap-method'></span><span id='topic+dims+3C-+2CqkIsomap-method'></span><span id='topic+connum+3C-+2CqkIsomap-method'></span><span id='topic+Residuals+3C-+2CqkIsomap-method'></span><span id='topic+eVal+3C-+2CqkIsomap-method'></span><span id='topic+eVec+3C-+2CqkIsomap-method'></span>

<h3>Description</h3>

<p>The qKernel Isometric Feature Mapping class</p>


<h3>Objects of class &quot;qkIsomap&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkIsomap", ...)</code>.
or by calling the <code>qkIsomap</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prj</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the Nxdim matrix (N samples, dim features) with the reduced input data (list of several matrices if more than one dimension specified)</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
dimension of the target space (default 2)</p>
</dd>
<dt><code>connum</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the number of connected components in graph</p>
</dd>
<dt><code>Residuals</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the
residual variances for all dimensions</p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the corresponding eigenvalues</p>
</dd>
<dt><code>eVec</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the corresponding eigenvectors </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>prj</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the Nxdim
matrix (N samples, dim features) </p>
</dd>
<dt>dims</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the
dimension </p>
</dd>
<dt>Residuals</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the
residual variances </p>
</dd>
<dt>eVal</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the
eigenvalues</p>
</dd>
<dt>eVec</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the
eigenvectors </p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the used
data matrix </p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkIsomap")</code>: returns the
performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkIsomapa")</code>: returns the used
kernel function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>,
<code><a href="#topic+qkIsomap">qkIsomap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # another example using the iris data
  data(iris)
  testset &lt;- sample(1:150,20)
  train &lt;- as.matrix(iris[-testset,-5])
  labeltrain&lt;- as.integer(iris[-testset,5])
  test &lt;- as.matrix(iris[testset,-5])
  # ratibase(c=1,q=0.8)
  d_low = qkIsomap(train, kernel = "ratibase", qpar = list(c=1,q=0.8),
                    dims=2,  k=5, plotResiduals = TRUE)
  #plot the data projection on the components
  plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd  Principal Component")

  prj(d_low)
	dims(d_low)
	Residuals(d_low)
	eVal(d_low)
	eVec(d_low)
	kcall(d_low)
	cndkernf(d_low)
</code></pre>

<hr>
<h2 id='qkLLE'>qKernel Locally Linear Embedding</h2><span id='topic+qkLLE'></span><span id='topic+qkLLE+2Cmatrix-method'></span><span id='topic+qkLLE+2Ccndkernmatrix-method'></span><span id='topic+qkLLE+2Cqkernmatrix-method'></span>

<h3>Description</h3>

<p>Computes the qkernel Locally Linear Embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkLLE(x, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
                         dims = 2, k, na.action = na.omit, ...)
## S4 method for signature 'cndkernmatrix'
qkLLE(x, dims = 2, k, na.action = na.omit, ...)
## S4 method for signature 'qkernmatrix'
qkLLE(x, dims = 2, k, na.action = na.omit,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkLLE_+3A_x">x</code></td>
<td>

<p>N x D matrix (N samples, D features) or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the Power qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>power, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>power, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>power</code> for the Power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_dims">dims</code></td>
<td>
<p>dimension of the target space</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_k">k</code></td>
<td>
<p>the number of nearest neighbours.</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkLLE_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qkernel Locally Linear Embedding (qkLLE) preserves local properties of the data by
representing each sample in the data by a linear combination of
its k nearest neighbours with each neighbour weighted
independently. qkLLE finally chooses the low-dimensional
representation that best preserves the weights in the target
space. It is an extension of Locally Linear Embedding (LLE) with qkernel method. <br />
</p>


<h3>Value</h3>

<p>It returns an S4 object containing the principal component vectors along with the
corresponding eigenvalues.
</p>
<table role = "presentation">
<tr><td><code>prj</code></td>
<td>
<p>a matrix with the reduced input data</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>dimension of the target space</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>The corresponding eigenvalues</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>The corresponding eigenvectors</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>the kernel function used</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Roweis, Sam T. and Saul, Lawrence K., &quot;Nonlinear Dimensionality Reduction by Locally Linear Embedding&quot;,2000;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
data(iris)
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[-testset,-5])
labeltrain&lt;- as.integer(iris[-testset,5])
test &lt;- as.matrix(iris[testset,-5])
plot(train ,col=labeltrain, xlab="1st Principal Component",ylab="2nd Principal Component")
# ratibase(c=1,q=0.8)
d_low &lt;- qkLLE(train, kernel = "ratibase", qpar = list(c=1,q=0.8), dims=2, k=5)
#plot the data projection on the components
plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd Principal Component")

## S4 method for signature 'qkernmatrix'
# ratibase(c=0.1,q=0.8)
qkfunc &lt;- ratibase(c=0.1,q=0.8)
ktrain1 &lt;- qkernmatrix(qkfunc,train)
d_low &lt;- qkLLE(ktrain1, dims = 2, k=5)
#plot the data projection on the components
plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd Principal Component")
</code></pre>

<hr>
<h2 id='qkLLE-class'>Class &quot;qkLLE&quot;</h2><span id='topic+qkLLE-class'></span><span id='topic+prj+2CqkLLE-method'></span><span id='topic+dims+2CqkLLE-method'></span><span id='topic+eVal+2CqkLLE-method'></span><span id='topic+eVec+2CqkLLE-method'></span><span id='topic+prj+3C-+2CqkLLE-method'></span><span id='topic+dims+3C-+2CqkLLE-method'></span><span id='topic+eVal+3C-+2CqkLLE-method'></span><span id='topic+eVec+3C-+2CqkLLE-method'></span>

<h3>Description</h3>

<p> The qKernel Locally Linear Embedding class</p>


<h3>Objects of class &quot;qkLLE&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkLLE", ...)</code>.
or by calling the <code>qkLLE</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prj</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the reduced input data</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
dimension of the target space (default 2)</p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the corresponding eigenvalues</p>
</dd>
<dt><code>eVec</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the corresponding eigenvectors</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>prj</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the reduced input data</p>
</dd>
<dt>dims</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the 
dimension </p>
</dd>
<dt>eVal</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the 
eigenvalues</p>
</dd>
<dt>eVec</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the 
eigenvectors </p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the used
data matrix </p>
</dd>  
<dt>kcall</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the
performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkLLE")</code>: returns the used
kernel function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>, 
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## S4 method for signature 'matrix'
data(iris)
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[-testset,-5])
labeltrain&lt;- as.integer(iris[-testset,5])
test &lt;- as.matrix(iris[testset,-5])
plot(train ,col=labeltrain, xlab="1st Principal Component",ylab="2nd Principal Component")
# ratibase(c=1,q=0.8)
d_low &lt;- qkLLE(train, kernel = "ratibase", qpar = list(c=1,q=0.8), dims=2, k=5)
#plot the data projection on the components
plot(prj(d_low),col=labeltrain,xlab="1st Principal Component",ylab="2nd Principal Component")

## S4 method for signature 'qkernmatrix'
# ratibase(c=0.1,q=0.8)
qkfunc &lt;- ratibase(c=0.1,q=0.8)
ktrain1 &lt;- qkernmatrix(qkfunc,train)
d_low &lt;- qkLLE(ktrain1, dims = 2, k=5)
#plot the data projection on the components
plot(prj(d_low),col=labeltrain,xlab="1st Principal Component",ylab="2nd Principal Component")
  </code></pre>

<hr>
<h2 id='qkMDS'>
qKernel Metric Multi-Dimensional Scaling
</h2><span id='topic+qkMDS'></span><span id='topic+qkMDS+2Cmatrix-method'></span><span id='topic+qkMDS+2Ccndkernmatrix-method'></span><span id='topic+qkMDS+2Cqkernmatrix-method'></span>

<h3>Description</h3>

<p>The qkernel Metric Multi-Dimensional Scaling is a nonlinear form of Metric Multi-Dimensional Scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkMDS(x, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
dims = 2, plotResiduals = FALSE, verbose = TRUE, na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qkMDS(x, dims = 2,plotResiduals = FALSE,
verbose = TRUE, na.action = na.omit, ...)

## S4 method for signature 'qkernmatrix'
qkMDS(x, dims = 2,plotResiduals = FALSE,
verbose = TRUE, na.action = na.omit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkMDS_+3A_x">x</code></td>
<td>

<p>N x D matrix (N samples, D features) or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the Power qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the Power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_dims">dims</code></td>
<td>
<p>vector containing the target space dimension(s)</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_plotresiduals">plotResiduals</code></td>
<td>

<p>show a plot with the residuals between the high and the low dimensional data</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_verbose">verbose</code></td>
<td>
<p>show a summary of the embedding procedure at the end</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkMDS_+3A_...">...</code></td>
<td>
<p> additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several versions of non-metric multidimensional
scaling in <span class="rlang"><b>R</b></span>, but <span class="pkg">qkerntool</span> offers the following unique
combination of using qKernel methods</p>


<h3>Value</h3>

<p><code>qkMDS</code> gives out an S4 object which is a LIST with components
</p>
<table role = "presentation">
<tr><td><code>prj</code></td>
<td>
<p>a N x dim matrix (N samples, dim features) with the reduced input data (list of several matrices if more than one dimension was specified). </p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>the dimension of the target space.</p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p>the residual variances for all dimensions.</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>the corresponding eigenvalues.</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>the corresponding eigenvectors.</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>the kernel function used.</p>
</td></tr>
<tr><td><code>kcall</code></td>
<td>
<p>The formula of the function called</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Kruskal, J.B. 1964a. Multidimensional scaling by optimizing
goodness-of-fit to a nonmetric hypothesis. <em>Psychometrika</em>
29, 1&ndash;28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # another example using the iris
  data(iris)
  testset &lt;- sample(1:150,20)
  train &lt;- as.matrix(iris[-testset,-5])
  labeltrain&lt;- as.integer(iris[-testset,5])
  test &lt;- as.matrix(iris[testset,-5])
  # ratibase(c=1,q=0.8)
  d_low = qkMDS(train, kernel = "ratibase", qpar = list(c=1,q=0.9),dims = 2,
                 plotResiduals = TRUE)
  #plot the data projection on the components
  plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd  Principal Component")

  prj(d_low)
	dims(d_low)
	Residuals(d_low)
	eVal(d_low)
	eVec(d_low)
	kcall(d_low)
	cndkernf(d_low)
</code></pre>

<hr>
<h2 id='qkMDS-class'>qKernel Metric Multi-Dimensional Scaling</h2><span id='topic+qkMDS-class'></span><span id='topic+prj+2CqkMDS-method'></span><span id='topic+dims+2CqkMDS-method'></span><span id='topic+connum+2CqkMDS-method'></span><span id='topic+Residuals+2CqkMDS-method'></span><span id='topic+eVal+2CqkMDS-method'></span><span id='topic+eVec+2CqkMDS-method'></span><span id='topic+prj+3C-+2CqkMDS-method'></span><span id='topic+dims+3C-+2CqkMDS-method'></span><span id='topic+connum+3C-+2CqkMDS-method'></span><span id='topic+Residuals+3C-+2CqkMDS-method'></span><span id='topic+eVal+3C-+2CqkMDS-method'></span><span id='topic+eVec+3C-+2CqkMDS-method'></span>

<h3>Description</h3>

<p>The qkernel Metric Multi-Dimensional Scaling class</p>


<h3>Objects of class &quot;qkMDS&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkMDS", ...)</code>.
or by calling the <code>qkMDS</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prj</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the Nxdim matrix (N samples, dim features) with the reduced input data (list of         several matrices if more than one dimension specified)</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the
dimension of the target space (default 2)</p>
</dd>
<dt><code>connum</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the number of connected components in graph</p>
</dd>
<dt><code>Residuals</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the
residual variances for all dimensions</p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the corresponding eigenvalues</p>
</dd>
<dt><code>eVec</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the corresponding eigenvectors </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>prj</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the Nxdim
matrix (N samples, dim features) </p>
</dd>
<dt>dims</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the
dimension </p>
</dd>
<dt>Residuals</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the
residual variances </p>
</dd>
<dt>eVal</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the
eigenvalues</p>
</dd>
<dt>eVec</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the
eigenvectors </p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the used
data matrix </p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the
performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkMDS")</code>: returns the used
kernel function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>,
<code><a href="#topic+qkMDS">qkMDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # another example using the iris
  data(iris)
  testset &lt;- sample(1:150,20)
  train &lt;- as.matrix(iris[-testset,-5])
  labeltrain&lt;- as.integer(iris[-testset,5])
  test &lt;- as.matrix(iris[testset,-5])
  # ratibase(c=1,q=0.8)
  d_low = qkMDS(train, kernel = "ratibase", qpar = list(c=1,q=0.8),
                    dims=2, plotResiduals = TRUE)
  #plot the data projection on the components
  plot(prj(d_low),col=labeltrain, xlab="1st Principal Component",ylab="2nd  Principal Component")

  prj(d_low)
	dims(d_low)
	Residuals(d_low)
	eVal(d_low)
	eVec(d_low)
	kcall(d_low)
	cndkernf(d_low)
</code></pre>

<hr>
<h2 id='qkpca'>qKernel Principal Components Analysis</h2><span id='topic+qkpca'></span><span id='topic+qkpca+2Cformula-method'></span><span id='topic+qkpca+2Cmatrix-method'></span><span id='topic+qkpca+2Ccndkernmatrix-method'></span><span id='topic+qkpca+2Cqkernmatrix-method'></span><span id='topic+predict+2Cqkpca-method'></span>

<h3>Description</h3>

<p>The qkernel Principal Components Analysis is a nonlinear form of principal
component analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'formula'
qkpca(x, data = NULL, na.action, ...)
## S4 method for signature 'matrix'
qkpca(x, kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
                        features = 0, th = 1e-4, na.action = na.omit, ...)
## S4 method for signature 'cndkernmatrix'
qkpca(x, features = 0, th = 1e-4, ...)
## S4 method for signature 'qkernmatrix'
qkpca(x, features = 0, th = 1e-4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkpca_+3A_x">x</code></td>
<td>
<p>the data matrix indexed by row, a formula describing the
model or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkpca_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in
the model (when using a formula).</p>
</td></tr>
<tr><td><code id="qkpca_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a  kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> d qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkpca_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the d qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the power cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkpca_+3A_features">features</code></td>
<td>
<p>Number of features (principal components) to
return. (default: 0 , all)</p>
</td></tr>
<tr><td><code id="qkpca_+3A_th">th</code></td>
<td>
<p>the value of the eigenvalue under which principal
components are ignored (only valid when features =  0). (default : 0.0001) </p>
</td></tr>
<tr><td><code id="qkpca_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qkpca_+3A_...">...</code></td>
<td>
<p> additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using kernel functions one can efficiently compute
principal components in high-dimensional
feature spaces, related to input space by some non-linear map.<br />
The data can be passed to the <code>qkpca</code> function in a <code>matrix</code>, in addition <code>qkpca</code> also supports input in the form of a
kernel matrix of class <code>qkernmatrix</code> or class <code>cndkernmatrix</code>.
</p>


<h3>Value</h3>

<p>An S4 object containing the principal component vectors along with the
corresponding eigenvalues.
</p>
<table role = "presentation">
<tr><td><code>pcv</code></td>
<td>
<p>a matrix containing the principal component vectors (column
wise)</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>The corresponding eigenvalues</p>
</td></tr>
<tr><td><code>rotated</code></td>
<td>
<p>The original data projected (rotated) on the principal components</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>the kernel function used</p>
</td></tr>
<tr><td><code>xmatrix</code></td>
<td>
<p>The original data matrix</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Note</h3>

<p>The predict function can be used to embed new data on the new space</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Schoelkopf B., A. Smola, K.-R. Mueller :<br />
<em>Nonlinear component analysis as a kernel eigenvalue problem</em><br />
Neural Computation 10, 1299-1319<br />
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.1366">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.1366</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># another example using the iris data
data(iris)
test &lt;- sample(1:150,20)
qkpc &lt;- qkpca(~.,data=iris[-test,-5],kernel="rbfbase",
              qpar=list(sigma=50,q=0.8),features=2)

# print the principal component vectors
pcv(qkpc)
#plot the data projection on the components
plot(rotated(qkpc),col=as.integer(iris[-test,5]),
     xlab="1st Principal Component",ylab="2nd Principal Component")

# embed remaining points
emb &lt;- predict(qkpc,iris[test,-5])
points(emb,col=as.integer(iris[test,5]))
</code></pre>

<hr>
<h2 id='qkpca-class'>Class &quot;qkpca&quot;</h2><span id='topic+qkpca-class'></span><span id='topic+rotated'></span><span id='topic+rotated+3C-'></span><span id='topic+pcv'></span><span id='topic+pcv+3C-'></span><span id='topic+eVal+2Cqkpca-method'></span><span id='topic+pcv+2Cqkpca-method'></span><span id='topic+rotated+2Cqkpca-method'></span><span id='topic+eVal+3C-+2Cqkpca-method'></span><span id='topic+pcv+3C-+2Cqkpca-method'></span><span id='topic+rotated+3C-+2Cqkpca-method'></span>

<h3>Description</h3>

<p> The qkernel Principal Components Analysis class</p>


<h3>Objects of class &quot;qkpca&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qkpca", ...)</code>.
or by calling the <code>qkpca</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pcv</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the
principal component vectors </p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the
corresponding eigenvalues</p>
</dd>
<dt><code>rotated</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the
projection of the data on the principal components</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>eVal</dt><dd><p><code>signature(object = "qkpca")</code>: returns the eigenvalues </p>
</dd>
<dt>pcv</dt><dd><p><code>signature(object = "qkpca")</code>: returns the principal
component vectors </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "qkpca")</code>: embeds new data </p>
</dd>
<dt>rotated</dt><dd><p><code>signature(object = "qkpca")</code>: returns the
projected data</p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkpca")</code>: returns the used
data matrix </p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkpca")</code>: returns the
performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkpca")</code>: returns the used
kernel function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # another example using the iris data
  data(iris)
  test &lt;- sample(1:150,20)
  qkpc &lt;- qkpca(~.,iris[-test,-5], kernel = "rbfbase",
                qpar = list(sigma = 50, q = 0.8), features = 2)

  # print the principal component vectors
  pcv(qkpc)
  rotated(qkpc)
  cndkernf(qkpc)
  eVal(qkpc)
  xmatrix(qkpc)
  names(eVal(qkpc))
</code></pre>

<hr>
<h2 id='qkprc-class'>Class &quot;qkprc&quot;</h2><span id='topic+qkprc-class'></span><span id='topic+cndkernf'></span><span id='topic+qpar'></span><span id='topic+xmatrix'></span><span id='topic+ymatrix'></span><span id='topic+kcall'></span><span id='topic+terms'></span><span id='topic+n.action'></span><span id='topic+cndkernf+3C-'></span><span id='topic+qpar+3C-'></span><span id='topic+xmatrix+3C-'></span><span id='topic+ymatrix+3C-'></span><span id='topic+kcall+3C-'></span><span id='topic+terms+3C-'></span><span id='topic+n.action+3C-'></span><span id='topic+cndkernf+2Cqkprc-method'></span><span id='topic+qpar+2Cqkprc-method'></span><span id='topic+xmatrix+2Cqkprc-method'></span><span id='topic+ymatrix+2Cqkprc-method'></span><span id='topic+kcall+2Cqkprc-method'></span><span id='topic+terms+2Cqkprc-method'></span><span id='topic+n.action+2Cqkprc-method'></span><span id='topic+cndkernf+3C-+2Cqkprc-method'></span><span id='topic+qpar+3C-+2Cqkprc-method'></span><span id='topic+xmatrix+3C-+2Cqkprc-method'></span><span id='topic+ymatrix+3C-+2Cqkprc-method'></span><span id='topic+kcall+3C-+2Cqkprc-method'></span><span id='topic+terms+3C-+2Cqkprc-method'></span><span id='topic+n.action+3C-+2Cqkprc-method'></span>

<h3>Description</h3>

<p>The qKernel Prehead class</p>


<h3>Objects of class &quot;qkprc&quot;</h3>

<p>Objects from the class cannot be created directly but only contained
in other classes.</p>


<h3>Slots</h3>


<dl>
<dt><code>cndkernf</code>:</dt><dd><p>Object of class <code>"kfunction"</code> containing
the kernel function used</p>
</dd>
<dt><code>qpar</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
kernel parameters used </p>
</dd>
<dt><code>xmatrix</code>:</dt><dd><p>Object of class <code>"input"</code> containing
the data matrix used </p>
</dd>
<dt><code>ymatrix</code>:</dt><dd><p>Object of class <code>"input"</code> containing
the data matrix used </p>
</dd>
<dt><code>kcall</code>:</dt><dd><p>Object of class <code>"ANY"</code> containing the
function call </p>
</dd>
<dt><code>terms</code>:</dt><dd><p>Object of class <code>"ANY"</code> containing the
function terms </p>
</dd>
<dt><code>n.action</code>:</dt><dd><p>Object of class <code>"ANY"</code> containing the
action performed on NA </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkprc")</code>: returns the used
kernel function</p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkprc")</code>: returns the used
data matrix </p>
</dd>
<dt>ymatrix</dt><dd><p><code>signature(object = "qkprc")</code>: returns the used
data matrix </p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkprc")</code>: returns the
performed call</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>
</p>

<hr>
<h2 id='qkspecc'>qkernel spectral Clustering</h2><span id='topic+qkspecc'></span><span id='topic+qkspecc+2Cmatrix-method'></span><span id='topic+qkspecc+2Cqkernmatrix-method'></span><span id='topic+qkspecc+2Ccndkernmatrix-method'></span><span id='topic+show+2Cqkspecc-method'></span>

<h3>Description</h3>

<p>A qkernel spectral clustering algorithm. Clustering is performed by
embedding the data into the subspace of the eigenvectors
of a graph Laplacian matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
qkspecc(x,kernel = "rbfbase", qpar = list(sigma = 2, q = 0.9),
          Nocent=NA, normalize="symmetric", maxk=20, iterations=200,
          na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qkspecc(x, Nocent=NA, normalize="symmetric",
          maxk=20,iterations=200, ...)

## S4 method for signature 'qkernmatrix'
qkspecc(x, Nocent=NA, normalize="symmetric",
          maxk=20,iterations=200, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkspecc_+3A_x">x</code></td>
<td>
<p>the matrix of data to be clustered or a kernel Matrix of class
<code>qkernmatrix</code> or <code>cndkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in computing the affinity matrix.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. kernlab provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> d qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> d cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_qpar">qpar</code></td>
<td>
<p>a character string or the list of hyper-parameters (kernel parameters).
The default character string <code>list(sigma = 2, q = 0.9)</code> uses a heuristic to determine a
suitable value for the width parameter of the RBF kernel.
The second option <code>"local"</code> (local scaling) uses a more advanced heuristic
and sets a width parameter for every point in the data set. This is
particularly useful when the data incorporates multiple scales.
A list can also be used containing the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the d qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the d cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
where length is the length of the strings considered, lambda the
decay factor and normalized a logical parameter determining if the
kernel evaluations should be normalized.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_nocent">Nocent</code></td>
<td>
<p>the number of clusters.</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_normalize">normalize</code></td>
<td>
<p>Normalisation of the Laplacian (&quot;none&quot;, &quot;symmetric&quot; or &quot;random-walk&quot;).</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_maxk">maxk</code></td>
<td>
<p>If k is NA, an upper bound for the automatic estimation. Defaults to 20.</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_iterations">iterations</code></td>
<td>
<p>the maximum number of iterations allowed. </p>
</td></tr>
<tr><td><code id="qkspecc_+3A_na.action">na.action</code></td>
<td>
<p>the action to perform on NA.</p>
</td></tr>
<tr><td><code id="qkspecc_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qkernel spectral clustering  works by embedding the data points of the
partitioning problem into the subspace of the eigenvectors corresponding to the <code class="reqn">k</code>
smallest eigenvalues of the graph Laplacian matrix. Using a simple clustering method like
<code>kmeans</code> on the embedded points usually leads to good performance. It can be shown that
qkernel spectral clustering methods boil down to  graph partitioning.<br />
The data can be passed to the <code>qkspecc</code> function in a <code>matrix</code>,
in addition <code>qkspecc</code> also supports input in the form of a
kernel matrix of class <code>qkernmatrix</code> or <code>cndkernmatrix</code>.
</p>


<h3>Value</h3>

<p>An S4 object of class <code>qkspecc</code> which extends the class <code>vector</code>
containing integers indicating the cluster to which
each point is allocated. The following slots contain useful information
</p>
<table role = "presentation">
<tr><td><code>clust</code></td>
<td>
<p>The cluster assignments</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>The corresponding eigenvector</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>The corresponding eigenvalues</p>
</td></tr>
<tr><td><code>ymatrix</code></td>
<td>
<p>The eigenvectors corresponding to the <code class="reqn">k</code> smallest eigenvalues
of the graph Laplacian matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yusen Zhang <br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a>
</p>


<h3>References</h3>

<p>Andrew Y. Ng, Michael I. Jordan, Yair Weiss<br />
<em>On Spectral Clustering: Analysis and an Algorithm</em><br />
Neural Information Processing Symposium 2001<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code>, <code><a href="#topic+qkpca">qkpca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
x=as.matrix(iris[,-5])

qspe &lt;- qkspecc(x,kernel = "rbfbase", qpar = list(sigma = 10, q = 0.9),
                Nocent=3, normalize="symmetric", maxk=15, iterations=1200)
plot(x, col = clust(qspe))

qkfunc &lt;- nonlbase(alpha=1/15,q=0.8)
Ktrain &lt;- qkernmatrix(qkfunc, x)
qspe &lt;- qkspecc(Ktrain, Nocent=3, normalize="symmetric", maxk=20)
plot(x, col = clust(qspe))
</code></pre>

<hr>
<h2 id='qkspecc-class'>Class &quot;qkspecc&quot;</h2><span id='topic+qkspecc-class'></span><span id='topic+withinss'></span><span id='topic+withinss+3C-'></span><span id='topic+clust+2Cqkspecc-method'></span><span id='topic+eVec+2Cqkspecc-method'></span><span id='topic+eVal+2Cqkspecc-method'></span><span id='topic+withinss+2Cqkspecc-method'></span><span id='topic+plot+2Cqkspecc-method'></span><span id='topic+clust+3C-+2Cqkspecc-method'></span><span id='topic+eVec+3C-+2Cqkspecc-method'></span><span id='topic+eVal+3C-+2Cqkspecc-method'></span><span id='topic+withinss+3C-+2Cqkspecc-method'></span>

<h3>Description</h3>

<p> The qKernel Spectral Clustering Class</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("qkspecc", ...)</code>.
or by calling the function <code>qkspecc</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>clust</code>:</dt><dd><p>Object of class <code>"vector"</code> containing the cluster assignments</p>
</dd>
<dt><code>eVec</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing
the corresponding eigenvector in each  cluster</p>
</dd>
<dt><code>eVal</code>:</dt><dd><p>Object of class <code>"vector"</code> containing
the corresponding eigenvalue for each cluster</p>
</dd>
<dt><code>withinss</code>:</dt><dd><p>Object of class <code>"vector"</code> containing
the within-cluster sum of squares for each cluster</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>clust</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the cluster assignments</p>
</dd>
<dt>eVec</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the corresponding eigenvector in each  cluster</p>
</dd>
<dt>eVal</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the corresponding eigenvalue for each cluster </p>
</dd>
<dt>xmatrix</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the original data matrix or a kernel Matrix </p>
</dd>
<dt>ymatrix</dt><dd><p><code>signature(object = "qkspecc")</code>: returns The eigenvectors corresponding to the <code class="reqn">k</code> smallest eigenvalues of the graph Laplacian matrix. </p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the used kernel function</p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qkspecc")</code>: returns the performed call</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qkspecc">qkspecc</a></code>, <code><a href="#topic+qkernel-class">qkernel-class</a></code>,
<code><a href="#topic+cndkernel-class">cndkernel-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cluster the iris data set.
data("iris")
x=as.matrix(iris[,-5])

qspe &lt;- qkspecc(x,kernel = "rbfbase", qpar = list(sigma = 10, q = 0.9),
                Nocent=3, normalize="symmetric", maxk=15, iterations=1200)
clust(qspe)
eVec(qspe)
eVal(qspe)
xmatrix(qspe)
ymatrix(qspe)
cndkernf(qspe)
</code></pre>

<hr>
<h2 id='qkspeclust'>qkernel spectral Clustering</h2><span id='topic+qkspeclust'></span><span id='topic+qkspeclust+2Cqkspecc-method'></span>

<h3>Description</h3>

<p>This is also a qkernel spectral clustering algorithm which uses three ways to assign labels after the laplacian embedding: kmeans, hclust and dbscan.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'qkspecc'
qkspeclust(x, clustmethod = "kmeans",
         Nocent=NULL,iterations=NULL, hmethod=NULL,eps = NULL, MinPts = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkspeclust_+3A_x">x</code></td>
<td>
<p>object of class <code>qkspecc</code>.</p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_clustmethod">clustmethod</code></td>
<td>
<p>the strategy to use to assign labels in the embedding space.
There are three ways to assign labels after the laplacian embedding: kmeans, hclust and dbscan. </p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_nocent">Nocent</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_iterations">iterations</code></td>
<td>
<p>the maximum number of iterations allowed for &quot;kmeans&quot;. </p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_hmethod">hmethod</code></td>
<td>
<p>the agglomeration method for &quot;hclust&quot;. This should be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_eps">eps</code></td>
<td>
<p>Reachability distance for &quot;dbscan&quot;.</p>
</td></tr>
<tr><td><code id="qkspeclust_+3A_minpts">MinPts</code></td>
<td>
<p>Reachability minimum no. of points for &quot;dbscan&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qkernel spectral clustering  works by embedding the data points of the
partitioning problem into the subspace of the eigenvectors corresponding to the
<code class="reqn">k</code> smallest eigenvalues of the graph Laplacian matrix.
Using the simple clustering methods like <code>kmeans</code>, <code>hclust</code> and <code>dbscan</code>
on the embedded points usually leads to good performance. It can be shown that
qkernel spectral clustering methods boil down to graph partitioning.<br />
</p>


<h3>Value</h3>

<p>An S4 object of class <code>qkspecc</code> which extends the class <code>vector</code>
containing integers indicating the cluster to which
each point is allocated. The following slots contain useful information
</p>
<table role = "presentation">
<tr><td><code>clust</code></td>
<td>
<p>The cluster assignments</p>
</td></tr>
<tr><td><code>eVec</code></td>
<td>
<p>The corresponding eigenvector</p>
</td></tr>
<tr><td><code>eVal</code></td>
<td>
<p>The corresponding eigenvalues</p>
</td></tr>
<tr><td><code>xmatrix</code></td>
<td>
<p>The original data matrix</p>
</td></tr>
<tr><td><code>ymatrix</code></td>
<td>
<p>The real valued matrix of eigenvectors corresponding to the k smallest eigenvalues of the graph Laplacian matrix</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>The kernel function used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yusen Zhang <br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a>
</p>


<h3>References</h3>

<p>Andrew Y. Ng, Michael I. Jordan, Yair Weiss<br />
<em>On Spectral Clustering: Analysis and an Algorithm</em><br />
Neural Information Processing Symposium 2001<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code>, <code><a href="#topic+qkspecc-class">qkspecc-class</a></code>, <code><a href="#topic+qkspecc">qkspecc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
x=as.matrix(iris[ ,-5])

qspe &lt;- qkspecc(x,kernel = "rbfbase", qpar = list(sigma = 90, q = 0.9),
                Nocent=3, normalize="symmetric", maxk=15,iterations=1200)
plot(x, col = clust(qspe))

qspec &lt;- qkspeclust(qspe,clustmethod = "hclust", Nocent=3, hmethod="ward.D2")
plot(x, col = clust(qspec))
plot(qspec)

</code></pre>

<hr>
<h2 id='qsammon'>qKernel Sammon Mapping</h2><span id='topic+qsammon'></span><span id='topic+qsammon+2Cmatrix-method'></span><span id='topic+qsammon+2Ccndkernmatrix-method'></span><span id='topic+qsammon+2Cqkernmatrix-method'></span>

<h3>Description</h3>

<p>The qkernel Sammon Mapping is an implementation for Sammon mapping, one of the earliest
dimension reduction techniques that aims to find low-dimensional embedding
that preserves pairwise distance structure in high-dimensional data space.
qsammon is a nonlinear form of Sammon Mapping.</p>


<h3>Usage</h3>

<pre><code class='language-R'>

## S4 method for signature 'matrix'
qsammon(x, kernel = "rbfbase", qpar = list(sigma = 0.5, q = 0.9),
          dims = 2, Initialisation = 'random', MaxHalves = 20,
          MaxIter = 500, TolFun = 1e-7, na.action = na.omit, ...)

## S4 method for signature 'cndkernmatrix'
qsammon(cndkernel, x, k, dims = 2, Initialisation = 'random',
          MaxHalves = 20,MaxIter = 500, TolFun = 1e-7, ...)

## S4 method for signature 'qkernmatrix'
qsammon(qkernel, x, k, dims = 2, Initialisation = 'random',
          MaxHalves = 20, MaxIter = 500, TolFun = 1e-7, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qsammon_+3A_x">x</code></td>
<td>
<p>the data matrix indexed by row or a kernel matrix of <code>cndkernmatrix</code> or <code>qkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qsammon_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. qkerntool provides the most popular kernel functions
which can be used by setting the kernel parameter to the following
strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> d qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> d cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qsammon_+3A_qpar">qpar</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters).
This is a list which contains the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma, q</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; and the Cauchy qkernel function &quot;caubase&quot;.
</p>
</li>
<li> <p><code>alpha, q</code> for the Non Linear qkernel function &quot;nonlbase&quot;.
</p>
</li>
<li> <p><code>c, q</code> for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot; and the Inverse Multiquadric qkernel function &quot;invbase&quot;.
</p>
</li>
<li> <p><code>theta, q</code> for the Wave qkernel function &quot;wavbase&quot;.
</p>
</li>
<li> <p><code>d, q</code> for the d qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot; and the Generalized T-Student qkernel function &quot;studbase&quot;.
</p>
</li>
<li> <p><code>alpha</code> for the Non Linear cndkernel function &quot;nonlcnd&quot;.
</p>
</li>
<li> <p><code>d, alpha, c</code> for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>gamma</code> for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>d, sigma</code> for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>c</code> for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>theta</code> for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>d</code> for the d cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qpar parameter as well.</p>
</td></tr>
<tr><td><code id="qsammon_+3A_qkernel">qkernel</code></td>
<td>
<p>the kernel function to be used to calculate the qkernel
matrix.</p>
</td></tr>
<tr><td><code id="qsammon_+3A_cndkernel">cndkernel</code></td>
<td>
<p>the cndkernel function to be used to calculate the CND kernel
matrix.</p>
</td></tr>
<tr><td><code id="qsammon_+3A_k">k</code></td>
<td>
<p>the dimension of the original data.</p>
</td></tr>
<tr><td><code id="qsammon_+3A_dims">dims</code></td>
<td>
<p>Number of features to return. (default: 2)</p>
</td></tr>
<tr><td><code id="qsammon_+3A_initialisation">Initialisation</code></td>
<td>
<p><code>"random"</code> or <code>"pca"</code>; the former performs
fast random projection and the latter performs standard PCA  (default : <code>"random") </code></p>
</td></tr>
<tr><td><code id="qsammon_+3A_maxhalves">MaxHalves</code></td>
<td>
<p>maximum number of step halvings. (default : 20) </p>
</td></tr>
<tr><td><code id="qsammon_+3A_maxiter">MaxIter</code></td>
<td>
<p>the maximum number of iterations allowed. (default : 500)</p>
</td></tr>
<tr><td><code id="qsammon_+3A_tolfun">TolFun</code></td>
<td>
<p>relative tolerance on objective function. (default : 1e-7) </p>
</td></tr>
<tr><td><code id="qsammon_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s are
found. The default action is <code>na.omit</code>, which leads to rejection of cases
with missing values on any required variable. An alternative
is <code>na.fail</code>, which causes an error if <code>NA</code> cases
are found. (NOTE: If given, this argument must be named.)</p>
</td></tr>
<tr><td><code id="qsammon_+3A_...">...</code></td>
<td>
<p> additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using kernel functions one can efficiently compute
principal components in high-dimensional
feature spaces, related to input space by some non-linear map.<br />
The data can be passed to the <code>qsammon</code> function in a <code>matrix</code>, in addition <code>qsammon</code> also supports input in the form of a
kernel matrix of class <code>qkernmatrix</code> or class <code>cndkernmatrix</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dimRed</code></td>
<td>
<p>The matrix whose rows are embedded observations.</p>
</td></tr>
<tr><td><code>kcall</code></td>
<td>
<p>The function call contained</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>The kernel function used</p>
</td></tr>
</table>
<p>all the slots of the object can be accessed by accessor functions.
</p>


<h3>Author(s)</h3>

<p>Yusen Zhang <br />
<a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Sammon, J.W. (1969) <em>A Nonlinear Mapping for Data Structure Analysis</em>.
IEEE Transactions on Computers, C-18 5:401-409.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qkernmatrix">qkernmatrix</a></code>, <code><a href="#topic+cndkernmatrix">cndkernmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
train &lt;- as.matrix(iris[,1:4])
labeltrain&lt;- as.integer(iris[,5])
## S4 method for signature 'matrix'
kpc2 &lt;- qsammon(train, kernel = "rbfbase", qpar = list(sigma = 2, q = 0.9), dims = 2,
                Initialisation = 'pca', TolFun = 1e-5)
plot(dimRed(kpc2), col = as.integer(labeltrain))
cndkernf(kpc2)


</code></pre>

<hr>
<h2 id='qsammon-class'>Class &quot;qsammon&quot;</h2><span id='topic+qsammon-class'></span><span id='topic+dimRed'></span><span id='topic+dimRed+3C-'></span><span id='topic+fun'></span><span id='topic+dimRed+2Cqsammon-method'></span><span id='topic+dimRed+3C-+2Cqsammon-method'></span>

<h3>Description</h3>

<p> The qKernel Sammon Mapping class</p>


<h3>Objects of class &quot;qsammon&quot;</h3>

<p>Objects can be created by calls of the form <code>new("qsammon", ...)</code>.
or by calling the <code>qsammon</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimRed</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the
matrix whose rows are embedded observations </p>
</dd>
<dt><code>cndkernf</code>:</dt><dd><p>Object of class <code>"function"</code> containing
the kernel function used</p>
</dd>
<dt><code>kcall</code>:</dt><dd><p>Object of class <code>"ANY"</code> containing the
function call </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>dimRed</dt><dd><p><code>signature(object = "qsammon")</code>: returns the matrix whose rows are embedded observations </p>
</dd>
<dt>kcall</dt><dd><p><code>signature(object = "qsammon")</code>: returns the
performed call</p>
</dd>
<dt>cndkernf</dt><dd><p><code>signature(object = "qsammon")</code>: returns the used
kernel function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yusen Zhang<br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qsammon">qsammon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(iris)
  train &lt;- as.matrix(iris[,1:4])
  labeltrain&lt;- as.integer(iris[,5])
  ## S4 method for signature 'matrix'
  qkpc &lt;- qsammon(train, kernel = "rbfbase", qpar = list(sigma = 0.5, q = 0.9),
                   dims = 2, Initialisation = 'pca', MaxHalves = 50)

  cndkernf(qkpc)
  dimRed(qkpc)
  kcall(qkpc)
</code></pre>

<hr>
<h2 id='qtSNE'>qKernel t-Distributed Stochastic Neighbor Embedding</h2><span id='topic+qtSNE'></span><span id='topic+qtSNE+2Cmatrix-method'></span><span id='topic+qtSNE+2Cqkernmatrix-method'></span><span id='topic+qtSNE+2Ccndkernmatrix-method'></span>

<h3>Description</h3>

<p>Wrapper for the qkernel t-distributed stochastic neighbor embeddingg. qtSNE is a method for constructing a low dimensional embedding of high-dimensional data, distances or similarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'matrix'
qtSNE(x,kernel = "rbfbase", qpar = list(sigma = 0.1, q = 0.9),
        initial_config = NULL, no_dims=2, initial_dims=30, perplexity=30, max_iter= 1300,
         min_cost=0, epoch_callback=NULL, epoch=100, na.action = na.omit, ...)
## S4 method for signature 'cndkernmatrix'
qtSNE(x,initial_config = NULL, no_dims=2, initial_dims=30,
        perplexity=30, max_iter = 1000, min_cost=0, epoch_callback=NULL,epoch=100)
## S4 method for signature 'qkernmatrix'
qtSNE(x,initial_config = NULL, no_dims=2, initial_dims=30,
        perplexity=30, max_iter = 1000, min_cost=0, epoch_callback=NULL,epoch=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtSNE_+3A_x">x</code></td>
<td>
<p>the matrix of data to be clustered or a kernel Matrix of class
<code>qkernmatrix</code> or <code>cndkernmatrix</code>.</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in computing the affinity matrix.
This parameter can be set to any function, of class kernel, which computes a kernel function value between two
vector arguments. kernlab provides the most popular kernel functions
which can be used by setting the kernel parameter to the following strings:
</p>

<ul>
<li> <p><code>rbfbase</code> Radial Basis qkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>nonlbase</code> Non Linear qkernel function
</p>
</li>
<li> <p><code>laplbase</code> Laplbase qkernel function
</p>
</li>
<li> <p><code>ratibase</code> Rational Quadratic qkernel function
</p>
</li>
<li> <p><code>multbase</code> Multiquadric qkernel function
</p>
</li>
<li> <p><code>invbase</code> Inverse Multiquadric qkernel function
</p>
</li>
<li> <p><code>wavbase</code> Wave qkernel function
</p>
</li>
<li> <p><code>powbase</code> Power qkernel function
</p>
</li>
<li> <p><code>logbase</code> Log qkernel function
</p>
</li>
<li> <p><code>caubase</code> Cauchy qkernel function
</p>
</li>
<li> <p><code>chibase</code> Chi-Square qkernel function
</p>
</li>
<li> <p><code>studbase</code> Generalized T-Student qkernel function
</p>
</li>
<li> <p><code>nonlcnd</code> Non Linear cndkernel function
</p>
</li>
<li> <p><code>polycnd</code> Polynomial cndkernel function
</p>
</li>
<li> <p><code>rbfcnd</code> Radial Basis cndkernel function &quot;Gaussian&quot;
</p>
</li>
<li> <p><code>laplcnd</code> Laplacian cndkernel function
</p>
</li>
<li> <p><code>anocnd</code> ANOVA cndkernel function
</p>
</li>
<li> <p><code>raticnd</code> Rational Quadratic cndkernel function
</p>
</li>
<li> <p><code>multcnd</code> Multiquadric cndkernel function
</p>
</li>
<li> <p><code>invcnd</code> Inverse Multiquadric cndkernel function
</p>
</li>
<li> <p><code>wavcnd</code> Wave cndkernel function
</p>
</li>
<li> <p><code>powcnd</code> Power cndkernel function
</p>
</li>
<li> <p><code>logcnd</code> Log cndkernel function
</p>
</li>
<li> <p><code>caucnd</code> Cauchy cndkernel function
</p>
</li>
<li> <p><code>chicnd</code> Chi-Square cndkernel function
</p>
</li>
<li> <p><code>studcnd</code> Generalized T-Student cndkernel function
</p>
</li></ul>

<p>The kernel parameter can also be set to a user defined function of
class kernel by passing the function name as an argument.
</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_qpar">qpar</code></td>
<td>
<p>a character string or the list of hyper-parameters (kernel parameters).
The default character string <code>list(sigma = 2, q = 0.9)</code> uses a heuristic to determine a
suitable value for the width parameter of the RBF kernel.
The second option <code>"local"</code> (local scaling) uses a more advanced heuristic
and sets a width parameter for every point in the data set. This is
particularly useful when the data incorporates multiple scales.
A list can also be used containing the parameters to be used with the
kernel function. Valid parameters for existing kernels are :
</p>

<ul>
<li> <p><code>sigma</code>  for the Radial Basis qkernel function &quot;rbfbase&quot; , the Laplacian qkernel function &quot;laplbase&quot; the Cauchy qkernel function &quot;caubase&quot; and for the ANOVA cndkernel function &quot;anocnd&quot;.
</p>
</li>
<li> <p><code>alpha</code>  for the Non Linear qkernel function &quot;nonlbase&quot;,for the Non Linear cndkernel function &quot;nonlcnd&quot;,and for the Polynomial cndkernel function &quot;polycnd&quot;.
</p>
</li>
<li> <p><code>c</code>  for the Rational Quadratic qkernel function &quot;ratibase&quot; , the Multiquadric qkernel function &quot;multbase&quot;, the Inverse Multiquadric qkernel function &quot;invbase&quot;,for the Polynomial cndkernel function &quot;polycnd&quot;,for the Rational Quadratic cndkernel function &quot;raticnd&quot; , the Multiquadric cndkernel function &quot;multcnd&quot; and the Inverse Multiquadric cndkernel function &quot;invcnd&quot;.
</p>
</li>
<li> <p><code>d</code>   for qkernel function &quot;powbase&quot; , the Log qkernel function &quot;logbase&quot;, the Generalized T-Student qkernel function &quot;studbase&quot;, for the Polynomial cndkernel function &quot;polycnd&quot;, for the ANOVA cndkernel function &quot;anocnd&quot;,for the d cndkernel function &quot;powcnd&quot; , the Log cndkernel function &quot;logcnd&quot; and the Generalized T-Student cndkernel function &quot;studcnd&quot;.
</p>
</li>
<li> <p><code>theta</code>  for the Wave qkernel function &quot;wavbase&quot; and for the Wave cndkernel function &quot;wavcnd&quot;.
</p>
</li>
<li> <p><code>gamma</code>  for the Chi-Square qkernel function &quot;chibase&quot;,for the Radial Basis cndkernel function &quot;rbfcnd&quot; and the Laplacian cndkernel function &quot;laplcnd&quot; and the Cauchy cndkernel function &quot;caucnd&quot;.
</p>
</li>
<li> <p><code>q</code>  For all qkernel Function.
where length is the length of the strings considered, lambda the
decay factor and normalized a logical parameter determining if the
kernel evaluations should be normalized.
</p>
</li></ul>

<p>Hyper-parameters for user defined kernels can be passed through the
qkpar parameter as well.</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_initial_config">initial_config</code></td>
<td>
<p>An intitial configure about x (default: NULL)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_no_dims">no_dims</code></td>
<td>
<p>the dimension of the resulting embedding. (default: 2)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_initial_dims">initial_dims</code></td>
<td>
<p> The number of dimensions to use in reduction method. (default: 30)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_perplexity">perplexity</code></td>
<td>
<p>Perplexity parameter</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_max_iter">max_iter</code></td>
<td>
<p>Number of iterations (default: 1300)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_min_cost">min_cost</code></td>
<td>
<p>The minimum cost for every object after the final iteration</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_epoch_callback">epoch_callback</code></td>
<td>
<p>A callback function used after each epoch (an epoch here means a set number of iterations)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_epoch">epoch</code></td>
<td>
<p>The interval of the number of iterations displayed (default: 100)</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_na.action">na.action</code></td>
<td>
<p>the action to perform on NA</p>
</td></tr>
<tr><td><code id="qtSNE_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to qtSNE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the initial_config argument is specified, the algorithm will automatically enter the final momentum stage. This stage has less large scale adjustment to the embedding, and is intended for small scale tweaking of positioning. This can greatly speed up the generation of embeddings for various similar X datasets, while also preserving overall embedding orientation.
</p>


<h3>Value</h3>

<p><code>qtSNE</code> gives out an S4 object which is a LIST with components
</p>
<table role = "presentation">
<tr><td><code>dimRed</code></td>
<td>
<p> Matrix containing the new representations for the objects after qtSNE</p>
</td></tr>
<tr><td><code>cndkernf</code></td>
<td>
<p>The kernel function used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yusen Zhang <br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Maaten, L. Van Der, 2014. Accelerating t-SNE using Tree-Based Algorithms. Journal of Machine Learning Research, 15, p.3221-3245.
</p>
<p>van der Maaten, L.J.P. &amp; Hinton, G.E., 2008. Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research, 9, pp.2579-2605.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#use iris data set
data(iris)
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[,1:4])

colors = rainbow(length(unique(iris$Species)))
names(colors) = unique(iris$Species)
#for matrix
ecb = function(x,y){
  plot(x,t='n');
  text(x,labels=iris$Species, col=colors[iris$Species])
}
kpc2 &lt;- qtSNE(train, kernel = "rbfbase", qpar = list(sigma=1,q=0.8),
              epoch_callback = ecb, perplexity=10, max_iter = 500)


## End(Not run)
</code></pre>

<hr>
<h2 id='qtSNE-class'>Class &quot;qtSNE&quot;</h2><span id='topic+qtSNE-class'></span><span id='topic+dimRed+2CqtSNE-method'></span><span id='topic+dimRed+3C-+2CqtSNE-method'></span>

<h3>Description</h3>

<p>An S4 Class for qtSNE.
</p>


<h3>Details</h3>

<p>The qtSNE is a method that uses Qkernel t-Distributed Stochastic Neighborhood Embedding between the distance matrices in high and low-dimensional space to embed the data. The method is very well suited to visualize complex structures in low dimensions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("qtSNE", ...)</code>.
or by calling the function <code>qtSNE</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimRed</code></dt><dd><p> Matrix containing the new representations for the objects after qtSNE</p>
</dd>
<dt><code>cndkernf</code></dt><dd><p> The kernel function used</p>
</dd>
</dl>


<h3>Method</h3>


<dl>
<dt><code>dimRed</code></dt><dd><p><code>signature(object="qtSNE")</code>: return a new representation matrix</p>
</dd>
<dt><code>cndkernf</code></dt><dd><p><code>signature(object="qtSNE")</code>: return the kernel used</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yusen Zhang <br /> <a href="mailto:yusenzhang@126.com">yusenzhang@126.com</a></p>


<h3>References</h3>

<p>Maaten, L. van der, 2014. Accelerating t-SNE using Tree-Based
Algorithms. Journal of Machine Learning Research 15, 3221-3245.
</p>
<p>van der Maaten, L., Hinton, G., 2008. Visualizing Data using
t-SNE. J. Mach. Learn. Res. 9, 2579-2605.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qtSNE">qtSNE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#use iris data set
data(iris)
testset &lt;- sample(1:150,20)
train &lt;- as.matrix(iris[,1:4])

colors = rainbow(length(unique(iris$Species)))
names(colors) = unique(iris$Species)
#for matrix
ecb = function(x,y){
  plot(x,t='n');
  text(x,labels=iris$Species, col=colors[iris$Species])
}
kpc2 &lt;- qtSNE(train, kernel = "rbfbase", qpar = list(sigma=1,q=0.8),
              epoch_callback = ecb, perplexity=10, max_iter = 500)

#cndernf
cndkernf(kpc2)

#dimRed
plot(dimRed(kpc2),col=train)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
