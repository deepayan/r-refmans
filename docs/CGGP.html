<!DOCTYPE html><html lang="en"><head><title>Help for package CGGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CGGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CGGP'><p>CGGP: A package for running sparse grid computer experiments</p></a></li>
<li><a href='#CGGP_internal_calcMSE'><p>Calculate MSE over single dimension</p></a></li>
<li><a href='#CGGP_internal_calcMSEde'><p>Calculate MSE over blocks</p></a></li>
<li><a href='#CGGP_internal_calcpw'><p>Calculate predictive weights for CGGP</p></a></li>
<li><a href='#CGGP_internal_calcpwanddpw'><p>Calculate derivative of pw</p></a></li>
<li><a href='#CGGP_internal_CorrMatCauchy'><p>Cauchy correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatCauchySQ'><p>CauchySQ correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatCauchySQT'><p>CauchySQT correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatGaussian'><p>Gaussian correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatMatern32'><p>Matern 3/2 correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatMatern52'><p>Matern 5/2 correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatPowerExp'><p>Power exponential correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatWendland0'><p>Wendland0 (Triangle) correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatWendland1'><p>Wendland1 1 correlation function</p></a></li>
<li><a href='#CGGP_internal_CorrMatWendland2'><p>Wendland2 2 correlation function</p></a></li>
<li><a href='#CGGP_internal_gneglogpost'><p>Gradient of negative log likelihood posterior</p></a></li>
<li><a href='#CGGP_internal_MSEpredcalc'><p>Calculate MSE prediction along a single dimension</p></a></li>
<li><a href='#CGGP_internal_neglogpost'><p>Calculate negative log posterior</p></a></li>
<li><a href='#CGGP_internal_set_corr'><p>Set correlation function of CGGP object</p></a></li>
<li><a href='#CGGPappend'><p>Add points to CGGP</p></a></li>
<li><a href='#CGGPcreate'><p>Create sparse grid GP</p></a></li>
<li><a href='#CGGPfit'><p>Update CGGP model given data</p></a></li>
<li><a href='#CGGPplotblocks'><p>CGGP block plot</p></a></li>
<li><a href='#CGGPplotblockselection'><p>Plot CGGP block selection over time</p></a></li>
<li><a href='#CGGPplotcorr'><p>Plot correlation samples</p></a></li>
<li><a href='#CGGPplotheat'><p>Heatmap of SG design depth</p></a></li>
<li><a href='#CGGPplothist'><p>Histogram of measurements at each design depth of each input dimension</p></a></li>
<li><a href='#CGGPplotsamplesneglogpost'><p>Plot negative log posterior likelihood of samples</p></a></li>
<li><a href='#CGGPplotslice'><p>CGGP slice plot</p></a></li>
<li><a href='#CGGPplottheta'><p>Plot theta samples</p></a></li>
<li><a href='#CGGPplotvariogram'><p>Plot something similar to a semivariogram</p></a></li>
<li><a href='#CGGPvalplot'><p>Plot validation prediction errors for CGGP object</p></a></li>
<li><a href='#CGGPvalstats'><p>Calculate stats for CGGP prediction on validation data</p></a></li>
<li><a href='#plot.CGGP'><p>S3 plot method for CGGP</p></a></li>
<li><a href='#predict.CGGP'><p>S3 predict method for CGGP</p></a></li>
<li><a href='#print.CGGP'><p>Print CGGP object</p></a></li>
<li><a href='#rcpp_fastmatclcr'><p>rcpp_fastmatclcr</p></a></li>
<li><a href='#rcpp_fastmatclcranddclcr'><p>rcpp_fastmatclcranddclcr</p></a></li>
<li><a href='#rcpp_gkronDBS'><p>rcpp_kronDBS</p></a></li>
<li><a href='#rcpp_kronDBS'><p>rcpp_kronDBS</p></a></li>
<li><a href='#valplot'><p>Plot validation prediction errors</p></a></li>
<li><a href='#valstats'><p>Calculate stats for prediction on validation data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Composite Grid Gaussian Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Run computer experiments using the adaptive composite grid
    algorithm with a Gaussian process model.
    The algorithm works best when running an experiment that can evaluate thousands
    of points from a deterministic computer simulation.
    This package is an implementation of a forthcoming paper by Plumlee,
    Erickson, Ankenman, et al. For a preprint of the paper,
    contact the maintainer of this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, ggplot2, reshape2, plyr, MASS, rmarkdown,
knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CollinErickson/CGGP">https://github.com/CollinErickson/CGGP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CollinErickson/CGGP/issues">https://github.com/CollinErickson/CGGP/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 02:12:28 UTC; colli</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Erickson [aut, cre],
  Matthew Plumlee [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Erickson &lt;collinberickson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 03:22:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='CGGP'>CGGP: A package for running sparse grid computer experiments</h2><span id='topic+CGGP'></span><span id='topic+CGGP-package'></span>

<h3>Description</h3>

<p>The CGGP package implements the method presented in Plumlee et al. (2019).
</p>


<h3>CGGP functions</h3>

<p>The CGGP functions: CGGPcreate, CGGPfit, CGGPappend, and CGGPpred
</p>

<hr>
<h2 id='CGGP_internal_calcMSE'>Calculate MSE over single dimension</h2><span id='topic+CGGP_internal_calcMSE'></span>

<h3>Description</h3>

<p>Calculated using grid of integration points.
Can be calculated exactly, but not much reason in 1D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_calcMSE(xl, theta, CorrMat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_calcMSE_+3A_xl">xl</code></td>
<td>
<p>Vector of points in 1D</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcMSE_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcMSE_+3A_corrmat">CorrMat</code></td>
<td>
<p>Function that gives correlation matrix for vectors of 1D points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MSE value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_calcMSE(xl=c(0,.5,.9), theta=c(1,2,3),
         CorrMat=CGGP_internal_CorrMatCauchySQT)
</code></pre>

<hr>
<h2 id='CGGP_internal_calcMSEde'>Calculate MSE over blocks</h2><span id='topic+CGGP_internal_calcMSEde'></span>

<h3>Description</h3>

<p>Delta of adding block is product over i=1..d of IMSE(i,j-1) - IMSE(i,j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_calcMSEde(valsinds, MSE_MAP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_calcMSEde_+3A_valsinds">valsinds</code></td>
<td>
<p>Block levels to calculate MSEs for</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcMSEde_+3A_mse_map">MSE_MAP</code></td>
<td>
<p>Matrix of MSE values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All MSE values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(SG$design, 1, function(x){x[1]+x[2]^2})
SG &lt;- CGGPfit(SG, Y=y)
MSE_MAP &lt;- outer(1:SG$d, 1:8, 
     Vectorize(function(dimlcv, lcv1) {
        CGGP_internal_calcMSE(SG$xb[1:SG$sizest[dimlcv]],
        theta=SG$thetaMAP[(dimlcv-1)*SG$numpara+1:SG$numpara],
        CorrMat=SG$CorrMat)
 }))
CGGP_internal_calcMSEde(SG$po[1:SG$poCOUNT, ], MSE_MAP)
</code></pre>

<hr>
<h2 id='CGGP_internal_calcpw'>Calculate predictive weights for CGGP</h2><span id='topic+CGGP_internal_calcpw'></span>

<h3>Description</h3>

<p>Predictive weights are Sigma^(-1)*y in standard GP.
This calculation is much faster since we don't need to
solve the full system of equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_calcpw(CGGP, y, theta, return_lS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_calcpw_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpw_+3A_y">y</code></td>
<td>
<p>Measured values for CGGP$design</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpw_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpw_+3A_return_ls">return_lS</code></td>
<td>
<p>Should lS be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with predictive weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cggp &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(cggp$design, 1, function(x){x[1]+x[2]^2+rnorm(1,0,.01)})
CGGP_internal_calcpw(CGGP=cggp, y=y, theta=cggp$thetaMAP)
</code></pre>

<hr>
<h2 id='CGGP_internal_calcpwanddpw'>Calculate derivative of pw</h2><span id='topic+CGGP_internal_calcpwanddpw'></span>

<h3>Description</h3>

<p>Calculate derivative of pw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_calcpwanddpw(CGGP, y, theta, return_lS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_calcpwanddpw_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpwanddpw_+3A_y">y</code></td>
<td>
<p>Measured values for CGGP$design</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpwanddpw_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_calcpwanddpw_+3A_return_ls">return_lS</code></td>
<td>
<p>Should lS and dlS be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>derivative matrix of pw with respect to logtheta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cggp &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(cggp$design, 1, function(x){x[1]+x[2]^2+rnorm(1,0,.01)})
CGGP_internal_calcpwanddpw(CGGP=cggp, y=y, theta=cggp$thetaMAP)
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatCauchy'>Cauchy correlation function</h2><span id='topic+CGGP_internal_CorrMatCauchy'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchy(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchy_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchy(c(0,.2,.4),c(.1,.3,.5), theta=c(-1,.9,.1))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatCauchySQ'>CauchySQ correlation function</h2><span id='topic+CGGP_internal_CorrMatCauchySQ'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchySQ(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQ_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchySQ(c(0,.2,.4),c(.1,.3,.5), theta=c(-.7,-.5))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatCauchySQT'>CauchySQT correlation function</h2><span id='topic+CGGP_internal_CorrMatCauchySQT'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchySQT(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatCauchySQT_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatCauchySQT(c(0,.2,.4),c(.1,.3,.5), theta=c(-.1,.3,-.7))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatGaussian'>Gaussian correlation function</h2><span id='topic+CGGP_internal_CorrMatGaussian'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatGaussian(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatGaussian_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WE HIGHLY ADVISE NOT USING THIS CORRELATION FUNCTION.
Try Power Exponential, CauchySQT, Cauchy, or Matern 3/2 instead.
</p>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatGaussian(c(0,.2,.4),c(.1,.3,.5), theta=c(-.7))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatMatern32'>Matern 3/2 correlation function</h2><span id='topic+CGGP_internal_CorrMatMatern32'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatMatern32(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern32_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatMatern32(c(0,.2,.4),c(.1,.3,.5), theta=c(-.7))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatMatern52'>Matern 5/2 correlation function</h2><span id='topic+CGGP_internal_CorrMatMatern52'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatMatern52(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatMatern52_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatMatern52(c(0,.2,.4),c(.1,.3,.5), theta=c(-.7))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatPowerExp'>Power exponential correlation function</h2><span id='topic+CGGP_internal_CorrMatPowerExp'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatPowerExp(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatPowerExp_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatPowerExp(c(0,.2,.4),c(.1,.3,.5), theta=c(-.7,.2))
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatWendland0'>Wendland0 (Triangle) correlation function</h2><span id='topic+CGGP_internal_CorrMatWendland0'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland0(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland0_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland0(c(0,.2,.4),c(.1,.3,.5), theta=-.7)
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatWendland1'>Wendland1 1 correlation function</h2><span id='topic+CGGP_internal_CorrMatWendland1'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland1(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland1_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland2">CGGP_internal_CorrMatWendland2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland1(c(0,.2,.4),c(.1,.3,.5), theta=-.7)
</code></pre>

<hr>
<h2 id='CGGP_internal_CorrMatWendland2'>Wendland2 2 correlation function</h2><span id='topic+CGGP_internal_CorrMatWendland2'></span>

<h3>Description</h3>

<p>Calculate correlation matrix for two sets of points in one dimension.
Note that this is not the correlation between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland2(
  x1,
  x2,
  theta,
  return_dCdtheta = FALSE,
  return_numpara = FALSE,
  returnlogs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_x1">x1</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_x2">x2</code></td>
<td>
<p>Vector of coordinates from same dimension</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters:
</p>

<ul>
<li><p> LS Log of parameter that controls lengthscale
</p>
</li>
<li><p> FD Logit of 0.5*parameter  that controls the fractal dimension
</p>
</li>
<li><p> HE Log of parameter that controls the hurst effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_return_dcdtheta">return_dCdtheta</code></td>
<td>
<p>Should dCdtheta be returned?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_return_numpara">return_numpara</code></td>
<td>
<p>Should it just return the number of parameters?</p>
</td></tr>
<tr><td><code id="CGGP_internal_CorrMatWendland2_+3A_returnlogs">returnlogs</code></td>
<td>
<p>Should log of correlation be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of correlation values between x1 and x2
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+CGGP_internal_CorrMatCauchySQT">CGGP_internal_CorrMatCauchySQT</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchySQ">CGGP_internal_CorrMatCauchySQ</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatCauchy">CGGP_internal_CorrMatCauchy</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatGaussian">CGGP_internal_CorrMatGaussian</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern32">CGGP_internal_CorrMatMatern32</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatMatern52">CGGP_internal_CorrMatMatern52</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatPowerExp">CGGP_internal_CorrMatPowerExp</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland0">CGGP_internal_CorrMatWendland0</a>()</code>,
<code><a href="#topic+CGGP_internal_CorrMatWendland1">CGGP_internal_CorrMatWendland1</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_CorrMatWendland2(c(0,.2,.4),c(.1,.3,.5), theta=-.7)
</code></pre>

<hr>
<h2 id='CGGP_internal_gneglogpost'>Gradient of negative log likelihood posterior</h2><span id='topic+CGGP_internal_gneglogpost'></span>

<h3>Description</h3>

<p>Gradient of negative log likelihood posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_gneglogpost(
  theta,
  CGGP,
  y,
  ...,
  return_lik = FALSE,
  ys = NULL,
  Xs = NULL,
  HandlingSuppData = "Correct"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_gneglogpost_+3A_theta">theta</code></td>
<td>
<p>Log of correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_y">y</code></td>
<td>
<p>CGGP$design measured values</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_...">...</code></td>
<td>
<p>Forces you to name remaining arguments</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_return_lik">return_lik</code></td>
<td>
<p>If yes, it returns a list with lik and glik</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_ys">ys</code></td>
<td>
<p>Supplementary output data</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_xs">Xs</code></td>
<td>
<p>Supplementary input data</p>
</td></tr>
<tr><td><code id="CGGP_internal_gneglogpost_+3A_handlingsuppdata">HandlingSuppData</code></td>
<td>
<p>How should supplementary data be handled?
* Correct: full likelihood with grid and supplemental data
* Only: only use supplemental data
* Ignore: ignore supplemental data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector for gradient of likelihood w.r.t. x (theta)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cg &lt;- CGGPcreate(d=3, batchsize=20)
Y &lt;- apply(cg$design, 1, function(x){x[1]+x[2]^2})
cg &lt;- CGGPfit(cg, Y)
CGGP_internal_gneglogpost(cg$thetaMAP, CGGP=cg, y=cg$y)
</code></pre>

<hr>
<h2 id='CGGP_internal_MSEpredcalc'>Calculate MSE prediction along a single dimension</h2><span id='topic+CGGP_internal_MSEpredcalc'></span>

<h3>Description</h3>

<p>Calculate MSE prediction along a single dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_MSEpredcalc(xp, xl, theta, CorrMat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_MSEpredcalc_+3A_xp">xp</code></td>
<td>
<p>Points at which to calculate MSE</p>
</td></tr>
<tr><td><code id="CGGP_internal_MSEpredcalc_+3A_xl">xl</code></td>
<td>
<p>Levels along dimension, vector???</p>
</td></tr>
<tr><td><code id="CGGP_internal_MSEpredcalc_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_MSEpredcalc_+3A_corrmat">CorrMat</code></td>
<td>
<p>Function that gives correlation matrix for vectors of 1D points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MSE predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGP_internal_MSEpredcalc(c(.4,.52), c(0,.25,.5,.75,1), theta=c(.1,.2),
             CorrMat=CGGP_internal_CorrMatCauchySQ)
</code></pre>

<hr>
<h2 id='CGGP_internal_neglogpost'>Calculate negative log posterior</h2><span id='topic+CGGP_internal_neglogpost'></span>

<h3>Description</h3>

<p>Calculate negative log posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_neglogpost(
  theta,
  CGGP,
  y,
  ...,
  ys = NULL,
  Xs = NULL,
  HandlingSuppData = "Correct"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_neglogpost_+3A_theta">theta</code></td>
<td>
<p>Correlation parameters</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_y">y</code></td>
<td>
<p>Measured values of CGGP$design</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_...">...</code></td>
<td>
<p>Forces you to name remaining arguments</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_ys">ys</code></td>
<td>
<p>Supplementary output data</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_xs">Xs</code></td>
<td>
<p>Supplementary input data</p>
</td></tr>
<tr><td><code id="CGGP_internal_neglogpost_+3A_handlingsuppdata">HandlingSuppData</code></td>
<td>
<p>How should supplementary data be handled?
</p>

<ul>
<li><p> Correct: full likelihood with grid and supplemental data
</p>
</li>
<li><p> Only: only use supplemental data
</p>
</li>
<li><p> Ignore: ignore supplemental data
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cg &lt;- CGGPcreate(d=3, batchsize=20)
Y &lt;- apply(cg$design, 1, function(x){x[1]+x[2]^2})
cg &lt;- CGGPfit(cg, Y)
CGGP_internal_neglogpost(cg$thetaMAP, CGGP=cg, y=cg$y)
</code></pre>

<hr>
<h2 id='CGGP_internal_set_corr'>Set correlation function of CGGP object</h2><span id='topic+CGGP_internal_set_corr'></span>

<h3>Description</h3>

<p>Set correlation function of CGGP object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGP_internal_set_corr(CGGP, corr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGP_internal_set_corr_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGP_internal_set_corr_+3A_corr">corr</code></td>
<td>
<p>Correlation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CGGP object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- CGGPcreate(3, 20, corr="matern52")
CGGP_internal_set_corr(obj, "gaussian")
</code></pre>

<hr>
<h2 id='CGGPappend'>Add points to CGGP</h2><span id='topic+CGGPappend'></span>

<h3>Description</h3>

<p>Add 'batchsize' points to 'SG' using 'theta'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPappend(CGGP, batchsize, selectionmethod = "MAP")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPappend_+3A_cggp">CGGP</code></td>
<td>
<p>Sparse grid object</p>
</td></tr>
<tr><td><code id="CGGPappend_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to add</p>
</td></tr>
<tr><td><code id="CGGPappend_+3A_selectionmethod">selectionmethod</code></td>
<td>
<p>How points will be selected: one of 'UCB', 'TS',
'MAP', 'Oldest', 'Random', or 'Lowest'.
'UCB' uses Upper Confidence Bound estimates for the parameters.
'TS' uses Thompson sampling, a random sample from the posterior.
'MAP' uses maximum a posteriori parameter estimates.
'Oldest' adds the block that has been available the longest.
'Random' adds a random block.
'Lowest' adds the block with the lowest sum of index levels.
'UCB' and 'TS' are based on bandit algorithms and account for uncertainty
in the parameter estimates, but are the slowest.
&lsquo;MAP' is fast but doesn&rsquo;t account for parameter uncertainty.
The other three are naive methods that are not adaptive and won't
perform well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SG with new points added.
</p>


<h3>See Also</h3>

<p>Other CGGP core functions: 
<code><a href="#topic+CGGPcreate">CGGPcreate</a>()</code>,
<code><a href="#topic+CGGPfit">CGGPfit</a>()</code>,
<code><a href="#topic+predict.CGGP">predict.CGGP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(SG$design, 1, function(x){x[1]+x[2]^2})
SG &lt;- CGGPfit(SG, Y=y)
SG &lt;- CGGPappend(CGGP=SG, batchsize=20, selectionmethod="MAP")
</code></pre>

<hr>
<h2 id='CGGPcreate'>Create sparse grid GP</h2><span id='topic+CGGPcreate'></span>

<h3>Description</h3>

<p>Create sparse grid GP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPcreate(
  d,
  batchsize,
  corr = "PowerExponential",
  grid_sizes = c(1, 2, 4, 4, 8, 12, 20, 28, 32),
  Xs = NULL,
  Ys = NULL,
  HandlingSuppData = "Correct",
  supp_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPcreate_+3A_d">d</code></td>
<td>
<p>Input dimension</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_batchsize">batchsize</code></td>
<td>
<p>Number added to design each batch
for now only on predictions</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_corr">corr</code></td>
<td>
<p>Name of correlation function to use. Must be one of &quot;CauchySQT&quot;,
&quot;CauchySQ&quot;, &quot;Cauchy&quot;, &quot;Gaussian&quot;, &quot;PowerExp&quot;, &quot;Matern32&quot;, &quot;Matern52&quot;.</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_grid_sizes">grid_sizes</code></td>
<td>
<p>Size of grid refinements.</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_xs">Xs</code></td>
<td>
<p>Supplemental X data</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_ys">Ys</code></td>
<td>
<p>Supplemental Y data</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_handlingsuppdata">HandlingSuppData</code></td>
<td>
<p>How should supplementary data be handled?
* Correct: full likelihood with grid and supplemental data
* Only: only use supplemental data
* Ignore: ignore supplemental data</p>
</td></tr>
<tr><td><code id="CGGPcreate_+3A_supp_args">supp_args</code></td>
<td>
<p>Arguments used to fit if Xs and Ys are given</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CGGP
</p>


<h3>See Also</h3>

<p>Other CGGP core functions: 
<code><a href="#topic+CGGPappend">CGGPappend</a>()</code>,
<code><a href="#topic+CGGPfit">CGGPfit</a>()</code>,
<code><a href="#topic+predict.CGGP">predict.CGGP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CGGPcreate(d=8,200)
</code></pre>

<hr>
<h2 id='CGGPfit'>Update CGGP model given data</h2><span id='topic+CGGPfit'></span>

<h3>Description</h3>

<p>This function will update the GP parameters for a CGGP design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPfit(
  CGGP,
  Y,
  Xs = NULL,
  Ys = NULL,
  theta0 = pmax(pmin(CGGP$thetaMAP, 0.8), -0.8),
  HandlingSuppData = CGGP$HandlingSuppData,
  separateoutputparameterdimensions = is.matrix(CGGP$thetaMAP),
  set_thetaMAP_to,
  corr,
  Ynew
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPfit_+3A_cggp">CGGP</code></td>
<td>
<p>Sparse grid objects</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_y">Y</code></td>
<td>
<p>Output values calculated at CGGP$design</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_xs">Xs</code></td>
<td>
<p>Supplemental X matrix</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_ys">Ys</code></td>
<td>
<p>Supplemental Y values</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_theta0">theta0</code></td>
<td>
<p>Initial theta</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_handlingsuppdata">HandlingSuppData</code></td>
<td>
<p>How should supplementary data be handled?
* Correct: full likelihood with grid and supplemental data
* Only: only use supplemental data
* Ignore: ignore supplemental data</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_separateoutputparameterdimensions">separateoutputparameterdimensions</code></td>
<td>
<p>If multiple output dimensions,
should separate parameters be fit to each dimension?</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_set_thetamap_to">set_thetaMAP_to</code></td>
<td>
<p>Value for thetaMAP to be set to</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_corr">corr</code></td>
<td>
<p>Will update correlation function, if left missing it will be
same as last time.</p>
</td></tr>
<tr><td><code id="CGGPfit_+3A_ynew">Ynew</code></td>
<td>
<p>Values of 'CGGP$design_unevaluated'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated CGGP object fit to data given
</p>


<h3>See Also</h3>

<p>Other CGGP core functions: 
<code><a href="#topic+CGGPappend">CGGPappend</a>()</code>,
<code><a href="#topic+CGGPcreate">CGGPcreate</a>()</code>,
<code><a href="#topic+predict.CGGP">predict.CGGP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cg &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(cg$design, 1, function(x){x[1]+x[2]^2})
cg &lt;- CGGPfit(CGGP=cg, Y=y)
</code></pre>

<hr>
<h2 id='CGGPplotblocks'>CGGP block plot</h2><span id='topic+CGGPplotblocks'></span>

<h3>Description</h3>

<p>Plot the 2D projections of the blocks of an CGGP object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotblocks(CGGP, singleplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotblocks_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPplotblocks_+3A_singleplot">singleplot</code></td>
<td>
<p>If only two dimensions, should a single plot be made?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The first and fourth dimensions are most active and will have greater depth
ss &lt;- CGGPcreate(d=5, batchsize=50)
f &lt;- function(x) {cos(2*pi*x[1]*3) + x[3]*exp(4*x[4])}
ss &lt;- CGGPfit(ss, Y=apply(ss$design, 1, f))
ss &lt;- CGGPappend(CGGP=ss, batchsize=100)
CGGPplotblocks(ss)

mat &lt;- matrix(c(1,1,1,2,2,1,2,2,1,3), ncol=2, byrow=TRUE)
CGGPplotblocks(mat)

</code></pre>

<hr>
<h2 id='CGGPplotblockselection'>Plot CGGP block selection over time</h2><span id='topic+CGGPplotblockselection'></span>

<h3>Description</h3>

<p>Shows the order in which blocks were selected
for each dimension.
Gives an idea of how the selections change over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotblockselection(CGGP, indims)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotblockselection_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPplotblockselection_+3A_indims">indims</code></td>
<td>
<p>Which input dimensions should be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs &lt;- CGGPcreate(d=3, batchsize=100)
# All dimensions will look similar
CGGPplotblockselection(gs)

# You need to append with CGGPappend after fitting to see a difference
f &lt;- function(x){x[1]^1.2}
y &lt;- apply(gs$design, 1, f)
gs &lt;- CGGPfit(gs, Y=y)
gs &lt;- CGGPappend(gs, 100)
# Now you will see higher for X1 from 100 to 200 while others remain low.
CGGPplotblockselection(gs)

</code></pre>

<hr>
<h2 id='CGGPplotcorr'>Plot correlation samples</h2><span id='topic+CGGPplotcorr'></span>

<h3>Description</h3>

<p>Plot samples for a given correlation function and parameters.
Useful for getting an idea of what the correlation parameters mean
in terms of smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotcorr(
  Corr = CGGP_internal_CorrMatGaussian,
  theta = NULL,
  numlines = 20,
  outdims = NULL,
  zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotcorr_+3A_corr">Corr</code></td>
<td>
<p>Correlation function or CGGP object.
If CGGP object, it will make plots for thetaMAP,
the max a posteriori theta.</p>
</td></tr>
<tr><td><code id="CGGPplotcorr_+3A_theta">theta</code></td>
<td>
<p>Parameters for Corr</p>
</td></tr>
<tr><td><code id="CGGPplotcorr_+3A_numlines">numlines</code></td>
<td>
<p>Number of sample paths to draw</p>
</td></tr>
<tr><td><code id="CGGPplotcorr_+3A_outdims">outdims</code></td>
<td>
<p>Which output dimensions should be used?</p>
</td></tr>
<tr><td><code id="CGGPplotcorr_+3A_zero">zero</code></td>
<td>
<p>Should the sample paths start at y=0?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CGGPplotcorr()
CGGPplotcorr(theta=c(-2,-1,0,1))

SG &lt;- CGGPcreate(d=3, batchsize=100)
f &lt;- function(x){x[1]^1.2+sin(2*pi*x[2]*3)}
y &lt;- apply(SG$design, 1, f)
SG &lt;- CGGPfit(SG, Y=y)
CGGPplotcorr(SG)

</code></pre>

<hr>
<h2 id='CGGPplotheat'>Heatmap of SG design depth</h2><span id='topic+CGGPplotheat'></span>

<h3>Description</h3>

<p>The values on the diagonal are largest design depth for that dimension.
The off-diagonal values are the largest design depth that both dimensions
have been measured at simultaneously.
A greater depth means that more points have been measured along that
dimension or two-dimensional subspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotheat(CGGP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotheat_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heat map made from ggplot2
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/14290364/heatmap-with-values-ggplot2
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# All dimensions should look similar
d &lt;- 8
SG = CGGPcreate(d,201)
CGGPplotheat(SG)

# The first and fourth dimensions are most active and will have greater depth
SG &lt;- CGGPcreate(d=5, batchsize=50)
f &lt;- function(x) {cos(2*pi*x[1]*3) + exp(4*x[4])}
for (i in 1:1) {
  SG &lt;- CGGPfit(SG, Y=apply(SG$design, 1, f))
  SG &lt;- CGGPappend(CGGP=SG, batchsize=200)
}
# SG &lt;- CGGPfit(SG, Y=apply(SG$design, 1, f))
CGGPplotheat(SG)

</code></pre>

<hr>
<h2 id='CGGPplothist'>Histogram of measurements at each design depth of each input dimension</h2><span id='topic+CGGPplothist'></span>

<h3>Description</h3>

<p>A greater design depth signifies a more important dimension.
Thus a larger right tail on the histogram are more important variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplothist(CGGP, ylog = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplothist_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPplothist_+3A_ylog">ylog</code></td>
<td>
<p>Should the y axis be put on a log scale?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histogram plot made using ggplot2
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# All dimensions should look similar
d &lt;- 8
SG = CGGPcreate(d,201)
CGGPplothist(SG)
CGGPplothist(SG, ylog=FALSE)

# The first dimension is more active and will have greater depth
f &lt;- function(x) {sin(x[1]^.6*5)}
SG &lt;- CGGPcreate(d=5, batchsize=100)
SG &lt;- CGGPfit(SG, apply(SG$design, 1, f))
SG &lt;- CGGPappend(CGGP=SG, batchsize=1000)
CGGPplothist(SG)

</code></pre>

<hr>
<h2 id='CGGPplotsamplesneglogpost'>Plot negative log posterior likelihood of samples</h2><span id='topic+CGGPplotsamplesneglogpost'></span>

<h3>Description</h3>

<p>Plot negative log posterior likelihood of samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotsamplesneglogpost(CGGP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotsamplesneglogpost_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs &lt;- CGGPcreate(d=3, batchsize=100)
f &lt;- function(x){x[1]^1.2+x[3]^.4*sin(2*pi*x[2]^2*3) + .1*exp(3*x[3])}
y &lt;- apply(gs$design, 1, f)
gs &lt;- CGGPfit(gs, Y=y)
CGGPplotsamplesneglogpost(gs)
</code></pre>

<hr>
<h2 id='CGGPplotslice'>CGGP slice plot</h2><span id='topic+CGGPplotslice'></span>

<h3>Description</h3>

<p>Show prediction plots when varying over only one dimension.
Most useful when setting all values to 0.5 because it will
have the most points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotslice(
  CGGP,
  proj = 0.5,
  np = 300,
  color = "pink",
  outdims,
  scales = "free_y",
  facet = "grid"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotslice_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_proj">proj</code></td>
<td>
<p>Point to project onto</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_np">np</code></td>
<td>
<p>Number of points to use along each dimension</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_color">color</code></td>
<td>
<p>Color to make error region</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_outdims">outdims</code></td>
<td>
<p>If multiple outputs, which of them should be plotted?</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_scales">scales</code></td>
<td>
<p>Parameter passed to ggplot2::facet_grid()</p>
</td></tr>
<tr><td><code id="CGGPplotslice_+3A_facet">facet</code></td>
<td>
<p>If &quot;grid&quot;, will use ggplot2::facet_grid(), if &quot;wrap&quot; will
use ggplot2::facet_wrap(). Only applicable for a single output dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- 5
f1 &lt;- function(x){x[1]+x[2]^2 + cos(x[3]^2*2*pi*4) - 3.3}
s1 &lt;- CGGPcreate(d, 200)
s1 &lt;- CGGPfit(s1, apply(s1$design, 1, f1))
#s1 &lt;- CGGPappend(s1, 200)
#s1 &lt;- CGGPfit(s1, apply(s1$design, 1, f1))
CGGPplotslice(s1)
CGGPplotslice(s1, 0.)
CGGPplotslice(s1, s1$design[nrow(s1$design),])

</code></pre>

<hr>
<h2 id='CGGPplottheta'>Plot theta samples</h2><span id='topic+CGGPplottheta'></span>

<h3>Description</h3>

<p>Plot theta samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplottheta(CGGP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplottheta_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gs &lt;- CGGPcreate(d=3, batchsize=100)
f &lt;- function(x){x[1]^1.2+x[3]^.4*sin(2*pi*x[2]^2*3) + .1*exp(3*x[3])}
y &lt;- apply(gs$design, 1, f)
gs &lt;- CGGPfit(gs, Y=y)
CGGPplottheta(gs)
</code></pre>

<hr>
<h2 id='CGGPplotvariogram'>Plot something similar to a semivariogram</h2><span id='topic+CGGPplotvariogram'></span>

<h3>Description</h3>

<p>It's not actually a variogram or semivariogram.
It shows how the correlation function falls off as distance increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPplotvariogram(CGGP, facet = 1, outdims = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPplotvariogram_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPplotvariogram_+3A_facet">facet</code></td>
<td>
<p>How should the plots be faceted? If 1, in a row,
if 2, in a column, if 3, wrapped around.</p>
</td></tr>
<tr><td><code id="CGGPplotvariogram_+3A_outdims">outdims</code></td>
<td>
<p>Which output dimensions should be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPvalplot">CGGPvalplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG &lt;- CGGPcreate(d=3, batchsize=100)
f &lt;- function(x){x[1]^1.2+x[3]^.4*sin(2*pi*x[2]^2*3) + .1*exp(3*x[3])}
y &lt;- apply(SG$design, 1, f)
SG &lt;- CGGPfit(SG, Y=y)
CGGPplotvariogram(SG)
</code></pre>

<hr>
<h2 id='CGGPvalplot'>Plot validation prediction errors for CGGP object</h2><span id='topic+CGGPvalplot'></span>

<h3>Description</h3>

<p>Plot validation prediction errors for CGGP object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPvalplot(CGGP, Xval, Yval, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPvalplot_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object that has been fitted</p>
</td></tr>
<tr><td><code id="CGGPvalplot_+3A_xval">Xval</code></td>
<td>
<p>X validation data</p>
</td></tr>
<tr><td><code id="CGGPvalplot_+3A_yval">Yval</code></td>
<td>
<p>Y validation data</p>
</td></tr>
<tr><td><code id="CGGPvalplot_+3A_d">d</code></td>
<td>
<p>If output is multivariate, which column to use. Will do all if
left as NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, makes a plot
</p>


<h3>See Also</h3>

<p>Other CGGP plot functions: 
<code><a href="#topic+CGGPplotblocks">CGGPplotblocks</a>()</code>,
<code><a href="#topic+CGGPplotcorr">CGGPplotcorr</a>()</code>,
<code><a href="#topic+CGGPplotheat">CGGPplotheat</a>()</code>,
<code><a href="#topic+CGGPplothist">CGGPplothist</a>()</code>,
<code><a href="#topic+CGGPplotsamplesneglogpost">CGGPplotsamplesneglogpost</a>()</code>,
<code><a href="#topic+CGGPplotslice">CGGPplotslice</a>()</code>,
<code><a href="#topic+CGGPplottheta">CGGPplottheta</a>()</code>,
<code><a href="#topic+CGGPplotvariogram">CGGPplotvariogram</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG &lt;- CGGPcreate(d=3, batchsize=100)
f1 &lt;- function(x){x[1]+x[2]^2}
y &lt;- apply(SG$design, 1, f1)
SG &lt;- CGGPfit(SG, y)
Xval &lt;- matrix(runif(3*100), ncol=3)
Yval &lt;- apply(Xval, 1, f1)
CGGPvalplot(CGGP=SG, Xval=Xval, Yval=Yval)
</code></pre>

<hr>
<h2 id='CGGPvalstats'>Calculate stats for CGGP prediction on validation data</h2><span id='topic+CGGPvalstats'></span>

<h3>Description</h3>

<p>Calculate stats for CGGP prediction on validation data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGGPvalstats(CGGP, Xval, Yval, bydim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CGGPvalstats_+3A_cggp">CGGP</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="CGGPvalstats_+3A_xval">Xval</code></td>
<td>
<p>X validation matrix</p>
</td></tr>
<tr><td><code id="CGGPvalstats_+3A_yval">Yval</code></td>
<td>
<p>Y validation data</p>
</td></tr>
<tr><td><code id="CGGPvalstats_+3A_bydim">bydim</code></td>
<td>
<p>If multiple outputs, should it be done separately by dimension?</p>
</td></tr>
<tr><td><code id="CGGPvalstats_+3A_...">...</code></td>
<td>
<p>Passed to valstats, such as which stats to calculate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SG &lt;- CGGPcreate(d=3, batchsize=100)
f1 &lt;- function(x){x[1]+x[2]^2}
y &lt;- apply(SG$design, 1, f1)
SG &lt;- CGGPfit(SG, y)
Xval &lt;- matrix(runif(3*100), ncol=3)
Yval &lt;- apply(Xval, 1, f1)
CGGPvalstats(CGGP=SG, Xval=Xval, Yval=Yval)

# Multiple outputs
SG &lt;- CGGPcreate(d=3, batchsize=100)
f1 &lt;- function(x){x[1]+x[2]^2}
f2 &lt;- function(x){x[1]^1.3+.4*sin(6*x[2])+10}
y1 &lt;- apply(SG$design, 1, f1)#+rnorm(1,0,.01)
y2 &lt;- apply(SG$design, 1, f2)#+rnorm(1,0,.01)
y &lt;- cbind(y1, y2)
SG &lt;- CGGPfit(SG, Y=y)
Xval &lt;- matrix(runif(3*100), ncol=3)
Yval &lt;- cbind(apply(Xval, 1, f1),
              apply(Xval, 1, f2))
CGGPvalstats(SG, Xval, Yval)
CGGPvalstats(SG, Xval, Yval, bydim=FALSE)

</code></pre>

<hr>
<h2 id='plot.CGGP'>S3 plot method for CGGP</h2><span id='topic+plot.CGGP'></span>

<h3>Description</h3>

<p>There are a few different plot functions for CGGP objects:
'CGGPplotblocks', 'CGGPplotblockselection', 
'CGGPplotcorr', 'CGGPplotheat', 'CGGPplothist',
'CGGPvalplot', 
'CGGPplotslice', 'CGGPplotslice', and 'CGGPplotvariogram'.
Currently 'CGGPplotblocks' is the default plot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CGGP'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.CGGP_+3A_x">x</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="plot.CGGP_+3A_y">y</code></td>
<td>
<p>Don't use</p>
</td></tr>
<tr><td><code id="plot.CGGP_+3A_...">...</code></td>
<td>
<p>Passed to CGGPplotblocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either makes plot or returns plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG = CGGPcreate(3,100)
plot(SG)
</code></pre>

<hr>
<h2 id='predict.CGGP'>S3 predict method for CGGP</h2><span id='topic+predict.CGGP'></span><span id='topic+CGGPpred'></span>

<h3>Description</h3>

<p>Passes to CGGPpred
</p>
<p>Predict using SG with y values at xp?
Shouldn't y values already be stored in SG?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CGGP'
predict(object, xp, ...)

CGGPpred(CGGP, xp, theta = NULL, outdims = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CGGP_+3A_object">object</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="predict.CGGP_+3A_xp">xp</code></td>
<td>
<p>x value to predict at</p>
</td></tr>
<tr><td><code id="predict.CGGP_+3A_...">...</code></td>
<td>
<p>Other arguments passed to 'CGGPpred'</p>
</td></tr>
<tr><td><code id="predict.CGGP_+3A_cggp">CGGP</code></td>
<td>
<p>SG object</p>
</td></tr>
<tr><td><code id="predict.CGGP_+3A_theta">theta</code></td>
<td>
<p>Leave as NULL unless you want to use a value other than thetaMAP.
Much slower.</p>
</td></tr>
<tr><td><code id="predict.CGGP_+3A_outdims">outdims</code></td>
<td>
<p>If multiple outputs fit without PCA and with separate
parameters, you can predict just for certain dimensions to speed it up.
Will leave other columns in the output, but they will be wrong.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted mean values
</p>


<h3>See Also</h3>

<p>Other CGGP core functions: 
<code><a href="#topic+CGGPappend">CGGPappend</a>()</code>,
<code><a href="#topic+CGGPcreate">CGGPcreate</a>()</code>,
<code><a href="#topic+CGGPfit">CGGPfit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG &lt;- CGGPcreate(d=3, batchsize=100)
y &lt;- apply(SG$design, 1, function(x){x[1]+x[2]^2+rnorm(1,0,.01)})
SG &lt;- CGGPfit(SG, Y=y)
CGGPpred(SG, matrix(c(.1,.1,.1),1,3))
cbind(CGGPpred(SG, SG$design)$mean, y) # Should be near equal
</code></pre>

<hr>
<h2 id='print.CGGP'>Print CGGP object</h2><span id='topic+print.CGGP'></span>

<h3>Description</h3>

<p>Default print as a list is bad since there's a lot of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CGGP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CGGP_+3A_x">x</code></td>
<td>
<p>CGGP object</p>
</td></tr>
<tr><td><code id="print.CGGP_+3A_...">...</code></td>
<td>
<p>Passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String to be printed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SG = CGGPcreate(3,21)
print(SG)
f &lt;- function(x) {x[1]+exp(x[2]) + log(x[3]+4)}
y &lt;- apply(SG$design, 1, f)
SG &lt;- CGGPfit(SG, y)
print(SG)
</code></pre>

<hr>
<h2 id='rcpp_fastmatclcr'>rcpp_fastmatclcr</h2><span id='topic+rcpp_fastmatclcr'></span>

<h3>Description</h3>

<p>rcpp_fastmatclcr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_fastmatclcr(I, w, MSEmat, S, maxlevel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_fastmatclcr_+3A_i">I</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcr_+3A_w">w</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcr_+3A_msemat">MSEmat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcr_+3A_s">S</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcr_+3A_maxlevel">maxlevel</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, void
</p>

<hr>
<h2 id='rcpp_fastmatclcranddclcr'>rcpp_fastmatclcranddclcr</h2><span id='topic+rcpp_fastmatclcranddclcr'></span>

<h3>Description</h3>

<p>rcpp_fastmatclcranddclcr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_fastmatclcranddclcr(I, w, MSEmat, dMSEmat, S, dS, maxlevel, numpara)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_i">I</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_w">w</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_msemat">MSEmat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_dmsemat">dMSEmat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_s">S</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_ds">dS</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_maxlevel">maxlevel</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="rcpp_fastmatclcranddclcr_+3A_numpara">numpara</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, void
</p>

<hr>
<h2 id='rcpp_gkronDBS'>rcpp_kronDBS</h2><span id='topic+rcpp_gkronDBS'></span>

<h3>Description</h3>

<p>rcpp_kronDBS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_gkronDBS(A, dA, B, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_gkronDBS_+3A_a">A</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_gkronDBS_+3A_da">dA</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_gkronDBS_+3A_b">B</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_gkronDBS_+3A_p">p</code></td>
<td>
<p>Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kronDBS calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcpp_gkronDBS(c(1,1), c(0,0), c(.75), c(1,1))
</code></pre>

<hr>
<h2 id='rcpp_kronDBS'>rcpp_kronDBS</h2><span id='topic+rcpp_kronDBS'></span>

<h3>Description</h3>

<p>rcpp_kronDBS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_kronDBS(A, B, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_kronDBS_+3A_a">A</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_kronDBS_+3A_b">B</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="rcpp_kronDBS_+3A_p">p</code></td>
<td>
<p>Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kronDBS calculation
</p>

<hr>
<h2 id='valplot'>Plot validation prediction errors</h2><span id='topic+valplot'></span>

<h3>Description</h3>

<p>Plot validation prediction errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valplot(predmean, predvar, Yval, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valplot_+3A_predmean">predmean</code></td>
<td>
<p>Predicted mean</p>
</td></tr>
<tr><td><code id="valplot_+3A_predvar">predvar</code></td>
<td>
<p>Predicted variance</p>
</td></tr>
<tr><td><code id="valplot_+3A_yval">Yval</code></td>
<td>
<p>Y validation data</p>
</td></tr>
<tr><td><code id="valplot_+3A_d">d</code></td>
<td>
<p>If output is multivariate, which column to use. Will do all if
left as NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, makes a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(100*3), ncol=3)
f1 &lt;- function(x){x[1]+x[2]^2}
y &lt;- apply(x, 1, f1)
# Create a linear model on the data
mod &lt;- lm(y ~ ., data.frame(x))
# Predict at validation data
Xval &lt;- matrix(runif(3*100), ncol=3)
mod.pred &lt;- predict.lm(mod, data.frame(Xval), se.fit=TRUE)
# Compare to true results
Yval &lt;- apply(Xval, 1, f1)
valplot(mod.pred$fit, mod.pred$se.fit^2, Yval=Yval)
</code></pre>

<hr>
<h2 id='valstats'>Calculate stats for prediction on validation data</h2><span id='topic+valstats'></span>

<h3>Description</h3>

<p>Calculate stats for prediction on validation data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valstats(
  predmean,
  predvar,
  Yval,
  bydim = TRUE,
  RMSE = TRUE,
  score = TRUE,
  CRPscore = TRUE,
  coverage = TRUE,
  corr = TRUE,
  R2 = TRUE,
  MAE = FALSE,
  MIS90 = FALSE,
  metrics,
  min_var = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valstats_+3A_predmean">predmean</code></td>
<td>
<p>Predicted mean</p>
</td></tr>
<tr><td><code id="valstats_+3A_predvar">predvar</code></td>
<td>
<p>Predicted variance</p>
</td></tr>
<tr><td><code id="valstats_+3A_yval">Yval</code></td>
<td>
<p>Y validation data</p>
</td></tr>
<tr><td><code id="valstats_+3A_bydim">bydim</code></td>
<td>
<p>If multiple outputs, should it be done separately by dimension?</p>
</td></tr>
<tr><td><code id="valstats_+3A_rmse">RMSE</code></td>
<td>
<p>Should root mean squared error (RMSE) be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_score">score</code></td>
<td>
<p>Should score be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_crpscore">CRPscore</code></td>
<td>
<p>Should CRP score be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_coverage">coverage</code></td>
<td>
<p>Should coverage be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_corr">corr</code></td>
<td>
<p>Should correlation between predicted and true mean be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_r2">R2</code></td>
<td>
<p>Should R^2 be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_mae">MAE</code></td>
<td>
<p>Should mean absolute error (MAE) be included?</p>
</td></tr>
<tr><td><code id="valstats_+3A_mis90">MIS90</code></td>
<td>
<p>Should mean interval score for 90% confidence be included?
See Gneiting and Raftery (2007).</p>
</td></tr>
<tr><td><code id="valstats_+3A_metrics">metrics</code></td>
<td>
<p>Optional additional metrics to be calculated. Should have
same first three parameters as this function.</p>
</td></tr>
<tr><td><code id="valstats_+3A_min_var">min_var</code></td>
<td>
<p>Minimum value of the predicted variance.
Negative or zero variances can cause errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>References</h3>

<p>Gneiting, Tilmann, and Adrian E. Raftery.
&quot;Strictly proper scoring rules, prediction, and estimation.&quot;
Journal of the American Statistical Association 102.477 (2007): 359-378.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>valstats(c(0,1,2), c(.01,.01,.01), c(0,1.1,1.9))
valstats(cbind(c(0,1,2), c(1,2,3)),
         cbind(c(.01,.01,.01),c(.1,.1,.1)),
         cbind(c(0,1.1,1.9),c(1,2,3)))
valstats(cbind(c(0,1,2), c(8,12,34)),
         cbind(c(.01,.01,.01),c(1.1,.81,1.1)),
         cbind(c(0,1.1,1.9),c(10,20,30)), bydim=FALSE)
valstats(cbind(c(.8,1.2,3.4), c(8,12,34)),
         cbind(c(.01,.01,.01),c(1.1,.81,1.1)),
         cbind(c(1,2,3),c(10,20,30)), bydim=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
