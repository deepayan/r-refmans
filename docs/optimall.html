<!DOCTYPE html><html><head><title>Help for package optimall</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optimall}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allocate_wave'><p>Adaptive Multi-Wave Sampling</p></a></li>
<li><a href='#apply_multiwave'><p>Apply a basic optimall function to a Multiwave Object</p></a></li>
<li><a href='#get_data'><p>Access and Write Slots of a Multiwave Object</p></a></li>
<li><a href='#MatWgt_Sim'><p>Example Dataset: Maternal Weights</p></a></li>
<li><a href='#merge_samples'><p>Merge Sampled Data based on IDs</p></a></li>
<li><a href='#merge_strata'><p>Merge Strata</p></a></li>
<li><a href='#multiwave_diagram'><p>Print Summary Diagram of Multiwave Object</p></a></li>
<li><a href='#Multiwave-class'><p>Multiwave Class for Multi-Wave Sampling Organization</p></a></li>
<li><a href='#new_multiwave'><p>Initialize a Multiwave Object</p></a></li>
<li><a href='#optimall_shiny'><p>Run the shiny application</p></a></li>
<li><a href='#optimum_allocation'><p>Optimum Allocation</p></a></li>
<li><a href='#Phase-class'><p>Phase Class for Multi-Wave Sampling Organization</p></a></li>
<li><a href='#sample_strata'><p>Select Sampling Units based on Stratified Random Sampling</p></a></li>
<li><a href='#shiny_server'><p>Server logic for Interactive Shiny for Optimall.</p></a></li>
<li><a href='#shiny_ui'><p>UI for Shiny App for Splitting Strata with Optimum Allocation</p></a></li>
<li><a href='#split_strata'><p>Split Strata</p></a></li>
<li><a href='#summary,Multiwave-method'><p>Method for summary for class Multiwave</p></a></li>
<li><a href='#Wave-class'><p>Wave Class for Multi-Wave Sampling Organization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Allocate Samples Among Strata</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jasper Yang &lt;jbyang@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the design process of survey sampling, with specific tools for multi-wave and multi-phase designs. Perform optimum allocation using Neyman (1934) &lt;<a href="https://doi.org/10.2307%2F2342192">doi:10.2307/2342192</a>&gt; or Wright (2012) &lt;<a href="https://doi.org/10.1080%2F00031305.2012.733679">doi:10.1080/00031305.2012.733679</a>&gt; allocation, split strata based on quantiles or values of known variables, randomly select samples from strata, allocate sampling waves iteratively, and organize a complex survey design. Also includes a Shiny application for observing the effects of different strata splits.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yangjasp/optimall">https://github.com/yangjasp/optimall</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yangjasp/optimall/issues">https://github.com/yangjasp/optimall/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.5), glue (&ge; 1.4.0), magrittr (&ge; 2.0.0),
methods (&ge; 4.0.0), rlang (&ge; 0.2.2), stats (&ge; 4.0.2), tibble
(&ge; 1.4.2), utils (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bslib (&ge; 0.2.4), DiagrammeR (&ge; 1.0.0), DT (&ge; 0.15),
datasets, globals (&ge; 0.12), knitr (&ge; 1.28), rmarkdown (&ge;
2.7), shiny (&ge; 1.6.0), shinytest (&ge; 1.4.0), survey (&ge; 4.0),
testthat (&ge; 3.0.2), webshot (&ge; 0.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'allocate_wave.R' 'sample_strata.R' 'wave.R' 'phase.R'
'multiwave.R' 'merge_samples.R' 'optimum_allocation.R'
'get_data.R' 'apply_multiwave.R' 'matwgt_sim.R'
'merge_strata.R' 'multiwave_diagram.R' 'new_multiwave.R'
'optimall_shiny.R' 'split_strata.R' 'summary.multiwave.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 16:42:04 UTC; jasper</td>
</tr>
<tr>
<td>Author:</td>
<td>Jasper Yang [aut, cre],
  Pamela Shaw [aut],
  Bryan Shepherd [ctb],
  Thomas Lumley [ctb],
  Gustavo Amorim [rev]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allocate_wave'>Adaptive Multi-Wave Sampling</h2><span id='topic+allocate_wave'></span>

<h3>Description</h3>

<p>Determines the adaptive optimum sampling allocation for a new sampling
wave based on results from previous waves. Using Neyman or
Wright (2014) allocation, <code>allocate_wave</code> calculates the
optimum allocation for the <em>total</em> number of samples
across waves, determines how many were allocated to each strata
in previous waves, and allocates the remaining samples to make
up the difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate_wave(
  data,
  strata,
  y,
  already_sampled,
  nsample,
  allocation_method = c("WrightII", "WrightI", "Neyman"),
  method = c("iterative", "simple"),
  detailed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_wave_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with one row for each
sampling unit, one column specifying each unit's stratum,
one column holding the value of the continuous variable for
which the variance should be minimized, and one column
containing a binary indicator, <code>already_sampled</code>,
specifying whether each unit has already been sampled.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_strata">strata</code></td>
<td>
<p>A character string or vector of character strings
specifying the name of columns that indicate the stratum that
each unit belongs to.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_y">y</code></td>
<td>
<p>A character string specifying the name of the
continuous variable for which the variance should be minimized.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_already_sampled">already_sampled</code></td>
<td>
<p>A character string specifying the name of a
column that contains a binary (<code>Y</code>/<code>N</code> or <code>1</code>
/<code>0</code>) indicator specifying whether each unit has already
been sampled in a previous wave.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_nsample">nsample</code></td>
<td>
<p>The desired sample size of the next wave.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_allocation_method">allocation_method</code></td>
<td>
<p>A character string specifying the method of
optimum sample allocation to use. For details see
<code>optimum_allocation()</code>. Defaults to <code>WrightII</code> which is more exact
than <code>Neyman</code> but may run slower.</p>
</td></tr>
<tr><td><code id="allocate_wave_+3A_method">method</code></td>
<td>
<p>A character string specifying the method to be
used if at least one group was oversampled. Must be one of:
</p>

<ul>
<li> <p><code>"iterative"</code>, the default, will require a longer
runtime but may be a more precise method of handling oversampled
strata. If there are multiple oversampled strata, this method
closes strata and re-calculates optimum allocation one by one.
</p>
</li>
<li> <p><code>"simple"</code> closes all oversampled together and
re-calculates optimum allocation on the rest of the strata only
once. In certain cases where many strata have been oversampled
in prior waves, it is possible that this method will output a
negative value in n_to_sample. When this occurs, the function
will print a warning, and it is recommended that the user
re-runs the allocation with the 'iterative' method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="allocate_wave_+3A_detailed">detailed</code></td>
<td>
<p>A logical value indicating whether the output
dataframe should include details about each stratum including
the true optimum allocation without the constraint of
previous waves of sampling
and stratum standard deviations. Defaults to FALSE.
These details are all available from
<code>optimum_allocation()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the optimum sample size in a stratum is smaller than the
amount it was allocated in previous waves, that strata has been
<em>oversampled</em>. When oversampling occurs,
<code>allocate_wave</code> &quot;closes&quot; the oversampled strata and
re-allocates the remaining samples optimally among the open
strata. Under these circumstances, the total sampling
allocation is no longer optimal, but <code>optimall</code> will
output the <em>most</em> optimal allocation possible for the next wave.
</p>


<h3>Value</h3>

<p>Returns a dataframe with one row for each stratum and
columns specifying the stratum name (&quot;strata&quot;), population stratum size
(<code>"npop"</code>), cumulative sample in that strata
(<code>"nsample_actual"</code>), prior number sampled in that
strata (<code>"nsample_prior"</code>), and the optimally allocated
number of units in each strata for the next wave (<code>"n_to_sample"</code>).
</p>


<h3>References</h3>

<p>McIsaac MA, Cook RJ. Adaptive sampling in two-phase designs:
a biomarker study for progression in arthritis. Statistics in medicine.
2015 Sep 20;34(21):2899-912.
</p>
<p>Reilly, M., &amp; Pepe, M. S. (1995). A mean score method for
missing and auxiliary covariate data in regression models.
Biometrika, 82(2), 299-314.
</p>
<p>Wright, T. (2014). A Simple Method of Exact Optimal
Sample Allocation under Stratification with any Mixed
Constraint Patterns, Research Report Series (Statistics #2014-07),
Center for Statistical Research and Methodology, U.S. Bureau
of the Census, Washington, D.C.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dataframe with a column specifying strata, a variable of interest
# and an indicator for whether each unit was already sampled
set.seed(234)
mydata &lt;- data.frame(Strata = c(rep(1, times = 20),
                                rep(2, times = 20),
                                rep(3, times = 20)),
                     Var = c(rnorm(20, 1, 0.5),
                             rnorm(20, 1, 0.9),
                             rnorm(20, 1.5, 0.9)),
                     AlreadySampled = rep(c(rep(1, times = 5),
                                            rep(0, times = 15)),
                                          times = 3))

x &lt;- allocate_wave(
  data = mydata, strata = "Strata",
  y = "Var", already_sampled = "AlreadySampled",
  nsample = 20, method = "simple"
)
</code></pre>

<hr>
<h2 id='apply_multiwave'>Apply a basic optimall function to a Multiwave Object</h2><span id='topic+apply_multiwave'></span><span id='topic+apply_multiwave+2CMultiwave-method'></span>

<h3>Description</h3>

<p>Given a specified phase and wave of an object of class multiwave,
<code>apply_multiwave</code> applies one of four <code>optimall</code> functions
and returns an updated multiwave object with the output of the applied
function in its specified slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_multiwave(x, phase, wave, fun, ...)

## S4 method for signature 'Multiwave'
apply_multiwave(x, phase, wave, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_multiwave_+3A_x">x</code></td>
<td>
<p>An Object of class <code>"multiwave"</code></p>
</td></tr>
<tr><td><code id="apply_multiwave_+3A_phase">phase</code></td>
<td>
<p>A numeric or character value specifying the phase of
<code>multiwave</code> where the desired output should be placed.</p>
</td></tr>
<tr><td><code id="apply_multiwave_+3A_wave">wave</code></td>
<td>
<p>A numeric or character value specifying the wave of <code>phase</code>
in <code>multiwave</code> where the output should be placed.</p>
</td></tr>
<tr><td><code id="apply_multiwave_+3A_fun">fun</code></td>
<td>
<p>A character value specifying the name of the <code>optimall</code>
function to apply. The four available functions are:
<code>optimum_allocation</code>,
<code>allocate_wave</code>, <code>sample_strata</code>, and <code>merge_samples</code>.
</p>

<ul>
<li> <p><code>optimum_allocation</code>: Uses the <code>data</code> from
the previous wave
(or previous phase if <code>wave = 1</code>) to determine the optimum sampling
allocation for the specified wave. If used, the output multiwave
object contains an updated <code>"design"</code> slot in the specified wave.
</p>
</li>
<li> <p><code>allocate_wave</code>: Uses the <code>data</code> from the previous wave
(or previous phase if <code>wave = 1</code>) to determine the optimum sampling
allocation for the specified wave. If used, the outputted multiwave object
contains an updated <code>"design"</code> slot in the specified wave.
The default argument when <code>allocate_wave</code> is applied in a <code>apply_multiwave()</code> is <code>detailed = TRUE</code>.
</p>
</li>
<li> <p><code>sample_strata</code>: Uses the <code>data</code> from the previous wave
(or previous phase if <code>wave = 1</code>) and <code>design</code>
from current wave to generate a vector of ids to sample for the current
wave. If used, the output multiwave object contains an updated
<code>"samples"</code> slot in the specified wave.
</p>
</li>
<li> <p><code>merge_samples</code>: Uses the <code>data</code> from the previous wave (or
previous phase if <code>wave = 1</code>) and <code>sampled_data</code> from the
specified wave to generate the final, merged data for the current wave.
If used, the output multiwave object contains an updated <code>"data"</code>
slot in the specified wave. Note that <code>merge_samples</code> is already a
method for multiwave objects, so calling
it through <code>apply_multiwave</code> is the exact same as calling it on its
own.</p>
</li></ul>

<p>See documentation of these functions for more details on the
specific uses and arguments.</p>
</td></tr>
<tr><td><code id="apply_multiwave_+3A_...">...</code></td>
<td>
<p>Optional arguments to be given to <code>fun</code>. Not necessary if
the arguments are already provided as named values in the wave, phase,
or overall metadata in the multiwave object. Arguments provided here
will override specifications in the metadata if provided in both places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inputted multiwave object with one slot updated to include the
output of the specified function.
</p>
<p>Note that the phase and wave arguments specify where the function
<em>output</em> should be placed. <code>apply_multiwave</code> will determine where
to get the input dataframes from (returning an error if those slots are
empty or invalid) given the specified wave for the output. For example, if
<code>phase = 2, wave = 2, function = "allocate_wave"</code>, the data to
determine the optimum allocation will be taken from the previous wave
(phase 2, wave 1) and the output multiwave object will have an updated
<code>"design"</code> slot of phase 2, wave 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(datasets)

MySurvey &lt;- new_multiwave(phases = 2, waves = c(1, 3))
get_data(MySurvey, phase = 1, slot = "data") &lt;-
  dplyr::select(datasets::iris, -Sepal.Width)

# Get Design by applying optimum_allocation
MySurvey &lt;- apply_multiwave(MySurvey,
  phase = 2, wave = 1,
  fun = "optimum_allocation", strata = "Species",
  y = "Sepal.Length",
  nsample = 15,
  method = "WrightII"
)

# or, we can establish function args in the metadata
get_data(MySurvey, phase = 2, slot = "metadata") &lt;- list(
  strata = "Species",
  nsample = 15,
  y = "Sepal.Length",
  method = "WrightII"
)

# which allows the function to be run without specifying the args
MySurvey &lt;- apply_multiwave(MySurvey,
  phase = 2, wave = 1,
  fun = "optimum_allocation"
)
</code></pre>

<hr>
<h2 id='get_data'>Access and Write Slots of a Multiwave Object</h2><span id='topic+get_data'></span><span id='topic+get_data+2CMultiwave-method'></span><span id='topic+get_data+3C-'></span><span id='topic+get_data+3C-+2CMultiwave-method'></span>

<h3>Description</h3>

<p><code>get_data</code> is the accessor function for objects of
class <code>Multiwave</code>. It can be used to access or write slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(
  x,
  phase = 1,
  wave = NA,
  slot = c("data", "design", "metadata", "samples", "sampled_data")
)

get_data(
  x,
  phase = 1,
  wave = NA,
  slot = c("data", "design", "metadata", "samples", "sampled_data")
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_x">x</code></td>
<td>
<p>an object of class <code>'Multiwave'</code></p>
</td></tr>
<tr><td><code id="get_data_+3A_phase">phase</code></td>
<td>
<p>a numeric value specifying the phase that should be accessed.
To access the overall metadata, set <code>phase = NA</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="get_data_+3A_wave">wave</code></td>
<td>
<p>a numeric value specifying the wave that should be accessed.
Ta access phase metadata, set <code>wave = NA</code>. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="get_data_+3A_slot">slot</code></td>
<td>
<p>a character value specifying the name of the slot to be
accessed. Must be one of <code>"metadata"</code>, <code>"design"</code>,
<code>"samples"</code>, <code>"sampled_data"</code>, <code>"data"</code>. Defaults to
<code>"data"</code>. See class documentation or package vignettes for more
information about slots.</p>
</td></tr>
<tr><td><code id="get_data_+3A_value">value</code></td>
<td>
<p>value to assign to specified slot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If accessing a multiwave object slot, returns the specified slot.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_data()</code>: access slot of multiwave object
</p>
</li>
<li> <p><code>get_data(
  x,
  phase = 1,
  wave = NA,
  slot = c("data", "design", "metadata", "samples", "sampled_data")
) &lt;- value</code>: assign value to slot of a multiwave object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Intiate multiwave object
MySurvey &lt;- new_multiwave(phases = 2, waves = c(1, 3))

# To access overall metadata
get_data(MySurvey, phase = NA, slot = "metadata")

# To write overall metadata
get_data(MySurvey, phase = NA, slot = "metadata") &lt;- list(
  title = "Maternal Weight Survey"
)

# To access Phase 2 metadata
get_data(MySurvey, phase = 2, slot = "metadata")

# To access Phase 2, Wave 2 design
get_data(MySurvey, phase = 2, wave = 2, slot = "design")
</code></pre>

<hr>
<h2 id='MatWgt_Sim'>Example Dataset: Maternal Weights</h2><span id='topic+MatWgt_Sim'></span>

<h3>Description</h3>

<p>This SIMULATED dataset contains data on demographic
characteristics and clinical data related to childhood obesity
for 10335 mother-child pairs. It is used to generate the
workflow in the main package vignette. It is based on a study
that used multi-wave adaptive sampling to validate electronic
health records that target factors related to childhood obesity
(see https://www.pcori.org/research-results/2017/developin-methods-estimate-and-address-errors-studies-using-electronic-health).
</p>


<h3>Format</h3>

<p><code>MatWgt_Sim:</code> a data frame with 10335 rows and 6 columns
</p>

<dl>
<dt><code>id</code></dt><dd><p>unique ID for each mother-child pair</p>
</dd>
<dt><code>mat_weight_true</code></dt><dd><p>true (but unknown in phase 1) mother weight
change during pregnancy</p>
</dd>
<dt><code>mat_weight_est</code></dt><dd><p>estimated mother weight
change during pregnancy based on error-prone phase-1 measurement</p>
</dd>
<dt><code>race</code></dt><dd><p>specifies mother's race</p>
</dd>
<dt><code>diabetes</code></dt><dd><p>binary indicator for diabetes in the mother</p>
</dd>
<dt><code>obesity</code></dt><dd><p>binary indicator for childhood obesity in child</p>
</dd>
</dl>



<h3>Details</h3>

<p>See package vignettes for more details.
</p>

<hr>
<h2 id='merge_samples'>Merge Sampled Data based on IDs</h2><span id='topic+merge_samples'></span><span id='topic+merge_samples+2CMultiwave-method'></span>

<h3>Description</h3>

<p>In an object of class <code>"Mutiwave"</code>, <code>merge_samples</code> creates
a dataframe in the <code>"data"</code> slot of the specified wave by merging
the dataframe in the <code>"sampled data"</code> slot with the dataframe in
the <code>"data"</code> slot of the previous wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_samples(x, phase, wave, id = NULL, sampled_ind = "already_sampled_ind")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_samples_+3A_x">x</code></td>
<td>
<p>an object of class <code>"Multiwave"</code>.</p>
</td></tr>
<tr><td><code id="merge_samples_+3A_phase">phase</code></td>
<td>
<p>A numeric value specifying the phase of the
Multiwave object that
the specified wave is in. Cannot be phase 1.</p>
</td></tr>
<tr><td><code id="merge_samples_+3A_wave">wave</code></td>
<td>
<p>A numeric value specifying the wave of the Multiwave
object that the merge should be
performed in. This wave must have a valid dataframe in the
<code>"sampled data"</code> slot. The previous wave, taken as the final
wave of the previous phase if <code>wave</code> = 1, must have a valid
dataframe in the <code>"data"</code> slot.</p>
</td></tr>
<tr><td><code id="merge_samples_+3A_id">id</code></td>
<td>
<p>A character value specifying the name of the column holding unit
ids. Taken from wave, phase, or overall metadata (searched for in that
order) if <code>NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="merge_samples_+3A_sampled_ind">sampled_ind</code></td>
<td>
<p>a character value specifying the name of the column that
should hold the indicator of whether each unit has already been sampled in
the current phase.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a column name in the <code>"sampled data"</code> matches a column name in
the <code>"data"</code> slot of the previous wave, these columns will be
merged into one column with the same name in the output dataframe.
For ids that have non-missing values in both columns of the merge,
the value from
<code>"sampled_data"</code> will overwrite the previous value and a warning
will be printed. All ids present in the <code>"data"</code> from the previous
wave but missing from <code>"sampled_data"</code> will be given NA values
for the newly merged variables
</p>
<p>Columns in <code>"sampled_data"</code> that do not match names of the
<code>"data"</code> from the previous wave will be added as new columns in
the output dataframe. All ids that do not appear in
<code>"sampled_data"</code> will receive NA values for these new variables.
</p>


<h3>Value</h3>

<p>A Multiwave object with the merged dataframe in the
<code>"data"</code> slot of the specified wave.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
iris &lt;- data.frame(iris, id = 1:150)

MySurvey &lt;- new_multiwave(phases = 2, waves = c(1, 3))
get_data(MySurvey, phase = 1, slot = "data") &lt;-
  data.frame(dplyr::select(iris, -Sepal.Width))
get_data(MySurvey, phase = 2, wave = 1, slot = "sampled_data") &lt;-
  dplyr::select(iris, id, Sepal.Width)[1:40, ]
MySurvey &lt;- merge_samples(MySurvey, phase = 2, wave = 1, id = "id")
</code></pre>

<hr>
<h2 id='merge_strata'>Merge Strata</h2><span id='topic+merge_strata'></span>

<h3>Description</h3>

<p>Merges multiple pre-defined sampling strata into a single stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_strata(data, strata, merge, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_strata_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix with one row for each sampling
unit, one column, <code>strata</code>,
specifying each unit's current stratum, and any
other relevant columns.</p>
</td></tr>
<tr><td><code id="merge_strata_+3A_strata">strata</code></td>
<td>
<p>a character string specifying the name of the
column that defines each unit's current strata.</p>
</td></tr>
<tr><td><code id="merge_strata_+3A_merge">merge</code></td>
<td>
<p>the names of the strata to be merged, exactly as
they appear in <code>strata</code>.</p>
</td></tr>
<tr><td><code id="merge_strata_+3A_name">name</code></td>
<td>
<p>a character name for the new stratum. Defaults to
NULL, which pastes the old strata names together to create the
new stratum name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input dataframe with a new column named
'new_strata' that holds the name of the stratum that each sample
belongs to after the merge. The column containing the previous
strata names is retained and given the name 'old_strata'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- merge_strata(iris,
  strata = "Species",
  merge = c("virginica", "versicolor"), name = "v_species"
)
</code></pre>

<hr>
<h2 id='multiwave_diagram'>Print Summary Diagram of Multiwave Object</h2><span id='topic+multiwave_diagram'></span>

<h3>Description</h3>

<p>Takes a multiwave object as input and plots a diagram of its structure
in the plotting window using <code>grViz()</code> from the <code>DiagrammeR</code>
package. Red boxes indicate slots that have not yet been
filled, blue boxes indicate that the slot is filled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiwave_diagram(x, height = NULL, width = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiwave_diagram_+3A_x">x</code></td>
<td>
<p>An object of class <code>multiwave</code>.</p>
</td></tr>
<tr><td><code id="multiwave_diagram_+3A_height">height</code></td>
<td>
<p>The height in pixels of the diagram. Defaults to <code>NULL</code>
, which produces default height.</p>
</td></tr>
<tr><td><code id="multiwave_diagram_+3A_width">width</code></td>
<td>
<p>The width in pixels of the diagram. Defaults to <code>NULL</code>,
which produces the default width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>htmlwidget</code>
displaying the structure of the <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MySurvey &lt;- new_multiwave(phases = 2, waves = c(1, 3))
multiwave_diagram(MySurvey)
</code></pre>

<hr>
<h2 id='Multiwave-class'>Multiwave Class for Multi-Wave Sampling Organization</h2><span id='topic+Multiwave-class'></span><span id='topic+Multiwave'></span>

<h3>Description</h3>

<p><span class="pkg">optimall</span> defines three S4 classes for organizing the
multi-wave sampling workflow: <code>Wave</code>, <code>Phase</code>, and
<code>Multiwave</code>.
An object of class <code>Multiwave</code> holds metadata and a list of objects of
class <code>Phase</code>, which in turn holds metadata and a list of
objects of class
<code>Wave</code>. These three object classes are used together to organize the
workflow of multi-wave sampling designs.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list of elements that describe the entire survey.
The list is empty upon initialization of the multiwave object, but the user
may add anything to it as they see fit. It may include a &quot;title&quot;.</p>
</dd>
<dt><code>phases</code></dt><dd><p>A list of objects of class <code>Phase</code> (see other class
documentation).</p>
</dd>
</dl>

<hr>
<h2 id='new_multiwave'>Initialize a Multiwave Object</h2><span id='topic+new_multiwave'></span>

<h3>Description</h3>

<p>Creates an Object of Class <code>Multiwave</code> with the specified number
of phases and waves. All contents will be NULL upon initialization,
but the object contains a framework for contents to be added to
during the survey design and sample collection process. Currently,
multiwave objects may only have one wave in Phase 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_multiwave(phases, waves, metadata = list(), phase1 = data.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_multiwave_+3A_phases">phases</code></td>
<td>
<p>A numeric value specifying the number of phases in the
survey design.</p>
</td></tr>
<tr><td><code id="new_multiwave_+3A_waves">waves</code></td>
<td>
<p>A vector of numeric values specifying the number of waves in
each phase of the survey design. Length must match the number of
<code>phases</code> and the first</p>
</td></tr>
<tr><td><code id="new_multiwave_+3A_metadata">metadata</code></td>
<td>
<p>A list containing the survey metadata.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="new_multiwave_+3A_phase1">phase1</code></td>
<td>
<p>A dataframe containing the phase 1 data of the survey.
Defaults to an empty dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Multiwave</code> that stores all
relevant data from the survey design in an organized and easy-to-access
manner. See package vignettes or class documentation for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Initialize a multiwave object for a two-phase sampling design that will
# sample over three waves in the second phase
multiwave_object &lt;- new_multiwave(phases = 2, waves = c(1, 3))

# If we already have the phase 1 data and want to add a title to the survey
# metadata, we can initialize the object with these included.

library(datasets)
multiwave_object &lt;- new_multiwave(
  phases = 2, waves = c(1, 3),
  metadata = list(title = "my two-phase survey"), phase1 = iris
)
</code></pre>

<hr>
<h2 id='optimall_shiny'>Run the shiny application</h2><span id='topic+optimall_shiny'></span>

<h3>Description</h3>

<p>Launches an R Shiny application locally. This app can be used to
interactively split strata and determine how the results affect
optimum allocation of a fixed number of samples. It accepts
.csv and .rds files as well as .rda files that contain a single
dataset. See vignette titled &quot;Splitting Strata with Optimall Shiny&quot;
for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimall_shiny(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimall_shiny_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to <code>shiny::runApp</code>.
<code>display.mode</code> is already set to normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Launches an R Shiny application locally.
</p>

<hr>
<h2 id='optimum_allocation'>Optimum Allocation</h2><span id='topic+optimum_allocation'></span>

<h3>Description</h3>

<p>Determines the optimum sampling fraction and sample size for
each stratum in a stratified random sample, which
minimizes the variance of the sample mean according to Neyman
Allocation or Exact Optimum Sample Allocation (Wright 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimum_allocation(
  data,
  strata,
  y = NULL,
  sd_h = NULL,
  N_h = NULL,
  nsample = NULL,
  ndigits = 2,
  method = c("WrightII", "WrightI", "Neyman"),
  allow.na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimum_allocation_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with at least one column specifying
each unit's stratum, and either 1) a second column holding the value of the
continuous variable for which the sample mean variance should be minimized
(<code>y</code>) or 2) two columns: one holding the the within-stratum
standard deviation for the variable of interest (<code>sd_h</code>) and another
holding the stratum sample sizes (<code>N_h</code>).
If <code>data</code> contains a column <code>y</code> holding values for
the variable of interest, then <code>data</code> should have one row for
each sampled unit. If <code>data</code> holds <code>sd_h</code> and <code>N_h</code>, the
within-stratum standard deviations and population sizes, then <code>data</code>
should have one row per stratum.
Other columns are allowed but will be ignored.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_strata">strata</code></td>
<td>
<p>a character string or vector of character strings
specifying the name(s) of columns which specify the stratum
that each unit belongs to. If multiple column names are
provided, each unique combination of values in these columns
is taken to define one stratum.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_y">y</code></td>
<td>
<p>a character string specifying the name of the
continuous variable for which the variance should be minimized.
Defaults to <code>NULL</code> and should be left as <code>NULL</code> when <code>data</code>
holds stratum standard deviations and sample sizes instead of individual
sampling units.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_sd_h">sd_h</code></td>
<td>
<p>a character string specifying the name of the
column holding the within-stratum standard deviations for each stratum.
Defaults to <code>NULL</code> and should be left as <code>NULL</code> when <code>data</code>
holds individual sampling units.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_n_h">N_h</code></td>
<td>
<p>a character string specifying the name of the
column holding the population stratum sizes for each stratum.
Defaults to <code>NULL</code> and should be left as <code>NULL</code> when <code>data</code>
holds individual sampling units.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_nsample">nsample</code></td>
<td>
<p>the desired total sample size. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_ndigits">ndigits</code></td>
<td>
<p>a numeric value specifying the number of digits
to which the standard deviation and stratum fraction should be rounded.
Defaults to 2.</p>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_method">method</code></td>
<td>
<p>a character string specifying the method of
optimum sample allocation to use. Must be one of:
</p>

<ul>
<li> <p><code>"WrightII"</code>, the default, uses Algorithm II from
Wright (2014) to determine the optimum allocation of a fixed
sample size across the strata. It requires that at least two
samples are allocated to each stratum.
</p>
</li>
<li> <p><code>"WrightI"</code> uses Wright's Algorithm I to determine
the optimum sample allocation. It only requires that at least
one sample is allocated to each stratum, and can therefore
lead to a biased variance estimate.
</p>
</li>
<li> <p><code>"Neyman"</code> uses the standard method of Neyman
Allocation to determine the optimum sample allocation. When
<code>nsample = NULL</code>, the optimal sampling fraction is calculated
and returned. When a numeric value is specified for <code>nsample</code>,
then the number allocated to each stratum is the optimal sampling
fraction times <code>nsample</code> rounded to the nearest integer,
which may no longer be optimall.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimum_allocation_+3A_allow.na">allow.na</code></td>
<td>
<p>logical input specifying whether y should
be allowed to have NA values. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the specified total
sample size, <code>nsample</code>, allocated across
strata or the sampling fractions if nsample is NULL.
</p>


<h3>References</h3>

<p>Wright, T. (2014). A Simple Method of Exact Optimal
Sample Allocation under Stratification with any Mixed
Constraint Patterns, Research Report Series (Statistics #2014-07),
Center for Statistical Research and Methodology, U.S. Bureau
of the Census, Washington, D.C.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optimum_allocation(
  data = iris, strata = "Species", y = "Sepal.Length",
  nsample = 40, method = "WrightII"
)

# Or if input data is summary of strata sd and N:
iris_summary &lt;- data.frame(
  strata = unique(iris$Species),
  size = c(50, 50, 50),
  sd = c(0.3791, 0.3138, 0.3225)
)

optimum_allocation(
  data = iris_summary, strata = "strata",
  sd_h = "sd", N_h = "size",
  nsample = 40, method = "WrightII"
)
</code></pre>

<hr>
<h2 id='Phase-class'>Phase Class for Multi-Wave Sampling Organization</h2><span id='topic+Phase-class'></span><span id='topic+Phase'></span>

<h3>Description</h3>

<p><span class="pkg">optimall</span> defines three S4 classes for organizing the
multi-wave sampling workflow: <code>Wave</code>, <code>Phase</code>,
and <code>Multiwave</code>.
An object of class <code>Multiwave</code> holds metadata and a list of objects of
class <code>Phase</code>, which in turn holds metadata and a list of
objects of class
<code>Wave</code>. These three object classes are used together to organize the
workflow of multi-wave sampling designs.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list containing the phase metadata</p>
</dd>
<dt><code>waves</code></dt><dd><p>A list of objects of class <code>Wave</code>, each element
representing one wave of the phase</p>
</dd>
</dl>

<hr>
<h2 id='sample_strata'>Select Sampling Units based on Stratified Random Sampling</h2><span id='topic+sample_strata'></span>

<h3>Description</h3>

<p>Requires two dataframes or matrices: <code>data</code> with a column
<code>strata</code> which specifies stratum membership for each unit in
the population and a second dataframe <code>design_data</code> with one
row per strata level with a column <code>design_strata</code> that
indicates the unique levels of <code>strata</code> in <code>data</code> and
<code>n_allocated</code> that specifies the
number to be sampled from each stratum.
<code>sample_strata</code> selects the units to sample by
selecting a random sample of the desired size within each
stratum. The second dataframe can be the output of <code>allocate_wave()</code>
or <code>optimum_allocation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_strata(
  data,
  strata,
  id,
  already_sampled = NULL,
  design_data,
  design_strata = "strata",
  n_allocated = "n_to_sample"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_strata_+3A_data">data</code></td>
<td>
<p>A data frame or matrix with one row for each
sampling unit in the population, one column specifying each
unit's stratum, and one column with a unique identifier for each
unit.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_strata">strata</code></td>
<td>
<p>a character string specifying the name of column
in <code>data</code> which indicates stratum membership.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_id">id</code></td>
<td>
<p>a character string specifying the name of the column
in <code>data</code> that uniquely identifies each unit.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_already_sampled">already_sampled</code></td>
<td>
<p>a character sting specifying the name of the
column in <code>data</code> which indicates (1/0 or Y/N) whether a
unit has already been sampled in a prior wave. Defaults to NULL
which means that none have been sampled yet.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_design_data">design_data</code></td>
<td>
<p>a dataframe or matrix with one row for each stratum
that subdivides the population, one column specifying the
stratum name, and one column indicating the number of samples
allocated to each stratum.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_design_strata">design_strata</code></td>
<td>
<p>a character string specifying the name of the
column in <code>design_data</code> that contains the stratum levels.
Defaults to &quot;strata&quot;.</p>
</td></tr>
<tr><td><code id="sample_strata_+3A_n_allocated">n_allocated</code></td>
<td>
<p>a character string specifying the name of the
column in <code>design_data</code> that indicates the n allocated to each
stratum. Defaults to &quot;n_to_sample&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns <code>data</code> as a dataframe with a new column named
&quot;sample_indicator&quot; containing a binary (1/0) indicator of
whether each unit should be sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a design dataframe
design &lt;- data.frame(
  strata = c("setosa", "virginica", "versicolor"),
  n_to_sample = c(5, 5, 5)
)

# Make sure there is an id column
iris$id &lt;- 1:nrow(iris)

# Run
sample_strata(
  data = iris, strata = "Species", id = "id",
  design_data = design, design_strata = "strata", n_allocated = "n_to_sample"
)

# If some units had already been sampled
iris$already_sampled &lt;- rbinom(nrow(iris), 1, 0.25)

sample_strata(
  data = iris, strata = "Species", id = "id",
  already_sampled = "already_sampled",
  design_data = design, design_strata = "strata", n_allocated = "n_to_sample"
)
</code></pre>

<hr>
<h2 id='shiny_server'>Server logic for Interactive Shiny for Optimall.</h2><span id='topic+shiny_server'></span>

<h3>Description</h3>

<p>Server logic for Interactive Shiny for Optimall.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_server(input, output, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiny_server_+3A_input">input</code></td>
<td>
<p>input for Shiny server.</p>
</td></tr>
<tr><td><code id="shiny_server_+3A_output">output</code></td>
<td>
<p>output for by Shiny server.</p>
</td></tr>
<tr><td><code id="shiny_server_+3A_session">session</code></td>
<td>
<p>session for Shiny server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Defines server logic for Shiny app that can be loaded with
<code>optimall_shiny()</code>.
</p>

<hr>
<h2 id='shiny_ui'>UI for Shiny App for Splitting Strata with Optimum Allocation</h2><span id='topic+shiny_ui'></span>

<h3>Description</h3>

<p>UI for Shiny App for Splitting Strata with Optimum Allocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_ui()
</code></pre>


<h3>Value</h3>

<p>Creates the UI for the Shiny app that is loaded with
<code>optimall_shiny</code>.
</p>

<hr>
<h2 id='split_strata'>Split Strata</h2><span id='topic+split_strata'></span>

<h3>Description</h3>

<p>Splits pre-defined sampling strata based on values of a
continuous or categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_strata(
  data,
  strata,
  split = NULL,
  split_var,
  type = "global quantile",
  split_at = 0.5,
  trunc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_strata_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix with one row for each
sampling unit, one column specifying each unit's current
stratum, one column containing the continuous or categorical
values that will define the split, and any other relevant
columns.</p>
</td></tr>
<tr><td><code id="split_strata_+3A_strata">strata</code></td>
<td>
<p>a character string specifying the name of the
column that defines each unit's current strata.</p>
</td></tr>
<tr><td><code id="split_strata_+3A_split">split</code></td>
<td>
<p>the name of the stratum or strata to be split,
exactly as they appear in <code>strata</code>. Defaults to NULL,
which indicates that all strata in <code>strata</code> will be split.</p>
</td></tr>
<tr><td><code id="split_strata_+3A_split_var">split_var</code></td>
<td>
<p>a character string specifying the name of the
column that should be used to define the strata splits.</p>
</td></tr>
<tr><td><code id="split_strata_+3A_type">type</code></td>
<td>
<p>a character string specifying how the function
should interpret the <code>split_at</code> argument. Must be one of:
</p>

<ul>
<li> <p><code>"global quantile"</code>, the default, splits the strata
at the quantiles specified in <code>split_at</code> defined along
the entire, unfiltered <code>split_var</code> column.
</p>
</li>
<li> <p><code>"local quantile"</code> splits the strata at the
quantiles specified in <code>split_at</code> defined along the
filtered <code>split_var</code> column which only includes units in
the stratum being split.
</p>
</li>
<li> <p><code>"value"</code> splits the strata at the values specified
in <code>split_at</code> along <code>split_var</code> column.
</p>
</li>
<li> <p><code>"categorical"</code> splits the strata into two new
strata, one that contains each unit where <code>split_var</code>
matches an input of <code>split_at</code>, and a second that contains
every other unit.
</p>
</li></ul>
</td></tr>
<tr><td><code id="split_strata_+3A_split_at">split_at</code></td>
<td>
<p>the percentile, value, or name(s) which
<code>split_var</code> should be split at. The interpretation of
this input depends on <code>type</code>. For <code>"quantile"</code> types,
input must be between <code>0</code> and <code>1</code>. Defaults to
<code>0.5</code> (median). For <code>"categorical"</code> type, the
input should be a vector of values or names in <code>split_var</code>
that define the new stratum.</p>
</td></tr>
<tr><td><code id="split_strata_+3A_trunc">trunc</code></td>
<td>
<p>A numeric or character value specifying how the
name of the <code>split_var</code> should be truncated when naming
the new strata. If numeric, the new strata name will only
include the first 'n' characters of the <code>split_var</code> name.
If character, the specified string will be used to name the new
strata instead of the <code>split_var</code> name. Defaults to
<code>NULL</code>, which creates the new strata name using the entire
name of the <code>split_var</code> column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For splits on continuous variables, the new strata are defined
on left-open intervals. The only exception is the first interval,
which must include the overall minimum value. The names of the newly
created strata for a split generated
from a continuous value are the <code>split_var</code> column name with
the range of values defining that stratum appended to the
old strata name. For a categorical split, the new strata names
are the <code>split_var</code> column name appended to the
1/0 logical flag specifying whether the unit is in <code>split at</code>,
all appended to the old strata name.
If the <code>split_var</code> column name is long,
the user can specify a value for <code>trunc</code> to prevent the new
strata names from being inconveniently long.
</p>


<h3>Value</h3>

<p>Returns the input dataframe with a new column named
'new_strata' that holds the name of the stratum that each
sample belongs to after the split. The column containing the
previous strata names is retained and given the name &quot;old_strata&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- split_strata(iris, "Sepal.Length",
  strata = c("Species"),
  split = "setosa", split_var = "Sepal.Width",
  split_at = c(0.5), type = "global quantile"
)

# You can split at more than one quantile in one call.
# The above call splits the "setosa" stratum into three of equal size
x &lt;- split_strata(iris, "Sepal.Length",
  strata = c("Species"),
  split = "setosa", split_var = "Sepal.Width", split_at = c(0.33, 0.66),
  type = "local quantile"
)

# Manually select split values with type = "value"
x &lt;- split_strata(iris, "Sepal.Length",
  strata = "Species",
  split = "setosa", split_var = "Sepal.Width",
  split_at = c(3.1, 3.8), type = "value"
)

# Perform a categorical split.
iris$strata &lt;- rep(c(rep(1, times = 25), rep(0, times = 25)), times = 3)
x &lt;- split_strata(iris, "Sepal.Length",
  strata = "strata",
  split = NULL, split_var = "Species",
  split_at = c("virginica", "versicolor"), type = "categorical"
)
# Splits each initial strata 1 and 2 into one stratum with "virginia"
# and "versicolor" species and one stratum with all of the other species
# not specified in the split_at argument.
</code></pre>

<hr>
<h2 id='summary+2CMultiwave-method'>Method for summary for class Multiwave</h2><span id='topic+summary+2CMultiwave-method'></span>

<h3>Description</h3>

<p>Method for summary for class Multiwave
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Multiwave'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CMultiwave-method_+3A_object">object</code></td>
<td>
<p>object of class &quot;Multiwave&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the specified multiwave object in the console.
</p>

<hr>
<h2 id='Wave-class'>Wave Class for Multi-Wave Sampling Organization</h2><span id='topic+Wave-class'></span><span id='topic+Wave'></span>

<h3>Description</h3>

<p><span class="pkg">optimall</span> defines three S4 classes for organizing the
multi-wave sampling workflow: <code>Wave</code>, <code>Phase</code>,
and <code>Multiwave</code>.
An object of class <code>Multiwave</code> holds metadata and a list of objects of
class <code>Phase</code>, which in turn holds metadata and a list of
objects of class
<code>Wave</code>. These three object classes are used together to organize the
workflow of multi-wave sampling designs.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list containing the metadata for the wave.</p>
</dd>
<dt><code>design</code></dt><dd><p>a dataframe specifying the design of the wave.
Is often the output of <code>allocate_wave</code>.</p>
</dd>
<dt><code>samples</code></dt><dd><p>A character vector containing the ids of the units
sampled in the wave.</p>
</dd>
<dt><code>sampled_data</code></dt><dd><p>A dataframe holding the data, with ids,
<em>collected</em> in this wave of sampling</p>
</dd>
<dt><code>data</code></dt><dd><p>A dataframe holding the updated full data set with all of
the Phase 1 sampling units including the samples collected in this wave.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
