<!DOCTYPE html><html><head><title>Help for package skedastic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {skedastic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alvm.fit'><p>Auxiliary Linear Variance Model</p></a></li>
<li><a href='#anlvm.fit'><p>Auxiliary Nonlinear Variance Model</p></a></li>
<li><a href='#anscombe'><p>Anscombe's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#avm.ci'><p>Bootstrap Confidence Intervals for Linear Regression Error Variances</p></a></li>
<li><a href='#avm.fwls'><p>Apply Feasible Weighted Least Squares to a Linear Regression Model</p></a></li>
<li><a href='#avm.vcov'><p>Estimate Covariance Matrix of Ordinary Least Squares Estimators</p>
Using Error Variance Estimates from an Auxiliary Variance Model</a></li>
<li><a href='#bamset'><p>Ramsey's BAMSET Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#bickel'><p>Bickel's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#blus'><p>Compute Best Linear Unbiased Scalar-Covariance (BLUS) residuals from a linear model</p></a></li>
<li><a href='#bootlm'><p>Nonparametric Bootstrapping of Heteroskedastic Linear Regression Models</p></a></li>
<li><a href='#breusch_pagan'><p>Breusch-Pagan Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#carapeto_holt'><p>Carapeto-Holt Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#cook_weisberg'><p>Cook-Weisberg Score Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#countpeaks'><p>Count peaks in a data sequence</p></a></li>
<li><a href='#dDtrend'><p>Probability mass function of nonparametric trend statistic <code class="reqn">D</code></p></a></li>
<li><a href='#diblasi_bowman'><p>Diblasi and Bowman's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#dpeak'><p>Probability mass function of number of peaks in an i.i.d. random sequence</p></a></li>
<li><a href='#dpeakdat'><p>Probability distribution for number of peaks in a continuous,</p>
uncorrelated stochastic series</a></li>
<li><a href='#dufour_etal'><p>Dufour et al.'s Monte Carlo Test for Heteroskedasticity in a Linear</p>
Regression Model</a></li>
<li><a href='#evans_king'><p>Evans-King Tests for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#glejser'><p>Glejser Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#godfrey_orme'><p>Godfrey and Orme's Nonparametric Bootstrap Test for Heteroskedasticity in a Linear</p>
Regression Model</a></li>
<li><a href='#goldfeld_quandt'><p>Goldfeld-Quandt Tests for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#GSS'><p>Golden Section Search for Minimising Univariate Function over a Closed</p>
Interval</a></li>
<li><a href='#harrison_mccabe'><p>Harrison and McCabe's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#harvey'><p>Harvey Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#hccme'><p>Heteroskedasticity-Consistent Covariance Matrix Estimators for</p>
Linear Regression Models</a></li>
<li><a href='#hetplot'><p>Graphical Methods for Detecting Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#honda'><p>Honda's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#horn'><p>Horn's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#li_yao'><p>Li-Yao ALRT and CVT Tests for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#pDtrend'><p>Cumulative distribution function of nonparametric trend statistic <code class="reqn">D</code></p></a></li>
<li><a href='#ppeak'><p>Cumulative distribution function of number of peaks in an i.i.d. random sequence</p></a></li>
<li><a href='#pRQF'><p>Probabilities for a Ratio of Quadratic Forms in a Normal Random Vector</p></a></li>
<li><a href='#rackauskas_zuokas'><p>Rackauskas-Zuokas Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#simonoff_tsai'><p>Simonoff-Tsai Tests for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#szroeter'><p>Szroeter's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#T_alpha'><p>Pseudorandom numbers from Asymptotic Null Distribution of Test Statistic for</p>
Method of Rackauskas and Zuokas (2007)</a></li>
<li><a href='#twosidedpval'><p>Computation of Conditional Two-Sided <code class="reqn">p</code>-Values</p></a></li>
<li><a href='#verbyla'><p>Verbyla's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#white'><p>White's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#wilcox_keselman'><p>Wilcox and Keselman's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#yuce'><p>YÃ¼ce's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
<li><a href='#zhou_etal'><p>Zhou, Song, and Thompson's Test for Heteroskedasticity in a Linear Regression Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling Heteroskedasticity in the Linear Regression Model</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements numerous methods for testing for, modelling, and 
    correcting for heteroskedasticity in the classical linear regression 
    model. The most novel contribution of the 
    package is found in the functions that implement the as-yet-unpublished 
    auxiliary linear variance models and auxiliary nonlinear variance 
    models that are designed to estimate error variances in a heteroskedastic 
    linear regression model. These models follow principles of statistical 
    learning described in Hastie (2009) &lt;<a href="https://doi.org/10.1007%2F978-0-387-21606-5">doi:10.1007/978-0-387-21606-5</a>&gt;. 
    The nonlinear version of the model is estimated using quasi-likelihood 
    methods as described in Seber and Wild (2003, ISBN: 0-471-47135-6).
    Bootstrap methods for approximate confidence intervals for error variances 
    are implemented as described in Efron and Tibshirani 
    (1993, ISBN: 978-1-4899-4541-9), including also the expansion technique 
    described in Hesterberg (2014) &lt;<a href="https://doi.org/10.1080%2F00031305.2015.1089789">doi:10.1080/00031305.2015.1089789</a>&gt;. The 
    wild bootstrap employed here follows the description in Davidson and 
    Flachaire (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2008.08.003">doi:10.1016/j.jeconom.2008.08.003</a>&gt;. Tuning of 
    hyper-parameters makes use of a golden section search function that is 
    modelled after the MATLAB function of Zarnowiec (2022) 
    <a href="https://www.mathworks.com/matlabcentral/fileexchange/25919-golden-section-method-algorithm">https://www.mathworks.com/matlabcentral/fileexchange/25919-golden-section-method-algorithm</a>.
    A methodological description of the algorithm can be found in Fox (2021, 
    ISBN: 978-1-003-00957-3).
    There are 25 different functions that implement hypothesis tests for 
    heteroskedasticity. These include a test based on Anscombe (1961) 
    <a href="https://projecteuclid.org/euclid.bsmsp/1200512155">https://projecteuclid.org/euclid.bsmsp/1200512155</a>, Ramsey's (1969) 
    BAMSET Test &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1969.tb00796.x">doi:10.1111/j.2517-6161.1969.tb00796.x</a>&gt;, the tests of Bickel 
    (1978) &lt;<a href="https://doi.org/10.1214%2Faos%2F1176344124">doi:10.1214/aos/1176344124</a>&gt;, Breusch and Pagan (1979)  
    &lt;<a href="https://doi.org/10.2307%2F1911963">doi:10.2307/1911963</a>&gt; with and without the modification 
    proposed by Koenker (1981) &lt;<a href="https://doi.org/10.1016%2F0304-4076%2881%2990062-2">doi:10.1016/0304-4076(81)90062-2</a>&gt;, Carapeto and 
    Holt (2003) &lt;<a href="https://doi.org/10.1080%2F0266476022000018475">doi:10.1080/0266476022000018475</a>&gt;, Cook and Weisberg (1983) 
    &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F70.1.1">doi:10.1093/biomet/70.1.1</a>&gt; (including their graphical methods), Diblasi 
    and Bowman (1997) &lt;<a href="https://doi.org/10.1016%2FS0167-7152%2896%2900115-0">doi:10.1016/S0167-7152(96)00115-0</a>&gt;, Dufour, Khalaf, 
    Bernard, and Genest (2004) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2003.10.024">doi:10.1016/j.jeconom.2003.10.024</a>&gt;, Evans and 
    King (1985) &lt;<a href="https://doi.org/10.1016%2F0304-4076%2885%2990085-5">doi:10.1016/0304-4076(85)90085-5</a>&gt; and Evans and King (1988) 
    &lt;<a href="https://doi.org/10.1016%2F0304-4076%2888%2990006-1">doi:10.1016/0304-4076(88)90006-1</a>&gt;, Glejser (1969) 
    &lt;<a href="https://doi.org/10.1080%2F01621459.1969.10500976">doi:10.1080/01621459.1969.10500976</a>&gt; as formulated by 
    Mittelhammer, Judge and Miller (2000, ISBN: 0-521-62394-4), Godfrey and 
    Orme (1999) &lt;<a href="https://doi.org/10.1080%2F07474939908800438">doi:10.1080/07474939908800438</a>&gt;, Goldfeld and Quandt 
    (1965) &lt;<a href="https://doi.org/10.1080%2F01621459.1965.10480811">doi:10.1080/01621459.1965.10480811</a>&gt;, Harrison and McCabe (1979) 
    &lt;<a href="https://doi.org/10.1080%2F01621459.1979.10482544">doi:10.1080/01621459.1979.10482544</a>&gt;, Harvey (1976) &lt;<a href="https://doi.org/10.2307%2F1913974">doi:10.2307/1913974</a>&gt;, 
    Honda (1989) &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1989.tb01749.x">doi:10.1111/j.2517-6161.1989.tb01749.x</a>&gt;, Horn (1981) 
    &lt;<a href="https://doi.org/10.1080%2F03610928108828074">doi:10.1080/03610928108828074</a>&gt;, Li and Yao (2019) 
    &lt;<a href="https://doi.org/10.1016%2Fj.ecosta.2018.01.001">doi:10.1016/j.ecosta.2018.01.001</a>&gt; with and without the modification of 
    Bai, Pan, and Yin (2016) &lt;<a href="https://doi.org/10.1007%2Fs11749-017-0575-x">doi:10.1007/s11749-017-0575-x</a>&gt;, Rackauskas and 
    Zuokas (2007) &lt;<a href="https://doi.org/10.1007%2Fs10986-007-0018-6">doi:10.1007/s10986-007-0018-6</a>&gt;, Simonoff and Tsai (1994) 
    &lt;<a href="https://doi.org/10.2307%2F2986026">doi:10.2307/2986026</a>&gt; with and without the modification of Ferrari, 
    Cysneiros, and Cribari-Neto (2004) &lt;<a href="https://doi.org/10.1016%2FS0378-3758%2803%2900210-6">doi:10.1016/S0378-3758(03)00210-6</a>&gt;, 
    Szroeter (1978) &lt;<a href="https://doi.org/10.2307%2F1913831">doi:10.2307/1913831</a>&gt;, Verbyla (1993) 
    &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1993.tb01918.x">doi:10.1111/j.2517-6161.1993.tb01918.x</a>&gt;, White (1980) 
    &lt;<a href="https://doi.org/10.2307%2F1912934">doi:10.2307/1912934</a>&gt;, Wilcox and Keselman (2006) 
    &lt;<a href="https://doi.org/10.1080%2F10629360500107923">doi:10.1080/10629360500107923</a>&gt;, Yuce (2008) 
    <a href="https://dergipark.org.tr/en/pub/iuekois/issue/8989/112070">https://dergipark.org.tr/en/pub/iuekois/issue/8989/112070</a>, and Zhou, 
    Song, and Thompson (2015) &lt;<a href="https://doi.org/10.1002%2Fcjs.11252">doi:10.1002/cjs.11252</a>&gt;. Besides these 
    heteroskedasticity tests, there are supporting functions that compute the 
    BLUS residuals of Theil (1965) &lt;<a href="https://doi.org/10.1080%2F01621459.1965.10480851">doi:10.1080/01621459.1965.10480851</a>&gt;, the 
    conditional two-sided p-values of Kulinskaya (2008) &lt;<a href="https://doi.org/10.48550/arXiv.0810.2124">doi:10.48550/arXiv.0810.2124</a>&gt;, 
    and probabilities for the nonparametric trend statistic of Lehmann (1975, 
    ISBN: 0-816-24996-1). For handling heteroskedasticity, in addition to the 
    new auxiliary variance model methods, there is a function 
    to implement various existing Heteroskedasticity-Consistent Covariance 
    Matrix Estimators from the literature, such as those of White (1980) 
    &lt;<a href="https://doi.org/10.2307%2F1912934">doi:10.2307/1912934</a>&gt;, MacKinnon and White (1985) 
    &lt;<a href="https://doi.org/10.1016%2F0304-4076%2885%2990158-7">doi:10.1016/0304-4076(85)90158-7</a>&gt;, Cribari-Neto (2004) 
    &lt;<a href="https://doi.org/10.1016%2FS0167-9473%2802%2900366-3">doi:10.1016/S0167-9473(02)00366-3</a>&gt;, Cribari-Neto et al. (2007) 
    &lt;<a href="https://doi.org/10.1080%2F03610920601126589">doi:10.1080/03610920601126589</a>&gt;, Cribari-Neto and da Silva (2011) 
    &lt;<a href="https://doi.org/10.1007%2Fs10182-010-0141-2">doi:10.1007/s10182-010-0141-2</a>&gt;, Aftab and Chang (2016) 
    &lt;<a href="https://doi.org/10.18187%2Fpjsor.v12i2.983">doi:10.18187/pjsor.v12i2.983</a>&gt;, and Li et al. (2017) 
    &lt;<a href="https://doi.org/10.1080%2F00949655.2016.1198906">doi:10.1080/00949655.2016.1198906</a>&gt;. </td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack (&ge; 0.11.1), broom (&ge; 0.5.6), pracma (&ge; 2.2.9),
CompQuadForm (&ge; 1.4.3), MASS (&ge; 7.3.47), bazar (&ge; 1.0.11),
quadprog (&ge; 1.5.8), inflection (&ge; 1.3.5), Rfast (&ge; 2.0.6),
caret (&ge; 6.0.90), Matrix (&ge; 1.4.1), quadprogXT (&ge; 0.0.5),
slam (&ge; 0.1.49), ROI (&ge; 1.0.0), osqp (&ge; 0.6.0.5), mgcv (&ge;
1.8.40), ROI.plugin.qpoases (&ge; 1.0.2),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, devtools, lmtest, car, tseries, tibble,
testthat, mlbench, expm, arrangements, quantreg, gmp, Rmpfr,
cubature, mvtnorm, lmboot, sandwich, cmna</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tjfarrar/skedastic">https://github.com/tjfarrar/skedastic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tjfarrar/skedastic/issues">https://github.com/tjfarrar/skedastic/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 10:53:01 UTC; Tom</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Farrar <a href="https://orcid.org/0000-0003-0744-6972"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  University of the Western Cape [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Farrar &lt;tjfarrar@alumni.uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 15:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='alvm.fit'>Auxiliary Linear Variance Model</h2><span id='topic+alvm.fit'></span>

<h3>Description</h3>

<p>Fits an Auxiliary Linear Variance Model (ALVM) to estimate the error
variances of a heteroskedastic linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alvm.fit(
  mainlm,
  M = NULL,
  model = c("cluster", "spline", "linear", "polynomial", "basic", "homoskedastic"),
  varselect = c("none", "hettest", "cv.linear", "cv.cluster", "qgcv.linear",
    "qgcv.cluster"),
  lambda = c("foldcv", "qgcv"),
  nclust = c("elbow.swd", "elbow.mwd", "elbow.both", "foldcv"),
  clustering = NULL,
  polypen = c("L2", "L1"),
  d = 2L,
  solver = c("auto", "quadprog", "quadprogXT", "roi", "osqp"),
  tsk = NULL,
  tsm = NULL,
  constol = 1e-10,
  cvoption = c("testsetols", "partitionres"),
  nfolds = 5L,
  reduce2homosked = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alvm.fit_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_m">M</code></td>
<td>
<p>An <code class="reqn">n\times n</code> annihilator matrix. If <code>NULL</code>
(the default), this will be calculated from the <code>mainlm</code> object</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_model">model</code></td>
<td>
<p>A character corresponding to the type of ALVM to be fitted:
<code>"cluster"</code> for the clustering ALVM, <code>"spline"</code> for the
thin-plate spline ALVM, <code>"linear"</code> for the linear ALVM,
<code>"polynomial"</code> for the penalised polynomial ALVM, <code>"basic"</code> for
the basic or naive ALVM, and <code>"homoskedastic"</code> for the
homoskedastic error variance estimator, <code class="reqn">e'e/(n-p)</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_varselect">varselect</code></td>
<td>
<p>Either a character indicating how variable selection should
be conducted, or an integer vector giving indices of columns of the
predictor matrix (<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> of <code>mainlm</code>)
to select. The vector must include <code>1L</code> for the intercept to be
selected. If a character, it must be one of the following:
</p>

<ul>
<li> <p><code>"none"</code>: No variable selection is conducted;
</p>
</li>
<li> <p><code>"hettest"</code>: Variable selection is conducted by applying a
heteroskedasticity test with each feature in turn serving as the
&lsquo;deflator&rsquo; variable
</p>
</li>
<li> <p><code>"cv.linear"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (linear specification),
using squared-error loss computed under <code class="reqn">K</code>-fold cross-validation
</p>
</li>
<li> <p><code>"cv.cluster"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (clustering
specification), using squared-error loss computed under <code class="reqn">K</code>-fold
cross-validation
</p>
</li>
<li> <p><code>"qgcv.linear"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (linear specification),
using squared-error loss computed under quasi-generalised
cross-validation
</p>
</li>
<li> <p><code>"qgcv.cluster"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (clustering
specification), using squared-error loss computed under
quasi-generalised cross-validation
</p>
</li></ul>
</td></tr>
<tr><td><code id="alvm.fit_+3A_lambda">lambda</code></td>
<td>
<p>Either a double of length 1 indicating the value of the
penalty hyperparameter <code class="reqn">\lambda</code>, or a character specifying the
tuning method for choosing <code class="reqn">\lambda</code>: <code>"foldcv"</code> for
<code class="reqn">K</code>-fold cross-validation (the default) or <code>"qgcv"</code> for
quasi-generalised cross-validation. This argument is ignored if
<code>model</code> is neither <code>"polynomial"</code> nor <code>"spline"</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_nclust">nclust</code></td>
<td>
<p>Either an integer of length 1 indicating the value of the
number of clusters <code class="reqn">n_c</code>, or a character specifying the tuning method
for choosing <code class="reqn">n_c</code>: <code>"elbow.swd"</code> for the elbow method using a
sum of within-cluster distances criterion,  <code>"elbow.mwd"</code> for the
elbow method using a maximum within-cluster distances criterion,
<code>"elbow.both"</code> for rounded average of the results of the previous
two, and <code>"foldcv"</code> for <code class="reqn">K</code>-fold cross-validation. This argument
is ignored if <code>model</code> is not <code>"cluster"</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_clustering">clustering</code></td>
<td>
<p>A list object of class <code>"doclust"</code>. If set to
<code>NULL</code> (the default), such an object is generated (ignored if
<code>cluster</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_polypen">polypen</code></td>
<td>
<p>A character, either <code>"L2"</code> or <code>"L1"</code>, indicating
whether an <code class="reqn">L_2</code> norm penalty (ridge regression) or
<code class="reqn">L_1</code> norm penalty (LASSO) should be used with the polynomial model.
This argument is ignored if <code>model</code> is not <code>"polynomial"</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_d">d</code></td>
<td>
<p>An integer specifying the degree of polynomial to use in the
penalised polynomial ALVM; defaults to <code>2L</code>. Ignored if
<code>model</code> is other than <code>"polynomial"</code>. Setting <code>d</code> to
<code>1L</code> is not identical to setting <code>model</code> to <code>"linear"</code>,
because the linear ALVM does not have a penalty term in the objective
function.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_solver">solver</code></td>
<td>
<p>A character, indicating which Quadratic Programming solver
function to use to estimate <code class="reqn">\gamma</code>. The options are
<code>"quadprog"</code>, corresponding to
<code><a href="quadprog.html#topic+solve.QP.compact">solve.QP.compact</a></code> from the <span class="pkg">quadprog</span> package;
package; <code>"quadprogXT"</code>, corresponding to
<code><a href="quadprogXT.html#topic+buildQP">buildQP</a></code> from the <span class="pkg">quadprogXT</span> package;
<code>"roi"</code>, corresponding to the <code>qpoases</code> solver implemented in
<code><a href="ROI.html#topic+ROI_solve">ROI_solve</a></code> from the <span class="pkg">ROI</span> package with
<span class="pkg">ROI.plugin.qpoases</span> add-on; and <code>"osqp"</code>, corresponding to
<code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code> from the <span class="pkg">osqp</span> package.
Alternatively, the user can specify <code>"auto"</code> (the default), in which
case the function will select the solver that seems to work best for the
chosen model.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_tsk">tsk</code></td>
<td>
<p>An integer corresponding to the basis dimension <code>k</code> to be
passed to the <code>[mgcv]{s}</code> function for fitting of a thin-plate
spline ALVM; see <code>[mgcv]{choose.k}</code> for more details about
choosing the parameter and defaults. Ignored if <code>model</code> is not
<code>"spline"</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_tsm">tsm</code></td>
<td>
<p>An integer corresponding to the order <code>m</code> of the penalty
to be passed to the <code>[mgcv]{s}</code> function for fitting of a thin-plate
spline ALVM. If left as the default (<code>NULL</code>), it will be set to
2, corresponding to 2nd derivative penalties for a cubic spline.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_constol">constol</code></td>
<td>
<p>A double corresponding to the boundary value for the
constraint on error variances. Of course, the error variances must be
non-negative, but setting the constraint boundary to 0 can result in
zero estimates that then result in infinite weights for Feasible
Weighted Least Squares. The boundary value should thus be positive, but
small enough not to bias estimation of very small variances. Defaults to
<code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_cvoption">cvoption</code></td>
<td>
<p>A character, either <code>"testsetols"</code> or
<code>"partitionres"</code>, indicating how to obtain the observed response
values for each test fold when performing <code class="reqn">K</code>-fold cross-validation
on an ALVM. The default technique, <code>"testsetols"</code>, entails fitting
a linear regression model to the test fold of observations from the
original response vector <code class="reqn">y</code> and predictor matrix <code class="reqn">X</code>. The
squared residuals from this regression are the observed
responses that are predicted from the trained model to compute the
cross-validated squared error loss function. Under the other technique,
<code>"partitionres"</code>, the squared residuals from the full
linear regression model are partitioned into training and test folds and
the squared residuals in the test fold are the observed responses that
are predicted for computation of the cross-validated loss.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_nfolds">nfolds</code></td>
<td>
<p>An integer specifying the number of folds <code class="reqn">K</code> to use for
cross-validation, if the <code class="reqn">\lambda</code> and/or <code class="reqn">n_c</code> hyperparameters
are to be tuned using cross-validation. Defaults to <code>5L</code>. One must
ensure that each test fold contains at least <code class="reqn">p+1</code> observations if
the <code>"testsetols"</code> technique is used with cross-validation, so that
there are enough degrees of freedom to fit a linear model to the test
fold.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_reduce2homosked">reduce2homosked</code></td>
<td>
<p>A logical indicating whether the homoskedastic
error variance estimator <code class="reqn">e'e/(n-p)</code> should be used if the
variable selection procedure does not select any variables. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="alvm.fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to (non-exported) helper
functions, namely:
</p>

<ul>
<li> <p><code>greedy</code>, a logical passed to the functions implementing best subset
selection, indicating whether or not to use a greedy search rather than
exhaustive search for the best subset. Defaults to <code>FALSE</code>, but
coerced to <code>TRUE</code> unconditionally if <code class="reqn">p&gt;9</code>.
</p>
</li>
<li> <p><code>distmetric</code>, a character specifying the distance metric to use in
computing distance for the clustering algorithm. Corresponds to the
<code>method</code> argument of <code><a href="stats.html#topic+dist">dist</a></code> and defaults to
<code>"euclidean"</code>
</p>
</li>
<li> <p><code>linkage</code>, a character specifying the linkage rule to use in
agglomerative hierarchical clustering. Corresponds to the <code>method</code>
argument of <code><a href="stats.html#topic+hclust">hclust</a></code> and defaults to
<code>"complete"</code>
</p>
</li>
<li> <p><code>nclust2search</code>, an integer vector specifying the values of
<code class="reqn">n_c</code> to try when tuning <code class="reqn">n_c</code> by cross-validation. Defaults to
<code>1L:20L</code>
</p>
</li>
<li> <p><code>alpha</code>, a double specifying the significance level threshold to
use when applying heteroskedasticity test for the purpose of feature
selection in an ALVM; defaults to <code>0.1</code>
</p>
</li>
<li> <p><code>testname</code>, a character corresponding to the name of a function
that performs a heteroskedasticity test. The function must either be one
that takes a <code>deflator</code> argument or <code><a href="#topic+breusch_pagan">breusch_pagan</a></code>.
Defaults to <code>evans_king</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The ALVM model equation is
</p>
<p style="text-align: center;"><code class="reqn">e\circ e = (M \circ M)L \gamma + u</code>
</p>
<p>,
where <code class="reqn">e</code> is the Ordinary Least Squares residual vector, <code class="reqn">M</code> is
the annihilator matrix <code class="reqn">M=I-X(X'X)^{-1}X'</code>, <code class="reqn">L</code> is a linear
predictor matrix, <code class="reqn">u</code> is a random error vector, <code class="reqn">\gamma</code> is a
<code class="reqn">p</code>-vector of unknown parameters, and <code class="reqn">\circ</code> denotes the
Hadamard (elementwise) product. The construction of <code class="reqn">L</code> depends on
the method used to model or estimate the assumed heteroskedastic
function <code class="reqn">g(\cdot)</code>, a continuous, differentiable function that is
linear in <code class="reqn">\gamma</code> and by which the error variances <code class="reqn">\omega_i</code>
of the main linear model are related to the predictors <code class="reqn">X_{i\cdot}</code>.
This method has been developed as part of the author's doctoral research
project.
</p>
<p>Depending on the model used, the estimation method could be
Inequality-Constrained Least Squares or Inequality-Constrained Ridge
Regression. However, these are both special cases of Quadratic
Programming. Therefore, all of the models are fitted using Quadratic
Programming.
</p>
<p>Several techniques are available for feature selection within the model.
The LASSO-type model handles feature selection via a shrinkage penalty.
For this reason, if the user calls the polynomial model with
<code class="reqn">L_1</code>-norm penalty, it is not necessary to specify a variable
selection method, since this is handled automatically. Another feature
selection technique is to use a heteroskedasticity test that tests for
heteroskedasticity linked to a particular predictor variable (the
&lsquo;deflator&rsquo;). This test can be conducted with each features in turn
serving as the deflator. Those features for which the null hypothesis of
homoskedasticity is rejected at a specified significance level
<code>alpha</code> are selected. A third feature selection technique is best
subset selection, where the model is fitted with all possible subsets of
features. The models are scored in terms of some metric, and the
best-performing subset of features is selected. The metric could be
squared-error loss computed under <code class="reqn">K</code>-fold cross-validation or using
quasi-generalised cross-validation. (The <em>quasi-</em> prefix refers to
the fact that generalised cross-validation is, properly speaking, only
applicable to a linear fitting method, as defined by
Hastie et al. (2009). ALVMs are not linear fitting
methods due to the inequality constraint). Since best subset selection
requires fitting <code class="reqn">2^{p-1}</code> models (where <code class="reqn">p-1</code> is the number of
candidate features), it is infeasible for large <code class="reqn">p</code>. A greedy search
technique can therefore be used as an alternative, where one begins with
a null model and adds the feature that leads to the best improvement in
the metric, stopping when no new feature leads to an improvement.
</p>
<p>The polynomial and thin-plate spline ALVMs have a penalty hyperparameter
<code class="reqn">\lambda</code> that must either be specified or tuned. <code class="reqn">K</code>-fold
cross-validation or quasi-generalised cross-validation can be used for
tuning. The clustering ALVM has a hyperparameter <code class="reqn">n_c</code>, the number of
clusters into which to group the observations (where error variances
are assumed to be equal within each cluster). <code class="reqn">n_c</code> can be specified
or tuned. The available tuning methods are an elbow method (using a
sum of within-cluster distances criterion, a maximum
within-cluster distance criterion, or a combination of the two) and
<code class="reqn">K</code>-fold cross-validation.
</p>


<h3>Value</h3>

<p>An object of class <code>"alvm.fit"</code>, containing the following:
</p>

<ul>
<li> <p><code>coef.est</code>, a vector of parameter estimates, <code class="reqn">\hat{\gamma}</code>
</p>
</li>
<li> <p><code>var.est</code>, a vector of estimates <code class="reqn">\hat{\omega}</code> of the error
variances for all observations
</p>
</li>
<li> <p><code>method</code>, a character corresponding to the <code>model</code> argument
</p>
</li>
<li> <p><code>ols</code>, the <code>lm</code> object corresponding to the original linear
regression model
</p>
</li>
<li> <p><code>fitinfo</code>, a list containing four named objects: <code>Msq</code> (the
elementwise-square of the annihilator matrix <code class="reqn">M</code>), <code>L</code> (the
linear predictor matrix <code class="reqn">L</code>), <code>clustering</code> (a list object
with results of the clustering procedure), and <code>gam.object</code>, an
object of class <code>"gam"</code> (see <code><a href="mgcv.html#topic+gamObject">gamObject</a></code>). The
last two are set to <code>NA</code> unless the clustering ALVM or thin-plate
spline ALVM is used, respectively
</p>
</li>
<li> <p><code>hyperpar</code>, a named list of hyperparameter values,
<code>lambda</code>, <code>nclust</code>, <code>tsk</code>, and <code>d</code>, and tuning
methods, <code>lambdamethod</code> and <code>nclustmethod</code>. Values
corresponding to unused hyperparameters are set to <code>NA</code>.
</p>
</li>
<li> <p><code>selectinfo</code>, a list containing two named objects,
<code>varselect</code> (the value of the eponymous argument), and
<code>selectedcols</code> (a numeric vector with column indices of <code class="reqn">X</code>
that were selected, with <code>1</code> denoting the intercept column)
</p>
</li>
<li> <p><code>pentype</code>, a character corresponding to the <code>polypen</code>
argument
</p>
</li>
<li> <p><code>solver</code>, a character corresponding to the <code>solver</code>
argument (or specifying the QP solver actually used, if <code>solver</code>
was set to <code>"auto"</code>)
</p>
</li>
<li> <p><code>constol</code>, a double corresponding to the <code>constol</code> argument
</p>
</li></ul>



<h3>References</h3>

<p>Hastie T, Tibshirani R, Friedman JH (2009).
<em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>, 2nd edition.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alvm.fit">alvm.fit</a></code>, <code><a href="#topic+avm.ci">avm.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
myalvm &lt;- alvm.fit(mtcars_lm, model = "cluster")

</code></pre>

<hr>
<h2 id='anlvm.fit'>Auxiliary Nonlinear Variance Model</h2><span id='topic+anlvm.fit'></span>

<h3>Description</h3>

<p>Fits an Auxiliary Nonlinear Variance Model (ANLVM) to estimate the error
variances of a heteroskedastic linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anlvm.fit(
  mainlm,
  g,
  M = NULL,
  cluster = FALSE,
  varselect = c("none", "hettest", "cv.linear", "cv.cluster", "qgcv.linear",
    "qgcv.cluster"),
  nclust = c("elbow.swd", "elbow.mwd", "elbow.both"),
  clustering = NULL,
  param.init = function(q) stats::runif(n = q, min = -5, max = 5),
  maxgridrows = 20L,
  nconvstop = 3L,
  zerosallowed = FALSE,
  maxitql = 100L,
  tolql = 1e-08,
  nestedql = FALSE,
  reduce2homosked = TRUE,
  cvoption = c("testsetols", "partitionres"),
  nfolds = 5L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anlvm.fit_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_g">g</code></td>
<td>
<p>A numeric-valued function of one variable, or a character denoting
the name of such a function. <code>"sq"</code> is allowed as a way of denoting
<code>function(x) x ^ 2</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_m">M</code></td>
<td>
<p>An <code class="reqn">n\times n</code> annihilator matrix. If <code>NULL</code>
(the default), this will be calculated from the <code>mainlm</code> object</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_cluster">cluster</code></td>
<td>
<p>A logical; should the design matrix X be replaced with an
<code class="reqn">n\times n_c</code> matrix of ones and zeroes, with a single one in each
row, indicating assignments of the <code class="reqn">n</code> observations to <code class="reqn">n_c</code>
clusters using an agglomerative hierarchical clustering algorithm. In
this case, the dimensionality of <code class="reqn">\gamma</code> is <code class="reqn">n_c</code> and not
<code class="reqn">p</code>. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_varselect">varselect</code></td>
<td>
<p>Either a character indicating how variable selection should
be conducted, or an integer vector giving indices of columns of the
predictor matrix (<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> of <code>mainlm</code>)
to select. The vector must include <code>1L</code> for the intercept to be
selected. If a character, it must be one of the following:
</p>

<ul>
<li> <p><code>"none"</code>: No variable selection is conducted;
</p>
</li>
<li> <p><code>"hettest"</code>: Variable selection is conducted by applying a
heteroskedasticity test with each feature in turn serving as the
&lsquo;deflator&rsquo; variable
</p>
</li>
<li> <p><code>"cv.linear"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (linear specification),
using squared-error loss computed under <code class="reqn">K</code>-fold cross-validation
</p>
</li>
<li> <p><code>"cv.cluster"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (clustering
specification), using squared-error loss computed under <code class="reqn">K</code>-fold
cross-validation
</p>
</li>
<li> <p><code>"qgcv.linear"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (linear specification),
using squared-error loss computed under quasi-generalised
cross-validation
</p>
</li>
<li> <p><code>"qgcv.cluster"</code>: Variable selection is conducted by best subset
selection on the auxiliary linear variance model (clustering
specification), using squared-error loss computed under
quasi-generalised cross-validation
</p>
</li></ul>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_nclust">nclust</code></td>
<td>
<p>A character indicating which elbow method to use to select
the number of clusters (ignored if <code>cluster</code> is <code>FALSE</code>).
Alternatively, an integer specifying the number of clusters</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_clustering">clustering</code></td>
<td>
<p>A list object of class <code>"doclust"</code>. If set to
<code>NULL</code> (the default), such an object is generated (ignored if
<code>cluster</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_param.init">param.init</code></td>
<td>
<p>Specifies the initial values of the parameter vector to
use in the Gauss-Newton fitting algorithm. This can either be a function
for generating the initial values from a probability distribution, a
list containing named objects corresponding to the arguments of
<code><a href="base.html#topic+seq">seq</a></code> (specifying a sequence of scalar values that
will be passed to <code><a href="base.html#topic+expand.grid">expand.grid</a></code>), or a numeric vector
specifying a single initial parameter vector</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_maxgridrows">maxgridrows</code></td>
<td>
<p>An integer indicating the maximum number of initial
values of the parameter vector to try, in case of <code>param.init</code>
being a function or a list used to generate a grid. Defaults to
<code>20L</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_nconvstop">nconvstop</code></td>
<td>
<p>An integer indicating how many times the quasi-likelihood
estimation algorithm should converge before the grid search across
different initial parameter values is truncated. Defaults to <code>3L</code>.
If <code>nconvstop &gt;= maxgridrows</code>, no early stopping rule will be used.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_zerosallowed">zerosallowed</code></td>
<td>
<p>A logical indicating whether 0 values are acceptable
in the initial values of the parameter vector. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_maxitql">maxitql</code></td>
<td>
<p>An integer specifying the maximum number of iterations to
run in the Gauss-Newton algorithm for quasi-likelihood estimation.
Defaults to <code>100L</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_tolql">tolql</code></td>
<td>
<p>A double specifying the convergence criterion for the
Gauss-Newton algorithm; defaults to <code>1e-8</code>. The criterion is applied
to the <code>L_2</code> norm of the difference between parameter vectors in
successive iterations.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_nestedql">nestedql</code></td>
<td>
<p>A logical indicating whether to use the nested updating step
suggested in Seber and Wild (2003). Defaults to
<code>FALSE</code> due to the large computation time required.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_reduce2homosked">reduce2homosked</code></td>
<td>
<p>A logical indicating whether the homoskedastic
error variance estimator <code class="reqn">e'e/(n-p)</code> should be used if the
variable selection procedure does not select any variables. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_cvoption">cvoption</code></td>
<td>
<p>A character, either <code>"testsetols"</code> or
<code>"partitionres"</code>, indicating how to obtain the observed response
values for each test fold when performing <code class="reqn">K</code>-fold cross-validation
on an ALVM. The default technique, <code>"testsetols"</code>, entails fitting
a linear regression model to the test fold of observations from the
original response vector <code class="reqn">y</code> and predictor matrix <code class="reqn">X</code>. The
squared residuals from this regression are the observed
responses that are predicted from the trained model to compute the
cross-validated squared error loss function. Under the other technique,
<code>"partitionres"</code>, the squared residuals from the full
linear regression model are partitioned into training and test folds and
the squared residuals in the test fold are the observed responses that
are predicted for computation of the cross-validated loss.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_nfolds">nfolds</code></td>
<td>
<p>An integer specifying the number of folds <code class="reqn">K</code> to use for
cross-validation, if the <code class="reqn">\lambda</code> and/or <code class="reqn">n_c</code> hyperparameters
are to be tuned using cross-validation. Defaults to <code>5L</code>. One must
ensure that each test fold contains at least <code class="reqn">p+1</code> observations if
the <code>"testsetols"</code> technique is used with cross-validation, so that
there are enough degrees of freedom to fit a linear model to the test
fold.</p>
</td></tr>
<tr><td><code id="anlvm.fit_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to (non-exported) helper
functions, namely:
</p>

<ul>
<li> <p><code>greedy</code>, a logical passed to the functions implementing best subset
selection, indicating whether or not to use a greedy search rather than
exhaustive search for the best subset. Defaults to <code>FALSE</code>, but
coerced to <code>TRUE</code> unconditionally if <code class="reqn">p&gt;9</code>.
</p>
</li>
<li> <p><code>distmetric</code>, a character specifying the distance metric to use in
computing distance for the clustering algorithm. Corresponds to the
<code>method</code> argument of <code><a href="stats.html#topic+dist">dist</a></code> and defaults to
<code>"euclidean"</code>
</p>
</li>
<li> <p><code>linkage</code>, a character specifying the linkage rule to use in
agglomerative hierarchical clustering. Corresponds to the <code>method</code>
argument of <code><a href="stats.html#topic+hclust">hclust</a></code> and defaults to
<code>"complete"</code>
</p>
</li>
<li> <p><code>alpha</code>, a double specifying the significance level threshold to use
when applying heteroskedasticity test for the purpose of feature
selection in an ALVM; defaults to <code>0.1</code>
</p>
</li>
<li> <p><code>testname</code>, a character corresponding to the name of a function that
performs a heteroskedasticity test. The function must either be one that
takes a <code>deflator</code> argument or <code><a href="#topic+breusch_pagan">breusch_pagan</a></code>. Defaults
to <code>evans_king</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The ANLVM model equation is
</p>
<p style="text-align: center;"><code class="reqn">e_i^2=\displaystyle\sum_{k=1}^{n} g(X_{k\cdot}'\gamma) m_{ik}^2+u_i</code>
</p>
<p>,
where <code class="reqn">e_i</code> is the <code class="reqn">i</code>th Ordinary Least Squares residual,
<code class="reqn">X_{k\cdot}</code> is a vector corresponding to the <code class="reqn">k</code>th row of the
<code class="reqn">n\times p</code> design matrix <code class="reqn">X</code>, <code class="reqn">m_{ik}^2</code> is the
<code class="reqn">(i,k)</code>th element of the annihilator matrix <code class="reqn">M=I-X(X'X)^{-1}X'</code>,
<code class="reqn">u_i</code> is a random error term, <code class="reqn">\gamma</code> is a <code class="reqn">p</code>-vector of
unknown parameters, and <code class="reqn">g(\cdot)</code> is a continuous, differentiable
function that need not be linear in <code class="reqn">\gamma</code>, but must be expressible
as a function of the linear predictor <code class="reqn">X_{k\cdot}'\gamma</code>.
This method has been developed as part of the author's doctoral research
project.
</p>
<p>The parameter vector <code class="reqn">\gamma</code> is estimated using the maximum
quasi-likelihood method as described in section 2.3 of
Seber and Wild (2003). The optimisation problem is
solved numerically using a Gauss-Newton algorithm.
</p>
<p>For further discussion of feature selection and the methods for choosing the
number of clusters to use with the clustering version of the model, see
<code><a href="#topic+alvm.fit">alvm.fit</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anlvm.fit"</code>, containing the following:
</p>

<ul>
<li> <p><code>coef.est</code>, a vector of parameter estimates, <code class="reqn">\hat{\gamma}</code>
</p>
</li>
<li> <p><code>var.est</code>, a vector of estimates <code class="reqn">\hat{\omega}</code> of the error
variances for all observations
</p>
</li>
<li> <p><code>method</code>, either <code>"cluster"</code> or <code>"functionalform"</code>,
depending on whether <code>cluster</code> was set to <code>TRUE</code>
</p>
</li>
<li> <p><code>ols</code>, the <code>lm</code> object corresponding to the original linear
regression model
</p>
</li>
<li> <p><code>fitinfo</code>, a list containing three named objects, <code>g</code> (the
heteroskedastic function), <code>Msq</code> (the elementwise-square of the
annihilator matrix <code class="reqn">M</code>), <code>Z</code> (the design matrix used in the
ANLVM, after feature selection if applicable), and <code>clustering</code>
(a list object with results of the clustering procedure, if applicable).
</p>
</li>
<li> <p><code>selectinfo</code>, a list containing two named objects,
<code>varselect</code> (the value of the eponymous argument), and
<code>selectedcols</code> (a numeric vector with column indices of <code class="reqn">X</code>
that were selected, with <code>1</code> denoting the intercept column)
</p>
</li>
<li> <p><code>qlinfo</code>, a list containing nine named objects: <code>converged</code>
(a logical, indicating whether the Gauss-Newton algorithm converged
for at least one initial value of the parameter vector),
<code>iterations</code> (the number of Gauss-Newton iterations used to
obtain the parameter estimates returned), <code>Smin</code> (the minimum
achieved value of the objective function used in the Gauss-Newton
routine), and six arguments passed to the function (<code>nested</code>,
<code>param.init</code>, <code>maxgridrows</code>, <code>nconvstop</code>,
<code>maxitql</code>, and <code>tolql</code>)
</p>
</li></ul>



<h3>References</h3>

<p>Seber GAF, Wild CJ (2003).
<em>Nonlinear Regression</em>.
Wiley, Hoboken, NJ.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alvm.fit">alvm.fit</a></code>, <code><a href="#topic+avm.ci">avm.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
myanlvm &lt;- anlvm.fit(mtcars_lm, g = function(x) x ^ 2,
 varselect = "qgcv.linear")

</code></pre>

<hr>
<h2 id='anscombe'>Anscombe's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+anscombe'></span>

<h3>Description</h3>

<p>This function implements the method of
Anscombe (1961) for testing for
heteroskedasticity in a linear regression model, with or without the
studentising modification of
Bickel (1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anscombe(mainlm, studentise = TRUE, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anscombe_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="anscombe_+3A_studentise">studentise</code></td>
<td>
<p>A logical. Should studentising modification of
Bickel (1978) be implemented? Defaults to
<code>TRUE</code>; if <code>FALSE</code>, the original form of the test proposed by
Anscombe (1961) is used.</p>
</td></tr>
<tr><td><code id="anscombe_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Anscombe's Test is among the earliest suggestions for heteroskedasticity
diagnostics in the linear regression model. The test is not based on
formally derived theory but on a test statistic that Anscombe intuited
to be approximately standard normal under the null hypothesis of
homoskedasticity. Bickel (1978) discusses
the test and suggests a studentising modification (included in this
function) as well as a robustifying modification
(included in <code><a href="#topic+bickel">bickel</a></code>). The test is two-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Anscombe FJ (1961).
&ldquo;Examination of Residuals.&rdquo;
In Neyman J (ed.), <em>Fourth Berkeley Symposium on Mathematical Statistics and Probability June 20-July 30, 1960</em>, 1&ndash;36.
Berkeley: University of California Press.<br /><br /> Bickel PJ (1978).
&ldquo;Using Residuals Robustly I: Tests for Heteroscedasticity, Nonlinearity.&rdquo;
<em>The Annals of Statistics</em>, <b>6</b>(2), 266&ndash;291.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bickel">bickel</a></code>, which is a robust extension of this test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
anscombe(mtcars_lm)

</code></pre>

<hr>
<h2 id='avm.ci'>Bootstrap Confidence Intervals for Linear Regression Error Variances</h2><span id='topic+avm.ci'></span>

<h3>Description</h3>

<p>Uses bootstrap methods to compute approximate confidence intervals for
error variances in a heteroskedastic linear regression model based on
an auxiliary linear variance model (ALVM) or auxiliary nonlinear variance
model (ANLVM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avm.ci(
  object,
  bootobject = NULL,
  bootavmobject = NULL,
  jackobject = NULL,
  bootCImethod = c("pct", "bca", "stdnorm"),
  bootsampmethod = c("pairs", "wild"),
  Bextra = 500L,
  Brequired = 1000L,
  conf.level = 0.95,
  expand = TRUE,
  retune = FALSE,
  resfunc = c("identity", "hccme"),
  qtype = 6,
  rm_on_constraint = TRUE,
  rm_nonconverged = TRUE,
  jackknife_point = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avm.ci_+3A_object">object</code></td>
<td>
<p>An object of class <code>"alvm.fit"</code> or of class
<code>"anlvm.fit"</code>, containing information on a fitted ALVM or ANLVM</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_bootobject">bootobject</code></td>
<td>
<p>An object of class <code>"bootlm"</code>, containing information
on a set of <code class="reqn">B</code> bootstrapped versions of a linear regression model,
obtained by a nonparametric bootstrap method suitable for heteroskedastic
linear models. If set to <code>NULL</code> (the default), it is generated by
calling <code><a href="#topic+bootlm">bootlm</a></code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_bootavmobject">bootavmobject</code></td>
<td>
<p>An object of class <code>"bootavm"</code>, containing
information on an ALVM or ANLVM fit to <code class="reqn">B</code> bootstrapped linear
regression models. If set to <code>NULL</code> (the default), it is generated
by calling the non-exported function <code>bootavm</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_jackobject">jackobject</code></td>
<td>
<p>An object of class <code>"jackavm"</code>, containing
information on ALVMs or ANVLMs fit to jackknife versions of a linear
regression model. If set to <code>NULL</code> (the default), it is generated
by calling the non-exported function <code>jackavm</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_bootcimethod">bootCImethod</code></td>
<td>
<p>A character specifying the method to use when computing
the approximate bootstrap confidence interval. The default, <code>"pct"</code>,
corresponds to the percentile interval. <code>"bca"</code> corresponds to the
Bias-Corrected and accelerated (BCa) modification of the percentile
interval. <code>"stdnorm"</code> corresponds to a naive standard normal
interval with bootstrap standard error estimates.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_bootsampmethod">bootsampmethod</code></td>
<td>
<p>A character specifying the method to use for
generating nonparametric bootstrap linear regression models. Corresponds
to the <code>sampmethod</code> argument of <code><a href="#topic+bootlm">bootlm</a></code> and defaults
to <code>"pairs"</code>. <strong>Warning:</strong> in simulations, bootstrap intervals
computed using the wild bootstrap have shown very poor coverage
probabilities. Ignored unless <code>bootobject</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_bextra">Bextra</code></td>
<td>
<p>An integer indicating the maximum number of additional
bootstrap models that should be fitted in an attempt to obtain
<code>Brequired</code> appropriate sets of bootstrap variance estimates, as
explained above under <code>Brequired</code>. Defaults to <code>500L</code>.
Ignored if <code>rm_on_constraint</code> is set to <code>FALSE</code> (for an ALVM)
or if <code>rm_nonconverged</code> is set to <code>FALSE</code> (for an ANLVM).</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_brequired">Brequired</code></td>
<td>
<p>An integer indicating the number of bootstrap regression
models that should be used to compute the bootstrap confidence intervals.
The default behaviour is to base the interval estimates only on bootstrap
ALVM variance estimates that are not on the constraint boundary or on
bootstrap ANLVMs where the estimation algorithm converged. Consequently,
if this is not the case for all of the first <code>Brequired</code> bootstrap
models, additional bootstrap models are used (up to a maximum of
<code>Bextra</code>). Defaults to <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_conf.level">conf.level</code></td>
<td>
<p>A double representing the confidence level <code class="reqn">1-\alpha</code>;
must be between 0 and 1. Defaults to <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_expand">expand</code></td>
<td>
<p>A logical specifying whether to implement the expansion
technique described in Hesterberg (2015).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_retune">retune</code></td>
<td>
<p>A logical specifying whether to re-tune hyperparameters and
re-select features each time an ALVM or (in the case of feature
selection) ANLVM is fit to a bootstrapped regression model. If
<code>FALSE</code> (the default), the hyperparameter value and selected
features from the ALVM fit to the original model are reused in every
bootstrap model. Setting to <code>TRUE</code> is more theoretically sound but
increases computation time substantially.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_resfunc">resfunc</code></td>
<td>
<p>Either a character naming a function to call to apply a
transformation to the Ordinary Least Squares residuals, or a function
to apply for the same purpose. This argument is ignored if
<code>sampmethod</code> is <code>"pairs"</code>. The only two character values
accepted are <code>"identity"</code>, in which case no transformation is
applied to the residuals, and <code>"hccme"</code>, in which case the
transformation corresponds to a heteroskedasticity-consistent
covariance matrix estimator calculated from <code><a href="#topic+hccme">hccme</a></code>. If
<code>resfunc</code> is a function, it is assumed that its first argument
is the numeric vector of residuals.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_qtype">qtype</code></td>
<td>
<p>A numeric corresponding to the <code>type</code> argument of
<code><a href="stats.html#topic+quantile">quantile</a></code>. Defaults to <code>6</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_rm_on_constraint">rm_on_constraint</code></td>
<td>
<p>A logical specifying whether to exclude
bootstrapped ALVMs from the interval estimation method where the ALVM
parameter estimate falls on the constraint boundary. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_rm_nonconverged">rm_nonconverged</code></td>
<td>
<p>A logical specifying whether to exclude bootstrapped
ANLVMs from the interval estimation method where the optimisation
algorithm used in quasi-likelihood estimation of the ANLVM parameter did
not converge. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_jackknife_point">jackknife_point</code></td>
<td>
<p>A logical specifying whether to replace the point
estimates of the error variances <code class="reqn">\omega</code> with jackknife estimates
based only on the leave-one-out auxiliary models where the parameter
estimates do not lie on the constraint boundary (in the ALVM case) or
where the quasi-likelihood estimation algorithm converged (in the ANLVM
case). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="avm.ci_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to non-exported helper functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">B</code> resampled versions of the original linear regression model
(which can be accessed using <code>object$ols</code>) are generated using a
nonparametric bootstrap method that is suitable for heteroskedastic
linear regression models, namely either the pairs bootstrap or the wild
bootstrap (bootstrapping residuals is <em>not</em> suitable). Depending on
the class of <code>object</code>, either an ALVM or an ANLVM is fit to each of
the bootstrapped regression models. The distribution of the <code class="reqn">B</code>
bootstrap estimates of each error variance <code class="reqn">\omega_i</code>,
<code class="reqn">i=1,2,\ldots,n</code>, is used to construct an approximate confidence
interval for <code class="reqn">\omega_i</code>. This is done using one of three methods.
The first is the percentile interval, which simply takes the empirical
<code class="reqn">\alpha/2</code> and <code class="reqn">1-\alpha/2</code> quantiles of the <code class="reqn">i</code>th bootstrap
variance estimates. The second is the Bias-Corrected and accelerated
(BCa) method as described in Efron and Tibshirani (1993),
which is intended to improve on the percentile interval (although
simulations have not found it to yield better coverage probabilities).
The third is the naive standard normal interval, which takes
<code class="reqn">\hat{\omega}_i \pm z_{1-\alpha/2} \widehat{\mathrm{SE}}</code>, where
<code class="reqn">\widehat{\mathrm{SE}}</code> is the standard deviation of the <code class="reqn">B</code>
bootstrap estimates of <code class="reqn">\omega_i</code>. By default, the expansion
technique described in Hesterberg (2015) is
also applied; evidence from simulations suggests that this <em>does</em>
improve coverage probabilities.
</p>
<p>Technically, the hyperparameters of the ALVM, such as <code class="reqn">\lambda</code> (for a
penalised polynomial or thin-plate spline model) or <code class="reqn">n_c</code> (for a
clustering model) should be re-tuned every time the ALVM is fitted to
another bootstrapped regression model. However, due to the computational
cost, this is not done by <code>avm.ci</code> unless <code>retune</code> is set to
<code>TRUE</code>.
</p>
<p>When obtained from ALVMs, bootstrap estimates of <code class="reqn">\omega_i</code> that fall on
the constraint boundary (i.e., are estimated to be near 0) are ignored
by default; there is an attempt to obtain <code>Brequired</code> bootstrap
estimates of each <code class="reqn">\omega_i</code> that do not fall on the constraint
boundary. This fine-tuning can be turned off by setting the
<code>rm_onconstraint</code> argument to <code>FALSE</code>; the amount of effort
put into obtaining non-boundary estimates is controlled using the
<code>Bextra</code> argument. When ANLVMs are used, the default behaviour is to
try to obtain <code>Brequired</code> bootstrap estimates of <code class="reqn">\omega</code> where
the Gauss-Newton algorithm applied for quasi-likelihood estimation
has converged, and ignore estimates obtained from non-convergent cases.
This behaviour can be toggled using the <code>rm_nonconverged</code> argument.
</p>


<h3>Value</h3>

<p>An object of class <code>"avm.ci"</code>, containing the following:
</p>

<ul>
<li> <p><code>climits</code>, an <code class="reqn">n\times 2</code> matrix with lower confidence
limits in the first column and upper confidence limits in the second
</p>
</li>
<li> <p><code>var.est</code>, a vector of length <code class="reqn">n</code> of point estimates
<code class="reqn">\hat{\omega}</code> of the error variances. This is the same vector
passed within <code>object</code>, unless <code>jackknife_point</code> is
<code>TRUE</code>.
</p>
</li>
<li> <p><code>conf.level</code>, corresponding to the eponymous argument
</p>
</li>
<li> <p><code>bootCImethod</code>, corresponding to the eponymous argument
</p>
</li>
<li> <p><code>bootsampmethod</code>, corresponding to the eponymous argument or
otherwise extracted from <code>bootobject</code>
</p>
</li></ul>



<h3>References</h3>

<p>Efron B, Tibshirani RJ (1993).
<em>An Introduction to the Bootstrap</em>.
Springer Science+Business Media, Dordrecht.<br /><br /> Hesterberg T (2015).
&ldquo;What Teachers Should Know about the Bootstrap: Resampling in the Undergraduate Statistics Curriculum.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alvm.fit">alvm.fit</a></code>, <code><a href="#topic+anlvm.fit">anlvm.fit</a></code>,
Efron and Tibshirani (1993)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
myalvm &lt;- alvm.fit(mtcars_lm, model = "cluster")
# Brequired would of course not be so small in practice
ci.alvm &lt;- avm.ci(myalvm, Brequired = 5)
</code></pre>

<hr>
<h2 id='avm.fwls'>Apply Feasible Weighted Least Squares to a Linear Regression Model</h2><span id='topic+avm.fwls'></span>

<h3>Description</h3>

<p>This function applies feasible weighted least squares (FWLS) to a
linear regression model using error variance estimates obtained
from an auxiliary linear variance model fit using <code>alvm.fit</code>
or from an auxiliary nonlinear variance model fit using
<code>anlvm.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avm.fwls(object, fastfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avm.fwls_+3A_object">object</code></td>
<td>
<p>Either an object of class <code>"alvm.fit"</code> or an object
of class <code>"anlvm.fit"</code></p>
</td></tr>
<tr><td><code id="avm.fwls_+3A_fastfit">fastfit</code></td>
<td>
<p>A logical. If <code>FALSE</code> (the default), the linear
regression model is fit using <code><a href="stats.html#topic+lm">lm</a></code>; otherwise,
using <code><a href="stats.html#topic+lm.wfit">lm.wfit</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply calculates
</p>
<p style="text-align: center;"><code class="reqn">\hat{\beta}=(X'\hat{\Omega}^{-1}X)^{-1}X'\hat{\Omega}^{-1}y</code>
</p>
<p>,
where <code class="reqn">X</code> is the design matrix, <code class="reqn">y</code> is the response vector, and
<code class="reqn">\hat{\Omega}</code> is the diagonal variance-covariance matrix of the
random errors, whose diagonal elements have been estimated by an
auxiliary variance model.
</p>


<h3>Value</h3>

<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(if <code>fastfit</code> is <code>FALSE</code>) or otherwise a generic
list object
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alvm.fit">alvm.fit</a></code>, <code><a href="#topic+anlvm.fit">anlvm.fit</a></code>,
<code><a href="#topic+avm.vcov">avm.vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
myalvm &lt;- alvm.fit(mainlm = mtcars_lm, model = "linear",
   varselect = "qgcv.linear")
myfwls &lt;- avm.fwls(myalvm)
cbind(coef(mtcars_lm), coef(myfwls))

</code></pre>

<hr>
<h2 id='avm.vcov'>Estimate Covariance Matrix of Ordinary Least Squares Estimators
Using Error Variance Estimates from an Auxiliary Variance Model</h2><span id='topic+avm.vcov'></span>

<h3>Description</h3>

<p>The function simply calculates
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Cov}{\hat{\beta}}=(X'X)^{-1}X'\hat{\Omega}X(X'X)^{-1}</code>
</p>
<p>,
where <code class="reqn">X</code> is the design matrix of a linear regression model and
<code class="reqn">\hat{\Omega}</code> is an estimate of the diagonal variance-covariance
matrix of the random errors, whose diagonal elements have been
obtained from an auxiliary variance model fit with <code>alvm.fit</code>
or <code>anlvm.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avm.vcov(object, as_matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avm.vcov_+3A_object">object</code></td>
<td>
<p>Either an object of class <code>"alvm.fit"</code> or an object
of class <code>"anlvm.fit"</code></p>
</td></tr>
<tr><td><code id="avm.vcov_+3A_as_matrix">as_matrix</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default), a
<code class="reqn">p \times p</code> matrix is returned, where <code class="reqn">p</code> is the
number of columns in <code class="reqn">X</code>. Otherwise, a numeric vector of length
<code class="reqn">p</code> is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric matrix or a numeric vector, whose (diagonal)
elements are <code class="reqn">\widehat{\mathrm{Var}}(\hat{\beta}_j)</code>,
<code class="reqn">j=1,2,\ldots,p</code>.
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alvm.fit">alvm.fit</a></code>, <code><a href="#topic+anlvm.fit">anlvm.fit</a></code>,
<code><a href="#topic+avm.fwls">avm.fwls</a></code>. If a matrix is returned, it can be
passed to <code><a href="lmtest.html#topic+coeftest">coeftest</a></code> for implementation
of a quasi-<code class="reqn">t</code>-test of significance of the <code class="reqn">\beta</code> coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
myalvm &lt;- alvm.fit(mainlm = mtcars_lm, model = "linear",
   varselect = "qgcv.linear")
myvcov &lt;- avm.vcov(myalvm)
lmtest::coeftest(mtcars_lm, vcov. = myvcov)

</code></pre>

<hr>
<h2 id='bamset'>Ramsey's BAMSET Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+bamset'></span>

<h3>Description</h3>

<p>This function implements the Bartlett's <code class="reqn">M</code> Specification Error Test
(BAMSET) method of Ramsey (1969) for testing
for heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamset(
  mainlm,
  k = 3,
  deflator = NA,
  correct = TRUE,
  omitatmargins = TRUE,
  omit = NA,
  categorical = FALSE,
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamset_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="bamset_+3A_k">k</code></td>
<td>
<p>An integer. The number of subsets (&gt;= 2) into which the BLUS residuals are
to be partitioned. Defaults to 3, the value suggested in
Ramsey (1969).</p>
</td></tr>
<tr><td><code id="bamset_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="bamset_+3A_correct">correct</code></td>
<td>
<p>A logical. Should the test statistic be divided by a scaling
constant to improve the chi-squared approximation? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bamset_+3A_omitatmargins">omitatmargins</code></td>
<td>
<p>A logical. Should the indices of observations at the
margins of the <code>k</code> subsets be passed to <code><a href="#topic+blus">blus</a></code> as the
<code>omit</code> argument? If <code>TRUE</code> (the default), this overrides any
<code>omit</code> argument passed directly. If <code>FALSE</code>, the <code>omit</code>
argument must be specified and cannot be left as <code>NA</code>. If
<code>categorical</code> is <code>TRUE</code>, setting <code>omitatmargins</code> to
<code>TRUE</code> results in omitting observations from the most frequently
occurring factor levels or values.</p>
</td></tr>
<tr><td><code id="bamset_+3A_omit">omit</code></td>
<td>
<p>A numeric vector of length <code class="reqn">p</code> (the number of columns in the
linear model design matrix) giving the indices of <code class="reqn">p</code> observations to
omit in the BLUS residual vector; or a character partially matching
<code>"first"</code> (for the first <code class="reqn">p</code>) observations, <code>"last"</code> (for
the last <code class="reqn">p</code> observations), or <code>"random"</code> (for a random sample
of <code class="reqn">p</code> indices between 1 and <code class="reqn">n</code>). Defaults to <code>"first"</code>.</p>
</td></tr>
<tr><td><code id="bamset_+3A_categorical">categorical</code></td>
<td>
<p>A logical. Is the deflator a categorical variable? If
so, the number of levels will be used as <code class="reqn">k</code> with each level forming
a subset. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bamset_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BAMSET is an analogue of Bartlett's <code class="reqn">M</code> Test for heterogeneity
of variances across independent samples from <code class="reqn">k</code> populations. In this
case the populations are <code class="reqn">k</code> subsets of the residuals from a linear
regression model. In order to meet the independence assumption,
<a href="#topic+blus">BLUS residuals</a> are computed, meaning that only <code class="reqn">n-p</code>
observations are used (where <code class="reqn">n</code> is the number of rows and <code class="reqn">p</code>
the number of columns in the design matrix). Under the null hypothesis
of homoskedasticity, the test statistic is asymptotically chi-squared
distributed with <code class="reqn">k-1</code> degrees of freedom. The test is right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Ramsey JB (1969).
&ldquo;Tests for Specification Errors in Classical Linear Least-Squares Regression Analysis.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Statistical Methodology)</em>, <b>31</b>(2), 350&ndash;371.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
bamset(mtcars_lm, deflator = "qsec", k = 3)

# BLUS residuals cannot be computed with given `omit` argument and so
# omitted indices are randomised:
bamset(mtcars_lm, deflator = "qsec", k = 4, omitatmargins = FALSE, omit = "last")

</code></pre>

<hr>
<h2 id='bickel'>Bickel's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+bickel'></span>

<h3>Description</h3>

<p>This function implements the method of
Bickel (1978) for testing for
heteroskedasticity in a linear regression model, with or without the
scale-invariance modification of
Carroll and Ruppert (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bickel(
  mainlm,
  fitmethod = c("lm", "rlm"),
  a = "identity",
  b = c("hubersq", "tanhsq"),
  scale_invariant = TRUE,
  k = 1.345,
  statonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bickel_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="bickel_+3A_fitmethod">fitmethod</code></td>
<td>
<p>A character indicating the method to be used to fit the
regression model. This can be &quot;OLS&quot; for ordinary least squares (the
default) or &quot;robust&quot; in which case a robust fitting method is called
from <code><a href="MASS.html#topic+rlm">rlm</a></code>.</p>
</td></tr>
<tr><td><code id="bickel_+3A_a">a</code></td>
<td>
<p>A character argument specifying the name of a function to be
applied to the fitted values, or an integer <code class="reqn">m</code> in which case the
function applied is <code class="reqn">f(x) = x^m</code>. Defaults to <code>"identity"</code> for
<code><a href="base.html#topic+identity">identity</a></code>.</p>
</td></tr>
<tr><td><code id="bickel_+3A_b">b</code></td>
<td>
<p>A character argument specifying a function to be applied to the
residuals. Defaults to Huber's function squared, as recommended by
Carroll and Ruppert (1981). Currently the only supported
functions are <code>"hubersq"</code> (for Huber's function squared) and
<code>"tanhsq"</code> (for <code class="reqn">b(x)=\mathrm{tanh}(x)^2</code>.)</p>
</td></tr>
<tr><td><code id="bickel_+3A_scale_invariant">scale_invariant</code></td>
<td>
<p>A logical indicating whether the scale-invariance
modification proposed by Carroll and Ruppert (1981)
should be implemented. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bickel_+3A_k">k</code></td>
<td>
<p>A double argument specifying a parameter for Huber's function
squared; used only if <code>b == "hubersq"</code>. This is not to be confused
with the argument <code>k2</code> that could be passed to
<code><a href="MASS.html#topic+rlm">rlm</a></code> if the regression is fitted using robust methods.
<code>k</code> defaults to 1.345.</p>
</td></tr>
<tr><td><code id="bickel_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bickel_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="MASS.html#topic+rlm">rlm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bickel's Test is a robust extension of Anscombe's Test
(Anscombe 1961) in which the OLS residuals and
estimated standard error are replaced with an <code class="reqn">M</code> estimator. Under
the null hypothesis of homoskedasticity, the distribution of the test
statistic is asymptotically standard normally distributed. The test is
two-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Anscombe FJ (1961).
&ldquo;Examination of Residuals.&rdquo;
In Neyman J (ed.), <em>Fourth Berkeley Symposium on Mathematical Statistics and Probability June 20-July 30, 1960</em>, 1&ndash;36.
Berkeley: University of California Press.<br /><br /> Bickel PJ (1978).
&ldquo;Using Residuals Robustly I: Tests for Heteroscedasticity, Nonlinearity.&rdquo;
<em>The Annals of Statistics</em>, <b>6</b>(2), 266&ndash;291.<br /><br /> Carroll RJ, Ruppert D (1981).
&ldquo;On Robust Tests for Heteroscedasticity.&rdquo;
<em>The Annals of Statistics</em>, <b>9</b>(1), 206&ndash;210.
</p>


<h3>See Also</h3>

<p>discussions of this test in
Carroll and Ruppert (1981) and
Ali and Giaccotto (1984).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
bickel(mtcars_lm)
bickel(mtcars_lm, fitmethod = "rlm")
bickel(mtcars_lm, scale_invariant = FALSE)

</code></pre>

<hr>
<h2 id='blus'>Compute Best Linear Unbiased Scalar-Covariance (BLUS) residuals from a linear model</h2><span id='topic+blus'></span>

<h3>Description</h3>

<p>This function computes the Best Linear Unbiased Scalar-Covariance (BLUS)
residuals from a linear model, as defined in
Theil (1965) and explained further in
Theil (1968).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blus(
  mainlm,
  omit = c("first", "last", "random"),
  keepNA = TRUE,
  exhaust = NA,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blus_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="blus_+3A_omit">omit</code></td>
<td>
<p>A numeric vector of length <code class="reqn">p</code> (the number of columns in the
linear model design matrix) giving the indices of <code class="reqn">p</code> observations to
omit in the BLUS residual vector; or a character partially matching
<code>"first"</code> (for the first <code class="reqn">p</code>) observations, <code>"last"</code> (for
the last <code class="reqn">p</code> observations), or <code>"random"</code> (for a random sample
of <code class="reqn">p</code> indices between 1 and <code class="reqn">n</code>). Defaults to <code>"first"</code>.</p>
</td></tr>
<tr><td><code id="blus_+3A_keepna">keepNA</code></td>
<td>
<p>A logical. Should BLUS residuals for omitted observations be
returned as <code>NA_real_</code> to preserve the length of the residual vector?</p>
</td></tr>
<tr><td><code id="blus_+3A_exhaust">exhaust</code></td>
<td>
<p>An integer. If singular matrices are encountered
using the passed value of <code>omit</code>, how many random combinations
of <code class="reqn">p</code> indices should be attempted before an error is thrown? If
<code>NA</code> (the default), all possible combinations are attempted
provided that <code class="reqn">{n \choose p} \le 10^4</code>; otherwise up to
<code class="reqn">10^4</code> random samples of size <code>p</code> from <code>1:n</code> are
attempted (with replacement). Integer values of <code>exhaust</code>
greater than <code>1e4L</code> are treated as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="blus_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
reproducibility of bootstrap results. The value <code>NA</code>
results in not setting a seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the ideal linear model conditions, the BLUS residuals have a
scalar covariance matrix <code class="reqn">\omega I</code> (meaning they have a constant
variance and are mutually uncorrelated), unlike the OLS residuals, which
have covariance matrix <code class="reqn">\omega M</code> where <code class="reqn">M</code> is a function of
the design matrix. Use of BLUS residuals could improve the performance of
tests for heteroskedasticity and/or autocorrelation in the linear model.
A linear model with <code class="reqn">n</code> observations and an <code class="reqn">n\times p</code> design
matrix yields only <code class="reqn">n-p</code> BLUS residuals. The choice of which <code class="reqn">p</code>
observations will not be represented in the BLUS residuals is specified
within the algorithm.
</p>


<h3>Value</h3>

<p>A double vector of length <code class="reqn">n</code> containing the BLUS residuals
(with <code>NA_real_</code>) for omitted observations), or a double vector
of length <code class="reqn">n-p</code> containing the BLUS residuals only (if <code>keepNA</code>
is set to <code>FALSE</code>)
</p>


<h3>References</h3>

<p>Theil H (1965).
&ldquo;The Analysis of Disturbances in Regression Analysis.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(312), 1067&ndash;1079.<br /><br /> Theil H (1968).
&ldquo;A Simplification of the BLUS Procedure for Analyzing Regression Disturbances.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>63</b>(321), 242&ndash;251.
</p>


<h3>See Also</h3>

<p>H. D. Vinod's online article,
<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2412740">Theil's
BLUS Residuals and R Tools for Testing and Removing Autocorrelation and
Heteroscedasticity</a>, for an alternative function for computing BLUS
residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
blus(mtcars_lm)
plot(mtcars_lm$residuals, blus(mtcars_lm))
# Same as first example
mtcars_list &lt;- list("y" = mtcars$mpg, "X" = cbind(1, mtcars$wt, mtcars$qsec, mtcars$am))
blus(mtcars_list)
# Again same as first example
mtcars_list2 &lt;- list("e" = mtcars_lm$residuals, "X" = cbind(1, mtcars$wt, mtcars$qsec, mtcars$am))
blus(mtcars_list2)
# BLUS residuals cannot be computed with `omit = "last"` in this example, so
# omitted indices are randomised:
blus(mtcars_lm, omit = "last")

</code></pre>

<hr>
<h2 id='bootlm'>Nonparametric Bootstrapping of Heteroskedastic Linear Regression Models</h2><span id='topic+bootlm'></span>

<h3>Description</h3>

<p>Generates <code class="reqn">B</code> nonparametric bootstrap replications of a linear
regression model that may have heteroskedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootlm(
  object,
  sampmethod = c("pairs", "wild"),
  B = 1000L,
  resfunc = c("identity", "hccme"),
  fastfit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootlm_+3A_object">object</code></td>
<td>
<p>Either an object of class <code>"lm"</code> (generated by
<code><a href="stats.html#topic+lm">lm</a></code>), an object of class <code>"alvm.fit"</code>
(generated by <code><a href="#topic+alvm.fit">alvm.fit</a></code>), or an object of class
<code>"anlvm.fit"</code> (generated by <code><a href="#topic+anlvm.fit">anlvm.fit</a></code>)</p>
</td></tr>
<tr><td><code id="bootlm_+3A_sampmethod">sampmethod</code></td>
<td>
<p>A character, either <code>"pairs"</code> or <code>"wild"</code>,
indicating the method to be used to generate the resampled models:
bootstrapping pairs (Efron and Tibshirani 1993) or the wild bootstrap
(Davidson and Flachaire 2008). Defaults to <code>"pairs"</code>.</p>
</td></tr>
<tr><td><code id="bootlm_+3A_b">B</code></td>
<td>
<p>An integer representing the number of bootstrapped linear
regression models to generate; defaults to <code>1000L</code></p>
</td></tr>
<tr><td><code id="bootlm_+3A_resfunc">resfunc</code></td>
<td>
<p>Either a character naming a function to call to apply a
transformation to the Ordinary Least Squares residuals, or a function
to apply for the same purpose. This argument is ignored if
<code>sampmethod</code> is <code>"pairs"</code>. The only two character values
accepted are <code>"identity"</code>, in which case no transformation is
applied to the residuals, and <code>"hccme"</code>, in which case the
transformation corresponds to a heteroskedasticity-consistent
covariance matrix estimator calculated from <code><a href="#topic+hccme">hccme</a></code>. If
<code>resfunc</code> is a function, it is assumed that its first argument
is the numeric vector of residuals.</p>
</td></tr>
<tr><td><code id="bootlm_+3A_fastfit">fastfit</code></td>
<td>
<p>A logical indicating whether the <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>
function should be used to fit the bootstrapped regression models for
greater computational speed; defaults to <code>TRUE</code>. This affects the
class of the returned value (see below). If <code>FALSE</code>,
<code><a href="stats.html#topic+lm">lm</a></code> is used to fit the bootstrapped regression
models.</p>
</td></tr>
<tr><td><code id="bootlm_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+hccme">hccme</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each replication of the pairs bootstrap entails drawing a sample
of size <code class="reqn">n</code> (the number of observations) with replacement from the
indices <code class="reqn">i=1,2,\ldots,n</code>. The pair or case <code class="reqn">(y_i, X_i)</code> is
included as an observation in the bootstrapped data set for each sampled
index. An Ordinary Least Squares fit to the bootstrapped data set is then
computed.
</p>
<p>Under the wild bootstrap, each replication of the linear regression model
is generated by first independently drawing <code class="reqn">n</code> random values
<code class="reqn">r_i</code>, <code class="reqn">i=1,2,\ldots,n</code>, from a distribution with zero mean and
unit variance. The <code class="reqn">i</code>th bootstrap response is then computed as
</p>
<p style="text-align: center;"><code class="reqn">X_i'\hat{\beta} + f_i(e_i) r_i</code>
</p>
<p>, where <code class="reqn">X_i</code> is the <code class="reqn">i</code>th
design observation, <code class="reqn">\hat{\beta}</code> is the Ordinary Least Squares
estimate of the coefficient vector <code class="reqn">\beta</code>, <code class="reqn">e_i</code> is the
<code class="reqn">i</code>th Ordinary Least Squares residual, and <code class="reqn">f_i(\cdot)</code> is a
function performing some transformation on the residual. An Ordinary
Least Squares fit is then computed on the original design matrix and the
bootstrap response vector.
</p>


<h3>Value</h3>

<p>A list object of class <code>"bootlm"</code>, containing <code>B</code> objects,
each of which is a bootstrapped linear regression model fit by Ordinary
Least Squares. If <code>fastfit</code> was set to <code>TRUE</code>, each of these
objects will be a list containing named objects <code>y</code> (the bootstrap
response vector), <code>X</code> (the bootstrap design matrix, which is just
the original design matrix under the wild bootstrap), <code>e</code> (the
residual vector from the Ordinary Least Squares fit to this bootstrap
data set), <code>beta.hat</code> (the vector of coefficient estimates from the
Ordinary Least Squares fit to this bootstrap data set),
<code>sampmethod</code>, and <code>ind</code> (a vector of the indices from the
original data set used in this bootstrap sample; ignored under the
wild bootstrap)
of the kind returned by
<code><a href="stats.html#topic+lm.fit">lm.fit</a></code>; otherwise, each will be an object of class
<code>"lm"</code>.
</p>


<h3>References</h3>

<p>Davidson R, Flachaire E (2008).
&ldquo;The Wild Bootstrap, Tamed at Last.&rdquo;
<em>Journal of Econometrics</em>, <b>146</b>, 162&ndash;169.<br /><br /> Efron B, Tibshirani RJ (1993).
<em>An Introduction to the Bootstrap</em>.
Springer Science+Business Media, Dordrecht.
</p>


<h3>See Also</h3>

<p><code><a href="lmboot.html#topic+paired.boot">paired.boot</a></code> and
<code><a href="lmboot.html#topic+wild.boot">wild.boot</a></code> for the pairs bootstrap and wild
bootstrap, respectively. The latter function does not appear to allow
transformations of the residuals in the wild bootstrap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
mybootlm &lt;- bootlm(mtcars_lm)

</code></pre>

<hr>
<h2 id='breusch_pagan'>Breusch-Pagan Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+breusch_pagan'></span>

<h3>Description</h3>

<p>This function implements the popular method of
Breusch and Pagan (1979) for testing for
heteroskedasticity in a linear regression model, with or without the
studentising modification of Koenker (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breusch_pagan(mainlm, auxdesign = NA, koenker = TRUE, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breusch_pagan_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="breusch_pagan_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="breusch_pagan_+3A_koenker">koenker</code></td>
<td>
<p>A logical. Should studentising modification of
Koenker (1981) be implemented? Defaults to
<code>TRUE</code>; if <code>FALSE</code>, the original form of the test proposed by
Breusch and Pagan (1979) is used.</p>
</td></tr>
<tr><td><code id="breusch_pagan_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Breusch-Pagan Test entails fitting an auxiliary regression
model in which the response variable is the vector of squared residuals
from the original model and the design matrix <code class="reqn">Z</code> consists of one or
more exogenous variables that are suspected of being related to the error
variance. In the absence of prior information on a possible choice of
<code class="reqn">Z</code>, one would typically use the explanatory variables from the
original model. Under the null hypothesis of homoskedasticity, the
distribution of the test statistic is asymptotically chi-squared with
<code>parameter</code> degrees of freedom. The test is right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object
is not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Breusch TS, Pagan AR (1979).
&ldquo;A Simple Test for Heteroscedasticity and Random Coefficient Variation.&rdquo;
<em>Econometrica</em>, <b>47</b>(5), 1287&ndash;1294.<br /><br /> Koenker R (1981).
&ldquo;A Note on Studentizing a Test for Heteroscedasticity.&rdquo;
<em>Journal of Econometrics</em>, <b>17</b>, 107&ndash;112.
</p>


<h3>See Also</h3>

<p><code><a href="lmtest.html#topic+bptest">lmtest::bptest</a></code>, which performs exactly
the same test as this function; <code><a href="car.html#topic+ncvTest">car::ncvTest</a></code>,
which is not the same test but is implemented in
<code><a href="#topic+cook_weisberg">cook_weisberg</a></code>; <code><a href="#topic+white">white</a></code>, which is a special
case of the Breusch-Pagan Test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
breusch_pagan(mtcars_lm)
breusch_pagan(mtcars_lm, koenker = FALSE)
# Same as first example
mtcars_list &lt;- list("y" = mtcars$mpg, "X" = cbind(1, mtcars$wt, mtcars$qsec, mtcars$am))
breusch_pagan(mtcars_list)

</code></pre>

<hr>
<h2 id='carapeto_holt'>Carapeto-Holt Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+carapeto_holt'></span>

<h3>Description</h3>

<p>This function implements the two methods (parametric and nonparametric) of
Carapeto and Holt (2003) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carapeto_holt(
  mainlm,
  deflator = NA,
  prop_central = 1/3,
  group1prop = 1/2,
  qfmethod = "imhof",
  alternative = c("greater", "less", "two.sided"),
  twosidedmethod = c("doubled", "kulinskaya"),
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carapeto_holt_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_prop_central">prop_central</code></td>
<td>
<p>A double specifying the proportion of central
observations to exclude when comparing the two subsets of observations.
<code><a href="base.html#topic+round">round</a></code> is used to ensure the number of central
observations is an integer. Defaults to <code class="reqn">\frac{1}{3}</code>.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_group1prop">group1prop</code></td>
<td>
<p>A double specifying the proportion of remaining
observations <em>(after excluding central observations)</em> to allocate
to the first group. The default value of <code>1 / 2</code> means that an
equal number of observations is assigned to the first and second groups.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_qfmethod">qfmethod</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>, corresponding to the <code>algorithm</code> argument
of <code><a href="#topic+pRQF">pRQF</a></code>. The default is <code>"imhof"</code>.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_alternative">alternative</code></td>
<td>
<p>A character specifying the form of alternative
hypothesis. If it is suspected that the error variance is positively
associated with the deflator variable, <code>"greater"</code>. If it is
suspected that the error variance is negatively associated with deflator
variable, <code>"less"</code>. If no information is available on the suspected
direction of the association, <code>"two.sided"</code>. Defaults to
<code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_twosidedmethod">twosidedmethod</code></td>
<td>
<p>A character indicating the method to be used to compute
two-sided <code class="reqn">p</code>-values for the parametric test when <code>alternative</code>
is <code>"two.sided"</code>. The argument is passed to
<code><a href="#topic+twosidedpval">twosidedpval</a></code> as its <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="carapeto_holt_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is based on the methodology of
Goldfeld and Quandt (1965) but does not require any
auxiliary regression. It entails ordering the observations by some
suspected deflator (one of the explanatory variables) in such a way
that, under the alternative hypothesis, the observations would now
be arranged in decreasing order of error variance. A specified proportion
of the most central observations (under this ordering) is removed,
leaving a subset of lower observations and a subset of upper
observations. The test statistic is then computed as a ratio of quadratic
forms corresponding to the sums of squared residuals of the upper and
lower observations respectively. <code class="reqn">p</code>-values are computed by the
Imhof algorithm in <code><a href="#topic+pRQF">pRQF</a></code>.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Carapeto M, Holt W (2003).
&ldquo;Testing for Heteroscedasticity in Regression Models.&rdquo;
<em>Journal of Applied Statistics</em>, <b>30</b>(1), 13&ndash;20.<br /><br /> Goldfeld SM, Quandt RE (1965).
&ldquo;Some Tests for Homoscedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(310), 539&ndash;547.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
carapeto_holt(mtcars_lm, deflator = "qsec", prop_central = 0.25)
# Same as previous example
mtcars_list &lt;- list("y" = mtcars$mpg, "X" = cbind(1, mtcars$wt, mtcars$qsec, mtcars$am))
carapeto_holt(mtcars_list, deflator = 3, prop_central = 0.25)

</code></pre>

<hr>
<h2 id='cook_weisberg'>Cook-Weisberg Score Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+cook_weisberg'></span>

<h3>Description</h3>

<p>This function implements the score test of
Cook and Weisberg (1983) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cook_weisberg(
  mainlm,
  auxdesign = NA,
  hetfun = c("mult", "add", "logmult"),
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cook_weisberg_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="cook_weisberg_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="cook_weisberg_+3A_hetfun">hetfun</code></td>
<td>
<p>A character describing the form of <code class="reqn">w(\cdot)</code>, the error
variance function under the heteroskedastic alternative. Possible values
are <code>"mult"</code> (the default), corresponding to
<code class="reqn">w(Z_i,\lambda)=\exp\left\{\sum_{j=1}^{q}\lambda_j Z_{ij}\right\}</code>,
<code>"add"</code>, corresponding to
<code class="reqn">w(Z_i,\lambda)=\left(1+\sum_{j=1}^{q} \lambda_j Z_{ij}\right)^2</code>, and
<code>"logmult"</code>, corresponding to
<code class="reqn">w(Z_i,\lambda)=\exp\left\{\sum_{j=1}^{q}\lambda_j \log Z_{ij}\right\}</code>.
The multiplicative and log-multiplicative cases are considered in
Cook and Weisberg (1983); the additive case is discussed,
<em>inter alia</em>, by Griffiths and Surekha (1986).
Results for the additive and multiplicative models are identical for this
test. Partial matching is used.</p>
</td></tr>
<tr><td><code id="cook_weisberg_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cook-Weisberg Score Test entails fitting an auxiliary
regression model in which the response variable is the vector of
standardised squared residuals <code class="reqn">e_i^2/\hat{\omega}</code> from the original
OLS model and the design matrix is some function of <code class="reqn">Z</code>, an
<code class="reqn">n \times q</code> matrix consisting of <code class="reqn">q</code> exogenous variables,
appended to a column of ones. The test statistic is half the residual sum
of squares from this auxiliary regression. Under the null hypothesis of
homoskedasticity, the distribution of the test statistic is
asymptotically chi-squared with <code class="reqn">q</code> degrees of freedom. The test is
right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Cook RD, Weisberg S (1983).
&ldquo;Diagnostics for Heteroscedasticity in Regression.&rdquo;
<em>Biometrika</em>, <b>70</b>(1), 1&ndash;10.<br /><br /> Griffiths WE, Surekha K (1986).
&ldquo;A Monte Carlo Evaluation of the Power of Some Tests for Heteroscedasticity.&rdquo;
<em>Journal of Econometrics</em>, <b>31</b>(1), 219&ndash;231.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+ncvTest">car::ncvTest</a></code>, which implements the same
test. Calling <code>car::ncvTest</code> with <code>var.formula</code> argument omitted
is equivalent to calling <code>skedastic::cook_weisberg</code> with
<code>auxdesign = "fitted.values", hetfun = "additive"</code>. Calling
<code>car::ncvTest</code> with <code>var.formula = ~ X</code> (where <code>X</code> is the
design matrix of the linear model with the intercept column omitted) is
equivalent to calling <code>skedastic::cook_weisberg</code> with default
<code>auxdesign</code> and <code>hetfun</code> values. The
<code>hetfun = "multiplicative"</code> option has no equivalent in
<code>car::ncvTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
cook_weisberg(mtcars_lm)
cook_weisberg(mtcars_lm, auxdesign = "fitted.values", hetfun = "logmult")

</code></pre>

<hr>
<h2 id='countpeaks'>Count peaks in a data sequence</h2><span id='topic+countpeaks'></span>

<h3>Description</h3>

<p>This function computes the number of peaks in a double vector, with
peak defined as per Goldfeld and Quandt (1965). The function
is used in the Goldfeld-Quandt nonparametric test for heteroskedasticity in
a linear model. <code>NA</code> and <code>NaN</code> values in the sequence are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countpeaks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countpeaks_+3A_x">x</code></td>
<td>
<p>A double vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value between <code>0</code> and <code>length(x) - 1</code>
representing the number of peaks in the sequence.
</p>


<h3>References</h3>

<p>Goldfeld SM, Quandt RE (1965).
&ldquo;Some Tests for Homoscedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(310), 539&ndash;547.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+goldfeld_quandt">goldfeld_quandt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9586)
countpeaks(stats::rnorm(20))
mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
countpeaks(mtcars_lm$residuals)

</code></pre>

<hr>
<h2 id='dDtrend'>Probability mass function of nonparametric trend statistic <code class="reqn">D</code></h2><span id='topic+dDtrend'></span>

<h3>Description</h3>

<p>This function computes <code class="reqn">\Pr(D = k)</code>, i.e. the probability mass
function for <code class="reqn">D=\sum_{i=1}^{n} (R_i - i)^2</code>, the nonparametric trend
statistic proposed by Lehmann (1975), under the
assumption that the ranks <code class="reqn">R_i</code> are computed on a series of <code class="reqn">n</code>
independent and identically distributed random variables with no ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDtrend(k = "all", n, override = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dDtrend_+3A_k">k</code></td>
<td>
<p>An integer of <code>length</code> <code class="reqn">\ge 1</code>
or a character <code>"all"</code> (the default) indicating that the probability
mass function should be applied to the entire support of <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="dDtrend_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of observations in the
series. Note that computation time increases rapidly with <code class="reqn">n</code> and is
infeasible for <code class="reqn">n&gt;11</code>.</p>
</td></tr>
<tr><td><code id="dDtrend_+3A_override">override</code></td>
<td>
<p>A logical. By default, the function aborts if <code class="reqn">n &gt; 11</code>
due to the prohibitively slow computation (which may cause some systems
to crash). Setting this argument to <code>TRUE</code> overrides the abort.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used within <code><a href="#topic+horn">horn</a></code> in computing
<code class="reqn">p</code>-values for Horn's nonparametric test for heteroskedasticity in a
linear regression model (Horn 1981). The support of
<code class="reqn">D</code> consists of consecutive even numbers from 0 to
<code class="reqn">\frac{n(n-1)(n+1)}{3}</code>, with the exception of the case <code class="reqn">n=3</code>,
when the value 4 is excluded from the support. Note that computation speed
for <code>k = "all"</code> is about the same as when <code>k</code> is set to an
individual integer value, because the entire distribution is still
computed in the latter case.
</p>


<h3>Value</h3>

<p>A double vector containing the probabilities corresponding to the
integers in its <code>names</code> attribute.
</p>


<h3>References</h3>

<p>Horn P (1981).
&ldquo;Heteroscedasticity of Residuals: A Non-Parametric Alternative to the Goldfeld-Quandt Peak Test.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>10</b>(8), 795&ndash;808.<br /><br /> Lehmann EL (1975).
<em>Nonparametrics: Statistical Methods Based on Ranks</em>.
Holden-Day, San Francisco.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+horn">horn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob &lt;- dDtrend(k = "all", n = 6)
values &lt;- as.integer(names(prob))
plot(c(values[1], values[1]), c(0, prob[1]), type = "l",
  axes = FALSE, xlab = expression(k), ylab = expression(Pr(D == k)),
  xlim = c(0, 70), yaxs = "i", ylim = c(0, 1.05 * max(prob)))
  axis(side = 1, at = seq(0, 70, 10), las = 2)
for (i in seq_along(values)) {
 lines(c(values[i], values[i]), c(0, prob[i]))
}

</code></pre>

<hr>
<h2 id='diblasi_bowman'>Diblasi and Bowman's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+diblasi_bowman'></span>

<h3>Description</h3>

<p>This function implements the nonparametric test of
Diblasi and Bowman (1997) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diblasi_bowman(
  mainlm,
  distmethod = c("moment.match", "bootstrap"),
  H = 0.08,
  ignorecov = TRUE,
  B = 500L,
  seed = 1234,
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diblasi_bowman_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_distmethod">distmethod</code></td>
<td>
<p>A character specifying the method by which to estimate
the <code class="reqn">p</code>-values, either <code>"moment.match"</code> or <code>"bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_h">H</code></td>
<td>
<p>A hyperparameter denoting the bandwidth matrix in the kernel
function used for weights in nonparametric smoothing. If a double of
length 1 (the default), <code>H</code> is set to <code class="reqn">h I_{p^\prime}</code> where
<code class="reqn">h</code> is the scalar bandwidth value entered and <code class="reqn">I_{p^\prime}</code>
is the <code class="reqn">p^\prime \times p^\prime</code> identity matrix (where
<code class="reqn">p^\prime</code> is the number of columns in the <code class="reqn">X</code> matrix, excluding
an intercept if present). If a double of length <code class="reqn">p^\prime</code>, <code>H</code>
is set to <code class="reqn">diag(h)</code> where <code class="reqn">h</code> is the bandwidth vector entered.
If <code>H</code> is a <code class="reqn">p^\prime\times p^\prime</code> matrix it is used as is.
Any other dimensionality of <code>H</code> results in an error.</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_ignorecov">ignorecov</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default), the
variance-covariance matrix of <code class="reqn">s</code> is assumed to be diagonal. (This
assumption is, strictly speaking, invalid, but usually yields a reasonable
approximation. Computation time is
prohibitive for large sample sizes if set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of nonparametric bootstrap
replications to be used, if <code>distmethod="bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
reproducibility of bootstrap results. The value <code>NA</code>
results in not setting a seed.</p>
</td></tr>
<tr><td><code id="diblasi_bowman_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test entails undertaking a transformation of the OLS residuals
<code class="reqn">s_i=\sqrt{|e_i|}-E_0(\sqrt{|e_i|})</code>, where <code class="reqn">E_0</code> denotes
expectation under the null hypothesis of homoskedasticity. The kernel
method of nonparametric regression is used to fit the relationship
between these <code class="reqn">s_i</code> and the explanatory variables. This leads to a
test statistic <code class="reqn">T</code> that is a ratio of quadratic forms involving the
vector of <code class="reqn">s_i</code> and the matrix of normal kernel weights. Although
nonparametric in its method of fitting the possible heteroskedastic
relationship, the distributional approximation used to compute
<code class="reqn">p</code>-values assumes normality of the errors.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Diblasi A, Bowman A (1997).
&ldquo;Testing for Constant Variance in a Linear Model.&rdquo;
<em>Statistics &amp; Probability Letters</em>, <b>33</b>, 95&ndash;103.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
diblasi_bowman(mtcars_lm)
diblasi_bowman(mtcars_lm, ignorecov = FALSE)
diblasi_bowman(mtcars_lm, distmethod = "bootstrap")

</code></pre>

<hr>
<h2 id='dpeak'>Probability mass function of number of peaks in an i.i.d. random sequence</h2><span id='topic+dpeak'></span>

<h3>Description</h3>

<p>This function computes <code class="reqn">P(n,k)</code> as defined by
Goldfeld and Quandt (1965), i.e. the probability that a
sequence of <code class="reqn">n</code> independent and identically distributed random variables
contains exactly <code class="reqn">k</code> peaks, with peaks also as defined by
Goldfeld and Quandt (1965). The function is used in
<code><a href="#topic+ppeak">ppeak</a></code> to compute <code class="reqn">p</code>-values for the Goldfeld-Quandt
nonparametric test for heteroskedasticity in a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpeak(k, n, usedata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpeak_+3A_k">k</code></td>
<td>
<p>An integer or a sequence of integers strictly incrementing by 1,
with all values between 0 and <code>n - 1</code> inclusive. Represents the number
of peaks in the sequence.</p>
</td></tr>
<tr><td><code id="dpeak_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of observations in the
sequence.</p>
</td></tr>
<tr><td><code id="dpeak_+3A_usedata">usedata</code></td>
<td>
<p>A logical. Should probability mass function values be
read from <code><a href="#topic+dpeakdat">dpeakdat</a></code> rather than computing them? This option
will save significantly on computation time if <code class="reqn">n &lt; 170</code> but is
currently only available for <code class="reqn">n \leq 1000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double between 0 and 1 representing the probability of exactly
k peaks occurring in a sequence of <code class="reqn">n</code> independent and identically
distributed continuous random variables. The double has a <code>names</code>
attribute with the values corresponding to the probabilities.
Computation time is very slow for
<code class="reqn">n &gt; 170</code> (if <code>usedata</code> is <code>FALSE</code>) and for <code class="reqn">n &gt; 1000</code>
regardless of <code>usedata</code> value.
</p>


<h3>References</h3>

<p>Goldfeld SM, Quandt RE (1965).
&ldquo;Some Tests for Homoscedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(310), 539&ndash;547.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppeak">ppeak</a></code>, <code><a href="#topic+goldfeld_quandt">goldfeld_quandt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpeak(0:9, 10)
plot(0:9, dpeak(0:9, 10), type = "p", pch = 20, xlab = "Number of Peaks",
         ylab = "Probability")

# This would be extremely slow if usedata were set to FALSE:
prob &lt;- dpeak(0:199, 200, usedata = TRUE)
plot(0:199, prob, type = "l", xlab = "Number of Peaks", ylab = "Probability")

# `dpeakdat` is a dataset containing probabilities generated from `dpeak`
utils::data(dpeakdat)
expval &lt;- unlist(lapply(dpeakdat,
                 function(p) sum(p * 0:(length(p) - 1))))
plot(1:1000, expval[1:1000], type = "l", xlab = parse(text = "n"),
     ylab = "Expected Number of Peaks")
</code></pre>

<hr>
<h2 id='dpeakdat'>Probability distribution for number of peaks in a continuous,
uncorrelated stochastic series</h2><span id='topic+dpeakdat'></span>

<h3>Description</h3>

<p>A dataset containing the probability mass function for the distribution of
the number of peaks in a continuous, uncorrelated stochastic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpeakdat
</code></pre>


<h3>Format</h3>

<p>A list of 1000 objects. The <code class="reqn">n</code>th object is a double vector
of length <code class="reqn">n</code>, with elements representing the probability of <code class="reqn">k</code>
peaks for <code class="reqn">k=0,1,\ldots,n-1</code>.
</p>


<h3>Details</h3>

<p>These probabilities were generated from the <code><a href="#topic+dpeak">dpeak</a></code>
function. This function is computationally very slow for <code class="reqn">n &gt; 170</code>;
thus the functions of <code>skedastic</code> package that require peak
probabilities (<code><a href="#topic+ppeak">ppeak</a></code> and <code><a href="#topic+goldfeld_quandt">goldfeld_quandt</a></code>)
by default obtain the probabilities from this data set rather than
from <code><a href="#topic+dpeak">dpeak</a></code>, provided that <code class="reqn">n \leq 1000</code>. For
<code class="reqn">n &gt; 1000</code>, good luck!
</p>

<hr>
<h2 id='dufour_etal'>Dufour et al.'s Monte Carlo Test for Heteroskedasticity in a Linear
Regression Model</h2><span id='topic+dufour_etal'></span>

<h3>Description</h3>

<p>This function implements the method of
Dufour et al. (2004) for testing for
heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dufour_etal(
  mainlm,
  hettest,
  R = 1000L,
  alternative = c("greater", "less", "two.sided"),
  errorgen = stats::rnorm,
  errorparam = list(),
  seed = 1234,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dufour_etal_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_hettest">hettest</code></td>
<td>
<p>A character specifying the name of a function
that implements a heteroskedasticity test on a linear regression model.
The function is called with the <code>statonly</code> argument set to
<code>TRUE</code> to improve computational efficiency.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of Monte Carlo replicates to
generate. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_alternative">alternative</code></td>
<td>
<p>The tailedness of the test whose statistic is computed by
<code>hettest</code> function; one of <code>"greater"</code> (the default),
<code>"less"</code>, or <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_errorgen">errorgen</code></td>
<td>
<p>A function, or a character specifying the name of a
function, from which the random errors are to be generated. The function
should correspond to a continuous probability distribution that has (or
at least can have) a mean of 0. Defaults to <code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_errorparam">errorparam</code></td>
<td>
<p>An optional list of parameters to pass to <code>errorgen</code>.
This argument is ignored if <code>errorgen</code> is
<code><a href="stats.html#topic+rnorm">rnorm</a></code>, since <code>mean</code> must be set to 0, and
<code>sd</code> is set to 1 because the heteroskedasticity test implemented by
<code>hettest</code> function is assumed to be scale invariant. If
<code>errorgen</code> is not <code>rnorm</code>, <code>errorparam</code> should be chosen
in such a way that the error distribution has a mean of 0.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
reproducibility of Monte Carlo results. A value of <code>NA</code>
results in not setting a seed.</p>
</td></tr>
<tr><td><code id="dufour_etal_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to function with name <code>hettest</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test implements a Monte Carlo procedure as follows. (1) The
observed value of the test statistic <code class="reqn">T_0</code> is computed using function
with name <code>hettest</code>. (2) <code>R</code> replications of the random error
vector are generated from the distribution specified using
<code>errorgen</code>. (3) <code>R</code> replications of the test statistic,
<code class="reqn">T_1,T_2,\ldots,T_R</code>, are computed from the generated error vectors.
(4) The empirical <code>p</code>-value is computed as
<code class="reqn">\frac{\hat{G}_R(T_0)+1}{R+1}</code>, where
<code class="reqn">\hat{G}_R(x)=\sum_{j=1}^{R} 1_{T_j \ge x}</code>, <code class="reqn">1_{\bullet}</code>
being the indicator function. The test is right-tailed, regardless of the
tailedness of <code>hettest</code>. Note that the heteroskedasticity
test implemented by <code>hettest</code> must have a test statistic that is
continuous and that is invariant with respect to nuisance parameters
(<code class="reqn">\omega</code> and <code class="reqn">\beta</code>). Note further that if <code>hettest</code>
is <code>goldfeld_quandt</code> with <code>method</code> argument
<code>"parametric"</code>, the replicated Goldfeld-Quandt <code class="reqn">F</code> statistics
are computed directly within this function rather than by calling
<code>goldfeld_quandt</code>, due to some idiosyncratic features of this test.
Note that, if <code>alternative</code> is set to <code>"two.sided"</code>, the
one-sided <code class="reqn">p</code>-value is doubled (<code><a href="#topic+twosidedpval">twosidedpval</a></code> cannot
be used in this case).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object
is not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Dufour J, Khalaf L, Bernard J, Genest I (2004).
&ldquo;Simulation-Based Finite-Sample Tests for Heteroskedasticity and ARCH Effects.&rdquo;
<em>Journal of Econometrics</em>, <b>122</b>, 317&ndash;347.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
dufour_etal(mtcars_lm, hettest = "breusch_pagan")

</code></pre>

<hr>
<h2 id='evans_king'>Evans-King Tests for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+evans_king'></span>

<h3>Description</h3>

<p>This function implements the two methods of
Evans and King (1988) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evans_king(
  mainlm,
  method = c("GLS", "LM"),
  deflator = NA,
  lambda_star = 5,
  qfmethod = "imhof",
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evans_king_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="evans_king_+3A_method">method</code></td>
<td>
<p>A character indicating which of the two tests derived in
Evans and King (1988) should be implemented.
Possible values are <code>"GLS"</code> and <code>"LM"</code>; partial matching is
used (which is not case-sensitive).</p>
</td></tr>
<tr><td><code id="evans_king_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="evans_king_+3A_lambda_star">lambda_star</code></td>
<td>
<p>A double; coefficient representing the degree of
heteroskedasticity under the alternative hypothesis.
Evans and King (1985) suggests 2.5, 5, 7.5, and 10 as
values to consider, and Evans and King (1988) finds
that 2.5 and 5 perform best empirically. This parameter is used only for
the <code>"GLS"</code> method; the <code>"LM"</code> method represents the limiting
case as <code class="reqn">\lambda^\star \to 0</code>. Defaults to <code>5</code>.</p>
</td></tr>
<tr><td><code id="evans_king_+3A_qfmethod">qfmethod</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>, corresponding to the <code>algorithm</code> argument
of <code><a href="#topic+pRQF">pRQF</a></code>. The default is <code>"imhof"</code>.</p>
</td></tr>
<tr><td><code id="evans_king_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test entails putting the data rows in increasing order of
some specified deflator (e.g., one of the explanatory variables) that
is believed to be related to the error variance by some non-decreasing
function. There are two statistics that can be used, corresponding to
the two values of the <code>method</code> argument. In both cases the test
statistic can be expressed as a ratio of quadratic forms in the errors,
and thus the Imhof algorithm is used to compute <code class="reqn">p</code>-values. Both
methods involve a left-tailed test.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Evans M, King ML (1985).
&ldquo;A Point Optimal Test for Heteroscedastic Disturbances.&rdquo;
<em>Journal of Econometrics</em>, <b>27</b>(2), 163&ndash;178.<br /><br /> Evans MA, King ML (1988).
&ldquo;A Further Class of Tests for Heteroscedasticity.&rdquo;
<em>Journal of Econometrics</em>, <b>37</b>, 265&ndash;276.
</p>


<h3>See Also</h3>

<p>Evans and King (1985), which already anticipates
one of the tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
evans_king(mtcars_lm, deflator = "qsec", method = "GLS")
evans_king(mtcars_lm, deflator = "qsec", method = "LM")

</code></pre>

<hr>
<h2 id='glejser'>Glejser Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+glejser'></span>

<h3>Description</h3>

<p>This function implements the method of
Glejser (1969) for testing for &quot;multiplicative&quot;
heteroskedasticity in a linear regression model.
Mittelhammer et al. (2000) gives the
formulation of the test used here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glejser(
  mainlm,
  auxdesign = NA,
  sigmaest = c("main", "auxiliary"),
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glejser_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="glejser_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="glejser_+3A_sigmaest">sigmaest</code></td>
<td>
<p>A character indicating which model residuals to use in the
<code class="reqn">\hat{\omega}</code> estimator in the denominator of the test statistic.
If <code>"main"</code> (the default), the OLS residuals from the original model
are used; this produces results identical to the Glejser Test in SHAZAM
software. If <code>"auxiliary"</code>, the OLS residuals from the auxiliary
model are used, as in Mittelhammer et al. (2000).
Partial matching is used.</p>
</td></tr>
<tr><td><code id="glejser_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Glejser's Test entails fitting an auxiliary regression model in
which the response variable is the absolute residual from the original
model and the design matrix <code class="reqn">Z</code> consists of one or more exogenous
variables that are suspected of being related to the error variance.
In the absence of prior information on a possible choice of <code class="reqn">Z</code>,
one would typically use the explanatory variables from the original model.
Under the null hypothesis of homoskedasticity, the distribution of the
test statistic is asymptotically chi-squared with <code>parameter</code> degrees
of freedom. The test is right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Glejser H (1969).
&ldquo;A New Test for Heteroskedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>64</b>(325), 316&ndash;323.<br /><br /> Mittelhammer RC, Judge GG, Miller DJ (2000).
<em>Econometric Foundations</em>.
Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p>the description of the test in
<a href="http://www.econometrics.com/intro/testhet.htm">SHAZAM</a> software
(which produces identical results).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
glejser(mtcars_lm)

</code></pre>

<hr>
<h2 id='godfrey_orme'>Godfrey and Orme's Nonparametric Bootstrap Test for Heteroskedasticity in a Linear
Regression Model</h2><span id='topic+godfrey_orme'></span>

<h3>Description</h3>

<p>This function implements the method of
Godfrey and Orme (1999) for testing for
heteroskedasticity in a linear regression model. The procedure is more
clearly described in Godfrey et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>godfrey_orme(
  mainlm,
  hettest,
  B = 1000L,
  alternative = c("greater", "less", "two.sided"),
  seed = 1234,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="godfrey_orme_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="godfrey_orme_+3A_hettest">hettest</code></td>
<td>
<p>A character specifying the name of a function
that implements a heteroskedasticity test on a linear regression model.
The function is called with the <code>statonly</code> argument set to
<code>TRUE</code> to improve computational efficiency.</p>
</td></tr>
<tr><td><code id="godfrey_orme_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of nonparametric bootstrap samples
to generate. Defaults to <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="godfrey_orme_+3A_alternative">alternative</code></td>
<td>
<p>The tailedness of the test whose statistic is computed by
<code>hettest</code> function; one of <code>"greater"</code> (the default),
<code>"less"</code>, or <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="godfrey_orme_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
reproducibility of bootstrap results. A value of <code>NA</code>
results in not setting a seed.</p>
</td></tr>
<tr><td><code id="godfrey_orme_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to function with name <code>hettest</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure runs as follows. (1) The observed
value of the test statistic <code class="reqn">T_0</code> is computed using function with
name <code>hettest</code>. (2) A sample
<code class="reqn">e_1^\star,e_2^\star,\ldots,e_n^\star</code> is drawn with replacement from
the OLS residuals. (3) Bootstrapped response values are computed as
<code class="reqn">y_i^{\star}=x_i' \hat{\beta}+e_i^\star,i=1,2,\ldots,n</code>.
(4) Bootstrapped test statistic value <code class="reqn">T^\star</code> is computed from the
regression of <code class="reqn">y^\star</code> on <code class="reqn">X</code> using function <code>hettest</code>.
(5) Steps (2)-(4) are repeated until <code class="reqn">B</code> bootstrapped test statistic
values are computed. (6) Empirical <code class="reqn">p</code>-value is computed by comparing
the bootstrapped test statistic values to the observed test statistic
value. Note that, if <code>alternative</code> is set to <code>"two.sided"</code>, the
one-sided <code class="reqn">p</code>-value is doubled (<code><a href="#topic+twosidedpval">twosidedpval</a></code> cannot
be used in this case).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object
is not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Godfrey LG, Orme CD (1999).
&ldquo;The Robustness, Reliability and Power of Heteroskedasticity Tests.&rdquo;
<em>Econometric Reviews</em>, <b>18</b>(2), 169&ndash;194.<br /><br /> Godfrey LG, Orme CD, Silva JS (2006).
&ldquo;Simulation-Based Tests for Heteroskedasticity in Linear Regression Models: Some Further Results.&rdquo;
<em>Econometrics Journal</em>, <b>9</b>, 76&ndash;97.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
godfrey_orme(mtcars_lm, hettest = "breusch_pagan")

</code></pre>

<hr>
<h2 id='goldfeld_quandt'>Goldfeld-Quandt Tests for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+goldfeld_quandt'></span>

<h3>Description</h3>

<p>This function implements the two methods (parametric and nonparametric) of
Goldfeld and Quandt (1965) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goldfeld_quandt(
  mainlm,
  method = c("parametric", "nonparametric"),
  deflator = NA,
  prop_central = 1/3,
  group1prop = 1/2,
  alternative = c("greater", "less", "two.sided"),
  prob = NA,
  twosidedmethod = c("doubled", "kulinskaya"),
  restype = c("ols", "blus"),
  statonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goldfeld_quandt_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_method">method</code></td>
<td>
<p>A character indicating which of the two tests derived in
Goldfeld and Quandt (1965) should be implemented.
Possible values are &quot;parametric&quot; and &quot;nonparametric&quot;. Default is
&quot;parametric&quot;. It is acceptable to specify only the first letter.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_prop_central">prop_central</code></td>
<td>
<p>A double specifying the proportion of central
observations to exclude from the F test (when <code>method</code> is
<code>"parametric"</code> only). <code><a href="base.html#topic+round">round</a></code> is
used to ensure the number of central observations is an integer. The
value must be small enough to allow the two auxiliary regressions to
be fit; otherwise an error is thrown. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_group1prop">group1prop</code></td>
<td>
<p>A double specifying the proportion of remaining
observations <em>(after excluding central observations)</em> to allocate
to the first group. The default value of <code>1 / 2</code> means that an
equal number of observations is assigned to the first and second groups.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_alternative">alternative</code></td>
<td>
<p>A character specifying the form of alternative
hypothesis. If it is suspected that the
error variance is positively associated with the deflator variable,
<code>"greater"</code>. If it is suspected that the error variance is
negatively associated with deflator variable, <code>"less"</code>. If no
information is available on the suspected direction of the association,
<code>"two.sided"</code>. Defaults to <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_prob">prob</code></td>
<td>
<p>A vector of probabilities corresponding to values of the test
statistic (number of peaks) from 0 to <code class="reqn">n-1</code> inclusive (used
only when <code>method</code> is <code>"nonparametric"</code>). If
<code>NA</code> (the default), probabilities are calculated within the
function by calling <code>ppeak</code>. The user can improve computational
performance of the test (for instance, when the test is being used
repeatedly in a simulation) by pre-specifying the exact probability
distribution of the number of peaks using this argument, e.g. by
calling the <code class="reqn">n</code>th element of <code><a href="#topic+dpeakdat">dpeakdat</a></code> (or <code class="reqn">(n-p)</code>th
element, if BLUS residuals are used).</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_twosidedmethod">twosidedmethod</code></td>
<td>
<p>A character indicating the method to be used to compute
two-sided <code class="reqn">p</code>-values for the parametric test when <code>alternative</code>
is <code>"two.sided"</code>. The argument is passed to
<code><a href="#topic+twosidedpval">twosidedpval</a></code> as its <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_restype">restype</code></td>
<td>
<p>A character specifying which residuals to use: <code>"ols"</code>
for OLS residuals (the default) or the <code>"blus"</code> for
<a href="#topic+blus">BLUS</a> residuals. The advantage of using BLUS residuals is
that, under the null hypothesis, the assumption that the random series
is independent and identically distributed is met (whereas with OLS
residuals it is not). The disadvantage of using BLUS residuals is that
only <code class="reqn">n-p</code> residuals are used rather than the full <code class="reqn">n</code>. This
argument is ignored if <code>method</code> is <code>"parametric"</code>.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="goldfeld_quandt_+3A_...">...</code></td>
<td>
<p>Optional further arguments to pass to <code><a href="#topic+blus">blus</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametric test entails putting the data rows in increasing
order of some specified deflator (one of the explanatory variables). A
specified proportion of the most central observations (under this
ordering) is removed, leaving a subset of lower observations and a subset
of upper observations. Separate OLS regressions are fit to these two
subsets of observations (using all variables from the original model).
The test statistic is the ratio of the sum of squared residuals from the
'upper' model to the sum of squared residuals from the 'lower' model.
Under the null hypothesis, the test statistic is exactly F-distributed
with numerator and denominator degrees of freedom equal to
<code class="reqn">(n-c)/2 - p</code> where <code class="reqn">n</code> is the number of observations in the
original regression model, <code class="reqn">c</code> is the number of central observations
removed, and <code class="reqn">p</code> is the number of columns in the design matrix (number of
parameters to be estimated, including intercept).
</p>
<p>The nonparametric test entails putting the residuals of the linear model in
increasing order of some specified deflator (one of the explanatory
variables). The test statistic is the number of peaks, with the <code class="reqn">j</code>th
absolute residual <code class="reqn">|e_j|</code> defined as a peak if <code class="reqn">|e_j|\ge|e_i|</code>
for all <code class="reqn">i&lt;j</code>. The first observation does not constitute a peak. If
the number of peaks is large relative to the distribution of peaks under
the null hypothesis, this constitutes evidence for heteroskedasticity.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Goldfeld SM, Quandt RE (1965).
&ldquo;Some Tests for Homoscedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(310), 539&ndash;547.
</p>


<h3>See Also</h3>

<p><code><a href="lmtest.html#topic+gqtest">lmtest::gqtest</a></code>, another implementation
of the Goldfeld-Quandt Test (parametric method only).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
goldfeld_quandt(mtcars_lm, deflator = "qsec", prop_central = 0.25)
# This is equivalent to lmtest::gqtest(mtcars_lm, fraction = 0.25, order.by = mtcars$qsec)
goldfeld_quandt(mtcars_lm, deflator = "qsec", method = "nonparametric",
 restype = "blus")
goldfeld_quandt(mtcars_lm, deflator = "qsec", prop_central = 0.25, alternative = "two.sided")
goldfeld_quandt(mtcars_lm, deflator = "qsec", method = "nonparametric",
 restype = "blus", alternative = "two.sided")
</code></pre>

<hr>
<h2 id='GSS'>Golden Section Search for Minimising Univariate Function over a Closed
Interval</h2><span id='topic+GSS'></span>

<h3>Description</h3>

<p>Golden Section Search (GSS) is a useful algorithm for minimising a
continuous univariate function <code class="reqn">f(x)</code> over an interval
<code class="reqn">\left[a,b\right]</code> in instances where the first derivative
<code class="reqn">f'(x)</code> is not easily obtainable, such as with loss functions
that need to be minimised under cross-validation to tune a
hyperparameter in a machine learning model. The method is described
by Fox (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSS(f, a, b, tol = 1e-08, maxitgss = 100L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSS_+3A_f">f</code></td>
<td>
<p>A function of one variable that returns a numeric value</p>
</td></tr>
<tr><td><code id="GSS_+3A_a">a</code></td>
<td>
<p>A numeric of length 1 representing the lower endpoint of the
search interval</p>
</td></tr>
<tr><td><code id="GSS_+3A_b">b</code></td>
<td>
<p>A numeric of length 1 representing the upper endpoint of the
search interval; must be greater than <code>a</code></p>
</td></tr>
<tr><td><code id="GSS_+3A_tol">tol</code></td>
<td>
<p>A numeric of length 1 representing the tolerance used to
determine when the search interval has been narrowed sufficiently
for convergence</p>
</td></tr>
<tr><td><code id="GSS_+3A_maxitgss">maxitgss</code></td>
<td>
<p>An integer of length 1 representing the maximum number
of iterations to use in the search</p>
</td></tr>
<tr><td><code id="GSS_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is modelled after a MATLAB function written by
 (). The method assumes that
there is one local minimum in this interval. The solution produced is
also an interval, the width of which can be made arbitrarily small by
setting a tolerance value. Since the desired solution is a single
point, the midpoint of the final interval can be taken as the best
approximation to the solution.
</p>
<p>The premise of the method is to shorten the interval
<code class="reqn">\left[a,b\right]</code> by comparing the values of the function at two
test points, <code class="reqn">x_1 &lt; x_2</code>, where <code class="reqn">x_1 = a + r(b-a)</code> and
<code class="reqn">x_2 = b - r(b-a)</code>, and <code class="reqn">r=(\sqrt{5}-1)/2\approx 0.618</code> is the
reciprocal of the golden ratio. One compares <code class="reqn">f(x_1)</code> to <code class="reqn">f(x_2)</code>
and updates the search interval <code class="reqn">\left[a,b\right]</code> as follows:
</p>

<ul>
<li><p> If <code class="reqn">f(x_1)&lt;f(x_2)</code>, the solution cannot lie in
<code class="reqn">\left[x_2,b\right]</code>;
thus, update the search interval to
</p>
<p style="text-align: center;"><code class="reqn">\left[a_\mathrm{new},b_\mathrm{new}\right]=\left[a,x_2\right]</code>
</p>

</li>
<li><p> If <code class="reqn">f(x_1)&gt;f(x_2)</code>, the solution cannot lie in
<code class="reqn">\left[a,x_1\right]</code>;
thus, update the search interval to
</p>
<p style="text-align: center;"><code class="reqn">\left[a_\mathrm{new},b_\mathrm{new}\right]=\left[x_1,b\right]</code>
</p>

</li></ul>

<p>One then chooses two new test points by replacing <code class="reqn">a</code> and <code class="reqn">b</code> with
<code class="reqn">a_\mathrm{new}</code> and <code class="reqn">b_\mathrm{new}</code> and recalculating <code class="reqn">x_1</code>
and <code class="reqn">x_2</code> based on these new endpoints. One continues iterating in
this fashion until <code class="reqn">b-a&lt; \tau</code>, where <code class="reqn">\tau</code> is the desired
tolerance.
</p>


<h3>Value</h3>

<p>A list object containing the following:
</p>

<ul>
<li> <p><code>argmin</code>, the argument of <code>f</code> that minimises <code>f</code>
</p>
</li>
<li> <p><code>funmin</code>, the minimum value of <code>f</code> achieved at <code>argmin</code>
</p>
</li>
<li> <p><code>converged</code>, a logical indicating whether the convergence tolerance
was satisfied
</p>
</li>
<li> <p><code>iterations</code>, an integer indicating the number of search iterations
used
</p>
</li></ul>



<h3>References</h3>

<p>(????).
<em>Golden Section Method Algorithm, author=Katarzyna Zarnowiec, organization=MATLAB Central File Exchange, url=https://www.mathworks.com/matlabcentral/fileexchange/25919-golden-section-method-algorithm, urldate=2022-10-19, year=2022, </em>.<br /><br /> Fox WP (2021).
<em>Nonlinear Optimization: Models and Applications</em>, 1st edition.
Chapman and Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="cmna.html#topic+goldsect">goldsect</a></code> is similar to this function, but does
not allow the user to pass additional arguments to <code>f</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) (x - 1) ^ 2
GSS(f, a = 0, b = 2)

</code></pre>

<hr>
<h2 id='harrison_mccabe'>Harrison and McCabe's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+harrison_mccabe'></span>

<h3>Description</h3>

<p>This function implements the method of
Harrison and McCabe (1979) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harrison_mccabe(
  mainlm,
  deflator = NA,
  m = 0.5,
  alternative = c("less", "greater", "two.sided"),
  twosidedmethod = c("doubled", "kulinskaya"),
  qfmethod = "imhof",
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harrison_mccabe_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_m">m</code></td>
<td>
<p>Either a <code>double</code> giving the proportion of the <code class="reqn">n</code>
diagonal elements of <code class="reqn">A</code> that are ones, or an <code>integer</code>
giving the index <code class="reqn">m</code> up to which the diagonal elements are ones.
Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_alternative">alternative</code></td>
<td>
<p>A character specifying the form of alternative
hypothesis. If it is suspected that the error variance is positively
associated with the deflator variable, <code>"less"</code>. If it is
suspected that the error variance is negatively associated with deflator
variable, <code>"greater"</code>. If no information is available on the suspected
direction of the association, <code>"two.sided"</code>. Defaults to
<code>"less"</code>.</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_twosidedmethod">twosidedmethod</code></td>
<td>
<p>A character indicating the method to be used to compute
two-sided <code class="reqn">p</code>-values for the parametric test when <code>alternative</code>
is <code>"two.sided"</code>. The argument is passed to
<code><a href="#topic+twosidedpval">twosidedpval</a></code> as its <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_qfmethod">qfmethod</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>, corresponding to the <code>algorithm</code> argument
of <code><a href="#topic+pRQF">pRQF</a></code>. The default is <code>"imhof"</code>.</p>
</td></tr>
<tr><td><code id="harrison_mccabe_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test assumes that heteroskedasticity, if present, is
monotonically related to one of the explanatory variables (known as the
deflator). The OLS residuals <code class="reqn">e</code> are placed in increasing order of
the deflator variable and we let <code class="reqn">A</code> be an <code class="reqn">n\times n</code> selector
matrix whose first <code class="reqn">m</code> diagonal elements are 1 and all other elements
are 0. The alternative hypothesis posits that the error variance changes
around index <code class="reqn">m</code>. Under the null hypothesis of homoskedasticity, the
ratio of quadratic forms <code class="reqn">Q=\frac{e' A e}{e'e}</code> should be close to
<code class="reqn">\frac{m}{n}</code>. Since the test statistic <code class="reqn">Q</code> is a ratio of
quadratic forms in the errors, the Imhof algorithm is used to compute
<code class="reqn">p</code>-values (with normality of errors assumed).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Harrison MJ, McCabe BPM (1979).
&ldquo;A Test for Heteroscedasticity Based on Ordinary Least Squares Residuals.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>74</b>(366), 494&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="lmtest.html#topic+hmctest">lmtest::hmctest</a></code>, another
implementation of the Harrison-McCabe Test. Note that the <code class="reqn">p</code>-values
from that function are simulated rather than computed from the
distribution of a ratio of quadratic forms in normal random vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
harrison_mccabe(mtcars_lm, deflator = "qsec")

</code></pre>

<hr>
<h2 id='harvey'>Harvey Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+harvey'></span>

<h3>Description</h3>

<p>This function implements the method of
Harvey (1976) for testing for &quot;multiplicative&quot;
heteroskedasticity in a linear regression model.
Mittelhammer et al. (2000) gives the
formulation of the test used here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harvey(mainlm, auxdesign = NA, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harvey_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="harvey_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="harvey_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Harvey's Test entails fitting an auxiliary regression model in
which the response variable is the log of the  vector of squared
residuals from the original model and the design matrix <code class="reqn">Z</code>
consists of one or more exogenous variables that are suspected of being
related to the error variance. In the absence of prior information on
a possible choice of <code class="reqn">Z</code>, one would typically use the explanatory
variables from the original model. Under the null hypothesis of
homoskedasticity, the distribution of the test statistic is
asymptotically chi-squared with <code>parameter</code> degrees of freedom.
The test is right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Harvey AC (1976).
&ldquo;Estimating Regression Models with Multiplicative Heteroscedasticity.&rdquo;
<em>Econometrica</em>, <b>44</b>(3), 461&ndash;465.<br /><br /> Mittelhammer RC, Judge GG, Miller DJ (2000).
<em>Econometric Foundations</em>.
Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p>the description of the test in
<a href="http://www.econometrics.com/intro/testhet.htm">SHAZAM</a> software
(which produces identical results).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
harvey(mtcars_lm)
harvey(mtcars_lm, auxdesign = "fitted.values")

</code></pre>

<hr>
<h2 id='hccme'>Heteroskedasticity-Consistent Covariance Matrix Estimators for
Linear Regression Models</h2><span id='topic+hccme'></span>

<h3>Description</h3>

<p>Computes an estimate of the <code class="reqn">n\times n</code> covariance matrix <code class="reqn">\Omega</code>
(assumed to be diagonal) of the random error vector of a linear
regression model, using a specified method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hccme(
  mainlm,
  hcnum = c("3", "0", "1", "2", "4", "5", "6", "7", "4m", "5m", "const"),
  sandwich = FALSE,
  as_matrix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hccme_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="hccme_+3A_hcnum">hcnum</code></td>
<td>
<p>A character corresponding to a subscript in the name of an
HCCME according to the usual nomenclature <code class="reqn">\mathrm{HC\#}</code>.
Possible values are:
</p>

<ul>
<li><p> &quot;3&quot;, the default, corresponding to HC3
(MacKinnon and White 1985)
</p>
</li>
<li><p> &quot;0&quot;, corresponding to HC0 (White 1980)
</p>
</li>
<li><p> &quot;1&quot;, corresponding to HC1 (MacKinnon and White 1985)
</p>
</li>
<li><p> &quot;2&quot;, corresponding to HC1 (MacKinnon and White 1985)
</p>
</li>
<li><p> &quot;4&quot;, corresponding to HC4 (Cribari-Neto 2004)
</p>
</li>
<li><p> &quot;5&quot;, corresponding to HC5 (Cribari-Neto et al. 2007)
</p>
</li>
<li><p> &quot;6&quot;, corresponding to HC6 (Aftab and Chand 2016)
</p>
</li>
<li><p> &quot;7&quot;, corresponding to HC7 (Aftab and Chand 2018)
</p>
</li>
<li><p> &quot;4m&quot;, corresponding to HC4m (Cribari-Neto and da Silva 2011)
</p>
</li>
<li><p> &quot;5m&quot;, corresponding to HC5m (Li et al. 2017)
</p>
</li>
<li><p> &quot;const&quot;, corresponding to the homoskedastic estimator,
<code class="reqn">(n-p)^{-1}\displaystyle\sum_{i=1}^{n}e_i^2</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="hccme_+3A_sandwich">sandwich</code></td>
<td>
<p>A logical, defaulting to <code>FALSE</code>, indicating
whether or not the sandwich estimator
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Cov}{\hat{\beta}}=(X'X)^{-1}X'\hat{\Omega}X(X'X)^{-1}</code>
</p>

<p>should be returned instead of <code class="reqn">\mathrm{Cov}(\epsilon)=\hat{\Omega}</code></p>
</td></tr>
<tr><td><code id="hccme_+3A_as_matrix">as_matrix</code></td>
<td>
<p>A logical, defaulting to <code>TRUE</code>, indicating whether
a covariance matrix estimate should be returned rather
than a vector of variance estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix (if <code>as_matrix</code> is <code>TRUE</code>) or else a
numeric vector
</p>


<h3>References</h3>

<p>Aftab N, Chand S (2016).
&ldquo;A New Heteroskedastic Consistent Covariance Matrix Estimator Using Deviance Measure.&rdquo;
<em>Pakistan Journal of Statistics and Operations Research</em>, <b>12</b>(2), 235&ndash;244.<br /><br /> Aftab N, Chand S (2018).
&ldquo;A Simulation-Based Evidence on the Improved Performance of a New Modified Leverage Adjusted Heteroskedastic Consistent Covariance Matrix Estimator in the Linear Regression Model.&rdquo;
<em>Kuwait Journal of Science</em>, <b>45</b>(3), 29&ndash;38.<br /><br /> Cribari-Neto F (2004).
&ldquo;Asymptotic Inference under Heteroskedasticity of Unknown Form.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>45</b>, 215&ndash;233.<br /><br /> Cribari-Neto F, Souza TC, Vasconcellos KLP (2007).
&ldquo;Inference under Heteroskedasticity and Leveraged Data.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>36</b>(10), 1877&ndash;1888.<br /><br /> Cribari-Neto F, da Silva WB (2011).
&ldquo;A New Heteroskedasticity-Consistent Covariance Matrix Estimator for the Linear Regression Model.&rdquo;
<em>Advances in Statistical Analysis</em>, <b>95</b>(2), 129&ndash;146.<br /><br /> Li S, Zhang N, Zhang X, Wang G (2017).
&ldquo;A New Heteroskedasticity-Consistent Covariance Matrix Estimator and Inference under Heteroskedasticity.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>87</b>(1), 198&ndash;210.<br /><br /> MacKinnon JG, White H (1985).
&ldquo;Some Heteroskedasticity-Consistent Covariance Matrix Estimators with Improved Finite Sample Properties.&rdquo;
<em>Journal of Econometrics</em>, <b>29</b>(3), 305&ndash;325.<br /><br /> White H (1980).
&ldquo;A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity.&rdquo;
<em>Econometrica</em>, <b>48</b>(4), 817&ndash;838.
</p>


<h3>See Also</h3>

<p><code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
Omega_hat &lt;- hccme(mtcars_lm, hcnum = "4")
Cov_beta_hat &lt;- hccme(mtcars_lm, hcnum = "4", sandwich = TRUE)

</code></pre>

<hr>
<h2 id='hetplot'>Graphical Methods for Detecting Heteroskedasticity in a Linear Regression Model</h2><span id='topic+hetplot'></span>

<h3>Description</h3>

<p>This function creates various two-dimensional scatter plots that can aid in
detecting heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetplot(
  mainlm,
  horzvar = "index",
  vertvar = "res",
  vertfun = "identity",
  filetype = NA,
  values = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hetplot_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="hetplot_+3A_horzvar">horzvar</code></td>
<td>
<p>A character vector describing the variable(s) to plot on
horizontal axes (<code>"index"</code> for the data index <code class="reqn">i</code>,
<code>"fitted.values"</code> for the OLS predicted values <code class="reqn">\hat{y}_i</code>,
<code>"fitted.values2"</code> for transformed OLS predicted values
<code class="reqn">m_{ii}\hat{y}_i</code>, and/or <code>names</code> of explanatory variable columns).
<code>"explanatory"</code> passes all explanatory variable columns. <code>"log_"</code>
concatenated with <code>names</code> of explanatory variable columns passes logs
of those explanatory variables. <code>"log_explanatory"</code> passes logs of
all explanatory variables. If more than one variable is specified,
a separate plot is created for each.</p>
</td></tr>
<tr><td><code id="hetplot_+3A_vertvar">vertvar</code></td>
<td>
<p>A character vector describing the variable to plot on the
vertical axis (<code>"res"</code> for OLS residuals [the default],
<code>"res_blus"</code> for <code><a href="#topic+blus">BLUS</a></code> residuals,
<code>"res_stand"</code> for standardised OLS residuals:
<code class="reqn">e_i/\sqrt{\hat{\omega}}</code>, <code>"res_constvar"</code> for OLS residuals
transformed to have constant variance: <code class="reqn">e_i/\sqrt{m_{ii}}</code>,
<code>"res_stud"</code> for studentised OLS residuals:
<code class="reqn">e_i/(s\sqrt{m_{ii}})</code>. If more than one value is specified,
a separate plot is created for each.</p>
</td></tr>
<tr><td><code id="hetplot_+3A_vertfun">vertfun</code></td>
<td>
<p>A character vector giving the name of a function to apply to
the <code>vertvar</code> variable. Values that can be coerced to numeric such
as <code>"2"</code> are taken to be powers to which <code>vertvar</code> should be
set. If multiple values are specified, they are all applied to each
element of <code>vertvar</code>. Common choices might be <code>"identity"</code> (the
default), <code>"abs"</code> (absolute value), and <code>"2"</code> (squaring).</p>
</td></tr>
<tr><td><code id="hetplot_+3A_filetype">filetype</code></td>
<td>
<p>A character giving the type of image file to which the
plot(s) should be written. Values can be <code>"png"</code>,
<code>"bmp"</code>, <code>"jpeg"</code>, or <code>"tiff"</code>. Image files are written
to a subdirectory called &quot;hetplot&quot; within the R session's temporary
directory, which can be located using <code>tempdir()</code>. The files should
be moved or copied to another location if they are needed after the R
session is ended. Default filenames contain timestamps for uniqueness.
If <code>NA</code> (the default), no image files are written, and in this
case, if there are multiple plots, they are plotted on a single device
using the <code>"mfrow"</code> graphical parameter. If many plots are requested
at once, it is advisable to write them to image files.</p>
</td></tr>
<tr><td><code id="hetplot_+3A_values">values</code></td>
<td>
<p>A logical. Should the sequences corresponding to the
horizontal and vertical variable(s) be returned in a <code>list</code> object?</p>
</td></tr>
<tr><td><code id="hetplot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters
(see <code><a href="graphics.html#topic+par">par</a></code>), parameters for <code><a href="graphics.html#topic+plot">plot</a></code>,
for <code><a href="grDevices.html#topic+png">graphics devices</a></code>,
and/or the <code>omit</code> argument for function <code><a href="#topic+blus">blus</a></code>,
if BLUS residuals are being plotted. If it is desired to pass the
<code>type</code> argument to a graphics device, use <code>gtype = </code>, since
a <code>type</code> argument will be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable plotted on the horizontal axis could be the original
data indices, one of the explanatory variables, the OLS predicted
(fitted) values, or any other numeric vector specified by the user. The
variable plotted on the vertical axis is some function of the OLS
residuals or transformed version thereof such as the BLUS residuals
Theil (1968) or standardised or studentised
residuals as discussed in Cook and Weisberg (1983). A
separate plot is created for each (<code>horzvar</code>, <code>vertvar</code>,
<code>vertfun</code>) combination.
</p>


<h3>Value</h3>

<p>A list containing two <code><a href="base.html#topic+data.frame">data frames</a></code>, one
for vectors plotted on horizontal axes and one for vectors plotted
on vertical axes.
</p>


<h3>References</h3>

<p>Cook RD, Weisberg S (1983).
&ldquo;Diagnostics for Heteroscedasticity in Regression.&rdquo;
<em>Biometrika</em>, <b>70</b>(1), 1&ndash;10.<br /><br /> Theil H (1968).
&ldquo;A Simplification of the BLUS Procedure for Analyzing Regression Disturbances.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>63</b>(321), 242&ndash;251.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.lm">plot.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
# Generates 2 x 2 matrix of plots in console
hetplot(mtcars_lm, horzvar = c("index", "fitted.values"),
vertvar = c("res_blus"), vertfun = c("2", "abs"), filetype = NA)

# Generates 84 png files in tempdir() folder
## Not run: hetplot(mainlm = mtcars_lm, horzvar = c("explanatory", "log_explanatory",
"fitted.values2"), vertvar = c("res", "res_stand", "res_stud",
"res_constvar"), vertfun = c("identity", "abs", "2"), filetype = "png")
## End(Not run)

</code></pre>

<hr>
<h2 id='honda'>Honda's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+honda'></span>

<h3>Description</h3>

<p>This function implements the two-sided LM Test of
Honda (1989) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>honda(
  mainlm,
  deflator = NA,
  alternative = c("two.sided", "greater", "less"),
  twosidedmethod = c("doubled", "kulinskaya"),
  qfmethod = "imhof",
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="honda_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="honda_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="honda_+3A_alternative">alternative</code></td>
<td>
<p>A character specifying the form of alternative
hypothesis. If it is suspected that the error variance is positively
associated with the deflator variable, <code>"greater"</code>. If it is
suspected that the error variance is negatively associated with deflator
variable, <code>"less"</code>. If no information is available on the suspected
direction of the association, <code>"two.sided"</code>. Defaults to
<code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="honda_+3A_twosidedmethod">twosidedmethod</code></td>
<td>
<p>A character indicating the method to be used to compute
two-sided <code class="reqn">p</code>-values for the parametric test when <code>alternative</code>
is <code>"two.sided"</code>. The argument is passed to
<code><a href="#topic+twosidedpval">twosidedpval</a></code> as its <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="honda_+3A_qfmethod">qfmethod</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>, corresponding to the <code>algorithm</code> argument
of <code><a href="#topic+pRQF">pRQF</a></code>. The default is <code>"imhof"</code>.</p>
</td></tr>
<tr><td><code id="honda_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test assumes that heteroskedasticity, if present, would be
either of the form <code class="reqn">\omega_i = \omega(1+\theta z_i)</code> or of the
form <code class="reqn">\omega_i = \omega e^{\theta z_i}</code>, where
where <code class="reqn">z_i</code> is a deflator (a nonstochastic variable
suspected of being related to the error variance), <code class="reqn">\omega</code> is
some unknown constant, and <code class="reqn">\theta</code> is an unknown parameter
representing the degree of heteroskedasticity. Since the test
statistic <code class="reqn">Q=\frac{e' A_0 e}{e'e}</code> is a ratio of quadratic forms
in the errors, the Imhof algorithm is used to compute <code class="reqn">p</code>-values.
Since the null distribution is in general asymmetrical, the two-sided
<code class="reqn">p</code>-value is computed using the conditional method of
Kulinskaya (2008), setting <code class="reqn">A=1</code>.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Honda Y (1989).
&ldquo;On the Optimality of Some Tests of the Error Covariance Matrix in the Linear Regression Model.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Statistical Methodology)</em>, <b>51</b>(1), 71&ndash;79.<br /><br /> Kulinskaya E (2008).
&ldquo;On Two-Sided p-Values for Non-Symmetric Distributions.&rdquo;
0810.2124, 0810.2124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
# In this example, only the test statistic is returned, to save time
honda(mtcars_lm, deflator = "qsec", statonly = TRUE)

</code></pre>

<hr>
<h2 id='horn'>Horn's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+horn'></span>

<h3>Description</h3>

<p>This function implements the nonparametric test of
Horn (1981) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horn(
  mainlm,
  deflator = NA,
  restype = c("ols", "blus"),
  alternative = c("two.sided", "greater", "less"),
  exact = (nres &lt;= 10),
  statonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horn_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="horn_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="horn_+3A_restype">restype</code></td>
<td>
<p>A character specifying which residuals to use: <code>"ols"</code>
for OLS residuals (the default) or the <code>"blus"</code> for
<a href="#topic+blus">BLUS</a> residuals. The advantage of using BLUS residuals is
that, under the null hypothesis, the assumption that the random series
is independent and identically distributed is met (whereas with OLS
residuals it is not). The disadvantage of using BLUS residuals is that
only <code class="reqn">n-p</code> residuals are used rather than the full <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="horn_+3A_alternative">alternative</code></td>
<td>
<p>A character specifying the form of alternative
hypothesis; one of <code>"two.sided"</code> (default), <code>"greater"</code>,
or <code>"less"</code>. <code>"two.sided"</code> corresponds to any trend in the
absolute residuals when ordered by <code>deflator</code>. <code>"greater"</code>
corresponds to a negative trend in the absolute residuals when ordered by
<code>deflator</code>. <code>"less"</code> corresponds to a positive trend in the
absolute residuals when ordered by <code>deflator</code>. (Notice that <code class="reqn">D</code>
tends to be small when there is a positive trend.)</p>
</td></tr>
<tr><td><code id="horn_+3A_exact">exact</code></td>
<td>
<p>A logical. Should exact <code class="reqn">p</code>-values be computed? If
<code>FALSE</code>, a normal approximation is used. Defaults to <code>TRUE</code>
only if the number of absolute residuals being ranked is <code class="reqn">\le 10</code>.</p>
</td></tr>
<tr><td><code id="horn_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="horn_+3A_...">...</code></td>
<td>
<p>Optional further arguments to pass to <code><a href="#topic+blus">blus</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test entails specifying a 'deflator', an explanatory variable
suspected of being related to the error variance. Residuals are ordered
by the deflator and the nonparametric trend statistic
<code class="reqn">D=\sum (R_i - i)^2</code> proposed by
Lehmann (1975) is
then computed on the absolute residuals and used to test for an
increasing or decreasing trend, either of which would correspond to
heteroskedasticity. Exact probabilities for the null distribution of
<code class="reqn">D</code> can be obtained from functions <code><a href="#topic+dDtrend">dDtrend</a></code> and
<code><a href="#topic+pDtrend">pDtrend</a></code>, but since computation time increases rapidly with
<code class="reqn">n</code>, use of a normal approximation is recommended for <code class="reqn">n&gt;10</code>.
Lehmann (1975) proves that <code class="reqn">D</code> is
asymptotically normally distributed and the approximation of the
statistic <code class="reqn">Z=(D-E(D))/\sqrt{V(D)}</code> to the standard normal
distribution is already quite good for <code class="reqn">n=11</code>.
</p>
<p>The expectation and variance of <code class="reqn">D</code> (when ties are absent) are
respectively <code class="reqn">E(D)=\frac{n^3-n}{6}</code> and
<code class="reqn">V(D)=\frac{n^2(n+1)^2(n-1)}{36}</code>; see
Lehmann (1975) for <code class="reqn">E(D)</code> and <code class="reqn">V(D)</code>
when ties are present. When ties are absent, a continuity correction
is used to improve the normal approximation. When
exact distribution is used, two-sided <code class="reqn">p</code>-value is computed by
doubling the one-sided <code class="reqn">p</code>-value, since the distribution of <code class="reqn">D</code>
is symmetric. The function does not support the exact distribution of
<code class="reqn">D</code> in the presence of ties, so in this case the normal approximation
is used regardless of <code class="reqn">n</code>.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Horn P (1981).
&ldquo;Heteroscedasticity of Residuals: A Non-Parametric Alternative to the Goldfeld-Quandt Peak Test.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>10</b>(8), 795&ndash;808.<br /><br /> Lehmann EL (1975).
<em>Nonparametrics: Statistical Methods Based on Ranks</em>.
Holden-Day, San Francisco.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
horn(mtcars_lm, deflator = "qsec")
horn(mtcars_lm, deflator = "qsec", restype = "blus")

</code></pre>

<hr>
<h2 id='li_yao'>Li-Yao ALRT and CVT Tests for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+li_yao'></span>

<h3>Description</h3>

<p>This function implements the two methods of
Li and Yao (2019) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>li_yao(mainlm, method = c("cvt", "alrt"), baipanyin = TRUE, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="li_yao_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="li_yao_+3A_method">method</code></td>
<td>
<p>A character indicating which of the two tests derived in
Li and Yao (2019) should be implemented. Possible
values are <code>"alrt"</code> (approximate likelihood-ratio test) and
<code>"cvt"</code> (coefficient-of-variation test). Default is <code>"cvt"</code>.
Partial matching is used.</p>
</td></tr>
<tr><td><code id="li_yao_+3A_baipanyin">baipanyin</code></td>
<td>
<p>A logical. Should the central limit theorem of
Bai et al. (2016) be used to determine the
<code class="reqn">p</code>-value for the coefficient-of-variation test (assuming normally
distributed errors)? If <code>FALSE</code>, the asymptotic null distribution
in Li and Yao (2019) is used, which requires the
assumption that the design variables are random and normally distributed.
This argument is ignored if <code>method</code> is <code>"alrt"</code>.</p>
</td></tr>
<tr><td><code id="li_yao_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two tests are straightforward to implement; in both cases the
test statistic is a function only of the residuals of the linear
regression model. Furthermore, in both cases the test statistic is
asymptotically normally distributed under the null hypothesis of
homoskedasticity. Both tests are right-tailed. These tests are designed
to be especially powerful in high-dimensional regressions, i.e. when the
number of explanatory variables is large.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Bai Z, Pan G, Yin Y (2016).
&ldquo;Homoscedasticity Tests for Both Low and High-Dimensional Fixed Design Regressions.&rdquo;
1603.03830, 1603.03830.<br /><br /> Li Z, Yao J (2019).
&ldquo;Testing for Heteroscedasticity in High-Dimensional Regressions.&rdquo;
<em>Econometrics and Statistics</em>, <b>9</b>, 122&ndash;139.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
li_yao(mtcars_lm, method = "alrt")
li_yao(mtcars_lm, method = "cvt")
li_yao(mtcars_lm, method = "cvt", baipanyin = FALSE)
# Same as first example
li_yao(list("e" = mtcars_lm$residuals), method = "alrt")

</code></pre>

<hr>
<h2 id='pDtrend'>Cumulative distribution function of nonparametric trend statistic <code class="reqn">D</code></h2><span id='topic+pDtrend'></span>

<h3>Description</h3>

<p>This function computes <code class="reqn">\Pr(D \le k)</code> (<code class="reqn">\Pr(D \ge k)</code>), i.e.
lower (upper) cumulative probabilities for
<code class="reqn">D=\sum_{i=1}^{n} (R_i - i)^2</code>, the nonparametric trend statistic
proposed by Lehmann (1975), under the assumption
that the ranks <code class="reqn">R_i</code> are computed on a series of <code class="reqn">n</code> independent and
identically distributed random variables with no ties. The function may be
used to compute one-sided <code class="reqn">p</code>-values for the nonparametric test for
heteroskedasticity of Horn (1981). Computation
time is extremely slow for <code class="reqn">n &gt; 10</code> if <code>usedata</code> is set to
<code>FALSE</code>; thus a normal approximation is implemented, including a
continuity correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pDtrend(
  k,
  n,
  lower.tail = TRUE,
  exact = (n &lt;= 10),
  tiefreq = NA,
  override = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pDtrend_+3A_k">k</code></td>
<td>
<p>An integer of <code>length</code> <code class="reqn">\ge 1</code>
or a character <code>"all"</code> indicating that the cumulative
distribution function should be applied to the entire support of <code class="reqn">D</code>.
The latter is only acceptable when <code>exact</code> is <code>TRUE</code>, since
the distribution is otherwise continuous.</p>
</td></tr>
<tr><td><code id="pDtrend_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of observations in the
series.</p>
</td></tr>
<tr><td><code id="pDtrend_+3A_lower.tail">lower.tail</code></td>
<td>
<p>A logical. Should lower tailed cumulative probability be
calculated? Defaults to <code>TRUE</code>. Note that both lower- and upper-
tailed cumulative probabilities are computed inclusive of <code>k</code>.</p>
</td></tr>
<tr><td><code id="pDtrend_+3A_exact">exact</code></td>
<td>
<p>A logical. Should exact distribution of <code class="reqn">D</code> be used by
calling <code><a href="#topic+dDtrend">dDtrend</a></code>? If <code>FALSE</code>, a normal approximation
is used. If <code>tiefreq</code> is not <code>NA</code> (ties are present),
normal approximation is used regardless of the value of <code>exact</code>.
By default, <code>exact</code> is set to <code>TRUE</code> provided that
<code>n &lt;= 10</code>. Setting <code>exact</code> to <code>TRUE</code> for <code>n &gt; 11</code>
results in an error unless <code>override</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pDtrend_+3A_tiefreq">tiefreq</code></td>
<td>
<p>A double vector corresponding to the value of <code class="reqn">d_i</code>
in Lehmann (1975). These are the frequencies
of the various tied ranks. If ties are absent, <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="pDtrend_+3A_override">override</code></td>
<td>
<p>A logical. By default, the <code>dDtrend</code> function aborts if
<code class="reqn">n &gt; 11</code> due to the prohibitively slow computation (which may cause
some systems to crash). Setting this argument to <code>TRUE</code> overrides
the abort. Ignored unless <code>exact</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double between 0 and 1 representing the probability/ies of <code class="reqn">D</code>
taking on at least (at most) the value(s) in the <code>names</code> attribute.
</p>


<h3>References</h3>

<p>Horn P (1981).
&ldquo;Heteroscedasticity of Residuals: A Non-Parametric Alternative to the Goldfeld-Quandt Peak Test.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>10</b>(8), 795&ndash;808.<br /><br /> Lehmann EL (1975).
<em>Nonparametrics: Statistical Methods Based on Ranks</em>.
Holden-Day, San Francisco.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dDtrend">dDtrend</a></code>, <code><a href="#topic+horn">horn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an independent sample of size 6, the probability that D is &lt;= 50 is
# 0.8222
pDtrend(k = 50, n = 6)
# Normal approximation of the above with continuity correction is
# 0.8145
pDtrend(k = 50, n = 6, exact = FALSE)

</code></pre>

<hr>
<h2 id='ppeak'>Cumulative distribution function of number of peaks in an i.i.d. random sequence</h2><span id='topic+ppeak'></span>

<h3>Description</h3>

<p>This function computes <code class="reqn">\sum_{k} P(n,k)</code>, i.e. the probability that a
sequence of <code class="reqn">n</code> independent and identically distributed random variables
contains <code class="reqn">\ge k</code> <code class="reqn">(\le k)</code> peaks, with peaks as defined in
Goldfeld and Quandt (1965). The function may be used to
compute <code class="reqn">p</code>-values for the Goldfeld-Quandt nonparametric test for
heteroskedasticity in a linear model. Computation time is very slow for
<code class="reqn">n &gt; 170</code> if <code>usedata</code> is set to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppeak(k, n, lower.tail = FALSE, usedata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppeak_+3A_k">k</code></td>
<td>
<p>An integer or a sequence of integers strictly incrementing by 1,
with all values between 0 and <code>n - 1</code> inclusive. Represents the
number of peaks in the sequence.</p>
</td></tr>
<tr><td><code id="ppeak_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of observations in the
sequence.</p>
</td></tr>
<tr><td><code id="ppeak_+3A_lower.tail">lower.tail</code></td>
<td>
<p>A logical. Should lower tailed cumulative probability be
calculated? Defaults to <code>FALSE</code> due to function being designed
primarily for calculating <code class="reqn">p</code>-values for the peaks test, which is
by default an upper-tailed test. Note that both upper and lower tailed
cumulative probabilities are computed inclusive of <code>k</code>.</p>
</td></tr>
<tr><td><code id="ppeak_+3A_usedata">usedata</code></td>
<td>
<p>A logical. Should probability mass function values be
read from <code><a href="#topic+dpeakdat">dpeakdat</a></code> rather than computing them from
<code><a href="#topic+dpeak">dpeak</a></code>? This option will save significantly on
computation time if <code class="reqn">n &lt; 170</code> but is currently only available
for <code class="reqn">n \le 1000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double between 0 and 1 representing the probability of at least
(at most) k peaks occurring in a sequence of <code class="reqn">n</code> independent and
identically distributed continuous random variables. The double has a
<code>names</code> attribute with the values corresponding to the
probabilities.
</p>


<h3>References</h3>

<p>Goldfeld SM, Quandt RE (1965).
&ldquo;Some Tests for Homoscedasticity.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>60</b>(310), 539&ndash;547.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpeak">dpeak</a></code>, <code><a href="#topic+goldfeld_quandt">goldfeld_quandt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an independent sample of size 250, the probability of at least 10
# peaks is 0.02650008
ppeak(k = 10, n = 250, lower.tail = FALSE, usedata = TRUE)
# For an independent sample of size 10, the probability of at most 2 peaks
# is 0.7060615
ppeak(k = 2, n = 10, lower.tail = TRUE, usedata = FALSE)

</code></pre>

<hr>
<h2 id='pRQF'>Probabilities for a Ratio of Quadratic Forms in a Normal Random Vector</h2><span id='topic+pRQF'></span>

<h3>Description</h3>

<p>This function computes cumulative probabilities (lower or upper tail) on a
ratio of quadratic forms in a vector of normally distributed
random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pRQF(
  r,
  A,
  B,
  Sigma = diag(nrow(A)),
  algorithm = c("imhof", "davies", "integrate"),
  lower.tail = TRUE,
  usenames = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pRQF_+3A_r">r</code></td>
<td>
<p>A double representing the value(s) for which <code class="reqn">\Pr(R\le r)</code> or
<code class="reqn">\Pr(R \ge r)</code> should be computed.</p>
</td></tr>
<tr><td><code id="pRQF_+3A_a">A</code></td>
<td>
<p>A numeric, symmetric matrix that is symmetric</p>
</td></tr>
<tr><td><code id="pRQF_+3A_b">B</code></td>
<td>
<p>A numeric, symmetric, non-negative definite matrix having the same
dimensions as <code>A</code>.</p>
</td></tr>
<tr><td><code id="pRQF_+3A_sigma">Sigma</code></td>
<td>
<p>A numeric, symmetric matrix with the same dimensions as
<code>A</code> and <code>B</code>, denoting the covariance matrix of the normal
random vector. Defaults to the identity matrix, corresponding to the case
in which the normal random variables are independent and identically
distributed.</p>
</td></tr>
<tr><td><code id="pRQF_+3A_algorithm">algorithm</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>. Values <code>"imhof"</code> and <code>"integrate"</code>
both implement the Imhof algorithm. The difference is that <code>"imhof"</code>
means that <code><a href="CompQuadForm.html#topic+imhof">imhof</a></code> is used, whereas
<code>"integrate"</code> means that <code><a href="stats.html#topic+integrate">integrate</a></code> is
used (which is slower). The Imhof algorithm is more precise than the
Davies algorithm.</p>
</td></tr>
<tr><td><code id="pRQF_+3A_lower.tail">lower.tail</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the cumulative distribution
function <code class="reqn">\Pr(R \le r)</code> is computed; if <code>FALSE</code>, the survival
function <code class="reqn">\Pr(R \ge r)</code> is computed.</p>
</td></tr>
<tr><td><code id="pRQF_+3A_usenames">usenames</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the function value has a
<code>names</code> attribute corresponding to <code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the work is done by other functions, namely
<code><a href="CompQuadForm.html#topic+imhof">imhof</a></code>, <code><a href="CompQuadForm.html#topic+davies">davies</a></code>,
or <code><a href="stats.html#topic+integrate">integrate</a></code> (depending on the <code>algorithm</code>
argument). It is assumed that the ratio of quadratic forms can be
expressed as
</p>
<p style="text-align: center;"><code class="reqn">R = \displaystyle\frac{x' A x}{x' B x}</code>
</p>
<p> where <code class="reqn">x</code> is an
<code class="reqn">n</code>-dimensional normally distributed random variable with mean vector
<code class="reqn">\mu</code> and covariance matrix <code class="reqn">\Sigma</code>, and <code class="reqn">A</code> and
<code class="reqn">B</code> are real-valued, symmetric <code class="reqn">n\times n</code> matrices. Matrix
<code class="reqn">B</code> must be non-negative definite to ensure that the denominator of
the ratio of quadratic forms is nonzero.
</p>
<p>The function makes use of the fact that a probability statement involving a
ratio of quadratic forms can be rewritten as a probability statement
involving a quadratic form. Hence, methods for computing probabilities
for a quadratic form in normal random variables, such as the Imhof
algorithm (Imhof 1961) or the Davies algorithm
(Davies 1980) can be applied to the rearranged
expression to obtain the probability for the ratio of quadratic forms.
Note that the Ruben-Farebrother algorithm (as implemented in
<code><a href="CompQuadForm.html#topic+farebrother">farebrother</a></code>) cannot be used here because the
<code class="reqn">A</code> matrix within the quadratic form (after rearrangement of the
probability statement involving a ratio of quadratic forms) is not in
general positive semi-definite.
</p>


<h3>Value</h3>

<p>A double denoting the probability/ies corresponding to the value(s)
<code>r</code>.
</p>


<h3>References</h3>

<p>Davies RB (1980).
&ldquo;Algorithm AS 155: The Distribution of a Linear Combination of <code class="reqn">\chi^2</code> Random Variables.&rdquo;
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <b>29</b>, 323&ndash;333.<br /><br /> Imhof JP (1961).
&ldquo;Computing the Distribution of Quadratic Forms in Normal Variables.&rdquo;
<em>Biometrika</em>, <b>48</b>(3/4), 419&ndash;426.
</p>


<h3>See Also</h3>

<p>Duchesne and de Micheaux (2010), the article associated
with the <code><a href="CompQuadForm.html#topic+imhof">imhof</a></code> and
<code><a href="CompQuadForm.html#topic+davies">davies</a></code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
A &lt;- matrix(data = 1, nrow = n, ncol = n)
B &lt;- diag(n)
pRQF(r = 1, A = A, B = B)
pRQF(r = 1, A = A, B = B, algorithm = "integrate")
pRQF(r = 1:3, A = A, B = B, algorithm = "davies")

</code></pre>

<hr>
<h2 id='rackauskas_zuokas'>Rackauskas-Zuokas Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+rackauskas_zuokas'></span>

<h3>Description</h3>

<p>This function implements the two methods of
Rackauskas and Zuokas (2007) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rackauskas_zuokas(
  mainlm,
  alpha = 0,
  pvalmethod = c("data", "sim"),
  R = 2^14,
  m = 2^17,
  sqZ = FALSE,
  seed = 1234,
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rackauskas_zuokas_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_alpha">alpha</code></td>
<td>
<p>A double such that <code class="reqn">0 \le \alpha &lt; 1/2</code>; a hyperparameter
of the test. Defaults to 0.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_pvalmethod">pvalmethod</code></td>
<td>
<p>A character, either <code>"data"</code> or <code>"sim"</code>,
determining which method to use to compute the empirical
<code class="reqn">p</code>-value. If <code>"data"</code>, the dataset <code><a href="#topic+T_alpha">T_alpha</a></code>
consisting of pre-generated Monte Carlo replicates from the
asymptotic null distribution of the test statistic is loaded and used to
compute empirical <code class="reqn">p</code>-value. This is only available for certain
values of <code>alpha</code>, namely <code class="reqn">i/32</code> where <code class="reqn">i=0,1,\ldots,15</code>.
If <code>"sim"</code>, Monte Carlo replicates are generated from the
asymptotic null distribution. Partial matching is used.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_r">R</code></td>
<td>
<p>An integer representing the number of Monte Carlo replicates to
generate, if <code>pvalmethod == "sim"</code>. Ignored if
<code>pvalmethod == "data"</code>.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_m">m</code></td>
<td>
<p>An integer representing the number of standard normal variates to
use when generating the Brownian Bridge for each replicate, if
<code>pvalmethod == "sim"</code>. Ignored if <code>pvalmethod == "data"</code>. If
number of observations is small,
Rackauskas and Zuokas (2007) recommends using <code class="reqn">m=n</code>.
The dataset <code><a href="#topic+T_alpha">T_alpha</a></code> used <code class="reqn">m=2^17</code> which is
computationally intensive.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_sqz">sqZ</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the standard normal variates used
in the Brownian Bridge when generating from the asymptotic null
distribution are first squared, i.e. transformed to <code class="reqn">\chi^2(1)</code>
variates. This is recommended by
Rackauskas and Zuokas (2007) when the number of
observations is small. Ignored if <code>pvalmethod == "data"</code>.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_seed">seed</code></td>
<td>
<p>An integer representing the seed to be used for pseudorandom
number generation when simulating values from the asymptotic null
distribution. This is to provide reproducibility of test results.
Ignored if <code>pvalmethod == "data"</code>. If user does not wish to set
the seed, pass <code>NA</code>.</p>
</td></tr>
<tr><td><code id="rackauskas_zuokas_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rackauskas and Zuokas propose a class of tests that entails
determining the largest weighted difference in variance of estimated
error. The asymptotic behaviour of their test statistic
<code class="reqn">T_{n,\alpha}</code> is studied using the empirical polygonal process
constructed from partial sums of the squared residuals. The test is
right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Rackauskas A, Zuokas D (2007).
&ldquo;New Tests of Heteroskedasticity in Linear Regression Model.&rdquo;
<em>Lithuanian Mathematical Journal</em>, <b>47</b>(3), 248&ndash;265.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
rackauskas_zuokas(mtcars_lm)
rackauskas_zuokas(mtcars_lm, alpha = 7 / 16)

n &lt;- length(mtcars_lm$residuals)
rackauskas_zuokas(mtcars_lm, pvalmethod = "sim", m = n, sqZ = TRUE)


</code></pre>

<hr>
<h2 id='simonoff_tsai'>Simonoff-Tsai Tests for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+simonoff_tsai'></span>

<h3>Description</h3>

<p>This function implements the modified profile likelihood ratio test and
score test of Simonoff and Tsai (1994) for testing
for heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simonoff_tsai(
  mainlm,
  auxdesign = NA,
  method = c("mlr", "score"),
  hetfun = c("mult", "add", "logmult"),
  basetest = c("koenker", "cook_weisberg"),
  bartlett = TRUE,
  optmethod = "Nelder-Mead",
  statonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simonoff_tsai_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_method">method</code></td>
<td>
<p>A character specifying which of the tests proposed in
Simonoff and Tsai (1994) to implement. <code>"mlr"</code>
corresponds to the modified profile likelihood ratio test, and
<code>"score"</code> corresponds to the score test.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_hetfun">hetfun</code></td>
<td>
<p>A character describing the form of <code class="reqn">w(\cdot)</code>, the error
variance function under the heteroskedastic alternative. Possible values
are <code>"mult"</code> (the default), corresponding to
<code class="reqn">w(Z_i,\lambda)=\exp\left\{\sum_{j=1}^{q}\lambda_j Z_{ij}\right\}</code>,
<code>"add"</code>, corresponding to
<code class="reqn">w(Z_i,\lambda)=\left(1+\sum_{j=1}^{q} \lambda_j Z_{ij}\right)^2</code>, and
<code>"logmult"</code>, corresponding to
<code class="reqn">w(Z_i,\lambda)=\exp\left\{\sum_{j=1}^{q}\lambda_j \log Z_{ij}\right\}</code>.
The multiplicative and log-multiplicative cases are considered in
Cook and Weisberg (1983); the additive case is discussed,
<em>inter alia</em>, by Griffiths and Surekha (1986).
Results for the additive and multiplicative models are identical for this
test. Partial matching is used.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_basetest">basetest</code></td>
<td>
<p>A character specifying the base test statistic which is
robustified using the added term described in Details. <code>"koenker"</code>
corresponds to the test statistic produced by <code><a href="#topic+breusch_pagan">breusch_pagan</a></code>
with argument <code>koenker</code> set to <code>TRUE</code>, while
<code>"cook_weisberg"</code> corresponds to the test statistic produced by
<code><a href="#topic+cook_weisberg">cook_weisberg</a></code>. Partial matching is used. This argument is
only used if <code>method</code> is <code>"score"</code>.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_bartlett">bartlett</code></td>
<td>
<p>A logical specifying whether a Bartlett correction should be
made, as per Ferrari et al. (2004), to improve the
fit of the test statistic to the asymptotic null distribution. This
argument is only applicable where <code>method</code> is <code>"mlr"</code>, and is
implemented only where <code>hetfun</code> is <code>"mult"</code> or
<code>"logmult"</code>.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_optmethod">optmethod</code></td>
<td>
<p>A character specifying the optimisation method to use with
<code><a href="stats.html#topic+optim">optim</a></code>, if <code>method</code> is <code>"mlr"</code>. The
default, <code>"Nelder-Mead"</code>, corresponds to the default <code>method</code>
value in <code><a href="stats.html#topic+optim">optim</a></code>. Warnings about Nelder-Mead algorithm
being unreliable for one-dimensional optimization have been suppressed,
since the algorithm does appear to work for the three implemented choices
of <code>hetfun</code>.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simonoff_tsai_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code>, such as
<code>par</code> (initial value of <code class="reqn">\lambda</code>) and <code>maxit</code> (maximum
number of iterations to use in optimisation algorithm), and <code>trace</code>
(to provide detailed output on optimisation algorithm). Default initial
value of <code class="reqn">\lambda</code> is <code>rep(1e-3, q)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Simonoff-Tsai Likelihood Ratio Test involves a modification of
the profile likelihood function so that the nuisance parameter will be
orthogonal to the parameter of interest. The maximum likelihood estimate
of <code class="reqn">\lambda</code> (called <code class="reqn">\delta</code> in
Simonoff and Tsai (1994)) is computed from the modified
profile log-likelihood function using the Nelder-Mead algorithm in
<code><a href="stats.html#topic+optim">optim</a></code>. Under the null hypothesis of
homoskedasticity, the distribution of the test statistic is
asymptotically chi-squared with <code class="reqn">q</code> degrees of freedom. The test is
right-tailed.
</p>
<p>The Simonoff-Tsai Score Test entails adding a term to either the score
statistic of Cook and Weisberg (1983) (a test implemented
in <code><a href="#topic+cook_weisberg">cook_weisberg</a></code>) or to that of
Koenker (1981) (a test implemented in
<code><a href="#topic+breusch_pagan">breusch_pagan</a></code> with argument <code>koenker</code> set to
<code>TRUE</code>), in order to improve the robustness of these respective
tests in the presence of non-normality. This test likewise has a test
statistic that is asymptotically <code class="reqn">\chi^2(q)</code>-distributed and the test
is likewise right-tailed.
</p>
<p>The assumption of underlying both tests is that
<code class="reqn">\mathrm{Cov}(\epsilon)=\omega W</code>, where <code class="reqn">W</code> is
an <code class="reqn">n\times n</code> diagonal matrix with <code class="reqn">i</code>th diagonal element
<code class="reqn">w_i=w(Z_i, \lambda)</code>. Here, <code class="reqn">Z_i</code> is the <code class="reqn">i</code>th row of an
<code class="reqn">n \times q</code> nonstochastic auxiliary design matrix <code class="reqn">Z</code>. Note:
<code class="reqn">Z</code> as defined here does not have a column of ones, but is
concatenated to a column of ones when used in an auxiliary regression.
<code class="reqn">\lambda</code> is a <code class="reqn">q</code>-vector of unknown parameters, and
<code class="reqn">w(\cdot)</code> is a real-valued, twice-differentiable function having the
property that there exists some <code class="reqn">\lambda_0</code> for which
<code class="reqn">w(Z_i,\lambda_0)=0</code> for all <code class="reqn">i=1,2,\ldots,n</code>. Thus, the null
hypothesis of homoskedasticity may be expressed as
<code class="reqn">\lambda=\lambda_0</code>.
</p>
<p>In the score test, the added term in the test statistic is of the form
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^{q} \left(\sum_{i=1}^{n} h_{ii} t_{ij}\right) \tau_j</code>
</p>
<p>,
where <code class="reqn">t_{ij}</code> is the <code class="reqn">(i,j)</code>th element of the Jacobian matrix
<code class="reqn">J</code> evaluated at <code class="reqn">\lambda=\lambda_0</code>:
</p>
<p style="text-align: center;"><code class="reqn">t_{ij}=\left.\frac{\partial w(Z_i, \lambda)}{\partial \lambda_j}\right|_{\lambda=\lambda_0}</code>
</p>
<p>,
and <code class="reqn">\tau=(\bar{J}'\bar{J})^{-1}\bar{J}'d</code>, where <code class="reqn">d</code> is the
<code class="reqn">n</code>-vector whose <code class="reqn">i</code>th element is <code class="reqn">e_i^2\bar{\omega}^{-1}</code>,
<code class="reqn">\bar{\omega}=n^{-1}e'e</code>, and <code class="reqn">\bar{J}=(I_n-1_n 1_n'/n)J</code>.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Cook RD, Weisberg S (1983).
&ldquo;Diagnostics for Heteroscedasticity in Regression.&rdquo;
<em>Biometrika</em>, <b>70</b>(1), 1&ndash;10.<br /><br /> Ferrari SL, Cysneiros AH, Cribari-Neto F (2004).
&ldquo;An Improved Test for Heteroskedasticity Using Adjusted Modified Profile Likelihood Inference.&rdquo;
<em>Journal of Statistical Planning and Inference</em>, <b>124</b>, 423&ndash;437.<br /><br /> Griffiths WE, Surekha K (1986).
&ldquo;A Monte Carlo Evaluation of the Power of Some Tests for Heteroscedasticity.&rdquo;
<em>Journal of Econometrics</em>, <b>31</b>(1), 219&ndash;231.<br /><br /> Koenker R (1981).
&ldquo;A Note on Studentizing a Test for Heteroscedasticity.&rdquo;
<em>Journal of Econometrics</em>, <b>17</b>, 107&ndash;112.<br /><br /> Simonoff JS, Tsai C (1994).
&ldquo;Use of Modified Profile Likelihood for Improved Tests of Constancy of Variance in Regression.&rdquo;
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <b>43</b>(2), 357&ndash;370.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
simonoff_tsai(mtcars_lm, method = "score")
simonoff_tsai(mtcars_lm, method = "score", basetest = "cook_weisberg")
simonoff_tsai(mtcars_lm, method = "mlr")
simonoff_tsai(mtcars_lm, method = "mlr", bartlett = FALSE)
## Not run: simonoff_tsai(mtcars_lm, auxdesign = data.frame(mtcars$wt, mtcars$qsec),
 method = "mlr", hetfun = "logmult")
## End(Not run)

</code></pre>

<hr>
<h2 id='szroeter'>Szroeter's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+szroeter'></span>

<h3>Description</h3>

<p>This function implements the method of
Szroeter (1978) for testing for
heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>szroeter(mainlm, deflator = NA, h = SKH, qfmethod = "imhof", statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="szroeter_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="szroeter_+3A_deflator">deflator</code></td>
<td>
<p>Either a character specifying a column name from the
design matrix of <code>mainlm</code> or an integer giving the index of a
column of the design matrix. This variable is suspected to be
related to the error variance under the alternative hypothesis.
<code>deflator</code> may not correspond to a column of 1's (intercept).
Default <code>NA</code> means the data will be left in its current order
(e.g. in case the existing index is believed to be associated with
error variance).</p>
</td></tr>
<tr><td><code id="szroeter_+3A_h">h</code></td>
<td>
<p>A non-decreasing function taking as its argument the index
<code>i</code> of observations from 1 to <code class="reqn">n</code>. Defaults to <code>SKH</code>,
which is equivalent to <code class="reqn">h(i)=2(1-\cos \frac{\pi i}{n+1})</code>.
The function must be able to take a vector argument of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="szroeter_+3A_qfmethod">qfmethod</code></td>
<td>
<p>A character, either <code>"imhof"</code>, <code>"davies"</code>, or
<code>"integrate"</code>, corresponding to the <code>algorithm</code> argument
of <code><a href="#topic+pRQF">pRQF</a></code>. The default is <code>"imhof"</code>.</p>
</td></tr>
<tr><td><code id="szroeter_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test entails putting the data rows in increasing order of
some specified deflator (e.g., one of the explanatory variables) that
is believed to be related to the error variance by some non-decreasing
function. The test statistic is a ratio of quadratic forms in the OLS
residuals. It is a right-tailed test.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Szroeter J (1978).
&ldquo;A Class of Parametric Tests for Heteroscedasticity in Linear Econometric Models.&rdquo;
<em>Econometrica</em>, <b>46</b>(6), 1311&ndash;1327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
szroeter(mtcars_lm, deflator = "qsec")

</code></pre>

<hr>
<h2 id='T_alpha'>Pseudorandom numbers from Asymptotic Null Distribution of Test Statistic for
Method of Rackauskas and Zuokas (2007)</h2><span id='topic+T_alpha'></span>

<h3>Description</h3>

<p>A matrix of <code class="reqn">2 ^ 14</code> rows and 16 columns. Each column contains
<code class="reqn">2 ^ 14</code> Monte Carlo replicates from the distribution of
<code class="reqn">T_{\alpha}</code> for a particular value of <code class="reqn">\alpha</code>, <code class="reqn">\alpha=i/32</code>,
<code class="reqn">i=0,1,\ldots,15</code>. The values were generated by first generating a
Brownian Bridge using <code class="reqn">m = 2 ^ 17</code> standard normal variates and then
applying Equation (11) from Rackauskas and Zuokas (2007).
It can be used to compute empirical approximate <code class="reqn">p</code>-values for
implementation of the Rackauskas-Zuokas Test for heteroskedasticity. This
is a time-saving measure because, while <code><a href="#topic+rackauskas_zuokas">rackauskas_zuokas</a></code>
contains an option for simulating the <code class="reqn">p</code>-value directly, this would be
computationally intensive for the authors' recommended <code class="reqn">m</code> of
<code class="reqn">2 ^ 17</code>. Passing the argument <code>pvalmethod = "data"</code> to
<code><a href="#topic+rackauskas_zuokas">rackauskas_zuokas</a></code> instructs the function to use the
pre-generated values in this data set to compute the empirical approximate
<code class="reqn">p</code>-value for the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_alpha
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 16384 rows and 16 columns.
</p>

<hr>
<h2 id='twosidedpval'>Computation of Conditional Two-Sided <code class="reqn">p</code>-Values</h2><span id='topic+twosidedpval'></span>

<h3>Description</h3>

<p>Computes the conditional <code class="reqn">p</code>-value <code class="reqn">P_C</code> for a continuous
or discrete test statistic, as defined in
Kulinskaya (2008). This provides a method
for computing a two-sided <code class="reqn">p</code>-value from an asymmetric null
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosidedpval(
  q,
  CDF,
  continuous,
  method = c("doubled", "kulinskaya", "minlikelihood"),
  locpar,
  supportlim = c(-Inf, Inf),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twosidedpval_+3A_q">q</code></td>
<td>
<p>A double representing the quantile, i.e. the observed value of the
test statistic for which a two-sided <code class="reqn">p</code>-value is to be computed</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_cdf">CDF</code></td>
<td>
<p>A function representing the cumulative distribution function of
the test statistic under the null hypothesis, i.e.
<code class="reqn">\Pr(T\le q|\mathrm{H}_0)</code>.</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_continuous">continuous</code></td>
<td>
<p>A logical indicating whether the test statistic is a
continuous (<code>TRUE</code>) or discrete (<code>FALSE</code>) random variable.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_method">method</code></td>
<td>
<p>A character specifying the method to use to calculate
two-sided <code class="reqn">p</code>-value; one of <code>"doubled"</code> (representing
doubling of the one-sided <code class="reqn">p</code>-value),
<code>"kulinskaya"</code> (representing the method of
Kulinskaya (2008)), or <code>"minlikelihood"</code>
(representing the sum of probabilities for values with probability less
than or equal to that of the observed value. Partial matching is used.
Note that the <code>"minlikelihood"</code> method is available only
for discrete distributions.</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_locpar">locpar</code></td>
<td>
<p>a double representing a generic location parameter chosen to
separate the tails of the distribution. Note that if <code>locpar</code>
corresponds to the median of <code>CDF</code>, there is no difference between
the two methods, in the continuous case. If <code>locpar</code> is not specified,
the function attempts to compute the expectation of <code>CDF</code> using
numerical integration and, if successful, uses this as <code>locpar</code>.
However, this may yield unexpected results, especially if <code>CDF</code> is
not one of the cumulative distribution functions of well-known
distributions included in the <code>stats</code> package.</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_supportlim">supportlim</code></td>
<td>
<p>A numeric vector of <code>length</code> 2, giving the minimum
and maximum values in the support of the distribution whose cumulative
distribution function is <code>CDF</code>. This argument is only used if the
distribution is discrete (i.e. if <code>continuous</code> is <code>FALSE</code>) and
if <code>method</code> is <code>"minlikelihood"</code> or <code>locpar</code> is not
specified. If <code>supportlim</code> is not supplied, the function assumes
that the support is <code>-1e6:1e6</code>. Values of <code>-Inf</code> and <code>Inf</code>
may be supplied, but if so, the support is truncated at <code>-1e6</code> and
<code>1e6</code> respectively.</p>
</td></tr>
<tr><td><code id="twosidedpval_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to <code>CDF</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">T</code> be a statistic that, under the null hypothesis, has
cumulative distribution function <code class="reqn">F</code> and probability density or mass
function <code class="reqn">f</code>. Denote by <code class="reqn">A</code> a generic location parameter chosen
to separate the two tails of the distribution. Particular examples
include the mean <code class="reqn">E(T|\mathrm{H}_0)</code>, the mode
<code class="reqn">\arg \sup_{t} f(t)</code>, or the median
<code class="reqn">F^{-1}\left(\frac{1}{2}\right)</code>. Let <code class="reqn">q</code> be the observed value
of <code class="reqn">T</code>.
</p>
<p>In the continuous case, the conditional two-sided <code class="reqn">p</code>-value centered
at <code class="reqn">A</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">P_C^A(q)=\frac{F(q)}{F(A)}1_{q \le A} + \frac{1-F(q)}{1-F(A)}1_{q &gt; A}</code>
</p>

<p>where <code class="reqn">1_{\cdot}</code> is the indicator function. In the discrete case,
<code class="reqn">P_C^A</code> depends on whether <code class="reqn">A</code> is an attainable value within the
support of <code class="reqn">T</code>. If <code class="reqn">A</code> is not attainable, the conditional two-sided
<code class="reqn">p</code>-value centred at <code class="reqn">A</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">P_C^{A}(q)=\frac{\Pr(T\le q)}{\Pr(T&lt;A)}1_{q&lt;A} + \frac{\Pr(T\ge q)}{\Pr(T&gt;A)}1_{q&gt;A}</code>
</p>

<p>If <code class="reqn">A</code> is attainable, the conditional two-sided <code class="reqn">p</code>-value centred
at <code class="reqn">A</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">P_C^{A}(q)=\frac{\Pr(T\le q)}{\Pr(T\le A)/\left(1+\Pr(T=A)\right)} 1_{q&lt;A} +
   1_{q=A}+\frac{\Pr(T\ge q)}{\Pr(T \ge A)/\left(1+\Pr(T=A)\right)} 1_{q&gt;A}</code>
</p>



<h3>Value</h3>

<p>A double.
</p>


<h3>References</h3>

<p>Kulinskaya E (2008).
&ldquo;On Two-Sided p-Values for Non-Symmetric Distributions.&rdquo;
0810.2124, 0810.2124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computation of two-sided p-value for F test for equality of variances
n1 &lt;- 10
n2 &lt;- 20
set.seed(1234)
x1 &lt;- stats::rnorm(n1, mean = 0, sd = 1)
x2 &lt;- stats::rnorm(n2, mean = 0, sd = 3)
# 'Conventional' two-sided p-value obtained by doubling one-sided p-value:
stats::var.test(x1, x2, alternative = "two.sided")$p.value
# This is replicated in `twosidedpval` by setting `method` argument to `"doubled"`
twosidedpval(q = var(x1) / var(x2), CDF = stats::pf, continuous = TRUE,
 method = "doubled", locpar = 1, df1 = n1 - 1, df2 = n2 - 1)
# Conditional two-sided p-value centered at df (mean of chi-squared r.v.):
twosidedpval(q = var(x1) / var(x2), CDF = stats::pf, continuous = TRUE,
 method = "kulinskaya", locpar = 1, df1 = n1 - 1, df2 = n2 - 1)
</code></pre>

<hr>
<h2 id='verbyla'>Verbyla's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+verbyla'></span>

<h3>Description</h3>

<p>This function implements the residual maximum likelihood test of
Verbyla (1993) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbyla(mainlm, auxdesign = NA, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbyla_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="verbyla_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="verbyla_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Verbyla's Test entails fitting a generalised auxiliary regression
model in which the response variable is the vector of standardised
squared residuals <code class="reqn">e_i^2/\hat{\omega}</code> from the original OLS model
and the design matrix is some function of <code class="reqn">Z</code>, an <code class="reqn">n \times q</code>
matrix consisting of <code class="reqn">q</code> exogenous variables, appended to a column of
ones. The test statistic is half the residual sum of squares from this
generalised auxiliary regression. Under the null hypothesis of
homoskedasticity, the distribution of the test statistic is
asymptotically chi-squared with <code class="reqn">q</code> degrees of freedom. The test is
right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Verbyla AP (1993).
&ldquo;Modelling Variance Heterogeneity: Residual Maximum Likelihood and Diagnostics.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Statistical Methodology)</em>, <b>55</b>(2), 493&ndash;508.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
verbyla(mtcars_lm)
verbyla(mtcars_lm, auxdesign = "fitted.values")

</code></pre>

<hr>
<h2 id='white'>White's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+white'></span>

<h3>Description</h3>

<p>This function implements the popular method of
White (1980) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>white(mainlm, interactions = FALSE, statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="white_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="white_+3A_interactions">interactions</code></td>
<td>
<p>A logical. Should two-way interactions between explanatory
variables be included in the auxiliary regression? Defaults to
<code>FALSE</code>, since when interaction terms are present the test is not a
pure test of heteroskedasticity but also of model specification.</p>
</td></tr>
<tr><td><code id="white_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>White's Test entails fitting an auxiliary regression model in which
the response variable is the vector of squared residuals from the
original model and the design matrix includes the original explanatory
variables, their squares, and (optionally) their two-way interactions.
The test statistic is the number of observations multiplied by the
coefficient of determination from the auxiliary regression model:
</p>
<p style="text-align: center;"><code class="reqn">T = n r_{\mathrm{aux}}^2</code>
</p>

<p>White's Test is thus a special case of the method of
Breusch and Pagan (1979). Under the null hypothesis of
homoskedasticity, the distribution of the test statistic is
asymptotically chi-squared with <code>parameter</code> degrees of freedom.
The test is right-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Breusch TS, Pagan AR (1979).
&ldquo;A Simple Test for Heteroscedasticity and Random Coefficient Variation.&rdquo;
<em>Econometrica</em>, <b>47</b>(5), 1287&ndash;1294.<br /><br /> White H (1980).
&ldquo;A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity.&rdquo;
<em>Econometrica</em>, <b>48</b>(4), 817&ndash;838.
</p>


<h3>See Also</h3>

<p>This function should not be confused with
<code><a href="tseries.html#topic+white.test">tseries::white.test</a></code>, which does
<em>not</em> implement the method of
White (1980) for testing for
heteroskedasticity in a linear model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
white(mtcars_lm)
white(mtcars_lm, interactions = TRUE)

</code></pre>

<hr>
<h2 id='wilcox_keselman'>Wilcox and Keselman's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+wilcox_keselman'></span>

<h3>Description</h3>

<p>This function implements the nonparametric test of
Wilcox and Keselman (2006) for testing for heteroskedasticity
in a simple linear regression model, and extends it to the multiple linear
regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcox_keselman(
  mainlm,
  gammapar = 0.2,
  B = 500L,
  p.adjust.method = "none",
  seed = NA,
  rqwarn = FALSE,
  matchWRS = FALSE,
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcox_keselman_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_gammapar">gammapar</code></td>
<td>
<p>A double value between 0 and 0.5 exclusive specifying the
quantile value <code class="reqn">gamma</code>. Defaults to 0.2.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of nonparametric bootstrap samples
to use to estimate standard error(s) of the quantile difference(s).
Defaults to <code>500L</code>.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>A character specifying the family-wise error rate
method to use in adjusting <code class="reqn">p</code>-values (if it is a multiple linear
regression model). The value is passed to <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
By default no adjustment is made.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
reproducibility of bootstrap results. The value <code>NA</code>
results in not setting a seed.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_rqwarn">rqwarn</code></td>
<td>
<p>A logical specifying whether warnings generated by
<code><a href="quantreg.html#topic+rq.fit">rq.fit</a></code> (such as 'Solution may be nonunique')
should be printed (<code>TRUE</code>) or suppressed (<code>FALSE</code>). Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_matchwrs">matchWRS</code></td>
<td>
<p>A logical specifying whether bootstrap samples should be
generated in the exact same manner as in the <code>qhomtv2</code> function in
<a href="https://github.com/nicebread/WRS">WRS</a> package. If <code>TRUE</code>, and
<code>seed</code> is set to <code>2</code> and <code>B</code> to <code>100</code> and
<code>p.adjust.method</code> to <code>"none"</code>, results will
be identical to those of the default settings of <code>qhomtv2</code>.</p>
</td></tr>
<tr><td><code id="wilcox_keselman_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Wilcox RR, Keselman HJ (2006).
&ldquo;Detecting Heteroscedasticity in a Simple Regression Model via Quantile Regression Slopes.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>76</b>(8), 705&ndash;712.
</p>


<h3>See Also</h3>

<p>Rand R. Wilcox's package
<a href="https://github.com/nicebread/WRS">WRS</a> on Github; in particular
the functions <code>qhomt</code> and <code>qhomtv2</code>, which implement this
method for simple and multiple linear regression respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
wilcox_keselman(mtcars_lm)

</code></pre>

<hr>
<h2 id='yuce'>YÃ¼ce's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+yuce'></span>

<h3>Description</h3>

<p>This function implements the two methods of
YÃ¼ce (2008) for testing for heteroskedasticity
in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yuce(mainlm, method = c("A", "B"), statonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yuce_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="yuce_+3A_method">method</code></td>
<td>
<p>A character indicating which of the two tests presented in
YÃ¼ce (2008) should be implemented. Possible
values are <code>"A"</code> (the chi-squared test) and
<code>"B"</code> (the <code class="reqn">t</code>-test). Partial matching is used and the argument
is not case-sensitive.</p>
</td></tr>
<tr><td><code id="yuce_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two tests are straightforward to implement; in both cases the
test statistic is a function only of the residuals of the linear
regression model. The first test statistic has an asymptotic chi-squared
distribution and the second has an asymptotic <code class="reqn">t</code>-distribution. In
both cases the degrees of freedom are <code class="reqn">n-p</code>. The chi-squared test
is right-tailed whereas the <code class="reqn">t</code>-test is two-tailed.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"htest"</code>. If object is
not assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>YÃ¼ce M (2008).
&ldquo;An Asymptotic Test for the Detection of Heteroskedasticity.&rdquo;
<em>Istanbul University Econometrics and Statistics e-Journal</em>, <b>8</b>, 33&ndash;44.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
yuce(mtcars_lm, method = "A")
yuce(mtcars_lm, method = "B")

</code></pre>

<hr>
<h2 id='zhou_etal'>Zhou, Song, and Thompson's Test for Heteroskedasticity in a Linear Regression Model</h2><span id='topic+zhou_etal'></span>

<h3>Description</h3>

<p>This function implements the methods of
Zhou et al. (2015) for testing for
heteroskedasticity in a linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zhou_etal(
  mainlm,
  auxdesign = NA,
  method = c("pooled", "covariate-specific", "hybrid"),
  Bperturbed = 500L,
  seed = 1234,
  statonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zhou_etal_+3A_mainlm">mainlm</code></td>
<td>
<p>Either an object of <code><a href="base.html#topic+class">class</a></code> <code>"lm"</code>
(e.g., generated by <code><a href="stats.html#topic+lm">lm</a></code>), or
a list of two objects: a response vector and a design matrix. The objects
are assumed to be in that order, unless they are given the names
<code>"X"</code>  and <code>"y"</code> to distinguish them. The design matrix passed
in a list must begin with a column of ones if an intercept is to be
included in the linear model. The design matrix passed in a list should
not contain factors, as all columns are treated 'as is'. For tests that
use ordinary least squares residuals, one can also pass a vector of
residuals in the list, which should either be the third object or be
named <code>"e"</code>.</p>
</td></tr>
<tr><td><code id="zhou_etal_+3A_auxdesign">auxdesign</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code> representing an auxiliary design matrix of
containing exogenous variables that (under alternative hypothesis) are
related to error variance, or a character &quot;fitted.values&quot; indicating
that the fitted <code class="reqn">\hat{y}_i</code> values from OLS should be used.
If set to <code>NA</code> (the default), the
design matrix of the original regression model is used. An intercept
is included in the auxiliary regression even if the first column of
<code>auxdesign</code> is not a vector of ones.</p>
</td></tr>
<tr><td><code id="zhou_etal_+3A_method">method</code></td>
<td>
<p>A character specifying which of the three test methods to
implement; one of <code>"pooled"</code>, <code>"covariate-specific"</code>, or
<code>"hybrid"</code> (which combines the other two). Partial matching is
used.</p>
</td></tr>
<tr><td><code id="zhou_etal_+3A_bperturbed">Bperturbed</code></td>
<td>
<p>An integer specifying the number of perturbation samples
to generate when estimating the <code class="reqn">p</code>-value. Defaults to <code>500L</code>.</p>
</td></tr>
<tr><td><code id="zhou_etal_+3A_seed">seed</code></td>
<td>
<p>An integer specifying a seed to pass to
<code><a href="base.html#topic+set.seed">set.seed</a></code> for random number generation. This allows
for reproducibility of perturbation sampling. A value of <code>NA</code>
results in not setting a seed.</p>
</td></tr>
<tr><td><code id="zhou_etal_+3A_statonly">statonly</code></td>
<td>
<p>A logical. If <code>TRUE</code>, only the test statistic value
is returned, instead of an object of <code><a href="base.html#topic+class">class</a></code>
<code>"htest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zhou et al. (2015) The authors propose
three variations based on comparisons between sandwich and model-based
estimators for the variances of individual regression coefficient
esimators. The covariate-specific method computes a test statistic and
<code class="reqn">p</code>-value for each column of the auxiliary design matrix (which is,
by default, the original design matrix with intercept omitted). The
<code class="reqn">p</code>-values undergo a Bonferroni correction to control overall test
size. When the null hypothesis is rejected in this case, it also provides
information about which auxiliary design variable is associated with the
error variance. The pooled method computes a single test statistic and
<code class="reqn">p</code>-value and is thus an omnibus test. The hybrid method returns the
minimum <code class="reqn">p</code>-value between the Bonferroni-corrected covariate-specific
<code class="reqn">p</code>-values and the pooled <code class="reqn">p</code>-value, multiplying it by 2 for a
further Bonferroni correction. The test statistic returned is that
which corresponds to the minimum <code class="reqn">p</code>-value. The covariate-specific
and pooled test statistics have null distributions that are
asymptotically normal with mean 0. However, the variance is intractable
and thus perturbation sampling is used to compute <code class="reqn">p</code>-values
empirically.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> &quot;htest&quot;. If object is not
assigned, its attributes are displayed in the console as a
<code><a href="tibble.html#topic+tibble">tibble</a></code> using <code><a href="broom.html#topic+tidy">tidy</a></code>.
</p>


<h3>References</h3>

<p>Zhou QM, Song PX, Thompson ME (2015).
&ldquo;Profiling Heteroscedasticity in Linear Regression Models.&rdquo;
<em>The Canadian Journal of Statistics</em>, <b>43</b>(3), 358&ndash;377.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_lm &lt;- lm(mpg ~ wt + qsec + am, data = mtcars)
zhou_etal(mtcars_lm, method = "pooled")
zhou_etal(mtcars_lm, method = "covariate-specific")
zhou_etal(mtcars_lm, method = "hybrid")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
