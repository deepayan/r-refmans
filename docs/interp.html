<!DOCTYPE html><html lang="en"><head><title>Help for package interp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {interp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#interp-package'>
<p>Interpolation of data</p></a></li>
<li><a href='#akima'>
<p>Waveform Distortion Data for Bivariate Interpolation</p></a></li>
<li><a href='#akima474'>
<p>Sample data from Akima's Bicubic Spline Interpolation code (TOMS 474)</p></a></li>
<li><a href='#arcs'>
<p>Extract a list of arcs from a triangulation object.</p></a></li>
<li><a href='#area'>
<p>Extract a list of triangle areas from a triangulation object.</p></a></li>
<li><a href='#aspline'>
<p>Univariate Akima interpolation</p></a></li>
<li><a href='#bicubic'>
<p>Bivariate Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bicubic.grid'>
<p>Bicubic Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bilinear'>
<p>Bilinear Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#bilinear.grid'>
<p>Bilinear Interpolation for Data on a Rectangular grid</p></a></li>
<li><a href='#cells'><p> extract info about voronoi cells</p></a></li>
<li><a href='#circles'><p> plot circles</p></a></li>
<li><a href='#circtest'><p> circtest / sample data</p></a></li>
<li><a href='#circum'>
<p>Determine the circumcircle (and some other characteristics) of a triangle</p></a></li>
<li><a href='#circumcircle'>
<p>Determine the circumcircle of a set of points</p></a></li>
<li><a href='#convex.hull'><p>Return the convex hull of a triangulation object</p></a></li>
<li><a href='#franke.data'>
<p>Test datasets from Franke for interpolation of scattered data</p></a></li>
<li><a href='#identify.triSht'><p>Identify points in a triangulation plot</p></a></li>
<li><a href='#interp'>
<p>Interpolation function</p></a></li>
<li><a href='#interp2xyz'><p>From interp() Result, Produce 3-column Matrix</p></a></li>
<li><a href='#interpp'>
<p>Pointwise interpolate irregular gridded data</p></a></li>
<li><a href='#locpoly'>
<p>Local polynomial fit.</p></a></li>
<li><a href='#nearest.neighbours'>
<p>Nearest neighbour structure for a data set</p></a></li>
<li><a href='#neighbours'><p>List of neighbours from a triangulation or voronoi object</p></a></li>
<li><a href='#on'>
<p>Determines if a point is on or left of the vector described by two other points.</p></a></li>
<li><a href='#on.convex.hull'><p>Determines if points are on or in the convex hull of a triangulation object</p></a></li>
<li><a href='#outer.convhull'><p>Version of outer which operates only in a convex hull</p></a></li>
<li><a href='#plot.triSht'><p>Plot a triangulation object</p></a></li>
<li><a href='#plot.voronoi'><p>Plot a voronoi object</p></a></li>
<li><a href='#plot.voronoi.polygons'><p>plots an voronoi.polygons object</p></a></li>
<li><a href='#print.summary.triSht'><p>Print a summary of a triangulation object</p></a></li>
<li><a href='#print.summary.voronoi'><p>Print a summary of a voronoi object</p></a></li>
<li><a href='#print.triSht'><p>Print a triangulation object</p></a></li>
<li><a href='#print.voronoi'><p>Print a voronoi object</p></a></li>
<li><a href='#summary.triSht'><p>Return a summary of a triangulation object</p></a></li>
<li><a href='#summary.voronoi'><p>Return a summary of a voronoi object</p></a></li>
<li><a href='#tri.find'><p>Locate a point in a triangulation</p></a></li>
<li><a href='#tri.mesh'>
<p>Delaunay triangulation</p></a></li>
<li><a href='#triangles'><p>Extract a list of triangles from a triangulation object</p></a></li>
<li><a href='#triSht'><p>A triangulation object</p></a></li>
<li><a href='#triSht2tri'>
<p>Converter to tripack objects</p></a></li>
<li><a href='#tritest'><p> tritest / sample data</p></a></li>
<li><a href='#voronoi'><p>Voronoi object</p></a></li>
<li><a href='#voronoi.area'><p>Calculate area of Voronoi polygons</p></a></li>
<li><a href='#voronoi.findrejectsites'><p>Find the Voronoi sites at the border of the region (to be rejected).</p></a></li>
<li><a href='#voronoi.mosaic'>
<p>Voronoi mosaic</p></a></li>
<li><a href='#voronoi.polygons'><p> extract polygons from a voronoi mosaic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interpolation Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bivariate data interpolation on regular and irregular
  grids, either linear or using splines are the main part of this
  package.  It is intended to provide FOSS replacement functions for
  the ACM licensed akima::interp and tripack::tri.mesh functions.
  Linear interpolation is implemented in 
  interp::interp(..., method="linear"), this corresponds to the call 
  akima::interp(..., linear=TRUE) which is the default setting and 
  covers most of akima::interp use cases in depending packages.  
  A re-implementation of Akimas irregular grid spline
  interpolation (akima::interp(..., linear=FALSE)) is now also
  available via interp::interp(..., method="akima").
  Estimators for partial derivatives are now also available in 
  interp::locpoly(), these are a prerequisite for the spline interpolation.  
  The basic part is a GPLed triangulation algorithm (sweep hull 
  algorithm by David Sinclair) providing the starting point for the
  irregular grid interpolator. As side effect this algorithm is also
  used to provide replacements for almost all functions of the tripack
  package which also suffers from the same ACM license restrictions.  
  All functions are designed to be backward compatible with their 
  akima / tripack counterparts.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.9), deldir</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sp, Deriv, Ryacas, ggplot2, gridExtra, lattice, stringi,
stringr, scatterplot3d, MASS</td>
</tr>
<tr>
<td>Enhances:</td>
<td>RcppEigen</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 16:14:50 UTC; alge</td>
</tr>
<tr>
<td>Author:</td>
<td>Albrecht Gebhardt [aut, cre, cph],
  Roger Bivand [aut],
  David Sinclair [aut, cph] (author of the shull library)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='interp-package'>
Interpolation of data
</h2><span id='topic+interp-package'></span>

<h3>Description</h3>

<p>Interpolation of <code class="reqn">z</code> values given regular or irregular gridded
data sets containing coordinates <code class="reqn">(x_i,y_i)</code> and function values
<code class="reqn">z_i</code> is (will be) available through this package. As this
interpolation is (for the irregular gridded data case) based on
trianglation of the data locations also triangulation functions are
implemented. Moreover the (not yet finished) spline interpolation
needs estimators for partial derivates, these are also made available
to the end user for direct use. 
</p>


<h3>Details</h3>

<p>The interpolation use can be divided by the used method into piecewise
linear (finished in 1_0.27) and spline  (not yet finished) interpolation and by
input and output settings into  gridded and pointwise setups.
</p>


<h3>Note</h3>

<p>This package is a FOSS replacement for the ACM licensed packages
<code>akima</code> and <code>tripack</code>. The function calls are backward
compatible.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>
<p>Maintainer: Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+tri.mesh">tri.mesh</a></code>,
<code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>, <code><a href="#topic+locpoly">locpoly</a></code>
</p>

<hr>
<h2 id='akima'>
Waveform Distortion Data for Bivariate Interpolation
</h2><span id='topic+akima'></span>

<h3>Description</h3>

<p><code>akima</code> is a list with components <code>x</code>, <code>y</code> and <code>z</code> which
represents a smooth surface of <code>z</code> values at selected points
irregularly distributed in the <code>x-y</code> plane.
</p>
<p>The data was taken from a study of waveform distortion in
electronic circuits, described in:
Hiroshi Akima, &quot;A Method of Bivariate Interpolation and
Smooth Surface Fitting Based on Local Procedures&quot;, 
CACM,
Vol. 17, No. 1, January 1974, pp. 18-20.
</p>


<h3>References</h3>

<p>Hiroshi Akima, &quot;A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data
Points&quot;, 
ACM Transactions on Mathematical Software,
Vol. 4, No. 2, June 1978, pp. 148-159.
Copyright 1978, Association for Computing Machinery, Inc.,
reprinted by permission.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rgl)
data(akima)
# data
rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
rgl.bbox()
# bivariate linear interpolation
# interp:
akima.li &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100))
# interp surface:
rgl.surface(akima.li$x,akima.li$y,akima.li$z,color="green",alpha=c(0.5))
# interpp:
akima.p &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)))
# interpp points:
rgl.points(akima.p$x,akima.p$z , akima.p$y,size=4,color="yellow")

# bivariate spline interpolation
# data
rgl.spheres(akima$x,akima$z , akima$y,0.5,color="red")
rgl.bbox()
# bivariate cubic spline interpolation
# interp:
akima.si &lt;- interp(akima$x, akima$y, akima$z, 
                   xo=seq(min(akima$x), max(akima$x), length = 100),
                   yo=seq(min(akima$y), max(akima$y), length = 100),
                   linear = FALSE, extrap = TRUE)
# interp surface:
rgl.surface(akima.si$x,akima.si$y,akima.si$z,color="green",alpha=c(0.5))
# interpp:
akima.sp &lt;- interpp(akima$x, akima$y, akima$z,
                    runif(200,min(akima$x),max(akima$x)),
                    runif(200,min(akima$y),max(akima$y)),
                   linear = FALSE, extrap = TRUE)
# interpp points:
rgl.points(akima.sp$x,akima.sp$z , akima.sp$y,size=4,color="yellow")


## End(Not run)
</code></pre>

<hr>
<h2 id='akima474'>
Sample data from Akima's Bicubic Spline Interpolation code (TOMS 474)
</h2><span id='topic+akima474'></span>

<h3>Description</h3>

<p><code>akima474</code> is a list with vector components <code>x</code>, <code>y</code> and a matrix <code>z</code> which
represents a smooth surface of <code>z</code> values at the points
of a regular grid spanned by the vectors <code>x</code> and <code>y</code>.
</p>


<h3>References</h3>

<p>Hiroshi Akima, Bivariate Interpolation and
Smooth Surface Fitting Based
on Local Procedures [E2], 
Communications of ACM,
Vol. 17, No. 1, January 1974, pp. 26-30
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rgl)
data(akima474)
# data
rgl.spheres(akima474$x,akima474$z , akima474$y,0.5,color="red")
rgl.bbox()
# bivariate linear interpolation
# interp:
akima474.li &lt;- interp(akima474$x, akima474$y, akima474$z, 
                   xo=seq(min(akima474$x), max(akima474$x), length = 100),
                   yo=seq(min(akima474$y), max(akima474$y), length = 100))
# interp surface:
rgl.surface(akima474.li$x,akima474.li$y,akima474.li$z,color="green",alpha=c(0.5))
# interpp:
akima474.p &lt;- interpp(akima474$x, akima474$y, akima474$z,
                    runif(200,min(akima474$x),max(akima474$x)),
                    runif(200,min(akima474$y),max(akima474$y)))
# interpp points:
rgl.points(akima474.p$x,akima474.p$z , akima474.p$y,size=4,color="yellow")

# bivariate spline interpolation
# data
rgl.spheres(akima474$x,akima474$z , akima474$y,0.5,color="red")
rgl.bbox()
# bivariate cubic spline interpolation
# interp:
akima474.si &lt;- interp(akima474$x, akima474$y, akima474$z, 
                   xo=seq(min(akima474$x), max(akima474$x), length = 100),
                   yo=seq(min(akima474$y), max(akima474$y), length = 100),
                   linear = FALSE, extrap = TRUE)
# interp surface:
rgl.surface(akima474.si$x,akima474.si$y,akima474.si$z,color="green",alpha=c(0.5))
# interpp:
akima474.sp &lt;- interpp(akima474$x, akima474$y, akima474$z,
                    runif(200,min(akima474$x),max(akima474$x)),
                    runif(200,min(akima474$y),max(akima474$y)),
                   linear = FALSE, extrap = TRUE)
# interpp points:
rgl.points(akima474.sp$x,akima474.sp$z , akima474.sp$y,size=4,color="yellow")


## End(Not run)
</code></pre>

<hr>
<h2 id='arcs'>
Extract a list of arcs from a triangulation object.
</h2><span id='topic+arcs'></span>

<h3>Description</h3>

<p>This function extracts a list of arcs from a triangulation object
created by <code>tri.mesh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcs(tri.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arcs_+3A_tri.obj">tri.obj</code></td>
<td>

<p>object of class <code><a href="#topic+triSht">triSht</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acesses the <code>arcs</code> component of a triangulation
object returned by <code><a href="#topic+tri.mesh">tri.mesh</a></code> and extracts the arcs
contained in this triangulation. This is e.g. used for plotting.
</p>


<h3>Value</h3>

<p>A matrix with two columns <code>"from"</code> and <code>"to"</code> containing the
indices of points connected by the arc with the corresponding row index.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>, <code><a href="#topic+area">area</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
tr &lt;- tri.mesh(franke$ds3)
arcs(tr)
</code></pre>

<hr>
<h2 id='area'>
Extract a list of triangle areas from a triangulation object.
</h2><span id='topic+area'></span>

<h3>Description</h3>

<p>This function returns a list containing the areas of each triangle of
a  triangulation object created by <code>tri.mesh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area(tri.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="area_+3A_tri.obj">tri.obj</code></td>
<td>

<p>object of class <code><a href="#topic+triSht">triSht</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acesses the <code>cclist</code> component of a triangulation
object returned by <code><a href="#topic+tri.mesh">tri.mesh</a></code> and extracts the areas
of the triangles contained in this triangulation.
</p>


<h3>Value</h3>

<p>A vector containing the area values.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>, <code><a href="#topic+arcs">arcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
tr &lt;- tri.mesh(franke$ds3)
area(tr)
</code></pre>

<hr>
<h2 id='aspline'>
Univariate Akima interpolation
</h2><span id='topic+aspline'></span><span id='topic+aSpline'></span>

<h3>Description</h3>

<p>The function returns a list of points which smoothly
interpolate given data points, similar to a curve drawn by hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspline(x, y = NULL, xout, n = 50, ties = mean, method = "improved",
degree = 3)
aSpline(x, y, xout, method = "improved", degree = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aspline_+3A_x">x</code>, <code id="aspline_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the points to be
interpolated.  Alternatively a single plotting structure can be
specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
<tr><td><code id="aspline_+3A_xout">xout</code></td>
<td>
<p>an optional set of values specifying where interpolation
is to take place.</p>
</td></tr>
<tr><td><code id="aspline_+3A_n">n</code></td>
<td>
<p>If <code>xout</code> is not specified, interpolation takes place at
<code>n</code> equally spaced points spanning the interval [<code>min(x)</code>,
<code>max(x)</code>].</p>
</td></tr>
<tr><td><code id="aspline_+3A_ties">ties</code></td>
<td>
<p>Handling of tied <code>x</code> values.  Either a function
with a single vector argument returning a single number result or
the string <code>"ordered"</code>.</p>
</td></tr>
<tr><td><code id="aspline_+3A_method">method</code></td>
<td>
<p>either <code>"original"</code> method after Akima (1970) or
<code>"improved"</code> method (default) after Akima (1991)</p>
</td></tr>
<tr><td><code id="aspline_+3A_degree">degree</code></td>
<td>
<p>if improved algorithm is selected: degree of the
polynomials for the interpolating function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original algorithm is based on a piecewise function composed of a
set of polynomials, each of degree three, at most, and applicable to
successive interval of the given points. In this method, the slope of
the curve is determined at each given point locally by fitting a third
degree polynomial to four consecutive points. Each polynomial
representing a portion of the curve between a pair of given
points is determined by the coordinates of and the slopes at the
points. The data set is prolonged below and above minimum and maximum
x values to enable estimation of derivatives at the boundary. 
The improved algorithm uses polynomials of degree two and one at the
boundary. Additionally four overlapping  sequences of points are used
for the estimation via a residual based weighting scheme.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>x coordinates of the interpolated data as given by 'xout' or 'n'.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>interpolated y values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>'aspline' is a wrapper call for the underlying Rcpp function 'aSpline'
which could also be called directly with 'x' and 'y' arguments if
'xout' is given and no 'ties' argument is needed.  
</p>
<p>This is a reimplementation of Akimas algorithms (original and improved 
version). It is only based on the original articles. It does not involve 
or resemble the Fortran code associated with those articles. For this 
reason results may differ slightly because different expressions can
result in different numerical errors.
</p>
<p>This code is under GPL in contrast to original Fortran code as
provided in package 'akima'.
</p>
<p>The function arguments are identical to the call in package 'akima',
only the 'method' argument has its default now set to 'improved'.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Thomas Petzold &lt;thomas.petzoldt@tu-dresden.de&gt;
</p>


<h3>References</h3>

<p>Akima, H. (1970) A new method of interpolation
and smooth curve fitting based on local procedures,
J. ACM <b>17</b>(4), 589-602
</p>
<p>Akima, H. (1991) A Method of Univariate Interpolation that Has
the Accuracy of a Third-degree Polynomial. ACM Transactions on
Mathematical Software, <b>17</b>(3), 341-366.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spline">spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## regular spaced data
x &lt;- 1:10
y &lt;- c(rnorm(5), c(1,1,1,1,3))

xnew &lt;- seq(-1, 11, 0.1)
plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
## stats::spline() for comparison
lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")

lines(aspline(x, y, xnew, method="original"), col="red")
lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")

## irregular spaced data
x &lt;- sort(runif(10, max=10))
y &lt;- c(rnorm(5), c(1,1,1,1,3))

xnew &lt;- seq(-1, 11, 0.1)
plot(x, y, ylim=c(-3, 3), xlim=range(xnew))
## stats::spline() for comparison
lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col="blue")

lines(aspline(x, y, xnew, method="original"), col="red")
lines(aspline(x, y, xnew, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, xnew, method="improved", degree=10), col="green", lty="dashed")

## an example of Akima, 1991
x &lt;- c(-3, -2, -1, 0,  1,  2, 2.5, 3)
y &lt;- c( 0,  0,  0, 0, -1, -1, 0,   2)

plot(x, y, ylim=c(-3, 3))
## stats::spline() for comparison
lines(spline(x, y, n=200), col="blue")

lines(aspline(x, y, n=200, method="original"), col="red")
lines(aspline(x, y, n=200, method="improved"), col="black", lty="dotted")
lines(aspline(x, y, n=200, method="improved", degree=10), col="green", lty="dashed")
</code></pre>

<hr>
<h2 id='bicubic'>
Bivariate Interpolation for Data on a Rectangular grid
</h2><span id='topic+bicubic'></span>

<h3>Description</h3>

<p>This is a placeholder function for backward compatibility with packaga akima.
</p>
<p>In its current state it simply calls the reimplemented Akima algorithm for
irregular grids applied to the regular gridded data given.
</p>
<p>Later a reimplementation of the original algorithm for regular grids may follow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicubic(x, y, z, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicubic_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_x0">x0</code></td>
<td>

<p>vector of <code>x</code> coordinates used to interpolate at.
</p>
</td></tr>
<tr><td><code id="bicubic_+3A_y0">y0</code></td>
<td>

<p>vector of <code>y</code> coordinates used to interpolate at.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a call wrapper for backward compatibility with package akima.
</p>
<p>Currently it applies Akimas irregular grid splines to regular grids, later 
a FOSS reimplementation of his regular grid splines may replace this wrapper.
</p>


<h3>Value</h3>

<p>This function produces a list of interpolated points:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector of interpolated data <code>z</code>.</p>
</td></tr>
</table>
<p>If you need an output grid, see <code><a href="#topic+bicubic.grid">bicubic.grid</a></code>.
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+interp">interp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Akima, H. (1996) Rectangular-Grid-Data
Surface Fitting that Has the Accuracy of a
Bicubic Polynomial,
J. ACM <b>22</b>(3), 357-361
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bicubic.grid">bicubic.grid</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima474)
# interpolate at the diagonal of the grid [0,8]x[0,10]
akima.bic &lt;- bicubic(akima474$x,akima474$y,akima474$z,
                     seq(0,8,length=50), seq(0,10,length=50))
plot(sqrt(akima.bic$x^2+akima.bic$y^2), akima.bic$z, type="l")

</code></pre>

<hr>
<h2 id='bicubic.grid'>
Bicubic Interpolation for Data on a Rectangular grid
</h2><span id='topic+bicubic.grid'></span>

<h3>Description</h3>

<p>This is a placeholder function for backward compatibility with packaga akima.
</p>
<p>In its current state it simply calls the reimplemented Akima algorithm for
irregular grids applied to the regular gridded data given.
</p>
<p>Later a reimplementation of the original algorithm for regular grids may follow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicubic.grid(x,y,z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),
             nx=40,ny=40,dx=NULL,dy=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicubic.grid_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_xlim">xlim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range <code>x</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_ylim">ylim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range of <code>y</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_nx">nx</code></td>
<td>

<p>output grid dimension in <code>x</code> direction.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_ny">ny</code></td>
<td>

<p>output grid dimension in <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_dx">dx</code></td>
<td>

<p>output grid spacing in <code>x</code> direction, not used by default,
overrides <code>nx</code> if specified.
</p>
</td></tr>
<tr><td><code id="bicubic.grid_+3A_dy">dy</code></td>
<td>

<p>output grid spacing in <code>y</code> direction, not used by default,
overrides <code>ny</code> if specified..
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a call wrapper for backward compatibility with package akima.
</p>
<p>Currently it applies Akimas irregular grid splines to regular grids, later 
a FOSS reimplementation of his regular grid splines may replace this wrapper.
</p>


<h3>Value</h3>

<p>This function produces a grid of interpolated points, feasible to be
used directly with <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of interpolated data for the output grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+interp">interp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Akima, H. (1996) Rectangular-Grid-Data
Surface Fitting that Has the Accuracy of a
Bicubic Polynomial,
J. ACM <b>22</b>(3), 357-361
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bicubic">bicubic</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima474)
# interpolate at a grid [0,8]x[0,10]
akima.bic &lt;- bicubic.grid(akima474$x,akima474$y,akima474$z)
zmin &lt;- min(akima.bic$z, na.rm=TRUE)
zmax &lt;- max(akima.bic$z, na.rm=TRUE)
breaks &lt;- pretty(c(zmin,zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
image(akima.bic, breaks=breaks, col=colors)
contour(akima.bic, levels=breaks,  add=TRUE)
</code></pre>

<hr>
<h2 id='bilinear'>
Bilinear Interpolation for Data on a Rectangular grid
</h2><span id='topic+bilinear'></span><span id='topic+BiLinear'></span>

<h3>Description</h3>

<p>This is an implementation of a bilinear interpolating function.
</p>
<p>For a point (x0,y0) contained in a rectangle (x1,y1),(x2,y1),
(x2,y2),(x1,y2) and x1&lt;x2, y1&lt;y2, the first step is to get z()
at locations (x0,y1) and (x0,y2) as convex linear combinations
z(x0,y*)=a*z(x1,y*)+(1-a)*z(x2,y*) where a=(x2-x1)/(x0-x1) for
y*=y1,y2. In a second step z(x0,y0) is calculated as convex linear
combination between z(x0,y1) and z(x0,y2) as
z(x0,y1)=b*z(x0,y1)+(1-b)*z(x0,y2)  where b=(y2-y1)/(y0-y1).
</p>
<p>Finally, z(x0,y0) is a convex linear combination of the z values at
the corners of the containing  rectangle with weights according to
the distance from (x0,y0) to these corners.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear(x, y, z, x0, y0)
BiLinear(x, y, z, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilinear_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_x0">x0</code></td>
<td>

<p>vector of <code>x</code> coordinates used to interpolate at.
</p>
</td></tr>
<tr><td><code id="bilinear_+3A_y0">y0</code></td>
<td>

<p>vector of <code>y</code> coordinates used to interpolate at.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces a list of interpolated points:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector of interpolated data <code>z</code>.</p>
</td></tr>
</table>
<p>If you need an output grid, see <code><a href="#topic+bilinear.grid">bilinear.grid</a></code>.
</p>


<h3>Note</h3>

<p>This Fortran function was part of the akima package but not related to 
any of Akimas algorithms and under GPL. So it could be transfered
into the interp package without changes.
</p>
<p><code>BiLinear</code> is a C++ reimplementation, maybe it will replace the Fortran 
implementation later, so
its name may change in futrure versions.
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+interpp">interpp</a></code> for the general case of irregular gridded data!
</p>


<h3>References</h3>

<p>Pascal Getreuer,
Linear Methods for Image Interpolation,
Image Processing On Line, 2011,
http://www.ipol.im/pub/art/2011/g_lmii/article.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>, <code><a href="#topic+bilinear.grid">bilinear.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima474)
# interpolate at the diagonal of the grid [0,8]x[0,10]
akima.bil &lt;- bilinear(akima474$x,akima474$y,akima474$z,
                     seq(0,8,length=50), seq(0,10,length=50))
plot(sqrt(akima.bil$x^2+akima.bil$y^2), akima.bil$z, type="l")
</code></pre>

<hr>
<h2 id='bilinear.grid'>
Bilinear Interpolation for Data on a Rectangular grid
</h2><span id='topic+bilinear.grid'></span><span id='topic+BiLinear.grid'></span>

<h3>Description</h3>

<p>This is an implementation of a bilinear interpolating function.
</p>
<p>For a point (x0,y0) contained in a rectangle (x1,y1),(x2,y1),
(x2,y2),(x1,y2) and x1&lt;x2, y1&lt;y2, the first step is to get z()
at locations (x0,y1) and (x0,y2) as convex linear combinations
z(x0,y*)=a*z(x1,y*)+(1-a)*z(x2,y*) where a=(x2-x1)/(x0-x1) for
y*=y1,y2. In a second step z(x0,y0) is calculated as convex linear
combination between z(x0,y1) and z(x0,y2) as
z(x0,y1)=b*z(x0,y1)+(1-b)*z(x0,y2)  where b=(y2-y1)/(y0-y1).
</p>
<p>Finally, z(x0,y0) is a convex linear combination of the z values at
the corners of the containing  rectangle with weights according to
the distance from (x0,y0) to these corners.
</p>
<p>The grid lines can be unevenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear.grid(x,y,z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),
                         nx=40,ny=40,dx=NULL,dy=NULL)
BiLinear.grid(x,y,z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),
                         nx=40,ny=40,dx=NULL,dy=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilinear.grid_+3A_x">x</code></td>
<td>

<p>a vector containing the <code>x</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_y">y</code></td>
<td>

<p>a vector containing the <code>y</code> coordinates of the rectangular data grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_z">z</code></td>
<td>

<p>a matrix containing the <code>z[i,j]</code> data values for the grid points (<code>x[i]</code>,<code>y[j]</code>).
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_xlim">xlim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range <code>x</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_ylim">ylim</code></td>
<td>

<p>vector of length 2 giving lower and upper limit for range of <code>y</code>
coordinates used for  output grid.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_nx">nx</code></td>
<td>

<p>output grid dimension in <code>x</code> direction.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_ny">ny</code></td>
<td>

<p>output grid dimension in <code>y</code> direction.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_dx">dx</code></td>
<td>

<p>output grid spacing in <code>x</code> direction, not used by default,
overrides <code>nx</code> if specified.
</p>
</td></tr>
<tr><td><code id="bilinear.grid_+3A_dy">dy</code></td>
<td>

<p>output grid spacing in <code>y</code> direction, not used by default,
overrides <code>ny</code> if specified..
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces a grid of interpolated points, feasible to be
used directly with <code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of <code>x</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector of <code>y</code> coordinates of the output grid.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of interpolated data for the output grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This Fortran function was part of the akima package but not related to 
any of Akimas algorithms and under GPL. So it could be transfered
into the interp package without changes.
</p>
<p><code>BiLinear.grid</code> is a C++ reimplementation, maybe this will replace the 
Fortran implementation later. So its name may change in future versions, dont
rely on it currently.
</p>


<h3>References</h3>

<p>Pascal Getreuer,
Linear Methods for Image Interpolation,
Image Processing On Line, 2011,
http://www.ipol.im/pub/art/2011/g_lmii/article.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima474)
# interpolate at a grid [0,8]x[0,10]
akima.bil &lt;- bilinear.grid(akima474$x,akima474$y,akima474$z)
zmin &lt;- min(akima.bil$z, na.rm=TRUE)
zmax &lt;- max(akima.bil$z, na.rm=TRUE)
breaks &lt;- pretty(c(zmin,zmax),10)
colors &lt;- heat.colors(length(breaks)-1)
image(akima.bil, breaks=breaks, col=colors)
contour(akima.bil, levels=breaks, add=TRUE)
</code></pre>

<hr>
<h2 id='cells'> extract info about voronoi cells </h2><span id='topic+cells'></span>

<h3>Description</h3>

<p>This function returns some info about the cells of a voronoi mosaic,
including the coordinates of the vertices and the cell area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cells(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cells_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p> object of class <code>voronoi</code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the neighbourhood relations between the
underlying triangulation and translates it into the neighbourhood
relations between the voronoi cells.
</p>


<h3>Value</h3>

<p>retruns a list of lists, one entry for each voronoi cell which contains
</p>
<table role = "presentation">
<tr><td><code>cell</code></td>
<td>
<p>cell index</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>cell 'center'</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>neighbour cell indices</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>2 times <code>nnb</code> matrix with vertice coordinates</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>cell area</p>
</td></tr>
</table>


<h3>Note</h3>

<p> outer cells have <code>area=NA</code>, currently also <code>nodes=NA</code>
which is not really useful &ndash; to be done later </p>


<h3>Author(s)</h3>

<p> A. Gebhardt </p>


<h3>See Also</h3>

  <p><code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,  <code><a href="#topic+voronoi.area">voronoi.area</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.vm &lt;- voronoi.mosaic(tritest$x,tritest$y)
tritest.cells &lt;- cells(tritest.vm)
# higlight cell 12:
plot(tritest.vm)
polygon(t(tritest.cells[[12]]$nodes),col="green")
# put cell area into cell center:
text(tritest.cells[[12]]$center[1],
     tritest.cells[[12]]$center[2],
     tritest.cells[[12]]$area)
</code></pre>

<hr>
<h2 id='circles'> plot circles </h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>This function plots circles at given locations with given radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles(x, y, r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circles_+3A_x">x</code></td>
<td>
<p> vector of x coordinates </p>
</td></tr>
<tr><td><code id="circles_+3A_y">y</code></td>
<td>
<p> vector of y coordinates </p>
</td></tr>
<tr><td><code id="circles_+3A_r">r</code></td>
<td>
<p> vactor of radii </p>
</td></tr>
<tr><td><code id="circles_+3A_...">...</code></td>
<td>
<p> additional graphic parameters will be passed through </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function needs a previous plot where it adds the circles.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

  <p><code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(10)
y&lt;-rnorm(10)
r&lt;-runif(10,0,0.5)
plot(x,y, xlim=c(-3,3), ylim=c(-3,3), pch="+")
circles(x,y,r)
</code></pre>

<hr>
<h2 id='circtest'> circtest / sample data </h2><span id='topic+circtest'></span><span id='topic+circtest2'></span>

<h3>Description</h3>

<p>Sample data for the <code>link{circumcircle}</code> function.
</p>
<p><code>circtest2</code> are points sampled from a circle with some jitter
added, i.e. they represent the most complicated case for the
<code>link{circumcircle}</code> function.
</p>

<hr>
<h2 id='circum'>
Determine the circumcircle (and some other characteristics) of a triangle
</h2><span id='topic+circum'></span>

<h3>Description</h3>

<p>This function returns the circumcircle of a triangle and some additonal
values used to determine them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circum(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circum_+3A_x">x</code></td>
<td>
<p>Vector of three elements, giving the x coordinatres of the
triangle nodes.
</p>
</td></tr>
<tr><td><code id="circum_+3A_y">y</code></td>
<td>
<p>Vector of three elements, giving the y coordinatres of the
triangle nodes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the Fortran function CIRCUM found in TRIPACK.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p> 'x' coordinate of center</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> 'y' coordinate of center</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p> circumcircle radius </p>
</td></tr>
<tr><td><code>signed.area</code></td>
<td>
<p> signed area of riangle (positive iff nodes are
numbered counter clock wise) </p>
</td></tr>
<tr><td><code>aspect.ratio</code></td>
<td>
<p> ratio &quot;radius of inscribed circle&quot;/&quot;radius of
circumcircle&quot;, varies between 0 and 0.5
</p>
<p>0 means collinear points, 0.5 equilateral trangle.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is mainly intended to be used by <code><a href="#topic+circumcircle">circumcircle</a></code>.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt
</p>


<h3>References</h3>

<p>https://math.fandom.com/wiki/Circumscribed_circle#Coordinates_of_circumcenter, visited march 2022.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circumcircle">circumcircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circum(c(0,1,0),c(0,0,1))

tr &lt;- list()
tr$t1 &lt;-list(x=c(0,1,0),y=c(0,0,1))
tr$t2 &lt;-list(x=c(0.5,0.9,0.7),y=c(0.2,0.9,1))
tr$t3 &lt;-list(x=c(0.05,0,0.3),y=c(0.2,0.7,0.1))
plot(0,0,type="n",xlim=c(-0.5,1.5),ylim=c(-0.5,1.5))
for(i in 1:3){
    x &lt;- tr[[i]]$x
    y &lt;- tr[[i]]$y
    points(x,y,pch=c("1","2","3"),xlim=c(-0.5,1.5),ylim=c(-0.5,1.5))
    cc =circum(x,y)
    lines(c(x,x[1]),c(y,y[1]))
    points(cc$x,cc$y)
    if(cc$signed.area&lt;0)
      circles(cc$x,cc$y,cc$radius,col="blue",lty="dotted")
    else
      circles(cc$x,cc$y,cc$radius,col="red",lty="dotted")
}
</code></pre>

<hr>
<h2 id='circumcircle'>
Determine the circumcircle of a set of points
</h2><span id='topic+circumcircle'></span>

<h3>Description</h3>

<p>This function returns the (smallest) circumcircle of a set of n points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcircle(x, y = NULL, num.touch=2, plot = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circumcircle_+3A_x">x</code></td>
<td>
<p>vector containing x coordinates of the data. If <code>y</code> is missing
<code>x</code> should contain two elements <code>$x</code> and <code>$y</code>.
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_y">y</code></td>
<td>
<p>vector containing y coordinates of the data.
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_num.touch">num.touch</code></td>
<td>

<p>How often should the resulting circle touch the convex hull of the
given points?
</p>
<p>default: 2
</p>
<p>possible values: 2 or 3
</p>
<p>Note: The circumcircle of a triangle is usually defined to touch
at 3 points, this function searches by default the minimum circle,
which may be only touching at 2 points. Set parameter
<code>num.touch</code> accordingly if you dont want the default behaviour!
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_plot">plot</code></td>
<td>
<p>Logical, produce a simple plot of the result.
</p>
<p>default: <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="circumcircle_+3A_debug">debug</code></td>
<td>
<p>Logical, more plots, only needed for debugging.
</p>
<p>default: <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a (naive implemented) algorithm which determines the smallest
circumcircle of n points:
</p>
<p>First step: Take the convex hull.
</p>
<p>Second step: Determine two points on the convex hull with maximum
distance for the diameter of the set.
</p>
<p>Third step: Check if the circumcircle of these two points already
contains all other points (of the convex hull and hence all other points).
</p>
<p>If not or if 3 or more touching points are desired
(<code>num.touch=3</code>), 
search a point with minimum enclosing circumcircle among the
remaining points of the convex hull.
</p>
<p>If such a point cannot be found (e.g. for <code>data(circtest2)</code>),
search the remaining triangle combinations of points from the convex
hull until an enclosing circle with minimum radius is found.
</p>
<p>The last search uses an upper and lower bound for the desired miniumum
radius:
</p>
<p>Any enclosing rectangle and its circumcircle gives an upper bound (the
axis-parallel rectangle is used).
</p>
<p>Half the diameter of the set from step 1 is a lower bound.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>'x' coordinate of circumcircle center</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>'y' coordinate of circumcircle center</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>radius of circumcircle</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(circtest)
 # smallest circle:
 circumcircle(circtest,num.touch=2,plot=TRUE)

 # smallest circle with maximum touching points (3):
 circumcircle(circtest,num.touch=3,plot=TRUE)

 # some stress test for this function,
 data(circtest2)
 # circtest2 was generated by:
 # 100 random points almost one a circle:
 # alpha &lt;- runif(100,0,2*pi)
 # x &lt;- cos(alpha)
 # y &lt;- sin(alpha)
 # circtest2&lt;-list(x=cos(alpha)+runif(100,0,0.1),
 #                 y=sin(alpha)+runif(100,0,0.1))
 #  
 circumcircle(circtest2,plot=TRUE)

</code></pre>

<hr>
<h2 id='convex.hull'>Return the convex hull of a triangulation object</h2><span id='topic+convex.hull'></span><span id='topic+ConvexHull'></span>

<h3>Description</h3>

<p>Given a triangulation <code>tri.obj</code> of <code class="reqn">n</code> points in the plane, this
subroutine returns two vectors containing the coordinates
of the nodes on the boundary of the convex hull.
</p>
<p><code>ConvexHull</code> is an experimental C++ implementation of Grahams Scan
without previous triangulation, should be much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex.hull(tri.obj, plot.it=FALSE, add=FALSE,...)
       ConvexHull(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convex.hull_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code><a href="#topic+triSht">triSht</a></code></p>
</td></tr>
<tr><td><code id="convex.hull_+3A_plot.it">plot.it</code></td>
<td>
<p>logical, if <code>TRUE</code> the convex hull of
<code>tri.obj</code> will be plotted.</p>
</td></tr>
<tr><td><code id="convex.hull_+3A_add">add</code></td>
<td>
<p>logical. if <code>TRUE</code> (and <code>plot.it=TRUE</code>), add to
a current plot.</p>
</td></tr>
<tr><td><code id="convex.hull_+3A_...">...</code></td>
<td>
<p>additional plot arguments</p>
</td></tr>
<tr><td><code id="convex.hull_+3A_x">x</code></td>
<td>
<p>only for <code>ConvexHull()</code>: <code>x</code> coordinates for C++ call to <code>ConvexHull</code></p>
</td></tr>
<tr><td><code id="convex.hull_+3A_y">y</code></td>
<td>
<p>only for <code>ConvexHull()</code>: see <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>x coordinates of boundary nodes.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y coordinates of boundary nodes.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In case that there are several collinear nodes on the convex hull
<code>convex.hull</code> will return them all while <code>ConvexHull</code> will only
give edge points.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>,
<code><a href="#topic+plot.triSht">plot.triSht</a></code>, <code><a href="#topic+summary.triSht">summary.triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## random points:
rand.tr&lt;-tri.mesh(runif(10),runif(10))
plot(rand.tr)
rand.ch&lt;-convex.hull(rand.tr, plot.it=TRUE, add=TRUE, col="red")
## use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-17 &amp; quakes[,1]&gt;=-19.0 &amp;
                     quakes[,2]&lt;=182.0 &amp; quakes[,2]&gt;=180.0),]
quakes.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
plot(quakes.tri)
convex.hull(quakes.tri, plot.it=TRUE, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='franke.data'>
Test datasets from Franke for interpolation of scattered data
</h2><span id='topic+franke.data'></span><span id='topic+franke.fn'></span><span id='topic+franke'></span>

<h3>Description</h3>

<p><code>franke.data</code> generates the test datasets from Franke, 1979, see references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>franke.data(fn = 1, ds = 1, data)
franke.fn(x, y, fn = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="franke.data_+3A_fn">fn</code></td>
<td>

<p>function number, from 1 to 5.
</p>
</td></tr>
<tr><td><code id="franke.data_+3A_x">x</code></td>
<td>
<p>'x' value</p>
</td></tr>
<tr><td><code id="franke.data_+3A_y">y</code></td>
<td>
<p>'y' value</p>
</td></tr>
<tr><td><code id="franke.data_+3A_ds">ds</code></td>
<td>

<p>data set number, from 1 to 3. Dataset 1 consists of 100 points,
dataset 2 of 33 points and dataset 3 of 25 points scattered in the
square <code class="reqn">[0,1]\times[0,1]</code>. (and partially slightly
outside).
</p>
</td></tr>
<tr><td><code id="franke.data_+3A_data">data</code></td>
<td>

<p>A list of dataframes with 'x' and 'y' to choose from, dataset
<code>franke</code> should be used here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These datasets are mentioned in Akima, (1996) as a testbed for the
irregular scattered data interpolator.
</p>
<p>Franke used the five functions:
</p>
<p style="text-align: center;"><code class="reqn">0.75e^{-\frac{(9x-2)^2+(9y-2)^2}{4}}+
    0.75e^{-\frac{(9x+1)^2}{49}-\frac{9y+1}{10}}+
    0.5e^{-\frac{(9x-7)^2+(9y-3)^2}{4}}-
      0.2e^{-((9x-4)^2-(9y-7)^2)}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{\mbox{tanh}(9y-9x)+1}{9}</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{1.25+\cos(5.4y)}{6(1+(3x-1)^2)}</code>
</p>

<p style="text-align: center;"><code class="reqn">e^{-\frac{81((x-0.5)^2+\frac{(y-0.5)^2}{16})}{3}}</code>
</p>

<p style="text-align: center;"><code class="reqn">e^{-\frac{81((x-0.5)^2+\frac{(y-0.5)^2}{4})}{3}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{\sqrt{64-81((x-0.5)^2+(y-0.5)^2)}}{9}-0.5</code>
</p>

<p>and evaluated them on different more or less dense grids over <code class="reqn">[0,1]\times[0,1]</code>.
</p>


<h3>Value</h3>

<p>A data frame with components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>'x' coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>'y' coordinate</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>'z' value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The datasets have to be generated via <code>franke.data</code> before
use, the dataset <code>franke</code> only contains a list of 3 dataframes of
'x' and 'y' coordinates for the above mentioned irregular grids.
Do not forget to load the <code>franke</code> dataset first.
</p>
<p>The 'x' and 'y' values have been taken from Akima (1996).
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>FRANKE, R., (1979). A critical comparison of some methods for interpolation
of scattered data. Tech. Rep. NPS-53-79-003, Dept. of Mathematics, Naval
Postgraduate School, Monterey, Calif.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software <b>22</b>, 362&ndash;371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate Frankes data set for function 2 and dataset 3:
data(franke)
F23 &lt;- franke.data(2,3,franke)
str(F23)
</code></pre>

<hr>
<h2 id='identify.triSht'>Identify points in a triangulation plot</h2><span id='topic+identify.triSht'></span>

<h3>Description</h3>

<p>Identify points in a plot of <code>"x"</code> with its
coordinates. The plot of <code>"x"</code> must be generated with <code>plot.tri</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triSht'
identify(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify.triSht_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+triSht">triSht</a></code></p>
</td></tr>
<tr><td><code id="identify.triSht_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>identify</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector containing the indexes of the identified points.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>, <code><a href="#topic+summary.triSht">summary.triSht</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(franke)
tr &lt;- tri.mesh(franke$ds3$x, franke$ds3$y)
plot(tr)
identify(tr)

## End(Not run)
</code></pre>

<hr>
<h2 id='interp'>
Interpolation function
</h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>This function implements bivariate interpolation for irregularly 
spaced input data. Piecewise linear (=barycentric interpolation), 
bilinear or bicubic spline interpolation according to Akimas method
is applied. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(x, y = NULL, z, xo = seq(min(x), max(x), length = nx),
       yo = seq(min(y), max(y), length = ny),
       linear = (method == "linear"), extrap = FALSE,
       duplicate = "error", dupfun = NULL,
       nx = 40, ny = 40, input="points", output = "grid",
       method = "linear", deltri = "shull", h=0,
       kernel="gaussian", solver="QR", degree=3,
       baryweight=TRUE, autodegree=FALSE, adtol=0.1,
       smoothpde=FALSE, akimaweight=TRUE, nweight=25,
       na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_+3A_x">x</code></td>
<td>

<p>vector of <code class="reqn">x</code>-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object (a regular gridded 
<code>SpatialPixelsDataFrame</code> is also allowed). In this case also
an sp data object will be returned.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interp_+3A_y">y</code></td>
<td>

<p>vector of <code class="reqn">y</code>-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interp_+3A_z">z</code></td>
<td>

<p>vector of <code class="reqn">z</code>-values at data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted by default, see parameter <code>na.rm</code>.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may
contain no fewer than four points. The points of <code>x</code> and
<code>y</code> should not be collinear if <code>input="grid"</code>, 
as the underlying triangulation in these cases sometimes fails.
</p>
<p><code>interp</code> is meant for cases in which you have <code class="reqn">x</code>, <code class="reqn">y</code> 
values scattered over a plane and a <code class="reqn">z</code> value for each.  If, instead,
you are trying to evaluate a mathematical function, or get a
graphical interpretation of relationships that can be described by a
polynomial, try <code><a href="base.html#topic+outer">outer</a></code>.
</p>
</td></tr>
<tr><td><code id="interp_+3A_xo">xo</code></td>
<td>

<p>If <code>output="grid"</code> (which is the default): sequence of <code class="reqn">x</code> locations for
rectangular output grid, defaults to <code>nx</code> points between
<code>min(x)</code> and <code>max(x)</code>.
</p>
<p>If <code>output="points"</code>: vector of <code class="reqn">x</code> locations for output points.
</p>
</td></tr>
<tr><td><code id="interp_+3A_yo">yo</code></td>
<td>

<p>If <code>output="grid"</code> (default): sequence of <code class="reqn">y</code> locations for
rectangular output grid, defaults to <code>ny</code> points between
<code>min(y)</code> and <code>max(y)</code>.
</p>
<p>If <code>output="points"</code>: vector of <code class="reqn">y</code> locations for output
points. In this case it has to be same length as <code>xo</code>.
</p>
</td></tr>
<tr><td><code id="interp_+3A_input">input</code></td>
<td>

<p>text, possible values are <code>"grid"</code> (not yet implemented) and
<code>"points"</code> (default).
</p>
<p>This is used to distinguish between regular and irregular gridded 
input data.
</p>
</td></tr>
<tr><td><code id="interp_+3A_output">output</code></td>
<td>

<p>text, possible values are <code>"grid"</code> (=default) and
<code>"points"</code>.
</p>
<p>If <code>"grid"</code> is choosen then <code>xo</code> and <code>yo</code> are
interpreted as vectors spanning a rectangular grid of points
<code class="reqn">(xo[i],yo[j])</code>, <code class="reqn">i=1,...,nx</code>, <code class="reqn">j=1,...,ny</code>. This
default behaviour matches how <code>akima::interp</code> works.
</p>
<p>In the case of <code>"points"</code>  <code>xo</code> and <code>yo</code> have to be
of same length and are taken as possibly irregular spaced output
points <code class="reqn">(xo[i],yo[i])</code>, <code class="reqn">i=1,...,no</code> with
<code>no=length(xo)</code>. <code>nx</code> and <code>ny</code> are ignored in this
case. This case is meant as replacement for the pointwise
interpolation done by <code>akima::interpp</code>. If the input <code>x</code>
is a <code>SpatialPointsDataFrame</code> and <code>output="points"</code> then
<code>xo</code> has to be a <code>SpatialPointsDataFrame</code>, <code>yo</code> will
be ignored.
</p>
</td></tr>
<tr><td><code id="interp_+3A_linear">linear</code></td>
<td>

<p>logical, only for backward compatibility with <code>akima::interp</code>,
indicates if piecewise linear interpolation or Akima splines should be
used. 
</p>
<p>Please use the new <code>method</code> argument instead!
</p>
</td></tr>
<tr><td><code id="interp_+3A_method">method</code></td>
<td>

<p>text, possible methods are 
<code>"linear"</code> (piecewise linear interpolation within
the triangles of the Delaunay triangulation, also
referred to as barycentric interpolation based on barycentric 
coordinates) and <code>"akima"</code> (a reimplementation for Akimas spline 
algorithms for irregular gridded data with the accuracy of a 
bicubic polynomial).
</p>
<p><code>method="bilinear"</code> is only applicable to regular grids
(<code>input="grid"</code>) and in turn calls <code><a href="#topic+bilinear">bilinear</a></code>, 
see there for more details.
</p>
<p><code>method="linear"</code> replaces the old <code>linear</code> argument of 
<code>akima::interp</code>.
</p>
</td></tr>
<tr><td><code id="interp_+3A_extrap">extrap</code></td>
<td>

<p>logical, indicates if extrapolation outside the convex hull is
intended, this will not work for piecewise linear interpolation!
</p>
</td></tr>
<tr><td><code id="interp_+3A_duplicate">duplicate</code></td>
<td>

<p>character string indicating how to handle duplicate
data points. Possible values are
</p>

<dl>
<dt><code>"error"</code></dt><dd><p>produces an error message,</p>
</dd>
<dt><code>"strip"</code></dt><dd><p>remove duplicate z values,</p>
</dd>
<dt><code>"mean"</code>,<code>"median"</code>,<code>"user"</code></dt><dd><p>calculate
mean , median or user defined function (<code>dupfun</code>) of duplicate
<code class="reqn">z</code> values.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="interp_+3A_dupfun">dupfun</code></td>
<td>

<p>a function, applied to duplicate points if
<code>duplicate= "user"</code>.</p>
</td></tr>
<tr><td><code id="interp_+3A_nx">nx</code></td>
<td>

<p>dimension of output grid in x direction
</p>
</td></tr>
<tr><td><code id="interp_+3A_ny">ny</code></td>
<td>

<p>dimension of output grid in y direction
</p>
</td></tr>
<tr><td><code id="interp_+3A_deltri">deltri</code></td>
<td>

<p>triangulation method used, this argument may later be moved
into a control set together with others related to the spline
interpolation! Possible values are <code>"shull"</code> (default, sweep 
hull algorithm) and <code>"deldir"</code> (uses package<code>deldir</code>).
</p>
</td></tr>
<tr><td><code id="interp_+3A_h">h</code></td>
<td>
<p>bandwidth for partial derivatives estimation, compare <code><a href="#topic+locpoly">locpoly</a></code> for details</p>
</td></tr>
<tr><td><code id="interp_+3A_kernel">kernel</code></td>
<td>
<p>kernel for partial derivatives estimation, compare <code><a href="#topic+locpoly">locpoly</a></code> for details</p>
</td></tr>
<tr><td><code id="interp_+3A_solver">solver</code></td>
<td>
<p>solver used in partial derivatives estimation, compare <code><a href="#topic+locpoly">locpoly</a></code> for details</p>
</td></tr>
<tr><td><code id="interp_+3A_degree">degree</code></td>
<td>
<p>degree of local polynomial used for partial derivatives
estimation, compare <code><a href="#topic+locpoly">locpoly</a></code> for details</p>
</td></tr>
<tr><td><code id="interp_+3A_baryweight">baryweight</code></td>
<td>
<p>calculate three partial derivatives estimators and
return a barycentric weighted average.
</p>
<p>This increases the accuracy of Akima splines but the runtime is 
multplied by 3!
</p>
</td></tr>
<tr><td><code id="interp_+3A_autodegree">autodegree</code></td>
<td>
<p>try to reduce <code>degree</code> automatically</p>
</td></tr>
<tr><td><code id="interp_+3A_adtol">adtol</code></td>
<td>
<p>tolerance used for autodegree</p>
</td></tr>
<tr><td><code id="interp_+3A_smoothpde">smoothpde</code></td>
<td>
<p>Use an averaged version of partial derivatives
estimates, by default simple average of <code>nweight</code> estimates.
</p>
<p>Currently disabled by default (FALSE), underlying code still a bit 
experimental.
</p>
</td></tr>
<tr><td><code id="interp_+3A_akimaweight">akimaweight</code></td>
<td>
<p>apply Akima weighting scheme on partial derivatives
estimations instead of simply averaging</p>
</td></tr>
<tr><td><code id="interp_+3A_nweight">nweight</code></td>
<td>
<p>size of search neighbourhood for weighting scheme,
default: 25</p>
</td></tr>
<tr><td><code id="interp_+3A_na.rm">na.rm</code></td>
<td>
<p>remove points where z=<code>NA</code>, defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>

<p>If <code>output="grid"</code>:
vectors of <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of output grid, the same
as the input
argument <code>xo</code>, or <code>yo</code>, if present.  Otherwise, their
default, a vector 40 points evenly spaced over the range of the
input <code>x</code> and <code>y</code>.
</p>
<p>If <code>output="points"</code>: vectors of <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of
output points as given by <code>xo</code> and <code>yo</code>.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>If <code>output="grid"</code>:
matrix of fitted <code class="reqn">z</code>-values.  The value <code>z[i,j]</code> is computed
at the point <code class="reqn">(xo[i], yo[j])</code>. <code>z</code> has
dimensions <code>length(xo)</code> times <code>length(yo)</code>.
</p>
<p>If <code>output="points"</code>: a vector with the calculated z values for
the output points as given by <code>xo</code> and <code>yo</code>.
</p>
<p>If the input was a <code>SpatialPointsDataFrame</code> a
<code>SpatialPixelsDataFrame</code> is returned for <code>output="grid"</code>
and a  <code>SpatialPointsDataFrame</code>  for <code>output="points"</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please note that this function tries to be a replacement for the interp() function 
from the akima package. So it should be call compatible for most applications. 
It also offers additional tuning parameters, usually the default settings will fit.
Please be aware that these additional parameters may change in the future as they are
still under development.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>Moebius, A. F. (1827) Der barymetrische Calcul. Verlag v. Johann
Ambrosius Barth, Leipzig,
https://books.google.at/books?id=eFPluv_UqFEC&amp;hl=de&amp;pg=PR1#v=onepage&amp;q&amp;f=false
</p>
<p>Franke, R., (1979). A critical comparison of some methods for interpolation
of scattered data. Tech. Rep. NPS-53-79-003, Dept. of Mathematics, Naval
Postgraduate School, Monterey, Calif.
</p>
<p>Akima, H. (1978). A Method of Bivariate Interpolation and
Smooth Surface Fitting for Irregularly Distributed Data Points.
ACM Transactions on Mathematical Software <b>4</b>, 148-164.
</p>
<p>Akima, H. (1996). Algorithm 761: scattered-data surface fitting that has
the accuracy of a cubic polynomial.
ACM Transactions on Mathematical Software <b>22</b>, 362&ndash;371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpp">interpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Use all datasets from Franke, 1979:
data(franke)
## x-y irregular grid points:
oldseed &lt;- set.seed(42)
ni &lt;- 64
xi &lt;- runif(ni,0,1)
yi &lt;- runif(ni,0,1)
xyi &lt;- cbind(xi,yi)
## linear interpolation
fi &lt;- franke.fn(xi,yi,1)
IL &lt;- interp(xi,yi,fi,nx=80,ny=80,method="linear")
## prepare breaks and colors that match for image and contour:
breaks &lt;- pretty(seq(min(IL$z,na.rm=TRUE),max(IL$z,na.rm=TRUE),length=11))
db &lt;- breaks[2]-breaks[1]
nb &lt;- length(breaks)
breaks &lt;- c(breaks[1]-db,breaks,breaks[nb]+db)
colors &lt;- terrain.colors(length(breaks)-1)
image(IL,breaks=breaks,col=colors,main="Franke function 1",
      sub=paste("linear interpolation, ", ni,"points"))
contour(IL,add=TRUE,levels=breaks)
points(xi,yi)
## spline interpolation
fi &lt;- franke.fn(xi,yi,1)
IS &lt;- interp(xi,yi,fi,method="akima",
             kernel="gaussian",solver="QR")
## prepare breaks and colors that match for image and contour:
breaks &lt;- pretty(seq(min(IS$z,na.rm=TRUE),max(IS$z,na.rm=TRUE),length=11))
db &lt;- breaks[2]-breaks[1]
nb &lt;- length(breaks)
breaks &lt;- c(breaks[1]-db,breaks,breaks[nb]+db)
colors &lt;- terrain.colors(length(breaks)-1)
image(IS,breaks=breaks,col=colors,main="Franke function 1",
      sub=paste("spline interpolation, ", ni,"points"))
contour(IS,add=TRUE,levels=breaks)
        points(xi,yi)
## regular grid:
nx &lt;- 8; ny &lt;- 8
xg&lt;-seq(0,1,length=nx)
yg&lt;-seq(0,1,length=ny)
xx &lt;- t(matrix(rep(xg,ny),nx,ny))
yy &lt;- matrix(rep(yg,nx),ny,nx)
xyg&lt;-expand.grid(xg,yg)
## linear interpolation
fg &lt;- outer(xg,yg,function(x,y)franke.fn(x,y,1))
IL &lt;- interp(xg,yg,fg,input="grid",method="linear")
## prepare breaks and colors that match for image and contour:
breaks &lt;- pretty(seq(min(IL$z,na.rm=TRUE),max(IL$z,na.rm=TRUE),length=11))
db &lt;- breaks[2]-breaks[1]
nb &lt;- length(breaks)
breaks &lt;- c(breaks[1]-db,breaks,breaks[nb]+db)
colors &lt;- terrain.colors(length(breaks)-1)
image(IL,breaks=breaks,col=colors,main="Franke function 1",
      sub=paste("linear interpolation, ", nx,"x",ny,"points"))
contour(IL,add=TRUE,levels=breaks)
points(xx,yy)
## spline interpolation
fg &lt;- outer(xg,yg,function(x,y)franke.fn(x,y,1))
IS &lt;- interp(xg,yg,fg,input="grid",method="akima",
             kernel="gaussian",solver="QR")
## prepare breaks and colors that match for image and contour:
breaks &lt;- pretty(seq(min(IS$z,na.rm=TRUE),max(IS$z,na.rm=TRUE),length=11))
db &lt;- breaks[2]-breaks[1]
nb &lt;- length(breaks)
breaks &lt;- c(breaks[1]-db,breaks,breaks[nb]+db)
colors &lt;- terrain.colors(length(breaks)-1)
image(IS,breaks=breaks,col=colors,main="Franke function 1",
      sub=paste("spline interpolation, ", nx,"x",ny,"points"))
contour(IS,add=TRUE,levels=breaks)
points(xx,yy)

## apply interp to sp data:
require(sp)
## convert Akima data set to a sp object 
data(akima)
asp &lt;- SpatialPointsDataFrame(list(x=akima$x,y=akima$y),
                              data = data.frame(z=akima$z))
spplot(asp,"z")
## linear interpolation
spli &lt;- interp(asp, z="z", method="linear")
## the result is again a SpatialPointsDataFrame: 
spplot(spli,"z")
## now with spline interpolation, slightly higher resolution
spsi &lt;- interp(asp, z="z", method="akima", nx=120, ny=120)
spplot(spsi,"z")

## now sp grids: reuse stuff from above
spgr &lt;- SpatialPixelsDataFrame(list(x=c(xx),y=c(yy)),
                               data=data.frame(z=c(fg)))
spplot(spgr)
## linear interpolation
spli &lt;- interp(spgr, z="z", method="linear", input="grid")
## the result is again a SpatialPointsDataFrame: 
spplot(spli,"z")
## now with spline interpolation, slightly higher resolution
spsi &lt;- interp(spgr, z="z", method="akima", nx=240, ny=240)
spplot(spsi,"z")

set.seed(oldseed)
</code></pre>

<hr>
<h2 id='interp2xyz'>From interp() Result, Produce 3-column Matrix</h2><span id='topic+interp2xyz'></span>

<h3>Description</h3>

<p>From an <code><a href="#topic+interp">interp</a>()</code> result, produce a 3-column matrix
or <code><a href="base.html#topic+data.frame">data.frame</a></code> <code>cbind(x, y, z)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp2xyz(al, data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp2xyz_+3A_al">al</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> as produced from <code><a href="#topic+interp">interp</a>()</code>.</p>
</td></tr>
<tr><td><code id="interp2xyz_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating if result should be
<a href="base.html#topic+data.frame">data.frame</a> or matrix (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix (or data.frame) with three columns, called
<code>"x"</code>, <code>"y"</code>, <code>"z"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, Jan.18, 2013
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+expand.grid">expand.grid</a>()</code> is the &ldquo;essential ingredient&rdquo; of
<code>interp2xyz()</code>.
</p>
<p><code><a href="#topic+interp">interp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(akima)
ak.spl &lt;- with(akima, interp(x, y, z, method = "akima"))
str(ak.spl)# list (x[i], y[j], z = &lt;matrix&gt;[i,j])

## Now transform to simple  (x,y,z)  matrix / data.frame :
str(am &lt;- interp2xyz(ak.spl))
str(ad &lt;- interp2xyz(ak.spl, data.frame=TRUE))
## and they are the same:
stopifnot( am == ad | (is.na(am) &amp; is.na(ad)) )
</code></pre>

<hr>
<h2 id='interpp'>
Pointwise interpolate irregular gridded data
</h2><span id='topic+interpp'></span>

<h3>Description</h3>

<p>This function implements bivariate interpolation onto a set of points
for irregularly spaced input data.
</p>
<p>This function is meant for backward compatibility to package
<code>akima</code>, please use <code><a href="#topic+interp">interp</a></code> with its <code>output</code>
argument set to <code>"points"</code> now. Especially newer options to the underlying
algorithm are only available there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpp(x, y = NULL, z, xo, yo = NULL, linear = TRUE,
  extrap = FALSE, duplicate = "error", dupfun = NULL,
  deltri = "shull")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpp_+3A_x">x</code></td>
<td>

<p>vector of x-coordinates of data points or a
<code>SpatialPointsDataFrame</code> object.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_y">y</code></td>
<td>

<p>vector of y-coordinates of data points.
Missing values are not accepted.
</p>
<p>If left as NULL indicates that <code>x</code> should be a
<code>SpatialPointsDataFrame</code> and <code>z</code> names the variable of
interest in this dataframe.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_z">z</code></td>
<td>

<p>vector of z-coordinates of data points or a character variable
naming the variable of interest in the
<code>SpatialPointsDataFrame</code> <code>x</code>.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
(execpt if <code>x</code> is a <code>SpatialPointsDataFrame</code>) and may
contain no fewer than four points. The points of <code>x</code> and <code>y</code>
cannot be collinear, i.e, they cannot fall on the same line (two vectors
<code>x</code> and <code>y</code> such that <code>y = ax + b</code> for some <code>a</code>,
<code>b</code> will not be accepted).
</p>
</td></tr>
<tr><td><code id="interpp_+3A_xo">xo</code></td>
<td>

<p>vector of x-coordinates of points at which to evaluate the interpolating
function. If <code>x</code> is a <code>SpatialPointsDataFrame</code> this has
also to be a <code>SpatialPointsDataFrame</code>.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_yo">yo</code></td>
<td>

<p>vector of y-coordinates of points at which to evaluate the interpolating
function.
</p>
<p>If operating on <code>SpatialPointsDataFrame</code>s this is left as <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="interpp_+3A_linear">linear</code></td>
<td>
<p>logical &ndash; indicating wether linear or spline
interpolation should be used.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_extrap">extrap</code></td>
<td>

<p>logical flag: should extrapolation be used outside of the
convex hull determined by the data points? Not possible for linear
interpolation.</p>
</td></tr>
<tr><td><code id="interpp_+3A_duplicate">duplicate</code></td>
<td>

<p>indicates how to handle duplicate data points. Possible values are
<code>"error"</code> - produces an error message, <code>"strip"</code> - remove
duplicate z values, <code>"mean"</code>,<code>"median"</code>,<code>"user"</code>  -
calculate  mean , median or user defined function of duplicate z
values.
</p>
</td></tr>
<tr><td><code id="interpp_+3A_dupfun">dupfun</code></td>
<td>

<p>this function is applied to duplicate points if <code>duplicate="user"</code>
</p>
</td></tr>
<tr><td><code id="interpp_+3A_deltri">deltri</code></td>
<td>

<p>triangulation method used, this argument will later be moved
into a control set together with others related to the spline
interpolation!
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 3 components:
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>

<p>If <code>output="grid"</code>:
vectors of <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of output grid, the same
as the input
argument <code>xo</code>, or <code>yo</code>, if present.  Otherwise, their
default, a vector 40 points evenly spaced over the range of the
input <code>x</code> and <code>y</code>.
</p>
<p>If <code>output="points"</code>: vectors of <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of
output points as given by <code>xo</code> and <code>yo</code>.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>If <code>output="grid"</code>:
matrix of fitted <code class="reqn">z</code>-values.  The value <code>z[i,j]</code> is computed
at the point <code class="reqn">(xo[i], yo[j])</code>. <code>z</code> has
dimensions <code>length(xo)</code> times <code>length(yo)</code>.
</p>
<p>If <code>output="points"</code>: a vector with the calculated z values for
the output points as given by <code>xo</code> and <code>yo</code>.
</p>
<p>If the input was a <code>SpatialPointsDataFrame</code> a
<code>SpatialPixelssDataFrame</code> is returned for <code>output="grid"</code>
and a  <code>SpatialPointsDataFrame</code>  for <code>output="points"</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is only a call wrapper meant for backward compatibility, see
<code><a href="#topic+interp">interp</a></code> for more details!
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>Moebius, A. F. (1827) Der barymetrische Calcul. Verlag v. Johann
Ambrosius Barth, Leipzig,
https://books.google.at/books?id=eFPluv_UqFEC&amp;hl=de&amp;pg=PR1#v=onepage&amp;q&amp;f=false
</p>
<p>Franke, R., (1979). A critical comparison of some methods for interpolation
of scattered data. Tech. Rep. NPS-53-79-003, Dept. of Mathematics, Naval
Postgraduate School, Monterey, Calif.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp">interp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Use all datasets from Franke, 1979:
### calculate z at shifted original locations.
data(franke)
for(i in 1:5)
    for(j in 1:3){
        FR &lt;- franke.data(i,j,franke)
        IL &lt;- with(FR, interpp(x,y,z,x+0.1,y+0.1,linear=TRUE))
        str(IL)
    }
</code></pre>

<hr>
<h2 id='locpoly'>
Local polynomial fit.
</h2><span id='topic+locpoly'></span>

<h3>Description</h3>

<p>This function performs a local polynomial fit of up to order 3 to
bivariate data. It returns estimated values of the regression function
as well as estimated partial derivatives up to order 3. This access to the 
partial derivatives was the main intent for writing this code as there already
many other local polynomial regression implementations in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locpoly(x, y, z, xo = seq(min(x), max(x), length = nx), yo = seq(min(y),
 max(y), length = ny), nx = 40, ny = 40, input = "points", output = "grid",
 h = 0, kernel = "gaussian", solver = "QR", degree = 3, pd = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locpoly_+3A_x">x</code></td>
<td>

<p>vector of <code class="reqn">x</code>-coordinates of data points.
</p>
<p>Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_y">y</code></td>
<td>

<p>vector of <code class="reqn">y</code>-coordinates of data points.
</p>
<p>Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_z">z</code></td>
<td>

<p>vector of <code class="reqn">z</code>-values at data points.
</p>
<p>Missing values are not accepted.
</p>
<p><code>x</code>, <code>y</code>, and <code>z</code> must be the same length
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_xo">xo</code></td>
<td>

<p>If <code>output="grid"</code> (default): sequence of <code class="reqn">x</code> locations for
rectangular output grid, defaults to <code>nx</code> points between
<code>min(x)</code> and <code>max(x)</code>.
</p>
<p>If <code>output="points"</code>: vector of <code class="reqn">x</code> locations for output points.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_yo">yo</code></td>
<td>

<p>If <code>output="grid"</code> (default): sequence of <code class="reqn">y</code> locations for
rectangular output grid, defaults to <code>ny</code> points between
<code>min(y)</code> and <code>max(y)</code>.
</p>
<p>If <code>output="points"</code>: vector of <code class="reqn">y</code> locations for output
points. In this case it has to be same length as <code>xo</code>.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_input">input</code></td>
<td>

<p>text, possible values are <code>"grid"</code> (not yet implemented) and
<code>"points"</code> (default).
</p>
<p>This is used to distinguish between regular and irregular gridded data.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_output">output</code></td>
<td>

<p>text, possible values are <code>"grid"</code> (=default) and
<code>"points"</code>.
</p>
<p>If <code>"grid"</code> is choosen then <code>xo</code> and <code>yo</code> are
interpreted as vectors spanning a rectangular grid of points
<code class="reqn">(xo[i],yo[j])</code>, <code class="reqn">i=1,...,nx</code>, <code class="reqn">j=1,...,ny</code>. This
default behaviour matches how <code>akima::interp</code> works.
</p>
<p>In the case of <code>"points"</code>  <code>xo</code> and <code>yo</code> have to be
of same lenght and are taken as possibly irregular spaced output
points <code class="reqn">(xo[i],yo[i])</code>, <code class="reqn">i=1,...,no</code> with
<code>no=length(xo)</code>. <code>nx</code> and <code>ny</code> are ignored in this
case. 
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_nx">nx</code></td>
<td>

<p>dimension of output grid in x direction
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_ny">ny</code></td>
<td>

<p>dimension of output grid in y direction
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_h">h</code></td>
<td>

<p>bandwidth parameter, between 0 and 1.
If a scalar is given it is interpreted as ratio applied to the dataset size 
to determine a local search neighbourhood, if set to 0 a minimum useful 
search neighbourhood is choosen (e.g. 10 points for a cubic trend function 
to determine all 10 parameters).
</p>
<p>If a vector of length 2 is given both components are interpreted as
ratio of the <code class="reqn">x</code>- and <code class="reqn">y</code>-range and taken as global
bandwidth. 
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_kernel">kernel</code></td>
<td>

<p>Text value, implemented kernels are <code>uniform</code>, <code>triangle</code>,
<code>epanechnikov</code>, <code>biweight</code>, <code>tricube</code>,
<code>triweight</code>, <code>cosine</code>  and <code>gaussian</code> (default).
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_solver">solver</code></td>
<td>

<p>Text value, determines used solver in fastLM algorithm used by this 
code 
</p>
<p>Possible values are <code>LLt</code>, <code>QR</code> (default), <code>SVD</code>,
<code>Eigen</code> and
<code>CPivQR</code> (compare <code><a href="RcppEigen.html#topic+fastLm">fastLm</a></code>).

</p>
</td></tr>
<tr><td><code id="locpoly_+3A_degree">degree</code></td>
<td>

<p>Integer value, degree of polynomial trend, maximum allowed value is 3.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_pd">pd</code></td>
<td>

<p>Text value, determines which partial derivative should be returned,
possible values are  <code>""</code> (default, the polynomial itself),
<code>"x"</code>, <code>"y"</code>, <code>"xx"</code>, <code>"xy"</code>, <code>"yy"</code>, 
<code>"xxx"</code>, <code>"xxy"</code>, <code>"xyy"</code>, <code>"yyy"</code> or <code>"all"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>pd="all"</code>:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p><code class="reqn">x</code> coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p><code class="reqn">y</code> coordinates</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>estimates of <code class="reqn">z</code></p>
</td></tr>
<tr><td><code>zx</code></td>
<td>
<p>estimates of <code class="reqn">dz/dx</code></p>
</td></tr>
<tr><td><code>zy</code></td>
<td>
<p>estimates of <code class="reqn">dz/dy</code></p>
</td></tr>
<tr><td><code>zxx</code></td>
<td>
<p>estimates of <code class="reqn">d^2z/dx^2</code></p>
</td></tr>
<tr><td><code>zxy</code></td>
<td>
<p>estimates of <code class="reqn">d^2z/dxdy</code></p>
</td></tr>
<tr><td><code>zyy</code></td>
<td>
<p>estimates of <code class="reqn">d^2z/dy^2</code></p>
</td></tr>
<tr><td><code>zxxx</code></td>
<td>
<p>estimates of <code class="reqn">d^3z/dx^3</code></p>
</td></tr>
<tr><td><code>zxxy</code></td>
<td>
<p>estimates of <code class="reqn">d^3z/dx^2dy</code></p>
</td></tr>
<tr><td><code>zxyy</code></td>
<td>
<p>estimates of <code class="reqn">d^3z/dxdy^2</code></p>
</td></tr>
<tr><td><code>zyyy</code></td>
<td>
<p>estimates of <code class="reqn">d^3z/dy^3</code></p>
</td></tr>
</table>
<p>If <code>pd!="all"</code> only the elements <code>x</code>, <code>y</code> and the desired
derivative will be returned, e.g. <code>zxy</code> for <code>pd="xy"</code>. 
</p>


<h3>Note</h3>

<p>Function <code><a href="KernSmooth.html#topic+locpoly">locpoly</a></code> of package
<code>KernSmooth</code> performs a similar task for univariate data.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>Douglas Bates, Dirk Eddelbuettel (2013). Fast and Elegant Numerical
Linear Algebra Using the RcppEigen Package. Journal of Statistical
Software, 52(5), 1-24. URL http://www.jstatsoft.org/v52/i05/.
</p>


<h3>See Also</h3>

<p><code><a href="KernSmooth.html#topic+locpoly">locpoly</a></code>, <code><a href="RcppEigen.html#topic+fastLm">fastLm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## choose a kernel
knl &lt;- "gaussian"

## choose global and local bandwidth 
bwg &lt;- 0.25 # *100% means: percentage of x- y-range used
bwl &lt;- 0.1  # *100% means: percentage of data set (nearest neighbours) used

## a bivariate polynomial of degree 5:
f &lt;- function(x,y) 0.1+ 0.2*x-0.3*y+0.1*x*y+0.3*x^2*y-0.5*y^2*x+y^3*x^2+0.1*y^5

## degree of model
dg=3 

## part 1:
## regular gridded data:
ng&lt;- 11 # x/y size of a square data grid

## build and fill the grid with the theoretical values:

xg&lt;-seq(0,1,length=ng)
yg&lt;-seq(0,1,length=ng)

# xg and yg as matrix matching fg
nx &lt;- length(xg)
ny &lt;- length(yg)
xx &lt;- t(matrix(rep(xg,ny),nx,ny))
yy &lt;- matrix(rep(yg,nx),ny,nx)

fg   &lt;- outer(xg,yg,f)

## local polynomial estimate
## global bw:
ttg &lt;- system.time(pdg &lt;- locpoly(xg,yg,fg,
  input="grid", pd="all", h=c(bwg,bwg), solver="QR", degree=dg, kernel=knl))
## time used:
ttg

## local bw:
ttl &lt;- system.time(pdl &lt;- locpoly(xg,yg,fg,
  input="grid", pd="all", h=bwl, solver="QR", degree=dg, kernel=knl))
## time used:
ttl

image(pdl$x,pdl$y,pdl$z,main="f and its estimated first partial derivatives",
      sub="colors: f, dotted: df/dx, dashed: df/dy")
contour(pdl$x,pdl$y,pdl$zx,add=TRUE,lty="dotted")
contour(pdl$x,pdl$y,pdl$zy,add=TRUE,lty="dashed")
points(xx,yy,pch=".")


## part 2:
## irregular data,
## results will not be as good as with the regular 21*21=231 points.

nd&lt;- 121 # size of data set

## random irregular data
oldseed &lt;- set.seed(42)
x&lt;-runif(ng)
y&lt;-runif(ng)
set.seed(oldseed)

z &lt;- f(x,y)

## global bw:
ttg &lt;- system.time(pdg &lt;- interp::locpoly(x,y,z, xg,yg, pd="all",
  h=c(bwg,bwg), solver="QR", degree=dg,kernel=knl))

ttg

## local bw:
ttl &lt;- system.time(pdl &lt;- interp::locpoly(x,y,z, xg,yg, pd="all",
  h=bwl, solver="QR", degree=dg,kernel=knl))

ttl

image(pdl$x,pdl$y,pdl$z,main="f and its estimated first partial derivatives",
      sub="colors: f, dotted: df/dx, dashed: df/dy")
contour(pdl$x,pdl$y,pdl$zx,add=TRUE,lty="dotted")
contour(pdl$x,pdl$y,pdl$zy,add=TRUE,lty="dashed")
points(x,y,pch=".")

</code></pre>

<hr>
<h2 id='nearest.neighbours'>
Nearest neighbour structure for a data set
</h2><span id='topic+nearest.neighbours'></span>

<h3>Description</h3>

<p>This function can be used to generate nearest neighbour information
for a set of 2D data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest.neighbours(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearest.neighbours_+3A_x">x</code></td>
<td>

<p>vector containing <code class="reqn">x</code> ccordinates of points.
</p>
</td></tr>
<tr><td><code id="nearest.neighbours_+3A_y">y</code></td>
<td>

<p>vector containing <code class="reqn">x</code> ccordinates of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The C++ implementation of this function is used inside the
<code><a href="#topic+locpoly">locpoly</a></code> and <code><a href="#topic+interp">interp</a></code> functions.
</p>


<h3>Value</h3>

<p>A list with two components
</p>
<table role = "presentation">
<tr><td><code>index</code></td>
<td>

<p>A matrix with one row per data point. Each row contains the indices
of the nearest neigbours to the point associated with this row, 
currently the point itself is also listed in the first row, so
this matrix is of dimension <code class="reqn">n</code> times <code class="reqn">n</code> (will change to
<code class="reqn">n</code> times <code class="reqn">n-1</code> later).
</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>

<p>A matrix containing the distances according to the neigbours listed
in component <code>index</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
## use only a small subset
fd &lt;- franke$ds1[1:5,]
nearest.neighbours(fd$x,fd$y)
</code></pre>

<hr>
<h2 id='neighbours'>List of neighbours from a triangulation or voronoi object</h2><span id='topic+neighbours'></span>

<h3>Description</h3>

<p>Extract a list of neighbours from a triangulation or
voronoi object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbours(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighbours_+3A_obj">obj</code></td>
<td>
<p>object of class <code>"triSht"</code> or <code>"voronoi.mosaic"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of neighbours per point
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>, <code><a href="#topic+summary.triSht">summary.triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tritest)
tritest.tr&lt;-tri.mesh(tritest$x,tritest$y)
tritest.nb&lt;-neighbours(tritest.tr)
</code></pre>

<hr>
<h2 id='on'>
Determines if a point is on or left of the vector described by two other points.
</h2><span id='topic+on'></span><span id='topic+left'></span>

<h3>Description</h3>

<p>A simple test function to determine the position of one (or more)
points relative to a vector spanned by two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on(x1, y1, x2, y2, x0, y0, eps = 1e-16)
left(x1, y1, x2, y2, x0, y0, eps = 1e-16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="on_+3A_x1">x1</code></td>
<td>

<p><code>x</code> coordinate of first point determinig the vector.
</p>
</td></tr>
<tr><td><code id="on_+3A_y1">y1</code></td>
<td>

<p><code>y</code> coordinate of first point determinig the vector.
</p>
</td></tr>
<tr><td><code id="on_+3A_x2">x2</code></td>
<td>

<p><code>x</code> coordinate of second point determinig the vector.
</p>
</td></tr>
<tr><td><code id="on_+3A_y2">y2</code></td>
<td>

<p><code>y</code> coordinate of second point determinig the vector.
</p>
</td></tr>
<tr><td><code id="on_+3A_x0">x0</code></td>
<td>

<p>vector of <code>x</code> coordinates to locate relative to the vector
<code class="reqn">(x_2-x_1, y_2-y_1)</code>.
</p>
</td></tr>
<tr><td><code id="on_+3A_y0">y0</code></td>
<td>

<p>vector of <code>x</code> coordinates to locate relative to the vector
<code class="reqn">(x_2-x_1, y_2-y_1)</code>.
</p>
</td></tr>
<tr><td><code id="on_+3A_eps">eps</code></td>
<td>

<p>tolerance for checking if <code class="reqn">x_0,y_0</code> is on or left of <code class="reqn">(x_2-x_1,
      y_2-y_1)</code>, defaults to <code class="reqn">10^{-16}</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector with the results of the test.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.convex.hull">in.convex.hull</a></code>,   <code><a href="#topic+on.convex.hull">on.convex.hull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- x &lt;- c(0,1)
## should be TRUE
on(x[1],y[1],x[2],y[2],0.5,0.5)
## note the default setting of eps leading to
on(x[1],y[1],x[2],y[2],0.5,0.50000000000000001)
## also be TRUE

## should be TRUE
left(x[1],y[1],x[2],y[2],0.5,0.6)
## note the default setting of eps leading to
left(x[1],y[1],x[2],y[2],0.5,0.50000000000000001)
## already resulting to FALSE

</code></pre>

<hr>
<h2 id='on.convex.hull'>Determines if points are on or in the convex hull of a triangulation object</h2><span id='topic+on.convex.hull'></span><span id='topic+in.convex.hull'></span>

<h3>Description</h3>

<p>Given a triangulation object <code>tri.obj</code> of <code class="reqn">n</code> points in the plane, this
subroutine returns a logical vector indicating if the points
<code class="reqn">(x_i,y_i)</code>
lay on or in the convex hull of <code>tri.obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on.convex.hull(tri.obj, x, y, eps=1E-16)
in.convex.hull(tri.obj, x, y, eps=1E-16, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="on.convex.hull_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code><a href="#topic+triSht">triSht</a></code></p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_x">x</code></td>
<td>
<p>vector of <code class="reqn">x</code>-coordinates of points to locate</p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_y">y</code></td>
<td>
<p>vector of <code class="reqn">y</code>-coordinates of points to locate</p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_eps">eps</code></td>
<td>
<p>accuracy for checking the condition</p>
</td></tr>
<tr><td><code id="on.convex.hull_+3A_strict">strict</code></td>
<td>
<p>logical, default <code>TRUE</code>. It indicates if the convex
hull is treated as an open (<code>strict=TRUE</code>) or closed
(<code>strict=FALSE</code>) set. (applies only to <code>in.convex.hull</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>,
<code><a href="#topic+convex.hull">convex.hull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-10.78 &amp; quakes[,1]&gt;=-19.4 &amp;
                     quakes[,2]&lt;=182.29 &amp; quakes[,2]&gt;=165.77),]
q.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
on.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20])
# Check with part of data set:
# Note that points on the hull (see above) get marked FALSE below:
in.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20])
# If points both on the hull and in the interior of the hull are meant 
# disable strict mode:
in.convex.hull(q.tri,quakes.part$lon[1:20],quakes.part$lat[1:20],strict=FALSE)
# something completely outside:
in.convex.hull(q.tri,c(170,180),c(-20,-10))
</code></pre>

<hr>
<h2 id='outer.convhull'>Version of outer which operates only in a convex hull</h2><span id='topic+outer.convhull'></span>

<h3>Description</h3>

<p>This version of <code>outer</code> evaluates <code>FUN</code>
only on that part of the grid <code class="reqn">cx</code> times <code class="reqn">cy</code> that is enclosed within
the convex hull of the points <code class="reqn">(px,py)</code>.
</p>
<p>This can be useful for spatial estimation if no extrapolation is wanted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer.convhull(cx,cy,px,py,FUN,duplicate="remove",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outer.convhull_+3A_cx">cx</code></td>
<td>
<p>x cordinates of grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_cy">cy</code></td>
<td>
<p>y cordinates of grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_px">px</code></td>
<td>
<p>vector of x coordinates of points</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_py">py</code></td>
<td>
<p>vector of y coordinates of points</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_fun">FUN</code></td>
<td>
<p>function to be evaluated over the grid</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_duplicate">duplicate</code></td>
<td>
<p>indicates what to do with duplicate
<code class="reqn">(px_i,py_i)</code> points, default <code>"remove"</code>.</p>
</td></tr>
<tr><td><code id="outer.convhull_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with values of <code>FUN</code> (<code>NA</code>s if outside the
convex hull).
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.convex.hull">in.convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-runif(20)
y&lt;-runif(20)
z&lt;-runif(20)
z.lm&lt;-lm(z~x+y)
f.pred&lt;-function(x,y)
  {predict(z.lm,data.frame(x=as.vector(x),y=as.vector(y)))}
xg&lt;-seq(0,1,0.05)
yg&lt;-seq(0,1,0.05)
image(xg,yg,outer.convhull(xg,yg,x,y,f.pred))
points(x,y)
</code></pre>

<hr>
<h2 id='plot.triSht'>Plot a triangulation object</h2><span id='topic+plot.triSht'></span>

<h3>Description</h3>

<p>plots the triangulation object <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triSht'
plot(x, add = FALSE, xlim = range(x$x),
  ylim = range(x$y), do.points = TRUE, do.labels = FALSE, isometric = TRUE,
  do.circumcircles = FALSE, segment.lty = "dashed", circle.lty =
  "dotted", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.triSht_+3A_x">x</code></td>
<td>
<p>object of class <code>"triSht"</code></p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_do.points">do.points</code></td>
<td>
<p>logical, indicates if points should be
plotted. (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_do.labels">do.labels</code></td>
<td>
<p>logical, indicates if points should be labelled.
(default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_xlim">xlim</code>, <code id="plot.triSht_+3A_ylim">ylim</code></td>
<td>
<p>x/y ranges for plot</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_isometric">isometric</code></td>
<td>
<p>generate an isometric plot (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_do.circumcircles">do.circumcircles</code></td>
<td>
<p>logical, indicates if circumcircles should be
plotted (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_segment.lty">segment.lty</code></td>
<td>
<p>line type for triangulation segments</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_circle.lty">circle.lty</code></td>
<td>
<p>line type for circumcircles</p>
</td></tr>
<tr><td><code id="plot.triSht_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## random points
plot(tri.mesh(rpois(100,lambda=20),rpois(100,lambda=20),duplicate="remove"))
## use a part of the quakes data set:
data(quakes)
quakes.part&lt;-quakes[(quakes[,1]&lt;=-10.78 &amp; quakes[,1]&gt;=-19.4 &amp;
                     quakes[,2]&lt;=182.29 &amp; quakes[,2]&gt;=165.77),]
quakes.tri&lt;-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
plot(quakes.tri)
## use the whole quakes data set
## (will not work with standard memory settings, hence commented out)
## plot(tri.mesh(quakes$lon, quakes$lat, duplicate="remove"), do.points=F)
</code></pre>

<hr>
<h2 id='plot.voronoi'>Plot a voronoi object</h2><span id='topic+plot.voronoi'></span>

<h3>Description</h3>

<p>Plots the mosaic <code>"x"</code>.
Dashed lines are used for outer tiles of the mosaic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
plot(x,add=FALSE,
                           xlim=c(min(x$tri$x)-
                             0.1*diff(range(x$tri$x)),
                             max(x$tri$x)+
                             0.1*diff(range(x$tri$x))),
                           ylim=c(min(x$tri$y)-
                             0.1*diff(range(x$tri$y)),
                             max(x$tri$y)+
                             0.1*diff(range(x$tri$y))),
                           all=FALSE,
                           do.points=TRUE,
                           main="Voronoi mosaic",
                           sub=deparse(substitute(x)),
                           isometric=TRUE,
                           ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_xlim">xlim</code></td>
<td>
<p>x plot ranges, by default modified to hide dummy 
points outside of the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_ylim">ylim</code></td>
<td>
<p>y plot ranges, by default modified to hide dummy 
points outside of the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_all">all</code></td>
<td>
<p>show all (including dummy points in the plot</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_do.points">do.points</code></td>
<td>
<p>logical, indicates if points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_sub">sub</code></td>
<td>
<p>plot subtitle</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_isometric">isometric</code></td>
<td>
<p>generate an isometric plot (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_...">...</code></td>
<td>
<p>additional plot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi">voronoi</a></code>, <code><a href="#topic+print.voronoi">print.voronoi</a></code>, 
<code><a href="#topic+summary.voronoi">summary.voronoi</a></code>, <code><a href="#topic+plot.voronoi.polygons">plot.voronoi.polygons</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
tr &lt;- tri.mesh(franke$ds3)
vr &lt;- voronoi.mosaic(tr)
plot(tr)
plot(vr,add=TRUE)
</code></pre>

<hr>
<h2 id='plot.voronoi.polygons'>plots an voronoi.polygons object</h2><span id='topic+plot.voronoi.polygons'></span>

<h3>Description</h3>

<p>plots an <code>voronoi.polygons</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi.polygons'
plot(x, which, color=TRUE, isometric=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.voronoi.polygons_+3A_x">x</code></td>
<td>
<p> object of class <code>voronoi.polygons</code>  </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_which">which</code></td>
<td>
<p> index vector selecting which polygons to plot </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_color">color</code></td>
<td>
<p> logical, determines if plot should be colored, default:
<code>TRUE</code> </p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_isometric">isometric</code></td>
<td>
<p>generate an isometric plot (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.voronoi.polygons_+3A_...">...</code></td>
<td>
<p> additional plot arguments </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> A. Gebhardt</p>


<h3>See Also</h3>

 <p><code><a href="#topic+voronoi.polygons">voronoi.polygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
fd3 &lt;- franke$ds3
fd3.vm &lt;- voronoi.mosaic(fd3$x,fd3$y)
fd3.vp &lt;- voronoi.polygons(fd3.vm)
plot(fd3.vp)
plot(fd3.vp,which=c(3,4,6,10))
</code></pre>

<hr>
<h2 id='print.summary.triSht'>Print a summary of a triangulation object</h2><span id='topic+print.summary.triSht'></span>

<h3>Description</h3>

<p>Prints some information about <code>tri.obj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.triSht'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.triSht_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.triSht"</code>,
generated by <code><a href="#topic+summary.triSht">summary.triSht</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.triSht_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This function is meant as replacement for the function of same name in
package <code>tripack</code>.
</p>
<p>The only difference is that no constraints are possible with
<code>triSht</code> objects of package <code>interp</code>.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>,<code><a href="#topic+tri.mesh">tri.mesh</a></code>,
<code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>.
</p>

<hr>
<h2 id='print.summary.voronoi'>Print a summary of a voronoi object</h2><span id='topic+print.summary.voronoi'></span>

<h3>Description</h3>

<p>Prints some information about object <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.voronoi'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"summary.voronoi"</code>,
generated by <code><a href="#topic+summary.voronoi">summary.voronoi</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.voronoi_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This function is meant as replacement for the function of same name in
package <code>tripack</code> and should be fully backward compatible.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi">voronoi</a></code>,<code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
<code><a href="#topic+print.voronoi">print.voronoi</a></code>, <code><a href="#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="#topic+summary.voronoi">summary.voronoi</a></code>. 
</p>

<hr>
<h2 id='print.triSht'>Print a triangulation object</h2><span id='topic+print.triSht'></span>

<h3>Description</h3>

<p>prints a adjacency list of <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triSht'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.triSht_+3A_x">x</code></td>
<td>
<p>object of class <code>"triSht"</code></p>
</td></tr>
<tr><td><code id="print.triSht_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>,
<code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>
</p>

<hr>
<h2 id='print.voronoi'>Print a voronoi object</h2><span id='topic+print.voronoi'></span>

<h3>Description</h3>

<p>prints a summary of <code>"x"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.voronoi_+3A_x">x</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="print.voronoi_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi">voronoi</a></code>,
<code><a href="#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="#topic+summary.voronoi">summary.voronoi</a></code>
</p>

<hr>
<h2 id='summary.triSht'>Return a summary of a triangulation object</h2><span id='topic+summary.triSht'></span>

<h3>Description</h3>

<p>Returns some information (number of nodes, triangles, arcs)
about <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triSht'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.triSht_+3A_object">object</code></td>
<td>
<p>object of class <code>"triSht"</code></p>
</td></tr>
<tr><td><code id="summary.triSht_+3A_...">...</code></td>
<td>
<p>additional paramters for <code>summary</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.triSht"</code>, to be printed by
<code><a href="#topic+print.summary.triSht">print.summary.triSht</a></code>.
</p>
<p>It contains the number of nodes (<code>n</code>), of arcs (<code>na</code>), of
boundary nodes (<code>nb</code>) and triangles (<code>nt</code>).
</p>


<h3>Note</h3>

<p>This function is meant as replacement for the function of same name in
package <code>tripack</code>.
</p>
<p>The only difference is that no constraints are possible with
<code>triSht</code> objects of package <code>interp</code>.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+print.summary.triSht">print.summary.triSht</a></code>.
</p>

<hr>
<h2 id='summary.voronoi'>Return a summary of a voronoi object</h2><span id='topic+summary.voronoi'></span>

<h3>Description</h3>

<p>Returns some information about <code>object</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.voronoi_+3A_object">object</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="summary.voronoi_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>summary</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"summary.voronoi"</code>.
</p>
<p>It contains the number of nodes (<code>nn</code>) and dummy nodes (<code>nd</code>).
</p>


<h3>Note</h3>

<p>This function is meant as replacement for the function of same name in
package <code>tripack</code> and should be fully backward compatible.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi">voronoi</a></code>,<code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
<code><a href="#topic+print.voronoi">print.voronoi</a></code>, <code><a href="#topic+plot.voronoi">plot.voronoi</a></code>,
<code><a href="#topic+print.summary.voronoi">print.summary.voronoi</a></code>.
</p>

<hr>
<h2 id='tri.find'>Locate a point in a triangulation</h2><span id='topic+tri.find'></span>

<h3>Description</h3>

<p>This subroutine locates a point <code class="reqn">P=(x,y)</code> relative to a
triangulation  created by <code>tri.mesh</code>.  If <code class="reqn">P</code> is
contained in a triangle, the three vertex indexes are
returned.  Otherwise, the indexes of the rightmost and
leftmost visible boundary nodes are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.find(tri.obj,x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tri.find_+3A_tri.obj">tri.obj</code></td>
<td>
<p>an triangulation object of class <code>triSht</code></p>
</td></tr>
<tr><td><code id="tri.find_+3A_x">x</code></td>
<td>
<p>x-coordinate of the point</p>
</td></tr>
<tr><td><code id="tri.find_+3A_y">y</code></td>
<td>
<p>y-coordinate of the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>i1</code>,<code>i2</code>,<code>i3</code> containing nodal
indexes, in counterclockwise order, of the vertices of a triangle
containing <code class="reqn">P=(x,y)</code>. <code>tr</code> contains the triangle index and 
<code>bc</code> contains the barycentric coordinates 
of <code class="reqn">P</code> w.r.t. the found triangle.
</p>
<p>If <code class="reqn">P</code> is not contained in the
convex hull of the nodes this indices are 0 (<code>bc</code> is meaningless then).








</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>,
<code><a href="#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
tr&lt;-tri.mesh(franke$ds3$x,franke$ds3$y)
plot(tr)
pnt&lt;-list(x=0.3,y=0.4)
triangle.with.pnt&lt;-tri.find(tr,pnt$x,pnt$y)
attach(triangle.with.pnt)
lines(franke$ds3$x[c(i1,i2,i3,i1)],franke$ds3$y[c(i1,i2,i3,i1)],col="red")
points(pnt$x,pnt$y)
</code></pre>

<hr>
<h2 id='tri.mesh'>
Delaunay triangulation
</h2><span id='topic+tri.mesh'></span>

<h3>Description</h3>

<p>This function generates a Delaunay triangulation of arbitrarily distributed
points in the plane. The resulting object can be printed or plotted,
some additional functions can extract details from it like the list of
triangles, arcs or the convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.mesh(x, y = NULL, duplicate = "error", jitter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tri.mesh_+3A_x">x</code></td>
<td>

<p>vector containing <code class="reqn">x</code> coordinates of the data. If <code>y</code> is missing
<code>x</code> should be a list or dataframe with two components <code>x</code>
and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_y">y</code></td>
<td>

<p>vector containing <code class="reqn">y</code> coordinates of the data. Can be omitted if
<code>x</code> is a list with two components <code>x</code> and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="tri.mesh_+3A_duplicate">duplicate</code></td>
<td>

<p>flag indicating how to handle duplicate elements.
Possible values are:
</p>

<ul>
<li>
<p><code>"error"</code> &ndash; default,

</p>
</li>
<li>
<p><code>"strip"</code> &ndash; remove all duplicate points,

</p>
</li>
<li>
<p><code>"remove"</code> &ndash; leave one point of the duplicate points.

</p>
</li></ul>

</td></tr>
<tr><td><code id="tri.mesh_+3A_jitter">jitter</code></td>
<td>
<p>logical, adds some jitter to both coordinates as this can 
help in situations with too much colinearity. Default is <code>FALSE</code>.
Some error conditions within C++ code can also lead to enabling this 
internally (a warning will be displayed). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a Delaunay triangulation of a set of
arbitrarily distributed points in the plane referred to as
nodes.
</p>
<p>The Delaunay triangulation is defined as a set of triangles with the
following five properties:
</p>

<ol>
<li><p> The triangle vertices are nodes.
</p>
</li>
<li><p> No triangle contains a node other than its vertices.
</p>
</li>
<li><p> The interiors of the triangles are pairwise disjoint.
</p>
</li>
<li><p> The union of triangles is the convex hull of the set
of nodes (the smallest convex set which contains
the nodes).
</p>
</li>
<li><p> The interior of the circumcircle of each triangle
contains no node.
</p>
</li></ol>

<p>The first four properties define a triangulation, and the
last property results in a triangulation which is as close
as possible to equiangular in a certain sense and which is
uniquely defined unless four or more nodes lie on a common
circle.  This property makes the triangulation well-suited
for solving closest point problems and for triangle-based
interpolation.
</p>
<p>This triangulation is based on the s-hull algorithm by David
Sinclair. It consist of two steps:
</p>

<ol>
<li>
<p>Create an initial non-overlapping triangulation from the
radially sorted nodes (w.r.t to an arbitrary first
node). Starting from a first triangle built from the first node
and its nearest neigbours this is done by adding triangles from the
next node (in the sense of distance to the first node) to the hull
of the actual triangulation visible from this node (sweep hull
step).

</p>
</li>
<li>
<p>Apply triange flipping to each pair of triangles sharing a
border until condition 5 holds (Cline-Renka test).

</p>
</li></ol>

<p>This algorithm has complexicity <code class="reqn">O(n*log(n))</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"triSht"</code>, see <code><a href="#topic+triSht">triSht</a></code>.
</p>


<h3>Note</h3>

<p>This function is meant as a replacement for function
<code>tri.mesh</code> from package <code>tripack</code>.
Please note that the underlying algorithm changed from Renka's method
to Sinclair's sweep hull method. Delaunay triangulations are unique if
no four or more points exist which share the same
circumcircle. Otherwise several solutions are available and different
algorithms will give different results. This especially holds for
regular grids, where in the case of rectangular gridded points each
grid cell can be triangulated in two different ways.
</p>
<p>The arguments are backward compatible, but the returned object
is not compatible with package <code>tripack</code> (it
provides a <code>tri</code> object type)! But you
can apply methods with same names to the object returned in package
<code>interp</code> which is of type <code><a href="#topic+triSht">triSht</a></code>, so you can reuse
your old code but you cannot reuse your old saved workspace.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>B. Delaunay, Sur la sphere vide. A la memoire de Georges Voronoi,
Bulletin de l'Academie des Sciences de l'URSS. Classe des sciences
mathematiques et na, 1934, no. 6, p. 793&ndash;800
</p>
<p>D. A. Sinclair, S-Hull: A Fast Radial Sweep-Hull Routine for Delaunay
Triangulation. https://arxiv.org/pdf/1604.01428.pdf, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>, <code><a href="#topic+plot.triSht">plot.triSht</a></code>,
<code><a href="#topic+summary.triSht">summary.triSht</a></code>, <code><a href="#topic+triangles">triangles</a></code>,
<code><a href="#topic+convex.hull">convex.hull</a></code>, <code><a href="#topic+arcs">arcs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use Frankes datasets:
data(franke)
tr1 &lt;- tri.mesh(franke$ds3$x, franke$ds3$y)
tr1
tr2 &lt;- tri.mesh(franke$ds2)
summary(tr2)
</code></pre>

<hr>
<h2 id='triangles'>Extract a list of triangles from a triangulation object</h2><span id='topic+triangles'></span>

<h3>Description</h3>

<p>This function extracts a list of triangles
from an triangulation object created by <code>tri.mesh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangles(tri.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangles_+3A_tri.obj">tri.obj</code></td>
<td>
<p>object of class <code><a href="#topic+triSht">triSht</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vertices in the returned matrix (let's denote it with
<code>retval</code>) are ordered counterclockwise.  The columns <code>tr</code><code class="reqn">x</code>
and <code>arc</code><code class="reqn">x</code>, <code class="reqn">x=1,2,3</code> index the triangle and arc, respectively,
which are opposite (not shared by) node <code>node</code><code class="reqn">x</code>, with
<code>tri</code><code class="reqn">x=0</code> if <code>arc</code><code class="reqn">x</code> indexes a boundary arc.  Vertex indexes
range from 1 to <code class="reqn">n</code>, the number of nodes, triangle indexes from 0
to <code class="reqn">nt</code>, and arc indexes from 1 to <code class="reqn">na = nt+n-1</code>.
</p>


<h3>Value</h3>

<p>A matrix with columns <code>node1</code>, <code>node2</code>, <code>node3</code>,
representing the vertex nodal indexes,
<code>tr1</code>, <code>tr2</code>, <code>tr3</code>, representing neighboring triangle
indexes and <code>arc1</code>, <code>arc2</code>, <code>arc3</code> reresenting arc
indexes.
</p>
<p>Each row represents one triangle.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triSht">triSht</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>,
<code><a href="#topic+plot.triSht">plot.triSht</a></code>, <code><a href="#topic+summary.triSht">summary.triSht</a></code>,
<code><a href="#topic+triangles">triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the smallest Franke data set
data(franke)
fr3.tr&lt;-tri.mesh(franke$ds3$x, franke$ds3$y)
triangles(fr3.tr)
</code></pre>

<hr>
<h2 id='triSht'>A triangulation object</h2><span id='topic+triSht'></span>

<h3>Description</h3>

<p>R object that represents the triangulation of a set of 2D points,
generated by <code><a href="#topic+tri.mesh">tri.mesh</a></code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triSht_+3A_n">n</code></td>
<td>
<p>Number of nodes</p>
</td></tr>
<tr><td><code id="triSht_+3A_x">x</code></td>
<td>
<p><code class="reqn">x</code> coordinates of the triangulation nodes</p>
</td></tr>
<tr><td><code id="triSht_+3A_y">y</code></td>
<td>
<p><code class="reqn">y</code> coordinates of the triangulation nodes</p>
</td></tr>
<tr><td><code id="triSht_+3A_nt">nt</code></td>
<td>
<p>number of triangles</p>
</td></tr>
<tr><td><code id="triSht_+3A_trlist">trlist</code></td>
<td>
<p>Matrix of indices which defines the triangulation,
each row corresponds to a triangle.
</p>
<p>Columns <code>i1</code>, <code>i2</code>, <code>i3</code> of the row <code class="reqn">i</code> contain
the node indices defining the <code class="reqn">i</code>th triangle.
</p>
<p>Columns <code>j1</code>, <code>j2</code>, <code>j3</code> of the row <code class="reqn">i</code> contain
the indices of neighbour triangles (or 0 if no neighbour available
along the convex hull).
</p>
<p>Columns <code>k1</code>, <code>k2</code>, <code>k3</code> of the row <code class="reqn">i</code> contain
the indices of the arcs of the <code class="reqn">i</code>th triangle as returned by the
<code><a href="#topic+arcs">arcs</a></code> function.
</p>
</td></tr>
<tr><td><code id="triSht_+3A_cclist">cclist</code></td>
<td>

<p>Matrix describing the circumcircles and triangles.
</p>
<p>Columns <code>x</code> and <code>y</code> contain coordinates of the
circumcircle centers, <code>r</code> is the circumcircle radius.
</p>
<p><code>area</code> is the triangle area and <code>ratio</code> is the ratio of
the radius of the inscribed circle to the circumcircle radius. It
takes it maximum value 0.5 for an equilateral triangle.
</p>
<p>The radius of the inscribed circle can be get via
<code class="reqn">r_i=\frac{r}{ratio}</code>.
</p>
</td></tr>
<tr><td><code id="triSht_+3A_nchull">nchull</code></td>
<td>
<p>number of points on the convex hull</p>
</td></tr>
<tr><td><code id="triSht_+3A_chull">chull</code></td>
<td>

<p>A vector containing the indices of nodes forming the convec hull (in
counterclockwise ordering).
</p>
</td></tr>
<tr><td><code id="triSht_+3A_narcs">narcs</code></td>
<td>
<p>number of arcs forming the triangulation</p>
</td></tr>
<tr><td><code id="triSht_+3A_arcs">arcs</code></td>
<td>
<p>A matrix with node indices describing the arcs, contains
two columns <code>from</code> and <code>to</code>.
</p>
</td></tr>
<tr><td><code id="triSht_+3A_call">call</code></td>
<td>
<p>call, which generated this object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This object is not backward compatible with <code>tri</code> objects generated
from package <code>tripack</code> but the functions and methods are! So you
have to regenerate these objects and then you can continue to use the
same calls as before.
</p>
<p>The only difference is that no constraints to the triangulation are
possible in package <code>interp</code>.
</p>
<p>Function <code>triSht2tri</code> provides an option to convert this object into
the older form from package <code>tripack</code>, but it will not generate exact
copies as if the object would have been created with <code>tripack::tri.mesh</code>!
The old data structure consists of three lists describing adjacency lists
of triangulation nodes in counterclockwise order, the translation function 
only genrates such a valid (but not unique) description. 
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tri.mesh">tri.mesh</a></code>, <code><a href="#topic+print.triSht">print.triSht</a></code>,<code><a href="#topic+triSht2tri">triSht2tri</a></code>, 
<code><a href="#topic+plot.triSht">plot.triSht</a></code>, <code><a href="#topic+summary.triSht">summary.triSht</a></code>
</p>

<hr>
<h2 id='triSht2tri'>
Converter to tripack objects
</h2><span id='topic+triSht2tri'></span>

<h3>Description</h3>

<p>This function converts <code>triSht</code> objects (from this package) to <code>tri</code> objects (from tripack package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triSht2tri(t.triSht)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triSht2tri_+3A_t.trisht">t.triSht</code></td>
<td>

<p>a class <code>triSht</code> object as returned by <code>tri.mesh</code> 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class <code>tri</code> object, see tripack package.
</p>


<h3>Note</h3>

<p>The converted objects are not fully compatible with <code>tripack</code> functions. Basic stuff (printing, plotting) works, <code>tripack::triangles</code> e.g. does not work.
Voronoi functions from package <code>tripack</code> are working correctly with translated objects.
</p>


<h3>Author(s)</h3>

<p>A. Gebhardt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tri.mesh">tri.mesh</a></code>,
<code><a href="#topic+triSht">triSht</a></code>
</p>

<hr>
<h2 id='tritest'> tritest / sample data </h2><span id='topic+tritest'></span><span id='topic+tritest2'></span>

<h3>Description</h3>

<p>A very simply set set of points to test the tripack functions, taken
from the FORTRAN original. <code>tritest2</code> is a slight modification by 
adding <code>runif(,-0.1,0.1)</code> random numbers to the coordinates.
</p>


<h3>References</h3>

<p>R. J. Renka (1996). Algorithm 751: TRIPACK: a constrained
two-dimensional Delaunay triangulation package.
ACM Transactions on Mathematical Software.
<b>22</b>, 1-8.
</p>

<hr>
<h2 id='voronoi'>Voronoi object</h2><span id='topic+voronoi'></span>

<h3>Description</h3>

<p>A <code>voronoi</code> object is created with <code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi_+3A_x">x</code>, <code id="voronoi_+3A_y">y</code></td>
<td>
<p>x and y coordinates of nodes of the voronoi mosaic. Each node is a
circumcircle center of some triangle from the Delaunay triangulation.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_node">node</code></td>
<td>
<p>logical vector, indicating real nodes of the voronoi
mosaic. These nodes are the centers of circumcircles of triangles with
positive area of the delaunay triangulation.
</p>
<p>If <code>node[i]</code>=<code>FALSE</code>, (<code>c[i]</code>,<code>x[i]</code>) belongs to a
triangle with area 0.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_n1">n1</code>, <code id="voronoi_+3A_n2">n2</code>, <code id="voronoi_+3A_n3">n3</code></td>
<td>
<p>indices of neighbour nodes. Negative indices indicate
dummy points as neighbours.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_tri">tri</code></td>
<td>
<p>triangulation object, see <code><a href="#topic+triSht">triSht</a></code>.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_area">area</code></td>
<td>
<p>area of triangle <code class="reqn">i</code>.
</p>
</td></tr>
<tr><td><code id="voronoi_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio (inscribed radius/circumradius) of triangle
<code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_radius">radius</code></td>
<td>
<p>circumradius of triangle i.</p>
</td></tr>
<tr><td><code id="voronoi_+3A_dummy.x">dummy.x</code>, <code id="voronoi_+3A_dummy.y">dummy.y</code></td>
<td>
<p>x and y coordinates of dummy points. They are
used for plotting of unbounded tiles.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This version of <code>voronoi</code> object is generated from the
<code><a href="#topic+tri.mesh">tri.mesh</a></code> function from package <code>interp</code>. That's the only
difference to <code>voronoi</code> objects generated with package
<code>tripack</code>.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,<code><a href="#topic+plot.voronoi">plot.voronoi</a></code>
</p>

<hr>
<h2 id='voronoi.area'>Calculate area of Voronoi polygons</h2><span id='topic+voronoi.area'></span>

<h3>Description</h3>

<p>Computes the area of each Voronoi polygon.
For some sites at the edge of the region, the Voronoi polygon is not
bounded, and so the area of those sites cannot be calculated, and hence
will be <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.area(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi.area_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of polygon areas.</p>


<h3>Author(s)</h3>

<p>S. J. Eglen</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,<code><a href="#topic+voronoi.polygons">voronoi.polygons</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
fd3 &lt;- franke$ds3
fd3.vm &lt;- voronoi.mosaic(fd3$x,fd3$y)
fd3.vm.areas &lt;- voronoi.area(fd3.vm)
plot(fd3.vm)
text(fd3$x, fd3$y, round(fd3.vm.areas,5))
</code></pre>

<hr>
<h2 id='voronoi.findrejectsites'>Find the Voronoi sites at the border of the region (to be rejected).</h2><span id='topic+voronoi.findrejectsites'></span>

<h3>Description</h3>

<p>Find the sites in the Voronoi tesselation that lie at the
edge of the region.  A site is at the edge if any of the vertices of
its Voronoi polygon lie outside the rectangle with corners (xmin,ymin)
and (xmax,ymax).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.findrejectsites(voronoi.obj, xmin, xmax, ymin, ymax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi.findrejectsites_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p>object of class <code>"voronoi"</code></p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_xmax">xmax</code></td>
<td>
<p>maximum x-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_ymin">ymin</code></td>
<td>
<p>minimum y-coordinate of sites in the region</p>
</td></tr>
<tr><td><code id="voronoi.findrejectsites_+3A_ymax">ymax</code></td>
<td>
<p>maximum y-coordinate of sites in the region</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as the number of sites.  If
the site is a reject, the corresponding element of the vector is set
to TRUE.</p>


<h3>Author(s)</h3>

<p>S. J. Eglen</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi.polygons">voronoi.polygons</a></code>
</p>

<hr>
<h2 id='voronoi.mosaic'>
Voronoi mosaic
</h2><span id='topic+voronoi.mosaic'></span>

<h3>Description</h3>

<p>This function creates a Voronoi mosaic out of a given set of
arbitraryly located points in the plane. Each cell of a voronoi
mosaic is associated with a data point and contains all points
<code class="reqn">(x,y)</code> closest to this data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.mosaic(x, y = NULL, duplicate = "error")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi.mosaic_+3A_x">x</code></td>
<td>

<p>vector containing <code class="reqn">x</code> coordinates of the data. If <code>y</code> is missing
<code>x</code> should be a list or dataframe with two components <code>x</code>
and <code>y</code>.
</p>
<p><code>x</code> can also be an object of class <code><a href="#topic+triSht">triSht</a></code> generated
by <code><a href="#topic+tri.mesh">tri.mesh</a></code>. In this case the internal triangulation
step can be skipped.
</p>
</td></tr>
<tr><td><code id="voronoi.mosaic_+3A_y">y</code></td>
<td>

<p>vector containing <code class="reqn">y</code> coordinates of the data. Can be omitted if
<code>x</code> is a list with two components <code>x</code> and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="voronoi.mosaic_+3A_duplicate">duplicate</code></td>
<td>

<p>flag indicating how to handle duplicate elements.
Possible values are:
</p>

<ul>
<li>
<p><code>"error"</code> &ndash; default,

</p>
</li>
<li>
<p><code>"strip"</code> &ndash; remove all duplicate points,

</p>
</li>
<li>
<p><code>"remove"</code> &ndash; leave one point of the duplicate points.

</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The function creates first a Delaunay triangulation (if not already
given), extracts the circumcircle centers of these triangles, and then
connects these points according to the neighbourhood relations between
the triangles.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+voronoi">voronoi</a></code>.
</p>


<h3>Note</h3>

<p>This function is meant as a replacement for function
<code>voronoi.mosaic</code> from package <code>tripack</code>.
Please note that the underlying triangulation uses a
different algorithm, see <code><a href="#topic+tri.mesh">tri.mesh</a></code>. Contrary to
<code>tri.mesh</code> this should not affect the result for non
unique triangulations e.g. on regular grids as the voronoi mosaic in
this case will still be unique.
</p>
<p>The arguments are backward compatible, even the returned object should be
compatible with functions from package <code>tripack</code>.
</p>


<h3>Author(s)</h3>

<p>Albrecht Gebhardt &lt;albrecht.gebhardt@aau.at&gt;,
Roger Bivand &lt;roger.bivand@nhh.no&gt;
</p>


<h3>References</h3>

<p>G. Voronoi, Nouvelles applications des parametres continus a la theorie
des formes quadratiques. Deuxieme memoire. Recherches sur les
parallelloedres primitifs, Journal fuer die reine und angewandte
Mathematik, 1908, vol 134, p. 198-287
</p>


<h3>See Also</h3>

<p><code><a href="#topic+voronoi">voronoi</a></code>,<code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code>,
<code><a href="#topic+print.voronoi">print.voronoi</a></code>, <code><a href="#topic+plot.voronoi">plot.voronoi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
fd &lt;- franke$ds3
vr &lt;- voronoi.mosaic(fd$x, fd$y)
summary(vr)
</code></pre>

<hr>
<h2 id='voronoi.polygons'> extract polygons from a voronoi mosaic </h2><span id='topic+voronoi.polygons'></span>

<h3>Description</h3>

<p>This functions extracts polygons from a <code>voronoi.mosaic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons(voronoi.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi.polygons_+3A_voronoi.obj">voronoi.obj</code></td>
<td>
<p> object of class <code>voronoi.mosaic</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>voronoi.polygons</code> with unamed list
elements for each polygon. These list
elements are matrices with columns <code>x</code> and <code>y</code>.
Unbounded polygons along the border are represented by <code>NULL</code>
instead of a matrix.
</p>


<h3>Author(s)</h3>

<p> Denis White </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.voronoi.polygons">plot.voronoi.polygons</a></code>,<code><a href="#topic+voronoi.mosaic">voronoi.mosaic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(franke)
fd3 &lt;- franke$ds3
fd3.vm &lt;- voronoi.mosaic(fd3$x,fd3$y)
fd3.vp &lt;- voronoi.polygons(fd3.vm)
fd3.vp
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
