<!DOCTYPE html><html><head><title>Help for package adamethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adamethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adalara'><p>Multivariate parallel archetypoid algorithm for large applications (ADALARA)</p></a></li>
<li><a href='#adalara_no_paral'><p>Multivariate non-parallel archetypoid algorithm for large applications (ADALARA)</p></a></li>
<li><a href='#archetypoids_funct'><p>Archetypoid algorithm with the functional Frobenius norm</p></a></li>
<li><a href='#archetypoids_funct_multiv'><p>Archetypoid algorithm with the functional multivariate Frobenius norm</p></a></li>
<li><a href='#archetypoids_funct_multiv_robust'><p>Archetypoid algorithm with the functional multivariate robust Frobenius norm</p></a></li>
<li><a href='#archetypoids_funct_robust'><p>Archetypoid algorithm with the functional robust Frobenius norm</p></a></li>
<li><a href='#archetypoids_norm_frob'><p>Archetypoid algorithm with the Frobenius norm</p></a></li>
<li><a href='#archetypoids_robust'><p>Archetypoid algorithm with the robust Frobenius norm</p></a></li>
<li><a href='#bisquare_function'><p>Bisquare function</p></a></li>
<li><a href='#do_ada'><p>Run the whole classical archetypoid analysis with the Frobenius norm</p></a></li>
<li><a href='#do_ada_robust'><p>Run the whole robust archetypoid analysis with the robust Frobenius norm</p></a></li>
<li><a href='#do_alphas_rss'><p>Alphas and RSS of every set of archetypoids</p></a></li>
<li><a href='#do_alphas_rss_multiv'><p>Alphas and RSS of every set of multivariate archetypoids</p></a></li>
<li><a href='#do_clean'><p>Cleaning outliers</p></a></li>
<li><a href='#do_clean_multiv'><p>Cleaning multivariate functional outliers</p></a></li>
<li><a href='#do_fada'><p>Run the whole functional archetypoid analysis with the Frobenius norm</p></a></li>
<li><a href='#do_fada_multiv'><p>Run the whole archetypoid analysis with the functional multivariate Frobenius norm</p></a></li>
<li><a href='#do_fada_multiv_robust'><p>Run the whole archetypoid analysis with the functional multivariate robust Frobenius norm</p></a></li>
<li><a href='#do_fada_robust'><p>Run the whole archetypoid analysis with the functional robust Frobenius norm</p></a></li>
<li><a href='#do_knno'><p>kNN for outlier detection</p></a></li>
<li><a href='#do_outl_degree'><p>Degree of outlierness</p></a></li>
<li><a href='#fadalara'><p>Functional parallel archetypoid algorithm for large applications (FADALARA)</p></a></li>
<li><a href='#fadalara_no_paral'><p>Functional non-parallel archetypoid algorithm for large applications (FADALARA)</p></a></li>
<li><a href='#frame_in_r'><p>Compute archetypes frame</p></a></li>
<li><a href='#frobenius_norm'><p>Frobenius norm</p></a></li>
<li><a href='#frobenius_norm_funct'><p>Functional Frobenius norm</p></a></li>
<li><a href='#frobenius_norm_funct_multiv'><p>Functional multivariate Frobenius norm</p></a></li>
<li><a href='#frobenius_norm_funct_multiv_robust'><p>Functional multivariate robust Frobenius norm</p></a></li>
<li><a href='#frobenius_norm_funct_robust'><p>Functional robust Frobenius norm</p></a></li>
<li><a href='#frobenius_norm_robust'><p>Robust Frobenius norm</p></a></li>
<li><a href='#int_prod_mat'><p>Interior product between matrices</p></a></li>
<li><a href='#int_prod_mat_funct'><p>Interior product between matrices for FDA</p></a></li>
<li><a href='#int_prod_mat_sq'><p>Squared interior product between matrices</p></a></li>
<li><a href='#int_prod_mat_sq_funct'><p>Squared interior product between matrices for FDA</p></a></li>
<li><a href='#outl_toler'><p>Tolerance outliers</p></a></li>
<li><a href='#stepArchetypesRawData_funct'><p>Archetype algorithm to raw data with the functional Frobenius norm</p></a></li>
<li><a href='#stepArchetypesRawData_funct_multiv'><p>Archetype algorithm to raw data with the functional multivariate Frobenius norm</p></a></li>
<li><a href='#stepArchetypesRawData_funct_multiv_robust'><p>Archetype algorithm to raw data with the functional multivariate robust Frobenius norm</p></a></li>
<li><a href='#stepArchetypesRawData_funct_robust'><p>Archetype algorithm to raw data with the functional robust Frobenius norm</p></a></li>
<li><a href='#stepArchetypesRawData_norm_frob'><p>Archetype algorithm to raw data with the Frobenius norm</p></a></li>
<li><a href='#stepArchetypesRawData_robust'><p>Archetype algorithm to raw data with the robust Frobenius norm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Archetypoid Algorithms and Anomaly Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillermo Vinue, Irene Epifanio</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillermo Vinue &lt;Guillermo.Vinue@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of several algorithms to obtain archetypoids with small and large databases, and with both classical 
	multivariate data and functional data (univariate and multivariate). Some of these algorithms also allow to detect 
	anomalies (outliers). Please see Vinue and Epifanio (2020) &lt;<a href="https://doi.org/10.1007%2Fs11634-020-00412-9">doi:10.1007/s11634-020-00412-9</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Anthropometry, archetypes, FNN, foreach, graphics, nnls,
parallel, stats, tolerance, univOutl, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, fda</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-04 09:51:01 UTC; guillevinue</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-04 12:30:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='adalara'>Multivariate parallel archetypoid algorithm for large applications (ADALARA)</h2><span id='topic+adalara'></span>

<h3>Description</h3>

<p>The ADALARA algorithm is based on the CLARA clustering algorithm. This is the 
parallel version of the algorithm to try to get faster results. It allows to
detect anomalies (outliers). There are two different methods to detect them:
the adjusted boxplot (default and most reliable option) and tolerance intervals.
If needed, tolerance intervals allow to define a degree of outlierness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adalara(data, N, m, numArchoid, numRep, huge, prob, type_alg = "ada", 
        compare = FALSE, vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
        outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"), 
        method = "adjbox", frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adalara_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric. The data must have row names
so that the algorithm can identify the archetypoids in every sample.</p>
</td></tr>
<tr><td><code id="adalara_+3A_n">N</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="adalara_+3A_m">m</code></td>
<td>
<p>Sample size of each sample.</p>
</td></tr>
<tr><td><code id="adalara_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="adalara_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArchoid</code>, run the archetype algorithm <code>numRep</code> 
times.</p>
</td></tr>
<tr><td><code id="adalara_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="adalara_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="adalara_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'ada' for the non-robust adalara algorithm and 
'ada_rob' for the robust adalara algorithm.</p>
</td></tr>
<tr><td><code id="adalara_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
if <code>type_alg = "ada"</code> and the non-robust if <code>type_alg = "ada_rob"</code>.</p>
</td></tr>
<tr><td><code id="adalara_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector with the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;). 
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
<tr><td><code id="adalara_+3A_frame">frame</code></td>
<td>
<p>Boolean value to indicate whether the frame is 
computed (Mair et al., 2017) or not. The frame is made up of a subset of
extreme points, so the archetypoids are only computed on the frame. 
Low frame densities are obtained when only small portions of the data were extreme.
However, high frame densities reduce this speed-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases Optimal vector of archetypoids.
</p>
</li>
<li><p> rss Optimal residual sum of squares.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Hubert, M. and Vandervieren, E., An adjusted boxplot for skewed distributions, 2008.
<em>Computational Statistics and Data Analysis</em> <b>52(12)</b>, 5186-5201,
<a href="https://doi.org/10.1016/j.csda.2007.11.008">https://doi.org/10.1016/j.csda.2007.11.008</a>
</p>
<p>Kaufman, L. and Rousseeuw, P.J., Clustering Large Data Sets, 1986.
<em>Pattern Recognition in Practice</em>, 425-437.
</p>
<p>Mair, S., Boubekki, A. and Brefeld, U., Frame-based Data Factorizations, 2017.
Proceedings of the 34th International Conference on Machine Learning, 
Sydney, Australia, 1-9.
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do_ada">do_ada</a></code>, <code><a href="#topic+do_ada_robust">do_ada_robust</a></code>, <code><a href="#topic+adalara_no_paral">adalara_no_paral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Anthropometry)
library(doParallel)

# Prepare parallelization (including the seed for reproducibility):
no_cores &lt;- detectCores() - 1
cl &lt;- makeCluster(no_cores)
registerDoParallel(cl)
clusterSetRNGStream(cl, iseed = 1)

# Load data:
data(mtcars)
data &lt;- mtcars
n &lt;- nrow(data)

# Arguments for the archetype/archetypoid algorithm:
# Number of archetypoids:
k &lt;- 3 
numRep &lt;- 2
huge &lt;- 200

# Size of the random sample of observations:
m &lt;- 10
# Number of samples:
N &lt;- floor(1 + (n - m)/(m - k))
N
           
prob &lt;- 0.75            

# ADALARA algorithm:
preproc &lt;- preprocessing(data, stand = TRUE, percAccomm = 1)
data1 &lt;- as.data.frame(preproc$data)

adalara_aux &lt;- adalara(data1, N, m, k, numRep, huge, prob, 
                       "ada_rob", FALSE, method = "adjbox", frame = FALSE)

#adalara_aux &lt;- adalara(data1, N, m, k, numRep, huge, prob, 
#                       "ada_rob", FALSE, vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
#                       outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
#                       method = "toler", frame = FALSE)

# Take the minimum RSS, which is in the second position of every sublist:
adalara &lt;- adalara_aux[which.min(unlist(sapply(adalara_aux, function(x) x[2])))][[1]]
adalara

# End parallelization:
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='adalara_no_paral'>Multivariate non-parallel archetypoid algorithm for large applications (ADALARA)</h2><span id='topic+adalara_no_paral'></span>

<h3>Description</h3>

<p>The ADALARA algorithm is based on the CLARA clustering algorithm. This is the 
non-parallel version of the algorithm. It allows to detect anomalies (outliers). 
There are two different methods to detect them: the adjusted boxplot (default 
and most reliable option) and tolerance intervals.
If needed, tolerance intervals allow to define a degree of outlierness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adalara_no_paral(data, seed, N, m, numArchoid, numRep, huge, prob, type_alg = "ada", 
                 compare = FALSE, verbose = TRUE, vect_tol = c(0.95, 0.9, 0.85), 
                 alpha = 0.05, outl_degree = c("outl_strong", "outl_semi_strong", 
                 "outl_moderate"), method = "adjbox", frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adalara_no_paral_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric. 
The data must have row names so that the algorithm can identify the archetypoids 
in every sample.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_seed">seed</code></td>
<td>
<p>Integer value to set the seed. This ensures reproducibility.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_n">N</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_m">m</code></td>
<td>
<p>Sample size of each sample.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArchoid</code>, run the archetype algorithm <code>numRep</code> 
times.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'ada' for the non-robust adalara algorithm and 
'ada_rob' for the robust adalara algorithm.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
if <code>type_alg = "ada"</code> and the non-robust if <code>type_alg = "ada_rob"</code>.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_verbose">verbose</code></td>
<td>
<p>Display progress? Default TRUE.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
<tr><td><code id="adalara_no_paral_+3A_frame">frame</code></td>
<td>
<p>Boolean value to indicate whether the frame is 
computed (Mair et al., 2017) or not. The frame is made up of a subset of
extreme points, so the archetypoids are only computed on the frame. 
Low frame densities are obtained when only small portions of the data were extreme.
However, high frame densities reduce this speed-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases Optimal vector of archetypoids.
</p>
</li>
<li><p> rss Optimal residual sum of squares.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Hubert, M. and Vandervieren, E., An adjusted boxplot for skewed distributions, 2008.
<em>Computational Statistics and Data Analysis</em> <b>52(12)</b>, 5186-5201,
<a href="https://doi.org/10.1016/j.csda.2007.11.008">https://doi.org/10.1016/j.csda.2007.11.008</a>
</p>
<p>Kaufman, L. and Rousseeuw, P.J., Clustering Large Data Sets, 1986.
<em>Pattern Recognition in Practice</em>, 425-437.
</p>
<p>Mair, S., Boubekki, A. and Brefeld, U., Frame-based Data Factorizations, 2017.
Proceedings of the 34th International Conference on Machine Learning, 
Sydney, Australia, 1-9.
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do_ada">do_ada</a></code>, <code><a href="#topic+do_ada_robust">do_ada_robust</a></code>, <code><a href="#topic+adalara">adalara</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Anthropometry)

# Load data:
data(mtcars)
data &lt;- mtcars
n &lt;- nrow(data)

# Arguments for the archetype/archetypoid algorithm:
# Number of archetypoids:
k &lt;- 3 
numRep &lt;- 2
huge &lt;- 200

# Size of the random sample of observations:
m &lt;- 10
# Number of samples:
N &lt;- floor(1 + (n - m)/(m - k))
N
           
prob &lt;- 0.75            

# ADALARA algorithm:
preproc &lt;- preprocessing(data, stand = TRUE, percAccomm = 1)
data1 &lt;- as.data.frame(preproc$data)
res_adalara &lt;- adalara_no_paral(data1, 1, N, m, k, 
                                numRep, huge, prob, "ada_rob", FALSE, TRUE, 
                                method = "adjbox", frame = FALSE)

# Examine the results:
res_adalara

res_adalara1 &lt;- adalara_no_paral(data1, 1, N, m, k, 
                                numRep, huge, prob, "ada_rob", FALSE, TRUE, 
                                vect_tol = c(0.95, 0.9, 0.85), 
                                alpha = 0.05, outl_degree = c("outl_strong", "outl_semi_strong", 
                                                              "outl_moderate"),
                                method = "toler", frame = FALSE)
res_adalara1                                 
                                 

## End(Not run)
                                                                                                                                                             
</code></pre>

<hr>
<h2 id='archetypoids_funct'>Archetypoid algorithm with the functional Frobenius norm</h2><span id='topic+archetypoids_funct'></span>

<h3>Description</h3>

<p>Archetypoid algorithm with the functional Frobenius norm 
to be used with functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_funct(numArchoid, data, huge = 200, ArchObj, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_funct_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_funct">stepArchetypesRawData_funct</a></code> function.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)
# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

lass &lt;- stepArchetypesRawData_funct(data = data_archs, numArch = 3, 
                                    numRep = 5, verbose = FALSE, 
                                    saveHistory = FALSE, PM)

af &lt;- archetypoids_funct(3, data_archs, huge = 200, ArchObj = lass, PM) 
str(af)                                

## End(Not run)                                                          
                                                     
</code></pre>

<hr>
<h2 id='archetypoids_funct_multiv'>Archetypoid algorithm with the functional multivariate Frobenius norm</h2><span id='topic+archetypoids_funct_multiv'></span>

<h3>Description</h3>

<p>Archetypoid algorithm with the functional multivariate Frobenius norm 
to be used with functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_funct_multiv(numArchoid, data, huge = 200, ArchObj, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_funct_multiv_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_funct">stepArchetypesRawData_funct</a></code> function.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

lass &lt;- stepArchetypesRawData_funct_multiv(data = Xs, numArch = 3, 
                                           numRep = 5, verbose = FALSE, 
                                           saveHistory = FALSE, PM)
                                           
afm &lt;- archetypoids_funct_multiv(3, Xs, huge = 200, ArchObj = lass, PM)
str(afm)

## End(Not run)                                                          
                                                     
</code></pre>

<hr>
<h2 id='archetypoids_funct_multiv_robust'>Archetypoid algorithm with the functional multivariate robust Frobenius norm</h2><span id='topic+archetypoids_funct_multiv_robust'></span>

<h3>Description</h3>

<p>Archetypoid algorithm with the functional multivariate robust Frobenius norm 
to be used with functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_funct_multiv_robust(numArchoid, data, huge = 200, ArchObj, PM, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_funct">stepArchetypesRawData_funct</a></code> function.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_multiv_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

lass &lt;- stepArchetypesRawData_funct_multiv_robust(data = Xs, numArch = 3, 
                                                  numRep = 5, verbose = FALSE, 
                                                  saveHistory = FALSE, PM, prob = 0.8, 
                                                  nbasis, nvars)

afmr &lt;- archetypoids_funct_multiv_robust(3, Xs, huge = 200, ArchObj = lass, PM, 0.8)
str(afmr)

## End(Not run)                                                          
                                                     
</code></pre>

<hr>
<h2 id='archetypoids_funct_robust'>Archetypoid algorithm with the functional robust Frobenius norm</h2><span id='topic+archetypoids_funct_robust'></span>

<h3>Description</h3>

<p>Archetypoid algorithm with the functional robust Frobenius norm 
to be used with functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_funct_robust(numArchoid, data, huge = 200, ArchObj, PM, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_funct_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_robust_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_robust_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_funct_robust">stepArchetypesRawData_funct_robust</a></code> function.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="archetypoids_funct_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)
# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

lass &lt;- stepArchetypesRawData_funct_robust(data = data_archs, numArch = 3, 
                                           numRep = 5, verbose = FALSE, 
                                           saveHistory = FALSE, PM, prob = 0.8)

afr &lt;- archetypoids_funct_robust(3, data_archs, huge = 200, ArchObj = lass, PM, 0.8)
str(afr)

## End(Not run)                                                          
                                                     
</code></pre>

<hr>
<h2 id='archetypoids_norm_frob'>Archetypoid algorithm with the Frobenius norm</h2><span id='topic+archetypoids_norm_frob'></span>

<h3>Description</h3>

<p>This function is the same as <code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code> but the 2-norm 
is replaced by the Frobenius norm. Thus, the comparison with the robust archetypoids
can be directly made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_norm_frob(numArchoid, data, huge = 200, ArchObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_norm_frob_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_norm_frob_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_norm_frob_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_norm_frob_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_norm_frob">stepArchetypesRawData_norm_frob</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., Archetypoids: a new approach to 
define representative archetypal data, 2015.
<em>Computational Statistics and Data Analysis</em> <b>87</b>, 102-115,
<a href="https://doi.org/10.1016/j.csda.2015.01.018">https://doi.org/10.1016/j.csda.2015.01.018</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- mtcars

k &lt;- 3
numRep &lt;- 2
huge &lt;- 200

lass &lt;- stepArchetypesRawData_norm_frob(data = data, numArch = k, 
                                        numRep = numRep, verbose = FALSE)

res &lt;- archetypoids_norm_frob(k, data, huge, ArchObj = lass)
str(res)  
res$cases
res$rss                                                           

</code></pre>

<hr>
<h2 id='archetypoids_robust'>Archetypoid algorithm with the robust Frobenius norm</h2><span id='topic+archetypoids_robust'></span>

<h3>Description</h3>

<p>Robust version of the archetypoid algorithm with the Frobenius form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids_robust(numArchoid, data, huge = 200, ArchObj, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypoids.</p>
</td></tr>
<tr><td><code id="archetypoids_robust_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric.</p>
</td></tr>
<tr><td><code id="archetypoids_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="archetypoids_robust_+3A_archobj">ArchObj</code></td>
<td>
<p>The list object returned by the 
<code><a href="#topic+stepArchetypesRawData_robust">stepArchetypesRawData_robust</a></code> function.</p>
</td></tr>
<tr><td><code id="archetypoids_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> archet_ini: Vector of initial archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> resid: Matrix with the residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids_norm_frob">archetypoids_norm_frob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- mtcars

k &lt;- 3
numRep &lt;- 2
huge &lt;- 200

lass &lt;- stepArchetypesRawData_robust(data = data, numArch = k, 
                                     numRep = numRep, verbose = FALSE, 
                                     saveHistory = FALSE, prob = 0.8)

res &lt;- archetypoids_robust(k, data, huge, ArchObj = lass, 0.8)
str(res)    
res$cases
res$rss                                                           
              
</code></pre>

<hr>
<h2 id='bisquare_function'>Bisquare function</h2><span id='topic+bisquare_function'></span>

<h3>Description</h3>

<p>This function belongs to the bisquare family of loss functions.
The bisquare family can better cope with extreme outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisquare_function(resid, prob, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisquare_function_+3A_resid">resid</code></td>
<td>
<p>Vector of residuals, computed from the 
<code class="reqn">m \times n</code> residuals data matrix.</p>
</td></tr>
<tr><td><code id="bisquare_function_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="bisquare_function_+3A_...">...</code></td>
<td>
<p>Additional possible arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of real numbers.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resid &lt;- c(2.47, 11.85)  
bisquare_function(resid, 0.8)

</code></pre>

<hr>
<h2 id='do_ada'>Run the whole classical archetypoid analysis with the Frobenius norm</h2><span id='topic+do_ada'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the archetypoid analysis.
Firstly, the initial vector of archetypoids is obtained using the archetypal 
algorithm and finally, the optimal vector of archetypoids is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_ada(subset, numArchoid, numRep, huge, compare = FALSE,
              vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
              outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
              method = "adjbox", prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_ada_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In ADALARA this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_ada_robust">do_ada_robust</a></code>.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
<tr><td><code id="do_ada_+3A_prob">prob</code></td>
<td>
<p>If <code>compare=TRUE</code>, probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_rob: If <code>compare=TRUE</code>, this is the residual sum of squares using
the robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid: Vector with the residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., Archetypoids: a new approach to 
define representative archetypal data, 2015.
<em>Computational Statistics and Data Analysis</em> <b>87</b>, 102-115,
<a href="https://doi.org/10.1016/j.csda.2015.01.018">https://doi.org/10.1016/j.csda.2015.01.018</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_norm_frob">stepArchetypesRawData_norm_frob</a></code>, <code><a href="#topic+archetypoids_norm_frob">archetypoids_norm_frob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Anthropometry)
data(mtcars)
#data &lt;- as.matrix(mtcars)
data &lt;- mtcars

k &lt;- 3
numRep &lt;- 2
huge &lt;- 200

preproc &lt;- preprocessing(data, stand = TRUE, percAccomm = 1)
suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_ada &lt;- do_ada(preproc$data, k, numRep, huge, FALSE, method = "adjbox")
str(res_ada)     

res_ada1 &lt;- do_ada(preproc$data, k, numRep, huge, FALSE, 
                   vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
                   outl_degree = c("outl_strong", "outl_semi_strong", 
                                   "outl_moderate"), method = "toler")
str(res_ada1) 

res_ada2 &lt;- do_ada(preproc$data, k, numRep, huge, TRUE, method = "adjbox", prob = 0.8)
str(res_ada2) 
                 
</code></pre>

<hr>
<h2 id='do_ada_robust'>Run the whole robust archetypoid analysis with the robust Frobenius norm</h2><span id='topic+do_ada_robust'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the robust archetypoid 
analysis. Firstly, the initial vector of archetypoids is obtained using the 
robust archetypal algorithm and finally, the optimal vector of robust archetypoids 
is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_ada_robust(subset, numArchoid, numRep, huge, prob, compare = FALSE,
              vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
              outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
              method = "adjbox")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_ada_robust_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In ADALARA this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> 
times.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the non-robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_ada">do_ada</a></code>.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_ada_robust_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_non_rob: If <code>compare=TRUE</code>, this is the residual sum of squares using
the non-robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid Vector of residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_robust">stepArchetypesRawData_robust</a></code>, <code><a href="#topic+archetypoids_robust">archetypoids_robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Anthropometry)
data(mtcars)
#data &lt;- as.matrix(mtcars)
data &lt;- mtcars

k &lt;- 3
numRep &lt;- 2
huge &lt;- 200

preproc &lt;- preprocessing(data, stand = TRUE, percAccomm = 1)
suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_ada_rob &lt;- do_ada_robust(preproc$data, k, numRep, huge, 0.8,
                             FALSE, method = "adjbox")
str(res_ada_rob)    

res_ada_rob1 &lt;- do_ada_robust(preproc$data, k, numRep, huge, 0.8,
                             FALSE, vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
                             outl_degree = c("outl_strong", "outl_semi_strong", 
                                             "outl_moderate"),
                             method = "toler")
str(res_ada_rob1)  

## End(Not run)
                 
</code></pre>

<hr>
<h2 id='do_alphas_rss'>Alphas and RSS of every set of archetypoids</h2><span id='topic+do_alphas_rss'></span>

<h3>Description</h3>

<p>In the ADALARA algorithm, every time that a set of archetypoids is computed using
a sample of the data, the alpha coefficients and the associated residual sum of 
squares (RSS) for the entire data set must be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_alphas_rss(data, subset, huge, k_subset, rand_obs, alphas_subset, 
              type_alg = "ada", PM, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_alphas_rss_+3A_data">data</code></td>
<td>
<p>Data matrix with all the observations.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_subset">subset</code></td>
<td>
<p>Data matrix with a sample of the <code>data</code> observations.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_k_subset">k_subset</code></td>
<td>
<p>Archetypoids obtained from <code>subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_rand_obs">rand_obs</code></td>
<td>
<p>Sample observations that form <code>subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_alphas_subset">alphas_subset</code></td>
<td>
<p>Alpha coefficients related to <code>k_subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'ada' for the non-robust multivariate adalara 
algorithm, 'ada_rob' for the robust multivariate adalara algorithm, 'fada' for 
the non-robust fda fadalara algorithm and 'fada_rob' for the robust fda
fadalara algorithm.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>. Needed when
<code>type_alg = 'fada'</code> or <code>type_alg = 'fada_rob'</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1]. Needed when
<code>type_alg = 'ada_rob'</code> or <code>type_alg = 'fada_rob'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> rss Real number of the residual sum of squares.
</p>
</li>
<li><p> resid_rss Matrix with the residuals.
</p>
</li>
<li><p> alphas Matrix with the alpha values.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids_norm_frob">archetypoids_norm_frob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- mtcars
n &lt;- nrow(data)
m &lt;- 10

k &lt;- 3 
numRep &lt;- 2
huge &lt;- 200

suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
rand_obs_si &lt;- sample(1:n, size = m) 

si &lt;- data[rand_obs_si,]
ada_si &lt;- do_ada(si, k, numRep, huge, FALSE) 

k_si &lt;- ada_si$cases
alphas_si &lt;- ada_si$alphas
colnames(alphas_si) &lt;- rownames(si)     

rss_si &lt;- do_alphas_rss(data, si, huge, k_si, rand_obs_si, alphas_si, "ada")
str(rss_si)
                                 
</code></pre>

<hr>
<h2 id='do_alphas_rss_multiv'>Alphas and RSS of every set of multivariate archetypoids</h2><span id='topic+do_alphas_rss_multiv'></span>

<h3>Description</h3>

<p>In the ADALARA algorithm, every time that a set of archetypoids is computed using
a sample of the data, the alpha coefficients and the associated residual sum of 
squares (RSS) for the entire data set must be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_alphas_rss_multiv(data, subset, huge, k_subset, rand_obs, alphas_subset, 
                  type_alg = "ada", PM, prob, nbasis, nvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_alphas_rss_multiv_+3A_data">data</code></td>
<td>
<p>Data matrix with all the observations.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_subset">subset</code></td>
<td>
<p>Data matrix with a sample of the <code>data</code> observations.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_k_subset">k_subset</code></td>
<td>
<p>Archetypoids obtained from <code>subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_rand_obs">rand_obs</code></td>
<td>
<p>Sample observations that form <code>subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_alphas_subset">alphas_subset</code></td>
<td>
<p>Alpha coefficients related to <code>k_subset</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'ada' for the non-robust multivariate adalara 
algorithm, 'ada_rob' for the robust multivariate adalara algorithm, 'fada' for 
the non-robust fda fadalara algorithm and 'fada_rob' for the robust fda
fadalara algorithm.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>. Needed when
<code>type_alg = 'fada'</code> or <code>type_alg = 'fada_rob'</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1]. Needed when
<code>type_alg = 'ada_rob'</code> or <code>type_alg = 'fada_rob'</code>.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of basis.</p>
</td></tr>
<tr><td><code id="do_alphas_rss_multiv_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> rss Real number of the residual sum of squares.
</p>
</li>
<li><p> resid_rss Matrix with the residuals.
</p>
</li>
<li><p> alphas Matrix with the alpha values.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids_norm_frob">archetypoids_norm_frob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])
# We have to give names to the dimensions to know the 
# observations that were identified as archetypoids.
dimnames(Xs) &lt;- list(paste("Obs", 1:dim(hgtm)[2], sep = ""), 
                     1:nbasis,
                     c("boys", "girls"))

n &lt;- dim(Xs)[1] 
# Number of archetypoids:
k &lt;- 3 
numRep &lt;- 20
huge &lt;- 200

# Size of the random sample of observations:
m &lt;- 15
# Number of samples:
N &lt;- floor(1 + (n - m)/(m - k))
N
prob &lt;- 0.75
data_alg &lt;- Xs

nbasis &lt;- dim(data_alg)[2] # number of basis.
nvars &lt;- dim(data_alg)[3] # number of variables.
n &lt;- nrow(data_alg)

suppressWarnings(RNGversion("3.5.0"))
set.seed(1) 
rand_obs_si &lt;- sample(1:n, size = m)  
si &lt;- apply(data_alg, 2:3, function(x) x[rand_obs_si])  

fada_si &lt;- do_fada_multiv_robust(si, k, numRep, huge, 0.8, FALSE, PM)

k_si &lt;- fada_si$cases
alphas_si &lt;- fada_si$alphas
colnames(alphas_si) &lt;- rownames(si)

rss_si &lt;- do_alphas_rss_multiv(data_alg, si, huge, k_si, rand_obs_si, alphas_si, 
                               "fada_rob", PM, 0.8, nbasis, nvars)
str(rss_si)                                

## End(Not run)
                                 
</code></pre>

<hr>
<h2 id='do_clean'>Cleaning outliers</h2><span id='topic+do_clean'></span>

<h3>Description</h3>

<p>Cleaning of the most remarkable outliers. This improves the performance of 
the archetypoid algorithm since it is not affected by spurious points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_clean(data, num_pts, range = 1.5, out_perc = 80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_clean_+3A_data">data</code></td>
<td>
<p>Data frame with (temporal) points in the rows and observations in 
the columns.</p>
</td></tr>
<tr><td><code id="do_clean_+3A_num_pts">num_pts</code></td>
<td>
<p>Number of temporal points.</p>
</td></tr>
<tr><td><code id="do_clean_+3A_range">range</code></td>
<td>
<p>Same parameter as in function <code><a href="graphics.html#topic+boxplot">boxplot</a></code>. 
A value of 1.5 is enough to detect amplitude and shift outliers, while a value
of 3 is needed to detect isolated outliers.</p>
</td></tr>
<tr><td><code id="do_clean_+3A_out_perc">out_perc</code></td>
<td>
<p>Minimum number of temporal points (in percentage) to consider 
the observation as an outlier. Needed when <code>range=1.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the outliers.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- mtcars
num_pts &lt;- ncol(data)
do_clean(t(data), num_pts, 1.5, 80)

</code></pre>

<hr>
<h2 id='do_clean_multiv'>Cleaning multivariate functional outliers</h2><span id='topic+do_clean_multiv'></span>

<h3>Description</h3>

<p>Cleaning of the most remarkable multivariate functional outliers. 
This improves the performance of the archetypoid algorithm since it 
is not affected by spurious points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_clean_multiv(data, num_pts, range = 1.5, out_perc = 80, nbasis, nvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_clean_multiv_+3A_data">data</code></td>
<td>
<p>Data frame with (temporal) points in the rows and observations in 
the columns.</p>
</td></tr>
<tr><td><code id="do_clean_multiv_+3A_num_pts">num_pts</code></td>
<td>
<p>Number of temporal points.</p>
</td></tr>
<tr><td><code id="do_clean_multiv_+3A_range">range</code></td>
<td>
<p>Same parameter as in function <code><a href="graphics.html#topic+boxplot">boxplot</a></code>. 
A value of 1.5 is enough to detect amplitude and shift outliers, while a value
of 3 is needed to detect isolated outliers.</p>
</td></tr>
<tr><td><code id="do_clean_multiv_+3A_out_perc">out_perc</code></td>
<td>
<p>Minimum number of temporal points (in percentage) to consider 
the observation as an outlier. Needed when <code>range=1.5</code>.</p>
</td></tr>
<tr><td><code id="do_clean_multiv_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of basis.</p>
</td></tr>
<tr><td><code id="do_clean_multiv_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the outliers for each variable.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

x1 &lt;- t(Xs[,,1]) 
for (i in 2:nvars) { 
 x12 &lt;- t(Xs[,,i]) 
 x1 &lt;- rbind(x1, x12) 
}
data_all &lt;- t(x1) 

num_pts &lt;- ncol(data_all) / nvars
range &lt;- 3 
outl &lt;- do_clean_multiv(t(data_all), num_pts, range, out_perc, nbasis, nvars)
outl

## End(Not run)
                  
</code></pre>

<hr>
<h2 id='do_fada'>Run the whole functional archetypoid analysis with the Frobenius norm</h2><span id='topic+do_fada'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the functional archetypoid 
analysis. Firstly, the initial vector of archetypoids is obtained using the 
functional archetypal algorithm and finally, the optimal vector of archetypoids is 
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_fada(subset, numArchoid, numRep, huge, compare = FALSE, PM,
              vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
              outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
              method = "adjbox", prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_fada_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In fadalara this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_fada_robust">do_fada_robust</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
<tr><td><code id="do_fada_+3A_prob">prob</code></td>
<td>
<p>If <code>compare=TRUE</code>, probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_rob: If <code>compare_robust=TRUE</code>, this is the residual sum of squares using
the robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid: Vector of residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_funct">stepArchetypesRawData_funct</a></code>, <code><a href="#topic+archetypoids_funct">archetypoids_funct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)

# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada &lt;- do_fada(subset = data_archs, numArchoid = 3, numRep = 5, huge = 200, 
                    compare = FALSE, PM = PM, method = "adjbox")
str(res_fada)      

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada1 &lt;- do_fada(subset = data_archs, numArchoid = 3, numRep = 5, huge = 200, 
                     compare = FALSE, PM = PM, 
                     vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
                     outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
                     method = "toler")
str(res_fada1)                               

res_fada2 &lt;- do_fada(subset = data_archs, numArchoid = 3, numRep = 5, huge = 200, 
                    compare = TRUE, PM = PM, method = "adjbox", prob = 0.8)
str(res_fada2)  


## End(Not run)
                                  
</code></pre>

<hr>
<h2 id='do_fada_multiv'>Run the whole archetypoid analysis with the functional multivariate Frobenius norm</h2><span id='topic+do_fada_multiv'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the functional archetypoid 
analysis. Firstly, the initial vector of archetypoids is obtained using the 
functional archetypal algorithm and finally, the optimal vector of archetypoids is 
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_fada_multiv(subset, numArchoid, numRep, huge, compare = FALSE, PM,
               method = "adjbox", prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_fada_multiv_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In fadalara this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_fada_robust">do_fada_robust</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. So far the only option allowed is 
'adjbox' for using adjusted boxplots for skewed distributions. The use of
tolerance intervals might also be explored in the future for the multivariate case.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_+3A_prob">prob</code></td>
<td>
<p>If <code>compare=TRUE</code>, probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_rob: If <code>compare_robust=TRUE</code>, this is the residual sum of squares using
the robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid: Vector of residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_funct_multiv">stepArchetypesRawData_funct_multiv</a></code>, <code><a href="#topic+archetypoids_funct_multiv">archetypoids_funct_multiv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada &lt;- do_fada_multiv(subset = Xs, numArchoid = 3, numRep = 5, huge = 200, 
                           compare = FALSE, PM = PM, method = "adjbox")
str(res_fada)     

## End(Not run)
                                  
</code></pre>

<hr>
<h2 id='do_fada_multiv_robust'>Run the whole archetypoid analysis with the functional multivariate robust Frobenius norm</h2><span id='topic+do_fada_multiv_robust'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the functional archetypoid 
analysis. Firstly, the initial vector of archetypoids is obtained using the 
functional archetypal algorithm and finally, the optimal vector of archetypoids is 
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_fada_multiv_robust(subset, numArchoid, numRep, huge, prob, compare = FALSE, PM,
                      method = "adjbox")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_fada_multiv_robust_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In fadalara this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization to solve the convex least squares problem, 
see <code><a href="Anthropometry.html#topic+archetypoids">archetypoids</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the non-robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_fada">do_fada</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_multiv_robust_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. So far the only option allowed is 
'adjbox' for using adjusted boxplots for skewed distributions. The use of
tolerance intervals might also be explored in the future for the multivariate case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_non_rob: If <code>compare=TRUE</code>, this is the residual sum of squares using
the non-robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid Vector of residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li>
<li><p> local_rel_imp Matrix with the local (casewise) relative importance 
(in percentage) of each variable for the outlier identification. Only for 
the multivariate case. It is relative to the outlier observation itself. 
The other observations are not considered for computing this importance. 
This procedure works because the functional variables are in the same scale, 
after standardizing. Otherwise, it couldn't be interpreted like that.
</p>
</li>
<li><p> margi_rel_imp Matrix with the marginal relative importance of each variable 
(in percentage) for the outlier identification. Only for the multivariate case. 
In this case, the other points are considered, since the value of the outlier 
observation is compared with the remaining points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_funct_multiv_robust">stepArchetypesRawData_funct_multiv_robust</a></code>, 
<code><a href="#topic+archetypoids_funct_multiv_robust">archetypoids_funct_multiv_robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada &lt;- do_fada_multiv_robust(subset = Xs, numArchoid = 3, numRep = 5, huge = 200, 
                                  prob = 0.75, compare = FALSE, PM = PM, method = "adjbox")
str(res_fada)
res_fada$cases
#[1]  8 24 29
res_fada$rss
#[1] 2.301741

## End(Not run)
                                  
</code></pre>

<hr>
<h2 id='do_fada_robust'>Run the whole archetypoid analysis with the functional robust Frobenius norm</h2><span id='topic+do_fada_robust'></span>

<h3>Description</h3>

<p>This function executes the entire procedure involved in the functional archetypoid 
analysis. Firstly, the initial vector of archetypoids is obtained using the 
functional archetypal algorithm and finally, the optimal vector of archetypoids is 
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_fada_robust(subset, numArchoid, numRep, huge, prob, compare = FALSE, PM,
              vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
              outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
              method = "adjbox")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_fada_robust_+3A_subset">subset</code></td>
<td>
<p>Data to obtain archetypes. In fadalara this is a subset of the 
entire data frame.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the non-robust residual sum of squares 
to compare these results with the ones provided by <code><a href="#topic+do_fada">do_fada</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="do_fada_robust_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases: Final vector of archetypoids.
</p>
</li>
<li><p> alphas: Alpha coefficients for the final vector of archetypoids.
</p>
</li>
<li><p> rss: Residual sum of squares corresponding to the final vector of archetypoids.
</p>
</li>
<li><p> rss_non_rob: If <code>compare=TRUE</code>, this is the residual sum of squares using
the non-robust Frobenius norm. Otherwise, NULL.
</p>
</li>
<li><p> resid: Vector of residuals.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_funct_robust">stepArchetypesRawData_funct_robust</a></code>, 
<code><a href="#topic+archetypoids_funct_robust">archetypoids_funct_robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)

# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada_rob &lt;- do_fada_robust(subset = data_archs, numArchoid = 3, numRep = 5, huge = 200,
                               prob = 0.75, compare = FALSE, PM = PM, method = "adjbox")
str(res_fada_rob)  

suppressWarnings(RNGversion("3.5.0"))
set.seed(2018)
res_fada_rob1 &lt;- do_fada_robust(subset = data_archs, numArchoid = 3, numRep = 5, huge = 200,
                                prob = 0.75, compare = FALSE, PM = PM, 
                                vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
                                outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
                                method = "toler")
str(res_fada_rob1) 

## End(Not run)
                                  
</code></pre>

<hr>
<h2 id='do_knno'>kNN for outlier detection</h2><span id='topic+do_knno'></span>

<h3>Description</h3>

<p>Ramaswamy et al. proposed the k-nearest neighbors outlier detection method (kNNo). 
Each point's anomaly score is the distance to its kth nearest neighbor in the 
data set. Then, all points are ranked based on this distance. The higher an example's 
score is, the more anomalous it is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_knno(data, k, top_n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_knno_+3A_data">data</code></td>
<td>
<p>Data observations.</p>
</td></tr>
<tr><td><code id="do_knno_+3A_k">k</code></td>
<td>
<p>Number of neighbors of a point that we are interested in.</p>
</td></tr>
<tr><td><code id="do_knno_+3A_top_n">top_n</code></td>
<td>
<p>Total number of outliers we are interested in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of outliers.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ramaswamy, S., Rastogi, R. and Shim, K. 
Efficient Algorithms for Mining Outliers from Large Data Sets.
SIGMOD'00 Proceedings of the 2000 ACM SIGMOD international conference 
on Management of data, 2000, 427-438.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- as.matrix(mtcars)
outl &lt;- do_knno(data, 3, 2)
outl
data[outl,]
                 
</code></pre>

<hr>
<h2 id='do_outl_degree'>Degree of outlierness</h2><span id='topic+do_outl_degree'></span>

<h3>Description</h3>

<p>Classification of outliers according to their degree of outlierness.
They are classified using the tolerance proportion. For instance,
outliers from a 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_outl_degree(vect_tol = c(0.95, 0.9, 0.85), resid_vect, alpha = 0.05, 
               outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_outl_degree_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).</p>
</td></tr>
<tr><td><code id="do_outl_degree_+3A_resid_vect">resid_vect</code></td>
<td>
<p>Vector of n residuals, where n was the number of rows
of the data matrix.</p>
</td></tr>
<tr><td><code id="do_outl_degree_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05.</p>
</td></tr>
<tr><td><code id="do_outl_degree_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the type outliers.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outl_toler">outl_toler</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>do_outl_degree(0.95, 1:100, 0.05, "outl_strong")
                                                     
</code></pre>

<hr>
<h2 id='fadalara'>Functional parallel archetypoid algorithm for large applications (FADALARA)</h2><span id='topic+fadalara'></span>

<h3>Description</h3>

<p>The FADALARA algorithm is based on the CLARA clustering algorithm. This is the 
parallel version of the algorithm. It allows to detect anomalies (outliers). 
In the univariate case, there are two different methods to detect them: 
the adjusted boxplot (default and most reliable option) and tolerance intervals.
In the multivariate case, only adjusted boxplots are used.
If needed, tolerance intervals allow to define a degree of outlierness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fadalara(data, N, m, numArchoid, numRep, huge, prob, type_alg = "fada", 
         compare = FALSE, PM, vect_tol = c(0.95, 0.9, 0.85), alpha = 0.05, 
         outl_degree = c("outl_strong", "outl_semi_strong", "outl_moderate"),
         method = "adjbox", multiv, frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fadalara_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable. All variables are numeric. The data must have row names
so that the algorithm can identify the archetypoids in every sample.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_n">N</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_m">m</code></td>
<td>
<p>Sample size of each sample.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> 
times.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="fadalara_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'fada' for the non-robust fadalara algorithm, 
whereas 'fada_rob' is for the robust fadalara algorithm.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
if <code>type_alg = "fada"</code> and the non-robust if <code>type_alg = "fada_rob"</code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals. 
The tolerance intervals are only computed in the univariate case, i.e.,
<code>method='toler'</code> only valid if <code>multiv=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_multiv">multiv</code></td>
<td>
<p>Multivariate (TRUE) or univariate (FALSE) algorithm.</p>
</td></tr>
<tr><td><code id="fadalara_+3A_frame">frame</code></td>
<td>
<p>Boolean value to indicate whether the frame is 
computed (Mair et al., 2017) or not. The frame is made up of a subset of
extreme points, so the archetypoids are only computed on the frame. 
Low frame densities are obtained when only small portions of the data were extreme.
However, high frame densities reduce this speed-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases Vector of archetypoids.
</p>
</li>
<li><p> rss Optimal residual sum of squares.
</p>
</li>
<li><p> outliers: Outliers.
</p>
</li>
<li><p> alphas: Matrix with the alpha coefficients.
</p>
</li>
<li><p> local_rel_imp Matrix with the local (casewise) relative importance 
(in percentage) of each variable for the outlier identification. Only for 
the multivariate case. It is relative to the outlier observation itself. 
The other observations are not considered for computing this importance. 
This procedure works because the functional variables are in the same scale, 
after standardizing. Otherwise, it couldn't be interpreted like that.
</p>
</li>
<li><p> margi_rel_imp Matrix with the marginal relative importance of each variable 
(in percentage) for the outlier identification. Only for the multivariate case. 
In this case, the other points are considered, since the value of the outlier 
observation is compared with the remaining points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Hubert, M. and Vandervieren, E., An adjusted boxplot for skewed distributions, 2008.
<em>Computational Statistics and Data Analysis</em> <b>52(12)</b>, 5186-5201,
<a href="https://doi.org/10.1016/j.csda.2007.11.008">https://doi.org/10.1016/j.csda.2007.11.008</a>
</p>
<p>Kaufman, L. and Rousseeuw, P.J., Clustering Large Data Sets, 1986.
<em>Pattern Recognition in Practice</em>, 425-437.
</p>
<p>Mair, S., Boubekki, A. and Brefeld, U., Frame-based Data Factorizations, 2017.
Proceedings of the 34th International Conference on Machine Learning, 
Sydney, Australia, 1-9.
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do_fada">do_fada</a></code>, <code><a href="#topic+do_fada_robust">do_fada_robust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])
# We have to give names to the dimensions to know the 
# observations that were identified as archetypoids.
dimnames(Xs) &lt;- list(paste("Obs", 1:dim(hgtm)[2], sep = ""), 
                     1:nbasis,
                     c("boys", "girls"))

n &lt;- dim(Xs)[1] 
# Number of archetypoids:
k &lt;- 3 
numRep &lt;- 20
huge &lt;- 200

# Size of the random sample of observations:
m &lt;- 15
# Number of samples:
N &lt;- floor(1 + (n - m)/(m - k))
N
prob &lt;- 0.75
data_alg &lt;- Xs

# Parallel:
# Prepare parallelization (including the seed for reproducibility):
library(doParallel)
no_cores &lt;- detectCores() - 1
no_cores 
cl &lt;- makeCluster(no_cores)
registerDoParallel(cl)
clusterSetRNGStream(cl, iseed = 2018)
res_fl &lt;- fadalara(data = data_alg, N = N, m = m, numArchoid = k, numRep = numRep, 
                   huge = huge, prob = prob, type_alg = "fada_rob", compare = FALSE, 
                   PM = PM, method = "adjbox", multiv = TRUE, frame = FALSE) # frame = TRUE
stopCluster(cl)

res_fl_copy &lt;- res_fl
res_fl &lt;- res_fl[which.min(unlist(sapply(res_fl, function(x) x[2])))][[1]]
str(res_fl)
res_fl$cases
res_fl$rss
as.vector(res_fl$outliers)

## End(Not run)

</code></pre>

<hr>
<h2 id='fadalara_no_paral'>Functional non-parallel archetypoid algorithm for large applications (FADALARA)</h2><span id='topic+fadalara_no_paral'></span>

<h3>Description</h3>

<p>The FADALARA algorithm is based on the CLARA clustering algorithm. This is the 
non-parallel version of the algorithm. It allows to detect anomalies (outliers). 
In the univariate case, there are two different methods to detect them: 
the adjusted boxplot (default and most reliable option) and tolerance intervals.
In the multivariate case, only adjusted boxplots are used.
If needed, tolerance intervals allow to define a degree of outlierness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fadalara_no_paral(data, seed, N, m, numArchoid, numRep, huge, prob, type_alg = "fada", 
                 compare = FALSE, verbose = TRUE, PM, vect_tol = c(0.95, 0.9, 0.85), 
                 alpha = 0.05, outl_degree = c("outl_strong", "outl_semi_strong", 
                 "outl_moderate"), method = "adjbox", multiv, frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fadalara_no_paral_+3A_data">data</code></td>
<td>
<p>Data matrix. Each row corresponds to an observation and each column 
corresponds to a variable (temporal point). All variables are numeric. 
The data must have row names so that the algorithm can identify the archetypoids 
in every sample.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_seed">seed</code></td>
<td>
<p>Integer value to set the seed. This ensures reproducibility.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_n">N</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_m">m</code></td>
<td>
<p>Sample size of each sample.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_numarchoid">numArchoid</code></td>
<td>
<p>Number of archetypes/archetypoids.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> 
times.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_huge">huge</code></td>
<td>
<p>Penalization added to solve the convex least squares problems.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_type_alg">type_alg</code></td>
<td>
<p>String. Options are 'fada' for the non-robust fadalara algorithm, 
whereas 'fada_rob' is for the robust fadalara algorithm.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_compare">compare</code></td>
<td>
<p>Boolean argument to compute the robust residual sum of squares 
if <code>type_alg = "fada"</code> and the non-robust if <code>type_alg = "fada_rob"</code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_verbose">verbose</code></td>
<td>
<p>Display progress? Default TRUE.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_vect_tol">vect_tol</code></td>
<td>
<p>Vector the tolerance values. Default c(0.95, 0.9, 0.85).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Default 0.05. Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_outl_degree">outl_degree</code></td>
<td>
<p>Type of outlier to identify the degree of outlierness.
Default c(&quot;outl_strong&quot;, &quot;outl_semi_strong&quot;, &quot;outl_moderate&quot;).
Needed if <code>method='toler'</code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_method">method</code></td>
<td>
<p>Method to compute the outliers. Options allowed are 'adjbox' for
using adjusted boxplots for skewed distributions, and 'toler' for using
tolerance intervals.
The tolerance intervals are only computed in the univariate case, i.e.,
<code>method='toler'</code> only valid if <code>multiv = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_multiv">multiv</code></td>
<td>
<p>Multivariate (TRUE) or univariate (FALSE) algorithm.</p>
</td></tr>
<tr><td><code id="fadalara_no_paral_+3A_frame">frame</code></td>
<td>
<p>Boolean value to indicate whether the frame is 
computed (Mair et al., 2017) or not. The frame is made up of a subset of
extreme points, so the archetypoids are only computed on the frame. 
Low frame densities are obtained when only small portions of the data were extreme.
However, high frame densities reduce this speed-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> cases Vector of archetypoids.
</p>
</li>
<li><p> rss Optimal residual sum of squares.
</p>
</li>
<li><p> outliers: Vector of outliers.
</p>
</li>
<li><p> alphas: Matrix with the alpha coefficients.
</p>
</li>
<li><p> local_rel_imp Matrix with the local (casewise) relative importance 
(in percentage) of each variable for the outlier identification. Only for 
the multivariate case. It is relative to the outlier observation itself. 
The other observations are not considered for computing this importance. 
This procedure works because the functional variables are in the same scale, 
after standardizing. Otherwise, it couldn't be interpreted like that.
</p>
</li>
<li><p> margi_rel_imp Matrix with the marginal relative importance of each variable 
(in percentage) for the outlier identification. Only for the multivariate case. 
In this case, the other points are considered, since the value of the outlier 
observation is compared with the remaining points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Hubert, M. and Vandervieren, E., An adjusted boxplot for skewed distributions, 2008.
<em>Computational Statistics and Data Analysis</em> <b>52(12)</b>, 5186-5201,
<a href="https://doi.org/10.1016/j.csda.2007.11.008">https://doi.org/10.1016/j.csda.2007.11.008</a>
</p>
<p>Kaufman, L. and Rousseeuw, P.J., Clustering Large Data Sets, 1986.
<em>Pattern Recognition in Practice</em>, 425-437.
</p>
<p>Mair, S., Boubekki, A. and Brefeld, U., Frame-based Data Factorizations, 2017.
Proceedings of the 34th International Conference on Machine Learning, 
Sydney, Australia, 1-9.
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fadalara">fadalara</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])
# We have to give names to the dimensions to know the 
# observations that were identified as archetypoids.
dimnames(Xs) &lt;- list(paste("Obs", 1:dim(hgtm)[2], sep = ""), 
                     1:nbasis,
                     c("boys", "girls"))

n &lt;- dim(Xs)[1] 
# Number of archetypoids:
k &lt;- 3 
numRep &lt;- 20
huge &lt;- 200

# Size of the random sample of observations:
m &lt;- 15
# Number of samples:
N &lt;- floor(1 + (n - m)/(m - k))
N
prob &lt;- 0.75
data_alg &lt;- Xs

seed &lt;- 2018
res_fl &lt;- fadalara_no_paral(data = data_alg, seed = seed, N = N, m = m, 
                            numArchoid = k, numRep = numRep, huge = huge, 
                            prob = prob, type_alg = "fada_rob", compare = FALSE, 
                            verbose = TRUE, PM = PM, method = "adjbox", multiv = TRUE,
                            frame = FALSE) # frame = TRUE
                   
str(res_fl)
res_fl$cases
res_fl$rss
as.vector(res_fl$outliers)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='frame_in_r'>Compute archetypes frame</h2><span id='topic+frame_in_r'></span>

<h3>Description</h3>

<p>Computing the frame with the approach by Mair et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame_in_r(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frame_in_r_+3A_x">X</code></td>
<td>
<p>Data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the observations that belong to the frame.
</p>


<h3>Author(s)</h3>

<p>Sebastian Mair, code kindly provided by him.
</p>


<h3>References</h3>

<p>Mair, S., Boubekki, A. and Brefeld, U., Frame-based Data Factorizations, 2017.
Proceedings of the 34th International Conference on Machine Learning, 
Sydney, Australia, 1-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X &lt;- mtcars
q &lt;- frame_in_r(X)
H &lt;- X[q,]
q

## End(Not run)

</code></pre>

<hr>
<h2 id='frobenius_norm'>Frobenius norm</h2><span id='topic+frobenius_norm'></span>

<h3>Description</h3>

<p>Computes the Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue, Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S.,Archetypoids: a new approach to 
define representative archetypal data, 2015.
<em>Computational Statistics and Data Analysis</em> <b>87</b>, 102-115,
<a href="https://doi.org/10.1016/j.csda.2015.01.018">https://doi.org/10.1016/j.csda.2015.01.018</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:4, nrow = 2)
frobenius_norm(mat)
                 
</code></pre>

<hr>
<h2 id='frobenius_norm_funct'>Functional Frobenius norm</h2><span id='topic+frobenius_norm_funct'></span>

<h3>Description</h3>

<p>Computes the functional Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm_funct(m, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_funct_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
mat &lt;- matrix(1:9, nrow = 3)
fbasis &lt;- create.fourier.basis(rangeval = c(1, 32), nbasis = 3)
PM &lt;- eval.penalty(fbasis)
frobenius_norm_funct(mat, PM)
                 
</code></pre>

<hr>
<h2 id='frobenius_norm_funct_multiv'>Functional multivariate Frobenius norm</h2><span id='topic+frobenius_norm_funct_multiv'></span>

<h3>Description</h3>

<p>Computes the functional multivariate Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm_funct_multiv(m, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_funct_multiv_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_multiv_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:400, ncol = 20)
PM &lt;- matrix(1:100, ncol = 10)
frobenius_norm_funct_multiv(mat, PM)
                 
</code></pre>

<hr>
<h2 id='frobenius_norm_funct_multiv_robust'>Functional multivariate robust Frobenius norm</h2><span id='topic+frobenius_norm_funct_multiv_robust'></span>

<h3>Description</h3>

<p>Computes the functional multivariate robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm_funct_multiv_robust(m, PM, prob, nbasis, nvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_funct_multiv_robust_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_multiv_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_multiv_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_multiv_robust_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of basis.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_multiv_robust_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:400, ncol = 20)
PM &lt;- matrix(1:100, ncol = 10)
frobenius_norm_funct_multiv_robust(mat, PM, 0.8, 10, 2)
                 
</code></pre>

<hr>
<h2 id='frobenius_norm_funct_robust'>Functional robust Frobenius norm</h2><span id='topic+frobenius_norm_funct_robust'></span>

<h3>Description</h3>

<p>Computes the functional robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm_funct_robust(m, PM, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_funct_robust_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="frobenius_norm_funct_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
mat &lt;- matrix(1:9, nrow = 3)
fbasis &lt;- create.fourier.basis(rangeval = c(1, 32), nbasis = 3)
PM &lt;- eval.penalty(fbasis)
frobenius_norm_funct_robust(mat, PM, 0.8)
                           
</code></pre>

<hr>
<h2 id='frobenius_norm_robust'>Robust Frobenius norm</h2><span id='topic+frobenius_norm_robust'></span>

<h3>Description</h3>

<p>Computes the robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius_norm_robust(m, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius_norm_robust_+3A_m">m</code></td>
<td>
<p>Data matrix with the residuals. This matrix has 
the same dimensions as the original data matrix.</p>
</td></tr>
<tr><td><code id="frobenius_norm_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are vectors. If there are p variables (columns),
for every observation there is a residual that there is 
a p-dimensional vector. If there are n observations, the
residuals are an n times p matrix.
</p>


<h3>Value</h3>

<p>Real number.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:4, nrow = 2)
frobenius_norm_robust(mat, 0.8)
                 
</code></pre>

<hr>
<h2 id='int_prod_mat'>Interior product between matrices</h2><span id='topic+int_prod_mat'></span>

<h3>Description</h3>

<p>Helper function to compute the Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prod_mat(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_prod_mat_+3A_m">m</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data matrix.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:4, nrow = 2)
int_prod_mat(mat)

</code></pre>

<hr>
<h2 id='int_prod_mat_funct'>Interior product between matrices for FDA</h2><span id='topic+int_prod_mat_funct'></span>

<h3>Description</h3>

<p>Helper function to compute the Frobenius norm 
in the functional data analysis (FDA) scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prod_mat_funct(m, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_prod_mat_funct_+3A_m">m</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="int_prod_mat_funct_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data matrix.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
mat &lt;- matrix(1:9, nrow = 3)
fbasis &lt;- create.fourier.basis(rangeval = c(1, 32), nbasis = 3)
PM &lt;- eval.penalty(fbasis)  
int_prod_mat_funct(mat, PM) 
                 
</code></pre>

<hr>
<h2 id='int_prod_mat_sq'>Squared interior product between matrices</h2><span id='topic+int_prod_mat_sq'></span>

<h3>Description</h3>

<p>Helper function to compute the robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prod_mat_sq(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_prod_mat_sq_+3A_m">m</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data matrix.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:4, nrow = 2)
int_prod_mat_sq(mat)

</code></pre>

<hr>
<h2 id='int_prod_mat_sq_funct'>Squared interior product between matrices for FDA</h2><span id='topic+int_prod_mat_sq_funct'></span>

<h3>Description</h3>

<p>Helper function to compute the robust Frobenius norm 
in the functional data analysis (FDA) scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prod_mat_sq_funct(m, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_prod_mat_sq_funct_+3A_m">m</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="int_prod_mat_sq_funct_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data matrix.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
mat &lt;- matrix(1:9, nrow = 3)
fbasis &lt;- create.fourier.basis(rangeval = c(1, 32), nbasis = 3)
PM &lt;- eval.penalty(fbasis)  
int_prod_mat_sq_funct(mat, PM)
                 
</code></pre>

<hr>
<h2 id='outl_toler'>Tolerance outliers</h2><span id='topic+outl_toler'></span>

<h3>Description</h3>

<p>Outliers according to a tolerance interval. This function is used by 
the archetypoid algorithms to identify the outliers. See the function
<code>nptol.int</code> in package <code>tolerance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outl_toler(p_tol = 0.95, resid_vect, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outl_toler_+3A_p_tol">p_tol</code></td>
<td>
<p>The proportion of observations to be covered by this 
tolerance interval.</p>
</td></tr>
<tr><td><code id="outl_toler_+3A_resid_vect">resid_vect</code></td>
<td>
<p>Vector of n residuals, where n was the number of rows
of the data matrix.</p>
</td></tr>
<tr><td><code id="outl_toler_+3A_alpha">alpha</code></td>
<td>
<p>Significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the outliers.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Young, D., tolerance: An R package for estimating tolerance intervals, 2010.
<em>Journal of Statistical Software</em>, <b>36(5)</b>, 1-39, 
<a href="https://doi.org/10.18637/jss.v036.i05">https://doi.org/10.18637/jss.v036.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adalara">adalara</a></code>, <code><a href="#topic+fadalara">fadalara</a></code>, <code><a href="#topic+do_outl_degree">do_outl_degree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outl_toler(0.95, 1:100, 0.05)
                                                     
</code></pre>

<hr>
<h2 id='stepArchetypesRawData_funct'>Archetype algorithm to raw data with the functional Frobenius norm</h2><span id='topic+stepArchetypesRawData_funct'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the functional archetype algorithm with the Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_funct(data, numArch, numRep = 3, 
                            verbose = TRUE, saveHistory = FALSE, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_funct_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Cutler, A. and Breiman, L., Archetypal Analysis. <em>Technometrics</em>, 1994,
<b>36(4)</b>, 338-347, <a href="https://doi.org/10.2307/1269949">https://doi.org/10.2307/1269949</a>
</p>
<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)
# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

lass &lt;- stepArchetypesRawData_funct(data = data_archs, numArch = 3, 
                                    numRep = 5, verbose = FALSE, 
                                    saveHistory = FALSE, PM)
str(lass)   
length(lass[[1]])
class(lass[[1]])  
class(lass[[1]][[5]])                                 

## End(Not run)                                         

</code></pre>

<hr>
<h2 id='stepArchetypesRawData_funct_multiv'>Archetype algorithm to raw data with the functional multivariate Frobenius norm</h2><span id='topic+stepArchetypesRawData_funct_multiv'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the functional archetype algorithm with the multivariate Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_funct_multiv(data, numArch, numRep = 3, 
                                   verbose = TRUE, saveHistory = FALSE, PM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Cutler, A. and Breiman, L., Archetypal Analysis. <em>Technometrics</em>, 1994,
<b>36(4)</b>, 338-347, <a href="https://doi.org/10.2307/1269949">https://doi.org/10.2307/1269949</a>
</p>
<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

lass &lt;- stepArchetypesRawData_funct_multiv(data = Xs, numArch = 3, 
                                           numRep = 5, verbose = FALSE, 
                                           saveHistory = FALSE, PM)
                                           
str(lass)   
length(lass[[1]])
class(lass[[1]])  
class(lass[[1]][[5]])                                             

## End(Not run)                                         

</code></pre>

<hr>
<h2 id='stepArchetypesRawData_funct_multiv_robust'>Archetype algorithm to raw data with the functional multivariate robust Frobenius norm</h2><span id='topic+stepArchetypesRawData_funct_multiv_robust'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the functional archetype algorithm with the multivariate Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_funct_multiv_robust(data, numArch, numRep = 3, 
                            verbose = TRUE, saveHistory = FALSE, PM, prob, nbasis, nvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of basis.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_multiv_robust_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Cutler, A. and Breiman, L., Archetypal Analysis. <em>Technometrics</em>, 1994,
<b>36(4)</b>, 338-347, <a href="https://doi.org/10.2307/1269949">https://doi.org/10.2307/1269949</a>
</p>
<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- growth$hgtm
hgtf &lt;- growth$hgtf[,1:39]

# Create array:
nvars &lt;- 2
data.array &lt;- array(0, dim = c(dim(hgtm), nvars))
data.array[,,1] &lt;- as.matrix(hgtm)
data.array[,,2] &lt;- as.matrix(hgtf)
rownames(data.array) &lt;- 1:nrow(hgtm)
colnames(data.array) &lt;- colnames(hgtm)
str(data.array)

# Create basis:
nbasis &lt;- 10
basis_fd &lt;- create.bspline.basis(c(1,nrow(hgtm)), nbasis)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:nrow(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = data.array, basisobj = basis_fd)

X &lt;- array(0, dim = c(dim(t(temp_fd$coefs[,,1])), nvars))
X[,,1] &lt;- t(temp_fd$coef[,,1]) 
X[,,2] &lt;- t(temp_fd$coef[,,2])

# Standardize the variables:
Xs &lt;- X
Xs[,,1] &lt;- scale(X[,,1])
Xs[,,2] &lt;- scale(X[,,2])

lass &lt;- stepArchetypesRawData_funct_multiv_robust(data = Xs, numArch = 3, 
                                                  numRep = 5, verbose = FALSE, 
                                                  saveHistory = FALSE, PM, prob = 0.8, 
                                                  nbasis, nvars)
str(lass)   
length(lass[[1]])
class(lass[[1]])  
class(lass[[1]][[5]]) 

## End(Not run)                                         

</code></pre>

<hr>
<h2 id='stepArchetypesRawData_funct_robust'>Archetype algorithm to raw data with the functional robust Frobenius norm</h2><span id='topic+stepArchetypesRawData_funct_robust'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the functional archetype algorithm with the functional robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_funct_robust(data, numArch, numRep = 3, 
                                verbose = TRUE, saveHistory = FALSE, PM, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_pm">PM</code></td>
<td>
<p>Penalty matrix obtained with <code><a href="fda.html#topic+eval.penalty">eval.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_funct_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Cutler, A. and Breiman, L., Archetypal Analysis. <em>Technometrics</em>, 1994,
<b>36(4)</b>, 338-347, <a href="https://doi.org/10.2307/1269949">https://doi.org/10.2307/1269949</a>
</p>
<p>Epifanio, I., Functional archetype and archetypoid analysis, 2016. 
<em>Computational Statistics and Data Analysis</em> <b>104</b>, 24-34, 
<a href="https://doi.org/10.1016/j.csda.2016.06.007">https://doi.org/10.1016/j.csda.2016.06.007</a>
</p>
<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fda)
?growth
str(growth)
hgtm &lt;- t(growth$hgtm)
# Create basis:
basis_fd &lt;- create.bspline.basis(c(1,ncol(hgtm)), 10)
PM &lt;- eval.penalty(basis_fd)
# Make fd object:
temp_points &lt;- 1:ncol(hgtm)
temp_fd &lt;- Data2fd(argvals = temp_points, y = growth$hgtm, basisobj = basis_fd)
data_archs &lt;- t(temp_fd$coefs)

lass &lt;- stepArchetypesRawData_funct_robust(data = data_archs, numArch = 3, 
                                           numRep = 5, verbose = FALSE, 
                                           saveHistory = FALSE, PM, prob = 0.8)
str(lass)   
length(lass[[1]])
class(lass[[1]])  
class(lass[[1]][[5]]) 

## End(Not run)                                         

</code></pre>

<hr>
<h2 id='stepArchetypesRawData_norm_frob'>Archetype algorithm to raw data with the Frobenius norm</h2><span id='topic+stepArchetypesRawData_norm_frob'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the archetype algorithm with the Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_norm_frob(data, numArch, numRep = 3, 
                                verbose = TRUE, saveHistory = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_norm_frob_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_norm_frob_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_norm_frob_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_norm_frob_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_norm_frob_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Eugster, M.J.A. and Leisch, F., From Spider-Man to Hero - Archetypal Analysis in 
R, 2009. <em>Journal of Statistical Software</em> <b>30(8)</b>, 1-23,
<a href="https://doi.org/10.18637/jss.v030.i08">https://doi.org/10.18637/jss.v030.i08</a>
</p>
<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., Archetypoids: a new approach to 
define representative archetypal data, 2015.
<em>Computational Statistics and Data Analysis</em> <b>87</b>, 102-115,
<a href="https://doi.org/10.1016/j.csda.2015.01.018">https://doi.org/10.1016/j.csda.2015.01.018</a>
</p>
<p>Vinue, G., Anthropometry: An R Package for Analysis of Anthropometric Data, 2017.
<em>Journal of Statistical Software</em> <b>77(6)</b>, 1-39,
<a href="https://doi.org/10.18637/jss.v077.i06">https://doi.org/10.18637/jss.v077.i06</a>
</p>


<h3>See Also</h3>

<p><code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>, 
<code><a href="archetypes.html#topic+stepArchetypes">stepArchetypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- as.matrix(mtcars)

numArch &lt;- 5 
numRep &lt;- 2

lass &lt;- stepArchetypesRawData_norm_frob(data = data, numArch = 1:numArch, 
                                        numRep = numRep, verbose = FALSE)
                                        
str(lass)   
length(lass[[1]])
class(lass[[1]])  
                                                   
</code></pre>

<hr>
<h2 id='stepArchetypesRawData_robust'>Archetype algorithm to raw data with the robust Frobenius norm</h2><span id='topic+stepArchetypesRawData_robust'></span>

<h3>Description</h3>

<p>This is a slight modification of <code><a href="Anthropometry.html#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>
to use the archetype algorithm with the robust Frobenius norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData_robust(data, numArch, numRep = 3, 
                             verbose = TRUE, saveHistory = FALSE, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_robust_+3A_data">data</code></td>
<td>
<p>Data to obtain archetypes.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_robust_+3A_numarch">numArch</code></td>
<td>
<p>Number of archetypes to compute, from 1 to <code>numArch</code>.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_robust_+3A_numrep">numRep</code></td>
<td>
<p>For each <code>numArch</code>, run the archetype algorithm <code>numRep</code> times.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_robust_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the progress during execution is shown.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_robust_+3A_savehistory">saveHistory</code></td>
<td>
<p>Save execution steps.</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_robust_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Moliner, J. and Epifanio, I., Robust multivariate and functional archetypal analysis 
with application to financial time series analysis, 2019. 
<em>Physica A: Statistical Mechanics and its Applications</em> <b>519</b>, 195-208. 
<a href="https://doi.org/10.1016/j.physa.2018.12.036">https://doi.org/10.1016/j.physa.2018.12.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData_norm_frob">stepArchetypesRawData_norm_frob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data &lt;- as.matrix(mtcars)

numArch &lt;- 5 
numRep &lt;- 2

lass &lt;- stepArchetypesRawData_robust(data = data, numArch = 1:numArch, 
                                     numRep = numRep, verbose = FALSE,
                                     saveHistory = FALSE, prob = 0.8)
str(lass)   
length(lass[[1]])
class(lass[[1]])                                       
                 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
