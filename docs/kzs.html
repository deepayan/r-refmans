<!DOCTYPE html><html><head><title>Help for package kzs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kzs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kzs'><p> Kolmogorov-Zurbenko Spline</p></a></li>
<li><a href='#kzs.2d'><p> Spatial Kolmogorov-Zurbenko Spline</p></a></li>
<li><a href='#kzs.3d_data'><p>4-dimensional KZS Output</p></a></li>
<li><a href='#kzs.md'><p> Spatial Kolmogorov-Zurbenko Spline</p></a></li>
<li><a href='#kzs.params'><p> Restrictions for KZS Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kolmogorov-Zurbenko Spatial Smoothing and Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2008-10-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Cyr &lt;cyr.derek@gmail.com&gt; and Igor Zurbenko &lt;igorg.zurbenko@gmail.com&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Cyr &lt;cyr.derek@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.8.0), graphics, lattice, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>A spatial smoothing algorithm based on convolutions of finite rectangular kernels that provides sharp resolution in the presence of high levels of noise.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>Tue Oct 28 13:41:02 2008; Owner</td>
</tr>
</table>
<hr>
<h2 id='kzs'> Kolmogorov-Zurbenko Spline </h2><span id='topic+kzs'></span>

<h3>Description</h3>

<p>This is a one-dimensional iterative smoothing algorithm based on convolutions of rectangular kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kzs(y, x, smooth, scale, k = 1, edges = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kzs_+3A_y">y</code></td>
<td>
  
<p>a one-dimensional vector of real values representing the response variable to be smoothed.
</p>
</td></tr>
<tr><td><code id="kzs_+3A_x">x</code></td>
<td>
 
<p>a one-dimensional vector of real values representing the input variable.
</p>
</td></tr>
<tr><td><code id="kzs_+3A_smooth">smooth</code></td>
<td>
 
<p>a real number defining the width of the smoothing window, i.e., the width of the rectangular kernel.   
</p>
</td></tr>
<tr><td><code id="kzs_+3A_scale">scale</code></td>
<td>
 
<p>for an irregularly spaced <code>x</code>, <code>scale</code> is a positive real number that will define a uniform
scale along <code>x</code>.
</p>
</td></tr>
<tr><td><code id="kzs_+3A_k">k</code></td>
<td>
 
<p>an integer specifying the number of iterations <code>kzs</code> will execute; <code>k</code> may also be 
interpreted as the order of smoothness (as a polynomial of degree <code>k-1</code>). By default, <code>k = 1</code>.
</p>
</td></tr>
<tr><td><code id="kzs_+3A_edges">edges</code></td>
<td>
 
<p>a logical indicating whether or not to display the outcome data beyond the initial range of <code>x</code>. By 
default, <code>edges = TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="kzs_+3A_plot">plot</code></td>
<td>
  
<p>a logical indicating whether or not to produce a plot of the <code>kzs</code> outcome. This is <code>TRUE</code>
by default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relation between variables Y and X as a function of a current value of X = x [namely, Y(x)] is 
often desired as a result of practical research. Usually we search for some simple function, Y(x), 
when given a data set of pairs (Xi, Yi). When plotted, these pairs frequently resemble a noisy plot, 
and thus Y(x) is desired to be a smooth outcome that captures patterns or long-term trends in the 
original data, while suppressing the noise. The <code>kzs</code> function is based on convolutions of the
rectangular kernel, which is equilvalent to repeated applications of a moving average. According to 
the Central Limit Theorem, repeated convolutions with rectangular kernels will converge to the Gaussian
kernel; the resulting kernel will have finite support equal to <code>smooth*k</code>, which will result in a 
smooth outcome with diminished noise leakage, which is a feature that the standard Gaussian kernel does
not exhibit. 
</p>


<h3>Value</h3>

<p>a two-column data frame of paired values <code>(xk, yk)</code>:
</p>
<table>
<tr><td><code>xk</code></td>
<td>
<p><code>x</code> values in increments of <code>scale</code> </p>
</td></tr>
<tr><td><code>yk</code></td>
<td>
<p>smoothed response values resulting from <code>k</code> iterations of <code>kzs</code> </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>Data set (Xi, Yi) must be provided, usually as some observations that occur at certain times; <code>kzs</code>
is designed for the general situation, including time series data. In many applications where the input 
variable, <code>x</code>, can be time, <code>kzs</code> is resolving the problem of missing values in time series or 
irregularly observed values in longitudinal data analysis.<br /> 
</p>
<p><code>kzs</code> may take time to completely run depending on the size of the data set used and the number of 
iterations specified.<br />
</p>
<p>For more information on the restrictions imposed on <code>delta</code> and <code>d</code>, consult <code><a href="#topic+kzs.params">kzs.params</a></code>.
</p>


<h3>Author(s)</h3>

<p> Derek Cyr <a href="mailto:cyr.derek@gmail.com">cyr.derek@gmail.com</a> and Igor Zurbenko <a href="mailto:igorg.zurbenko@gmail.com">igorg.zurbenko@gmail.com</a></p>


<h3>References</h3>

<p> Zurbenko, I.G. (1986). <em>The Spectral Analysis of Time Series</em>. North Holland Series in 
Statistics and Probability, Elsevier Science, Amsterdam. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+kzs.params">kzs.params</a></code>, <code><a href="#topic+kzs.2d">kzs.2d</a></code>, <code><a href="#topic+kzs.md">kzs.md</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Total time t
t &lt;- seq(from = -round(400*pi), to = round(400*pi), by = .25) 

# Construct the signal over time
ts &lt;- 0.5*sin(sqrt((2*pi*abs(t))/200))
signal &lt;- ifelse(t &lt; 0, -ts, ts)

# Bury the signal in noise [randomly, from N(0, 1)]
et &lt;- rnorm(length(t), mean = 0, sd = 1)
yt &lt;- et + signal

# Data frame of (t, yt) 
pts &lt;- data.frame(cbind(t, yt))


### EXAMPLE 1 - Apply kzs to the signal buried in noise                 

# Plot of the true signal
plot(signal ~ t, xlab = "t", ylab = "Signal", main = "True Signal",
type = "l")

# Plot of signal + noise
plot(yt ~ t, ylab = "yt", main = "Signal buried in noise", type = "p")

# Apply 3 iterations of kzs
kzs(y = pts[,2], x = pts[,1], smooth = 80, scale = .2, k = 3, edges = TRUE,
plot = TRUE)
lines(signal ~ t, col = "red")
title(main = "kzs(smooth = 80, scale = .2, k = 3, edges = TRUE)")
legend("topright", c("True signal","kzs estimate"), cex = 0.8,
col = c("red", "black"), lty = 1:1, lwd = 2, bty = "n")

### EXAMPLE 2 - Irregularly observed data over time

# Cancel a random 20 percent of (t, yt) leaving irregularly observed time points
obs &lt;- seq(1:length(t))
t20 &lt;- sample(obs, size = length(obs)/5)
pts20 &lt;- pts[-t20,]        

# Plot of (t,yt) with 20 percent of the data removed
plot(pts20$yt ~ pts20$t, main = "Signal buried in noise\n20 percent of 
(t, yt) deleted", xlab = "t", ylab = "yt", type = "p")

# Apply 3 iterations of kzs
kzs(y = pts20[,2], x = pts20[,1], smooth = 80, scale = .2, k = 3, edges = TRUE, 
plot = TRUE)
lines(signal ~ t, col = "red")
title(main = "kzs(smooth = 80, scale = .2, k = 3, edges = TRUE)")
legend("topright", c("True signal","kzs estimate"), cex = 0.8, 
col = c("red", "black"), lty = 1:1, lwd = 2, bty = "n")  
</code></pre>

<hr>
<h2 id='kzs.2d'> Spatial Kolmogorov-Zurbenko Spline </h2><span id='topic+kzs.2d'></span>

<h3>Description</h3>

<p>The <code>kzs.2d</code> function is a spatial extension of the <code>kzs</code> function for two input variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kzs.2d(y, x, smooth, scale, k = 1, edges = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kzs.2d_+3A_y">y</code></td>
<td>

<p>a one-dimensional vector of real values representing the response variable to be smoothed.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_x">x</code></td>
<td>
 
<p>a two-dimensional matrix of real values containing the input variables X = (X1, X2). Each column
represents an input variable.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_smooth">smooth</code></td>
<td>
 
<p>a vector of size two that defines the width of the smoothing window along each input variable.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_scale">scale</code></td>
<td>
 
<p>a vector of size two in which each element will define a uniformly spaced scale along its respective
input variable.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_k">k</code></td>
<td>
 
<p>an integer specifying the number of iterations <code>kzs.2d</code> will execute. By default, <code>k = 1</code>.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_edges">edges</code></td>
<td>
 
<p>a logical indicating whether or not to display the outcome data beyond the rectangular range of the two
input variables. By default, <code>edges = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="kzs.2d_+3A_plot">plot</code></td>
<td>
 
<p>a logical indicating whether or not to produce a 3-dimensional plot of the <code>kzs.2d</code> outcome. By 
default, this argument is set to <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details for this function are nearly identical to that of <code><a href="#topic+kzs">kzs</a></code>, except now extended to
three dimensional space. The only difference is that the <code>kzs.2d</code> function averages all <code>y</code> that
are contained within a rectangular window made up of sides <code>smooth[1]</code> and <code>smooth[2]</code>.   
</p>


<h3>Value</h3>

<p>a three column data frame of the form <code>(x1, x2, yk)</code>:
</p>
<table>
<tr><td><code>x1</code></td>
<td>

<p>the <code>x1</code> coordinates of a two-dimensional grid.
</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>

<p>the <code>x2</code> coordinates of a two-dimensional grid.
</p>
</td></tr>
<tr><td><code>yk</code></td>
<td>

<p>the smoothed response values resulting from <code>k</code> iterations of <code>kzs.2d</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>Data set (Y, X1, X2) must be provided, usually as 3-dimensional observations that occur in time or
space; <code>kzs.2d</code> is designed for the general situation, including time series data. In many applications 
where an input variable can be time, <code>kzs.2d</code> can resolve the problem of missing values in time series or
or irregularly observed values in Geographical Information Systems (GIS) data analysis. The name of this 
function, <code>kzs.2d</code>, simply means that there are two input variables required for use.<br />
</p>
<p>The graphical output of <code>kzs.2d</code> is a result of the <code>wireframe()</code> function within the <span class="pkg">lattice</span> package.
</p>


<h3>Author(s)</h3>

<p> Derek Cyr <a href="mailto:cyr.derek@gmail.com">cyr.derek@gmail.com</a> and Igor Zurbenko <a href="mailto:igorg.zurbenko@gmail.com">igorg.zurbenko@gmail.com</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+kzs">kzs</a></code>; For more on the parameter restrictions, see <code><a href="#topic+kzs.params">kzs.params</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE - Estimating the Sinc function in the interval (-3pi, 3pi)
#           Load the LATTICE package 


# Gridded data for X = (x1, x2) input variables
x1 &lt;- seq(-3*pi, 3*pi, length = 60)
x2 &lt;- x1			
df &lt;- expand.grid(x1 = x1, x2 = x2)
  
# Apply the Sinc function to the (x1, x2) coordinates
df$z &lt;- sin(sqrt(df$x1^2 + df$x2^2)) / sqrt(df$x1^2 + df$x2^2)
df$z[is.na(df$z)] &lt;- 1

# Any point outside the circle of radius 3pi is set to 0. This provides
# a better picture of the outcome solely for the purposes of this example.
dst &lt;- sqrt((df$x1 - 0)^2 + (df$x2 - 0)^2)
df$dist &lt;- dst	
df$z[df$dist &gt; 3*pi] &lt;- 0

# Add noise to distort the signal
ez &lt;- rnorm(length(df$z), mean = 0, sd = 1) * 1/4    
df$zn &lt;- ez + df$z

### (1) 3D plot of the signal to be estimated by kzs.2d()
wireframe(z ~ x1 * x2, df, main = "Signal to be estimated", drape = TRUE, 
colorkey = TRUE, scales = list(arrows = FALSE))

### (2) 3D plot of the signal buried in noise
wireframe(zn ~ x1 * x2, df, main = "Signal buried in noise", drape = TRUE, 
colorkey = TRUE, scales = list(arrows = FALSE))
  
### (3) Execute kzs.2d()   
# kzs.2d() may take time to run; k = 1 iteration is used here, but k = 2
# will provide a smoother outcome.
sw &lt;- c(1, 1)
sc &lt;- c(0.2, 0.2)
kzs.2d(y = df[,5], x = df[,1:2], smooth = sw, scale = sc, k = 1, edges = TRUE, 
plot = TRUE)  
</code></pre>

<hr>
<h2 id='kzs.3d_data'>4-dimensional KZS Output</h2><span id='topic+kzs.3d_data'></span>

<h3>Description</h3>

<p>This data set contains the output from a KZS operation consisting of 3
input variables, X = (X1, X2, X3), and the single outcome variable Y,
which is buried in noise. See the &lsquo;Details&rsquo; for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kzs.3d_data)</code></pre>


<h3>Format</h3>

<p>A data frame with 9025 observations on 52 variables. The first two variables are the coordinates of a
two-dimensional grid (X1, X2). The remaining 50 variables are KZS output.  See more details below.
</p>


<h3>Details</h3>

<p>This data set is based on the example documented in <code>kzs.2d</code>. A 2D grid of points, (X1, X2), is 
constructed over the range [-1.5pi, 1.5pi] and acts as two input variables. The third input variable 
is time, and has values, 1, 2, ..., 50. For each of the 50 time points, there is a corresponding amplitude,
that ranges from 0 to 1. For each unique amplitude, the outcome variable, Y, is calculated by applying the 
Sinc function to the <code>(x1, x2)</code> grid over each of the 50 time points. This process results in 50 columns
of data, 1 for each time point and amplitude. As stated in the <code>kzs.md</code> documentation, KZS is a linear 
operation, and thus is commutative (that is, we can change the order of the operations, without changing the 
end result). For example, <code>kzs.3d</code> = <code>kzs.1d</code> + <code>kzs.2d</code> = <code>kzs.2d</code> + <code>kzs.1d</code>.  This 
property of KZS was used to receive the 4-dimensional result. Using the data described above, <code>kzs.2d</code> was 
first applied to each of the 50 columns of input using <code>k = 2</code> iterations, <code>smooth</code> = (1.5, 1.5) and 
<code>scale</code> = (0.1, 0.1), which were chosen arbitrarily. Using the resulting data from the <code>kzs.2d</code> operation,
<code>kzs.1d</code> was applied across time. The result of this operation is 4-dimensional data, which can be visualized 
as a 2-dimensional map with color (blue for low amplitudes near 0 and red for high amplitudes close to 1).  
Incorporating time, this result can be visualized as a &ldquo;movie&rdquo; of the 50 2-dimensional images, where the 
amplitude (color) is changing from 0 to 1 (blue to red).<br />
</p>
<p>This data set has been included in this package due to the significant amount of computer time it took to run. Including
this process as an example would not be efficient. Using this data set, the example in the <code>kzs.md</code> documentation
is constructed.  
</p>

<hr>
<h2 id='kzs.md'> Spatial Kolmogorov-Zurbenko Spline </h2><span id='topic+kzs.md'></span>

<h3>Description</h3>

<p>The <code>kzs.md</code> function is an extension of the <code>kzs</code> function to <em>d</em> input variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kzs.md(y, x, smooth, scale, k = 1, edges = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kzs.md_+3A_y">y</code></td>
<td>

<p>a one-dimensional vector of real values representing the response variable to be smoothed.
</p>
</td></tr>
<tr><td><code id="kzs.md_+3A_x">x</code></td>
<td>
 
<p>a <em>d</em>-dimensional matrix of real values containing the input variables X = (X1, X2, ..., X<em>d</em>);
i.e., each column of the matrix is an input variable.
</p>
</td></tr>
<tr><td><code id="kzs.md_+3A_smooth">smooth</code></td>
<td>
 
<p>a real-valued vector of size <em>d</em> in which each element defines the range of smoothing for each 
corresponding variable in <code>x</code>. 
</p>
</td></tr>
<tr><td><code id="kzs.md_+3A_scale">scale</code></td>
<td>
 
<p>a real-valued vector of size <em>d</em> in which each element defines a uniform scale along its 
corresponding input variable.
</p>
</td></tr>
<tr><td><code id="kzs.md_+3A_k">k</code></td>
<td>
 
<p>an integer specifying the number of iterations <code>kzs.md</code> will execute. By default, <code>k = 1</code>.
</p>
</td></tr>
<tr><td><code id="kzs.md_+3A_edges">edges</code></td>
<td>
 
<p>a logical indicating whether or not to display the outcome data beyond the ranges of the <em>d</em>
input variables in <code>x</code>. By default, <code>edges = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details for this function are nearly identical to that of <code><a href="#topic+kzs">kzs</a></code>, except now extended to
<em>d</em>-dimensional space. 
</p>


<h3>Value</h3>

<p>a (<em>d</em>+1)-column data frame of the form <code>(x1, x2, ...,xd, yk)</code>. See <code><a href="#topic+kzs.2d">kzs.2d</a></code> for the general
interpretations of these results.
</p>


<h3>Note</h3>

 
<p>In many applications where input variables can be space, <code>kzs.md</code> can resolve the problem of missing values 
in time series or or irregularly observed valuesin Geographical Information Systems (GIS) data analysis. For these 
applications, <code>scale</code> is especially advantageous because it can create a uniform space over a geographic region
to which the algorithm will be applied. Additionally, <code>kzs.md</code> can be recommended as a diagnostic tool before 
applying multiple linear regression analysis due to its capability of displaying nonlinearities of the outcome over 
the input variables.<br />
</p>
<p>There is no graphical output for this function; for two input variables, <code>kzs.2d</code> will produce a 3-dimensional
plot. For three input variables, a 4-dimensional movie can be constructed over time.<br />
</p>
<p>In general, <code>kzs</code>, <code>kzs.2d</code> and <code>kzs.md</code> are all linear operations, and linear operations are
commutative. Thus, for example, the outcome of a <code>kzs.2d</code> operation is equivalent to <code>kzs.1d</code> + <code>kzs.1d</code>; 
likewise, the outcome of a <code>kzs.3d</code> operation is equivalent to a <code>kzs.2d</code> + <code>kzs.1d</code>, etc...  
</p>


<h3>Author(s)</h3>

<p> Derek Cyr <a href="mailto:cyr.derek@gmail.com">cyr.derek@gmail.com</a> and Igor Zurbenko <a href="mailto:igorg.zurbenko@gmail.com">igorg.zurbenko@gmail.com</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+kzs">kzs</a></code>; For more on the parameter restrictions, see <code><a href="#topic+kzs.params">kzs.params</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is an extension of the example documented in kzs.2d. We make 
# use of the Sinc function to filter a signal buried in noise over 3-dimensional 
# input variables. See the "Details" section of the "kzs.3d_data" data frame 
# documentation for specific details. 
require(lattice)

# Gridded data for X = (X1, X2) input variables
x1 &lt;- seq(-1.5*pi, 1.5*pi, length = 50)
x2 &lt;- x1	
df &lt;- expand.grid(x1 = x1, x2 = x2)
	
# Time dimension
time &lt;- 1:50

# Change the amplitude of the original function to change from 0 to 1 along time
amplitude &lt;- sort(round(seq(0.02, 1, 0.02), digits = 2))

# Store the time and amplitude together in a data frame
t_amp &lt;- data.frame(cbind(time, amplitude))

# Create the data set of Sinc function outcomes for each amplitude
sinc &lt;- array(0, dim = c(nrow(df), length(amplitude)))
for (i in 1:length(amplitude)) {
	sinc[,i] &lt;- round(amplitude[i]*sin(sqrt(df$x1^2 + df$x2^2)) / 
		    	sqrt(df$x1^2 + df$x2^2)) 
	sinc[,i][is.na(sinc[,i])] &lt;- amplitude[i]
}

# Add noise to distort the signal 
for (j in 1:ncol(sinc)) {
	ez &lt;- rnorm(nrow(sinc), mean = 0, sd = 1)
	sinc[,j] &lt;- sinc[,j] + ez
}

# Change to a data frame and add the gridded input data 
kzs.2d_data &lt;- as.data.frame(cbind(df, sinc)) 

### Movie of the signal buried in noise
grayscale = colorRampPalette(c("white", "gray", "black"))
for (u in 1:50) {
	plot(levelplot(kzs.2d_data[,u+2] ~ x1*x2, kzs.2d_data, 
		col.regions = grayscale, colorkey = FALSE))
}

### Movie of KZS 4-dimensional KZS outcome
data(kzs.3d_data)
bluered = colorRampPalette(c("blue", "cyan2", "green", 
			     "yellow", "red", "firebrick"), space = "rgb")
for (j in 1:50) {
	plot(levelplot(kzs.3d_data[,j+2] ~ x1*x2, kzs.3d_data, 
           at = do.breaks(c(-0.3, 1.0), 100), col.regions = bluered))
} 
</code></pre>

<hr>
<h2 id='kzs.params'> Restrictions for KZS Parameters </h2><span id='topic+kzs.params'></span>

<h3>Description</h3>

<p>For a <em>d</em>-dimensional vector of input variables, this function will calculate the values by
which the parameters <code>smooth</code> and <code>scale</code> are bounded by. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kzs.params(x, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kzs.params_+3A_x">x</code></td>
<td>
 
<p>a matrix or data frame containing the input variable(s) that is to be used in <code>kzs</code>, <code>kzs.2d</code>, 
or <code>kzs.md</code>.
</p>
</td></tr>
<tr><td><code id="kzs.params_+3A_dimension">dimension</code></td>
<td>
 
<p>an integer specifying the dimensionality of <code>x</code>; i.e, the number of columns in <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The compilation of functions within the <span class="pkg">kzs</span> package requires the specification of two 
parameters: the first is <code>smooth</code>, the range of smoothing along each variable in <code>x</code>; 
the second is <code>scale</code>, a scale reading of each corresponding input variable in <code>x</code>. 
Each parameter is subject to two restrictions; <code>smooth[i]</code> and <code>scale[i]</code> must be 
positive real numbers; <code>scale[i]</code> must be less than or equal to the difference of sorted, 
consecutive <code>x[,i]</code> values and <code>smooth[i]</code> must be much less than the difference of the
maximum and minimum values for its corresponding input variable, <code>x[,i]</code>. For each input 
variable in <code>x</code>, there must be a corresponding <code>smooth</code> and <code>scale</code>. This function
was developed to be used prior to any of the functions within <span class="pkg">kzs</span> in order to increase the 
efficiency of use.
</p>


<h3>Author(s)</h3>

<p> Derek Cyr <a href="mailto:cyr.derek@gmail.com">cyr.derek@gmail.com</a> and Igor Zurbenko <a href="mailto:igorg.zurbenko@gmail.com">igorg.zurbenko@gmail.com</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 3 random sequences of numbers that would act as the input data set 
x1 &lt;- rnorm(100, 3, 6)
x2 &lt;- rnorm(100, 4, 5)
x3 &lt;- runif(100, 0, 1)

# A matrix or a data frame will work 
mat &lt;- matrix(c(x1, x2, x3), nrow = 100, ncol = 3)

# Dimensionality is 3 since there are 3 input variables
kzs.params(x = mat, dimension = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
