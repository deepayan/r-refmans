<!DOCTYPE html><html><head><title>Help for package irace</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {irace}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ablation'><p>Performs ablation between two configurations (from source to target).</p></a></li>
<li><a href='#ablation_cmdline'><p>Launch ablation with command-line options.</p></a></li>
<li><a href='#buildCommandLine'><p>Generate a command-line representation of a configuration</p></a></li>
<li><a href='#checkIraceScenario'><p>Test that the given irace scenario can be run.</p></a></li>
<li><a href='#checkParameters'><p>checkParameters</p></a></li>
<li><a href='#checkScenario'><p>Check and correct the given scenario</p></a></li>
<li><a href='#CommandArgsParser'><p>R6 Class for parsing command-line arguments</p></a></li>
<li><a href='#configurations.print'><p>Print configurations as a data frame</p></a></li>
<li><a href='#configurations.print.command'><p>Print configurations as command-line strings.</p></a></li>
<li><a href='#defaultScenario'><p>Default scenario settings</p></a></li>
<li><a href='#getConfigurationById'><p>Returns the configurations selected by ID.</p></a></li>
<li><a href='#getConfigurationByIteration'><p>Returns the configurations by the iteration in which they were executed.</p></a></li>
<li><a href='#getFinalElites'><p>Return the elite configurations of the final iteration.</p></a></li>
<li><a href='#irace'><p>irace</p></a></li>
<li><a href='#irace-package'><p>The irace package: Iterated Racing for Automatic Algorithm Configuration</p></a></li>
<li><a href='#irace.cmdline'><p>Launch <code>irace</code> with command-line options.</p></a></li>
<li><a href='#irace.license'><p>irace.license</p></a></li>
<li><a href='#irace.main'><p>Higher-level interface to launch irace.</p></a></li>
<li><a href='#irace.version'><p>irace.version</p></a></li>
<li><a href='#path_rel2abs'><p>Converts a relative path to an absolute path. It tries really hard to create</p>
canonical paths.</a></li>
<li><a href='#plotAblation'><p>Create plot from an ablation log</p></a></li>
<li><a href='#printParameters'><p>Print parameter space in the textual format accepted by irace.</p></a></li>
<li><a href='#printScenario'><p>Prints the given scenario</p></a></li>
<li><a href='#psRace'><p>psRace</p></a></li>
<li><a href='#read_logfile'><p>Read the log file produced by irace (<code>irace.Rdata</code>).</p></a></li>
<li><a href='#read_pcs_file'><p>Read parameters in PCS (AClib) format and write them in irace format.</p></a></li>
<li><a href='#readConfigurationsFile'><p>Read parameter configurations from a file</p></a></li>
<li><a href='#readParameters'><p>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a</p>
character string.</a></li>
<li><a href='#readScenario'><p>Reads from a file the scenario settings to be used by <span class="pkg">irace</span>.</p></a></li>
<li><a href='#removeConfigurationsMetaData'><p>removeConfigurationsMetaData</p></a></li>
<li><a href='#scenario_update_paths'><p>Update filesystem paths of a scenario consistently.</p></a></li>
<li><a href='#target.evaluator.default'><p>target.evaluator.default</p></a></li>
<li><a href='#target.runner.default'><p>Default <code>targetRunner</code> function.</p></a></li>
<li><a href='#testConfigurations'><p>Execute the given configurations on the testing instances specified in the</p>
scenario</a></li>
<li><a href='#testing_fromfile'><p>Test configurations given an explicit table of configurations and a scenario file</p></a></li>
<li><a href='#testing_fromlog'><p>Test configurations given in <code>.Rdata</code> file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterated Racing for Automatic Algorithm Configuration</td>
</tr>
<tr>
<td>Description:</td>
<td>Iterated race is an extension of the Iterated F-race method for
             the automatic configuration of optimization algorithms, that is,
             (offline) tuning their parameters by finding the most appropriate
             settings given a set of instances of an optimization problem.
             M. López-Ibáñez, J. Dubois-Lacoste, L. Pérez Cáceres, T. Stützle,
             and M. Birattari (2016) &lt;<a href="https://doi.org/10.1016%2Fj.orp.2016.09.002">doi:10.1016/j.orp.2016.09.002</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>3.5</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, compiler, R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rmpi (&ge; 0.6.0), parallel, knitr, testthat, withr, mlr (&ge;
2.15.0), ParamHelpers, devtools, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlopez-ibanez.github.io/irace/">https://mlopez-ibanez.github.io/irace/</a>,
<a href="https://github.com/MLopez-Ibanez/irace">https://github.com/MLopez-Ibanez/irace</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MLopez-Ibanez/irace/issues">https://github.com/MLopez-Ibanez/irace/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-23 13:44:18 UTC; manu</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel López-Ibáñez
    <a href="https://orcid.org/0000-0001-9974-1295"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jérémie Dubois-Lacoste [aut],
  Leslie Pérez Cáceres [aut],
  Thomas Stützle [aut],
  Mauro Birattari [aut],
  Eric Yuan [ctb],
  Prasanna Balaprakash [ctb],
  Nguyen Dang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel López-Ibáñez &lt;manuel.lopez-ibanez@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-23 14:55:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ablation'>Performs ablation between two configurations (from source to target).</h2><span id='topic+ablation'></span>

<h3>Description</h3>

<p>Ablation is a method for analyzing the differences between two configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ablation(
  iraceResults,
  src = 1L,
  target = NULL,
  ab.params = NULL,
  type = c("full", "racing"),
  n_instances = 1L,
  seed = 1234567,
  ablationLogFile = "log-ablation.Rdata",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ablation_+3A_iraceresults">iraceResults</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) <code>iraceResults</code> object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="ablation_+3A_src">src</code>, <code id="ablation_+3A_target">target</code></td>
<td>
<p>Source and target configuration IDs. By default, the first configuration ever evaluated (ID 1) is used as <code>src</code> and the best configuration found by irace is used as target.</p>
</td></tr>
<tr><td><code id="ablation_+3A_ab.params">ab.params</code></td>
<td>
<p>Specific parameter names to be used for the ablation. They must be in <code>parameters$names</code>. By default, use all parameters.</p>
</td></tr>
<tr><td><code id="ablation_+3A_type">type</code></td>
<td>
<p>Type of ablation to perform: <code>"full"</code> will execute each configuration on all <code>n_instances</code> to determine the best-performing one; <code>"racing"</code> will apply racing to find the best configurations.</p>
</td></tr>
<tr><td><code id="ablation_+3A_n_instances">n_instances</code></td>
<td>
<p>(<code>integer(1)</code>) Number of instances used in <code>"full"</code> ablation will be <code>n_instances * scenario$firstTest</code>.</p>
</td></tr>
<tr><td><code id="ablation_+3A_seed">seed</code></td>
<td>
<p>(<code>integer(1)</code>) Integer value to use as seed for the random number generation.</p>
</td></tr>
<tr><td><code id="ablation_+3A_ablationlogfile">ablationLogFile</code></td>
<td>
<p>(<code>character(1)</code>) Log file to save the ablation log. If <code>NULL</code>, the results are not saved to a file.</p>
</td></tr>
<tr><td><code id="ablation_+3A_...">...</code></td>
<td>
<p>Further arguments to override scenario settings, e.g., <code>debugLevel</code>, <code>parallel</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>configurations</dt><dd><p>Configurations tested in the ablation.</p>
</dd>
<dt>instances</dt><dd><p>A matrix with the instances used in the experiments. First column has the
instances IDs from <code>iraceResults$scenario$instances</code>, second column the seed assigned to the instance.</p>
</dd>
<dt>experiments</dt><dd><p>A matrix with the results of the experiments (columns are configurations, rows are instances).</p>
</dd>
<dt>scenario</dt><dd><p>Scenario object with the settings used for the experiments.</p>
</dd>
<dt>trajectory</dt><dd><p>IDs of the best configurations at each step of the ablation.</p>
</dd>
<dt>best</dt><dd><p>Best configuration found in the experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres and Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>C. Fawcett and H. H. Hoos. Analysing differences between algorithm
configurations through ablation. Journal of Heuristics, 22(4):431–458, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotAblation">plotAblation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfile &lt;- system.file(package="irace", "exdata", "sann.rda")
# Execute ablation between the first and the best configuration found by irace.
ablog &lt;- ablation(logfile, ablationLogFile = NULL)
plotAblation(ablog)
# Execute ablation between two selected configurations, and selecting only a
# subset of parameters, directly reading the setup from the irace log file.
ablog &lt;- ablation(logfile, src = 1, target = 10,
                  ab.params = c("temp"), ablationLogFile = NULL)
plotAblation(ablog)


</code></pre>

<hr>
<h2 id='ablation_cmdline'>Launch ablation with command-line options.</h2><span id='topic+ablation_cmdline'></span>

<h3>Description</h3>

<p>Launch <code><a href="#topic+ablation">ablation()</a></code> with the same command-line options as the command-line
executable (<code>ablation.exe</code> in Windows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ablation_cmdline(argv = commandArgs(trailingOnly = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ablation_cmdline_+3A_argv">argv</code></td>
<td>
<p>(<code>character()</code>) <br /> The arguments
provided on the R command line as a character vector, e.g.,
<code>c("-i", "irace.Rdata", "--src", 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads the parameters given on the command line
used to invoke R, launches <code><a href="#topic+ablation">ablation()</a></code> and possibly <code><a href="#topic+plotAblation">plotAblation()</a></code>.
</p>
<p>List of command-line options:</p>
<pre>-l,--log-file            Path to the (.Rdata) file created by irace from which
                         the "iraceResults" object will be loaded.
-S,--src                 Source configuration ID. Default: 1.
-T,--target              Target configuration ID. By default the best
                         configuration found by irace.
-P,--params              Specific parameter names to be used for the ablation
                         (separated with commas). By default use all
-t,--type                Type of ablation to perform: "full" will execute each
                         configuration on all "--n-instances" to determine the
                         best-performing one; "racing" will apply racing to
                         find the best configurations. Default: full.
-n,--n-instances         Number of instances used in "full" ablation will be
                         n_instances * scenario$firstTest. Default: 1.
   --seed                Integer value to use as seed for the random number
                         generation. Default: 1234567.
-o,--output-file         Log file to save the ablation log. If "", the results
                         are not saved to a file. Default: log-ablation.Rdata.
-p,--plot                Output filename (.pdf) for the plot. If not given, no
                         plot is created.
-O,--plot-type           Type of plot. Supported values are "mean" and
                         "boxplot". Default: mean.
   --old-path            Old path found in the log-file (.Rdata) given as input
                         to be replaced by --new-path.
   --new-path            New path to replace the path found in the log-file
                         (.Rdata) given as input.
-e,--exec-dir            Directory where the target runner will be run.
-s,--scenario            Scenario file to override the scenario given in the
                         log-file (.Rdata)
   --parallel            Number of calls to targetRunner to execute in
                         parallel. Values 0 or 1 mean no parallelization.
</pre>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>configurations</dt><dd><p>Configurations tested in the ablation.</p>
</dd>
<dt>instances</dt><dd><p>A matrix with the instances used in the experiments. First column has the
instances IDs from <code>iraceResults$scenario$instances</code>, second column the seed assigned to the instance.</p>
</dd>
<dt>experiments</dt><dd><p>A matrix with the results of the experiments (columns are configurations, rows are instances).</p>
</dd>
<dt>scenario</dt><dd><p>Scenario object with the settings used for the experiments.</p>
</dd>
<dt>trajectory</dt><dd><p>IDs of the best configurations at each step of the ablation.</p>
</dd>
<dt>best</dt><dd><p>Best configuration found in the experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ablation_cmdline("--help")

</code></pre>

<hr>
<h2 id='buildCommandLine'>Generate a command-line representation of a configuration</h2><span id='topic+buildCommandLine'></span>

<h3>Description</h3>

<p><code>buildCommandLine</code> receives two vectors, one containing
the values of the parameters, the other containing the switches of the
parameters. It builds a string with the switches and the values that can
be used as a command line to call the program to be tuned, thus generating
one candidate configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCommandLine(values, switches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildCommandLine_+3A_values">values</code></td>
<td>
<p>A vector containing the value of each parameter for the
candidate configuration.</p>
</td></tr>
<tr><td><code id="buildCommandLine_+3A_switches">switches</code></td>
<td>
<p>A vector containing the switches of each paramter (in an
order that corresponds to the values vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string concatenating each element of <code>switches</code> and
<code>values</code> for all parameters with a space between each pair of
parameters (but none between the switches and the corresponding values).
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>Examples</h3>

<pre><code class='language-R'>switches &lt;- c("--switch1 ", "--switch2 ")
values &lt;- c("value_1", "value_2")
buildCommandLine (values, switches)
## Build a command-line from the results produced by a previous run of irace.
# First, load the data produced by irace.
irace.logfile &lt;- file.path(system.file(package="irace"),
                           "exdata", "irace-acotsp.Rdata")
load(irace.logfile)
allConfigurations &lt;- iraceResults$allConfigurations
parameters &lt;- iraceResults$parameters
apply(allConfigurations[1:10, unlist(parameters$names)], 1, buildCommandLine,
      unlist(parameters$switches))

</code></pre>

<hr>
<h2 id='checkIraceScenario'>Test that the given irace scenario can be run.</h2><span id='topic+checkIraceScenario'></span>

<h3>Description</h3>

<p>Test that the given irace scenario can be run by checking the scenario
settings provided and trying to run the target-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIraceScenario(scenario, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIraceScenario_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="checkIraceScenario_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>parameters</code> argument is missing, then the parameters
will be read from the file <code>parameterFile</code>  given by <code>scenario</code>. If
<code>parameters</code> is provided, then <code>parameterFile</code> will not be read.  This function will
try to execute the target-algorithm.
</p>


<h3>Value</h3>

<p>returns <code>TRUE</code> if successful and gives an error and returns
<code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='checkParameters'>checkParameters</h2><span id='topic+checkParameters'></span>

<h3>Description</h3>

<p>FIXME: This is incomplete, for now we only repair inputs from previous irace
versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkParameters(parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkParameters_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='checkScenario'>Check and correct the given scenario</h2><span id='topic+checkScenario'></span>

<h3>Description</h3>

<p>Checks for errors a (possibly incomplete) scenario setup of
<span class="pkg">irace</span>  and transforms it into a valid scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkScenario(scenario = defaultScenario())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkScenario_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks that the directories and the file names
provided and required by the <span class="pkg">irace</span> exist. It also checks that the
settings are of the proper type, e.g. that settings expected to be integers
are really integers. Finally, it also checks that there is no inconsistency
between settings.  If an error is found that prevents <span class="pkg">irace</span> from
running properly, it will stop with an error.
</p>


<h3>Value</h3>

<p>The scenario received as a parameter, possibly corrected. Unset
scenario settings are set to their default values.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='CommandArgsParser'>R6 Class for parsing command-line arguments</h2><span id='topic+CommandArgsParser'></span><span id='topic+cmdline_usage'></span>

<h3>Description</h3>

<p>R6 Class for parsing command-line arguments
</p>
<p>R6 Class for parsing command-line arguments
</p>
<p><code>cmdline_usage()</code> prints the output of <code>--help</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmdline_usage(cmdline_args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CommandArgsParser_+3A_cmdline_args">cmdline_args</code></td>
<td>
<p>Definition of the command-line arguments.</p>
</td></tr>
</table>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>CommandArgsParser$new()</code></a>
</p>
</li>
<li> <p><a href="#method-readCmdLineParameter"><code>CommandArgsParser$readCmdLineParameter()</code></a>
</p>
</li>
<li> <p><a href="#method-readArg"><code>CommandArgsParser$readArg()</code></a>
</p>
</li>
<li> <p><a href="#method-readAll"><code>CommandArgsParser$readAll()</code></a>
</p>
</li>
<li> <p><a href="#method-cmdline_usage"><code>CommandArgsParser$cmdline_usage()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CommandArgsParser$new(argv, argsdef)</pre></div>


<hr>
<a id="method-readCmdLineParameter"></a>



<h4>Method <code>readCmdLineParameter()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CommandArgsParser$readCmdLineParameter(paramName, default = NULL)</pre></div>


<hr>
<a id="method-readArg"></a>



<h4>Method <code>readArg()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CommandArgsParser$readArg(short = "", long = "")</pre></div>


<hr>
<a id="method-readAll"></a>



<h4>Method <code>readAll()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CommandArgsParser$readAll()</pre></div>


<hr>
<a id="method-cmdline_usage"></a>



<h4>Method <code>cmdline_usage()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CommandArgsParser$cmdline_usage()</pre></div>



<hr>
<h2 id='configurations.print'>Print configurations as a data frame</h2><span id='topic+configurations.print'></span>

<h3>Description</h3>

<p>Print configurations as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configurations.print(configurations, metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configurations.print_+3A_configurations">configurations</code></td>
<td>
<p>(<code>data.frame</code>) <br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="configurations.print_+3A_metadata">metadata</code></td>
<td>
<p>A Boolean specifying whether to print the metadata or
not. The metadata are data for the configurations (additionally to the
value of each parameter) used by <span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations.print.command">configurations.print.command()</a></code> to print the configurations as command-line strings.
</p>

<hr>
<h2 id='configurations.print.command'>Print configurations as command-line strings.</h2><span id='topic+configurations.print.command'></span>

<h3>Description</h3>

<p>Prints configurations after converting them into a representation for the
command-line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configurations.print.command(configurations, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configurations.print.command_+3A_configurations">configurations</code></td>
<td>
<p>(<code>data.frame</code>) <br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="configurations.print.command_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations.print">configurations.print()</a></code> to print the configurations as a data frame.
</p>

<hr>
<h2 id='defaultScenario'>Default scenario settings</h2><span id='topic+defaultScenario'></span>

<h3>Description</h3>

<p>Return scenario object with default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultScenario(scenario = list(), params_def = .irace.params.def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultScenario_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="defaultScenario_+3A_params_def">params_def</code></td>
<td>
<p>(<code>data.frame()</code>) <br /> Definition of the options accepted by the scenario. This should only be modified by packages that wish to extend <span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list indexed by the <span class="pkg">irace</span> parameter names,
containing the default values for each parameter, except for those
already present in the scenario passed as argument.
The scenario list contains the following elements:
</p>

<ul>
<li><p> General options:
</p>

<dl>
<dt><code>scenarioFile</code></dt><dd><p>Path of the file that describes the configuration scenario setup and other irace settings. (Default: <code>"./scenario.txt"</code>)</p>
</dd>
<dt><code>execDir</code></dt><dd><p>Directory where the programs will be run. (Default: <code>"./"</code>)</p>
</dd>
<dt><code>logFile</code></dt><dd><p>File to save tuning results as an R dataset, either absolute path or relative to execDir. (Default: <code>"./irace.Rdata"</code>)</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Reduce the output generated by irace to a minimum. (Default: <code>0</code>)</p>
</dd>
<dt><code>debugLevel</code></dt><dd><p>Debug level of the output of <code>irace</code>. Set this to 0 to silence all debug messages. Higher values provide more verbose debug messages. (Default: <code>0</code>)</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed of the random number generator (by default, generate a random seed). (Default: <code>NA</code>)</p>
</dd>
<dt><code>repairConfiguration</code></dt><dd><p>User-defined R function that takes a configuration generated by irace and repairs it. (Default: <code>""</code>)</p>
</dd>
<dt><code>postselection</code></dt><dd><p>Percentage of the configuration budget used to perform a postselection race of the best configurations of each iteration after the execution of irace. (Default: <code>0</code>)</p>
</dd>
<dt><code>aclib</code></dt><dd><p>Enable/disable AClib mode. This option enables compatibility with GenericWrapper4AC as targetRunner script. (Default: <code>0</code>)</p>
</dd>
</dl>

</li>
<li><p> Elitist <code>irace</code>:
</p>

<dl>
<dt><code>elitist</code></dt><dd><p>Enable/disable elitist irace. (Default: <code>1</code>)</p>
</dd>
<dt><code>elitistNewInstances</code></dt><dd><p>Number of instances added to the execution list before previous instances in elitist irace. (Default: <code>1</code>)</p>
</dd>
<dt><code>elitistLimit</code></dt><dd><p>In elitist irace, maximum number per race of elimination tests that do not eliminate a configuration. Use 0 for no limit. (Default: <code>2</code>)</p>
</dd>
</dl>

</li>
<li><p> Internal <code>irace</code> options:
</p>

<dl>
<dt><code>sampleInstances</code></dt><dd><p>Randomly sample the training instances or use them in the order given. (Default: <code>1</code>)</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>Enable/disable the soft restart strategy that avoids premature convergence of the probabilistic model. (Default: <code>1</code>)</p>
</dd>
<dt><code>softRestartThreshold</code></dt><dd><p>Soft restart threshold value for numerical parameters. If <code>NA</code>, <code>NULL</code> or <code>""</code>, it is computed as <code>10^-digits</code>. (Default: <code>""</code>)</p>
</dd>
<dt><code>nbIterations</code></dt><dd><p>Maximum number of iterations. (Default: <code>0</code>)</p>
</dd>
<dt><code>nbExperimentsPerIteration</code></dt><dd><p>Number of runs of the target algorithm per iteration. (Default: <code>0</code>)</p>
</dd>
<dt><code>minNbSurvival</code></dt><dd><p>Minimum number of configurations needed to continue the execution of each race (iteration). (Default: <code>0</code>)</p>
</dd>
<dt><code>nbConfigurations</code></dt><dd><p>Number of configurations to be sampled and evaluated at each iteration. (Default: <code>0</code>)</p>
</dd>
<dt><code>mu</code></dt><dd><p>Parameter used to define the number of configurations sampled and evaluated at each iteration. (Default: <code>5</code>)</p>
</dd>
</dl>

</li>
<li><p> Target algorithm parameters:
</p>

<dl>
<dt><code>parameterFile</code></dt><dd><p>File that contains the description of the parameters of the target algorithm. (Default: <code>"./parameters.txt"</code>)</p>
</dd>
<dt><code>forbiddenExps</code></dt><dd><p>Vector of R logical expressions that cannot evaluate to <code>TRUE</code> for any evaluated configuration. (Default: <code>""</code>)</p>
</dd>
<dt><code>forbiddenFile</code></dt><dd><p>File that contains a list of logical expressions that cannot be <code>TRUE</code> for any evaluated configuration. If empty or <code>NULL</code>, do not use forbidden expressions. (Default: <code>""</code>)</p>
</dd>
<dt><code>digits</code></dt><dd><p>Maximum number of decimal places that are significant for numerical (real) parameters. (Default: <code>4</code>)</p>
</dd>
</dl>

</li>
<li><p> Target algorithm execution:
</p>

<dl>
<dt><code>targetRunner</code></dt><dd><p>Executable called for each configuration that executes the target algorithm to be tuned. See the templates and examples provided. (Default: <code>"./target-runner"</code>)</p>
</dd>
<dt><code>targetRunnerLauncher</code></dt><dd><p>Executable that will be used to launch the target runner, when <code>targetRunner</code> cannot be executed directly (.e.g, a Python script in Windows). (Default: <code>""</code>)</p>
</dd>
<dt><code>targetRunnerLauncherArgs</code></dt><dd><p>Command-line arguments provided to <code>targetRunnerLauncher</code>. The substrings <code>{targetRunner}</code> and <code>{targetRunnerArgs}</code> will be replaced by the value of the option <code>targetRunner</code> and by the arguments usually passed when calling <code>targetRunner</code>, respectively. Example: <code>"-m {targetRunner} --args {targetRunnerArgs}"</code>. (Default: <code>"{targetRunner} {targetRunnerArgs}"</code>)</p>
</dd>
<dt><code>targetRunnerRetries</code></dt><dd><p>Number of times to retry a call to <code>targetRunner</code> if the call failed. (Default: <code>0</code>)</p>
</dd>
<dt><code>targetRunnerData</code></dt><dd><p>Optional data passed to <code>targetRunner</code>. This is ignored by the default <code>targetRunner</code> function, but it may be used by custom <code>targetRunner</code> functions to pass persistent data around. (Default: <code>""</code>)</p>
</dd>
<dt><code>targetRunnerParallel</code></dt><dd><p>Optional R function to provide custom parallelization of <code>targetRunner</code>. (Default: <code>""</code>)</p>
</dd>
<dt><code>targetEvaluator</code></dt><dd><p>Optional script or R function that provides a numeric value for each configuration. See templates/target-evaluator.tmpl (Default: <code>""</code>)</p>
</dd>
<dt><code>deterministic</code></dt><dd><p>If the target algorithm is deterministic, configurations will be evaluated only once per instance. (Default: <code>0</code>)</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Number of calls to <code>targetRunner</code> to execute in parallel. Values <code>0</code> or <code>1</code> mean no parallelization. (Default: <code>0</code>)</p>
</dd>
<dt><code>loadBalancing</code></dt><dd><p>Enable/disable load-balancing when executing experiments in parallel. Load-balancing makes better use of computing resources, but increases communication overhead. If this overhead is large, disabling load-balancing may be faster. (Default: <code>1</code>)</p>
</dd>
<dt><code>mpi</code></dt><dd><p>Enable/disable MPI. Use <code>Rmpi</code> to execute <code>targetRunner</code> in parallel (parameter <code>parallel</code> is the number of slaves). (Default: <code>0</code>)</p>
</dd>
<dt><code>batchmode</code></dt><dd><p>Specify how irace waits for jobs to finish when <code>targetRunner</code> submits jobs to a batch cluster: sge, pbs, torque, slurm or htcondor. <code>targetRunner</code> must submit jobs to the cluster using, for example, <code>qsub</code>. (Default: <code>0</code>)</p>
</dd>
</dl>

</li>
<li><p> Initial configurations:
</p>

<dl>
<dt><code>initConfigurations</code></dt><dd><p>Data frame describing initial configurations (usually read from a file using <code>readConfigurations</code>). (Default: <code>""</code>)</p>
</dd>
<dt><code>configurationsFile</code></dt><dd><p>File that contains a table of initial configurations. If empty or <code>NULL</code>, all initial configurations are randomly generated. (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Training instances:
</p>

<dl>
<dt><code>instances</code></dt><dd><p>Character vector of the instances to be used in the <code>targetRunner</code>. (Default: <code>""</code>)</p>
</dd>
<dt><code>trainInstancesDir</code></dt><dd><p>Directory where training instances are located; either absolute path or relative to current directory. If no <code>trainInstancesFiles</code> is provided, all the files in <code>trainInstancesDir</code> will be listed as instances. (Default: <code>"./Instances"</code>)</p>
</dd>
<dt><code>trainInstancesFile</code></dt><dd><p>File that contains a list of training instances and optionally additional parameters for them. If <code>trainInstancesDir</code> is provided, <code>irace</code> will search for the files in this folder. (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Tuning budget:
</p>

<dl>
<dt><code>maxExperiments</code></dt><dd><p>Maximum number of runs (invocations of <code>targetRunner</code>) that will be performed. It determines the maximum budget of experiments for the tuning. (Default: <code>0</code>)</p>
</dd>
<dt><code>maxTime</code></dt><dd><p>Maximum total execution time in seconds for the executions of <code>targetRunner</code>. <code>targetRunner</code> must return two values: cost and time. (Default: <code>0</code>)</p>
</dd>
<dt><code>budgetEstimation</code></dt><dd><p>Fraction (smaller than 1) of the budget used to estimate the mean computation time of a configuration. Only used when <code>maxTime</code> &gt; 0 (Default: <code>0.02</code>)</p>
</dd>
<dt><code>minMeasurableTime</code></dt><dd><p>Minimum time unit that is still (significantly) measureable. (Default: <code>0.01</code>)</p>
</dd>
</dl>

</li>
<li><p> Statistical test:
</p>

<dl>
<dt><code>testType</code></dt><dd><p>Statistical test used for elimination. The default value selects <code>t-test</code> if <code>capping</code> is enabled or <code>F-test</code>, otherwise. Valid values are: F-test (Friedman test), t-test (pairwise t-tests with no correction), t-test-bonferroni (t-test with Bonferroni's correction for multiple comparisons), t-test-holm (t-test with Holm's correction for multiple comparisons). (Default: <code>""</code>)</p>
</dd>
<dt><code>firstTest</code></dt><dd><p>Number of instances evaluated before the first elimination test. It must be a multiple of <code>eachTest</code>. (Default: <code>5</code>)</p>
</dd>
<dt><code>eachTest</code></dt><dd><p>Number of instances evaluated between elimination tests. (Default: <code>1</code>)</p>
</dd>
<dt><code>confidence</code></dt><dd><p>Confidence level for the elimination test. (Default: <code>0.95</code>)</p>
</dd>
</dl>

</li>
<li><p> Adaptive capping:
</p>

<dl>
<dt><code>capping</code></dt><dd><p>Enable the use of adaptive capping, a technique designed for minimizing the computation time of configurations. This is only available when <code>elitist</code> is active. (Default: <code>0</code>)</p>
</dd>
<dt><code>cappingType</code></dt><dd><p>Measure used to obtain the execution bound from the performance of the elite configurations.</p>
<ul>
<li><p> median: Median performance of the elite configurations.</p>
</li>
<li><p> mean: Mean performance of the elite configurations.</p>
</li>
<li><p> best: Best performance of the elite configurations.</p>
</li>
<li><p> worst: Worst performance of the elite configurations.</p>
</li></ul>
<p> (Default: <code>"median"</code>)</p>
</dd>
<dt><code>boundType</code></dt><dd><p>Method to calculate the mean performance of elite configurations.</p>
<ul>
<li><p> candidate: Mean execution times across the executed instances and the current one.</p>
</li>
<li><p> instance: Execution time of the current instance.</p>
</li></ul>
<p> (Default: <code>"candidate"</code>)</p>
</dd>
<dt><code>boundMax</code></dt><dd><p>Maximum execution bound for <code>targetRunner</code>. It must be specified when capping is enabled. (Default: <code>0</code>)</p>
</dd>
<dt><code>boundDigits</code></dt><dd><p>Precision used for calculating the execution time. It must be specified when capping is enabled. (Default: <code>0</code>)</p>
</dd>
<dt><code>boundPar</code></dt><dd><p>Penalization constant for timed out executions (executions that reach <code>boundMax</code> execution time). (Default: <code>1</code>)</p>
</dd>
<dt><code>boundAsTimeout</code></dt><dd><p>Replace the configuration cost of bounded executions with <code>boundMax</code>. (Default: <code>1</code>)</p>
</dd>
</dl>

</li>
<li><p> Recovery:
</p>

<dl>
<dt><code>recoveryFile</code></dt><dd><p>Previously saved log file to recover the execution of <code>irace</code>, either absolute path or relative to the current directory.  If empty or <code>NULL</code>, recovery is not performed. (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Testing:
</p>

<dl>
<dt><code>testInstancesDir</code></dt><dd><p>Directory where testing instances are located, either absolute or relative to current directory. (Default: <code>""</code>)</p>
</dd>
<dt><code>testInstancesFile</code></dt><dd><p>File containing a list of test instances and optionally additional parameters for them. (Default: <code>""</code>)</p>
</dd>
<dt><code>testInstances</code></dt><dd><p>Character vector of the instances to be used in the <code>targetRunner</code> when executing the testing. (Default: <code>""</code>)</p>
</dd>
<dt><code>testNbElites</code></dt><dd><p>Number of elite configurations returned by irace that will be tested if test instances are provided. (Default: <code>1</code>)</p>
</dd>
<dt><code>testIterationElites</code></dt><dd><p>Enable/disable testing the elite configurations found at each iteration. (Default: <code>0</code>)</p>
</dd>
</dl>

</li></ul>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='getConfigurationById'>Returns the configurations selected by ID.</h2><span id='topic+getConfigurationById'></span>

<h3>Description</h3>

<p>Returns the configurations selected by ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfigurationById(iraceResults, ids, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfigurationById_+3A_iraceresults">iraceResults</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) <code>iraceResults</code> object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getConfigurationById_+3A_ids">ids</code></td>
<td>
<p>The id or a vector of ids of the candidates configurations to obtain.</p>
</td></tr>
<tr><td><code id="getConfigurationById_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p>Remove metadata, such the configuration ID and
the ID of the parent, from the returned configurations. See
<code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>

<hr>
<h2 id='getConfigurationByIteration'>Returns the configurations by the iteration in which they were executed.</h2><span id='topic+getConfigurationByIteration'></span>

<h3>Description</h3>

<p>Returns the configurations by the iteration in which they were executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfigurationByIteration(iraceResults, iterations, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfigurationByIteration_+3A_iraceresults">iraceResults</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) <code>iraceResults</code> object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getConfigurationByIteration_+3A_iterations">iterations</code></td>
<td>
<p>The iteration number or a vector of iteration numbers from where
the configurations should be obtained.</p>
</td></tr>
<tr><td><code id="getConfigurationByIteration_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p>(<code>FALSE</code>) Remove metadata, such the configuration ID and
the ID of the parent, from the returned configurations. See
<code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>

<hr>
<h2 id='getFinalElites'>Return the elite configurations of the final iteration.</h2><span id='topic+getFinalElites'></span>

<h3>Description</h3>

<p>Return the elite configurations of the final iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFinalElites(iraceResults, n = 0L, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFinalElites_+3A_iraceresults">iraceResults</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) <code>iraceResults</code> object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getFinalElites_+3A_n">n</code></td>
<td>
<p>Number of elite configurations to return, if <code>n</code> is larger than the
number of configurations, then only the existing ones are returned. The default (<code>n=0</code>) returns all of them.</p>
</td></tr>
<tr><td><code id="getFinalElites_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p>Remove metadata, such the configuration ID and
the ID of the parent, from the returned configurations. See
<code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_file &lt;- system.file("exdata/irace-acotsp.Rdata", package="irace", mustWork=TRUE)
print(removeConfigurationsMetaData(getFinalElites(log_file, n=1)))

</code></pre>

<hr>
<h2 id='irace'>irace</h2><span id='topic+irace'></span>

<h3>Description</h3>

<p><code>irace</code> implements iterated Race. It receives some parameters to be tuned
and returns the best configurations found, namely, the elite configurations
obtained from the last iterations (and sorted by rank).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace(scenario, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irace_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="irace_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>irace</code> executes the tuning procedure using
the information provided in <code>scenario</code> and <code>parameters</code>. Initially it checks
the correctness of <code>scenario</code> and recovers a previous execution if
<code>scenario$recoveryFile</code> is set. A R data file log of the execution is created
in <code>scenario$logFile</code>.
</p>


<h3>Value</h3>

<p>(<code>data.frame</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters R object containing the
description of the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimentLog</code></dt><dd><p>A matrix with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>scenario$instancesList</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>A list that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+irace.main">irace.main()</a></code></dt><dd><p>a higher-level interface to <code>irace</code>.</p>
</dd>
<dt><code><a href="#topic+irace.cmdline">irace.cmdline()</a></code></dt><dd><p>a command-line interface to <code>irace</code>.</p>
</dd>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+readParameters">readParameters()</a></code></dt><dd><p>read the target algorithm parameters from a file.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
parameters &lt;- readParameters("parameters.txt")
scenario &lt;- readScenario(filename = "scenario.txt")
irace(scenario = scenario, parameters = parameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='irace-package'>The irace package: Iterated Racing for Automatic Algorithm Configuration</h2><span id='topic+irace-package'></span>

<h3>Description</h3>

<p>Iterated race is an extension of the Iterated F-race method for
             the automatic configuration of optimization algorithms, that is,
             (offline) tuning their parameters by finding the most appropriate
             settings given a set of instances of an optimization problem.
             M. López-Ibáñez, J. Dubois-Lacoste, L. Pérez Cáceres, T. Stützle,
             and M. Birattari (2016) &lt;doi:10.1016/j.orp.2016.09.002&gt;.
</p>


<h3>Details</h3>

<p>License: GPL (&gt;= 2)
</p>


<h3>Author(s)</h3>

<p>Maintainers: Manuel López-Ibáñez and Leslie Pérez Cáceres
<a href="mailto:irace-package@googlegroups.com">irace-package@googlegroups.com</a>
</p>


<h3>References</h3>

<p>Manuel López-Ibáñez, Jérémie Dubois-Lacoste, Leslie Pérez Cáceres,
Thomas Stützle, and Mauro Birattari. The irace package: Iterated
Racing for Automatic Algorithm Configuration. <em>Operations Research
Perspectives</em>, 2016. doi: <a href="https://doi.org/10.1016/j.orp.2016.09.002">10.1016/j.orp.2016.09.002</a>
</p>
<p>Manuel López-Ibáñez, Jérémie Dubois-Lacoste, Thomas Stützle, and Mauro
Birattari. <em>The irace package, Iterated Race for Automatic
Algorithm Configuration</em>. Technical Report TR/IRIDIA/2011-004, IRIDIA,
Université Libre de Bruxelles, Belgium, 2011.
</p>
<p>Manuel López-Ibáñez and Thomas Stützle. The Automatic Design of
Multi-Objective Ant Colony Optimization Algorithms. <em>IEEE Transactions
on Evolutionary Computation</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irace.main">irace.main</a></code> to start <span class="pkg">irace</span> with a given scenario.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #######################################################################
 # This example illustrates how to tune the parameters of the simulated
 # annealing algorithm (SANN) provided by the optim() function in the
 # R base package.  The goal in this example is to optimize instances of
 # the following family:
 # f(x) = lambda * f_rastrigin(x) + (1 - lambda) * f_rosenbrock(x)
 # where lambda follows a normal distribution whose mean is 0.9 and
 # standard deviation is 0.02. f_rastrigin and f_rosenbrock are the
 # well-known Rastrigin and Rosenbrock benchmark functions (taken from
 # the cmaes package). In this scenario, different instances are given
 # by different values of lambda.
 #######################################################################
 ## First we provide an implementation of the functions to be optimized:
 f_rosenbrock &lt;- function (x) {
   d &lt;- length(x)
   z &lt;- x + 1
   hz &lt;- z[1:(d - 1)]
   tz &lt;- z[2:d]
   s &lt;- sum(100 * (hz^2 - tz)^2 + (hz - 1)^2)
   return(s)
 }
 f_rastrigin &lt;- function (x) {
   sum(x * x - 10 * cos(2 * pi * x) + 10)
 }
 
 ## We generate 20 instances (in this case, weights):
 weights &lt;- rnorm(20, mean = 0.9, sd = 0.02)
 
 ## On this set of instances, we are interested in optimizing two
 ## parameters of the SANN algorithm: tmax and temp. We setup the
 ## parameter space as follows:
 parameters_table &lt;- '
 tmax "" i,log (1, 5000)
 temp "" r (0, 100)
 '
 
 ## We use the irace function readParameters to read this table:
 parameters &lt;- readParameters(text = parameters_table)
 
 ## Next, we define the function that will evaluate each candidate
 ## configuration on a single instance. For simplicity, we restrict to
 ## three-dimensional functions and we set the maximum number of
 ## iterations of SANN to 1000.
 target_runner &lt;- function(experiment, scenario)
 {
   instance &lt;- experiment$instance
   configuration &lt;- experiment$configuration
 
   D &lt;- 3
   par &lt;- runif(D, min=-1, max=1)
   fn &lt;- function(x) {
     weight &lt;- instance
     return(weight * f_rastrigin(x) + (1 - weight) * f_rosenbrock(x))
   }
   res &lt;- stats::optim(par,fn, method="SANN",
                control=list(maxit=1000
                  , tmax = as.numeric(configuration[["tmax"]])
                  , temp = as.numeric(configuration[["temp"]])
                  ))
   ## New output interface in irace 2.0. This list may also contain:
   ## - 'time' if irace is called with 'maxTime'
   ## - 'error' is a string used to report an error
   ## - 'outputRaw' is a string used to report the raw output of calls to
   ##   an external program or function.
   ## - 'call' is a string used to report how target_runner called the
   ##   external program or function.
   return(list(cost = res$value))
 }
 
 ## We define a configuration scenario by setting targetRunner to the
 ## function define above, instances to the first 10 random weights, and
 ## a maximum budget of 'maxExperiments' calls to targetRunner.
 scenario &lt;- list(targetRunner = target_runner,
                  instances = weights[1:10],
                  maxExperiments = 500,
                  # Do not create a logFile
                  logFile = "")
 
 ## We check that the scenario is valid. This will also try to execute
 ## target_runner.
 checkIraceScenario(scenario, parameters = parameters)
 
 
 ## We are now ready to launch irace. We do it by means of the irace
 ## function. The function will print information about its
 ## progress. This may require a few minutes, so it is not run by default.
 tuned_confs &lt;- irace(scenario = scenario, parameters = parameters)
 
 ## We can print the best configurations found by irace as follows:
 configurations.print(tuned_confs)
 
 ## We can evaluate the quality of the best configuration found by
 ## irace versus the default configuration of the SANN algorithm on
 ## the other 10 instances previously generated.
 ## To do so, first we apply the default configuration of the SANN
 ## algorithm to these instances:
 test &lt;- function(configuration)
 {
   res &lt;- lapply(weights[11:20],
                 function(x) target_runner(
                               experiment = list(instance = x,
                                                 configuration = configuration),
                               scenario = scenario))
   return (sapply(res, getElement, name = "cost"))
 }
 default &lt;- test(data.frame(tmax=10, temp=10))
 ## We extract and apply the winning configuration found by irace
 ## to these instances:
 tuned &lt;- test(removeConfigurationsMetaData(tuned_confs[1,]))
 
 ## Finally, we can compare using a boxplot the quality obtained with the
 ## default parametrization of SANN and the quality obtained with the
 ## best configuration found by irace.
 boxplot(list(default = default, tuned = tuned))


</code></pre>

<hr>
<h2 id='irace.cmdline'>Launch <code>irace</code> with command-line options.</h2><span id='topic+irace.cmdline'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+irace.main">irace.main()</a></code> using command-line options, maybe parsed from the
command line used to invoke R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace.cmdline(argv = commandArgs(trailingOnly = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irace.cmdline_+3A_argv">argv</code></td>
<td>
<p>(<code>character()</code>) <br /> The arguments
provided on the R command line as a character vector, e.g.,
<code>c("--scenario", "scenario.txt", "-p", "parameters.txt")</code>.
Using the  default value (not providing the parameter) is the
easiest way to call <code>irace.cmdline</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads the parameters given on the command line
used to invoke R, finds the name of the scenario file,
initializes the scenario from the file (with the function
<code><a href="#topic+readScenario">readScenario</a></code>) and possibly from parameters passed in
the command line. It finally starts <span class="pkg">irace</span> by calling
<code><a href="#topic+irace.main">irace.main</a></code>.
</p>
<p>List of command-line options:</p>
<pre>-h,--help                Show this help.
-v,--version             Show irace package version.
-c,--check               Check scenario.
-i,--init                Initialize the working directory with template config
                         files.
   --only-test           Only test the configurations given in the file passed
                         as argument.
-s,--scenario            File that describes the configuration scenario setup
                         and other irace settings. Default: ./scenario.txt.
   --exec-dir            Directory where the programs will be run. Default: ./.
-p,--parameter-file      File that contains the description of the parameters
                         of the target algorithm. Default: ./parameters.txt.
   --forbidden-file      File that contains a list of logical expressions that
                         cannot be TRUE for any evaluated configuration. If
                         empty or NULL, do not use forbidden expressions.
   --configurations-file  File that contains a table of initial configurations.
                         If empty or NULL, all initial configurations are
                         randomly generated.
-l,--log-file            File to save tuning results as an R dataset, either
                         absolute path or relative to execDir. Default:
                         ./irace.Rdata.
   --recovery-file       Previously saved log file to recover the execution of
                         irace, either absolute path or relative to the current
                         directory.  If empty or NULL, recovery is not
                         performed.
   --train-instances-dir  Directory where training instances are located;
                         either absolute path or relative to current directory.
                         If no trainInstancesFiles is provided, all the files
                         in trainInstancesDir will be listed as instances.
                         Default: ./Instances.
   --train-instances-file  File that contains a list of training instances and
                         optionally additional parameters for them. If
                         trainInstancesDir is provided, irace will search for
                         the files in this folder.
   --sample-instances    Randomly sample the training instances or use them in
                         the order given. Default: 1.
   --test-instances-dir  Directory where testing instances are located, either
                         absolute or relative to current directory.
   --test-instances-file  File containing a list of test instances and
                         optionally additional parameters for them.
   --test-num-elites     Number of elite configurations returned by irace that
                         will be tested if test instances are provided.
                         Default: 1.
   --test-iteration-elites  Enable/disable testing the elite configurations
                         found at each iteration. Default: 0.
   --test-type           Statistical test used for elimination. The default
                         value selects t-test if capping is enabled or F-test,
                         otherwise. Valid values are: F-test (Friedman test),
                         t-test (pairwise t-tests with no correction),
                         t-test-bonferroni (t-test with Bonferroni's correction
                         for multiple comparisons), t-test-holm (t-test with
                         Holm's correction for multiple comparisons).
   --first-test          Number of instances evaluated before the first
                         elimination test. It must be a multiple of eachTest.
                         Default: 5.
   --each-test           Number of instances evaluated between elimination
                         tests. Default: 1.
   --target-runner       Executable called for each configuration that executes
                         the target algorithm to be tuned. See the templates
                         and examples provided. Default: ./target-runner.
   --target-runner-launcher  Executable that will be used to launch the target
                         runner, when targetRunner cannot be executed directly
                         (.e.g, a Python script in Windows).
   --target-runner-args  Command-line arguments provided to
                         targetRunnerLauncher. The substrings \{targetRunner\}
                         and \{targetRunnerArgs\} will be replaced by the value
                         of the option targetRunner and by the arguments
                         usually passed when calling targetRunner,
                         respectively. Example: "-m {targetRunner --args
                         {targetRunnerArgs}"}. Default: {targetRunner}
                         {targetRunnerArgs}.
   --target-runner-retries  Number of times to retry a call to targetRunner if
                         the call failed. Default: 0.
   --target-evaluator    Optional script or R function that provides a numeric
                         value for each configuration. See
                         templates/target-evaluator.tmpl
   --deterministic       If the target algorithm is deterministic,
                         configurations will be evaluated only once per
                         instance. Default: 0.
   --max-experiments     Maximum number of runs (invocations of targetRunner)
                         that will be performed. It determines the maximum
                         budget of experiments for the tuning. Default: 0.
   --max-time            Maximum total execution time in seconds for the
                         executions of targetRunner. targetRunner must return
                         two values: cost and time. Default: 0.
   --budget-estimation   Fraction (smaller than 1) of the budget used to
                         estimate the mean computation time of a configuration.
                         Only used when maxTime &gt; 0 Default: 0.02.
   --min-measurable-time  Minimum time unit that is still (significantly)
                         measureable. Default: 0.01.
   --parallel            Number of calls to targetRunner to execute in
                         parallel. Values 0 or 1 mean no parallelization.
                         Default: 0.
   --load-balancing      Enable/disable load-balancing when executing
                         experiments in parallel. Load-balancing makes better
                         use of computing resources, but increases
                         communication overhead. If this overhead is large,
                         disabling load-balancing may be faster. Default: 1.
   --mpi                 Enable/disable MPI. Use Rmpi to execute targetRunner
                         in parallel (parameter parallel is the number of
                         slaves). Default: 0.
   --batchmode           Specify how irace waits for jobs to finish when
                         targetRunner submits jobs to a batch cluster: sge,
                         pbs, torque, slurm or htcondor. targetRunner must
                         submit jobs to the cluster using, for example, qsub.
                         Default: 0.
   --digits              Maximum number of decimal places that are significant
                         for numerical (real) parameters. Default: 4.
-q,--quiet               Reduce the output generated by irace to a minimum.
                         Default: 0.
   --debug-level         Debug level of the output of irace. Set this to 0 to
                         silence all debug messages. Higher values provide more
                         verbose debug messages. Default: 0.
   --seed                Seed of the random number generator (by default,
                         generate a random seed).
   --soft-restart        Enable/disable the soft restart strategy that avoids
                         premature convergence of the probabilistic model.
                         Default: 1.
   --soft-restart-threshold  Soft restart threshold value for numerical
                         parameters. If NA, NULL or "", it is computed as
                         10^-digits.
-e,--elitist             Enable/disable elitist irace. Default: 1.
   --elitist-new-instances  Number of instances added to the execution list
                         before previous instances in elitist irace. Default:
                         1.
   --elitist-limit       In elitist irace, maximum number per race of
                         elimination tests that do not eliminate a
                         configuration. Use 0 for no limit. Default: 2.
   --capping             Enable the use of adaptive capping, a technique
                         designed for minimizing the computation time of
                         configurations. This is only available when elitist is
                         active. Default: 0.
   --capping-type        Measure used to obtain the execution bound from the
                         performance of the elite configurations: median, mean,
                         worst, best. Default: median.
   --bound-type          Method to calculate the mean performance of elite
                         configurations: candidate or instance. Default:
                         candidate.
   --bound-max           Maximum execution bound for targetRunner. It must be
                         specified when capping is enabled. Default: 0.
   --bound-digits        Precision used for calculating the execution time. It
                         must be specified when capping is enabled. Default: 0.
   --bound-par           Penalization constant for timed out executions
                         (executions that reach boundMax execution time).
                         Default: 1.
   --bound-as-timeout    Replace the configuration cost of bounded executions
                         with boundMax. Default: 1.
   --postselection       Percentage of the configuration budget used to perform
                         a postselection race of the best configurations of
                         each iteration after the execution of irace. Default:
                         0.
   --aclib               Enable/disable AClib mode. This option enables
                         compatibility with GenericWrapper4AC as targetRunner
                         script. Default: 0.
   --iterations          Maximum number of iterations. Default: 0.
   --experiments-per-iteration  Number of runs of the target algorithm per
                         iteration. Default: 0.
   --min-survival        Minimum number of configurations needed to continue
                         the execution of each race (iteration). Default: 0.
   --num-configurations  Number of configurations to be sampled and evaluated
                         at each iteration. Default: 0.
   --mu                  Parameter used to define the number of configurations
                         sampled and evaluated at each iteration. Default: 5.
   --confidence          Confidence level for the elimination test. Default:
                         0.95.
</pre>


<h3>Value</h3>

<p>(<code>invisible(data.frame)</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters R object containing the
description of the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimentLog</code></dt><dd><p>A matrix with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>scenario$instancesList</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>A list that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irace.main">irace.main()</a></code> to start <span class="pkg">irace</span> with a given scenario.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irace.cmdline("--version")
</code></pre>

<hr>
<h2 id='irace.license'>irace.license</h2><span id='topic+irace.license'></span>

<h3>Description</h3>

<p>A character string containing the license information of <span class="pkg">irace</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace.license
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='irace.main'>Higher-level interface to launch irace.</h2><span id='topic+irace.main'></span>

<h3>Description</h3>

<p>Higher-level interface to launch irace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace.main(scenario, output.width = 9999L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irace.main_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="irace.main_+3A_output.width">output.width</code></td>
<td>
<p>(<code>integer(1)</code>) The width used for the screen
output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the correctness of the scenario, reads the
parameter space from <code>scenario$parameterFile</code>, invokes <code><a href="#topic+irace">irace()</a></code>,
prints its results in various formatted ways, (optionally) calls
<code><a href="#topic+psRace">psRace()</a></code> and, finally, evaluates the best configurations on the test
instances (if provided). If you want a lower-level interface that just
runs irace, please see function <code><a href="#topic+irace">irace()</a></code>.
</p>


<h3>Value</h3>

<p>(<code>invisible(data.frame)</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters R object containing the
description of the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimentLog</code></dt><dd><p>A matrix with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>scenario$instancesList</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>A list that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irace.cmdline">irace.cmdline()</a></code> a higher-level command-line interface to
<code><a href="#topic+irace">irace()</a></code>
<code><a href="#topic+readScenario">readScenario()</a></code> to read the scenario setup from  a file.
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> to provide a default scenario for <span class="pkg">irace</span>.
</p>

<hr>
<h2 id='irace.version'>irace.version</h2><span id='topic+irace.version'></span>

<h3>Description</h3>

<p>A character string containing the version of <code>irace</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace.version
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='path_rel2abs'>Converts a relative path to an absolute path. It tries really hard to create
canonical paths.</h2><span id='topic+path_rel2abs'></span>

<h3>Description</h3>

<p>Converts a relative path to an absolute path. It tries really hard to create
canonical paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_rel2abs(path, cwd = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_rel2abs_+3A_path">path</code></td>
<td>
<p>(<code>character(1)</code>) Character string representing a relative path.</p>
</td></tr>
<tr><td><code id="path_rel2abs_+3A_cwd">cwd</code></td>
<td>
<p>(<code>character(1)</code>) Current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>character(1)</code>) Character string representing the absolute path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_rel2abs("..")
</code></pre>

<hr>
<h2 id='plotAblation'>Create plot from an ablation log</h2><span id='topic+plotAblation'></span>

<h3>Description</h3>

<p>Create plot from an ablation log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAblation(
  ablog,
  pdf.file = NULL,
  pdf.width = 20,
  type = c("mean", "boxplot"),
  mar = par("mar"),
  ylab = "Mean configuration cost",
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAblation_+3A_ablog">ablog</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) Ablation log object returned by <code><a href="#topic+ablation">ablation()</a></code>. Alternatively, the path to an <code>.Rdata</code> file, e.g., <code>"log-ablation.Rdata"</code>, from which the object will be loaded.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_pdf.file">pdf.file</code></td>
<td>
<p>Output filename.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_pdf.width">pdf.width</code></td>
<td>
<p>Width provided to create the pdf file.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_type">type</code></td>
<td>
<p>Type of plot. Supported values are <code>"mean"</code> and <code>"boxplot"</code>.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_mar">mar</code></td>
<td>
<p>Vector with the margins for the ablation plot.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates ranges.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may also be supplied as
arguments. See <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres and Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ablation">ablation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfile &lt;- file.path(system.file(package="irace"), "exdata", "log-ablation.Rdata")
plotAblation(ablog = logfile)
</code></pre>

<hr>
<h2 id='printParameters'>Print parameter space in the textual format accepted by irace.</h2><span id='topic+printParameters'></span>

<h3>Description</h3>

<p>FIXME: Dependent parameter bounds are not supported yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printParameters(params, digits = 15L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printParameters_+3A_params">params</code></td>
<td>
<p>(<code>list()</code>) Parameter object stored in <code>irace.Rdata</code> or read with <code>irace::readParameters()</code>.</p>
</td></tr>
<tr><td><code id="printParameters_+3A_digits">digits</code></td>
<td>
<p>(<code>integer()</code>) The desired number of digits after the decimal point for real-valued parameters. Default is 15, but it should be the value in <code>scenario$digits</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> parameters.table &lt;- '
 # name       switch           type  values               [conditions (using R syntax)]
 algorithm    "--"             c     (as,mmas,eas,ras,acs)
 localsearch  "--localsearch " c     (0, 1, 2, 3)
 ants         "--ants "        i,log (5, 100)
 q0           "--q0 "          r     (0.0, 1.0)           | algorithm == "acs"
 nnls         "--nnls "        i     (5, 50)              | localsearch %in% c(1,2,3)
 '
parameters &lt;- readParameters(text=parameters.table)
printParameters(parameters)
</code></pre>

<hr>
<h2 id='printScenario'>Prints the given scenario</h2><span id='topic+printScenario'></span>

<h3>Description</h3>

<p>Prints the given scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printScenario(scenario)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printScenario_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='psRace'>psRace</h2><span id='topic+psRace'></span>

<h3>Description</h3>

<p><code>psRace</code> performs a postselection race a set of configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psRace(
  iraceLogFile = NULL,
  iraceResults = NULL,
  conf.ids = NULL,
  postselection = NULL,
  max.experiments = NULL,
  elites = FALSE,
  seed = 1234567
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psRace_+3A_iracelogfile">iraceLogFile</code></td>
<td>
<p>NULL Log file created by <span class="pkg">irace</span>, this file must contain the
<code>iraceResults</code> object.</p>
</td></tr>
<tr><td><code id="psRace_+3A_iraceresults">iraceResults</code></td>
<td>
<p>NULL Object created by <span class="pkg">irace</span> and saved in <code>scenario$logFile</code>.</p>
</td></tr>
<tr><td><code id="psRace_+3A_conf.ids">conf.ids</code></td>
<td>
<p>NULL IDs of the configurations in iraceResults$allConfigurations to be used for ablation.
If NULL, the elites argument will be used.</p>
</td></tr>
<tr><td><code id="psRace_+3A_postselection">postselection</code></td>
<td>
<p>NULL Percentage of the maxExperiments provided in the scenario to be used in the race.</p>
</td></tr>
<tr><td><code id="psRace_+3A_max.experiments">max.experiments</code></td>
<td>
<p>NULL Number of experiments available for the race. If NULL budget for the race is set
by the parameter scenario$postselection, which defines the percentage of the total budget of <span class="pkg">irace</span>
(iraceResults$scenario$maxExperiments or iraceResults$scenario$maxTime/iraceResults$state$timeEstimate) to use
for the postselection.</p>
</td></tr>
<tr><td><code id="psRace_+3A_elites">elites</code></td>
<td>
<p>FALSE Flag for selecting configurations. If FALSE, the best configurations of each
iteration are used for the race. If TRUE, the elite configurtions of each iteration are used for the race.</p>
</td></tr>
<tr><td><code id="psRace_+3A_seed">seed</code></td>
<td>
<p>1234567 Numerical value to use as seed for the random number generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If iraceLogFile is NULL, it returns a list with the following elements:
</p>

<dl>
<dt>configurations</dt><dd><p>Configurations used in the race.</p>
</dd>
<dt>instances</dt><dd><p>A matrix with the instances used in the experiments. First column has the
instances ids from iraceResults$scenario$instances, second column the seed assigned to the instance.</p>
</dd>
<dt>maxExperiments</dt><dd><p>Maximum number of experiments set for the race.</p>
</dd>
<dt>experiments</dt><dd><p>A matrix with the results of the experiments (columns are configurations, rows are instances).</p>
</dd>
<dt>elites</dt><dd><p>Best configurations found in the experiments.</p>
</dd>
</dl>

<p>If <code>iraceLogFile</code> is provided this list object will be saved in <code>iraceResults$psrace.log</code>.
</p>


<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Execute the postselection automatically after irace
  scenario &lt;- readScenario(filename="scenario.txt")
  parameters &lt;- readParameters("parameters.txt")
  # Use 10% of the total budget
  scenario$postselection &lt;- 0.1
  irace(scenario=scenario, parameters=parameters)
  # Execute the postselection after the execution of \pkg{irace}.
  psRace(iraceLogFile="irace.Rdata", max.experiments=120)

## End(Not run)

</code></pre>

<hr>
<h2 id='read_logfile'>Read the log file produced by irace (<code>irace.Rdata</code>).</h2><span id='topic+read_logfile'></span>

<h3>Description</h3>

<p>Read the log file produced by irace (<code>irace.Rdata</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_logfile(filename, name = "iraceResults")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_logfile_+3A_filename">filename</code></td>
<td>
<p>Filename that contains the log file saved by irace. Example: <code>irace.Rdata</code>.</p>
</td></tr>
<tr><td><code id="read_logfile_+3A_name">name</code></td>
<td>
<p>Optional argument that allows overriding the default name of the object in the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list()</code>)
</p>

<hr>
<h2 id='read_pcs_file'>Read parameters in PCS (AClib) format and write them in irace format.</h2><span id='topic+read_pcs_file'></span>

<h3>Description</h3>

<p>Read parameters in PCS (AClib) format and write them in irace format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pcs_file(file, digits = 4, debugLevel = 0, text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pcs_file_+3A_file">file</code></td>
<td>
<p>(<code>character(1)</code>) <br /> Filename containing the definitions of
the parameters to be tuned.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_digits">digits</code></td>
<td>
<p>The number of decimal places to be considered for the real
parameters.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_debuglevel">debugLevel</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_text">text</code></td>
<td>
<p>(<code>character(1)</code>) <br /> If <code>file</code> is not supplied and this is,
then parameters are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>file</code> or <code>text</code> must be given. If <code>file</code> is given, the
parameters are read from the file <code>file</code>. If <code>text</code> is given instead,
the parameters are read directly from the <code>text</code> character string.
In both cases, the parameters must be given (in <code>text</code> or in the file
whose name is <code>file</code>) in the expected form.  See the documentation
for details.  If none of these parameters is given, <span class="pkg">irace</span>
will stop with an error.
</p>
<p><strong>FIXME:</strong> Forbidden configurations, default configuration and transformations (&quot;log&quot;) are currently ignored. See <a href="https://github.com/MLopez-Ibanez/irace/issues/31">https://github.com/MLopez-Ibanez/irace/issues/31</a>
</p>


<h3>Value</h3>

<p>A string representing the parameters in irace format.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Frank Hutter, Manuel López-Ibáñez, Chris Fawcett, Marius Thomas Lindauer, Holger H. Hoos, Kevin Leyton-Brown, and Thomas Stützle. <strong>AClib: A Benchmark Library for Algorithm Configuration</strong>. In P. M. Pardalos, M. G. C. Resende, C. Vogiatzis, and J. L. Walteros, editors, <em>Learning and Intelligent Optimization, 8th International Conference, LION 8</em>, volume 8426 of Lecture Notes in Computer Science, pages 36–40. Springer, Heidelberg, 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Read the parameters directly from text
 pcs_table &lt;- '
 # name       domain
 algorithm    {as,mmas,eas,ras,acs}[as]
 localsearch  {0, 1, 2, 3}[0]
 alpha        [0.00, 5.00][1]
 beta         [0.00, 10.00][1]
 rho          [0.01, 1.00][0.95]
 ants         [5, 100][10]i
 q0           [0.0, 1.0][0]
 rasrank      [1, 100][1]i
 elitistants  [1, 750][1]i
 nnls         [5, 50][5]i
 dlb          {0, 1}[1] 
 Conditionals:
 q0 | algorithm in {acs}
 rasrank | algorithm in {ras}
 elitistants | algorithm in {eas}
 nnls | localsearch in {1,2,3}
 dlb | localsearch in {1,2,3}
 '
 parameters_table &lt;- read_pcs_file(text=pcs_table)
 cat(parameters_table)
 parameters &lt;- readParameters(text=parameters_table)
 str(parameters)

</code></pre>

<hr>
<h2 id='readConfigurationsFile'>Read parameter configurations from a file</h2><span id='topic+readConfigurationsFile'></span>

<h3>Description</h3>

<p>Reads a set of target-algorithm configurations from a file and puts them in
<span class="pkg">irace</span> format. The configurations are checked to match the parameters
description provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readConfigurationsFile(filename, parameters, debugLevel = 0, text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readConfigurationsFile_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) <br /> Filename from which the configurations should be read. The contents should be readable by <code>read.table( , header=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_debuglevel">debugLevel</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_text">text</code></td>
<td>
<p>(<code>character(1)</code>) <br /> If <code>file</code> is not supplied and this is,
then parameters are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example of an input file:</p>
<pre># This is a comment line
&lt;param_name_1&gt;  &lt;param_name_2&gt; ... 
      0.5           "value_1"    ...
      1.0           "value_2"    ...
      1.2           "value_3"    ...
      ...           ...
</pre>
<p>The order of the columns does not necessarily have to be the same
as in the file containing the definition of the parameters.
</p>


<h3>Value</h3>

<p>A data frame containing the obtained configurations.
Each row of the data frame is a candidate configuration,
the columns correspond to the parameter names in <code>parameters</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readParameters">readParameters()</a></code> to obtain a valid parameter structure from a parameters file.
</p>

<hr>
<h2 id='readParameters'>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a
character string.</h2><span id='topic+readParameters'></span>

<h3>Description</h3>

<p>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a
character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readParameters(file, digits = 4, debugLevel = 0, text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readParameters_+3A_file">file</code></td>
<td>
<p>(<code>character(1)</code>) <br /> Filename containing the definitions of
the parameters to be tuned.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_digits">digits</code></td>
<td>
<p>The number of decimal places to be considered for the real
parameters.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_debuglevel">debugLevel</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_text">text</code></td>
<td>
<p>(<code>character(1)</code>) <br /> If <code>file</code> is not supplied and this is,
then parameters are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>file</code> or <code>text</code> must be given. If <code>file</code> is given, the
parameters are read from the file <code>file</code>. If <code>text</code> is given instead,
the parameters are read directly from the <code>text</code> character string.
In both cases, the parameters must be given (in <code>text</code> or in the file
whose name is <code>file</code>) in the expected form.  See the documentation
for details.  If none of these parameters is given, <span class="pkg">irace</span>
will stop with an error.
</p>
<p>A fixed parameter is a parameter that should not be sampled but
instead should be always set to the only value of its domain.  In this
function we set isFixed to TRUE only if the parameter is a categorical
and has only one possible value.  If it is an integer and the minimum
and maximum are equal, or it is a real and the minimum and maximum
values satisfy <code>round(minimum, digits) == round(maximum, digits)</code>,
then the parameter description is rejected as invalid to identify
potential user errors.
</p>


<h3>Value</h3>

<p>A list containing the definitions of the parameters read. The list is
structured as follows:
</p>

<dl>
<dt><code>names</code></dt><dd><p>Vector that contains the names of the parameters.</p>
</dd>
<dt><code>types</code></dt><dd><p>Vector that contains the type of each parameter 'i', 'c', 'r', 'o'.
Numerical parameters can be sampled in a log-scale with 'i,log' and 'r,log'
(no spaces).</p>
</dd>
<dt><code>switches</code></dt><dd><p>Vector that contains the switches to be used for the
parameters on the command line.</p>
</dd>
<dt><code>domain</code></dt><dd><p>List of vectors, where each vector may contain two
values (minimum, maximum) for real and integer parameters, or
possibly more for categorical parameters.</p>
</dd>
<dt><code>conditions</code></dt><dd><p>List of R logical expressions, with variables
corresponding to parameter names.</p>
</dd>
<dt><code>isFixed</code></dt><dd><p>Logical vector that specifies which parameter is fixed
and, thus, it does not need to be tuned.</p>
</dd>
<dt><code>nbParameters</code></dt><dd><p>An integer, the total number of parameters.</p>
</dd>
<dt><code>nbFixed</code></dt><dd><p>An integer, the number of parameters with a fixed value.</p>
</dd>
<dt><code>nbVariable</code></dt><dd><p>Number of variable (to be tuned) parameters.</p>
</dd>
<dt><code>depends</code></dt><dd><p>List of character vectors, each vector specifies
which parameters depend on this one.</p>
</dd>
<dt><code>isDependent</code></dt><dd><p>Logical vector that specifies which parameter has
a dependent domain.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Read the parameters directly from text
 parameters.table &lt;- '
 # name       switch           type  values               [conditions (using R syntax)]
 algorithm    "--"             c     (as,mmas,eas,ras,acs)
 localsearch  "--localsearch " c     (0, 1, 2, 3)
 alpha        "--alpha "       r     (0.00, 5.00)
 beta         "--beta "        r     (0.00, 10.00)
 rho          "--rho  "        r     (0.01, 1.00)
 ants         "--ants "        i,log (5, 100)
 q0           "--q0 "          r     (0.0, 1.0)           | algorithm == "acs"
 rasrank      "--rasranks "    i     (1, "min(ants, 10)") | algorithm == "ras"
 elitistants  "--elitistants " i     (1, ants)            | algorithm == "eas"
 nnls         "--nnls "        i     (5, 50)              | localsearch %in% c(1,2,3)
 dlb          "--dlb "         c     (0, 1)               | localsearch %in% c(1,2,3)
 '
 parameters &lt;- readParameters(text=parameters.table)
 str(parameters)

</code></pre>

<hr>
<h2 id='readScenario'>Reads from a file the scenario settings to be used by <span class="pkg">irace</span>.</h2><span id='topic+readScenario'></span>

<h3>Description</h3>

<p>Reads from a file the scenario settings to be used by <span class="pkg">irace</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readScenario(filename = "", scenario = list(), params_def = .irace.params.def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readScenario_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) <br /> Filename from which the scenario will
be read. If empty, the default <code>scenarioFile</code> is used.  An example
scenario file is provided in <code style="white-space: pre;">&#8288;system.file(``package="irace",&#8288;</code>
<code style="white-space: pre;">&#8288;"templates/scenario.txt.tmpl")&#8288;</code>.</p>
</td></tr>
<tr><td><code id="readScenario_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.
This is an initial scenario that is overwritten</p>
</td></tr>
<tr><td><code id="readScenario_+3A_params_def">params_def</code></td>
<td>
<p>(<code>data.frame()</code>) <br /> Definition of the options accepted by the scenario. This should only be modified by packages that wish to extend <span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scenario list read from the file. The scenario settings not
present in the file are not present in the list, i.e., they are <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='removeConfigurationsMetaData'>removeConfigurationsMetaData</h2><span id='topic+removeConfigurationsMetaData'></span>

<h3>Description</h3>

<p>Remove the columns with &quot;metadata&quot; of a matrix containing some
configuration configurations. These &quot;metadata&quot; are used internaly
by <span class="pkg">irace</span>. This function can be used e.g. before printing
the configurations, to output only the values for the parameters
of the configuration without data possibly useless to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeConfigurationsMetaData(configurations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeConfigurationsMetaData_+3A_configurations">configurations</code></td>
<td>
<p>(<code>data.frame</code>) <br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same matrix without the &quot;metadata&quot;.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations.print.command">configurations.print.command()</a></code> to print the configurations as command lines.
<code><a href="#topic+configurations.print">configurations.print()</a></code> to print the configurations as a data frame.
</p>

<hr>
<h2 id='scenario_update_paths'>Update filesystem paths of a scenario consistently.</h2><span id='topic+scenario_update_paths'></span><span id='topic+scenario.update.paths'></span>

<h3>Description</h3>

<p>This function should be used to change the filesystem paths stored in a
scenario object. Useful when moving a scenario from one computer to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scenario_update_paths(scenario, from, to, fixed = TRUE)

scenario.update.paths(scenario, from, to, fixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scenario_update_paths_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_from">from</code></td>
<td>
<p>character string containing a regular expression (or character
string for <code>fixed = TRUE</code>) to be matched.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_to">to</code></td>
<td>
<p>the replacement string.character string. For <code>fixed = FALSE</code>
this can include backreferences <code>"\1"</code> to <code>"\9"</code> to
parenthesized subexpressions of <code>from</code>.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_fixed">fixed</code></td>
<td>
<p>logical.  If <code>TRUE</code>, <code>from</code> is a string to be matched
as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated scenario
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">base::grep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
scenario &lt;- readScenario(filename = "scenario.txt")
scenario &lt;- scenario_update_paths(scenario, from = "/home/manuel/", to = "/home/leslie")

## End(Not run)
</code></pre>

<hr>
<h2 id='target.evaluator.default'>target.evaluator.default</h2><span id='topic+target.evaluator.default'></span>

<h3>Description</h3>

<p><code>target.evaluator.default</code> is the default <code>targetEvaluator</code> function that is
invoked if <code>targetEvaluator</code> is a string (by default
<code>targetEvaluator</code> is <code>NULL</code> and this function is not invoked). You can use it as
an advanced example of how to create your own <code>targetEvaluator</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.evaluator.default(
  experiment,
  num.configurations,
  all.conf.id,
  scenario,
  target.runner.call
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.evaluator.default_+3A_experiment">experiment</code></td>
<td>
<p>A list describing the experiment. It contains at least:
</p>

<dl>
<dt><code>id.configuration</code></dt><dd><p>An alphanumeric string that uniquely identifies a configuration;</p>
</dd>
<dt><code>id.instance</code></dt><dd><p>An alphanumeric string that uniquely identifies an instance;</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for the random number generator to be used for
this evaluation, ignore the seed for deterministic algorithms;</p>
</dd>
<dt><code>instance</code></dt><dd><p>String giving the instance to be used for this evaluation;</p>
</dd>
<dt><code>bound</code></dt><dd><p>(only when <code>capping</code> is enabled) Time bound for the execution;</p>
</dd>
<dt><code>configuration</code></dt><dd><p>1-row data frame with a column per parameter
name;</p>
</dd>
<dt><code>switches</code></dt><dd><p>Vector of parameter switches (labels) in the order
of parameters used in <code>configuration</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="target.evaluator.default_+3A_num.configurations">num.configurations</code></td>
<td>
<p>Number of  configurations alive in the race.</p>
</td></tr>
<tr><td><code id="target.evaluator.default_+3A_all.conf.id">all.conf.id</code></td>
<td>
<p>Vector of configuration IDs of the alive configurations.</p>
</td></tr>
<tr><td><code id="target.evaluator.default_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="target.evaluator.default_+3A_target.runner.call">target.runner.call</code></td>
<td>
<p>String describing the call to <code>targetRunner</code> that
corresponds to this call to <code>targetEvaluator</code>. This is used for
providing extra information to the user, for example, in case
<code>targetEvaluator</code> fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>targetEvaluator</code> must return a list with one element
<code>"cost"</code>, the numerical value corresponding to the cost measure of the
given configuration on the given instance.
</p>
<p>The return list may also contain the following optional elements that are used
by <span class="pkg">irace</span> for reporting errors in <code>targetEvaluator</code>:
</p>

<dl>
<dt><code>error</code></dt><dd><p>is a string used to report an error;</p>
</dd>
<dt><code>outputRaw</code></dt><dd><p>is a string used to report the raw output of calls to
an external program or function;</p>
</dd>
<dt><code>call</code></dt><dd><p>is a string used to report how <code>targetRunner</code> called
an external program or function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>

<hr>
<h2 id='target.runner.default'>Default <code>targetRunner</code> function.</h2><span id='topic+target.runner.default'></span>

<h3>Description</h3>

<p>Use it as an advanced example of how to create your own <code>targetRunner</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.runner.default(experiment, scenario)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.runner.default_+3A_experiment">experiment</code></td>
<td>
<p>A list describing the experiment. It contains at least:
</p>

<dl>
<dt><code>id.configuration</code></dt><dd><p>An alphanumeric string that uniquely identifies a configuration;</p>
</dd>
<dt><code>id.instance</code></dt><dd><p>An alphanumeric string that uniquely identifies an instance;</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for the random number generator to be used for
this evaluation, ignore the seed for deterministic algorithms;</p>
</dd>
<dt><code>instance</code></dt><dd><p>String giving the instance to be used for this evaluation;</p>
</dd>
<dt><code>bound</code></dt><dd><p>(only when <code>capping</code> is enabled) Time bound for the execution;</p>
</dd>
<dt><code>configuration</code></dt><dd><p>1-row data frame with a column per parameter
name;</p>
</dd>
<dt><code>switches</code></dt><dd><p>Vector of parameter switches (labels) in the order
of parameters used in <code>configuration</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="target.runner.default_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>targetEvaluator</code> is <code>NULL</code>, then the <code>targetRunner</code>
function must return a list with at least one element <code>"cost"</code>,
the numerical value corresponding to the evaluation of the given
configuration on the given instance.
</p>
<p>If the scenario option <code>maxTime</code> is non-zero or if <code>capping</code> is enabled
then the list must contain at least another element <code>"time"</code> that reports the
execution time for this call to <code>targetRunner</code>.
The return list may also contain the following optional elements that are used
by <span class="pkg">irace</span> for reporting errors in <code>targetRunner</code>:
</p>

<dl>
<dt><code>error</code></dt><dd><p>is a string used to report an error;</p>
</dd>
<dt><code>outputRaw</code></dt><dd><p>is a string used to report the raw output of calls to
an external program or function;</p>
</dd>
<dt><code>call</code></dt><dd><p>is a string used to report how <code>targetRunner</code> called
an external program or function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>

<hr>
<h2 id='testConfigurations'>Execute the given configurations on the testing instances specified in the
scenario</h2><span id='topic+testConfigurations'></span>

<h3>Description</h3>

<p>Execute the given configurations on the testing instances specified in the
scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testConfigurations(configurations, scenario, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testConfigurations_+3A_configurations">configurations</code></td>
<td>
<p>(<code>data.frame</code>) <br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="testConfigurations_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="testConfigurations_+3A_parameters">parameters</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A test instance set must be provided through <code>scenario[["testInstances"]]</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>experiments</code></dt><dd><p>Experiments results.</p>
</dd>
<dt><code>seeds</code></dt><dd><p>Array of the instance seeds used in the experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testing_fromlog">testing_fromlog()</a></code>
</p>

<hr>
<h2 id='testing_fromfile'>Test configurations given an explicit table of configurations and a scenario file</h2><span id='topic+testing_fromfile'></span>

<h3>Description</h3>

<p>Executes the testing of an explicit list of configurations given in
<code>filename</code> (same format as in <code><a href="#topic+readConfigurationsFile">readConfigurationsFile()</a></code>). A <code>logFile</code> is
created unless disabled in <code>scenario</code>. This may overwrite an existing one!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing_fromfile(filename, scenario)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testing_fromfile_+3A_filename">filename</code></td>
<td>
<p>Path to a file containing configurations: one configuration
per line, one parameter per column, parameter names in header.</p>
</td></tr>
<tr><td><code id="testing_fromfile_+3A_scenario">scenario</code></td>
<td>
<p>(<code>list()</code>) <br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iraceResults
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testing_fromlog">testing_fromlog()</a></code> provides a different interface for testing.
</p>

<hr>
<h2 id='testing_fromlog'>Test configurations given in <code>.Rdata</code> file</h2><span id='topic+testing_fromlog'></span>

<h3>Description</h3>

<p><code>testing_fromlog</code> executes the testing of the target algorithm configurations
found by an <span class="pkg">irace</span> execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing_fromlog(
  logFile,
  testNbElites,
  testIterationElites,
  testInstancesDir,
  testInstancesFile,
  testInstances
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testing_fromlog_+3A_logfile">logFile</code></td>
<td>
<p>Path to the <code>.Rdata</code> file produced by <span class="pkg">irace</span>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testnbelites">testNbElites</code></td>
<td>
<p>Number of (final) elite configurations to test. Overrides
the value found in <code>logFile</code>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testiterationelites">testIterationElites</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>FALSE</code>, only the final
<code>testNbElites</code> configurations are tested; otherwise, also test the best
configurations of each iteration. Overrides the value found in <code>logFile</code>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstancesdir">testInstancesDir</code></td>
<td>
<p>Directory where testing instances are located, either absolute or relative to current directory.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstancesfile">testInstancesFile</code></td>
<td>
<p>File containing a list of test instances and optionally additional parameters for them.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstances">testInstances</code></td>
<td>
<p>Character vector of the instances to be used in the <code>targetRunner</code> when executing the testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>testing_fromlog</code> loads the <code>logFile</code> and obtains the
testing setup and configurations to be tested.  Within the <code>logFile</code>, the
variable <code>scenario$testNbElites</code> specifies how many final elite
configurations to test and <code>scenario$testIterationElites</code> indicates
whether test the best configuration of each iteration. The values may be
overridden by setting the corresponding arguments in this function.  The
set of testing instances must appear in <code>scenario[["testInstances"]]</code>.
</p>


<h3>Value</h3>

<p>Boolean. <code>TRUE</code> if the testing ended successfully otherwise, <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defaultScenario">defaultScenario()</a></code> to provide a default scenario for <span class="pkg">irace</span>.
<code><a href="#topic+testing_fromfile">testing_fromfile()</a></code> provides a different interface for testing.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
