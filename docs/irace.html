<!DOCTYPE html><html lang="en"><head><title>Help for package irace</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {irace}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#irace-package'><p>The irace package: Iterated Racing for Automatic Algorithm Configuration</p></a></li>
<li><a href='#ablation'><p>Performs ablation between two configurations (from source to target).</p></a></li>
<li><a href='#ablation_cmdline'><p>Launch ablation with command-line options.</p></a></li>
<li><a href='#buildCommandLine'><p>Generate a command-line representation of a configuration</p></a></li>
<li><a href='#check_output_target_runner'><p>Check the output of the target runner and repair it if possible. If the</p>
output is incorrect, this function will throw an error.</a></li>
<li><a href='#checkIraceScenario'><p>Test that the given irace scenario can be run.</p></a></li>
<li><a href='#checkParameters'><p>checkParameters</p></a></li>
<li><a href='#checkScenario'><p>Check and correct the given scenario</p></a></li>
<li><a href='#configurations_print'><p>Print configurations as a data frame</p></a></li>
<li><a href='#configurations_print_command'><p>Print configurations as command-line strings.</p></a></li>
<li><a href='#defaultScenario'><p>Default scenario settings</p></a></li>
<li><a href='#get_instanceID_seed_pairs'><p>Returns the pairs of instance IDs and seeds used as instances in the race</p>
(and optionally the actual instances).</a></li>
<li><a href='#getConfigurationById'><p>Returns the configurations selected by ID.</p></a></li>
<li><a href='#getConfigurationByIteration'><p>Returns the configurations by the iteration in which they were executed.</p></a></li>
<li><a href='#getFinalElites'><p>Return the elite configurations of the final iteration.</p></a></li>
<li><a href='#has_testing_data'><p>Check if the results object generated by irace has data about the testing phase.</p></a></li>
<li><a href='#irace'><p>Execute one run of the Iterated Racing algorithm.</p></a></li>
<li><a href='#irace_cmdline'><p>Launch <code>irace</code> with command-line options.</p></a></li>
<li><a href='#irace_license'><p>irace_license</p></a></li>
<li><a href='#irace_main'><p>Higher-level interface to launch irace.</p></a></li>
<li><a href='#irace_summarise'><p>Summarise the results of a run of irace</p></a></li>
<li><a href='#irace_version'><p>A character string containing the version of <code>irace</code> including git SHA.</p></a></li>
<li><a href='#multi_irace'><p>Execute <code>irace()</code> multiple times with the same or different scenarios and parameter space definitions.</p></a></li>
<li><a href='#parameters'><p>Create a parameter space to be tuned.</p></a></li>
<li><a href='#path_rel2abs'><p>Converts a relative path to an absolute path.</p></a></li>
<li><a href='#plotAblation'><p>Create plot from an ablation log</p></a></li>
<li><a href='#printParameters'><p>Print parameter space in the textual format accepted by irace.</p></a></li>
<li><a href='#printScenario'><p>Prints the given scenario</p></a></li>
<li><a href='#psRace'><p>Post-selection race</p></a></li>
<li><a href='#random_seed'><p>Get, set and restore the state of the random number generator state.</p></a></li>
<li><a href='#read_ablogfile'><p>Read the log file (<code>log-ablation.Rdata</code>) produced by <code>ablation()</code>.</p></a></li>
<li><a href='#read_logfile'><p>Read the log file produced by irace (<code>irace.Rdata</code>).</p></a></li>
<li><a href='#read_pcs_file'><p>Read parameters in PCS (AClib) format and write them in irace format.</p></a></li>
<li><a href='#readConfigurationsFile'><p>Read parameter configurations from a file</p></a></li>
<li><a href='#readParameters'><p>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a</p>
character string.</a></li>
<li><a href='#readScenario'><p>Reads from a file the scenario settings to be used by <span class="pkg">irace</span>.</p></a></li>
<li><a href='#removeConfigurationsMetaData'><p>removeConfigurationsMetaData</p></a></li>
<li><a href='#save_irace_logfile'><p>Save the log generated by <span class="pkg">irace</span> to a file (by default <code>irace.Rdata</code>).</p></a></li>
<li><a href='#scenario_update_paths'><p>Update filesystem paths of a scenario consistently.</p></a></li>
<li><a href='#target_evaluator_default'><p>target_evaluator_default</p></a></li>
<li><a href='#target_runner_default'><p>Default <code>targetRunner</code> function.</p></a></li>
<li><a href='#testConfigurations'><p>Execute the given configurations on the testing instances specified in the</p>
scenario</a></li>
<li><a href='#testing_fromfile'><p>Test configurations given an explicit table of configurations and a scenario file</p></a></li>
<li><a href='#testing_fromlog'><p>Test configurations given in the logfile (typically <code>irace.Rdata</code>) produced by <span class="pkg">irace</span>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterated Racing for Automatic Algorithm Configuration</td>
</tr>
<tr>
<td>Description:</td>
<td>Iterated race is an extension of the Iterated F-race method for
             the automatic configuration of optimization algorithms, that is,
             (offline) tuning their parameters by finding the most appropriate
             settings given a set of instances of an optimization problem.
             M. López-Ibáñez, J. Dubois-Lacoste, L. Pérez Cáceres, T. Stützle,
             and M. Birattari (2016) &lt;<a href="https://doi.org/10.1016%2Fj.orp.2016.09.002">doi:10.1016/j.orp.2016.09.002</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, codetools, compiler, data.table (&ge; 1.15.0), fs,
matrixStats (&ge; 1.4.1), spacefillr, stats, utils, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rmpi (&ge; 0.6.0), highr, knitr, parallel, testthat (&ge; 3.1.8)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlopez-ibanez.github.io/irace/">https://mlopez-ibanez.github.io/irace/</a>,
<a href="https://github.com/MLopez-Ibanez/irace">https://github.com/MLopez-Ibanez/irace</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MLopez-Ibanez/irace/issues">https://github.com/MLopez-Ibanez/irace/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-10 17:00:56 UTC; manu</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel López-Ibáñez
    <a href="https://orcid.org/0000-0001-9974-1295"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jérémie Dubois-Lacoste [aut],
  Leslie Pérez Cáceres [aut],
  Thomas Stützle [aut],
  Mauro Birattari [aut],
  Eric Yuan [ctb],
  Prasanna Balaprakash [ctb],
  Nguyen Dang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel López-Ibáñez &lt;manuel.lopez-ibanez@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='irace-package'>The irace package: Iterated Racing for Automatic Algorithm Configuration</h2><span id='topic+irace-package'></span>

<h3>Description</h3>

<p>Iterated race is an extension of the Iterated F-race method for
             the automatic configuration of optimization algorithms, that is,
             (offline) tuning their parameters by finding the most appropriate
             settings given a set of instances of an optimization problem.
             M. López-Ibáñez, J. Dubois-Lacoste, L. Pérez Cáceres, T. Stützle,
             and M. Birattari (2016) &lt;doi:10.1016/j.orp.2016.09.002&gt;.
</p>


<h3>Details</h3>

<p>License: GPL (&gt;= 2)
</p>


<h3>Author(s)</h3>

<p>Maintainers: Manuel López-Ibáñez and Leslie Pérez Cáceres
<a href="mailto:irace-package@googlegroups.com">irace-package@googlegroups.com</a>
</p>


<h3>References</h3>

<p>Manuel López-Ibáñez, Jérémie Dubois-Lacoste, Leslie Pérez Cáceres,
Thomas Stützle, and Mauro Birattari. The irace package: Iterated
Racing for Automatic Algorithm Configuration. <em>Operations Research
Perspectives</em>, 2016. doi: <a href="https://doi.org/10.1016/j.orp.2016.09.002">10.1016/j.orp.2016.09.002</a>
</p>
<p>Manuel López-Ibáñez, Jérémie Dubois-Lacoste, Thomas Stützle, and Mauro
Birattari. <em>The irace package, Iterated Race for Automatic
Algorithm Configuration</em>. Technical Report TR/IRIDIA/2011-004, IRIDIA,
Université Libre de Bruxelles, Belgium, 2011.
</p>
<p>Manuel López-Ibáñez and Thomas Stützle. The Automatic Design of
Multi-Objective Ant Colony Optimization Algorithms. <em>IEEE Transactions
on Evolutionary Computation</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irace">irace()</a></code> for examples and <code>vignette(package = "irace")</code> for the user-guide.
</p>

<hr>
<h2 id='ablation'>Performs ablation between two configurations (from source to target).</h2><span id='topic+ablation'></span>

<h3>Description</h3>

<p>Ablation is a method for analyzing the differences between two configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ablation(
  iraceResults,
  src = 1L,
  target = NULL,
  ab_params = NULL,
  type = c("full", "racing"),
  nrep = 1L,
  seed = 1234567L,
  ablationLogFile = "log-ablation.Rdata",
  instancesFile = "train",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ablation_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="ablation_+3A_src">src</code>, <code id="ablation_+3A_target">target</code></td>
<td>
<p><code>integer(1)|character(1)</code><br /> Source and target configuration IDs. By default, the first configuration ever evaluated (ID 1) is used as <code>src</code> and the best configuration found by irace is used as target. If the argument is a string, it is interpreted as the path to a file, with the format specified by  <code><a href="#topic+readConfigurationsFile">readConfigurationsFile()</a></code>, that contains the configuration.</p>
</td></tr>
<tr><td><code id="ablation_+3A_ab_params">ab_params</code></td>
<td>
<p><code>character()</code><br /> Specific parameter names to be used for the ablation. They must be in <code>parameters$names</code>. By default, use all parameters.</p>
</td></tr>
<tr><td><code id="ablation_+3A_type">type</code></td>
<td>
<p><code>"full"|"racing"</code><br /> Type of ablation to perform: <code>"full"</code> will execute each configuration on all <code>n_instances</code> to determine the best-performing one; <code>"racing"</code> will apply racing to find the best configurations.</p>
</td></tr>
<tr><td><code id="ablation_+3A_nrep">nrep</code></td>
<td>
<p><code>integer(1)</code><br /> Number of replications per instance used in <code>"full"</code> ablation. When <code>nrep &gt; 1</code>, each configuration will be executed <code>nrep</code> times on each instance with different random seeds.</p>
</td></tr>
<tr><td><code id="ablation_+3A_seed">seed</code></td>
<td>
<p><code>integer(1)</code><br /> Integer value to use as seed for the random number generation.</p>
</td></tr>
<tr><td><code id="ablation_+3A_ablationlogfile">ablationLogFile</code></td>
<td>
<p><code>character(1)</code><br /> Log file to save the ablation log. If <code>NULL</code>, the results are not saved to a file.</p>
</td></tr>
<tr><td><code id="ablation_+3A_instancesfile">instancesFile</code></td>
<td>
<p><code>character(1)</code><br /> Instances file used for ablation: <code>'train'</code>, <code>'test'</code> or a filename containing the list of instances.</p>
</td></tr>
<tr><td><code id="ablation_+3A_...">...</code></td>
<td>
<p>Further arguments to override scenario settings, e.g., <code>debugLevel</code>, <code>parallel</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>allConfigurations</dt><dd><p>Configurations tested in the ablation.</p>
</dd>
<dt>state</dt><dd><p>State of the ablation process.</p>
</dd>
<dt>experiments</dt><dd><p>A matrix with the results of the experiments (columns are configurations, rows are instances).</p>
</dd>
<dt>scenario</dt><dd><p>Scenario object with the settings used for the experiments.</p>
</dd>
<dt>trajectory</dt><dd><p>IDs of the best configurations at each step of the ablation.</p>
</dd>
<dt>best</dt><dd><p>Best configuration found in the experiments.</p>
</dd>
<dt>complete</dt><dd><p><code>TRUE</code> if the ablation process was completed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres and Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>C. Fawcett and H. H. Hoos. Analysing differences between algorithm
configurations through ablation. Journal of Heuristics, 22(4):431–458, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotAblation">plotAblation()</a></code> <code><a href="#topic+ablation_cmdline">ablation_cmdline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfile &lt;- system.file(package="irace", "exdata", "sann.rda")
# Execute ablation between the first and the best configuration found by irace.
ablog &lt;- ablation(logfile, ablationLogFile = NULL)
plotAblation(ablog)
# Execute ablation between two selected configurations, and selecting only a
# subset of parameters, directly reading the setup from the irace log file.
ablog &lt;- ablation(logfile, src = 1, target = 10,
                  ab_params = c("temp"), ablationLogFile = NULL)
plotAblation(ablog)


</code></pre>

<hr>
<h2 id='ablation_cmdline'>Launch ablation with command-line options.</h2><span id='topic+ablation_cmdline'></span>

<h3>Description</h3>

<p>Launch <code><a href="#topic+ablation">ablation()</a></code> with the same command-line options as the command-line
executable (<code>ablation.exe</code> in Windows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ablation_cmdline(argv = commandArgs(trailingOnly = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ablation_cmdline_+3A_argv">argv</code></td>
<td>
<p><code>character()</code><br /> The arguments
provided on the R command line as a character vector, e.g.,
<code>c("-i", "irace.Rdata", "--src", 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads the parameters given on the command line
used to invoke R, launches <code><a href="#topic+ablation">ablation()</a></code> and possibly <code><a href="#topic+plotAblation">plotAblation()</a></code>.
</p>
<p>List of command-line options:
</p>
<div class="sourceCode"><pre>-l,--log-file            Path to the (.Rdata) file created by irace from which
                         the "iraceResults" object will be loaded.
-S,--src                 Source configuration ID or the path to a file
                         containing the configuration. Default: 1.
-T,--target              Target configuration ID (by default the best
                         configuration found by irace) or the path to a file
                         containing the configuration.
-P,--params              Specific parameter names to be used for the ablation
                         (separated with commas). By default use all
-t,--type                Type of ablation to perform: "full" will execute each
                         configuration on all "--n-instances" to determine the
                         best-performing one; "racing" will apply racing to
                         find the best configurations. Default: full.
-n,--nrep                Number of replications per instance used in "full"
                         ablation. Default: 1.
   --seed                Integer value to use as seed for the random number
                         generation. Default: 1234567.
-o,--output-file         Log file to save the ablation log. If "", the results
                         are not saved to a file. Default: log-ablation.Rdata.
   --instances-file      Instances file used for ablation: "train", "test" or a
                         filename containing the list of instances. Default:
                         train.
-p,--plot                Output filename (.pdf) for the plot. If not given, no
                         plot is created.
-O,--plot-type           Type of plot. Supported values are "mean", "boxplot",
                         "rank" or "rank,boxplot". Default: mean.
   --old-path            Old path found in the log-file (.Rdata) given as input
                         to be replaced by --new-path.
   --new-path            New path to replace the path found in the log-file
                         (.Rdata) given as input.
-e,--exec-dir            Directory where the target runner will be run.
-s,--scenario            Scenario file to override the scenario given in the
                         log-file (.Rdata)
   --parallel            Number of calls to targetRunner to execute in
                         parallel. Values 0 or 1 mean no parallelization.
</pre></div>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>allConfigurations</dt><dd><p>Configurations tested in the ablation.</p>
</dd>
<dt>state</dt><dd><p>State of the ablation process.</p>
</dd>
<dt>experiments</dt><dd><p>A matrix with the results of the experiments (columns are configurations, rows are instances).</p>
</dd>
<dt>scenario</dt><dd><p>Scenario object with the settings used for the experiments.</p>
</dd>
<dt>trajectory</dt><dd><p>IDs of the best configurations at each step of the ablation.</p>
</dd>
<dt>best</dt><dd><p>Best configuration found in the experiments.</p>
</dd>
<dt>complete</dt><dd><p><code>TRUE</code> if the ablation process was completed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotAblation">plotAblation()</a></code> <code><a href="#topic+ablation">ablation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ablation_cmdline("--help")
# Find the ablation command-line executable:
Sys.glob(file.path(system.file(package="irace", "bin"), "ablation*"))
</code></pre>

<hr>
<h2 id='buildCommandLine'>Generate a command-line representation of a configuration</h2><span id='topic+buildCommandLine'></span>

<h3>Description</h3>

<p><code>buildCommandLine</code> receives two vectors, one containing
the values of the parameters, the other containing the switches of the
parameters. It builds a string with the switches and the values that can
be used as a command line to call the program to be tuned, thus generating
one candidate configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCommandLine(values, switches)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildCommandLine_+3A_values">values</code></td>
<td>
<p>A vector containing the value of each parameter for the
candidate configuration.</p>
</td></tr>
<tr><td><code id="buildCommandLine_+3A_switches">switches</code></td>
<td>
<p>A vector containing the switches of each paramter (in an
order that corresponds to the values vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string concatenating each element of <code>switches</code> and
<code>values</code> for all parameters with a space between each pair of
parameters (but none between the switches and the corresponding values).
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>Examples</h3>

<pre><code class='language-R'>switches &lt;- c("--switch1 ", "--switch2-", "--switch3=")
values &lt;- list("value_1", 1L, sqrt(2))
buildCommandLine (values, switches)
## Build a command-line from the results produced by a previous run of irace.
# First, load the data produced by irace.
logfile &lt;- file.path(system.file(package="irace"), "exdata", "irace-acotsp.Rdata")
iraceResults &lt;- read_logfile(logfile)
allConfigurations &lt;- iraceResults$allConfigurations
parameters &lt;- iraceResults$scenario$parameters
apply(allConfigurations[1:10, unlist(parameters$names)], 1, buildCommandLine,
      unlist(parameters$switches))

</code></pre>

<hr>
<h2 id='check_output_target_runner'>Check the output of the target runner and repair it if possible. If the
output is incorrect, this function will throw an error.</h2><span id='topic+check_output_target_runner'></span>

<h3>Description</h3>

<p>Check the output of the target runner and repair it if possible. If the
output is incorrect, this function will throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_output_target_runner(output, scenario, bound = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_output_target_runner_+3A_output">output</code></td>
<td>
<p>The output from target runner.</p>
</td></tr>
<tr><td><code id="check_output_target_runner_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="check_output_target_runner_+3A_bound">bound</code></td>
<td>
<p>Optional time bound that the target runner should have respected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output with its contents repaired.
</p>

<hr>
<h2 id='checkIraceScenario'>Test that the given irace scenario can be run.</h2><span id='topic+checkIraceScenario'></span>

<h3>Description</h3>

<p>Test that the given irace scenario can be run by checking the scenario
settings provided and trying to run the target-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIraceScenario(scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkIraceScenario_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>parameters</code> argument is missing, then the parameters
will be read from the file <code>parameterFile</code>  given by <code>scenario</code>. If
<code>parameters</code> is provided, then <code>parameterFile</code> will not be read.  This function will
try to execute the target-algorithm.
</p>


<h3>Value</h3>

<p>returns <code>TRUE</code> if successful and gives an error and returns <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='checkParameters'>checkParameters</h2><span id='topic+checkParameters'></span>

<h3>Description</h3>

<p>FIXME: This is incomplete, for now we only repair inputs from previous irace
versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkParameters(parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkParameters_+3A_parameters">parameters</code></td>
<td>
<p><code>ParameterSpace</code><br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='checkScenario'>Check and correct the given scenario</h2><span id='topic+checkScenario'></span>

<h3>Description</h3>

<p>Checks for errors a (possibly incomplete) scenario setup of
<span class="pkg">irace</span>  and transforms it into a valid scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkScenario(scenario = defaultScenario())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkScenario_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks that the directories and the file names
provided and required by the <span class="pkg">irace</span> exist. It also checks that the
settings are of the proper type, e.g. that settings expected to be integers
are really integers. Finally, it also checks that there is no inconsistency
between settings.  If an error is found that prevents <span class="pkg">irace</span> from
running properly, it will stop with an error.
</p>


<h3>Value</h3>

<p>The scenario received as a parameter, possibly corrected. Unset
scenario settings are set to their default values.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='configurations_print'>Print configurations as a data frame</h2><span id='topic+configurations_print'></span>

<h3>Description</h3>

<p>Print configurations as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configurations_print(configurations, metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configurations_print_+3A_configurations">configurations</code></td>
<td>
<p><code>data.frame</code><br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="configurations_print_+3A_metadata">metadata</code></td>
<td>
<p><code>logical(1)</code><br /> whether to print the metadata or
not. The metadata are data for the configurations (additionally to the
value of each parameter) used by <span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations_print_command">configurations_print_command()</a></code> to print the configurations as command-line strings.
</p>

<hr>
<h2 id='configurations_print_command'>Print configurations as command-line strings.</h2><span id='topic+configurations_print_command'></span>

<h3>Description</h3>

<p>Prints configurations after converting them into a representation for the
command-line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configurations_print_command(configurations, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configurations_print_command_+3A_configurations">configurations</code></td>
<td>
<p><code>data.frame</code><br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="configurations_print_command_+3A_parameters">parameters</code></td>
<td>
<p><code>ParameterSpace</code><br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations_print">configurations_print()</a></code> to print the configurations as a data frame.
</p>

<hr>
<h2 id='defaultScenario'>Default scenario settings</h2><span id='topic+defaultScenario'></span>

<h3>Description</h3>

<p>Return scenario object with default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultScenario(scenario = list(), params_def = .irace.params.def)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defaultScenario_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="defaultScenario_+3A_params_def">params_def</code></td>
<td>
<p><code>data.frame()</code><br /> Definition of the options accepted by
the scenario. This should only be modified by packages that wish to extend
<span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list indexed by the <span class="pkg">irace</span> parameter names,
containing the default values for each parameter, except for those
already present in the scenario passed as argument.
The scenario list contains the following elements:
</p>

<ul>
<li><p> General options:
</p>

<dl>
<dt><code>scenarioFile</code></dt><dd><p>Path of the file that describes the configuration scenario setup and other irace settings. (Default: <code>"./scenario.txt"</code>)</p>
</dd>
<dt><code>execDir</code></dt><dd><p>Directory where the programs will be run. (Default: <code>"./"</code>)</p>
</dd>
<dt><code>logFile</code></dt><dd><p>File to save tuning results as an R dataset, either absolute path or relative to execDir. (Default: <code>"./irace.Rdata"</code>)</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Reduce the output generated by irace to a minimum. (Default: <code>0</code>)</p>
</dd>
<dt><code>debugLevel</code></dt><dd><p>Debug level of the output of <code>irace</code>. Set this to 0 to silence all debug messages. Higher values provide more verbose debug messages. (Default: <code>0</code>)</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed of the random number generator (by default, generate a random seed). (Default: <code>NA</code>)</p>
</dd>
<dt><code>repairConfiguration</code></dt><dd><p>User-defined R function that takes a configuration generated by irace and repairs it. (Default: <code>""</code>)</p>
</dd>
<dt><code>postselection</code></dt><dd><p>Perform a postselection race after the execution of irace to consume all remaining budget. Value 0 disables the postselection race. (Default: <code>1</code>)</p>
</dd>
<dt><code>aclib</code></dt><dd><p>Enable/disable AClib mode. This option enables compatibility with GenericWrapper4AC as targetRunner script. (Default: <code>0</code>)</p>
</dd>
</dl>

</li>
<li><p> Elitist <code>irace</code>:
</p>

<dl>
<dt><code>elitist</code></dt><dd><p>Enable/disable elitist irace. (Default: <code>1</code>)</p>
</dd>
<dt><code>elitistNewInstances</code></dt><dd><p>Number of instances added to the execution list before previous instances in elitist irace. (Default: <code>1</code>)</p>
</dd>
<dt><code>elitistLimit</code></dt><dd><p>In elitist irace, maximum number per race of elimination tests that do not eliminate a configuration. Use 0 for no limit. (Default: <code>2</code>)</p>
</dd>
</dl>

</li>
<li><p> Internal <code>irace</code> options:
</p>

<dl>
<dt><code>sampleInstances</code></dt><dd><p>Randomly sample the training instances or use them in the order given. (Default: <code>1</code>)</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>Enable/disable the soft restart strategy that avoids premature convergence of the probabilistic model. (Default: <code>1</code>)</p>
</dd>
<dt><code>softRestartThreshold</code></dt><dd><p>Soft restart threshold value for numerical parameters. (Default: <code>1e-04</code>)</p>
</dd>
<dt><code>nbIterations</code></dt><dd><p>Maximum number of iterations. (Default: <code>0</code>)</p>
</dd>
<dt><code>nbExperimentsPerIteration</code></dt><dd><p>Number of runs of the target algorithm per iteration. (Default: <code>0</code>)</p>
</dd>
<dt><code>minNbSurvival</code></dt><dd><p>Minimum number of configurations needed to continue the execution of each race (iteration). (Default: <code>0</code>)</p>
</dd>
<dt><code>nbConfigurations</code></dt><dd><p>Number of configurations to be sampled and evaluated at each iteration. (Default: <code>0</code>)</p>
</dd>
<dt><code>mu</code></dt><dd><p>Parameter used to define the number of configurations sampled and evaluated at each iteration. (Default: <code>5</code>)</p>
</dd>
</dl>

</li>
<li><p> Target algorithm parameters:
</p>

<dl>
<dt><code>parameterFile</code></dt><dd><p>File that contains the description of the parameters of the target algorithm. (Default: <code>"./parameters.txt"</code>)</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Parameters space object (usually read from a file using <code>readParameters</code>). (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Target algorithm execution:
</p>

<dl>
<dt><code>targetRunner</code></dt><dd><p>Executable called for each configuration that executes the target algorithm to be tuned. See the templates and examples provided. (Default: <code>"./target-runner"</code>)</p>
</dd>
<dt><code>targetRunnerLauncher</code></dt><dd><p>Executable that will be used to launch the target runner, when <code>targetRunner</code> cannot be executed directly (e.g., a Python script in Windows). (Default: <code>""</code>)</p>
</dd>
<dt><code>targetCmdline</code></dt><dd><p>Command-line arguments provided to <code>targetRunner</code> (or <code>targetRunnerLauncher</code> if defined). The substrings <code style="white-space: pre;">&#8288;\{configurationID\}&#8288;</code>, <code style="white-space: pre;">&#8288;\{instanceID\}&#8288;</code>,  <code style="white-space: pre;">&#8288;\{seed\}&#8288;</code>,  <code style="white-space: pre;">&#8288;\{instance\}&#8288;</code>, and <code style="white-space: pre;">&#8288;\{bound\}&#8288;</code> will be replaced by their corresponding values. The substring <code style="white-space: pre;">&#8288;\{targetRunnerArgs\}&#8288;</code> will be replaced by the concatenation of the switch and value of all active parameters of the particular configuration being evaluated.  The substring <code style="white-space: pre;">&#8288;\{targetRunner\}&#8288;</code>, if present, will be replaced by the value of <code>targetRunner</code> (useful when using <code>targetRunnerLauncher</code>). (Default: <code>"{configurationID} {instanceID} {seed} {instance} {bound} {targetRunnerArgs}"</code>)</p>
</dd>
<dt><code>targetRunnerRetries</code></dt><dd><p>Number of times to retry a call to <code>targetRunner</code> if the call failed. (Default: <code>0</code>)</p>
</dd>
<dt><code>targetRunnerTimeout</code></dt><dd><p>Timeout in seconds of any <code>targetRunner</code> call (only applies to <code>target-runner</code> executables not to R functions), ignored if 0. (Default: <code>0</code>)</p>
</dd>
<dt><code>targetRunnerData</code></dt><dd><p>Optional data passed to <code>targetRunner</code>. This is ignored by the default <code>targetRunner</code> function, but it may be used by custom <code>targetRunner</code> functions to pass persistent data around. (Default: <code>""</code>)</p>
</dd>
<dt><code>targetRunnerParallel</code></dt><dd><p>Optional R function to provide custom parallelization of <code>targetRunner</code>. (Default: <code>""</code>)</p>
</dd>
<dt><code>targetEvaluator</code></dt><dd><p>Optional script or R function that provides a numeric value for each configuration. See templates/target-evaluator.tmpl (Default: <code>""</code>)</p>
</dd>
<dt><code>deterministic</code></dt><dd><p>If the target algorithm is deterministic, configurations will be evaluated only once per instance. (Default: <code>0</code>)</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Number of calls to <code>targetRunner</code> to execute in parallel. Values <code>0</code> or <code>1</code> mean no parallelization. (Default: <code>0</code>)</p>
</dd>
<dt><code>loadBalancing</code></dt><dd><p>Enable/disable load-balancing when executing experiments in parallel. Load-balancing makes better use of computing resources, but increases communication overhead. If this overhead is large, disabling load-balancing may be faster. (Default: <code>1</code>)</p>
</dd>
<dt><code>mpi</code></dt><dd><p>Enable/disable MPI. Use <code>Rmpi</code> to execute <code>targetRunner</code> in parallel (parameter <code>parallel</code> is the number of slaves). (Default: <code>0</code>)</p>
</dd>
<dt><code>batchmode</code></dt><dd><p>Specify how irace waits for jobs to finish when <code>targetRunner</code> submits jobs to a batch cluster: sge, pbs, torque, slurm or htcondor. <code>targetRunner</code> must submit jobs to the cluster using, for example, <code>qsub</code>. (Default: <code>0</code>)</p>
</dd>
</dl>

</li>
<li><p> Initial configurations:
</p>

<dl>
<dt><code>initConfigurations</code></dt><dd><p>Data frame describing initial configurations (usually read from a file using <code>readConfigurations</code>). (Default: <code>""</code>)</p>
</dd>
<dt><code>configurationsFile</code></dt><dd><p>File that contains a table of initial configurations. If empty or <code>NULL</code>, all initial configurations are randomly generated. (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Training instances:
</p>

<dl>
<dt><code>instances</code></dt><dd><p>Character vector of the instances to be used in the <code>targetRunner</code>. (Default: <code>""</code>)</p>
</dd>
<dt><code>trainInstancesDir</code></dt><dd><p>Directory where training instances are located; either absolute path or relative to current directory. If no <code>trainInstancesFiles</code> is provided, all the files in <code>trainInstancesDir</code> will be listed as instances. (Default: <code>""</code>)</p>
</dd>
<dt><code>trainInstancesFile</code></dt><dd><p>File that contains a list of training instances and optionally additional parameters for them. If <code>trainInstancesDir</code> is provided, <code>irace</code> will search for the files in this folder. (Default: <code>""</code>)</p>
</dd>
<dt><code>blockSize</code></dt><dd><p>Number of training instances, that make up a 'block' in <code>trainInstancesFile</code>. Elimination of configurations will only be performed after evaluating a complete block and never in the middle of a block. Each block typically contains one instance from each instance class (type or family) and the block size is the number of classes. The value of <code>blockSize</code> will multiply <code>firstTest</code>, <code>eachTest</code> and <code>elitistNewInstances</code>. (Default: <code>1</code>)</p>
</dd>
</dl>

</li>
<li><p> Tuning budget:
</p>

<dl>
<dt><code>maxExperiments</code></dt><dd><p>Maximum number of runs (invocations of <code>targetRunner</code>) that will be performed. It determines the maximum budget of experiments for the tuning. (Default: <code>0</code>)</p>
</dd>
<dt><code>minExperiments</code></dt><dd><p>Minimum number of runs (invocations of <code>targetRunner</code>) that will be performed. It determines the minimum budget of experiments for the tuning. The actual budget depends on the number of parameters and <code>minSurvival</code>. (Default: <code>NA</code>)</p>
</dd>
<dt><code>maxTime</code></dt><dd><p>Maximum total execution time for the executions of <code>targetRunner</code>. <code>targetRunner</code> must return two values: cost and time. This value and the one returned by <code>targetRunner</code> must use the same units (seconds, minutes, iterations, evaluations, ...). (Default: <code>0</code>)</p>
</dd>
<dt><code>budgetEstimation</code></dt><dd><p>Fraction (smaller than 1) of the budget used to estimate the mean computation time of a configuration. Only used when <code>maxTime</code> &gt; 0 (Default: <code>0.05</code>)</p>
</dd>
<dt><code>minMeasurableTime</code></dt><dd><p>Minimum time unit that is still (significantly) measureable. (Default: <code>0.01</code>)</p>
</dd>
</dl>

</li>
<li><p> Statistical test:
</p>

<dl>
<dt><code>testType</code></dt><dd><p>Statistical test used for elimination. The default value selects <code>t-test</code> if <code>capping</code> is enabled or <code>F-test</code>, otherwise. Valid values are: F-test (Friedman test), t-test (pairwise t-tests with no correction), t-test-bonferroni (t-test with Bonferroni's correction for multiple comparisons), t-test-holm (t-test with Holm's correction for multiple comparisons). (Default: <code>""</code>)</p>
</dd>
<dt><code>firstTest</code></dt><dd><p>Number of instances evaluated before the first elimination test. It must be a multiple of <code>eachTest</code>. (Default: <code>5</code>)</p>
</dd>
<dt><code>eachTest</code></dt><dd><p>Number of instances evaluated between elimination tests. (Default: <code>1</code>)</p>
</dd>
<dt><code>confidence</code></dt><dd><p>Confidence level for the elimination test. (Default: <code>0.95</code>)</p>
</dd>
</dl>

</li>
<li><p> Adaptive capping:
</p>

<dl>
<dt><code>capping</code></dt><dd><p>Enable the use of adaptive capping, a technique designed for minimizing the computation time of configurations. Capping is enabled by default if <code>elitist</code> is active, <code>maxTime &gt; 0</code> and  <code>boundMax &gt; 0</code>. (Default: <code>NA</code>)</p>
</dd>
<dt><code>cappingAfterFirstTest</code></dt><dd><p>If set to 1, elimination due to capping only happens after <code>firstTest</code> instances are seen. (Default: <code>0</code>)</p>
</dd>
<dt><code>cappingType</code></dt><dd><p>Measure used to obtain the execution bound from the performance of the elite configurations.</p>
<ul>
<li><p> median: Median performance of the elite configurations.</p>
</li>
<li><p> mean: Mean performance of the elite configurations.</p>
</li>
<li><p> best: Best performance of the elite configurations.</p>
</li>
<li><p> worst: Worst performance of the elite configurations.</p>
</li></ul>
<p> (Default: <code>"median"</code>)</p>
</dd>
<dt><code>boundType</code></dt><dd><p>Method to calculate the mean performance of elite configurations.</p>
<ul>
<li><p> candidate: Mean execution times across the executed instances and the current one.</p>
</li>
<li><p> instance: Execution time of the current instance.</p>
</li></ul>
<p> (Default: <code>"candidate"</code>)</p>
</dd>
<dt><code>boundMax</code></dt><dd><p>Maximum execution bound for <code>targetRunner</code>. It must be specified when capping is enabled. (Default: <code>0</code>)</p>
</dd>
<dt><code>boundDigits</code></dt><dd><p>Precision used for calculating the execution time. It must be specified when capping is enabled. (Default: <code>0</code>)</p>
</dd>
<dt><code>boundPar</code></dt><dd><p>Penalization constant for timed out executions (executions that reach <code>boundMax</code> execution time). (Default: <code>1</code>)</p>
</dd>
<dt><code>boundAsTimeout</code></dt><dd><p>Replace the configuration cost of bounded executions with <code>boundMax</code>. (Default: <code>1</code>)</p>
</dd>
</dl>

</li>
<li><p> Recovery:
</p>

<dl>
<dt><code>recoveryFile</code></dt><dd><p>Previously saved log file to recover the execution of <code>irace</code>, either absolute path or relative to the current directory.  If empty or <code>NULL</code>, recovery is not performed. (Default: <code>""</code>)</p>
</dd>
</dl>

</li>
<li><p> Testing:
</p>

<dl>
<dt><code>testInstancesDir</code></dt><dd><p>Directory where testing instances are located, either absolute or relative to current directory. (Default: <code>""</code>)</p>
</dd>
<dt><code>testInstancesFile</code></dt><dd><p>File containing a list of test instances and optionally additional parameters for them. (Default: <code>""</code>)</p>
</dd>
<dt><code>testInstances</code></dt><dd><p>Character vector of the instances to be used in the <code>targetRunner</code> when executing the testing. (Default: <code>""</code>)</p>
</dd>
<dt><code>testNbElites</code></dt><dd><p>Number of elite configurations returned by irace that will be tested if test instances are provided. (Default: <code>1</code>)</p>
</dd>
<dt><code>testIterationElites</code></dt><dd><p>Enable/disable testing the elite configurations found at each iteration. (Default: <code>0</code>)</p>
</dd>
</dl>

</li></ul>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='get_instanceID_seed_pairs'>Returns the pairs of instance IDs and seeds used as instances in the race
(and optionally the actual instances).</h2><span id='topic+get_instanceID_seed_pairs'></span>

<h3>Description</h3>

<p>Returns the pairs of instance IDs and seeds used as instances in the race
(and optionally the actual instances).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_instanceID_seed_pairs(iraceResults, index, instances = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_instanceID_seed_pairs_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="get_instanceID_seed_pairs_+3A_index">index</code></td>
<td>
<p><code>integer()</code><br /> Indexes of the (instanceID,seed) pairs to be returned. The default returns everything.</p>
</td></tr>
<tr><td><code id="get_instanceID_seed_pairs_+3A_instances">instances</code></td>
<td>
<p><code>logical(1)</code><br /> Whether to add the actual instances as an additional column (only if the instances are of atomic type).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.table()</code><br /> With default arguments, a <code>data.table</code> containing two columns
<code>"instanceID"</code> and <code>"seed"</code>. With <code>instances=TRUE</code> and if the instances
are of atomic type (see <code><a href="base.html#topic+is.atomic">is.atomic()</a></code>) type, another column <code>instance</code> is
added that contains the actual instance.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_file &lt;- system.file("exdata/irace-acotsp.Rdata", package="irace", mustWork=TRUE)
head(get_instanceID_seed_pairs(log_file))
# Add the instance names
get_instanceID_seed_pairs(log_file, index=1:10, instances=TRUE)
</code></pre>

<hr>
<h2 id='getConfigurationById'>Returns the configurations selected by ID.</h2><span id='topic+getConfigurationById'></span>

<h3>Description</h3>

<p>Returns the configurations selected by ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfigurationById(iraceResults, ids, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConfigurationById_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getConfigurationById_+3A_ids">ids</code></td>
<td>
<p><code>integer()</code><br /> The id or a vector of ids of the candidates configurations to obtain.</p>
</td></tr>
<tr><td><code id="getConfigurationById_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p><code>logical(1)</code><br /> Remove metadata, such as the
configuration ID and the ID of the parent, from the returned
configurations.  See <code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required, in the
order and with the repetitions given by <code>ids</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_file &lt;- system.file("exdata/irace-acotsp.Rdata", package="irace", mustWork=TRUE)
getConfigurationById(log_file, ids = c(2,1), drop.metadata = TRUE)

</code></pre>

<hr>
<h2 id='getConfigurationByIteration'>Returns the configurations by the iteration in which they were executed.</h2><span id='topic+getConfigurationByIteration'></span>

<h3>Description</h3>

<p>Returns the configurations by the iteration in which they were executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfigurationByIteration(iraceResults, iterations, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConfigurationByIteration_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getConfigurationByIteration_+3A_iterations">iterations</code></td>
<td>
<p><code>integer()</code><br /> The iteration number or a vector of iteration numbers from where
the configurations should be obtained. Negative values start counting from the last iteration.</p>
</td></tr>
<tr><td><code id="getConfigurationByIteration_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p><code>logical(1)</code><br /> Remove metadata, such as the
configuration ID and the ID of the parent, from the returned
configurations.  See <code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_file &lt;- system.file("exdata/irace-acotsp.Rdata", package="irace", mustWork=TRUE)
getConfigurationByIteration(log_file, iterations = c(-2, -1), drop.metadata = TRUE)

</code></pre>

<hr>
<h2 id='getFinalElites'>Return the elite configurations of the final iteration.</h2><span id='topic+getFinalElites'></span>

<h3>Description</h3>

<p>Return the elite configurations of the final iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFinalElites(iraceResults, n = 0L, drop.metadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFinalElites_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="getFinalElites_+3A_n">n</code></td>
<td>
<p><code>integer(1)</code><br /> Number of elite configurations to return, if <code>n</code> is larger than the
number of configurations, then only the existing ones are returned. The default (<code>n=0</code>) returns all of them.</p>
</td></tr>
<tr><td><code id="getFinalElites_+3A_drop.metadata">drop.metadata</code></td>
<td>
<p><code>logical(1)</code><br /> Remove metadata, such as the
configuration ID and the ID of the parent, from the returned
configurations.  See <code><a href="#topic+removeConfigurationsMetaData">removeConfigurationsMetaData()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the elite configurations required.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_file &lt;- system.file("exdata/irace-acotsp.Rdata", package="irace", mustWork=TRUE)
print(removeConfigurationsMetaData(getFinalElites(log_file, n=1)))

</code></pre>

<hr>
<h2 id='has_testing_data'>Check if the results object generated by irace has data about the testing phase.</h2><span id='topic+has_testing_data'></span>

<h3>Description</h3>

<p>Check if the results object generated by irace has data about the testing phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_testing_data(iraceResults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_testing_data_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irace_results &lt;- read_logfile(system.file("exdata/irace-acotsp.Rdata", package="irace",
                                          mustWork=TRUE))
print(has_testing_data(irace_results))
</code></pre>

<hr>
<h2 id='irace'>Execute one run of the Iterated Racing algorithm.</h2><span id='topic+irace'></span>

<h3>Description</h3>

<p>The function <code>irace</code> implements the Iterated Racing procedure for parameter
tuning. It receives a configuration scenario and a parameter space to be
tuned, and returns the best configurations found, namely, the elite
configurations obtained from the last iterations. As a first step, it checks
the correctness of <code>scenario</code> using <code><a href="#topic+checkScenario">checkScenario()</a></code> and recovers a
previous execution if <code>scenario$recoveryFile</code> is set. A R data file log of
the execution is created in <code>scenario$logFile</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace(scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irace_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The execution of this function is reproducible under some conditions. See
the FAQ section in the <a href="https://cran.r-project.org/package=irace/vignettes/irace-package.pdf">User Guide</a>.
</p>


<h3>Value</h3>

<p>(<code>data.frame</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information. The element <code>scenario$parameters</code> contains the parameters R object that describes the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimen_log</code></dt><dd><p>A <code>data.table</code> with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>race_state$instances_log</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>An environment that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+irace_main">irace_main()</a></code></dt><dd><p>a higher-level interface to <code><a href="#topic+irace">irace()</a></code>.</p>
</dd>
<dt><code><a href="#topic+irace_cmdline">irace_cmdline()</a></code></dt><dd><p>a command-line interface to <code><a href="#topic+irace">irace()</a></code>.</p>
</dd>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+readParameters">readParameters()</a></code></dt><dd><p>read the target algorithm parameters from a file.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In general, there are three steps:
scenario &lt;- readScenario(filename = "scenario.txt")
irace(scenario = scenario)

## End(Not run)
#######################################################################
# This example illustrates how to tune the parameters of the simulated
# annealing algorithm (SANN) provided by the optim() function in the
# R base package.  The goal in this example is to optimize instances of
# the following family:
#      f(x) = lambda * f_rastrigin(x) + (1 - lambda) * f_rosenbrock(x)
# where lambda follows a normal distribution whose mean is 0.9 and
# standard deviation is 0.02. f_rastrigin and f_rosenbrock are the
# well-known Rastrigin and Rosenbrock benchmark functions (taken from
# the cmaes package). In this scenario, different instances are given
# by different values of lambda.
#######################################################################
## First we provide an implementation of the functions to be optimized:
f_rosenbrock &lt;- function (x) {
  d &lt;- length(x)
  z &lt;- x + 1
  hz &lt;- z[1L:(d - 1L)]
  tz &lt;- z[2L:d]
  sum(100 * (hz^2 - tz)^2 + (hz - 1)^2)
}
f_rastrigin &lt;- function (x) {
  sum(x * x - 10 * cos(2 * pi * x) + 10)
}

## We generate 20 instances (in this case, weights):
weights &lt;- rnorm(20, mean = 0.9, sd = 0.02)

## On this set of instances, we are interested in optimizing two
## parameters of the SANN algorithm: tmax and temp. We setup the
## parameter space as follows:
parameters_table &lt;- '
  tmax "" i,log (1, 5000)
  temp "" r (0, 100)
  '
## We use the irace function readParameters to read this table:
parameters &lt;- readParameters(text = parameters_table)

## Next, we define the function that will evaluate each candidate
## configuration on a single instance. For simplicity, we restrict to
## three-dimensional functions and we set the maximum number of
## iterations of SANN to 1000.
target_runner &lt;- function(experiment, scenario)
{
    instance &lt;- experiment$instance
    configuration &lt;- experiment$configuration

    D &lt;- 3
    par &lt;- runif(D, min=-1, max=1)
    fn &lt;- function(x) {
      weight &lt;- instance
      return(weight * f_rastrigin(x) + (1 - weight) * f_rosenbrock(x))
    }
    # For reproducible results, we should use the random seed given by
    # experiment$seed to set the random seed of the target algorithm.
    res &lt;- withr::with_seed(experiment$seed,
                     stats::optim(par,fn, method="SANN",
                                  control=list(maxit=1000
                                             , tmax = as.numeric(configuration[["tmax"]])
                                             , temp = as.numeric(configuration[["temp"]])
                                               )))
    ## This list may also contain:
    ## - 'time' if irace is called with 'maxTime'
    ## - 'error' is a string used to report an error
    ## - 'outputRaw' is a string used to report the raw output of calls to
    ##   an external program or function.
    ## - 'call' is a string used to report how target_runner called the
    ##   external program or function.
    return(list(cost = res$value))
}

## We define a configuration scenario by setting targetRunner to the
## function define above, instances to the first 10 random weights, and
## a maximum budget of 'maxExperiments' calls to targetRunner.
scenario &lt;- list(targetRunner = target_runner,
                 instances = weights[1:10],
                 maxExperiments = 500,
                 # Do not create a logFile
                 logFile = "",
                 parameters = parameters)

## We check that the scenario is valid. This will also try to execute
## target_runner.
checkIraceScenario(scenario)


## We are now ready to launch irace. We do it by means of the irace
## function. The function will print information about its
## progress. This may require a few minutes, so it is not run by default.
tuned_confs &lt;- irace(scenario = scenario)

## We can print the best configurations found by irace as follows:
configurations_print(tuned_confs)

## We can evaluate the quality of the best configuration found by
## irace versus the default configuration of the SANN algorithm on
## the other 10 instances previously generated.
test_index &lt;- 11:20
test_seeds &lt;- sample.int(2147483647L, size = length(test_index), replace = TRUE)
test &lt;- function(configuration)
{
  res &lt;- lapply(seq_along(test_index),
                function(x) target_runner(
                              experiment = list(instance = weights[test_index[x]],
                                                seed = test_seeds[x],
                                                configuration = configuration),
                              scenario = scenario))
  return (sapply(res, getElement, name = "cost"))
}
## To do so, first we apply the default configuration of the SANN
## algorithm to these instances:
default &lt;- test(data.frame(tmax=10, temp=10))

## We extract and apply the winning configuration found by irace
## to these instances:
tuned &lt;- test(removeConfigurationsMetaData(tuned_confs[1,]))

## Finally, we can compare using a boxplot the quality obtained with the
## default parametrization of SANN and the quality obtained with the
## best configuration found by irace.
boxplot(list(default = default, tuned = tuned))

</code></pre>

<hr>
<h2 id='irace_cmdline'>Launch <code>irace</code> with command-line options.</h2><span id='topic+irace_cmdline'></span><span id='topic+irace.cmdline'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+irace_main">irace_main()</a></code> using command-line options, maybe parsed from the
command line used to invoke R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace_cmdline(argv = commandArgs(trailingOnly = TRUE))

irace.cmdline(argv = commandArgs(trailingOnly = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irace_cmdline_+3A_argv">argv</code></td>
<td>
<p><code>character()</code><br /> The arguments
provided on the R command line as a character vector, e.g.,
<code>c("--scenario", "scenario.txt", "-p", "parameters.txt")</code>.
Using the  default value (not providing the parameter) is the
easiest way to call <code><a href="#topic+irace_cmdline">irace_cmdline()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads the parameters given on the command line
used to invoke R, finds the name of the scenario file,
initializes the scenario from the file (with the function
<code><a href="#topic+readScenario">readScenario()</a></code>) and possibly from parameters passed in
the command line. It finally starts <span class="pkg">irace</span> by calling
<code><a href="#topic+irace_main">irace_main()</a></code>.
</p>
<p>List of command-line options:
</p>
<div class="sourceCode"><pre>-h,--help                Show this help.
-v,--version             Show irace package version.
-c,--check               Check scenario.
-i,--init                Initialize the working directory with template config
                         files.
   --only-test           Only test the configurations given in the file passed
                         as argument.
-s,--scenario            File that describes the configuration scenario setup
                         and other irace settings. Default: ./scenario.txt.
   --exec-dir            Directory where the programs will be run. Default: ./.
-p,--parameter-file      File that contains the description of the parameters
                         of the target algorithm. Default: ./parameters.txt.
   --configurations-file  File that contains a table of initial configurations.
                         If empty or `NULL`, all initial configurations are
                         randomly generated.
-l,--log-file            File to save tuning results as an R dataset, either
                         absolute path or relative to execDir. Default:
                         ./irace.Rdata.
   --recovery-file       Previously saved log file to recover the execution of
                         `irace`, either absolute path or relative to the
                         current directory.  If empty or `NULL`, recovery is
                         not performed.
   --train-instances-dir  Directory where training instances are located;
                         either absolute path or relative to current directory.
                         If no `trainInstancesFiles` is provided, all the files
                         in `trainInstancesDir` will be listed as instances.
   --train-instances-file  File that contains a list of training instances and
                         optionally additional parameters for them. If
                         `trainInstancesDir` is provided, `irace` will search
                         for the files in this folder.
   --sample-instances    Randomly sample the training instances or use them in
                         the order given. Default: 1.
   --test-instances-dir  Directory where testing instances are located, either
                         absolute or relative to current directory.
   --test-instances-file  File containing a list of test instances and
                         optionally additional parameters for them.
   --test-num-elites     Number of elite configurations returned by irace that
                         will be tested if test instances are provided.
                         Default: 1.
   --test-iteration-elites  Enable/disable testing the elite configurations
                         found at each iteration. Default: 0.
   --test-type           Statistical test used for elimination. The default
                         value selects `t-test` if `capping` is enabled or
                         `F-test`, otherwise. Valid values are: F-test
                         (Friedman test), t-test (pairwise t-tests with no
                         correction), t-test-bonferroni (t-test with
                         Bonferroni's correction for multiple comparisons),
                         t-test-holm (t-test with Holm's correction for
                         multiple comparisons).
   --first-test          Number of instances evaluated before the first
                         elimination test. It must be a multiple of `eachTest`.
                         Default: 5.
   --block-size          Number of training instances, that make up a 'block'
                         in `trainInstancesFile`. Elimination of configurations
                         will only be performed after evaluating a complete
                         block and never in the middle of a block. Each block
                         typically contains one instance from each instance
                         class (type or family) and the block size is the
                         number of classes. The value of `blockSize` will
                         multiply `firstTest`, `eachTest` and
                         `elitistNewInstances`. Default: 1.
   --each-test           Number of instances evaluated between elimination
                         tests. Default: 1.
   --target-runner       Executable called for each configuration that executes
                         the target algorithm to be tuned. See the templates
                         and examples provided. Default: ./target-runner.
   --target-runner-launcher  Executable that will be used to launch the target
                         runner, when `targetRunner` cannot be executed
                         directly (e.g., a Python script in Windows).
   --target-cmdline      Command-line arguments provided to `targetRunner` (or
                         `targetRunnerLauncher` if defined). The substrings
                         `\{configurationID\}`, `\{instanceID\}`, `\{seed\}`,
                         `\{instance\}`, and `\{bound\}` will be replaced by
                         their corresponding values. The substring
                         `\{targetRunnerArgs\}` will be replaced by the
                         concatenation of the switch and value of all active
                         parameters of the particular configuration being
                         evaluated.  The substring `\{targetRunner\}`, if
                         present, will be replaced by the value of
                         `targetRunner` (useful when using
                         `targetRunnerLauncher`). Default: {configurationID}
                         {instanceID} {seed} {instance} {bound}
                         {targetRunnerArgs}.
   --target-runner-retries  Number of times to retry a call to `targetRunner`
                         if the call failed. Default: 0.
   --target-runner-timeout  Timeout in seconds of any `targetRunner` call (only
                         applies to `target-runner` executables not to R
                         functions), ignored if 0. Default: 0.
   --target-evaluator    Optional script or R function that provides a numeric
                         value for each configuration. See
                         templates/target-evaluator.tmpl
   --deterministic       If the target algorithm is deterministic,
                         configurations will be evaluated only once per
                         instance. Default: 0.
   --max-experiments     Maximum number of runs (invocations of `targetRunner`)
                         that will be performed. It determines the maximum
                         budget of experiments for the tuning. Default: 0.
   --min-experiments     Minimum number of runs (invocations of `targetRunner`)
                         that will be performed. It determines the minimum
                         budget of experiments for the tuning. The actual
                         budget depends on the number of parameters and
                         `minSurvival`.
   --max-time            Maximum total execution time for the executions of
                         `targetRunner`. `targetRunner` must return two values:
                         cost and time. This value and the one returned by
                         `targetRunner` must use the same units (seconds,
                         minutes, iterations, evaluations, ...). Default: 0.
   --budget-estimation   Fraction (smaller than 1) of the budget used to
                         estimate the mean computation time of a configuration.
                         Only used when `maxTime` &gt; 0 Default: 0.05.
   --min-measurable-time  Minimum time unit that is still (significantly)
                         measureable. Default: 0.01.
   --parallel            Number of calls to `targetRunner` to execute in
                         parallel. Values `0` or `1` mean no parallelization.
                         Default: 0.
   --load-balancing      Enable/disable load-balancing when executing
                         experiments in parallel. Load-balancing makes better
                         use of computing resources, but increases
                         communication overhead. If this overhead is large,
                         disabling load-balancing may be faster. Default: 1.
   --mpi                 Enable/disable MPI. Use `Rmpi` to execute
                         `targetRunner` in parallel (parameter `parallel` is
                         the number of slaves). Default: 0.
   --batchmode           Specify how irace waits for jobs to finish when
                         `targetRunner` submits jobs to a batch cluster: sge,
                         pbs, torque, slurm or htcondor. `targetRunner` must
                         submit jobs to the cluster using, for example, `qsub`.
                         Default: 0.
-q,--quiet               Reduce the output generated by irace to a minimum.
                         Default: 0.
   --debug-level         Debug level of the output of `irace`. Set this to 0 to
                         silence all debug messages. Higher values provide more
                         verbose debug messages. Default: 0.
   --seed                Seed of the random number generator (by default,
                         generate a random seed).
   --soft-restart        Enable/disable the soft restart strategy that avoids
                         premature convergence of the probabilistic model.
                         Default: 1.
   --soft-restart-threshold  Soft restart threshold value for numerical
                         parameters. Default: 1e-04.
-e,--elitist             Enable/disable elitist irace. Default: 1.
   --elitist-new-instances  Number of instances added to the execution list
                         before previous instances in elitist irace. Default:
                         1.
   --elitist-limit       In elitist irace, maximum number per race of
                         elimination tests that do not eliminate a
                         configuration. Use 0 for no limit. Default: 2.
   --capping             Enable the use of adaptive capping, a technique
                         designed for minimizing the computation time of
                         configurations. Capping is enabled by default if
                         `elitist` is active, `maxTime &gt; 0` and `boundMax &gt; 0`.
   --capping-after-first-test  If set to 1, elimination due to capping only
                         happens after `firstTest` instances are seen. Default:
                         0.
   --capping-type        Measure used to obtain the execution bound from the
                         performance of the elite configurations: median, mean,
                         worst, best. Default: median.
   --bound-type          Method to calculate the mean performance of elite
                         configurations: candidate or instance. Default:
                         candidate.
   --bound-max           Maximum execution bound for `targetRunner`. It must be
                         specified when capping is enabled. Default: 0.
   --bound-digits        Precision used for calculating the execution time. It
                         must be specified when capping is enabled. Default: 0.
   --bound-par           Penalization constant for timed out executions
                         (executions that reach `boundMax` execution time).
                         Default: 1.
   --bound-as-timeout    Replace the configuration cost of bounded executions
                         with `boundMax`. Default: 1.
   --postselection       Perform a postselection race after the execution of
                         irace to consume all remaining budget. Value 0
                         disables the postselection race. Default: 1.
   --aclib               Enable/disable AClib mode. This option enables
                         compatibility with GenericWrapper4AC as targetRunner
                         script. Default: 0.
   --iterations          Maximum number of iterations. Default: 0.
   --experiments-per-iteration  Number of runs of the target algorithm per
                         iteration. Default: 0.
   --min-survival        Minimum number of configurations needed to continue
                         the execution of each race (iteration). Default: 0.
   --num-configurations  Number of configurations to be sampled and evaluated
                         at each iteration. Default: 0.
   --mu                  Parameter used to define the number of configurations
                         sampled and evaluated at each iteration. Default: 5.
   --confidence          Confidence level for the elimination test. Default:
                         0.95.
</pre></div>


<h3>Value</h3>

<p>(<code>invisible(data.frame)</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information. The element <code>scenario$parameters</code> contains the parameters R object that describes the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimen_log</code></dt><dd><p>A <code>data.table</code> with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>race_state$instances_log</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>An environment that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irace_main">irace_main()</a></code> to start <span class="pkg">irace</span> with a given scenario.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irace_cmdline("--version")
</code></pre>

<hr>
<h2 id='irace_license'>irace_license</h2><span id='topic+irace_license'></span>

<h3>Description</h3>

<p>A character string containing the license information of <span class="pkg">irace</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace_license
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='irace_main'>Higher-level interface to launch irace.</h2><span id='topic+irace_main'></span>

<h3>Description</h3>

<p>Higher-level interface to launch irace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace_main(scenario, output.width = 9999L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irace_main_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="irace_main_+3A_output.width">output.width</code></td>
<td>
<p><code>integer(1)</code><br /> The width used for the screen
output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the correctness of the scenario, reads the
parameter space from <code>scenario$parameterFile</code>, invokes <code><a href="#topic+irace">irace()</a></code>,
prints its results in various formatted ways, (optionally) calls
<code><a href="#topic+psRace">psRace()</a></code> and, finally, evaluates the best configurations on the test
instances (if provided). If you want a lower-level interface that just
runs irace, please see function <code><a href="#topic+irace">irace()</a></code>.
</p>


<h3>Value</h3>

<p>(<code>invisible(data.frame)</code>)
</p>
<p>A data frame with the set of best algorithm configurations found by <span class="pkg">irace</span>.
The data frame has the following columns:
</p>

<ul>
<li> <p><code>.ID.</code> : Internal id of the candidate configuration.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Parameter names&#8288;</code> : One column per parameter name in <code>parameters</code>.
</p>
</li>
<li> <p><code>.PARENT.</code> : Internal id of the parent candidate configuration.
</p>
</li></ul>

<p>Additionally, this function saves an R data file containing an object called
<code>iraceResults</code>. The path of the file is indicated in <code>scenario$logFile</code>.
The <code>iraceResults</code> object is a list with the following structure:
</p>

<dl>
<dt><code>scenario</code></dt><dd><p>The scenario R object containing the <span class="pkg">irace</span>
options used for the execution. See <code><a href="#topic+defaultScenario">defaultScenario</a></code>
for more information. The element <code>scenario$parameters</code> contains the parameters R object that describes the target algorithm parameters. See
<code><a href="#topic+readParameters">readParameters</a></code>.</p>
</dd>
<dt><code>allConfigurations</code></dt><dd><p>The target algorithm configurations
generated by <span class="pkg">irace</span>. This object is a data frame, each row is a
candidate configuration, the first column (<code>.ID.</code>) indicates the
internal identifier of the configuration, the following columns
correspond to the parameter values, each column named as the parameter
name specified in the parameter object. The final column
(<code>.PARENT.</code>)  is the identifier of the configuration from which
model the actual configuration was sampled.</p>
</dd>
<dt><code>allElites</code></dt><dd><p>A list that contains one element per iteration,
each element contains the internal identifier of the elite candidate
configurations of the corresponding iteration (identifiers correspond to
<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>iterationElites</code></dt><dd><p>A vector containing the best candidate
configuration internal identifier of each iteration. The best
configuration found corresponds to the last one of this vector.</p>
</dd>
<dt><code>experiments</code></dt><dd><p>A matrix with configurations as columns and
instances as rows. Column names correspond to the internal identifier of
the configuration (<code>allConfigurations$.ID.</code>).</p>
</dd>
<dt><code>experimen_log</code></dt><dd><p>A <code>data.table</code> with columns <code>iteration</code>,
<code>instance</code>, <code>configuration</code>, <code>time</code>.  This matrix contains the log of all the
experiments that <span class="pkg">irace</span> performs during its execution.  The
instance column refers to the index of the <code>race_state$instances_log</code>
data frame. Time is saved ONLY when reported by the <code>targetRunner</code>.</p>
</dd>
<dt><code>softRestart</code></dt><dd><p>A logical vector that indicates if a soft
restart was performed on each iteration. If <code>FALSE</code>, then no soft
restart was performed.</p>
</dd>
<dt><code>state</code></dt><dd><p>An environment that contains the state of <span class="pkg">irace</span>, the
recovery is done using the information contained in this object.</p>
</dd>
<dt><code>testing</code></dt><dd><p>A list that contains the testing results. The
elements of this list are: <code>experiments</code> a matrix with the testing
experiments of the selected configurations in the same format as the
explained above and <code>seeds</code> a vector with the seeds used to execute
each experiment.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+irace_cmdline">irace_cmdline()</a></code></dt><dd><p>a command-line interface to <code><a href="#topic+irace">irace()</a></code>.</p>
</dd>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+readParameters">readParameters()</a></code></dt><dd><p>read the target algorithm parameters from a file.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
</dl>


<hr>
<h2 id='irace_summarise'>Summarise the results of a run of irace</h2><span id='topic+irace_summarise'></span>

<h3>Description</h3>

<p>Summarise the results of a run of irace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace_summarise(iraceResults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irace_summarise_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code>
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irace_results &lt;- read_logfile(system.file("exdata/irace-acotsp.Rdata",
                                          package="irace", mustWork=TRUE))
irace_summarise(irace_results)

</code></pre>

<hr>
<h2 id='irace_version'>A character string containing the version of <code>irace</code> including git SHA.</h2><span id='topic+irace_version'></span>

<h3>Description</h3>

<p>A character string containing the version of <code>irace</code> including git SHA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irace_version
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='multi_irace'>Execute <code><a href="#topic+irace">irace()</a></code> multiple times with the same or different scenarios and parameter space definitions.</h2><span id='topic+multi_irace'></span>

<h3>Description</h3>

<p>There are three modes of operation:
</p>

<ul>
<li><p> One <code>scenarios</code> and <code>k</code> <code>parameters</code>: <code>k</code> runs with the same scenario and each parameter space definition.
</p>
</li>
<li><p> One <code>parameters</code> and <code>k</code> <code>scenarios</code>: <code>k</code> runs with the same parameter space definition and each scenario.
</p>
</li>
<li> <p><code>k</code> <code>parameters</code> and <code>k</code> scenarios: <code>k</code> runs with each scenario and parameter space definition.
</p>
</li></ul>

<p>Each of the <code>k</code> runs can be repeated <code>n</code> times by supplying a value for <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_irace(
  scenarios,
  parameters,
  n = 1L,
  parallel = 1L,
  split_output = parallel &gt; 1L,
  global_seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_irace_+3A_scenarios">scenarios</code></td>
<td>
<p><code>list()</code><br /> A list of scenarios.
If only a single scenario is supplied, it is used for all parameters.</p>
</td></tr>
<tr><td><code id="multi_irace_+3A_parameters">parameters</code></td>
<td>
<p><code>list()</code><br /> A list of parameter space definitions.
If only a single definition is supplied, it is used for all scenarios.</p>
</td></tr>
<tr><td><code id="multi_irace_+3A_n">n</code></td>
<td>
<p><code>integer(1)</code><br /> The number of repetitions.</p>
</td></tr>
<tr><td><code id="multi_irace_+3A_parallel">parallel</code></td>
<td>
<p><code>integer(1)</code><br /> The number of workers to use.
A value of <code>1</code> means sequential execution. Note that <code>parallel &gt; 1</code> is not supported on Windows.</p>
</td></tr>
<tr><td><code id="multi_irace_+3A_split_output">split_output</code></td>
<td>
<p><code>logical(1)</code><br /> If <code>TRUE</code>, the output of <code><a href="#topic+irace">irace()</a></code> is written to <code style="white-space: pre;">&#8288;{execDir}/run_{i}/irace.out&#8288;</code>
instead of the standard output.</p>
</td></tr>
<tr><td><code id="multi_irace_+3A_global_seed">global_seed</code></td>
<td>
<p><code>integer(1)</code><br /> The global seed used to seed the individual runs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the outputs of <code><a href="#topic+irace">irace()</a></code>.
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+irace">irace()</a></code></dt><dd><p>the main interface for single irace runs.</p>
</dd>
</dl>


<hr>
<h2 id='parameters'>Create a parameter space to be tuned.</h2><span id='topic+parameters'></span><span id='topic+parametersNew'></span><span id='topic+param_cat'></span><span id='topic+param_ord'></span><span id='topic+param_real'></span><span id='topic+param_int'></span>

<h3>Description</h3>


<ul>
<li> <p><code>param_cat()</code> creates a categorical parameter.
</p>
</li>
<li> <p><code>param_ord()</code> creates an ordinal parameter.
</p>
</li>
<li> <p><code>param_real()</code> creates a real-valued parameter.
</p>
</li>
<li> <p><code>param_int()</code> creates an integer parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>parametersNew(..., forbidden = NULL, debugLevel = 0L)

param_cat(name = name, values, label = "", condition = TRUE)

param_ord(name, values, label = "", condition = TRUE)

param_real(
  name,
  lower,
  upper,
  label = "",
  condition = TRUE,
  transf = "",
  digits = 15L
)

param_int(name, lower, upper, label = "", condition = TRUE, transf = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>
<p>one or more parameters created by <code>param_int()</code>, <code>param_real()</code>, <code>param_ord()</code>, or <code>param_cat()</code>.</p>
</td></tr>
<tr><td><code id="parameters_+3A_forbidden">forbidden</code></td>
<td>
<p><code>expression()|character(1)</code><br /> String or list of expressions that define forbidden parameter configurations.</p>
</td></tr>
<tr><td><code id="parameters_+3A_debuglevel">debugLevel</code></td>
<td>
<p><code>integer(1)</code><br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="parameters_+3A_name">name</code></td>
<td>
<p><code>character(1)</code><br /> Parameter name (must be alphanumeric).</p>
</td></tr>
<tr><td><code id="parameters_+3A_values">values</code></td>
<td>
<p><code>character()</code><br /> Domain as a vector of strings.</p>
</td></tr>
<tr><td><code id="parameters_+3A_label">label</code></td>
<td>
<p><code>character(1)</code><br /> Label associated to the parameter. Often used to encode a command-line switch that activates the parameter.</p>
</td></tr>
<tr><td><code id="parameters_+3A_condition">condition</code></td>
<td>
<p><code>expression(1)|character(1)</code><br /> Expression that defines when the parameter is active according to the value of other parameters.</p>
</td></tr>
<tr><td><code id="parameters_+3A_lower">lower</code>, <code id="parameters_+3A_upper">upper</code></td>
<td>
<p>Lower and upper limits of the valid domain.</p>
</td></tr>
<tr><td><code id="parameters_+3A_transf">transf</code></td>
<td>
<p><code>character(1)</code><br /> If <code>"log"</code>, then the parameter is sampled in a logarithmic scale.</p>
</td></tr>
<tr><td><code id="parameters_+3A_digits">digits</code></td>
<td>
<p><code>integer(1)</code><br /> The number of decimal places to be considered for real-valued parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ParameterSpace</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>digits &lt;- 4L
parametersNew(
   param_cat(name = "algorithm", values = c("as", "mmas", "eas", "ras", "acs"), label = "--"),
   param_ord(name = "localsearch", values = c("0", "1", "2", "3"), label = "--localsearch "),
   param_real(name = "alpha", lower = 0.0, upper=5.0, label = "--alpha ", digits = digits),
   param_real(name = "beta", lower = 0.0, upper = 10.0, label = "--beta ", digits = digits),
   param_real(name = "rho", lower = 0.01, upper = 1.00, label = "--rho ", digits = digits),
   param_int(name = "ants", lower = 5, upper = 100, transf = "log", label = "--ants "),
   param_real(name = "q0", label = "--q0 ", lower=0.0, upper=1.0,
              condition = expression(algorithm == "acs")),
   param_int(name = "rasrank", label = "--rasranks ", lower=1, upper=quote(min(ants, 10)),
             condition = 'algorithm == "ras"'),
   param_int(name = "elitistants", label = "--elitistants ", lower=1, upper=expression(ants),
             condition = 'algorithm == "eas"'),
   param_int(name = "nnls", label = "--nnls ", lower = 5, upper = 50,
             condition = expression(localsearch %in% c(1,2,3))),
   param_cat(name = "dlb",  label = "--dlb ", values = c(0,1),
             condition = "localsearch %in% c(1,2,3)"),
   forbidden = "(alpha == 0) &amp; (beta == 0)")

</code></pre>

<hr>
<h2 id='path_rel2abs'>Converts a relative path to an absolute path.</h2><span id='topic+path_rel2abs'></span>

<h3>Description</h3>

<p>If the path passed corresponds to an executable, it tries to find its path
using <code><a href="base.html#topic+Sys.which">Sys.which()</a></code>.  Expansion of <code>'~'</code> in Windows follows the definition
of <code><a href="fs.html#topic+path_expand">fs::path_expand()</a></code> rather than <code><a href="base.html#topic+path.expand">base::path.expand()</a></code>. This function
tries really hard to create canonical paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_rel2abs(path, cwd = getwd())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path_rel2abs_+3A_path">path</code></td>
<td>
<p>(<code>character(1)</code>) Character string representing a relative path.</p>
</td></tr>
<tr><td><code id="path_rel2abs_+3A_cwd">cwd</code></td>
<td>
<p>(<code>character(1)</code>) Current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>character(1)</code>) Character string representing the absolute path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_rel2abs("..")
</code></pre>

<hr>
<h2 id='plotAblation'>Create plot from an ablation log</h2><span id='topic+plotAblation'></span>

<h3>Description</h3>

<p>Create plot from an ablation log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAblation(
  ablog,
  pdf_file = NULL,
  width = 20,
  height = 7,
  type = c("mean", "boxplot", "rank"),
  n = 0L,
  mar = NULL,
  ylab = "Mean configuration cost",
  ylim = NULL,
  rename_labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAblation_+3A_ablog">ablog</code></td>
<td>
<p>(<code>list()</code>|<code>character(1)</code>) Ablation log object returned by <code><a href="#topic+ablation">ablation()</a></code>. Alternatively, the path to an <code>.Rdata</code> file, e.g., <code>"log-ablation.Rdata"</code>, from which the object will be loaded.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_pdf_file">pdf_file</code></td>
<td>
<p>Output filename.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_width">width</code></td>
<td>
<p>Width provided to create the PDF file.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_height">height</code></td>
<td>
<p>Height provided to create the PDF file.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_type">type</code></td>
<td>
<p>Type of plot. Supported values are <code>"mean"</code> and <code>"boxplot"</code>. Adding <code>"rank"</code> will plot rank per instance instead of raw cost value.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_n">n</code></td>
<td>
<p><code>integer(1)</code><br /> Number of parameters included in the plot. By default all parameters are included.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_mar">mar</code></td>
<td>
<p>Vector with the margins for the ablation plot.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2 giving the y-axis range.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_rename_labels">rename_labels</code></td>
<td>
<p><code>character()</code><br /> Renaming table for nicer labels. For example, <code>c("No value"="NA", "LongParameterName"="LPN")</code>.</p>
</td></tr>
<tr><td><code id="plotAblation_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may also be supplied as
arguments. See <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres and Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ablation">ablation()</a></code> <code><a href="#topic+ablation_cmdline">ablation_cmdline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfile &lt;- file.path(system.file(package="irace"), "exdata", "log-ablation.Rdata")
plotAblation(ablog = logfile)
plotAblation(ablog = logfile, type = "mean")
plotAblation(ablog = logfile, type = c("rank","boxplot"), rename_labels = c(
            "localsearch"="ls", algorithm="algo", source="default"))
</code></pre>

<hr>
<h2 id='printParameters'>Print parameter space in the textual format accepted by irace.</h2><span id='topic+printParameters'></span>

<h3>Description</h3>

<p>Print parameter space in the textual format accepted by irace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printParameters(parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printParameters_+3A_parameters">parameters</code></td>
<td>
<p><code>ParameterSpace</code><br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character()</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readParameters">readParameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parameters_table &lt;- '
 # name       switch           type  values               [conditions (using R syntax)]
 algorithm    "--"             c     (as,mmas,eas,ras,acs)
 localsearch  "--localsearch " c     (0, 1, 2, 3)
 alpha        "--alpha "       r     (0.00, 5.00)
 beta         "--beta "        r     (0.00, 10.00)
 rho          "--rho  "        r     (0.01, 1.00)
 ants         "--ants "        i,log (5, 100)
 q0           "--q0 "          r     (0.0, 1.0)           | algorithm == "acs"
 q0dep       "--q0 "           r     (0.0, q0)            | algorithm != "acs"
 rasrank      "--rasranks "    i     (1, "min(ants, 10)") | algorithm == "ras"
 elitistants  "--elitistants " i     (1, ants)            | algorithm == "eas"
 nnls         "--nnls "        i     (5, 50)              | localsearch %in% c(1,2,3)
 dlb          "--dlb "         c     (0, 1)               | localsearch %in% c(1,2,3)

 [forbidden]
 (alpha == 0.0) &amp; (beta == 0.0)
'
parameters &lt;- readParameters(text=parameters_table)
printParameters(parameters)
</code></pre>

<hr>
<h2 id='printScenario'>Prints the given scenario</h2><span id='topic+printScenario'></span>

<h3>Description</h3>

<p>Prints the given scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printScenario(scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printScenario_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+readScenario">readScenario()</a></code></dt><dd><p>for reading a configuration scenario from a file.</p>
</dd>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='psRace'>Post-selection race</h2><span id='topic+psRace'></span>

<h3>Description</h3>

<p><code>psRace</code> performs a post-selection race of a set of configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psRace(
  iraceResults,
  max_experiments,
  conf_ids = NULL,
  iteration_elites = FALSE,
  psrace_logFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psRace_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code>|<code>character(1)</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>. If a character string is given, then it is interpreted as the path to the log file from which the <code>iraceResults</code> object will be loaded.</p>
</td></tr>
<tr><td><code id="psRace_+3A_max_experiments">max_experiments</code></td>
<td>
<p><code>numeric(1)</code><br /> Number of experiments for the
post-selection race. If it is equal to or smaller than 1, then it is a
fraction of the total budget given by
<code>iraceResults$scenario$maxExperiments</code> or <code>iraceResults$scenario$maxTime / iraceResults$state$boundEstimate</code>.</p>
</td></tr>
<tr><td><code id="psRace_+3A_conf_ids">conf_ids</code></td>
<td>
<p>IDs of the configurations in <code>iraceResults$allConfigurations</code> to be used for the post-selection.
If <code>NULL</code>, then the configurations are automatically selected.</p>
</td></tr>
<tr><td><code id="psRace_+3A_iteration_elites">iteration_elites</code></td>
<td>
<p>If <code>FALSE</code>, give priority to selecting the configurations that were elite in the last iteration.
If <code>TRUE</code>, select from all elite configurations of all iterations. This parameter only has an effect when <code>conf_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psRace_+3A_psrace_logfile">psrace_logFile</code></td>
<td>
<p><code>character(1)</code><br /> Log file to save the post-selection race log. If <code>NULL</code>, the log is saved in <code>iraceResults$scenario$logFile</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The elite configurations after the post-selection. In addition, if <code>iraceResults$scenario$logFile</code> is defined,
it saves an updated copy of <code>iraceResults</code> in that file, where <code>iraceResults$psrace_log</code> is a list with the following elements:
</p>

<dl>
<dt>configurations</dt><dd><p>Configurations used in the post-selection race.</p>
</dd>
<dt>instances</dt><dd><p>Data frame with the instances used in the post-selection race. First column has the
instances IDs from <code>iraceResults$scenario$instances</code>, second column the seed assigned to the instance.</p>
</dd>
<dt>max_experiments</dt><dd><p>Configuration budget assigned to the post-selection race.</p>
</dd>
<dt>experiments</dt><dd><p>Matrix of results generated by the post-selection  race, in the same format as the matrix <code>iraceResults$experiments</code>. Column names are the configuration IDs and  row names are the instance IDs.</p>
</dd>
<dt>elites</dt><dd><p>Best configurations found in the experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Leslie Pérez Cáceres and Manuel López-Ibáñez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  irace_log &lt;- read_logfile(system.file(package="irace", "exdata", "sann.rda"))
  # Use a temporary file to not change the original "sann.rda".
  psrace_logFile &lt;- withr::local_tempfile(fileext = ".Rdata")
  # Execute the post-selection after the execution of irace. Use 10% of the total budget.
  psRace(irace_log, max_experiments=0.1, psrace_logFile = psrace_logFile)
  # Print psrace_log
  irace_log &lt;- read_logfile(psrace_logFile)
  str(irace_log$psrace_log)

</code></pre>

<hr>
<h2 id='random_seed'>Get, set and restore the state of the random number generator state.</h2><span id='topic+random_seed'></span><span id='topic+get_random_seed'></span><span id='topic+set_random_seed'></span><span id='topic+restore_random_seed'></span>

<h3>Description</h3>

<p>Get, set and restore the state of the random number generator state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_seed()

set_random_seed(seed)

restore_random_seed(seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_seed_+3A_seed">seed</code></td>
<td>
<p>(<code>list()</code>|<code>integer(1)</code>)<br /> Either an integer or the list returned gy <code><a href="#topic+get_random_seed">get_random_seed()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions originate from the <code><a href="withr.html#topic+with_seed">withr</a></code> package.
</p>


<h3>Value</h3>

<p><code><a href="#topic+get_random_seed">get_random_seed()</a></code> returns a list with two components <code>random_seed</code> and <code>rng_kind</code> or NULL if no seed was set; <code><a href="#topic+set_random_seed">set_random_seed()</a></code> and <code><a href="#topic+restore_random_seed">restore_random_seed()</a></code> do not return anything.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old_seed &lt;- get_random_seed()
on.exit(restore_random_seed(old_seed))
set_random_seed(42)
value1 &lt;- runif(1)
set_random_seed(42)
value2 &lt;- runif(1)
stopifnot(all.equal(value1,value2))

</code></pre>

<hr>
<h2 id='read_ablogfile'>Read the log file (<code>log-ablation.Rdata</code>) produced by <code><a href="#topic+ablation">ablation()</a></code>.</h2><span id='topic+read_ablogfile'></span>

<h3>Description</h3>

<p>Read the log file (<code>log-ablation.Rdata</code>) produced by <code><a href="#topic+ablation">ablation()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ablogfile(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_ablogfile_+3A_filename">filename</code></td>
<td>
<p><code>character(1)</code><br /> Filename that contains the log file saved by <code><a href="#topic+ablation">ablation()</a></code>. Example: <code>log-ablation.Rdata</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code>
</p>

<hr>
<h2 id='read_logfile'>Read the log file produced by irace (<code>irace.Rdata</code>).</h2><span id='topic+read_logfile'></span>

<h3>Description</h3>

<p>Read the log file produced by irace (<code>irace.Rdata</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_logfile(filename, name = "iraceResults")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_logfile_+3A_filename">filename</code></td>
<td>
<p>Filename that contains the log file saved by irace. Example: <code>irace.Rdata</code>.</p>
</td></tr>
<tr><td><code id="read_logfile_+3A_name">name</code></td>
<td>
<p>Optional argument that allows overriding the default name of the object in the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list()</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irace_results &lt;- read_logfile(system.file("exdata/irace-acotsp.Rdata", package="irace",
                                          mustWork=TRUE))
str(irace_results)
</code></pre>

<hr>
<h2 id='read_pcs_file'>Read parameters in PCS (AClib) format and write them in irace format.</h2><span id='topic+read_pcs_file'></span>

<h3>Description</h3>

<p>Read parameters in PCS (AClib) format and write them in irace format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pcs_file(file, digits = 4L, debugLevel = 0L, text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_pcs_file_+3A_file">file</code></td>
<td>
<p><code>character(1)</code><br /> Filename containing the definitions of
the parameters to be tuned.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_digits">digits</code></td>
<td>
<p><code>integer(1)</code><br /> The number of decimal places to be considered for real-valued parameters.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_debuglevel">debugLevel</code></td>
<td>
<p><code>integer(1)</code><br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="read_pcs_file_+3A_text">text</code></td>
<td>
<p><code>character(1)</code><br /> If <code>file</code> is not supplied and this is,
then parameters are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>file</code> or <code>text</code> must be given. If <code>file</code> is given, the
parameters are read from the file <code>file</code>. If <code>text</code> is given instead,
the parameters are read directly from the <code>text</code> character string.
In both cases, the parameters must be given (in <code>text</code> or in the file
whose name is <code>file</code>) in the expected form.  See the documentation
for details.  If none of these parameters is given, <span class="pkg">irace</span>
will stop with an error.
</p>
<p><strong>FIXME:</strong> Multiple conditions and default configuration are currently ignored. See <a href="https://github.com/MLopez-Ibanez/irace/issues/31">https://github.com/MLopez-Ibanez/irace/issues/31</a>
</p>


<h3>Value</h3>

<p>A string representing the parameters in irace format.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Frank Hutter, Manuel López-Ibáñez, Chris Fawcett, Marius Thomas Lindauer, Holger H. Hoos, Kevin Leyton-Brown, and Thomas Stützle. <strong>AClib: A Benchmark Library for Algorithm Configuration</strong>. In P. M. Pardalos, M. G. C. Resende, C. Vogiatzis, and J. L. Walteros, editors, <em>Learning and Intelligent Optimization, 8th International Conference, LION 8</em>, volume 8426 of Lecture Notes in Computer Science, pages 36–40. Springer, Heidelberg, 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readParameters">readParameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Read the parameters directly from text
 pcs_table &lt;- '
 # name       domain
 algorithm    {as,mmas,eas,ras,acs}[as]
 localsearch  {0, 1, 2, 3}[0]
 alpha        [0.00, 5.00][1]
 beta         [0.00, 10.00][1]
 rho          [0.01, 1.00][0.95]
 ants         [1, 100][10]il
 q0           [0.0, 1.0][0]
 rasrank      [1, 100][1]i
 elitistants  [1, 750][1]i
 nnls         [5, 50][5]i
 dlb          {0, 1}[1]
 Conditionals:
 q0 | algorithm in {acs}
 rasrank | algorithm in {ras}
 elitistants | algorithm in {eas}
 nnls | localsearch in {1,2,3}
 dlb | localsearch in {1,2,3}
 {alpha=0, beta=0}'
 parameters_table &lt;- read_pcs_file(text=pcs_table)
 cat(parameters_table)
 parameters &lt;- readParameters(text=parameters_table)
 str(parameters)

</code></pre>

<hr>
<h2 id='readConfigurationsFile'>Read parameter configurations from a file</h2><span id='topic+readConfigurationsFile'></span>

<h3>Description</h3>

<p>Reads a set of target-algorithm configurations from a file and puts them in
<span class="pkg">irace</span> format. The configurations are checked to match the parameters
description provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readConfigurationsFile(filename, parameters, debugLevel = 0L, text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readConfigurationsFile_+3A_filename">filename</code></td>
<td>
<p><code>character(1)</code><br /> Filename from which the configurations should be read.
The contents should be readable by <code>read.table( , header=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_parameters">parameters</code></td>
<td>
<p><code>ParameterSpace</code><br /> Data structure containing the parameter
space definition. The data structure has to similar to the one returned by the
function <code><a href="#topic+readParameters">readParameters</a></code>.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_debuglevel">debugLevel</code></td>
<td>
<p><code>integer(1)</code><br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="readConfigurationsFile_+3A_text">text</code></td>
<td>
<p><code>character(1)</code><br /> If <code>file</code> is not supplied and this is,
then configurations are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example of an input file:
</p>
<div class="sourceCode"><pre># This is a comment line
param_1    param_2
    0.5  "value_1"
    1.0         NA
    1.2  "value_3"
</pre></div>
<p>The order of the columns does not necessarily have to be the same
as in the file containing the definition of the parameters.
</p>


<h3>Value</h3>

<p>A data frame containing the obtained configurations.
Each row of the data frame is a candidate configuration,
the columns correspond to the parameter names in <code>parameters</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readParameters">readParameters()</a></code> to obtain a valid parameter structure from a parameters file.
</p>

<hr>
<h2 id='readParameters'>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a
character string.</h2><span id='topic+readParameters'></span>

<h3>Description</h3>

<p>Reads the parameters to be tuned by <span class="pkg">irace</span> from a file or from a
character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readParameters(file, digits = 4L, debugLevel = 0L, text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readParameters_+3A_file">file</code></td>
<td>
<p><code>character(1)</code><br /> Filename containing the definitions of
the parameters to be tuned.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_digits">digits</code></td>
<td>
<p><code>integer(1)</code><br /> The number of decimal places to be considered for real-valued parameters.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_debuglevel">debugLevel</code></td>
<td>
<p><code>integer(1)</code><br /> Larger values produce more verbose output.</p>
</td></tr>
<tr><td><code id="readParameters_+3A_text">text</code></td>
<td>
<p><code>character(1)</code><br /> If <code>file</code> is not supplied and this is,
then parameters are read from the value of <code>text</code> via a text connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>file</code> or <code>text</code> must be given. If <code>file</code> is given, the
parameters are read from the file <code>file</code>. If <code>text</code> is given instead,
the parameters are read directly from the <code>text</code> character string.
In both cases, the parameters must be given (in <code>text</code> or in the file
whose name is <code>file</code>) in the expected form.  See the documentation
for details.  If none of these parameters is given, <span class="pkg">irace</span>
will stop with an error.
</p>
<p>A fixed parameter is a parameter that should not be sampled but
instead should be always set to the only value of its domain.  In this
function we set <code>isFixed</code> to TRUE only if the parameter is a categorical
and has only one possible value.  If it is an integer and the minimum
and maximum are equal, or it is a real and the minimum and maximum
values satisfy <code>round(minimum, digits) == round(maximum, digits)</code>,
then the parameter description is rejected as invalid to identify
potential user errors.
</p>
<p>The order of the parameters determines the order in which parameters are
given to <code>targetRunner</code>. Changing the order may also change the results
produced by <code>irace</code>, even with the same random seed.
</p>


<h3>Value</h3>

<p>A list containing the definitions of the parameters read. The list is
structured as follows:
</p>

<dl>
<dt><code>names</code></dt><dd><p>Vector that contains the names of the parameters.</p>
</dd>
<dt><code>types</code></dt><dd><p>Vector that contains the type of each parameter 'i', 'c', 'r', 'o'.
Numerical parameters can be sampled in a log-scale with 'i,log' and 'r,log'
(no spaces).</p>
</dd>
<dt><code>switches</code></dt><dd><p>Vector that contains the switches to be used for the
parameters on the command line.</p>
</dd>
<dt><code>domain</code></dt><dd><p>List of vectors, where each vector may contain two
values (minimum, maximum) for real and integer parameters, or
possibly more for categorical parameters.</p>
</dd>
<dt><code>conditions</code></dt><dd><p>List of R logical expressions, with variables
corresponding to parameter names.</p>
</dd>
<dt><code>isFixed</code></dt><dd><p>Logical vector that specifies which parameter is fixed
and, thus, it does not need to be tuned.</p>
</dd>
<dt><code>nbParameters</code></dt><dd><p>An integer, the total number of parameters.</p>
</dd>
<dt><code>nbFixed</code></dt><dd><p>An integer, the number of parameters with a fixed value.</p>
</dd>
<dt><code>nbVariable</code></dt><dd><p>Number of variable (to be tuned) parameters.</p>
</dd>
<dt><code>depends</code></dt><dd><p>List of character vectors, each vector specifies
which parameters depend on this one.</p>
</dd>
<dt><code>is_dependent</code></dt><dd><p>Logical vector that specifies which parameter has
a dependent domain.</p>
</dd>
<dt><code>digits</code></dt><dd><p>Integer vector that specifies the number of digits per parameter.</p>
</dd>
<dt><code>forbidden</code></dt><dd><p>List of expressions that define which parameter configurations are forbidden.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Read the parameters directly from text
 parameters_table &lt;- '
 # name       switch           type  values               [conditions (using R syntax)]
 algorithm    "--"             c     (as,mmas,eas,ras,acs)
 localsearch  "--localsearch " o     (0, 1, 2, 3)
 alpha        "--alpha "       r     (0.00, 5.00)
 beta         "--beta "        r     (0.00, 10.00)
 rho          "--rho  "        r     (0.01, 1.00)
 ants         "--ants "        i,log (5, 100)
 q0           "--q0 "          r     (0.0, 1.0)           | algorithm == "acs"
 rasrank      "--rasranks "    i     (1, "min(ants, 10)") | algorithm == "ras"
 elitistants  "--elitistants " i     (1, ants)            | algorithm == "eas"
 nnls         "--nnls "        i     (5, 50)              | localsearch %in% c(1,2,3)
 dlb          "--dlb "         c     (0, 1)               | localsearch %in% c(1,2,3)

 [forbidden]
 (alpha == 0.0) &amp; (beta == 0.0)
 [global]
 digits = 4
 '
 parameters &lt;- readParameters(text=parameters_table)
 str(parameters)

</code></pre>

<hr>
<h2 id='readScenario'>Reads from a file the scenario settings to be used by <span class="pkg">irace</span>.</h2><span id='topic+readScenario'></span>

<h3>Description</h3>

<p>The scenario argument is an initial scenario that is overwritten for every
setting specified in the file to be read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readScenario(filename = "", scenario = list(), params_def = .irace.params.def)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readScenario_+3A_filename">filename</code></td>
<td>
<p><code>character(1)</code><br /> Filename from which the scenario will
be read. If empty, the default <code>scenarioFile</code> is used.  An example
scenario file is provided in <code>system.file(package="irace", "templates/scenario.txt.tmpl")</code>.</p>
</td></tr>
<tr><td><code id="readScenario_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="readScenario_+3A_params_def">params_def</code></td>
<td>
<p><code>data.frame()</code><br /> Definition of the options accepted by
the scenario. This should only be modified by packages that wish to extend
<span class="pkg">irace</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scenario list read from the file. The scenario settings not
present in the file are not present in the list, i.e., they are <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+printScenario">printScenario()</a></code></dt><dd><p>prints the given scenario.</p>
</dd>
<dt><code><a href="#topic+defaultScenario">defaultScenario()</a></code></dt><dd><p>returns the default scenario settings of <span class="pkg">irace</span>.</p>
</dd>
<dt><code><a href="#topic+checkScenario">checkScenario()</a></code></dt><dd><p>to check that the scenario is valid.</p>
</dd>
</dl>


<hr>
<h2 id='removeConfigurationsMetaData'>removeConfigurationsMetaData</h2><span id='topic+removeConfigurationsMetaData'></span>

<h3>Description</h3>

<p>Remove the columns with &quot;metadata&quot; of a data frame containing
configurations. Currently, metadata corresponds to column names starting
with a period.  This function should be used before printing the
configurations to output only the values for the parameters of the
configuration without metadata possibly useless to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeConfigurationsMetaData(configurations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeConfigurationsMetaData_+3A_configurations">configurations</code></td>
<td>
<p><code>data.frame</code><br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same data frame without &quot;metadata&quot;.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configurations_print_command">configurations_print_command()</a></code> to print the configurations as command lines.
<code><a href="#topic+configurations_print">configurations_print()</a></code> to print the configurations as a data frame.
</p>

<hr>
<h2 id='save_irace_logfile'>Save the log generated by <span class="pkg">irace</span> to a file (by default <code>irace.Rdata</code>).</h2><span id='topic+save_irace_logfile'></span>

<h3>Description</h3>

<p>This function may be useful if you are manually editing the log data generated by a run of <span class="pkg">irace</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_irace_logfile(iraceResults, logfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_irace_logfile_+3A_iraceresults">iraceResults</code></td>
<td>
<p><code>list()</code><br /> Object created by <span class="pkg">irace</span> and typically saved in the log file <code>irace.Rdata</code>.</p>
</td></tr>
<tr><td><code id="save_irace_logfile_+3A_logfile">logfile</code></td>
<td>
<p><code>character(1)</code><br /> Filename to save <code>iraceResults</code>. Usually, this is given by <code>scenario$logFile</code>. If <code>NULL</code> or <code>""</code>, no data is saved.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_logfile">read_logfile()</a></code>
</p>

<hr>
<h2 id='scenario_update_paths'>Update filesystem paths of a scenario consistently.</h2><span id='topic+scenario_update_paths'></span>

<h3>Description</h3>

<p>This function should be used to change the filesystem paths stored in a
scenario object. Useful when moving a scenario from one computer to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scenario_update_paths(scenario, from, to, fixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scenario_update_paths_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_from">from</code></td>
<td>
<p><code>character(1)</code><br /> Character string containing a regular expression (or character
string for <code>fixed = TRUE</code>) to be matched.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_to">to</code></td>
<td>
<p><code>character(1)</code><br />  The replacement string.character string. For <code>fixed = FALSE</code>
this can include backreferences <code>"\1"</code> to <code>"\9"</code> to
parenthesized subexpressions of <code>from</code>.</p>
</td></tr>
<tr><td><code id="scenario_update_paths_+3A_fixed">fixed</code></td>
<td>
<p><code>logical(1)</code><br /> If <code>TRUE</code>, <code>from</code> is a string to be matched
as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated scenario
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">base::grep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
scenario &lt;- readScenario(filename = "scenario.txt")
scenario &lt;- scenario_update_paths(scenario, from = "/home/manuel/", to = "/home/leslie")

## End(Not run)
</code></pre>

<hr>
<h2 id='target_evaluator_default'>target_evaluator_default</h2><span id='topic+target_evaluator_default'></span>

<h3>Description</h3>

<p><code>target_evaluator_default</code> is the default <code>targetEvaluator</code> function that is
invoked if <code>targetEvaluator</code> is a string (by default
<code>targetEvaluator</code> is <code>NULL</code> and this function is not invoked). You can use it as
an advanced example of how to create your own <code>targetEvaluator</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_evaluator_default(
  experiment,
  num_configurations,
  all_conf_id,
  scenario,
  target_runner_call
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_evaluator_default_+3A_experiment">experiment</code></td>
<td>
<p>A list describing the experiment. It contains at least:
</p>

<dl>
<dt><code>id_configuration</code></dt><dd><p>An alphanumeric string that uniquely identifies a configuration;</p>
</dd>
<dt><code>id_instance</code></dt><dd><p>An alphanumeric string that uniquely identifies an instance;</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for the random number generator to be used for
this evaluation, ignore the seed for deterministic algorithms;</p>
</dd>
<dt><code>instance</code></dt><dd><p>String giving the instance to be used for this evaluation;</p>
</dd>
<dt><code>bound</code></dt><dd><p>(only when <code>capping</code> is enabled) Time bound for the execution;</p>
</dd>
<dt><code>configuration</code></dt><dd><p>1-row data frame with a column per parameter
name;</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="target_evaluator_default_+3A_num_configurations">num_configurations</code></td>
<td>
<p>Number of  configurations alive in the race.</p>
</td></tr>
<tr><td><code id="target_evaluator_default_+3A_all_conf_id">all_conf_id</code></td>
<td>
<p>Vector of configuration IDs of the alive configurations.</p>
</td></tr>
<tr><td><code id="target_evaluator_default_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
<tr><td><code id="target_evaluator_default_+3A_target_runner_call">target_runner_call</code></td>
<td>
<p>String describing the call to <code>targetRunner</code> that
corresponds to this call to <code>targetEvaluator</code>. This is used for
providing extra information to the user, for example, in case
<code>targetEvaluator</code> fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>targetEvaluator</code> must return a list with one element
<code>"cost"</code>, the numerical value corresponding to the cost measure of the
given configuration on the given instance.
</p>
<p>The return list may also contain the following optional elements that are used
by <span class="pkg">irace</span> for reporting errors in <code>targetEvaluator</code>:
</p>

<dl>
<dt><code>error</code></dt><dd><p>is a string used to report an error;</p>
</dd>
<dt><code>outputRaw</code></dt><dd><p>is a string used to report the raw output of calls to
an external program or function;</p>
</dd>
<dt><code>call</code></dt><dd><p>is a string used to report how <code>targetRunner</code> called
an external program or function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>

<hr>
<h2 id='target_runner_default'>Default <code>targetRunner</code> function.</h2><span id='topic+target_runner_default'></span>

<h3>Description</h3>

<p>Use it as an advanced example of how to create your own <code>targetRunner</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_runner_default(experiment, scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_runner_default_+3A_experiment">experiment</code></td>
<td>
<p>A list describing the experiment. It contains at least:
</p>

<dl>
<dt><code>id_configuration</code></dt><dd><p>An alphanumeric string that uniquely identifies a configuration;</p>
</dd>
<dt><code>id_instance</code></dt><dd><p>An alphanumeric string that uniquely identifies an instance;</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for the random number generator to be used for
this evaluation, ignore the seed for deterministic algorithms;</p>
</dd>
<dt><code>instance</code></dt><dd><p>String giving the instance to be used for this evaluation;</p>
</dd>
<dt><code>bound</code></dt><dd><p>(only when <code>capping</code> is enabled) Time bound for the execution;</p>
</dd>
<dt><code>configuration</code></dt><dd><p>1-row data frame with a column per parameter
name;</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="target_runner_default_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>targetEvaluator</code> is <code>NULL</code>, then the <code>targetRunner</code>
function must return a list with at least one element <code>"cost"</code>,
the numerical value corresponding to the evaluation of the given
configuration on the given instance.
</p>
<p>If the scenario option <code>maxTime</code> is non-zero or if <code>capping</code> is enabled
then the list must contain at least another element <code>"time"</code> that reports the
execution time for this call to <code>targetRunner</code>.
The return list may also contain the following optional elements that are used
by <span class="pkg">irace</span> for reporting errors in <code>targetRunner</code>:
</p>

<dl>
<dt><code>error</code></dt><dd><p>is a string used to report an error;</p>
</dd>
<dt><code>outputRaw</code></dt><dd><p>is a string used to report the raw output of calls to
an external program or function;</p>
</dd>
<dt><code>call</code></dt><dd><p>is a string used to report how <code>targetRunner</code> called
an external program or function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Jérémie Dubois-Lacoste
</p>

<hr>
<h2 id='testConfigurations'>Execute the given configurations on the testing instances specified in the
scenario</h2><span id='topic+testConfigurations'></span>

<h3>Description</h3>

<p>Execute the given configurations on the testing instances specified in the
scenario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testConfigurations(configurations, scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testConfigurations_+3A_configurations">configurations</code></td>
<td>
<p><code>data.frame</code><br /> Parameter configurations of the
target algorithm (one per row).</p>
</td></tr>
<tr><td><code id="testConfigurations_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A test instance set must be provided through <code>scenario[["testInstances"]]</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>experiments</code></dt><dd><p>Experiments results.</p>
</dd>
<dt><code>seeds</code></dt><dd><p>Array of the instance seeds used in the experiments.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testing_fromlog">testing_fromlog()</a></code>
</p>

<hr>
<h2 id='testing_fromfile'>Test configurations given an explicit table of configurations and a scenario file</h2><span id='topic+testing_fromfile'></span>

<h3>Description</h3>

<p>Executes the testing of an explicit list of configurations given in
<code>filename</code> (same format as in <code><a href="#topic+readConfigurationsFile">readConfigurationsFile()</a></code>). A <code>logFile</code> is
created unless disabled in <code>scenario</code>. This may overwrite an existing one!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing_fromfile(filename, scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testing_fromfile_+3A_filename">filename</code></td>
<td>
<p><code>character(1)</code><br /> Path to a file containing configurations: one configuration
per line, one parameter per column, parameter names in header.</p>
</td></tr>
<tr><td><code id="testing_fromfile_+3A_scenario">scenario</code></td>
<td>
<p><code>list()</code><br /> Data structure containing <span class="pkg">irace</span>
settings. The data structure has to be the one returned by the function
<code><a href="#topic+defaultScenario">defaultScenario()</a></code> or <code><a href="#topic+readScenario">readScenario()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iraceResults
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testing_fromlog">testing_fromlog()</a></code> provides a different interface for testing.
</p>

<hr>
<h2 id='testing_fromlog'>Test configurations given in the logfile (typically <code>irace.Rdata</code>) produced by <span class="pkg">irace</span>.</h2><span id='topic+testing_fromlog'></span>

<h3>Description</h3>

<p><code>testing_fromlog</code> executes the testing of the target algorithm configurations
found by an <span class="pkg">irace</span> execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing_fromlog(
  logFile,
  testNbElites,
  testIterationElites,
  testInstancesDir,
  testInstancesFile,
  testInstances
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testing_fromlog_+3A_logfile">logFile</code></td>
<td>
<p><code>character(1)</code><br /> Path to the logfile (typically <code>irace.Rdata</code>) produced by <span class="pkg">irace</span>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testnbelites">testNbElites</code></td>
<td>
<p>Number of (final) elite configurations to test. Overrides
the value found in <code>logFile</code>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testiterationelites">testIterationElites</code></td>
<td>
<p><code>logical(1)</code><br /> If <code>FALSE</code>, only the final
<code>testNbElites</code> configurations are tested; otherwise, also test the best
configurations of each iteration. Overrides the value found in <code>logFile</code>.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstancesdir">testInstancesDir</code></td>
<td>
<p>Directory where testing instances are located, either absolute or relative to current directory.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstancesfile">testInstancesFile</code></td>
<td>
<p>File containing a list of test instances and optionally additional parameters for them.</p>
</td></tr>
<tr><td><code id="testing_fromlog_+3A_testinstances">testInstances</code></td>
<td>
<p>Character vector of the instances to be used in the <code>targetRunner</code> when executing the testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>testing_fromlog</code> loads the <code>logFile</code> and obtains the
testing setup and configurations to be tested.  Within the <code>logFile</code>, the
variable <code>scenario$testNbElites</code> specifies how many final elite
configurations to test and <code>scenario$testIterationElites</code> indicates
whether test the best configuration of each iteration. The values may be
overridden by setting the corresponding arguments in this function.  The
set of testing instances must appear in <code>scenario[["testInstances"]]</code>.
</p>


<h3>Value</h3>

<p><code>logical(1)</code><br /> <code>TRUE</code> if the testing ended successfully otherwise, <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez and Leslie Pérez Cáceres
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defaultScenario">defaultScenario()</a></code> to provide a default scenario for <span class="pkg">irace</span>.
<code><a href="#topic+testing_fromfile">testing_fromfile()</a></code> provides a different interface for testing.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
