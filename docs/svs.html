<!DOCTYPE html><html lang="en"><head><title>Help for package svs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {svs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#svs-package'><p>Tools for Semantic Vector Spaces</p></a></li>
<li><a href='#cd_plot'><p>Plotting a Cumulative Distribution</p></a></li>
<li><a href='#centers_ca'><p>Compute Coordinates for Cluster Centers</p></a></li>
<li><a href='#complete_pvpick'><p>Complete the Output of <code>pvpick</code></p></a></li>
<li><a href='#Ctxt_Dut.txt'><p>Context Words for seventeen Dutch Words</p></a></li>
<li><a href='#Ctxt_Eng.txt'><p>Context Words for seventeen Dutch Words Translated from French</p></a></li>
<li><a href='#Ctxt_Fra.txt'><p>Context Words for seventeen Dutch Words Translated from French</p></a></li>
<li><a href='#dat2ddc'><p>Transform a Data Frame into a Double-Coded Matrix</p></a></li>
<li><a href='#dat2ind'><p>Transform a Data Frame into an Indicator Matrix</p></a></li>
<li><a href='#dist_chisquare'><p>Compute Chi-square Distances</p></a></li>
<li><a href='#dist_cosine'><p>Compute Cosine Distances</p></a></li>
<li><a href='#dist_wrt'><p>Compute Distances with respect to a certain Point</p></a></li>
<li><a href='#dist_wrt_centers'><p>Compute Distances with respect to Cluster Centers</p></a></li>
<li><a href='#fast_dca'><p>Discriminant Correspondence Analysis</p></a></li>
<li><a href='#fast_E_M'><p>EM clustering</p></a></li>
<li><a href='#fast_lca'><p>Latent Class Analysis</p></a></li>
<li><a href='#fast_lma'><p>Log-Multiplicative Association Analysis</p></a></li>
<li><a href='#fast_lra'><p>Logratio Analysis</p></a></li>
<li><a href='#fast_lsa'><p>Latent Semantic Analysis</p></a></li>
<li><a href='#fast_mca'><p>Multiple Correspondence Analysis</p></a></li>
<li><a href='#fast_nmf'><p>Non-negative Matrix Factorization</p></a></li>
<li><a href='#fast_psa'><p>Probabilistic Latent Semantic Analysis</p></a></li>
<li><a href='#fast_sca'><p>Simple Correspondence Analysis</p></a></li>
<li><a href='#freq_ca'><p>Compute Level Frequencies (for a Factor or Vector)</p></a></li>
<li><a href='#InvT_Eng.txt'><p>Seventeen Dutch Target Words and their English Source Words</p></a></li>
<li><a href='#InvT_Fra.txt'><p>Seventeen Dutch Target Words and their French Source Words</p></a></li>
<li><a href='#layout4bipartite'><p>Create a Layout Matrix for a Bipartite Graph</p></a></li>
<li><a href='#log_or_0'><p>Logarithmic transform</p></a></li>
<li><a href='#MI'><p>Mutual Information</p></a></li>
<li><a href='#outerec'><p>Recursive Application of the Outer Product</p></a></li>
<li><a href='#pc_plot'><p>Plotting Parallel Coordinates</p></a></li>
<li><a href='#pmi'><p>Pointwise Mutual Information</p></a></li>
<li><a href='#rep4dat'><p>Repeat the Rows of a Data Frame according to a Frequency Column</p></a></li>
<li><a href='#SndT_Eng.txt'><p>Seventeen Dutch Source Words and their English Translations</p></a></li>
<li><a href='#SndT_Fra.txt'><p>Seventeen Dutch Source Words and their French Translations</p></a></li>
<li><a href='#tab2dat'><p>Transform a Table into a Data Frame</p></a></li>
<li><a href='#tab2ind'><p>Transform a Table into an Indicator Matrix</p></a></li>
<li><a href='#vec2ddc'><p>Transform a Vector into a Double-Coded Matrix</p></a></li>
<li><a href='#vec2ind'><p>Transform a Vector into an Indicator Matrix</p></a></li>
<li><a href='#weighting_functions'><p>Weighting Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Semantic Vector Spaces</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Various tools for semantic vector spaces, such as
    correspondence analysis (simple, multiple and discriminant), latent
    semantic analysis, probabilistic latent semantic analysis, non-negative
    matrix factorization, latent class analysis, EM clustering, logratio
	analysis and log-multiplicative (association) analysis. Furthermore,
    there are specialized distance measures, plotting functions and some helper
    functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, graphics, stats, methods, Matrix, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, MASS, pvclust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-24</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-24 12:53:25 UTC; kplevoet</td>
</tr>
<tr>
<td>Author:</td>
<td>Koen Plevoets <a href="https://orcid.org/0000-0003-3889-1809"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Koen Plevoets &lt;koen.plevoets@ugent.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-24 13:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='svs-package'>Tools for Semantic Vector Spaces</h2><span id='topic+svs-package'></span>

<h3>Description</h3>

<p>This package offers various tools for semantic vector spaces. There are techniques for correspondence analysis (simple,
multiple and discriminant), latent semantic analysis, probabilistic latent semantic analysis, non-negative matrix
factorization, latent class analysis, EM clustering, logratio analysis and log-multiplicative (association)
analysis. Furthermore, the package has specialized distance measures and plotting functions as well as
some helper functions.
</p>


<h3>Contents</h3>

<p>This package contains the following raw data files (in the folder <em>extdata</em>):
</p>

<dl>
<dt><code><a href="#topic+SndT_Fra.txt">SndT_Fra.txt</a></code></dt><dd><p>Seventeen Dutch source words and their French translations.</p>
</dd>
<dt><code><a href="#topic+SndT_Eng.txt">SndT_Eng.txt</a></code></dt><dd><p>Seventeen Dutch source words and their English translations.</p>
</dd>
<dt><code><a href="#topic+InvT_Fra.txt">InvT_Fra.txt</a></code></dt><dd><p>Seventeen Dutch target words and their French source words.</p>
</dd>
<dt><code><a href="#topic+InvT_Eng.txt">InvT_Eng.txt</a></code></dt><dd><p>Seventeen Dutch target words and their English source words.</p>
</dd>
<dt><code><a href="#topic+Ctxt_Dut.txt">Ctxt_Dut.txt</a></code></dt><dd><p>Context words for seventeen Dutch words.</p>
</dd>
<dt><code><a href="#topic+Ctxt_Fra.txt">Ctxt_Fra.txt</a></code></dt><dd><p>Context words for seventeen Dutch words translated from French.</p>
</dd>
<dt><code><a href="#topic+Ctxt_Eng.txt">Ctxt_Eng.txt</a></code></dt><dd><p>Context words for seventeen Dutch words translated from English.</p>
</dd>
</dl>

<p>The (fast procedures for the) techniques in this package are:
</p>

<dl>
<dt><code><a href="#topic+fast_sca">fast_sca</a></code></dt><dd><p>Simple correspondence analysis.</p>
</dd>
<dt><code><a href="#topic+fast_mca">fast_mca</a></code></dt><dd><p>Multiple correspondence analysis.</p>
</dd>
<dt><code><a href="#topic+fast_dca">fast_dca</a></code></dt><dd><p>Discriminant correspondence analysis.</p>
</dd>
<dt><code><a href="#topic+fast_lsa">fast_lsa</a></code></dt><dd><p>Latent semantic analysis.</p>
</dd>
<dt><code><a href="#topic+fast_psa">fast_psa</a></code></dt><dd><p>Probabilistic latent semantic analysis.</p>
</dd>
<dt><code><a href="#topic+fast_nmf">fast_nmf</a></code></dt><dd><p>Non-negative matrix factorization.</p>
</dd>
<dt><code><a href="#topic+fast_lca">fast_lca</a></code></dt><dd><p>Latent class analysis.</p>
</dd>
<dt><code><a href="#topic+fast_E_M">fast_E_M</a></code></dt><dd><p>EM clustering.</p>
</dd>
<dt><code><a href="#topic+fast_lra">fast_lra</a></code></dt><dd><p>Logratio analysis.</p>
</dd>
<dt><code><a href="#topic+fast_lma">fast_lma</a></code></dt><dd><p>Log-multiplicative (association) analysis.</p>
</dd>
</dl>

<p>The complete overview of local and global weighting functions in this package can be found on <code><a href="#topic+weighting_functions">weighting_functions</a></code>.
</p>
<p>The specialized distance measures are:
</p>

<dl>
<dt><code><a href="#topic+dist_chisquare">dist_chisquare</a></code></dt><dd><p>Chi-square distance.</p>
</dd>
<dt><code><a href="#topic+dist_cosine">dist_cosine</a></code></dt><dd><p>Cosine distance.</p>
</dd>
<dt><code><a href="#topic+dist_wrt">dist_wrt</a></code></dt><dd><p>Distance with respect to a certain point.</p>
</dd>
<dt><code><a href="#topic+dist_wrt_centers">dist_wrt_centers</a></code></dt><dd><p>Distance with respect to cluster centers.</p>
</dd>
</dl>

<p>The specialized plotting functions are:
</p>

<dl>
<dt><code><a href="#topic+cd_plot">cd_plot</a></code></dt><dd><p>Cumulative distribution plot.</p>
</dd>
<dt><code><a href="#topic+pc_plot">pc_plot</a></code></dt><dd><p>Parallel coordinate plot.</p>
</dd>
</dl>

<p>There are two helper functions for correspondence analysis:
</p>

<dl>
<dt><code><a href="#topic+freq_ca">freq_ca</a></code></dt><dd><p>Compute level frequencies (for a factor).</p>
</dd>
<dt><code><a href="#topic+centers_ca">centers_ca</a></code></dt><dd><p>Compute coordinates for cluster centers.</p>
</dd>
</dl>

<p>There is one helper function for <span class="pkg">pvclust</span>:
</p>

<dl>
<dt><code><a href="#topic+complete_pvpick">complete_pvpick</a></code></dt><dd><p>Complete the output of <code>pvpick</code>.</p>
</dd>
</dl>

<p>There is one helper function for <span class="pkg">igraph</span>:
</p>

<dl>
<dt><code><a href="#topic+layout4bipartite">layout4bipartite</a></code></dt><dd><p>Create a layout matrix for a bipartite graph.</p>
</dd>
</dl>

<p>The remaining helper functions in this package are:
</p>

<dl>
<dt><code><a href="#topic+rep4dat">rep4dat</a></code></dt><dd><p>Repeat the rows of a data frame according to a frequency column.</p>
</dd>
<dt><code><a href="#topic+vec2ddc">vec2ddc</a></code></dt><dd><p>Transform a vector into a double-coded matrix.</p>
</dd>
<dt><code><a href="#topic+dat2ddc">dat2ddc</a></code></dt><dd><p>Transform a data frame into a double-coded matrix.</p>
</dd>
<dt><code><a href="#topic+vec2ind">vec2ind</a></code></dt><dd><p>Transform a vector into an indicator matrix.</p>
</dd>
<dt><code><a href="#topic+tab2dat">tab2dat</a></code></dt><dd><p>Transform a table into a data frame.</p>
</dd>
<dt><code><a href="#topic+tab2ind">tab2ind</a></code></dt><dd><p>Transform a table into an indicator matrix.</p>
</dd>
<dt><code><a href="#topic+dat2ind">dat2ind</a></code></dt><dd><p>Transform a data frame into an indicator matrix.</p>
</dd>
<dt><code><a href="#topic+outerec">outerec</a></code></dt><dd><p>Recursive application of the outer product.</p>
</dd>
<dt><code><a href="#topic+pmi">pmi</a></code></dt><dd><p>Pointwise mutual information.</p>
</dd>
<dt><code><a href="#topic+MI">MI</a></code></dt><dd><p>Mutual information.</p>
</dd>
<dt><code><a href="#topic+log_or_0">log_or_0</a></code></dt><dd><p>Logarithmic transform.</p>
</dd>
</dl>



<h3>Further reference</h3>


<ul>
<li><p> Many packages contain correspondence analysis: <span class="pkg">ca</span>, <span class="pkg">FactoMineR</span>, <span class="pkg">MASS</span> and others.
</p>
</li>
<li><p> For latent semantic analysis there is also the package <span class="pkg">lsa</span>.
</p>
</li>
<li><p> The package <span class="pkg">NMF</span> provides more flexibility for non-negative matrix factorization.
</p>
</li>
<li><p> For topic models there are the packages <span class="pkg">lda</span> and <span class="pkg">topicmodels</span>.
</p>
</li>
<li><p> Latent class analysis can also be run in the package <span class="pkg">poLCA</span>.
</p>
</li>
<li><p> For log-ratio analysis there is also the package <span class="pkg">easyCODA</span>.
</p>
</li>
<li><p> The package <span class="pkg">gnm</span> offers much flexibility for association analysis, i.e. fitting log-multiplicative or Goodman's RC models.
</p>
</li></ul>



<h3>Link</h3>

<p>As from 2023, this package is part of <a href="https://www.mils.ugent.be/courses/module-10-multivariate-data-analysis-with-r/">Module 10: Multivariate data analysis with R</a> of the Summer School <em>Methods in Language Sciences</em>.
</p>


<h3>Author</h3>

<p>Koen Plevoets, <a href="mailto:koen.plevoets@ugent.be">koen.plevoets@ugent.be</a>
</p>


<h3>Acknowledgements</h3>

<p>This package has benefited greatly from the helpful comments of Lore Vandevoorde, Pauline De Baets and Gert De Sutter. Thanks to
Kurt Hornik, Uwe Ligges and Brian Ripley for their valuable recommendations when proofing this package.
</p>

<hr>
<h2 id='cd_plot'>Plotting a Cumulative Distribution</h2><span id='topic+cd_plot'></span>

<h3>Description</h3>

<p>A function for plotting a cumulative distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd_plot(
  x,
  inc = 0.01,
  col = "darkgrey",
  cex = 1,
  font = 1,
  family = "",
  srt = -45,
  pch = 20,
  pcol = "black",
  pbg = "white",
  pcex = cex,
  lcol = col,
  lwd = 1,
  lty = 1,
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  sub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cd_plot_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_inc">inc</code></td>
<td>
<p>The (numeric) increment for constructing the sequence from 0 to <code>ceiling(max(x))</code>, plotted on the horizontal axis.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_col">col</code></td>
<td>
<p>The color of the line and the text labels: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_cex">cex</code></td>
<td>
<p>The character expansion factor: a numberic value to specify the size of the text labels.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_font">font</code></td>
<td>
<p>The font of the text labels: <code>1</code> for plain, <code>2</code> for bold, <code>3</code> for italic, and <code>4</code> for bold italic.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_family">family</code></td>
<td>
<p>The font family of the text labels: <code>"serif"</code>, <code>"sans"</code>, <code>"mono"</code>, or one of the <code><a href="grDevices.html#topic+Hershey">Hershey</a></code> fonts.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_srt">srt</code></td>
<td>
<p>The rotation angle (in degrees) of the text labels.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_pch">pch</code></td>
<td>
<p>The plotting character for displaying points: see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_pcol">pcol</code></td>
<td>
<p>The color of the plotting character: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_pbg">pbg</code></td>
<td>
<p>The background color of the plotting character: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_pcex">pcex</code></td>
<td>
<p>The character expansion factor of the plotting character: a numeric value to specify the size of the plotting character.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_lcol">lcol</code></td>
<td>
<p>The color of the line: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_lwd">lwd</code></td>
<td>
<p>The line width of the line: a numeric value to specify the width of the line.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_lty">lty</code></td>
<td>
<p>The line type of the line: <code>0</code> or <code>"blank"</code>, <code>1</code> or <code>"solid"</code>, <code>2</code> or <code>"dashed"</code>, <code>3</code> or
<code>"dotted"</code>, <code>4</code> or <code>"dotdash"</code>, <code>5</code> or <code>"longdash"</code>, <code>6</code> or <code>"twodash"</code>.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_xlim">xlim</code></td>
<td>
<p>A vector of two numeric values specifying the lower and upper limit between which to plot the horizontal axis.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two numeric values specifying the lower and upper limit between which to plot the vertical axis.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_xlab">xlab</code></td>
<td>
<p>A character string for labelling of the horizontal axis.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_ylab">ylab</code></td>
<td>
<p>A character string for labelling of the vertical axis.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_main">main</code></td>
<td>
<p>A character string for the main title of the plot.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_sub">sub</code></td>
<td>
<p>A character string for the subtitle of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cumulative distribution plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
dis_SndT_Fra &lt;- dist_wrt(sca_SndT_Fra$pos1)
cd_plot(dis_SndT_Fra)
</code></pre>

<hr>
<h2 id='centers_ca'>Compute Coordinates for Cluster Centers</h2><span id='topic+centers_ca'></span>

<h3>Description</h3>

<p>A helper function for computing the coordinates of cluster centers (typically used in correspondence analysis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centers_ca(x, clusters, freq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centers_ca_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="centers_ca_+3A_clusters">clusters</code></td>
<td>
<p>A clustering of the row levels of <code>x</code>: either a list or the output of <code>kmeans</code>.</p>
</td></tr>
<tr><td><code id="centers_ca_+3A_freq">freq</code></td>
<td>
<p>An optional vector of frequency counts for the row levels of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the coordinates of the cluster centers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freq_ca">freq_ca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
kcl_SndT_Fra &lt;- kmeans(sca_SndT_Fra$pos1, centers = 7)
centers_ca(sca_SndT_Fra$pos1, clusters = kcl_SndT_Fra, freq = freq_ca(SndT_Fra[, 1]))
</code></pre>

<hr>
<h2 id='complete_pvpick'>Complete the Output of <code>pvpick</code></h2><span id='topic+complete_pvpick'></span>

<h3>Description</h3>

<p>A helper function to add the missing singleton clusters in the output of <code>pvpick</code> (from the package <span class="pkg">pvclust</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_pvpick(clusters, labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete_pvpick_+3A_clusters">clusters</code></td>
<td>
<p>A clustering by a call to <code>pvpick</code>.</p>
</td></tr>
<tr><td><code id="complete_pvpick_+3A_labels">labels</code></td>
<td>
<p>A character vector containing the exhaustive set of levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the singleton clusters inserted at the end (so that the set of clusters is exhaustive).
</p>

<hr>
<h2 id='Ctxt_Dut.txt'>Context Words for seventeen Dutch Words</h2><span id='topic+Ctxt_Dut.txt'></span>

<h3>Description</h3>

<p>The frequency table of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their context words (from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A table with 17 rows and 1404 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ctxt_Dut &lt;- read.table(system.file("extdata", "Ctxt_Dut.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8")
sca_Ctxt_Dut &lt;- fast_sca(data.matrix(Ctxt_Dut))
sca_Ctxt_Dut
lsa_Ctxt_Dut &lt;- fast_lsa(data.matrix(Ctxt_Dut))
lsa_Ctxt_Dut
</code></pre>

<hr>
<h2 id='Ctxt_Eng.txt'>Context Words for seventeen Dutch Words Translated from French</h2><span id='topic+Ctxt_Eng.txt'></span>

<h3>Description</h3>

<p>The frequency table of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their context words in texts translated from English
(from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A table with 17 rows and 609 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ctxt_Eng &lt;- read.table(system.file("extdata", "Ctxt_Eng.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8")
sca_Ctxt_Eng &lt;- fast_sca(data.matrix(Ctxt_Eng))
sca_Ctxt_Eng
lsa_Ctxt_Eng &lt;- fast_lsa(data.matrix(Ctxt_Eng))
lsa_Ctxt_Eng
</code></pre>

<hr>
<h2 id='Ctxt_Fra.txt'>Context Words for seventeen Dutch Words Translated from French</h2><span id='topic+Ctxt_Fra.txt'></span>

<h3>Description</h3>

<p>The frequency table of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their context words in texts translated from French
(from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A table with 17 rows and 612 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ctxt_Fra &lt;- read.table(system.file("extdata", "Ctxt_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8")
sca_Ctxt_Fra &lt;- fast_sca(data.matrix(Ctxt_Fra))
sca_Ctxt_Fra
lsa_Ctxt_Fra &lt;- fast_lsa(data.matrix(Ctxt_Fra))
lsa_Ctxt_Fra
</code></pre>

<hr>
<h2 id='dat2ddc'>Transform a Data Frame into a Double-Coded Matrix</h2><span id='topic+dat2ddc'></span><span id='topic+dat2dc'></span>

<h3>Description</h3>

<p>A helper function for transforming all columns of a data frame into a double-coded matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat2ddc(dat, limits = NULL)

dat2dc(dat, limits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dat2ddc_+3A_dat">dat</code></td>
<td>
<p>A data frame containing only numeric vectors or ordered factors as columns.</p>
</td></tr>
<tr><td><code id="dat2ddc_+3A_limits">limits</code></td>
<td>
<p>A vector, matrix or list specifying the lower and upper limits for the columns in <code>dat</code>. A single vector of length two applies the same limits to all columns. The matrix or list must either have the same number of columns/components as the number of the number of columns in <code>dat</code> or they must have names. The names can be a subset of the column names of <code>dat</code>. In any case, the limits for each column must be a vector of length two, i.e. the matrix must have two rows or each list component should be a vector of length two. If left unspecified (the default), then the minimum and maximum of each column in <code>dat</code> will be taken as (separate) limits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with doubly-coded columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vec2ddc">vec2ddc</a></code>.
</p>

<hr>
<h2 id='dat2ind'>Transform a Data Frame into an Indicator Matrix</h2><span id='topic+dat2ind'></span>

<h3>Description</h3>

<p>A helper function for transforming a data frame into an indicator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat2ind(dat, add_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dat2ind_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="dat2ind_+3A_add_names">add_names</code></td>
<td>
<p>Logical specifying whether to add rownames to the resulting indicator matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An indicator matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vec2ind">vec2ind</a></code>.
</p>

<hr>
<h2 id='dist_chisquare'>Compute Chi-square Distances</h2><span id='topic+dist_chisquare'></span><span id='topic+dist_chisq'></span>

<h3>Description</h3>

<p>A function for computing chi-square distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_chisquare(x, diag = FALSE, upper = FALSE)

dist_chisq(x, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_chisquare_+3A_x">x</code></td>
<td>
<p>A numeric matrix (containing coordinates).</p>
</td></tr>
<tr><td><code id="dist_chisquare_+3A_diag">diag</code></td>
<td>
<p>Logical specifying whether the diagonal of the resulting distance matrix should be printed.</p>
</td></tr>
<tr><td><code id="dist_chisquare_+3A_upper">upper</code></td>
<td>
<p>Logical specifying whether the upper triangle of the resulting distance matrix should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
dist_chisquare(tab_SndT_Fra)
</code></pre>

<hr>
<h2 id='dist_cosine'>Compute Cosine Distances</h2><span id='topic+dist_cosine'></span><span id='topic+dist_cos'></span>

<h3>Description</h3>

<p>A function for computing cosine distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_cosine(x, diag = FALSE, upper = FALSE)

dist_cos(x, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_cosine_+3A_x">x</code></td>
<td>
<p>A numeric matrix (containing coordinates).</p>
</td></tr>
<tr><td><code id="dist_cosine_+3A_diag">diag</code></td>
<td>
<p>Logical specifying whether the diagonal of the resulting distance matrix should be printed.</p>
</td></tr>
<tr><td><code id="dist_cosine_+3A_upper">upper</code></td>
<td>
<p>Logical specifying whether the upper triangle of the resulting distance matrix should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cosine distance equals 1 - the cosine similarity.
</p>


<h3>Value</h3>

<p>A distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
lsa_SndT_Fra &lt;- fast_lsa(SndT_Fra)
dist_cosine(lsa_SndT_Fra$pos1[, 1:7])
</code></pre>

<hr>
<h2 id='dist_wrt'>Compute Distances with respect to a certain Point</h2><span id='topic+dist_wrt'></span>

<h3>Description</h3>

<p>A function for computing (euclidean) distances with respect to a certain specified point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_wrt(x, wrt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_wrt_+3A_x">x</code></td>
<td>
<p>A numeric matrix (containing coordinates).</p>
</td></tr>
<tr><td><code id="dist_wrt_+3A_wrt">wrt</code></td>
<td>
<p>A specification of the point with respect to which to compute all distances: can be either a vector or
the character label of one of the row levels in <code>x</code>. If <code>NULL</code> or <code>NA</code>, then the origin (i.e.
the point <code>c(0 , 0, 0,... )</code>) is taken as the value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (containing distances between the rows of <code>x</code> and <code>wrt</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
dist_wrt(sca_SndT_Fra$pos1, wrt = "beginnen")
</code></pre>

<hr>
<h2 id='dist_wrt_centers'>Compute Distances with respect to Cluster Centers</h2><span id='topic+dist_wrt_centers'></span>

<h3>Description</h3>

<p>A function for computing (euclidean) distances with respect to specified cluster centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_wrt_centers(x, clusters, freq = NULL, members_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_wrt_centers_+3A_x">x</code></td>
<td>
<p>A numeric matrix (containing coordinates).</p>
</td></tr>
<tr><td><code id="dist_wrt_centers_+3A_clusters">clusters</code></td>
<td>
<p>A clustering of the row levels of <code>x</code>: either a list or the output of <code>kmeans</code>.</p>
</td></tr>
<tr><td><code id="dist_wrt_centers_+3A_freq">freq</code></td>
<td>
<p>An optional vector of frequency counts for the row levels of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dist_wrt_centers_+3A_members_only">members_only</code></td>
<td>
<p>Logical specifying whether the distances from the cluster centers should only be computed for
the cluster members.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a matrix of distances for every cluster.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centers_ca">centers_ca</a></code>, <code><a href="#topic+freq_ca">freq_ca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
kcl_SndT_Fra &lt;- kmeans(sca_SndT_Fra$pos1, centers = 7)
dist_wrt_centers(sca_SndT_Fra$pos1, clusters = kcl_SndT_Fra, freq = freq_ca(SndT_Fra[, 1]))
</code></pre>

<hr>
<h2 id='fast_dca'>Discriminant Correspondence Analysis</h2><span id='topic+fast_dca'></span>

<h3>Description</h3>

<p>A fast procedure for computing discriminant correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_dca(dat, clusters1 = NULL, clusters2 = NULL, members = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_dca_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_dca_+3A_clusters1">clusters1</code></td>
<td>
<p>A clustering of the first set of levels: either a list or the output of <code>kmeans</code>.</p>
</td></tr>
<tr><td><code id="fast_dca_+3A_clusters2">clusters2</code></td>
<td>
<p>A clustering of the second set of levels: either a list or the output of <code>kmeans</code>.</p>
</td></tr>
<tr><td><code id="fast_dca_+3A_members">members</code></td>
<td>
<p>Logical indicating whether the (supplementary) coordinates for the individual levels should also be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>The eigenvalues or principal inertias, indicating how much each latent axis explains.</p>
</td></tr>
<tr><td><code>cen1</code></td>
<td>
<p>The coordinates of the cluster centers for the first set of levels.</p>
</td></tr>
<tr><td><code>cen2</code></td>
<td>
<p>The coordinates of the cluster centers for the second set of levels.</p>
</td></tr>
<tr><td><code>mem1</code></td>
<td>
<p>If <code>members = TRUE</code>: The coordinates of the first set of individual levels.</p>
</td></tr>
<tr><td><code>mem2</code></td>
<td>
<p>If <code>members = TRUE</code>: The coordinates of the second set of individual levels.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abdi, H. (2007) Discriminant correspondence analysis. In: N. Salkind (ed.) <em>Encyclopedia of measurement and statistics</em>. Thousand Oaks: SAGE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
kcl_SndT_Fra &lt;- kmeans(sca_SndT_Fra$pos1, centers = 7)
dca_SndT_Fra &lt;- fast_dca(SndT_Fra, clusters1 = kcl_SndT_Fra)
dca_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_E_M'>EM clustering</h2><span id='topic+fast_E_M'></span><span id='topic+fast_EM'></span>

<h3>Description</h3>

<p>A fast procedure for Expectation-Maximization clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_E_M(dat, k, tol = 1e-08)

fast_EM(dat, k, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_E_M_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_E_M_+3A_k">k</code></td>
<td>
<p>Numeric specification of the number of latent classes to compute.</p>
</td></tr>
<tr><td><code id="fast_E_M_+3A_tol">tol</code></td>
<td>
<p>Numeric specification of the convergence criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the rows of a frequency table come from a multinomial distribution. The prior probabilities of
the latent classes are initialized with a Dirichlet distribution (by means of <code>rdirichlet</code> from the package <span class="pkg">gtools</span>) with
<code>alpha =</code> the total frequency counts of every level.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>prob0</code></td>
<td>
<p>The probabilities of the latent classes.</p>
</td></tr>
<tr><td><code>prob1</code></td>
<td>
<p>The probabilities for the first set of levels (<em>viz.</em> the row levels of a frequency table). The rows of <code>prob1</code> sum to 1.</p>
</td></tr>
<tr><td><code>prob2</code></td>
<td>
<p>The probabilities for the second set of levels (<em>viz.</em> the column levels of a frequency table). The rows of <code>prob2</code> sum to 1.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird and D. B. Rubin (1977) Maximum likelihood from incomplete data via the EM algorithm.
<em>Journal of the royal statistical society, series B</em> <strong>39</strong> (1), 1&ndash;38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
E_M_SndT_Fra &lt;- fast_E_M(SndT_Fra, k = 7)
E_M_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_lca'>Latent Class Analysis</h2><span id='topic+fast_lca'></span>

<h3>Description</h3>

<p>A fast procedure for computing latent class analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_lca(dat, k, tol = 1e-08, posterior = FALSE, transform = 1, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_lca_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame.</p>
</td></tr>
<tr><td><code id="fast_lca_+3A_k">k</code></td>
<td>
<p>Numeric specification of the number of latent classes to compute.</p>
</td></tr>
<tr><td><code id="fast_lca_+3A_tol">tol</code></td>
<td>
<p>Numeric specification of the convergence criterion.</p>
</td></tr>
<tr><td><code id="fast_lca_+3A_posterior">posterior</code></td>
<td>
<p>Logical indicating whether the posterior probabilities of the individual observations should also be returned.</p>
</td></tr>
<tr><td><code id="fast_lca_+3A_transform">transform</code></td>
<td>
<p>Numeric specification of the power transformation to be applied on the posterior distribution; see <code><a href="#topic+fast_psa">fast_psa</a></code>.</p>
</td></tr>
<tr><td><code id="fast_lca_+3A_sep">sep</code></td>
<td>
<p>Character specifying the separator string for joining the levels (if <code>posterior = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior probabilities of the latent classes are initialized with a Dirichlet distribution (by means of <code>rdirichlet</code> from
the package <span class="pkg">gtools</span>) with <code>alpha =</code> the total frequency counts of every level.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>prob0</code></td>
<td>
<p>The probabilities of the latent classes.</p>
</td></tr>
<tr><td><code>prob1-prob...</code></td>
<td>
<p>The probabilities for each set of levels. The columns of each <code>prob...</code> sum to 1.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>If <code>posterior = TRUE</code>: An indicator matrix with the posterior probabilities of each observation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Agresti, A. (2013) <em>Categorical data analysis</em>. Hoboken: John Wiley and Sons, 535&ndash;542.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
lca_SndT_Fra &lt;- fast_lca(SndT_Fra, k = 7)
lca_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_lma'>Log-Multiplicative Association Analysis</h2><span id='topic+fast_lma'></span><span id='topic+fast_rca'></span>

<h3>Description</h3>

<p>A fast procedure for computing log-multiplicative analysis, i.e. Goodman's _RC(M)_ association model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_lma(
  dat,
  k,
  weights = "marginal",
  tol = 1e-08,
  base = exp(1),
  init = "marginal"
)

fast_rca(
  dat,
  k,
  weights = "marginal",
  tol = 1e-08,
  base = exp(1),
  init = "marginal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_lma_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame.</p>
</td></tr>
<tr><td><code id="fast_lma_+3A_k">k</code></td>
<td>
<p>Numeric specification of the number of latent axes to compute (i.e. k = M).</p>
</td></tr>
<tr><td><code id="fast_lma_+3A_weights">weights</code></td>
<td>
<p>Character specification of the weights applied to standardize the coordinates: can be one of
<code>"marginal"</code>, <code>"uniform"</code>, <code>"unit"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="fast_lma_+3A_tol">tol</code></td>
<td>
<p>Numeric specification of the convergence criterion.</p>
</td></tr>
<tr><td><code id="fast_lma_+3A_base">base</code></td>
<td>
<p>Numeric specification of the base with respect to which logarithms are computed.</p>
</td></tr>
<tr><td><code id="fast_lma_+3A_init">init</code></td>
<td>
<p>Character specification of the initialization scheme for the marginal parameters: can be either
<code>"kateri"</code> or <code>"marginal"</code>. This argument may change in future versions of the <span class="pkg">svs</span> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For now (i.e. version 3.0.0 of the <span class="pkg">svs</span> package), the data frame must have only two columns.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>mar</code></td>
<td>
<p>A list with marginal parameters in components <code>mar1</code> and <code>mar2</code>; not so important for the analysis.</p>
</td></tr>
<tr><td><code>val</code></td>
<td>
<p>The association parameters, indicating how much association each latent axis explains.</p>
</td></tr>
<tr><td><code>pos1</code></td>
<td>
<p>The coordinates of the first set of levels (<em>viz.</em> the row levels of a frequency table).</p>
</td></tr>
<tr><td><code>pos2</code></td>
<td>
<p>The coordinates of the second set of levels (<em>viz.</em> the column levels of a frequency table).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goodman, L. A. (1979) Simple models for the analysis of association in cross-classifications having ordered categories.
<em>Journal of the American statistical association</em> <strong>74</strong> (367), 537&ndash;552.
</p>
<p>Kateri, M. (2014) <em>Contingency table analysis. Methods and implementation using R</em>. New York: Springer-Birkhauser.
</p>
<p>Wong, R. S.-K. (2010) <em>Association models</em>. Thousand Oaks: SAGE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
lma_SndT_Fra &lt;- fast_lma(SndT_Fra, k = 7)
lma_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_lra'>Logratio Analysis</h2><span id='topic+fast_lra'></span>

<h3>Description</h3>

<p>A fast procedure for computing logratio analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_lra(dat, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_lra_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_lra_+3A_base">base</code></td>
<td>
<p>Numeric specification of the base with respect to which logarithms are computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>The eigenvalues (i.e. squared singular values), indicating how much each latent axis explains.</p>
</td></tr>
<tr><td><code>pos1</code></td>
<td>
<p>The coordinates of the first set of levels (<em>viz.</em> the row levels of a frequency table).</p>
</td></tr>
<tr><td><code>pos2</code></td>
<td>
<p>The coordinates of the second set of levels (<em>viz.</em> the column levels of a frequency table).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greenacre, M. (2019) <em>Compositional data analysis in practice</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Van den Boogaart, K. G. and R. Tolosana-Delgado (2013) <em>Analyzing compositional data with R</em>. Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
lra_SndT_Fra &lt;- fast_lra(SndT_Fra)
lra_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_lsa'>Latent Semantic Analysis</h2><span id='topic+fast_lsa'></span><span id='topic+fast_lsi'></span>

<h3>Description</h3>

<p>A fast procedure for computing latent semantic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_lsa(dat, local_weights = "log", global_weights = "idf")

fast_lsi(dat, local_weights = "log", global_weights = "idf")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_lsa_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_lsa_+3A_local_weights">local_weights</code></td>
<td>
<p>Character specification of the local weighting function (without a prefix): see
<a href="#topic+weighting_functions">Weighting functions</a>.</p>
</td></tr>
<tr><td><code id="fast_lsa_+3A_global_weights">global_weights</code></td>
<td>
<p>Character specification of the global weighting function (without a prefix): see
<a href="#topic+weighting_functions">Weighting functions</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>The singular values, indicating how much each latent axis explains.</p>
</td></tr>
<tr><td><code>pos1</code></td>
<td>
<p>The coordinates of the first set of levels (<em>viz.</em> the row levels of a frequency table).</p>
</td></tr>
<tr><td><code>pos2</code></td>
<td>
<p>The coordinates of the second set of levels (<em>viz.</em> the column levels of a frequency table).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Deerwester, S., S. T. Dumais, G. W. Furnas, Th. K. Landauer and R. Harshman (1990) Indexing by latent semantic analysis.
<em>Journal of the American society for information science</em> <strong>41</strong> (6), 391&ndash;407.
</p>
<p>Landauer, Th. K. and S. T. Dumais (1997) A solution to Plato's problem: the latent semantic analysis theory of the
acquisition, induction, and representation of knowledge. <em>Psychological review</em> <strong>104</strong>, 211&ndash;240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
lsa_SndT_Fra &lt;- fast_lsa(SndT_Fra)
lsa_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_mca'>Multiple Correspondence Analysis</h2><span id='topic+fast_mca'></span>

<h3>Description</h3>

<p>A fast procedure for computing multiple correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_mca(dat, nfac = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_mca_+3A_dat">dat</code></td>
<td>
<p>Input data: has to be a data frame (with any number of columns).</p>
</td></tr>
<tr><td><code id="fast_mca_+3A_nfac">nfac</code></td>
<td>
<p>Logical indicating whether the number of factors (i.e. the number of columns in <code>dat</code>) is a divisor for
the eigenvalues (principal inertias) and the coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>The eigenvalues or principal inertias, indicating how much each latent axis explains.</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>
<p>The coordinates of all levels.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greenacre, M. (2017) <em>Correspondence analysis in practice, Third edition</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
mca_SndT_Fra &lt;- fast_mca(SndT_Fra)
mca_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_nmf'>Non-negative Matrix Factorization</h2><span id='topic+fast_nmf'></span><span id='topic+fast_nmf_KL'></span><span id='topic+fast_nmf_Fr'></span><span id='topic+fast_nmf_Al'></span>

<h3>Description</h3>

<p>A fast procedure for non-negative matrix factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_nmf(dat, k, type = "KL", tol = 1e-08)

fast_nmf_KL(dat, k, tol = 1e-08)

fast_nmf_Fr(dat, k, tol = 1e-08)

fast_nmf_Al(dat, k, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_nmf_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_nmf_+3A_k">k</code></td>
<td>
<p>Numeric specification of the number of latent axes to compute.</p>
</td></tr>
<tr><td><code id="fast_nmf_+3A_type">type</code></td>
<td>
<p>Character specification of the type of optimization: can in the current implementation be either <code>"KL"</code> for
the Kullback-Leibler divergence, <code>"Frobenius"</code> or <code>"euclidean"</code> (or abbreviations thereof) for the euclidean distance, or
<code>"ALS"</code> for alternating least squares.</p>
</td></tr>
<tr><td><code id="fast_nmf_+3A_tol">tol</code></td>
<td>
<p>Numeric specification of the convergence criterion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>pos1</code></td>
<td>
<p>The coordinates of the first set of levels (<em>viz.</em> the row levels of a frequency table).</p>
</td></tr>
<tr><td><code>pos2</code></td>
<td>
<p>The coordinates of the second set of levels (<em>viz.</em> the column levels of a frequency table).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, D. D. and H. S. Seung (1999) Learning the parts of objects by non-negative matrix factorization. <em>Nature</em> <strong>401</strong>, 788&ndash;791.
</p>
<p>Lee, D. D. and H. S. Seung (2001) Algorithms for non-negative matrix factorization. <em>Advances in neural information processing systems</em>
<strong>13</strong>, 556&ndash;562.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
nmf_SndT_Fra &lt;- fast_nmf(SndT_Fra, k = 7)
nmf_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_psa'>Probabilistic Latent Semantic Analysis</h2><span id='topic+fast_psa'></span><span id='topic+fast_psi'></span><span id='topic+fast_plsa'></span><span id='topic+fast_plsi'></span>

<h3>Description</h3>

<p>A fast procedure for computing probabilistic latent semantic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_psa(dat, k, symmetric = FALSE, transform = 1, tol = 1e-08)

fast_psi(dat, k, symmetric = FALSE, transform = 1, tol = 1e-08)

fast_plsa(dat, k, symmetric = FALSE, transform = 1, tol = 1e-08)

fast_plsi(dat, k, symmetric = FALSE, transform = 1, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_psa_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_psa_+3A_k">k</code></td>
<td>
<p>Numeric specification of the number of latent classes to compute.</p>
</td></tr>
<tr><td><code id="fast_psa_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical indicating whether to compute the symmetric or the asymmetric solution.</p>
</td></tr>
<tr><td><code id="fast_psa_+3A_transform">transform</code></td>
<td>
<p>Numeric specification of the &quot;tempering&quot; transformation as explained in Hofmann (1999: 51-52).</p>
</td></tr>
<tr><td><code id="fast_psa_+3A_tol">tol</code></td>
<td>
<p>Numeric specification of the convergence criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From version 1.1.0 of the <span class="pkg">svs</span> package on, probabilistic latent semantic analysis is a special case of latent class analysis.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>prob0</code></td>
<td>
<p>The probabilities of the latent classes.</p>
</td></tr>
<tr><td><code>prob1</code></td>
<td>
<p>The probabilities for the first set of levels (<em>viz.</em> the row levels of a frequency table). The rows of <code>prob1</code> sum to 1 if <code>symmetric = FALSE</code>, the columns sum to 1 if <code>symmetric = TRUE</code>.</p>
</td></tr>
<tr><td><code>prob2</code></td>
<td>
<p>The probabilities for the second set of levels (<em>viz.</em> the column levels of a frequency table). The columns of <code>prob2</code> sum to 1.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hofmann, Th. (1999). Probabilistic latent semantic indexing.
<em>SIGIR'99: Proceedings of the 22nd annual international SIGIR conference on research and development in information retrieval</em>, 50&ndash;57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
psa_SndT_Fra &lt;- fast_psa(SndT_Fra, k = 7)
psa_SndT_Fra
</code></pre>

<hr>
<h2 id='fast_sca'>Simple Correspondence Analysis</h2><span id='topic+fast_sca'></span>

<h3>Description</h3>

<p>A fast procedure for computing simple correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_sca(dat, transform = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_sca_+3A_dat">dat</code></td>
<td>
<p>Input data: can be a table or a data frame (but the data frame must have only two columns).</p>
</td></tr>
<tr><td><code id="fast_sca_+3A_transform">transform</code></td>
<td>
<p>Numeric specification of the power transformation to be applied on the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>The eigenvalues or principal inertias, indicating how much each latent axis explains.</p>
</td></tr>
<tr><td><code>pos1</code></td>
<td>
<p>The coordinates of the first set of levels (<em>viz.</em> the row levels of a frequency table).</p>
</td></tr>
<tr><td><code>pos2</code></td>
<td>
<p>The coordinates of the second set of levels (<em>viz.</em> the column levels of a frequency table).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greenacre, M. (2017) <em>Correspondence analysis in practice, Third edition</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
sca_SndT_Fra
</code></pre>

<hr>
<h2 id='freq_ca'>Compute Level Frequencies (for a Factor or Vector)</h2><span id='topic+freq_ca'></span>

<h3>Description</h3>

<p>A helper function for computing the frequency of each factor level (typically used in correspondence analysis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_ca(dat, nfac = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq_ca_+3A_dat">dat</code></td>
<td>
<p>A factor, (character) vector or a data frame.</p>
</td></tr>
<tr><td><code id="freq_ca_+3A_nfac">nfac</code></td>
<td>
<p>Logical indicating whether the number of factors (i.e. the number of columns in <code>dat</code>) is a divisor for
the level frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the frequency counts of every level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
freq_ca(SndT_Fra)
</code></pre>

<hr>
<h2 id='InvT_Eng.txt'>Seventeen Dutch Target Words and their English Source Words</h2><span id='topic+InvT_Eng.txt'></span>

<h3>Description</h3>

<p>The occurrences of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their English source words (from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A data frame with 782 rows and 2 variables.
</p>

<dl>
<dt><code>source_Eng</code></dt><dd><p>The English source word.</p>
</dd>
<dt><code>target_Dut</code></dt><dd><p>The Dutch target word.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>InvT_Eng &lt;- read.table(system.file("extdata", "InvT_Eng.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_InvT_Eng &lt;- fast_sca(InvT_Eng)
sca_InvT_Eng
lsa_InvT_Eng &lt;- fast_lsa(InvT_Eng)
lsa_InvT_Eng
</code></pre>

<hr>
<h2 id='InvT_Fra.txt'>Seventeen Dutch Target Words and their French Source Words</h2><span id='topic+InvT_Fra.txt'></span>

<h3>Description</h3>

<p>The occurrences of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their French source words (from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A data frame with 856 rows and 2 variables.
</p>

<dl>
<dt><code>source_Fra</code></dt><dd><p>The French source word.</p>
</dd>
<dt><code>target_Dut</code></dt><dd><p>The Dutch target word.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>InvT_Fra &lt;- read.table(system.file("extdata", "InvT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_InvT_Fra &lt;- fast_sca(InvT_Fra)
sca_InvT_Fra
lsa_InvT_Fra &lt;- fast_lsa(InvT_Fra)
lsa_InvT_Fra
</code></pre>

<hr>
<h2 id='layout4bipartite'>Create a Layout Matrix for a Bipartite Graph</h2><span id='topic+layout4bipartite'></span><span id='topic+layout4diagram'></span>

<h3>Description</h3>

<p>A helper function for creating a layout matrix for a bipartite graph, based on the dimensions of its biadjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout4bipartite(nrow, ncol, rowsLeft = TRUE)

layout4diagram(nrow, ncol, rowsLeft = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout4bipartite_+3A_nrow">nrow</code></td>
<td>
<p>Numeric specifying the number of rows of the biadjacency matrix.</p>
</td></tr>
<tr><td><code id="layout4bipartite_+3A_ncol">ncol</code></td>
<td>
<p>Numeric specifying the number of columns of the biadjacency matrix.</p>
</td></tr>
<tr><td><code id="layout4bipartite_+3A_rowsleft">rowsLeft</code></td>
<td>
<p>Logical specifying whether the rows of the biadjacency matrix should appear to the left of the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is essentially an alternative for <code>layout_as_bipartite()</code> from the <span class="pkg">igraph</span> package.
Bipartite graphs are typically represented by a biadjacency matrix, the dimensions of which can be used for constructing the layout.
In addition, the coordinates for the vertices are somewhat different from those in <span class="pkg">igraph</span>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='log_or_0'>Logarithmic transform</h2><span id='topic+log_or_0'></span>

<h3>Description</h3>

<p>A function for computing the logarithm of every entry in a table with 0 for zero entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_or_0(x, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_or_0_+3A_x">x</code></td>
<td>
<p>A table or a (sparse) matrix.</p>
</td></tr>
<tr><td><code id="log_or_0_+3A_base">base</code></td>
<td>
<p>Numeric specification of the base with respect to which logarithms are computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the logarithm of every entry and 0 for all zero entries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
log_or_0(tab_SndT_Fra)
</code></pre>

<hr>
<h2 id='MI'>Mutual Information</h2><span id='topic+MI'></span><span id='topic+mi'></span>

<h3>Description</h3>

<p>A function for computing the mutual information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI(x, base = 2)

mi(x, base = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MI_+3A_x">x</code></td>
<td>
<p>A table or a (sparse) matrix.</p>
</td></tr>
<tr><td><code id="MI_+3A_base">base</code></td>
<td>
<p>Numeric specification of the base with respect to which logarithms are computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value containing the mutual information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmi">pmi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
MI(tab_SndT_Fra)
</code></pre>

<hr>
<h2 id='outerec'>Recursive Application of the Outer Product</h2><span id='topic+outerec'></span>

<h3>Description</h3>

<p>A helper function for computing the outer product of two or more arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outerec(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outerec_+3A_...">...</code></td>
<td>
<p>The specification of two or more arrays (separated by comma's or contained in a list).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the outer product of all the arrays specified in <code>...</code>.
</p>

<hr>
<h2 id='pc_plot'>Plotting Parallel Coordinates</h2><span id='topic+pc_plot'></span>

<h3>Description</h3>

<p>A function for plotting parallel coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_plot(
  x,
  col = "darkgrey",
  cex = 1,
  font = 1,
  family = "",
  pch = 20,
  pcol = col,
  pcex = cex,
  lcol = col,
  lwd = 1,
  lty = 1,
  acol = "black",
  alwd = 1,
  alty = 1,
  las = 1,
  add_scale = FALSE,
  main = NULL,
  sub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_plot_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_col">col</code></td>
<td>
<p>The color of the text labels, points and connecting lines: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_cex">cex</code></td>
<td>
<p>The character expansion factor: A numeric value to specify the size of the text labels and the points.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_font">font</code></td>
<td>
<p>The font of the text labels: <code>1</code> for plain, <code>2</code> for bold, <code>3</code> for italic, and <code>4</code> for bold italic.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_family">family</code></td>
<td>
<p>The font family of the text labels: <code>"serif"</code>, <code>"sans"</code>, <code>"mono"</code>, or one of the <code><a href="grDevices.html#topic+Hershey">Hershey</a></code> fonts.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_pch">pch</code></td>
<td>
<p>The plotting character for displaying points: see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_pcol">pcol</code></td>
<td>
<p>The color of the plotting character: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_pcex">pcex</code></td>
<td>
<p>The character expansion factor of the plotting character: a numeric value to specify the size of the plotting character.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_lcol">lcol</code></td>
<td>
<p>The color of the connecting lines: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_lwd">lwd</code></td>
<td>
<p>The line width of the connecting lines: a numeric value to specify the width of the connecting lines.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_lty">lty</code></td>
<td>
<p>The line type of the connecting lines: <code>0</code> or <code>"blank"</code>, <code>1</code> or <code>"solid"</code>, <code>2</code> or <code>"dashed"</code>, <code>3</code> or
<code>"dotted"</code>, <code>4</code> or <code>"dotdash"</code>, <code>5</code> or <code>"longdash"</code>, <code>6</code> or <code>"twodash"</code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_acol">acol</code></td>
<td>
<p>The color of the parallel axes: see <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_alwd">alwd</code></td>
<td>
<p>The line width of the parallel axes: a numeric value to specify the width of the parallel axes.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_alty">alty</code></td>
<td>
<p>The line type of the parallel axes: <code>0</code> or <code>"blank"</code>, <code>1</code> or <code>"solid"</code>, <code>2</code> or <code>"dashed"</code>, <code>3</code> or
<code>"dotted"</code>, <code>4</code> or <code>"dotdash"</code>, <code>5</code> or <code>"longdash"</code>, <code>6</code> or <code>"twodash"</code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_las">las</code></td>
<td>
<p>The reading direction of the labels on the axes (&quot;label axis style&quot;): either a numeric value between <code>0</code> and <code>3</code> (see <code>las</code> in
<code><a href="graphics.html#topic+par">par</a></code>), or a character value matching either <code>"horizontal"</code> or <code>"vertical"</code>.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_add_scale">add_scale</code></td>
<td>
<p>Logical specifying whether to add a scale for the parallel axes (which are normalized).</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_main">main</code></td>
<td>
<p>A character string for the main title of the plot.</p>
</td></tr>
<tr><td><code id="pc_plot_+3A_sub">sub</code></td>
<td>
<p>A character string for the subtitle of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parallel coordinate plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
pc_plot(sca_SndT_Fra$pos1, las = "vertical")
</code></pre>

<hr>
<h2 id='pmi'>Pointwise Mutual Information</h2><span id='topic+pmi'></span><span id='topic+PMI'></span>

<h3>Description</h3>

<p>A function for computing the pointwise mutual information of every entry in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmi(x, normalize = FALSE, base = 2)

PMI(x, normalize = FALSE, base = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmi_+3A_x">x</code></td>
<td>
<p>A table or a (sparse) matrix.</p>
</td></tr>
<tr><td><code id="pmi_+3A_normalize">normalize</code></td>
<td>
<p>Logical indicating whether to normalize the pointwise mutual information.</p>
</td></tr>
<tr><td><code id="pmi_+3A_base">base</code></td>
<td>
<p>Numeric specification of the base with respect to which logarithms are computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the pointwise mutual information of every entry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI">MI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
pmi(tab_SndT_Fra)
</code></pre>

<hr>
<h2 id='rep4dat'>Repeat the Rows of a Data Frame according to a Frequency Column</h2><span id='topic+rep4dat'></span>

<h3>Description</h3>

<p>A helper function for repeating the rows a data frame according to a frequency column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep4dat(dat, freqName = "Freq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rep4dat_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="rep4dat_+3A_freqname">freqName</code></td>
<td>
<p>Character specifying the name of the frequency column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
dat_SndT_Fra &lt;- as.data.frame(tab_SndT_Fra)
rep4dat(dat_SndT_Fra)
</code></pre>

<hr>
<h2 id='SndT_Eng.txt'>Seventeen Dutch Source Words and their English Translations</h2><span id='topic+SndT_Eng.txt'></span>

<h3>Description</h3>

<p>The occurrences of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their English translations (from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A data frame with 1117 rows and 2 variables.
</p>

<dl>
<dt><code>source_Dut</code></dt><dd><p>The Dutch source word.</p>
</dd>
<dt><code>target_Eng</code></dt><dd><p>The English target word.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>SndT_Eng &lt;- read.table(system.file("extdata", "SndT_Eng.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Eng &lt;- fast_sca(SndT_Eng)
sca_SndT_Eng
lsa_SndT_Eng &lt;- fast_lsa(SndT_Eng)
lsa_SndT_Eng
</code></pre>

<hr>
<h2 id='SndT_Fra.txt'>Seventeen Dutch Source Words and their French Translations</h2><span id='topic+SndT_Fra.txt'></span>

<h3>Description</h3>

<p>The occurrences of seventeen Dutch synonyms of <em>beginnen</em> (&quot;to begin&quot;) and their French translations (from the Dutch Parallel Corpus).
</p>


<h3>Format</h3>

<p>A data frame with 1487 rows and 2 variables.
</p>

<dl>
<dt><code>source_Dut</code></dt><dd><p>The Dutch source word.</p>
</dd>
<dt><code>target_Fra</code></dt><dd><p>The French target word.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
sca_SndT_Fra &lt;- fast_sca(SndT_Fra)
sca_SndT_Fra
lsa_SndT_Fra &lt;- fast_lsa(SndT_Fra)
lsa_SndT_Fra
</code></pre>

<hr>
<h2 id='tab2dat'>Transform a Table into a Data Frame</h2><span id='topic+tab2dat'></span>

<h3>Description</h3>

<p>A helper function for transforming a table into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2dat(tab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tab2dat_+3A_tab">tab</code></td>
<td>
<p>A table or (sparse) matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='tab2ind'>Transform a Table into an Indicator Matrix</h2><span id='topic+tab2ind'></span>

<h3>Description</h3>

<p>A helper function for transforming a table into an indicator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2ind(tab, add_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tab2ind_+3A_tab">tab</code></td>
<td>
<p>A table or (sparse) matrix.</p>
</td></tr>
<tr><td><code id="tab2ind_+3A_add_names">add_names</code></td>
<td>
<p>Logical specifying whether to add rownames to the resulting indicator matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An indicator matrix.
</p>

<hr>
<h2 id='vec2ddc'>Transform a Vector into a Double-Coded Matrix</h2><span id='topic+vec2ddc'></span><span id='topic+vec2dc'></span>

<h3>Description</h3>

<p>A helper function for transforming a vector into a double-coded matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2ddc(x, limits = c(NA, NA))

vec2dc(x, limits = c(NA, NA))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec2ddc_+3A_x">x</code></td>
<td>
<p>A vector, either numeric or an ordered factor.</p>
</td></tr>
<tr><td><code id="vec2ddc_+3A_limits">limits</code></td>
<td>
<p>Numeric vector of length two specifying the limits (or &quot;poles&quot;) of the underlying ordinal variable. If left unspecified (the default), then the minimum and maximum in <code>x</code> will be taken.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Double coding, also called data doubling, is a way of indicating how the values of an ordinal variable relate to the lower and upper limits of the variable. Columns <code>-</code> and <code>+</code> express how close each (observed) value is to these respective limits.
</p>


<h3>Value</h3>

<p>A matrix with column names <code>-</code> and <code>+</code>.
</p>


<h3>References</h3>

<p>Greenacre, M. (2014) Data doubling and fuzzy coding. In: J. Blasius and M. Greenacre (eds.) <em>Visualization and verbalization of data</em>. Chapman and Hall/CRC, 239&ndash;253.
Greenacre, M. (2017) <em>Correspondence analysis in practice, Third edition</em>. Boca Raton: Chapman and Hall/CRC, 201&ndash;208.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dat2ddc">dat2ddc</a></code>.
</p>

<hr>
<h2 id='vec2ind'>Transform a Vector into an Indicator Matrix</h2><span id='topic+vec2ind'></span>

<h3>Description</h3>

<p>A helper function for transforming a vector into an indicator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2ind(x, add_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec2ind_+3A_x">x</code></td>
<td>
<p>A vector (which will internally be converted to a factor).</p>
</td></tr>
<tr><td><code id="vec2ind_+3A_add_names">add_names</code></td>
<td>
<p>Logical specifying whether to add dimnames to the resulting indicator matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 2.0.x of the <code>svs</code> package, this is essentially a wrapper for 
<code>t(fac2sparse())</code> from the <span class="pkg">Matrix</span> package.
</p>


<h3>Value</h3>

<p>An indicator matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dat2ind">dat2ind</a></code>.
</p>

<hr>
<h2 id='weighting_functions'>Weighting Functions</h2><span id='topic+weighting_functions'></span><span id='topic+lw_tf'></span><span id='topic+lw_raw'></span><span id='topic+lw_log'></span><span id='topic+lw_bin'></span><span id='topic+gw_idf'></span><span id='topic+gw_idf_alt'></span><span id='topic+gw_gfidf'></span><span id='topic+gw_nor'></span><span id='topic+gw_ent'></span><span id='topic+gw_bin'></span><span id='topic+gw_raw'></span>

<h3>Description</h3>

<p>Local and global weighting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lw_tf(x)

lw_raw(x)

lw_log(x)

lw_bin(x)

gw_idf(x)

gw_idf_alt(x)

gw_gfidf(x)

gw_nor(x)

gw_ent(x)

gw_bin(x)

gw_raw(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighting_functions_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many local and global weighting functions. In this package, local weighting functions are prefixed with <code>lw_</code> and
global weighting functions with <code>gw_</code>, so users can define their own weighting functions.  
</p>
<p>Local weighting functions (i.e. weighting every cell in the matrix):
</p>

<dl>
<dt><code>lw_tf</code></dt><dd><p>Term frequency: <em>f(x) = x</em>.</p>
</dd>
<dt><code>lw_raw</code></dt><dd><p>Raw frequency, which is the same as the term frequency: <em>f(x) = x</em>.</p>
</dd>
<dt><code>lw_log</code></dt><dd><p>Logarithm: <em>f(x) = log(x + 1)</em>.</p>
</dd>
<dt><code>lw_bin</code></dt><dd><p>Binary: <em>f(x) = 1</em> if <em>x &gt; 0</em> and <em>0</em> otherwise.</p>
</dd>
</dl>

<p>Global weighting functions, weighting the columns of the matrix (hence, these weighting functions work according to expectation for
a document-term matrix, i.e. with the documents as the rows and the terms as the columns):
</p>

<dl>
<dt><code>gw_idf</code></dt><dd><p>Inverse document frequency: <em>f(x) = log( nrow(x) / n + 1)</em> where <em>n =</em> the number of rows in which the column <em>&gt;0</em>.</p>
</dd>
<dt><code>gw_idf_alt</code></dt><dd><p>Alternative definition of the inverse document frequency: <em>f(x) = log( nrow(x) / n) + 1</em> where <em>n =</em> the number of rows in which the column <em>&gt;0</em>.</p>
</dd>
<dt><code>gw_gfidf</code></dt><dd><p>Global frequency multiplied by inverse document frequency: <em>f(x) = colSums(x) / n</em> where <em>n =</em> the number of rows in which the column <em>&gt;0</em>.</p>
</dd>
<dt><code>gw_nor</code></dt><dd><p>Normal(ized) frequency: <em>f(x) = x / colSums(x^2)</em>.</p>
</dd>
<dt><code>gw_ent</code></dt><dd><p>Entropy: <em>f(x) = 1 +</em> the relative Shannon entropy.</p>
</dd>
<dt><code>gw_bin</code></dt><dd><p>Binary: <em>f(x) = 1</em>.</p>
</dd>
<dt><code>gw_raw</code></dt><dd><p>Raw, which is the same as binary: <em>f(x) = 1</em>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fast_lsa">fast_lsa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SndT_Fra &lt;- read.table(system.file("extdata", "SndT_Fra.txt", package = "svs"),
   header = TRUE, sep = "\t", quote = "\"", encoding = "UTF-8",
   stringsAsFactors = FALSE)
tab_SndT_Fra &lt;- table(SndT_Fra)
lw_log(tab_SndT_Fra)
gw_idf(tab_SndT_Fra)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
