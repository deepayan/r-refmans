<!DOCTYPE html><html lang="en"><head><title>Help for package VAJointSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VAJointSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bs_term'><p>Term for a B-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#joint_ms_format'><p>Formats the Parameter Vector</p></a></li>
<li><a href='#joint_ms_hess'><p>Computes the Hessian</p></a></li>
<li><a href='#joint_ms_lb'><p>Evaluates the Lower Bound or the Gradient of the Lower Bound</p></a></li>
<li><a href='#joint_ms_opt'><p>Optimizes the Lower Bound</p></a></li>
<li><a href='#joint_ms_profile'><p>Approximate Likelihood Ratio based Confidence Intervals</p></a></li>
<li><a href='#joint_ms_ptr'><p>Creates a joint_ms Object to Estimate a Joint Survival and Marker Model</p></a></li>
<li><a href='#joint_ms_set_vcov'><p>Sets the Covariance Parameters</p></a></li>
<li><a href='#joint_ms_start_val'><p>Quick Heuristic for the Starting Values</p></a></li>
<li><a href='#joint_ms_va_par'><p>Extracts the Variational Parameters</p></a></li>
<li><a href='#marker_term'><p>Creates Data for One Type of Marker</p></a></li>
<li><a href='#ns_term'><p>Term for a Basis Matrix for Natural Cubic Splines</p></a></li>
<li><a href='#plot_marker'><p>Plots a Markers Mean Curve with Pointwise Quantiles</p></a></li>
<li><a href='#plot_surv'><p>Plots Quantiles of the Conditional Hazards</p></a></li>
<li><a href='#poly_term'><p>Term for Orthogonal Polynomials</p></a></li>
<li><a href='#stacked_term'><p>Term for a Basis Matrix for of Different Types of Terms</p></a></li>
<li><a href='#surv_term'><p>Creates Data for One Type of Survival Outcome</p></a></li>
<li><a href='#VAJointSurv-terms'><p>Expansions in the VAJointSurv package</p></a></li>
<li><a href='#weighted_term'><p>Term for a Basis Matrix for Weighted Term</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variational Approximation for Joint Survival and Marker Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Christoffersen &lt;boennecd@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates joint marker (longitudinal) and
    survival (time-to-event) outcomes using variational approximations.
    The package supports multivariate markers allowing for
    correlated error terms and multiple types of survival outcomes which may be
    left-truncated, right-censored, and recurrent. Time-varying fixed and
    random covariate effects are supported along with non-proportional hazards.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/boennecd/VAJointSurv">https://github.com/boennecd/VAJointSurv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/boennecd/VAJointSurv/issues">https://github.com/boennecd/VAJointSurv/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen, testthat, psqn (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, splines, utils, stats, SimSurvNMarker, psqn, Matrix,
methods, lme4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), xml2, R.rsp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), survival</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-14 13:44:21 UTC; benjaminnon-work</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Christoffersen
    <a href="https://orcid.org/0000-0002-7182-1346"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Mark Clements [aut],
  Birzhan Akynkozhayev [aut],
  Antoine Savine [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-15 18:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='bs_term'>Term for a B-Spline Basis for Polynomial Splines</h2><span id='topic+bs_term'></span>

<h3>Description</h3>

<p>Term for a B-Spline Basis for Polynomial Splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs_term(
  x = numeric(),
  df = NULL,
  knots = NULL,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = range(if (use_log) log(x) else x),
  use_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bs_term_+3A_x">x</code>, <code id="bs_term_+3A_df">df</code>, <code id="bs_term_+3A_knots">knots</code>, <code id="bs_term_+3A_degree">degree</code>, <code id="bs_term_+3A_intercept">intercept</code>, <code id="bs_term_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>same as <code><a href="splines.html#topic+bs">bs</a></code>.</p>
</td></tr>
<tr><td><code id="bs_term_+3A_use_log">use_log</code></td>
<td>
<p><code>TRUE</code> if the polynomials should be in the log of the
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list like <code><a href="splines.html#topic+bs">bs</a></code> with an additional element called <code>eval</code>
to evaluate the basis. See <code><a href="#topic+VAJointSurv-terms">VAJointSurv-terms</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poly_term">poly_term</a></code>, <code><a href="#topic+ns_term">ns_term</a></code>, <code><a href="#topic+weighted_term">weighted_term</a></code>,
and <code><a href="#topic+stacked_term">stacked_term</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(0.41, 0.29, 0.44, 0.1, 0.18, 0.65, 0.29, 0.85, 0.36, 0.47)
spline_basis &lt;- bs_term(vals,df = 3)
# evaluate spline basis at 0.5
spline_basis$eval(0.5)
# evaluate first derivative of spline basis at 0.5
spline_basis$eval(0.5, der = 1)
</code></pre>

<hr>
<h2 id='joint_ms_format'>Formats the Parameter Vector</h2><span id='topic+joint_ms_format'></span>

<h3>Description</h3>

<p>Formats a parameter vector by putting the model parameters into a <code>list</code>
with elements for each type of parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_format(object, par = object$start_val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_format_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_format_+3A_par">par</code></td>
<td>
<p>parameter vector to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>markers</code></td>
<td>
<p>list with an element for each marker. The lists contains an
element called <code>fixef</code> for non-time-varying fixed effects and an
element called <code>fixef_vary</code> time-varying fixed effects.</p>
</td></tr>
<tr><td><code>survival</code></td>
<td>
<p>list with an element for each survival outcome. The lists
contains an element called <code>fixef</code> for non-time-varying fixed effects,
an element called <code>fixef_vary</code> time-varying fixed effects, and an
element called <code>associations</code> for the association parameters.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>contains three covariance matrices called <code>vcov_marker</code>,
<code>vcov_vary</code> and <code>vcov_surv</code> for the covariance matrix of the
markers error term, the time-varying random effects, and the frailties,
respectively.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# format the starting values
joint_ms_format(model_ptr,start_vals)
</code></pre>

<hr>
<h2 id='joint_ms_hess'>Computes the Hessian</h2><span id='topic+joint_ms_hess'></span>

<h3>Description</h3>

<p>Computes the Hessian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_hess(
  object,
  par,
  quad_rule = object$quad_rule,
  cache_expansions = object$cache_expansions,
  eps = 1e-04,
  scale = 2,
  tol = .Machine$double.eps^(3/5),
  order = 4L,
  gh_quad_rule = object$gh_quad_rule
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_hess_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_hess_+3A_par">par</code></td>
<td>
<p>parameter vector for where the lower bound is evaluated at.</p>
</td></tr>
<tr><td><code id="joint_ms_hess_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_hess_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_hess_+3A_eps">eps</code>, <code id="joint_ms_hess_+3A_scale">scale</code>, <code id="joint_ms_hess_+3A_tol">tol</code>, <code id="joint_ms_hess_+3A_order">order</code></td>
<td>
<p>parameter to pass to psqn. See
<code><a href="psqn.html#topic+psqn_hess">psqn_hess</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_hess_+3A_gh_quad_rule">gh_quad_rule</code></td>
<td>
<p>list with two numeric vectors called node and weight
with Gauss–Hermite quadrature nodes and weights to handle delayed entry.
A low number of quadrature nodes and weights is used when <code>NULL</code> is
passed.
This seems to work well when delayed entry happens at time with large
marginal survival probabilities. The nodes and weights can be obtained e.g.
from <code>fastGHQuad::gaussHermiteData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following two Hessian matrices:
</p>
<table role = "presentation">
<tr><td><code>hessian</code></td>
<td>
<p>Hessian matrix of the model parameters with the
variational parameters profiled out.</p>
</td></tr>
<tr><td><code>hessian_all</code></td>
<td>
<p>Hessian matrix of the model and variational parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# optimize lower bound
fit &lt;- joint_ms_opt(object = model_ptr, par = start_vals, gr_tol = .01)

# compute the Hessian
hess &lt;- joint_ms_hess(object = model_ptr,par = fit$par)

# standard errors of the parameters
library(Matrix)
sqrt(diag(solve(hess$hessian))) 
</code></pre>

<hr>
<h2 id='joint_ms_lb'>Evaluates the Lower Bound or the Gradient of the Lower Bound</h2><span id='topic+joint_ms_lb'></span><span id='topic+joint_ms_lb_gr'></span>

<h3>Description</h3>

<p>Evaluates the Lower Bound or the Gradient of the Lower Bound
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_lb(
  object,
  par,
  n_threads = object$max_threads,
  quad_rule = object$quad_rule,
  cache_expansions = object$cache_expansions,
  gh_quad_rule = object$gh_quad_rule
)

joint_ms_lb_gr(
  object,
  par,
  n_threads = object$max_threads,
  quad_rule = object$quad_rule,
  cache_expansions = object$cache_expansions,
  gh_quad_rule = object$gh_quad_rule
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_lb_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_lb_+3A_par">par</code></td>
<td>
<p>parameter vector for where the lower bound is evaluated at.</p>
</td></tr>
<tr><td><code id="joint_ms_lb_+3A_n_threads">n_threads</code></td>
<td>
<p>number of threads to use. This is not supported on Windows.</p>
</td></tr>
<tr><td><code id="joint_ms_lb_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_lb_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_lb_+3A_gh_quad_rule">gh_quad_rule</code></td>
<td>
<p>list with two numeric vectors called node and weight
with Gauss–Hermite quadrature nodes and weights to handle delayed entry.
A low number of quadrature nodes and weights is used when <code>NULL</code> is
passed.
This seems to work well when delayed entry happens at time with large
marginal survival probabilities. The nodes and weights can be obtained e.g.
from <code>fastGHQuad::gaussHermiteData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>joint_ms_lb</code> returns a number scalar with the lower bound.
</p>
<p><code>joint_ms_lb_gr</code> returns a numeric vector with the gradient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# same lower bound
all.equal(attr(start_vals,"value"),joint_ms_lb(model_ptr,par = start_vals))
</code></pre>

<hr>
<h2 id='joint_ms_opt'>Optimizes the Lower Bound</h2><span id='topic+joint_ms_opt'></span>

<h3>Description</h3>

<p>Optimizes the Lower Bound
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_opt(
  object,
  par = object$start_val,
  rel_eps = 1e-08,
  max_it = 1000L,
  n_threads = object$max_threads,
  c1 = 1e-04,
  c2 = 0.9,
  use_bfgs = TRUE,
  trace = 0L,
  cg_tol = 0.5,
  strong_wolfe = TRUE,
  max_cg = 0L,
  pre_method = 3L,
  quad_rule = object$quad_rule,
  mask = integer(),
  cache_expansions = object$cache_expansions,
  gr_tol = -1,
  gh_quad_rule = object$gh_quad_rule
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_opt_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_par">par</code></td>
<td>
<p>starting value.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_rel_eps">rel_eps</code>, <code id="joint_ms_opt_+3A_max_it">max_it</code>, <code id="joint_ms_opt_+3A_c1">c1</code>, <code id="joint_ms_opt_+3A_c2">c2</code>, <code id="joint_ms_opt_+3A_use_bfgs">use_bfgs</code>, <code id="joint_ms_opt_+3A_trace">trace</code>, <code id="joint_ms_opt_+3A_cg_tol">cg_tol</code>, <code id="joint_ms_opt_+3A_strong_wolfe">strong_wolfe</code>, <code id="joint_ms_opt_+3A_max_cg">max_cg</code>, <code id="joint_ms_opt_+3A_pre_method">pre_method</code>, <code id="joint_ms_opt_+3A_mask">mask</code>, <code id="joint_ms_opt_+3A_gr_tol">gr_tol</code></td>
<td>
<p>arguments to pass to the C++ version of <code><a href="psqn.html#topic+psqn">psqn</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_n_threads">n_threads</code></td>
<td>
<p>number of threads to use. This is not supported on Windows.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_opt_+3A_gh_quad_rule">gh_quad_rule</code></td>
<td>
<p>list with two numeric vectors called node and weight
with Gauss–Hermite quadrature nodes and weights to handle delayed entry.
A low number of quadrature nodes and weights is used when <code>NULL</code> is
passed.
This seems to work well when delayed entry happens at time with large
marginal survival probabilities. The nodes and weights can be obtained e.g.
from <code>fastGHQuad::gaussHermiteData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>numeric vector of estimated model parameters.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>numeric scalar with the value of optimized lower bound.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>integer vector with the function counts and the number
of conjugate gradient iterations. See <code><a href="psqn.html#topic+psqn">psqn</a></code>.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>logical for whether the optimization converged.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# optimize lower bound
fit &lt;- joint_ms_opt(object = model_ptr, par = start_vals, gr_tol = .01)

# formatted maximum likelihood estimators
joint_ms_format(model_ptr, fit$par)
</code></pre>

<hr>
<h2 id='joint_ms_profile'>Approximate Likelihood Ratio based Confidence Intervals</h2><span id='topic+joint_ms_profile'></span>

<h3>Description</h3>

<p>Approximate Likelihood Ratio based Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_profile(
  object,
  opt_out,
  which_prof,
  delta,
  level = 0.95,
  max_step = 15L,
  rel_eps = 1e-08,
  max_it = 1000L,
  n_threads = object$max_threads,
  c1 = 1e-04,
  c2 = 0.9,
  use_bfgs = TRUE,
  trace = 0L,
  cg_tol = 0.5,
  strong_wolfe = TRUE,
  max_cg = 0L,
  pre_method = 3L,
  quad_rule = object$quad_rule,
  verbose = TRUE,
  mask = integer(),
  cache_expansions = object$cache_expansions,
  gr_tol = -1,
  hess = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_profile_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_opt_out">opt_out</code></td>
<td>
<p>maximum lower bound estimator from <code><a href="#topic+joint_ms_opt">joint_ms_opt</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_which_prof">which_prof</code></td>
<td>
<p>index of the parameter to profile.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_delta">delta</code></td>
<td>
<p>numeric scalar greater than zero for the initial step size.
Steps are made of size <code>2^(iteration - 1) * delta</code>. A guess of the
standard deviation is a good value.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_max_step">max_step</code></td>
<td>
<p>maximum number of steps to take in each direction when
constructing the approximate profile likelihood curve.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_rel_eps">rel_eps</code>, <code id="joint_ms_profile_+3A_max_it">max_it</code>, <code id="joint_ms_profile_+3A_c1">c1</code>, <code id="joint_ms_profile_+3A_c2">c2</code>, <code id="joint_ms_profile_+3A_use_bfgs">use_bfgs</code>, <code id="joint_ms_profile_+3A_trace">trace</code>, <code id="joint_ms_profile_+3A_cg_tol">cg_tol</code>, <code id="joint_ms_profile_+3A_strong_wolfe">strong_wolfe</code>, <code id="joint_ms_profile_+3A_max_cg">max_cg</code>, <code id="joint_ms_profile_+3A_pre_method">pre_method</code>, <code id="joint_ms_profile_+3A_mask">mask</code>, <code id="joint_ms_profile_+3A_gr_tol">gr_tol</code></td>
<td>
<p>arguments to pass to the C++ version of <code><a href="psqn.html#topic+psqn">psqn</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_n_threads">n_threads</code></td>
<td>
<p>number of threads to use. This is not supported on Windows.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_verbose">verbose</code></td>
<td>
<p>logical for whether to print output during the construction
of the approximate profile likelihood curve.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_profile_+3A_hess">hess</code></td>
<td>
<p>the Hessian from <code><a href="#topic+joint_ms_hess">joint_ms_hess</a></code>. It is used to get
better starting values along the profile likelihood curve. Use <code>NULL</code>
if it is not passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>confs</code></td>
<td>
<p>profile likelihood based confidence interval.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>the value of the parameter at which the profile likelihood is evaluated at.</p>
</td></tr>
<tr><td><code>p_log_Lik</code></td>
<td>
<p>numeric scalar with the profile log-likelihood.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>list of lists of the output of each point where the profile
likelihood is evaluated with the optimal parameter values of the
other parameters given the
constrained value of the parameter that is being profiled and
the optimal value of the lower bound.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> # load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))


# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# optimize lower bound
fit &lt;- joint_ms_opt(object = model_ptr, par = start_vals, gr_tol = .01)

# compute the Hessian
hess &lt;- joint_ms_hess(object = model_ptr,par = fit$par)

# compute the standard errors
library(Matrix)
se &lt;- sqrt(diag(solve(hess$hessian)))

# find index for the first association parameter
which_prof &lt;- model_ptr$indices$survival[[1]]$associations[1]

# initial step size for finding the confidence interval limits
delta &lt;- 2*se[which_prof]

# compute profile likelihood based confidence interval
# for the first association parameter
profile_CI &lt;- joint_ms_profile(
  object = model_ptr, opt_out = fit, which_prof = which_prof,
  delta= delta, gr_tol = .01)

# comparison of CIs
profile_CI$confs
fit$par[which_prof]+c(-1,1)*qnorm(0.975)*se[which_prof] 
</code></pre>

<hr>
<h2 id='joint_ms_ptr'>Creates a joint_ms Object to Estimate a Joint Survival and Marker Model</h2><span id='topic+joint_ms_ptr'></span>

<h3>Description</h3>

<p>Creates a joint_ms Object to Estimate a Joint Survival and Marker Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_ptr(
  markers = list(),
  survival_terms = list(),
  max_threads = 1L,
  quad_rule = NULL,
  cache_expansions = TRUE,
  gh_quad_rule = NULL,
  ders = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_ptr_+3A_markers">markers</code></td>
<td>
<p>either an object from <code><a href="#topic+marker_term">marker_term</a></code> or a list
of such objects.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_survival_terms">survival_terms</code></td>
<td>
<p>either an object from <code><a href="#topic+surv_term">surv_term</a></code> or a list
of such objects.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_max_threads">max_threads</code></td>
<td>
<p>maximum number of threads to use.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_gh_quad_rule">gh_quad_rule</code></td>
<td>
<p>list with two numeric vectors called node and weight
with Gauss–Hermite quadrature nodes and weights to handle delayed entry.
A low number of quadrature nodes and weights is used when <code>NULL</code> is
passed.
This seems to work well when delayed entry happens at time with large
marginal survival probabilities. The nodes and weights can be obtained e.g.
from <code>fastGHQuad::gaussHermiteData</code>.</p>
</td></tr>
<tr><td><code id="joint_ms_ptr_+3A_ders">ders</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+list">list</a></code>s with
<code><a href="base.html#topic+integer">integer</a></code> vectors for how
the survival outcomes are linked to the markers. 0 implies present values,
-1 is integral of, and 1 is the derivative. <code>NULL</code> implies the present
value of the random effect for all markers. Note that the number of integer
vectors should be equal to the number of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>joint_ms</code> class with the needed C++ and R objects
to estimate the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint_ms_opt">joint_ms_opt</a></code>, <code><a href="#topic+joint_ms_lb">joint_ms_lb</a></code>,
<code><a href="#topic+joint_ms_hess">joint_ms_hess</a></code>, and <code><a href="#topic+joint_ms_start_val">joint_ms_start_val</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L)
</code></pre>

<hr>
<h2 id='joint_ms_set_vcov'>Sets the Covariance Parameters</h2><span id='topic+joint_ms_set_vcov'></span>

<h3>Description</h3>

<p>Sets the covariance matrices to the passed values. The function also sets
covariance matrices for the variational distributions to the same values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_set_vcov(
  object,
  vcov_vary,
  vcov_surv,
  par = object$start_val,
  va_mean = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_set_vcov_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_set_vcov_+3A_vcov_vary">vcov_vary</code></td>
<td>
<p>the covariance matrix for the time-varying effects.</p>
</td></tr>
<tr><td><code id="joint_ms_set_vcov_+3A_vcov_surv">vcov_surv</code></td>
<td>
<p>the covariance matrix for the frailties.</p>
</td></tr>
<tr><td><code id="joint_ms_set_vcov_+3A_par">par</code></td>
<td>
<p>parameter vector to be formatted.</p>
</td></tr>
<tr><td><code id="joint_ms_set_vcov_+3A_va_mean">va_mean</code></td>
<td>
<p>a matrix with the number of rows equal to the number of
random effects per observation and the number of columns is the number
of observations. The order for the observations needs to be the same as the
<code>id</code> element of <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# compute var-covar matrices with the first set of starting values
joint_ms_format(object = model_ptr)$vcov
joint_ms_va_par(object = model_ptr)[[1]]

# altering var-covar matrices
alter_pars &lt;- joint_ms_set_vcov(
  object = model_ptr,
  vcov_vary = diag(1:4),
  vcov_surv = matrix(0,0,0))

# altered var-covar matrices
joint_ms_format(object = model_ptr, par = alter_pars)$vcov
joint_ms_va_par(object = model_ptr, par = alter_pars)[[1]]
</code></pre>

<hr>
<h2 id='joint_ms_start_val'>Quick Heuristic for the Starting Values</h2><span id='topic+joint_ms_start_val'></span>

<h3>Description</h3>

<p>Quick Heuristic for the Starting Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_start_val(
  object,
  par = object$start_val,
  rel_eps = 1e-08,
  max_it = 1000L,
  n_threads = object$max_threads,
  c1 = 1e-04,
  c2 = 0.9,
  use_bfgs = TRUE,
  trace = 0,
  cg_tol = 0.5,
  strong_wolfe = TRUE,
  max_cg = 0,
  pre_method = 3L,
  quad_rule = object$quad_rule,
  mask = integer(),
  cache_expansions = object$cache_expansions,
  gr_tol = -1,
  gh_quad_rule = object$gh_quad_rule
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_start_val_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_par">par</code></td>
<td>
<p>starting value.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_rel_eps">rel_eps</code>, <code id="joint_ms_start_val_+3A_max_it">max_it</code>, <code id="joint_ms_start_val_+3A_c1">c1</code>, <code id="joint_ms_start_val_+3A_c2">c2</code>, <code id="joint_ms_start_val_+3A_use_bfgs">use_bfgs</code>, <code id="joint_ms_start_val_+3A_trace">trace</code>, <code id="joint_ms_start_val_+3A_cg_tol">cg_tol</code>, <code id="joint_ms_start_val_+3A_strong_wolfe">strong_wolfe</code>, <code id="joint_ms_start_val_+3A_max_cg">max_cg</code>, <code id="joint_ms_start_val_+3A_pre_method">pre_method</code>, <code id="joint_ms_start_val_+3A_mask">mask</code>, <code id="joint_ms_start_val_+3A_gr_tol">gr_tol</code></td>
<td>
<p>arguments to pass to the C++ version of <code><a href="psqn.html#topic+psqn">psqn</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_n_threads">n_threads</code></td>
<td>
<p>number of threads to use. This is not supported on Windows.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_quad_rule">quad_rule</code></td>
<td>
<p>list with nodes and weights for a quadrature rule for the
integral from zero to one.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_cache_expansions">cache_expansions</code></td>
<td>
<p><code>TRUE</code> if the expansions in the numerical
integration in the survival parts of the lower bound should be cached (not
recomputed). This requires more memory and may be an advantage
particularly with
expansions that take longer to compute (like <code><a href="#topic+ns_term">ns_term</a></code> and
<code><a href="#topic+bs_term">bs_term</a></code>). The computation time may be worse particularly if
you use more threads as the CPU cache is not well utilized.</p>
</td></tr>
<tr><td><code id="joint_ms_start_val_+3A_gh_quad_rule">gh_quad_rule</code></td>
<td>
<p>list with two numeric vectors called node and weight
with Gauss–Hermite quadrature nodes and weights to handle delayed entry.
A low number of quadrature nodes and weights is used when <code>NULL</code> is
passed.
This seems to work well when delayed entry happens at time with large
marginal survival probabilities. The nodes and weights can be obtained e.g.
from <code>fastGHQuad::gaussHermiteData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of starting values for the model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

</code></pre>

<hr>
<h2 id='joint_ms_va_par'>Extracts the Variational Parameters</h2><span id='topic+joint_ms_va_par'></span>

<h3>Description</h3>

<p>Computes the estimated variational parameters for each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_ms_va_par(object, par = object$start_val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_ms_va_par_+3A_object">object</code></td>
<td>
<p>a joint_ms object from <code><a href="#topic+joint_ms_ptr">joint_ms_ptr</a></code>.</p>
</td></tr>
<tr><td><code id="joint_ms_va_par_+3A_par">par</code></td>
<td>
<p>parameter vector to be formatted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one list for each individual with the estimated mean and
covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# create the C++ object to do the fitting
model_ptr &lt;- joint_ms_ptr(
  markers = list(m1, m2), survival_terms = s_term,
  max_threads = 2L, ders = list(0L, c(0L, -1L)))

# find the starting values
start_vals &lt;- joint_ms_start_val(model_ptr)

# extract variational parameters for each individual
VA_pars &lt;- joint_ms_va_par(object = model_ptr,par = start_vals)

# number of sets of variational parameters is equal to the number of subjects
length(VA_pars)
length(unique(pbc$id))

# mean and var-covar matrix for 1st individual
VA_pars[[1]]
</code></pre>

<hr>
<h2 id='marker_term'>Creates Data for One Type of Marker</h2><span id='topic+marker_term'></span>

<h3>Description</h3>

<p>Creates Data for One Type of Marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_term(formula, id, data, time_fixef, time_rng)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marker_term_+3A_formula">formula</code></td>
<td>
<p>a two-sided <code><a href="stats.html#topic+formula">formula</a></code> with the marker outcome
on the left-hand side and fixed effect covariates on the right-hand
side.</p>
</td></tr>
<tr><td><code id="marker_term_+3A_id">id</code></td>
<td>
<p>the variable for the id of each individual.</p>
</td></tr>
<tr><td><code id="marker_term_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or environment to look at up the
variables in.</p>
</td></tr>
<tr><td><code id="marker_term_+3A_time_fixef">time_fixef</code></td>
<td>
<p>the time-varying fixed effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>.</p>
</td></tr>
<tr><td><code id="marker_term_+3A_time_rng">time_rng</code></td>
<td>
<p>the time-varying random effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_fixef</code> should likely not include an intercept as this is
often included in <code>formula</code>. Use
<code>poly_term(degree = 0, raw = TRUE, intercept = TRUE)</code> if you want only
a random intercept.
</p>


<h3>Value</h3>

<p>An object of class <code>marker_term</code> containing longitudinal data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
</code></pre>

<hr>
<h2 id='ns_term'>Term for a Basis Matrix for Natural Cubic Splines</h2><span id='topic+ns_term'></span>

<h3>Description</h3>

<p>Term for a Basis Matrix for Natural Cubic Splines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns_term(
  x = numeric(),
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = range(if (use_log) log(x) else x),
  use_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ns_term_+3A_x">x</code>, <code id="ns_term_+3A_df">df</code>, <code id="ns_term_+3A_knots">knots</code>, <code id="ns_term_+3A_intercept">intercept</code>, <code id="ns_term_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>same as <code><a href="splines.html#topic+ns">ns</a></code>.</p>
</td></tr>
<tr><td><code id="ns_term_+3A_use_log">use_log</code></td>
<td>
<p><code>TRUE</code> if the polynomials should be in the log of the
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list like <code><a href="splines.html#topic+ns">ns</a></code> with an additional element called <code>eval</code>
to evaluate the basis. See <code><a href="#topic+VAJointSurv-terms">VAJointSurv-terms</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poly_term">poly_term</a></code>, <code><a href="#topic+bs_term">bs_term</a></code>, <code><a href="#topic+weighted_term">weighted_term</a></code>, and
<code><a href="#topic+stacked_term">stacked_term</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(0.41, 0.29, 0.44, 0.1, 0.18, 0.65, 0.29, 0.85, 0.36, 0.47)
spline_basis &lt;- ns_term(vals,df = 3)
# evaluate spline basis at 0.5
spline_basis$eval(0.5)
# evaluate first derivative of spline basis at 0.5
spline_basis$eval(0.5, der = 1)
</code></pre>

<hr>
<h2 id='plot_marker'>Plots a Markers Mean Curve with Pointwise Quantiles</h2><span id='topic+plot_marker'></span>

<h3>Description</h3>

<p>Plots a Markers Mean Curve with Pointwise Quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_marker(
  time_fixef,
  time_rng,
  fixef_vary,
  x_range,
  vcov_vary,
  p = 0.95,
  xlab = "Time",
  ylab = "Marker",
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_marker_+3A_time_fixef">time_fixef</code></td>
<td>
<p>the time-varying fixed effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_time_rng">time_rng</code></td>
<td>
<p>the time-varying random effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_fixef_vary">fixef_vary</code></td>
<td>
<p>fixed effect coefficients for <code>time_fixef</code>.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_x_range">x_range</code></td>
<td>
<p>2D numeric vector with start and end points.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_vcov_vary">vcov_vary</code></td>
<td>
<p>the covariance matrix for <code>time_rng</code>.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_p">p</code></td>
<td>
<p>coverage of the two quantiles.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_xlab">xlab</code>, <code id="plot_marker_+3A_ylab">ylab</code>, <code id="plot_marker_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_marker_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> with data for the weights if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing data for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

fixef_vary &lt;- c(-0.1048, 0.2583, 1.0578, 2.4006, 2.9734)
vcov_vary &lt;- rbind(c(0.96580, 0.09543), c(0.09543,  0.03998))

# plot marker's trajectory
plot_marker(
  time_fixef = m1$time_fixef,
  time_rng = m1$time_rng,
  fixef_vary = fixef_vary,
  vcov_vary = vcov_vary, x_range = c(0,5))
</code></pre>

<hr>
<h2 id='plot_surv'>Plots Quantiles of the Conditional Hazards</h2><span id='topic+plot_surv'></span>

<h3>Description</h3>

<p>Plots Quantiles of the Conditional Hazards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surv(
  time_fixef,
  time_rng,
  x_range,
  fixef_vary,
  vcov_vary,
  frailty_var,
  ps = c(0.025, 0.5, 0.975),
  log_hazard_shift = 0,
  associations,
  xlab = "Time",
  ylab = "Hazard",
  ders = NULL,
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_surv_+3A_time_fixef">time_fixef</code></td>
<td>
<p>the time-varying fixed effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>. This is for the baseline hazard. Note that many
basis expansions have boundary knots. It is important that these are set
to cover the full range of survival times including time zero for some
expansions.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_time_rng">time_rng</code></td>
<td>
<p>an expansion or a list of expansions for the time-varying
random effects of the markers. See <code><a href="#topic+marker_term">marker_term</a></code>.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_x_range">x_range</code></td>
<td>
<p>two dimensional numerical vector with the range the hazard
should be plotted in.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_fixef_vary">fixef_vary</code></td>
<td>
<p>fixed effect coefficients for <code>time_fixef</code>.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_vcov_vary">vcov_vary</code></td>
<td>
<p>covariance matrix for the expansion or expansions in
<code>time_rng</code>.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_frailty_var">frailty_var</code></td>
<td>
<p>variance of the frailty.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_ps">ps</code></td>
<td>
<p>quantiles to plot.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_log_hazard_shift">log_hazard_shift</code></td>
<td>
<p>possible shift on the log hazard.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_associations">associations</code></td>
<td>
<p>association parameter for each <code>time_rng</code> or
possible multiple parameters for each <code>time_rng</code> if <code>ders</code> is
supplied.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_xlab">xlab</code>, <code id="plot_surv_+3A_ylab">ylab</code>, <code id="plot_surv_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_ders">ders</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with <code><a href="base.html#topic+integer">integer</a></code> vectors for how
the survival outcome is linked to the markers. 0 implies present values,
-1 is integral of, and 1 is the derivative. <code>NULL</code> implies the present
value of the random effect for all markers.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> with data for the weights if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing data for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# create the marker terms
m1 &lt;- marker_term(
  log(bili) ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))
m2 &lt;- marker_term(
  albumin ~ 1, id = id, data = pbcseq,
  time_fixef = bs_term(day_use, df = 5L),
  time_rng = poly_term(day_use, degree = 1L, raw = TRUE, intercept = TRUE))

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))

# expansion of time for the fixed effects in the survival term
time_fixef &lt;- s_term$time_fixef
# expansion of time for the random effects in the marker terms
time_rng &lt;- list(m1$time_rng, m2$time_rng)
# no frailty
frailty_var &lt;- matrix(0L,1)
# var-covar matrix for time-varying random effects
vcov_vary &lt;- c(0.9658, 0.0954, -0.1756, -0.0418, 0.0954, 0.04, -0.0276,
               -0.0128, -0.1756, -0.0276, 0.1189, 0.0077, -0.0418, -0.0128,
               0.0077, 0.0057) |&gt; matrix(4L)
# coefficients for time-varying fixed effects
fixef_vary &lt;- c(1.0495, -0.2004, 1.4167, 1.255, 2.5007, 4.8545, 4.7889)
# association parameters
associations &lt;- c(0.8627, -3.2358, 0.1842)
# constant shift on the log-hazard scale
log_hazard_shift &lt;- -4.498513
# specify how the survival outcome is linked with markers
ders = list(0L, c(0L, -1L))

# plot the hazard with pointwise quantiles
plot_surv(
  time_fixef = time_fixef,
  time_rng = time_rng,
  x_range = c(0, 5), vcov_vary = vcov_vary, frailty_var = frailty_var,
  ps = c(.25, .5, .75), log_hazard_shift = log_hazard_shift,
  fixef_vary = fixef_vary, associations = associations, ders = ders)
</code></pre>

<hr>
<h2 id='poly_term'>Term for Orthogonal Polynomials</h2><span id='topic+poly_term'></span>

<h3>Description</h3>

<p>Term for Orthogonal Polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_term(
  x = numeric(),
  degree = 1,
  coefs = NULL,
  raw = FALSE,
  intercept = FALSE,
  use_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly_term_+3A_x">x</code>, <code id="poly_term_+3A_degree">degree</code>, <code id="poly_term_+3A_coefs">coefs</code>, <code id="poly_term_+3A_raw">raw</code></td>
<td>
<p>same as <code><a href="stats.html#topic+poly">poly</a></code>.</p>
</td></tr>
<tr><td><code id="poly_term_+3A_intercept">intercept</code></td>
<td>
<p><code>TRUE</code> if there should be an intercept.</p>
</td></tr>
<tr><td><code id="poly_term_+3A_use_log">use_log</code></td>
<td>
<p><code>TRUE</code> if the polynomials should be in the log of the
argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list like <code><a href="stats.html#topic+poly">poly</a></code> with an additional element called <code>eval</code>
to evaluate the basis. See <code><a href="#topic+VAJointSurv-terms">VAJointSurv-terms</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bs_term">bs_term</a></code>, <code><a href="#topic+ns_term">ns_term</a></code>, <code><a href="#topic+weighted_term">weighted_term</a></code>, and
<code><a href="#topic+stacked_term">stacked_term</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(0.41, 0.29, 0.44, 0.1, 0.18, 0.65, 0.29, 0.85, 0.36, 0.47)
spline_basis &lt;- poly_term(vals,degree = 3, raw = TRUE)
# evaluate spline basis at 0.5
spline_basis$eval(0.5)
# evaluate first derivative of spline basis at 0.5
spline_basis$eval(0.5, der = 1)
</code></pre>

<hr>
<h2 id='stacked_term'>Term for a Basis Matrix for of Different Types of Terms</h2><span id='topic+stacked_term'></span>

<h3>Description</h3>

<p>Creates a basis matrix consisting of different types of terms.
E.g. to create a varying-coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stacked_term(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stacked_term_+3A_...">...</code></td>
<td>
<p>term objects from the package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an element called <code>eval</code>
to evaluate the basis. See <code><a href="#topic+VAJointSurv-terms">VAJointSurv-terms</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poly_term">poly_term</a></code>, <code><a href="#topic+bs_term">bs_term</a></code>, <code><a href="#topic+ns_term">ns_term</a></code>, and
<code><a href="#topic+weighted_term">weighted_term</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(0.41, 0.29, 0.44, 0.1, 0.18, 0.65, 0.29, 0.85, 0.36, 0.47)

spline_basis1 &lt;- ns_term(vals, df = 3)
spline_basis2 &lt;- bs_term(vals, df = 3)

# create stacked term from two spline bases
stacked_basis &lt;- stacked_term(spline_basis1, spline_basis2)

# evaluate stacked basis at 0.5
stacked_basis$eval(0.5)
# evaluate first derivative of stacked basis at 0.5
stacked_basis$eval(0.5, der = 1)
</code></pre>

<hr>
<h2 id='surv_term'>Creates Data for One Type of Survival Outcome</h2><span id='topic+surv_term'></span>

<h3>Description</h3>

<p>Creates Data for One Type of Survival Outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_term(formula, id, data, time_fixef, with_frailty = FALSE, delayed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_term_+3A_formula">formula</code></td>
<td>
<p>a two-sided <code><a href="stats.html#topic+formula">formula</a></code> with the survival outcome
on the left-hand side and fixed effect covariates on the right-hand
side. The left-hand side needs to be a <code><a href="survival.html#topic+Surv">Surv</a></code> object and can
be either right-censored and left-truncated.</p>
</td></tr>
<tr><td><code id="surv_term_+3A_id">id</code></td>
<td>
<p>the variable for the id of each individual.</p>
</td></tr>
<tr><td><code id="surv_term_+3A_data">data</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with at least the time variable.</p>
</td></tr>
<tr><td><code id="surv_term_+3A_time_fixef">time_fixef</code></td>
<td>
<p>the time-varying fixed effects. See .e.g.
<code><a href="#topic+poly_term">poly_term</a></code>. This is for the baseline hazard. Note that many
basis expansions have boundary knots. It is important that these are set
to cover the full range of survival times including time zero for some
expansions.</p>
</td></tr>
<tr><td><code id="surv_term_+3A_with_frailty">with_frailty</code></td>
<td>
<p><code>TRUE</code> if there should be a frailty term.</p>
</td></tr>
<tr><td><code id="surv_term_+3A_delayed">delayed</code></td>
<td>
<p>a vector with an entry which is <code>TRUE</code> if the
left-truncation time from the survival outcome is from a delayed entry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_fixef</code> should likely not include an intercept as this is
often included in <code>formula</code>.
</p>
<p>The <code>delayed</code> argument is to account for delayed entry with terminal
events when observations are sampled in a way such that they must not have
had the event prior to their left-truncation time. In this case, the proper
complete data likelihood is
</p>
<p style="text-align: center;"><code class="reqn">\frac{a(u)h(t_{ij}\mid u)^{d_{ij}}S(t_{ij} \mid u)g(u)}{\int a(u) S(v_{ij} \mid u) du}</code>
</p>

<p>and not
</p>
<p style="text-align: center;"><code class="reqn">a(u)h(t_{ij} \mid u)^{d_{ij}}\frac{S(t_{ij} \mid u)}{S(v_{ij} \mid u)}g(u)</code>
</p>

<p>where <code class="reqn">h</code> is conditional hazard, <code class="reqn">S</code> is the conditional survival
function, <code class="reqn">g</code> is additional conditional likelihood factors from other
outcomes, <code class="reqn">a</code> is the random effect distribution, <code class="reqn">t_{ij}</code> is the
observed time, <code class="reqn">d_{ij}</code> is an event indicator, and <code class="reqn">v_{ij}</code> is the
left truncation time.
</p>
<p>The denominator in the proper complete likelihood becomes the expectation
over all delayed entries when a cluster has more than one delayed entry. See
van den Berg and Drepper (2016) and Crowther et al. (2016) for further
details.
</p>


<h3>Value</h3>

<p>An object of class <code>surv_term</code> with data required for survival outcome.
</p>


<h3>References</h3>

<p>Crowther MJ, Andersson TM, Lambert PC, Abrams KR &amp; Humphreys K (2016).
<em>Joint
modelling of longitudinal and survival data: incorporating delayed entry and
an assessment of model misspecification</em>. Stat Med,
35(7):1193-1209. doi:10.1002/sim.6779
</p>
<p>van den Berg GJ &amp; Drepper B (2016). <em>Inference for Shared-Frailty
Survival Models with Left-Truncated Data</em>. Econometric Reviews, 35:6,
1075-1098, doi: 10.1080/07474938.2014.975640
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the data
library(survival)
data(pbc, package = "survival")

# re-scale by year
pbcseq &lt;- transform(pbcseq, day_use = day / 365.25)
pbc &lt;- transform(pbc, time_use = time / 365.25)

# base knots on observed event times
bs_term_knots &lt;-
  with(pbc, quantile(time_use[status == 2], probs = seq(0, 1, by = .2)))

boundary &lt;- c(bs_term_knots[ c(1, length(bs_term_knots))])
interior &lt;- c(bs_term_knots[-c(1, length(bs_term_knots))])

# create the survival term
s_term &lt;- surv_term(
  Surv(time_use, status == 2) ~ 1, id = id, data = pbc,
  time_fixef = bs_term(time_use, Boundary.knots = boundary, knots = interior))
</code></pre>

<hr>
<h2 id='VAJointSurv-terms'>Expansions in the VAJointSurv package</h2><span id='topic+VAJointSurv-terms'></span>

<h3>Description</h3>

<p>The VAJointSurv package uses different functions to allow for expansions in
time possibly with covariate interactions. The main usage of the functions
is internally but they do provide an element called 'eval()' which is a
function to evaluate the expansion. These functions take the following
arguments:
</p>

<ul>
<li> <p><code>x</code> numeric vector with points at which to evaluate the expansion.
</p>
</li>
<li> <p><code>der</code> integer indicating whether to evaluate the expansion, its integral,
or the derivative.
</p>
</li>
<li> <p><code>lower_limit</code> possible lower limit if integration is performed.
</p>
</li>
<li> <p><code>newdata</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> with new data if this is required.
E.g. for <code><a href="#topic+weighted_term">weighted_term</a></code>.
</p>
</li></ul>

<p>The supported terms are <code><a href="#topic+ns_term">ns_term</a></code>, <code><a href="#topic+bs_term">bs_term</a></code>,
<code><a href="#topic+poly_term">poly_term</a></code>, <code><a href="#topic+weighted_term">weighted_term</a></code>, and a
<code><a href="#topic+stacked_term">stacked_term</a></code>.
</p>

<hr>
<h2 id='weighted_term'>Term for a Basis Matrix for Weighted Term</h2><span id='topic+weighted_term'></span>

<h3>Description</h3>

<p>Creates a weighted basis matrix where the entries are weighted with a
numeric vector to e.g. create a varying-coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_term(x, weight)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_term_+3A_x">x</code></td>
<td>
<p>a term type from the package.</p>
</td></tr>
<tr><td><code id="weighted_term_+3A_weight">weight</code></td>
<td>
<p>a symbol for the weight. Notice that the symbol is first
first used when the <code>eval</code> function on the returned object is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an element called <code>eval</code>
to evaluate the basis. See <code><a href="#topic+VAJointSurv-terms">VAJointSurv-terms</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poly_term">poly_term</a></code>, <code><a href="#topic+bs_term">bs_term</a></code>, <code><a href="#topic+ns_term">ns_term</a></code>, and
<code><a href="#topic+stacked_term">stacked_term</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(0.41, 0.29, 0.44, 0.1, 0.18, 0.65, 0.29, 0.85, 0.36, 0.47)

spline_basis &lt;- ns_term(vals, df = 3)
ws &lt;- c(4,5)
# create a weighted term
w_term &lt;- weighted_term(spline_basis, weights)

# evaluate weighted basis at 0.5 and 0.7 with weights 4 and 5
w_term$eval(c(0.5,0.7), newdata = data.frame(weights = ws))
# evaluate the first derivative of weighted basis at 0.5 and 0.7
# with weights 4 and 5
w_term$eval(c(0.5,0.7), newdata = data.frame(weights = ws), der = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
