<!DOCTYPE html><html><head><title>Help for package scoringfunctions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scoringfunctions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aerr_sf'>
<p>Absolute error scoring function</p></a></li>
<li><a href='#aperr_sf'>
<p>Absolute percentage error scoring function</p></a></li>
<li><a href='#bmedian_sf'>
<p><code class="reqn">\beta</code>-median scoring function</p></a></li>
<li><a href='#bregman1_sf'>
<p>Bregman scoring function (type 1)</p></a></li>
<li><a href='#bregman2_sf'>
<p>Bregman scoring function (type 2, Patton scoring function)</p></a></li>
<li><a href='#bregman3_sf'>
<p>Bregman scoring function (type 3, QLIKE scoring function)</p></a></li>
<li><a href='#bregman4_sf'>
<p>Bregman scoring function (type 4, Patton scoring function)</p></a></li>
<li><a href='#capping_function'>
<p>Capping function</p></a></li>
<li><a href='#expectile_sf'>
<p>Asymmetric piecewise quadratic scoring function (expectile scoring function)</p></a></li>
<li><a href='#ghuber_sf'>
<p>Generalized Huber scoring function</p></a></li>
<li><a href='#gpl1_sf'>
<p>Generalized piecewise linear scoring function (type 1)</p></a></li>
<li><a href='#gpl2_sf'>
<p>Generalized piecewise linear scoring function (type 2)</p></a></li>
<li><a href='#huber_sf'>
<p>Huber scoring function</p></a></li>
<li><a href='#maelog_sf'>
<p>MAE-LOG scoring function</p></a></li>
<li><a href='#maesd_sf'>
<p>MAE-SD scoring function</p></a></li>
<li><a href='#obsweighted_sf'>
<p>Observation-weighted scoring function</p></a></li>
<li><a href='#quantile_sf'>
<p>Asymmetric piecewise linear scoring function (quantile scoring function)</p></a></li>
<li><a href='#relerr_sf'>
<p>Relative error scoring function (MAE-PROP scoring function)</p></a></li>
<li><a href='#serr_sf'>
<p>Squared error scoring function</p></a></li>
<li><a href='#sperr_sf'>
<p>Squared percentage error scoring function</p></a></li>
<li><a href='#srelerr_sf'>
<p>Squared relative error scoring function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-11</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Scoring Functions for Assessing Point Forecasts</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Implements multiple consistent scoring functions
    (Gneiting T (2011) &lt;<a href="https://doi.org/10.1198%2Fjasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>&gt;) for assessing point
    forecasts and point predictions. Detailed documentation of scoring
    functions' properties is included for facilitating interpretation of
    results.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Hristos Tyralis <a href="https://orcid.org/0000-0002-8932-4997"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Georgia Papacharalampous
    <a href="https://orcid.org/0000-0001-5446-954X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hristos Tyralis &lt;montchrister@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-12 11:44:13 UTC; Chris</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-12 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aerr_sf'>
Absolute error scoring function
</h2><span id='topic+aerr_sf'></span>

<h3>Description</h3>

<p>The function aerr_sf computes the absolute error scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive median functional.
</p>
<p>The absolute error scoring function is defined in Table 1 in Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aerr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aerr_sf_+3A_x">x</code></td>
<td>
<p>Predictive median functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="aerr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The absolute error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := |x - y|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y \in \R</code>
</p>



<h3>Value</h3>

<p>Vector of absolute errors.
</p>


<h3>Note</h3>

<p>For details on the absolute error scoring function, see Gneiting (2011).
</p>
<p>The median functional is the median of the probability distribution <code class="reqn">F</code> of
<code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The absolute error scoring function is negatively oriented (i.e. the smaller,
the better).
</p>
<p>The absolute error scoring function is strictly consistent for the median
functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which the first moment exists
and is finite (Thomson 1979, Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the absolute error scoring function.

df &lt;- data.frame(
    y = rep(x = 0, times = 5),
    x = -2:2
)

df$absolute_error &lt;- aerr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='aperr_sf'>
Absolute percentage error scoring function
</h2><span id='topic+aperr_sf'></span>

<h3>Description</h3>

<p>The function aperr_sf computes the absolute percentage error scoring function
when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive
<code class="reqn">\textnormal{med}^{(-1)}(F)</code> functional.
</p>
<p>The absolute percentage error scoring function is defined in Table 1 in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aperr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aperr_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\textnormal{med}^{(-1)}(F)</code> functional (prediction). It
can be a vector of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="aperr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The absolute percentage error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := |(x - y)/y|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of absolute percentage errors.
</p>


<h3>Note</h3>

<p>For details on the absolute percentage error scoring function, see
Gneiting (2011).
</p>
<p>The <code class="reqn">\beta</code>-median functional, <code class="reqn">\textnormal{med}^{(\beta)}(F)</code> is the
median of a probability distribution whose density is proportional to
<code class="reqn">y^\beta f(y)</code>, where <code class="reqn">f</code> is the density of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The absolute percentage error scoring function is negatively oriented (i.e. the
smaller, the better).
</p>
<p>The absolute percentage error scoring function is strictly consistent for the
<code class="reqn">\textnormal{med}^{(-1)}(F)</code> functional relative to the family
<code class="reqn">\mathbb{F}</code> of potential probability distributions (whose densities are
proportional to <code class="reqn">y^{-1} f(y)</code>, where <code class="reqn">f</code> is the density of the
probability distribution <code class="reqn">F</code>  for the future <code class="reqn">y</code>) for which the first
moment exists and is finite (see Theorems 5 and 9 in Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the absolute percentage error scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$absolute_percentage_error &lt;- aperr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='bmedian_sf'>
<code class="reqn">\beta</code>-median scoring function
</h2><span id='topic+bmedian_sf'></span>

<h3>Description</h3>

<p>The function bmedian_sf computes the <code class="reqn">\beta</code>-median scoring function
when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive
<code class="reqn">\textnormal{med}^{(\beta)}(F)</code> functional.
</p>
<p>The <code class="reqn">\beta</code>-median scoring function is defined in eq. (4) in Gneiting
(2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmedian_sf(x, y, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmedian_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\textnormal{med}^{(\beta)}(F)</code> functional (prediction).
It can be a vector of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="bmedian_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="bmedian_sf_+3A_b">b</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\beta</code>-median scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, b) := |1 - (y/x)^b|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b \neq 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, b) \geq 0, \forall x, y &gt; 0, b \neq 0</code>
</p>



<h3>Value</h3>

<p>Vector of <code class="reqn">\beta</code>-median losses.
</p>


<h3>Note</h3>

<p>For details on the <code class="reqn">\beta</code>-median scoring function, see Gneiting (2011).
</p>
<p>The <code class="reqn">\beta</code>-median functional, <code class="reqn">\textnormal{med}^{(\beta)}(F)</code> is the
median of a probability distribution whose density is proportional to
<code class="reqn">y^\beta f(y)</code>, where <code class="reqn">f</code> is the density of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The <code class="reqn">\beta</code>-median scoring function is negatively oriented (i.e. the
smaller, the better).
</p>
<p>The <code class="reqn">\beta</code>-median scoring function is strictly consistent for the
<code class="reqn">\textnormal{med}^{(\beta)}(F)</code> functional relative to the family
<code class="reqn">\mathbb{F}</code> of potential probability distributions (whose densities are
proportional to <code class="reqn">y^{\beta} f(y)</code>, where <code class="reqn">f</code> is the density of the
probability distribution <code class="reqn">F</code>  for the future <code class="reqn">y</code>) (see Theorems 5 and 9
in Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the bmedian scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3,
    b = c(-1, 1, 2)
)

df$bmedian_error &lt;- bmedian_sf(x = df$x, y = df$y, b = df$b)

print(df)
</code></pre>

<hr>
<h2 id='bregman1_sf'>
Bregman scoring function (type 1)
</h2><span id='topic+bregman1_sf'></span>

<h3>Description</h3>

<p>The function bregman1_sf computes the Bregman scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The Bregman scoring function is defined by eq. (18) in Gneiting (2011) and the
form implemented here for <code class="reqn">\phi(x) = |x|^a</code> is defined by eq. (19) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bregman1_sf(x, y, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bregman1_sf_+3A_x">x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="bregman1_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="bregman1_sf_+3A_a">a</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bregman scoring function (type 1) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, a) := |y|^a - |x|^a - a \textnormal{sign}(x) |x|^{a - 1} (y - x)
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">a &gt; 1</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, a) \geq 0, \forall x, y \in \R, a &gt; 1</code>
</p>



<h3>Value</h3>

<p>Vector of Bregman losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 1 since it corresponds to a specific
type of <code class="reqn">\phi(x)</code> of the general form of the Bregman scoring function
defined by eq. (18) in Gneiting (2011).
</p>
<p>For details on the Bregman scoring function, see Savage 1971, Banerjee et al.
(2005) and Gneiting (2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The Bregman scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The herein implemented Bregman scoring function is strictly consistent for the
mean functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code> and
<code class="reqn">E_F[|Y|^a]</code> exist and are finite (Savage 1971, Gneiting 2011).
</p>


<h3>References</h3>

<p>Banerjee A, Guo X, Wang H (2005) On the optimality of conditional expectation as
a Bregman predictor. <em>IEEE Transactions on Information Theory</em>
<b>51(7)</b>:2664&ndash;2669. <a href="https://doi.org/10.1109/TIT.2005.850145">doi:10.1109/TIT.2005.850145</a>.
</p>
<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783&ndash;810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Bregman scoring function (type 1).

df &lt;- data.frame(
    y = rep(x = 0, times = 7),
    x = c(-3, -2, -1, 0, 1, 2, 3),
    a = rep(x = 3, times = 7)
)

df$bregman1_penalty &lt;- bregman1_sf(x = df$x, y = df$y, a = df$a)

print(df)

# Equivalence of Bregman scoring function (type 1) and squared error scoring
# function, when a = 2.

set.seed(12345)

n &lt;- 100

x &lt;- runif(n, -20, 20)
y &lt;- runif(n, -20, 20)
a &lt;- rep(x = 2, times = n)

u &lt;- bregman1_sf(x = x, y = y, a = a)

v &lt;- serr_sf(x = x, y = y)

max(abs(u - v)) # values are slightly higher than 0 due to rounding error
min(abs(u - v))
</code></pre>

<hr>
<h2 id='bregman2_sf'>
Bregman scoring function (type 2, Patton scoring function)
</h2><span id='topic+bregman2_sf'></span>

<h3>Description</h3>

<p>The function bregman2_sf computes the Bregman scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The Bregman scoring function is defined by eq. (18) in Gneiting (2011) and the
form implemented here for <code class="reqn">\phi(x) = \dfrac{1}{b (b - 1)} x^b</code>,
<code class="reqn">b \in \R \setminus \lbrace 0, 1 \rbrace</code> is defined by eq. (20) in Gneiting
(2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bregman2_sf(x, y, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bregman2_sf_+3A_x">x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="bregman2_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="bregman2_sf_+3A_b">b</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bregman scoring function (type 2) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, b) := \dfrac{1}{b (b - 1)} (y^b - x^b) -
            \dfrac{1}{b - 1} x^{b - 1} (y - x)
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b \in \R \setminus \lbrace 0, 1 \rbrace</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, b) \geq 0, \forall x, y &gt; 0, b \in \R \setminus
        \lbrace 0, 1 \rbrace</code>
</p>



<h3>Value</h3>

<p>Vector of Bregman losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 2 since it corresponds to a specific
type of <code class="reqn">\phi(x)</code> of the general form of the Bregman scoring function
defined by eq. (18) in Gneiting (2011).
</p>
<p>For details on the Bregman scoring function, see Savage 1971, Banerjee et al.
(2005) and Gneiting (2011). For details on the specific form implemented here,
see Patton (2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The Bregman scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The herein implemented Bregman scoring function is strictly consistent for the
mean functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code> and
<code class="reqn">E_F[\dfrac{1}{b (b - 1)} Y^b]</code> exist and are finite (Savage 1971,
Gneiting 2011).
</p>


<h3>References</h3>

<p>Banerjee A, Guo X, Wang H (2005) On the optimality of conditional expectation as
a Bregman predictor. <em>IEEE Transactions on Information Theory</em>
<b>51(7)</b>:2664&ndash;2669. <a href="https://doi.org/10.1109/TIT.2005.850145">doi:10.1109/TIT.2005.850145</a>.
</p>
<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783&ndash;810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Bregman scoring function (type 2).

df &lt;- data.frame(
    y = rep(x = 2, times = 6),
    x = rep(x = 1:3, times = 2),
    b = rep(x = c(-3, 3), each = 3)
)

df$bregman2_penalty &lt;- bregman2_sf(x = df$x, y = df$y, b = df$b)

print(df)

# The Bregman scoring function (type 2) is half the squared error scoring
# function, when b = 2.

df &lt;- data.frame(
    y = rep(x = 5.5, times = 10),
    x = 1:10,
    b = rep(x = 2, times = 10)
)

df$bregman2_penalty &lt;- bregman2_sf(x = df$x, y = df$y, b = df$b)

df$squared_error &lt;- serr_sf(x = df$x, y = df$y)

df$ratio &lt;- df$bregman2_penalty/df$squared_error

print(df)


# When a = b &gt; 1 the Bregman scoring function (type 2) coincides with the
# Bregman scoring function (type 1) up to a multiplicative constant.

df &lt;- data.frame(
    y = rep(x = 5.5, times = 10),
    x = 1:10,
    b = rep(x = c(3, 4), each = 5)
)

df$bregman2_penalty &lt;- bregman2_sf(x = df$x, y = df$y, b = df$b)

df$bregman1_penalty &lt;- bregman1_sf(x = df$x, y = df$y, a = df$b)

df$ratio &lt;- df$bregman2_penalty/df$bregman1_penalty

print(df)
</code></pre>

<hr>
<h2 id='bregman3_sf'>
Bregman scoring function (type 3, QLIKE scoring function)
</h2><span id='topic+bregman3_sf'></span>

<h3>Description</h3>

<p>The function bregman3_sf computes the Bregman scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The Bregman scoring function is defined by eq. (18) in Gneiting (2011) and the
form implemented here for <code class="reqn">\phi(x) = -\log(x)</code> is defined by eq. (20) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bregman3_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bregman3_sf_+3A_x">x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="bregman3_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bregman scoring function (type 3) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := (y/x) - \log(y/x) - 1</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of Bregman losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 3 since it corresponds to a specific
type of <code class="reqn">\phi(x)</code> of the general form of the Bregman scoring function
defined by eq. (18) in Gneiting (2011).
</p>
<p>For details on the Bregman scoring function, see Savage 1971, Banerjee et al.
(2005) and Gneiting (2011). For details on the specific form implemented here,
see the QLIKE scoring function in Patton (2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The Bregman scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The herein implemented Bregman scoring function is strictly consistent for the
mean functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code> and
<code class="reqn">E_F[\log(Y)]</code> exist and are finite (Savage 1971, Gneiting 2011).
</p>


<h3>References</h3>

<p>Banerjee A, Guo X, Wang H (2005) On the optimality of conditional expectation as
a Bregman predictor. <em>IEEE Transactions on Information Theory</em>
<b>51(7)</b>:2664&ndash;2669. <a href="https://doi.org/10.1109/TIT.2005.850145">doi:10.1109/TIT.2005.850145</a>.
</p>
<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783&ndash;810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Bregman scoring function (type 3, QLIKE scoring function).

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$bregman3_penalty &lt;- bregman3_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='bregman4_sf'>
Bregman scoring function (type 4, Patton scoring function)
</h2><span id='topic+bregman4_sf'></span>

<h3>Description</h3>

<p>The function bregman4_sf computes the Bregman scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The Bregman scoring function is defined by eq. (18) in Gneiting (2011) and the
form implemented here for <code class="reqn">\phi(x) = x \log(x)</code> is defined by eq. (20) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bregman4_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bregman4_sf_+3A_x">x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="bregman4_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bregman scoring function (type 4) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := y \log(y/x) - y + x</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of Bregman losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 4 since it corresponds to a specific
type of <code class="reqn">\phi(x)</code> of the general form of the Bregman scoring function
defined by eq. (18) in Gneiting (2011).
</p>
<p>For details on the Bregman scoring function, see Savage 1971, Banerjee et al.
(2005) and Gneiting (2011). For details on the specific form implemented here,
see Patton (2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The Bregman scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The herein implemented Bregman scoring function is strictly consistent for the
mean functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code> and
<code class="reqn">E_F[Y \log(Y)]</code> exist and are finite (Savage 1971, Gneiting 2011).
</p>


<h3>References</h3>

<p>Banerjee A, Guo X, Wang H (2005) On the optimality of conditional expectation as
a Bregman predictor. <em>IEEE Transactions on Information Theory</em>
<b>51(7)</b>:2664&ndash;2669. <a href="https://doi.org/10.1109/TIT.2005.850145">doi:10.1109/TIT.2005.850145</a>.
</p>
<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783&ndash;810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Bregman scoring function (type 4).

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$bregman4_penalty &lt;- bregman4_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='capping_function'>
Capping function
</h2><span id='topic+capping_function'></span>

<h3>Description</h3>

<p>The function capping_function computes the value of the capping function,
defined in Taggart (2022), p.205.
</p>
<p>It is used by the generalized Huber loss function among others (see Taggart
2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capping_function(t, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capping_function_+3A_t">t</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="capping_function_+3A_a">a</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">t</code>).</p>
</td></tr>
<tr><td><code id="capping_function_+3A_b">b</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">t</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The capping function <code class="reqn">\kappa_{a,b}(t)</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">\kappa_{a,b}(t) := \max \lbrace \min \lbrace t,b \rbrace, -a \rbrace</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">t \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">a \geq 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b \geq 0</code>
</p>



<h3>Value</h3>

<p>Vector of values of the capping function.
</p>


<h3>Note</h3>

<p>For the definition of the capping function, see Taggart (2022), p.205.
</p>


<h3>References</h3>

<p>Taggart RJ (2022) Point forecasting and forecast evaluation with generalized
Huber loss. <em>Electronic Journal of Statistics</em> <b>16</b>:201&ndash;231.
<a href="https://doi.org/10.1214/21-EJS1957">doi:10.1214/21-EJS1957</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the capping function.

df &lt;- data.frame(
    t = c(1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 2.5, 2.5, 3.5, 3.5),
    a = c(0, 0, 0, 0, Inf, Inf, Inf, Inf, 2, 3, 2, 3, 2, 3),
    b = c(0, 0, Inf, Inf, 0, 0, Inf, Inf, 3, 2, 3, 2, 3, 2)
)

df$cf &lt;- capping_function(t = df$t, a = df$a, b = df$b)

print(df)
</code></pre>

<hr>
<h2 id='expectile_sf'>
Asymmetric piecewise quadratic scoring function (expectile scoring function)
</h2><span id='topic+expectile_sf'></span>

<h3>Description</h3>

<p>The function expectile_sf computes the asymmetric piecewise quadratic scoring
function (expectile scoring function) at a specific level <code class="reqn">p</code>, when
<code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive expectile at level
<code class="reqn">p</code>.
</p>
<p>The asymmetric piecewise quadratic scoring function is defined by eq. (27) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectile_sf(x, y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectile_sf_+3A_x">x</code></td>
<td>
<p>Predictive expectile (prediction) at level <code class="reqn">p</code>. It can be a vector
of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="expectile_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="expectile_sf_+3A_p">p</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymmetric piecewise quadratic scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, p) := |1(x \geq y) - p| (x - y)^2
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">0 &lt; p &lt; 1</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p) \geq 0, \forall x, y \in \R, p \in (0, 1)</code>
</p>



<h3>Value</h3>

<p>Vector of expectile losses.
</p>


<h3>Note</h3>

<p>For the definition of expectiles, see Newey and Powell (1987).
</p>
<p>The asymmetric piecewise quadratic scoring function is negatively oriented (i.e.
the smaller, the better).
</p>
<p>The asymmetric piecewise quadratic scoring function is strictly consistent for
the <code class="reqn">p</code>-expectile functional relative to the family <code class="reqn">\mathbb{F}</code> of
potential probability distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which
<code class="reqn">E_F[Y^2]</code> exists and is finite (Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Newey WK, Powell JL (1987) Asymmetric least squares estimation and testing.
<em>Econometrica</em> <b>55(4)</b>:819&ndash;847.
<a href="https://doi.org/10.2307/1911031">doi:10.2307/1911031</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the asymmetric piecewise quadratic scoring function (expectile scoring
# function).

df &lt;- data.frame(
    y = rep(x = 0, times = 6),
    x = c(2, 2, -2, -2, 0, 0),
    p = rep(x = c(0.05, 0.95), times = 3)
)

df$expectile_penalty &lt;- expectile_sf(x = df$x, y = df$y, p = df$p)

print(df)

# The asymmetric piecewise quadratic scoring function (expectile scoring
# function) at level p = 0.5 is half the squared error scoring function.

df &lt;- data.frame(
    y = rep(x = 0, times = 3),
    x = c(-2, 0, 2),
    p = rep(x = c(0.5), times = 3)
)

df$expectile_penalty &lt;- expectile_sf(x = df$x, y = df$y, p = df$p)

df$squared_error &lt;- serr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='ghuber_sf'>
Generalized Huber scoring function
</h2><span id='topic+ghuber_sf'></span>

<h3>Description</h3>

<p>The function ghuber_sf computes the generalized Huber scoring function at a
specific level <code class="reqn">p</code> and parameters <code class="reqn">a</code> and <code class="reqn">b</code>, when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive Huber functional at level <code class="reqn">p</code>.
</p>
<p>The generalized Huber scoring function is defined by eq. (4.7) in Taggart (2022)
for <code class="reqn">\phi(t) = t^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghuber_sf(x, y, p, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghuber_sf_+3A_x">x</code></td>
<td>
<p>Predictive Huber functional (prediction) at level <code class="reqn">p</code>. It can be a
vector of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="ghuber_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="ghuber_sf_+3A_p">p</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="ghuber_sf_+3A_a">a</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="ghuber_sf_+3A_b">b</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized Huber scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, p, a, b) := |1(x \geq y) - p|
            (y^2 - (\kappa_{a,b}(x - y) + y)^2 + 2 x \kappa_{a,b}(x - y))
    </code>
</p>

<p>where <code class="reqn">\kappa_{a,b}(t)</code> is the capping function defined by:
</p>
<p style="text-align: center;"><code class="reqn">\kappa_{a,b}(t) := \max \lbrace \min \lbrace t,b \rbrace, -a \rbrace</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">0 &lt; p &lt; 1</code>
</p>

<p style="text-align: center;"><code class="reqn">a &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p, a, b) \geq 0, \forall x, y \in \R, p \in (0, 1), a, b &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of generalized Huber losses.
</p>


<h3>Note</h3>

<p>For the definition of Huber functionals, see definition 3.3 in Taggart (2022).
The value of eq. (4.7) is twice the value of the equation in definition 4.2 in
Taggart (2002).
</p>
<p>The generalized Huber scoring function is negatively oriented (i.e. the smaller,
the better).
</p>
<p>The generalized Huber scoring function is strictly consistent for the
<code class="reqn">p</code>-Huber functional relative to the family <code class="reqn">\mathbb{F}</code> of potential
probability distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which
<code class="reqn">E_F[Y^2 - (Y - a)^2]</code> and <code class="reqn">E_F[Y^2 - (Y + b)^2]</code> exist and are finite
(Taggart 2022).
</p>


<h3>References</h3>

<p>Taggart RJ (2022) Point forecasting and forecast evaluation with generalized
Huber loss. <em>Electronic Journal of Statistics</em> <b>16</b>:201&ndash;231.
<a href="https://doi.org/10.1214/21-EJS1957">doi:10.1214/21-EJS1957</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the generalized Huber scoring function.

set.seed(12345)

n &lt;- 10

df &lt;- data.frame(
    x = runif(n, -2, 2),
    y = runif(n, -2, 2),
    p = runif(n, 0, 1),
    a = runif(n, 0, 1),
    b = runif(n, 0, 1)
)

df$ghuber_penalty &lt;- ghuber_sf(x = df$x, y = df$y, p = df$p, a = df$a, b = df$b)

print(df)

# Equivalence of the generalized Huber scoring function and the asymmetric
# piecewise quadratic scoring function (expectile scoring function), when
# a = Inf and b = Inf.

set.seed(12345)

n &lt;- 100

x &lt;- runif(n, -20, 20)
y &lt;- runif(n, -20, 20)
p &lt;- runif(n, 0, 1)
a &lt;- rep(x = Inf, times = n)
b &lt;- rep(x = Inf, times = n)

u &lt;- ghuber_sf(x = x, y = y, p = p, a = a, b = b)
v &lt;- expectile_sf(x = x, y = y, p = p)

max(abs(u - v)) # values are slightly higher than 0 due to rounding error
min(abs(u - v))

# Equivalence of the generalized Huber scoring function and the Huber scoring
# function when p = 1/2 and a = b.

set.seed(12345)

n &lt;- 100

x &lt;- runif(n, -20, 20)
y &lt;- runif(n, -20, 20)
p &lt;- rep(x = 1/2, times = n)
a &lt;- runif(n, 0, 20)

u &lt;- ghuber_sf(x = x, y = y, p = p, a = a, b = a)
v &lt;- huber_sf(x = x, y = y, a = a)

max(abs(u - v)) # values are slightly higher than 0 due to rounding error
min(abs(u - v))
</code></pre>

<hr>
<h2 id='gpl1_sf'>
Generalized piecewise linear scoring function (type 1)
</h2><span id='topic+gpl1_sf'></span>

<h3>Description</h3>

<p>The function gpl1_sf computes the generalized piecewise linear scoring
function at a specific level <code class="reqn">p</code> for <code class="reqn">g(x) = x^b/|b|</code>, <code class="reqn">b &gt; 0</code>, when
<code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive quantile at level <code class="reqn">p</code>.
</p>
<p>The generalized piecewise linear scoring function is defined by eq. (25) in
Gneiting (2011) and the form implemented here for the specific <code class="reqn">g(x)</code> is
defined by eq. (26) in Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpl1_sf(x, y, p, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpl1_sf_+3A_x">x</code></td>
<td>
<p>Predictive quantile (prediction) at level <code class="reqn">p</code>. It can be a vector
of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="gpl1_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="gpl1_sf_+3A_p">p</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="gpl1_sf_+3A_b">b</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized piecewise linear scoring function (type 1) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, p, b) := (1/|b|) (1(x \geq y) - p) (x^b - y^b)
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">0 &lt; p &lt; 1</code>
</p>

<p style="text-align: center;"><code class="reqn">b &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p, b) \geq 0, \forall x, y &gt; 0, p \in (0, 1), b &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of generalized piecewise linear losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 1 since it corresponds to a specific
type of <code class="reqn">g(x)</code> of the general form of the generalized piecewise linear
scoring function defined by eq. (25) in Gneiting (2011).
</p>
<p>For the definition of quantiles, see Koenker and Bassett Jr (1978).
</p>
<p>The generalized piecewise linear scoring function is negatively oriented (i.e.
the smaller, the better).
</p>
<p>The herein implemented generalized piecewise linear scoring function is strictly
consistent for the <code class="reqn">p</code>-quantile functional relative to the family
<code class="reqn">\mathbb{F}</code> of potential probability distributions <code class="reqn">F</code> for the future
<code class="reqn">y</code> for which <code class="reqn">E_F[Y^b]</code> exists and is finite (Thomson 1979,
Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Koenker R, Bassett Jr G (1978) Regression quantiles. <em>Econometrica</em>
<b>46(1)</b>:33&ndash;50. <a href="https://doi.org/10.2307/1913643">doi:10.2307/1913643</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the generalized piecewise linear scoring function (type 1).

df &lt;- data.frame(
    y = rep(x = 2, times = 6),
    x = c(1, 2, 3, 1, 2, 3),
    p = c(rep(x = 0.05, times = 3), rep(x = 0.95, times = 3)),
    b = rep(x = 2, times = 6)
)

df$gpl1_penalty &lt;- gpl1_sf(x = df$x, y = df$y, p = df$p, b = df$b)

print(df)

# Equivalence of generalized piecewise linear scoring function (type 1) and
# asymmetric piecewise linear scoring function (quantile scoring function), when
# b = 1.

set.seed(12345)

n &lt;- 100

x &lt;- runif(n, 0, 20)
y &lt;- runif(n, 0, 20)
p &lt;- runif(n, 0, 1)
b &lt;- rep(x = 1, times = n)

u &lt;- gpl1_sf(x = x, y = y, p = p, b = b)
v &lt;- quantile_sf(x = x, y = y, p = p)

max(abs(u - v))

# Equivalence of generalized piecewise linear scoring function (type 1) and
# MAE-SD scoring function, when p = 1/2 and b = 1/2.

set.seed(12345)

n &lt;- 100

x &lt;- runif(n, 0, 20)
y &lt;- runif(n, 0, 20)
p &lt;- rep(x = 0.5, times = n)
b &lt;- rep(x = 1/2, times = n)

u &lt;- gpl1_sf(x = x, y = y, p = p, b = b)
v &lt;- maesd_sf(x = x, y = y)

max(abs(u - v))
</code></pre>

<hr>
<h2 id='gpl2_sf'>
Generalized piecewise linear scoring function (type 2)
</h2><span id='topic+gpl2_sf'></span>

<h3>Description</h3>

<p>The function gpl2_sf computes the generalized piecewise linear scoring
function at a specific level <code class="reqn">p</code> for <code class="reqn">g(x) = \log(x)</code>, when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive quantile at level <code class="reqn">p</code>.
</p>
<p>The generalized piecewise linear scoring function is negatively oriented (i.e.
the smaller, the better).
</p>
<p>The generalized piecewise linear scoring function is defined by eq. (25) in
Gneiting (2011) and the form implemented here for the specific <code class="reqn">g(x)</code> is
defined by eq. (26) in Gneiting (2011) for <code class="reqn">b = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpl2_sf(x, y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpl2_sf_+3A_x">x</code></td>
<td>
<p>Predictive quantile (prediction) at level <code class="reqn">p</code>. It can be a vector
of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="gpl2_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="gpl2_sf_+3A_p">p</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized piecewise linear scoring function (type 2) is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, p) := (1(x \geq y) - p) \log(x/y)
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">0 &lt; p &lt; 1</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p) \geq 0, \forall x, y &gt; 0, p \in (0, 1)</code>
</p>



<h3>Value</h3>

<p>Vector of generalized piecewise linear losses.
</p>


<h3>Note</h3>

<p>The implemented function is denoted as type 2 since it corresponds to a specific
type of <code class="reqn">g(x)</code> of the general form of the generalized piecewise linear
scoring function defined by eq. (25) in Gneiting (2011).
</p>
<p>For the definition of quantiles, see Koenker and Bassett Jr (1978).
</p>
<p>The herein implemented generalized piecewise linear scoring function is strictly
consistent for the <code class="reqn">p</code>-quantile functional relative to the family
<code class="reqn">\mathbb{F}</code> of potential probability distributions <code class="reqn">F</code> for the future
<code class="reqn">y</code> for which <code class="reqn">E_F[\log(Y)]</code> exists and is finite (Thomson 1979,
Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Koenker R, Bassett Jr G (1978) Regression quantiles. <em>Econometrica</em>
<b>46(1)</b>:33&ndash;50. <a href="https://doi.org/10.2307/1913643">doi:10.2307/1913643</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the generalized piecewise linear scoring function (type 2).

df &lt;- data.frame(
    y = rep(x = 2, times = 6),
    x = c(1, 2, 3, 1, 2, 3),
    p = c(rep(x = 0.05, times = 3), rep(x = 0.95, times = 3))
)

df$gpl2_penalty &lt;- gpl2_sf(x = df$x, y = df$y, p = df$p)

print(df)

# The generalized piecewise linear scoring function (type 2) is half the MAE-LOG
# scoring function.

df &lt;- data.frame(
    y = rep(x = 5.5, times = 10),
    x = 1:10,
    p = rep(x = 0.5, times = 10)
)

df$gpl2_penalty &lt;- gpl2_sf(x = df$x, y = df$y, p = df$p)

df$mae_log_penalty &lt;- maelog_sf(x = df$x, y = df$y)

df$ratio &lt;- df$gpl2_penalty/df$mae_log_penalty

print(df)
</code></pre>

<hr>
<h2 id='huber_sf'>
Huber scoring function
</h2><span id='topic+huber_sf'></span>

<h3>Description</h3>

<p>The function huber_sf computes the Huber scoring function with parameter
<code class="reqn">a</code>, when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive Huber mean.
</p>
<p>The Huber scoring function is defined in Huber (1964).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huber_sf(x, y, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huber_sf_+3A_x">x</code></td>
<td>
<p>Predictive Huber mean (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="huber_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="huber_sf_+3A_a">a</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Huber scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
        S(x, y, a) := \left\{
        \begin{array}{ll}
        \dfrac{1}{2} (x - y)^2, &amp; |x - y| \leq a\\
        a |x - y| - \dfrac{1}{2} a^2, &amp; |x - y| &gt; a
        \end{array}
        \right.
    </code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">a &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, a) \geq 0, \forall x, y \in \R, a &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of Huber losses.
</p>


<h3>Note</h3>

<p>For the definition of Huber mean, see Taggart (2022).
</p>
<p>The Huber scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The Huber scoring function is strictly consistent for the Huber mean relative to
the family <code class="reqn">\mathbb{F}</code> of potential probability distributions <code class="reqn">F</code> for
the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y^2 - (Y - a)^2]</code> and
<code class="reqn">E_F[Y^2 - (Y + a)^2]</code> exist and are finite (Taggart 2022).
</p>


<h3>References</h3>

<p>Huber PJ (1964) Robust Estimation of a Location Parameter.
<em>Annals of Mathematical Statistics</em> <b>35(1)</b>:73&ndash;101.
<a href="https://doi.org/10.1214/aoms/1177703732">doi:10.1214/aoms/1177703732</a>.
</p>
<p>Taggart RJ (2022) Point forecasting and forecast evaluation with generalized
Huber loss. <em>Electronic Journal of Statistics</em> <b>16</b>:201&ndash;231.
<a href="https://doi.org/10.1214/21-EJS1957">doi:10.1214/21-EJS1957</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Huber scoring function.

df &lt;- data.frame(
    x = c(-3, -2, -1, 0, 1, 2, 3),
    y = c(0, 0, 0, 0, 0, 0, 0),
    a = c(2.7, 2.5, 0.6, 0.7, 0.9, 1.2, 5)
)

df$huber_penalty &lt;- huber_sf(x = df$x, y = df$y, a = df$a)

print(df)
</code></pre>

<hr>
<h2 id='maelog_sf'>
MAE-LOG scoring function
</h2><span id='topic+maelog_sf'></span>

<h3>Description</h3>

<p>The function maelog_sf computes the MAE-LOG scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive median functional.
</p>
<p>The MAE-LOG scoring function is defined by eq. (11) in Patton (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maelog_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maelog_sf_+3A_x">x</code></td>
<td>
<p>Predictive median functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="maelog_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MAE-LOG scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := |\log(x/y)|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of MAE-LOG losses.
</p>


<h3>Note</h3>

<p>For details on the MAE-LOG scoring function, see Gneiting (2011) and Patton
(2011).
</p>
<p>The median functional is the median of the probability distribution <code class="reqn">F</code> of
<code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The MAE-LOG scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The MAE-LOG scoring function is strictly consistent for the median functional
relative to the family <code class="reqn">\mathbb{F}</code> of potential probability distributions
<code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[\log(Y)]</code> exists and is finite
(Thomson 1979, Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the MAE-LOG scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$mae_log_penalty &lt;- maelog_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='maesd_sf'>
MAE-SD scoring function
</h2><span id='topic+maesd_sf'></span>

<h3>Description</h3>

<p>The function maesd_sf computes the MAE-SD scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive median functional.
</p>
<p>The MAE-SD scoring function is defined by eq. (12) in Patton (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maesd_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maesd_sf_+3A_x">x</code></td>
<td>
<p>Predictive median functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="maesd_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MAE-SD scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := |x^{1/2} - y^{1/2}|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of MAE-SD losses.
</p>


<h3>Note</h3>

<p>For details on the MAE-SD scoring function, see Gneiting (2011) and Patton
(2011).
</p>
<p>The median functional is the median of the probability distribution <code class="reqn">F</code> of
<code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The MAE-SD scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The MAE-SD scoring function is strictly consistent for the median functional
relative to the family <code class="reqn">\mathbb{F}</code> of potential probability distributions
<code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y^{1/2}]</code> exists and is finite
(Thomson 1979, Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the MAE-SD scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$mae_sd_penalty &lt;- maesd_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='obsweighted_sf'>
Observation-weighted scoring function
</h2><span id='topic+obsweighted_sf'></span>

<h3>Description</h3>

<p>The function obsweighted_sf computes the observation-weighted scoring function
when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code> functional.
</p>
<p>The observation-weighted scoring function is defined in p. 752 in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsweighted_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obsweighted_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code>
functional (prediction). It can be a vector of length <code class="reqn">n</code> (must have the
same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="obsweighted_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observation-weighted scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := y (x - y)^{2}</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of observation-weighted errors.
</p>


<h3>Note</h3>

<p>For details on the observation-weighted scoring function, see Gneiting (2011).
</p>
<p>The observation-weighted scoring function is negatively oriented (i.e. the
smaller, the better).
</p>
<p>The observation-weighted scoring function is strictly consistent for the
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code> functional.
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the observation-weighted scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$squared_relative_error &lt;- obsweighted_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='quantile_sf'>
Asymmetric piecewise linear scoring function (quantile scoring function)
</h2><span id='topic+quantile_sf'></span>

<h3>Description</h3>

<p>The function quantile_sf computes the asymmetric piecewise linear scoring
function (quantile scoring function) at a specific level <code class="reqn">p</code>, when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive quantile at level <code class="reqn">p</code>.
</p>
<p>The asymmetric piecewise linear scoring function is defined by eq. (24) in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_sf(x, y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_sf_+3A_x">x</code></td>
<td>
<p>Predictive quantile (prediction) at level <code class="reqn">p</code>. It can be a vector
of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="quantile_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
<tr><td><code id="quantile_sf_+3A_p">p</code></td>
<td>
<p>It can be a vector of length <code class="reqn">n</code> (must have the same length as
<code class="reqn">y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assymetric piecewise linear scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p) := (1(x \geq y) - p) (x - y)</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">0 &lt; p &lt; 1</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y, p) \geq 0, \forall x, y \in \R, p \in (0, 1)</code>
</p>



<h3>Value</h3>

<p>Vector of quantile losses.
</p>


<h3>Note</h3>

<p>For the definition of quantiles, see Koenker and Bassett Jr (1978).
</p>
<p>The asymmetric piecewise linear scoring function is negatively oriented (i.e.
the smaller, the better).
</p>
<p>The asymmetric piecewise linear scoring function is strictly consistent for the
<code class="reqn">p</code>-quantile functional relative to the family <code class="reqn">\mathbb{F}</code> of potential
probability distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which <code class="reqn">E_F[Y]</code>
exists and is finite (Thomson 1979, Saerens 2000, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Koenker R, Bassett Jr G (1978) Regression quantiles. <em>Econometrica</em>
<b>46(1)</b>:33&ndash;50. <a href="https://doi.org/10.2307/1913643">doi:10.2307/1913643</a>.
</p>
<p>Saerens M (2000) Building cost functions minimizing to some summary statistics.
<em>IEEE Transactions on Neural Networks</em> <b>11(6)</b>:1263&ndash;1271.
<a href="https://doi.org/10.1109/72.883416">doi:10.1109/72.883416</a>.
</p>
<p>Thomson W (1979) Eliciting production possibilities from a well-informed
manager. <em>Journal of Economic Theory</em> <b>20(3)</b>:360&ndash;380.
<a href="https://doi.org/10.1016/0022-0531%2879%2990042-5">doi:10.1016/0022-0531(79)90042-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the asymmetric piecewise linear scoring function (quantile scoring
# function).

df &lt;- data.frame(
    y = rep(x = 0, times = 6),
    x = c(2, 2, -2, -2, 0, 0),
    p = rep(x = c(0.05, 0.95), times = 3)
)

df$quantile_penalty &lt;- quantile_sf(x = df$x, y = df$y, p = df$p)

print(df)

# The absolute error scoring function is twice the asymmetric piecewise linear
# scoring function (quantile scoring function) at level p = 0.5.

df &lt;- data.frame(
    y = rep(x = 0, times = 3),
    x = c(-2, 0, 2),
    p = rep(x = c(0.5), times = 3)
)

df$quantile_penalty &lt;- quantile_sf(x = df$x, y = df$y, p = df$p)

df$absolute_error &lt;- aerr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='relerr_sf'>
Relative error scoring function (MAE-PROP scoring function)
</h2><span id='topic+relerr_sf'></span>

<h3>Description</h3>

<p>The function relerr_sf computes the relative error scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive <code class="reqn">\textnormal{med}^{(1)}(F)</code>
functional.
</p>
<p>The relative error scoring function is defined in Table 1 in Gneiting (2011).
</p>
<p>The relative error scoring function is referred to as MAE-PROP scoring function
in eq. (13) in Patton (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relerr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relerr_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\textnormal{med}^{(1)}(F)</code> functional (prediction). It
can be a vector of length <code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="relerr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := |(x - y)/x|</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of relative errors.
</p>


<h3>Note</h3>

<p>For details on the relative error scoring function, see Gneiting (2011).
</p>
<p>The <code class="reqn">\beta</code>-median functional, <code class="reqn">\textnormal{med}^{(\beta)}(F)</code> is the
median of a probability distribution whose density is proportional to
<code class="reqn">y^\beta f(y)</code>, where <code class="reqn">f</code> is the density of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The relative error scoring function is negatively oriented (i.e. the smaller,
the better).
</p>
<p>The relative error scoring function is strictly consistent for the
<code class="reqn">\textnormal{med}^{(1)}(F)</code> functional relative to the family
<code class="reqn">\mathbb{F}</code> of potential probability distributions (whose densities are
proportional to <code class="reqn">y f(y)</code>, where <code class="reqn">f</code> is the density of the
probability distribution <code class="reqn">F</code>  for the future <code class="reqn">y</code>) (see Theorems 5 and 9
in Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Patton AJ (2011) Volatility forecast comparison using imperfect volatility
proxies. <em>Journal of Econometrics</em> <b>160(1)</b>:246&ndash;256.
<a href="https://doi.org/10.1016/j.jeconom.2010.03.034">doi:10.1016/j.jeconom.2010.03.034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the relative error scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$relative_error &lt;- relerr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='serr_sf'>
Squared error scoring function
</h2><span id='topic+serr_sf'></span>

<h3>Description</h3>

<p>The function serr_sf computes the squared error scoring function when <code class="reqn">y</code>
materializes and <code class="reqn">x</code> is the predictive mean functional.
</p>
<p>The squared error scoring function is defined in Table 1 in Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serr_sf_+3A_x">x</code></td>
<td>
<p>Predictive mean functional (prediction). It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="serr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The squared error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := (x - y)^2</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x \in \R</code>
</p>

<p style="text-align: center;"><code class="reqn">y \in \R</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y \in \R</code>
</p>



<h3>Value</h3>

<p>Vector of squared errors.
</p>


<h3>Note</h3>

<p>For details on the squared error scoring function, see Savage 1971, Gneiting
(2011).
</p>
<p>The mean functional is the mean <code class="reqn">E_F[Y]</code> of the probability distribution
<code class="reqn">F</code> of <code class="reqn">y</code> (Gneiting 2011).
</p>
<p>The squared error scoring function is negatively oriented (i.e. the smaller, the
better).
</p>
<p>The squared error scoring function is strictly consistent for the mean
functional relative to the family <code class="reqn">\mathbb{F}</code> of potential probability
distributions <code class="reqn">F</code> for the future <code class="reqn">y</code> for which the second moment exists
and is finite (Savage 1971, Gneiting 2011).
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Savage LJ  (1971) Elicitation of personal probabilities and expectations.
<em>Journal of the American Statistical Association</em> <b>66(337)</b>:783&ndash;810.
<a href="https://doi.org/10.1080/01621459.1971.10482346">doi:10.1080/01621459.1971.10482346</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the squarer error scoring function.

df &lt;- data.frame(
    y = rep(x = 0, times = 5),
    x = -2:2
)

df$squared_error &lt;- serr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='sperr_sf'>
Squared percentage error scoring function
</h2><span id='topic+sperr_sf'></span>

<h3>Description</h3>

<p>The function sperr_sf computes the squared percentage error scoring function
when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{-1}]}{\textnormal{E}_F [Y^{-2}]}</code> functional.
</p>
<p>The squared percentage error scoring function is defined in p. 752 in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sperr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sperr_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\dfrac{\textnormal{E}_F [Y^{-1}]}{\textnormal{E}_F [Y^{-2}]}</code>
functional (prediction). It can be a vector of length <code class="reqn">n</code> (must have the
same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="sperr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The squared percentage error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := ((x - y)/y)^{2}</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of squared percentage errors.
</p>


<h3>Note</h3>

<p>For details on the squared percentage error scoring function, see
Park and Stefanski (1998) and Gneiting (2011).
</p>
<p>The squared percentage error scoring function is negatively oriented (i.e. the
smaller, the better).
</p>
<p>The squared percentage error scoring function is strictly consistent for the
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{-1}]}{\textnormal{E}_F [Y^{-2}]}</code> functional.
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>
<p>Park H, Stefanski LA (1998) Relative-error prediction.
<em>Statistics and Probability Letters</em> <b>40(3)</b>:227&ndash;236.
<a href="https://doi.org/10.1016/S0167-7152%2898%2900088-1">doi:10.1016/S0167-7152(98)00088-1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the squared percentage error scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$squared_percentage_error &lt;- sperr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

<hr>
<h2 id='srelerr_sf'>
Squared relative error scoring function
</h2><span id='topic+srelerr_sf'></span>

<h3>Description</h3>

<p>The function srelerr_sf computes the squared relative error scoring function
when <code class="reqn">y</code> materializes and <code class="reqn">x</code> is the predictive
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code> functional.
</p>
<p>The squared relative error scoring function is defined in p. 752 in
Gneiting (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srelerr_sf(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srelerr_sf_+3A_x">x</code></td>
<td>
<p>Predictive <code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code>
functional (prediction). It can be a vector of length <code class="reqn">n</code> (must have the
same length as <code class="reqn">y</code>).</p>
</td></tr>
<tr><td><code id="srelerr_sf_+3A_y">y</code></td>
<td>
<p>Realization (true value) of process. It can be a vector of length
<code class="reqn">n</code> (must have the same length as <code class="reqn">x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The squared relative error scoring function is defined by:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) := ((x - y)/x)^{2}</code>
</p>

<p>Domain of function:
</p>
<p style="text-align: center;"><code class="reqn">x &gt; 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y &gt; 0</code>
</p>

<p>Range of function:
</p>
<p style="text-align: center;"><code class="reqn">S(x, y) \geq 0, \forall x, y &gt; 0</code>
</p>



<h3>Value</h3>

<p>Vector of squared relative errors.
</p>


<h3>Note</h3>

<p>For details on the squared relative error scoring function, see Gneiting (2011).
</p>
<p>The squared relative error scoring function is negatively oriented (i.e. the
smaller, the better).
</p>
<p>The squared relative error scoring function is strictly consistent for the
<code class="reqn">\dfrac{\textnormal{E}_F [Y^{2}]}{\textnormal{E}_F [Y]}</code> functional.
</p>


<h3>References</h3>

<p>Gneiting T (2011) Making and evaluating point forecasts.
<em>Journal of the American Statistical Association</em> <b>106(494)</b>:746&ndash;762.
<a href="https://doi.org/10.1198/jasa.2011.r10138">doi:10.1198/jasa.2011.r10138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the squared percentage error scoring function.

df &lt;- data.frame(
    y = rep(x = 2, times = 3),
    x = 1:3
)

df$squared_relative_error &lt;- srelerr_sf(x = df$x, y = df$y)

print(df)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
