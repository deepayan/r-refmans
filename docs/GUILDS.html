<!DOCTYPE html><html><head><title>Help for package GUILDS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GUILDS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GUILDS-package'><p>Package implementing the Guilds sampling formula for the Neutral Theory of Biodiversity</p></a></li>
<li><a href='#expected.SAD'>
<p>Calculate the expected species abundance distribution of the standard neutral model, given theta, m and J</p></a></li>
<li><a href='#expected.SAD.Guilds'>
<p>Estimate the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y and J.</p></a></li>
<li><a href='#expected.SAD.Guilds.Conditional'>
<p>Estimate the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y, conditional on the size of guild X, Jx and the size of guild Y, Jy.</p></a></li>
<li><a href='#generate.ESF'>
<p>Generate community data under the standard neutral model of biodiversity, using the urn scheme as described in Etienne 2005</p></a></li>
<li><a href='#generate.Guilds'>
<p>Generate Artificial data under the GUILDS model</p></a></li>
<li><a href='#generate.Guilds.Cond'>
<p>Generate Artificial data under the GUILDS model, conditioned on Guild size</p>
</p></a></li>
<li><a href='#GUILDS-internal'><p>Internal Guilds functions</p></a></li>
<li><a href='#logLikelihood.ESF'>
<p>Likelihood of the Etienne sampling formula</p></a></li>
<li><a href='#logLikelihood.Guilds'><p> Likelihood of the Guilds sampling formula</p></a></li>
<li><a href='#logLikelihood.Guilds.Conditional'>
<p>Likelihood of the Guilds sampling formula, conditional on guild size</p></a></li>
<li><a href='#maxLikelihood.ESF'>
<p>Maximization of the loglikelihood given the standard Neutral Model, using the Etienne Sampling Formula</p></a></li>
<li><a href='#maxLikelihood.Guilds'>
<p>Maximization of the loglikelihood under the Guilds Model.</p></a></li>
<li><a href='#maxLikelihood.Guilds.Conditional'>
<p>Maximization of the loglikelihood under the Guilds Model, conditioned on guild size.</p></a></li>
<li><a href='#preston_plot'>
<p>Barplot in Preston style of an abundance dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of Sampling Formulas for the Unified Neutral
Model of Biodiversity and Biogeography, with or without Guild
Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of sampling formulas for the unified neutral model of biogeography and biodiversity. Alongside the sampling formulas, it includes methods to perform maximum likelihood optimization of the sampling formulas, methods to generate data given the neutral model, and methods to estimate the expected species abundance distribution. Sampling formulas included in the GUILDS package are the Etienne Sampling Formula (Etienne 2005), the guild sampling formula, where guilds are assumed to differ in dispersal ability (Janzen et al. 2015), and  the guilds sampling formula conditioned on guild size (Janzen et al. 2015).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), pracma, nloptr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thijsjanzen/GUILDS">https://github.com/thijsjanzen/GUILDS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thijsjanzen/GUILDS/issues">https://github.com/thijsjanzen/GUILDS/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 11:00:06 UTC; thijsjanzen</td>
</tr>
<tr>
<td>Author:</td>
<td>Thijs Janzen [aut, cre],
  Bart Haegeman [ctb],
  Franck Jabot [ctb],
  Jerome Chave [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thijs Janzen &lt;thijsjanzen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 11:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='GUILDS-package'>Package implementing the Guilds sampling formula for the Neutral Theory of Biodiversity
</h2><span id='topic+GUILDS'></span><span id='topic+GUILDS-package'></span>

<h3>Description</h3>

<p> The GUILDS package contains a number of sampling formula's being the Etienne Sampling Formula (Etienne 2005), the GUILDS sampling formula (Janzen et al. 2014) and the GUILDS sampling formula conditioned on guild Size (Janzen et al. 2015). Furthermore it contains functions to generate data given the guilds model, with or without conditioning on guild size. C++ Code to obtain Sterling numbers of the first kind was adopted from the Tetame program by Jabot et al. (2008).
<br /><br />
Updates <br /><br />
Version 1.4   : Cleaner README and Vignettes <br />
Version 1.4   : Extend support to M1 processors where sizeof(long double) &lt; 16 <br />
Version 1.4   : Comply with _R_CHECK_LENGTH_0_LOGIC2_ <br />
Version 1.3   : GUILDS is now on GitHub: https://github.com/thijsjanzen/GUILDS<br />
Version 1.3   : Wrote code tests to check code integrity, code coverage is &gt;95% <br />
Version 1.3   : Modified maximum likelihood functions to take into account theta_x = theta_y = theta / 2 <br />
Version 1.3   : Added a plotting function to plot Preston style plots <br />
Version 1.2.1 : Updated the User manual<br />
Version 1.2   : fixed memory leak issues by adding extra vector access checks <br />
Version 1.2   : fixed memory leak issues by introducing vectors in KDA code<br />
Version 1.2   : renamed logLik to avoid shadowing of the function logLik in the package stats<br />
Version 1.1   : removed malloc header from KDA code <br />
</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>
<p>Maintainer: Thijs Janzen &lt;thijsjanzen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Janzen, T., Haegeman B., Etienne, R.S. (2015) A sampling formula for communities with multiple dispersal syndromes. Journal of Theoretical Biology 374: 94-106
</p>
<p>Etienne, R.S. (2005). A new sampling formula for neutral biodiversity. Ecology Letters, 8(3), 253-260.
</p>
<p>Jabot, F., Etienne, R.S., &amp; Chave, J. (2008). Reconciling neutral community models and environmental filtering: theory and an empirical test. Oikos 117: 1308-1320
</p>

<hr>
<h2 id='expected.SAD'>
Calculate the expected species abundance distribution of the standard neutral model, given theta, m and J
</h2><span id='topic+expected.SAD'></span>

<h3>Description</h3>

<p>This function calculates the expected species abundance distribution of the standard neutral model given theta, m and J, sensu equation 6 from Etienne and Alonso (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected.SAD(theta, m, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected.SAD_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number theta
</p>
</td></tr>
<tr><td><code id="expected.SAD_+3A_m">m</code></td>
<td>
<p>migration parameter
</p>
</td></tr>
<tr><td><code id="expected.SAD_+3A_j">J</code></td>
<td>
<p>Total number of individuals in the local community
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the abundances binned into log2 bins (sensu Preston).
</p>


<h3>Author(s)</h3>

<p>Thijs Janzen &amp; Bart Haegeman
</p>


<h3>References</h3>

<p>Etienne, R.S., &amp; Alonso, D. (2005). A dispersal-limited sampling theory for species and alleles. Ecology Letters, 8(100), 1147-1156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SAD &lt;- expected.SAD(theta = 42, m = 0.1, J = 200)
barplot(SAD,
        names.arg=0:(length(SAD)-1),
	      xlab="Number of individuals (log2)",
	      ylab="Number of Species" )
</code></pre>

<hr>
<h2 id='expected.SAD.Guilds'>
Estimate the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y and J.
</h2><span id='topic+expected.SAD.Guilds'></span>

<h3>Description</h3>

<p>This function estimates the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y and J. The expected species abundance distribution is approximated by first drawing px from a beta distribution (equation 4 in Janzen et al. 2014). Then, guild sizes are drawn using equation 3 in Janzen et al. 2014. Because the abundance distributions of the two guilds are independent, the distributions can now be obtained using equation 6 in Etienne and Alonso 2005. Because drawing from the beta distribution and equation 3 is inherently stochastic, this function returns the average over a specified number of replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected.SAD.Guilds(theta, alpha_x, alpha_y, J, n_replicates = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected.SAD.Guilds_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number theta
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds_+3A_alpha_x">alpha_x</code></td>
<td>
<p>Dispersal ability of guild X
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds_+3A_alpha_y">alpha_y</code></td>
<td>
<p>Dispersal ability of guild Y
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds_+3A_j">J</code></td>
<td>
<p>Total number of individuals in the local community, e.g. J = Jx + Jy
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds_+3A_n_replicates">n_replicates</code></td>
<td>
<p>Number of replicates to use to estimate the abundance distributions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>guildX</code></td>
<td>
<p>Vector containing the mean abundances of species in Guild X, binned into log2 bins</p>
</td></tr>
<tr><td><code>guildY</code></td>
<td>
<p>Vector containing the mean abundances of species in Guild Y, binned into log2 bins</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen &amp; Bart Haegeman
</p>


<h3>References</h3>

<p>Etienne, R.S., &amp; Alonso, D. (2005). A dispersal-limited sampling theory for species and alleles. Ecology Letters, 8(100), 1147-1156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  SADs &lt;- expected.SAD.Guilds(theta = 42, alpha_x = 0.01, alpha_y = 0.1, J = 1000, n_replicates = 3)
  par(mfrow=c(1,2));
  barplot(SADs$guildX,names.arg=0:(length(SADs$guildX)-1),
	  xlab="Number of individuals (log2)",
	  ylab="Number of Species",main="Guild X" )

  barplot(SADs$guildY,names.arg=0:(length(SADs$guildY)-1),
	  xlab="Number of individuals (log2)",
	  ylab="Number of Species",main="Guild Y" )
</code></pre>

<hr>
<h2 id='expected.SAD.Guilds.Conditional'>
Estimate the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y, conditional on the size of guild X, Jx and the size of guild Y, Jy.
</h2><span id='topic+expected.SAD.Guilds.Conditional'></span>

<h3>Description</h3>

<p>This function estimates the expected species abundance distribution of both guilds using the guilds model, provided theta, alpha_x, alpha_y and J. The expected species abundance distribution is approximated by first drawing px from equation 9. Because the abundance distributions of the two guilds are independent, the distributions can now be obtained using equation 6 in Etienne and Alonso 2005. Because drawing from the beta distribution and equation 3 is inherently stochastic, this function returns the average over a specified number of replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected.SAD.Guilds.Conditional(theta, alpha_x, alpha_y, Jx, Jy, n_replicates = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number theta
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_alpha_x">alpha_x</code></td>
<td>
<p>Dispersal ability of guild X
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_alpha_y">alpha_y</code></td>
<td>
<p>Dispersal ability of guild Y
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_jx">Jx</code></td>
<td>
<p>Total number of individuals in guild X
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_jy">Jy</code></td>
<td>
<p>Total number of individuals in guild Y
</p>
</td></tr>
<tr><td><code id="expected.SAD.Guilds.Conditional_+3A_n_replicates">n_replicates</code></td>
<td>
<p>Number of replicates to use to estimate the abundance distributions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>guildX</code></td>
<td>
<p>Vector containing the mean abundances of species in Guild X, binned into log2 bins</p>
</td></tr>
<tr><td><code>guildY</code></td>
<td>
<p>Vector containing the mean abundances of species in Guild Y, binned into log2 bins</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen &amp; Bart Haegeman
</p>


<h3>References</h3>

<p>Etienne, R.S., &amp; Alonso, D. (2005). A dispersal-limited sampling theory for species and alleles. Ecology Letters, 8(100), 1147-1156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  SADs &lt;- expected.SAD.Guilds.Conditional(theta = 42,
                                          alpha_x = 0.01,
                                          alpha_y = 0.1,
                                          Jx = 100,
                                          Jy = 200,
                                          n_replicates = 3)

  par(mfrow=c(1,2))
  barplot(SADs$guildX, names.arg=0:(length(SADs$guildX) - 1),
	  xlab = "Number of individuals (log2)",
	  ylab = "Number of Species", main = "Guild X" )
  barplot(SADs$guildY, names.arg = 0:(length(SADs$guildY) - 1),
	  xlab = "Number of individuals (log2)",
	  ylab = "Number of Species", main = "Guild Y" )
</code></pre>

<hr>
<h2 id='generate.ESF'>
Generate community data under the standard neutral model of biodiversity, using the urn scheme as described in Etienne 2005
</h2><span id='topic+generate.ESF'></span>

<h3>Description</h3>

<p>This function generates community data under the standard neutral model of biodiversity, using the urn scheme as described in Etienne 2005
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.ESF(theta, I, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.ESF_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number theta
</p>
</td></tr>
<tr><td><code id="generate.ESF_+3A_i">I</code></td>
<td>
<p>Fundamental dispersal number I
</p>
</td></tr>
<tr><td><code id="generate.ESF_+3A_j">J</code></td>
<td>
<p>total number of individuals in the local community
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing the unlabeled species abundances in the local community
</p>


<h3>Author(s)</h3>

<p>Thijs Janzen &amp; Bart Haegeman
</p>


<h3>References</h3>

<p>Etienne, R.S. (2005). A new sampling formula for neutral biodiversity. Ecology Letters, 8(3), 253-260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	generate.ESF(theta = 42, I = 10, J = 2000)
</code></pre>

<hr>
<h2 id='generate.Guilds'>
Generate Artificial data under the GUILDS model
</h2><span id='topic+generate.Guilds'></span>

<h3>Description</h3>

<p>Using this function it is possible to generate a community dataset consisting of two separate abundance vectors for each guild, where the data generated adhere to the Guilds model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.Guilds(theta, alpha_x, alpha_y, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.Guilds_+3A_theta">theta</code></td>
<td>
<p> Fundamental Biodiversity Number theta
</p>
</td></tr>
<tr><td><code id="generate.Guilds_+3A_alpha_x">alpha_x</code></td>
<td>
<p> Dispersal Ability of Guild X
</p>
</td></tr>
<tr><td><code id="generate.Guilds_+3A_alpha_y">alpha_y</code></td>
<td>
<p>Dispersal Ability of Guild Y
</p>
</td></tr>
<tr><td><code id="generate.Guilds_+3A_j">J</code></td>
<td>
<p>Total number of individuals in the local community (e.g. J_X + J_Y).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>guildX</code></td>
<td>
<p>Vector containing the unlabeled abundances of species in Guild X</p>
</td></tr>
<tr><td><code>guildY</code></td>
<td>
<p>Vector containing the unlabeled abundances of species in Guild Y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate.Guilds(theta = 200,
                alpha_x = 0.005,
                alpha_y = 0.001,
                J = 10000)
</code></pre>

<hr>
<h2 id='generate.Guilds.Cond'>
Generate Artificial data under the GUILDS model, conditioned on Guild size
</h2><span id='topic+generate.Guilds.Cond'></span>

<h3>Description</h3>

<p>Using this function it is possible to generate a community dataset consisting of two separate abundance vectors for each guild, where the data generated adhere to the Guilds model. Data generated is conditioned on guild size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.Guilds.Cond(theta, alpha_x, alpha_y, JX, JY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.Guilds.Cond_+3A_theta">theta</code></td>
<td>
<p> Fundamental Biodiversity Number theta
</p>
</td></tr>
<tr><td><code id="generate.Guilds.Cond_+3A_alpha_x">alpha_x</code></td>
<td>
<p> Dispersal Ability of Guild X
</p>
</td></tr>
<tr><td><code id="generate.Guilds.Cond_+3A_alpha_y">alpha_y</code></td>
<td>
<p>Dispersal Ability of Guild Y
</p>
</td></tr>
<tr><td><code id="generate.Guilds.Cond_+3A_jx">JX</code></td>
<td>
<p>Total number of individuals in Guild X
</p>
</td></tr>
<tr><td><code id="generate.Guilds.Cond_+3A_jy">JY</code></td>
<td>
<p>Total number of individuals in Guild Y
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>guildX</code></td>
<td>
<p>Vector containing the unlabeled abundances of species in Guild X</p>
</td></tr>
<tr><td><code>guildY</code></td>
<td>
<p>Vector containing the unlabeled abundances of species in Guild Y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate.Guilds.Cond(theta = 200,
                     alpha_x = 0.005,
                     alpha_y = 0.001,
                     JX = 15000,
                     JY = 5000);
</code></pre>

<hr>
<h2 id='GUILDS-internal'>Internal Guilds functions</h2><span id='topic+rho'></span><span id='topic+polyaeggenberger'></span><span id='topic+logLikguilds'></span><span id='topic+localComm'></span><span id='topic+getpx'></span><span id='topic+local_esf'></span><span id='topic+evaluateLogLik'></span><span id='topic+conditional.LogLik'></span><span id='topic+calc_sum_kda'></span><span id='topic+calc_conditional'></span><span id='topic+evaluate_cond_lik'></span><span id='topic+calcKDA'></span><span id='topic+pm_sad'></span><span id='topic+pm_sadaux'></span><span id='topic+draw_local_cond'></span><span id='topic+draw_local'></span><span id='topic+sort_aux'></span><span id='topic+generate.ZSM'></span><span id='topic+octave_index'></span><span id='topic+preston_sort'></span>

<h3>Description</h3>

<p>Internal Guilds functions</p>


<h3>Details</h3>

<p>These are not to be called by the user</p>

<hr>
<h2 id='logLikelihood.ESF'>
Likelihood of the Etienne sampling formula
</h2><span id='topic+logLikelihood.ESF'></span>

<h3>Description</h3>

<p>This function calculates the likelihood of the Etienne Sampling Formula, provided abundance data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	logLikelihood.ESF(theta, m, abund)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.ESF_+3A_theta">theta</code></td>
<td>
<p>Parameter value for the fundamental biodiversity number theta</p>
</td></tr>
<tr><td><code id="logLikelihood.ESF_+3A_m">m</code></td>
<td>
<p>Parameter value for migration</p>
</td></tr>
<tr><td><code id="logLikelihood.ESF_+3A_abund">abund</code></td>
<td>
<p>Vector containing abundance data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the LogLikelihood</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>References</h3>

<p>Etienne, R.S. (2005). A new sampling formula for neutral biodiversity. Ecology Letters, 8(3), 253-260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	A &lt;- c(1,1,1,3,5,8); #Artificial abundance dataset
	LL &lt;- logLikelihood.ESF(theta = 7, m = 0.1, abund = A)
</code></pre>

<hr>
<h2 id='logLikelihood.Guilds'> Likelihood of the Guilds sampling formula
</h2><span id='topic+logLikelihood.Guilds'></span>

<h3>Description</h3>

<p> This function calculates the likelihood of the guilds model, provided abundance data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikelihood.Guilds(parameters, model, sadx, sady, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.Guilds_+3A_parameters">parameters</code></td>
<td>
<p><code>parameters</code> corresponds to a vector of parameter values depending on the provided model: <br />
- model: &quot;D0&quot; <code>parameters</code> = c(theta, alpha) <br />
- model: &quot;D1&quot; <code>parameters</code> = c(theta, alpha X, alpha Y) <br />
</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds_+3A_model">model</code></td>
<td>
<p> The chosen model to calculate the likelihood for, please note that the vector of parameters should contain the corresponding parameters in the right order. The user can pick one of these models:<br />
-  &quot;D0&quot; <br />
-  &quot;D1&quot; <br />
</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds_+3A_sadx">sadx</code></td>
<td>
<p> The Species Abundance Distribution of guild X</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds_+3A_sady">sady</code></td>
<td>
<p> The Species Abundance Distribution of guild Y</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE flag, indicates whether intermediate output is shown on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the LogLikelihood</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleData &lt;- generate.Guilds(theta = 200,
                               alpha_x = 0.005,
                               alpha_y = 0.001,
                               J = 1000)
#theta = 200, alpha X = 0.005, alpha Y = 0.001
parametervals &lt;- c(200, 0.005, 0.001)
LL = logLikelihood.Guilds(parametervals,
                          model = "D1",
			                    exampleData$guildX,
			                    exampleData$guildY,
			                    verbose = TRUE)
</code></pre>

<hr>
<h2 id='logLikelihood.Guilds.Conditional'>
Likelihood of the Guilds sampling formula, conditional on guild size
</h2><span id='topic+logLikelihood.Guilds.Conditional'></span>

<h3>Description</h3>

<p>This function calculates the likelihood of the guilds model, conditional on guild size; provided abundance data and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikelihood.Guilds.Conditional(parameters, model, sadx, sady, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.Guilds.Conditional_+3A_parameters">parameters</code></td>
<td>
<p><code>parameters</code> corresponds to a vector of parameter values depending on the provided model: <br />
- model: &quot;D0&quot; <code>parameters</code> = c(theta, alpha) <br />
- model: &quot;D1&quot; <code>parameters</code> = c(theta, alpha X, alpha Y) <br />
</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds.Conditional_+3A_model">model</code></td>
<td>
<p> The chosen model to calculate the likelihood for, please note that the vector of parameters should contain the corresponding parameters in the right order. The user can pick one of these models:<br />
-  &quot;D0&quot; <br />
-  &quot;D1&quot; <br />
</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds.Conditional_+3A_sadx">sadx</code></td>
<td>
<p> The Species Abundance Distribution of guild X</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds.Conditional_+3A_sady">sady</code></td>
<td>
<p> The Species Abundance Distribution of guild Y</p>
</td></tr>
<tr><td><code id="logLikelihood.Guilds.Conditional_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE flag, indicates whether intermediate output is shown on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the LogLikelihood</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleData &lt;- generate.Guilds.Cond(theta = 200,
                                    alpha_x = 0.005,
                                    alpha_y = 0.001,
                                    JX = 1000,
                                    JY = 2000)
#theta = 200, alpha X = 0.005, alpha Y = 0.001
parametervals &lt;- c(200, 0.005, 0.001)
LL = logLikelihood.Guilds.Conditional(parametervals,
                                      model="D1",
				                              exampleData$guildX,
				                              exampleData$guildY,
				                              verbose=TRUE)
</code></pre>

<hr>
<h2 id='maxLikelihood.ESF'>
Maximization of the loglikelihood given the standard Neutral Model, using the Etienne Sampling Formula
</h2><span id='topic+maxLikelihood.ESF'></span>

<h3>Description</h3>

<p>This function computes the maximum likelihood estimates of the parameters of the Neutral model, using the Etienne Sampling Formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLikelihood.ESF(init_vals, abund, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLikelihood.ESF_+3A_init_vals">init_vals</code></td>
<td>
<p>A vector of initial starting values, of the format c(theta, m)</p>
</td></tr>
<tr><td><code id="maxLikelihood.ESF_+3A_abund">abund</code></td>
<td>
<p>Vector containing a record of the number of individuals per species</p>
</td></tr>
<tr><td><code id="maxLikelihood.ESF_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE flag, indicates whether intermediate output is shown on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output is a list containing the following:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p> a vector containing the parameter values at the maximum likelihood c(theta, m)</p>
</td></tr>
<tr><td><code>fvalues</code></td>
<td>
<p> the likelihood at the corresponding parameter values</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p> gives a message on convergence of optimization; conv = 0 means convergence</p>
</td></tr> </table>
<p><br />
</p>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>References</h3>

<p>Etienne, R.S. (2005). A new sampling formula for neutral biodiversity. Ecology Letters, 8(3), 253-260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	A &lt;- c(1, 1, 1, 3, 5, 8)
	maxLikelihood.ESF( c(7, 0.1), abund = A)
</code></pre>

<hr>
<h2 id='maxLikelihood.Guilds'>
Maximization of the loglikelihood under the Guilds Model.
</h2><span id='topic+maxLikelihood.Guilds'></span>

<h3>Description</h3>

<p>This function computes the maximum likelihood estimates of the parameters of the guilds model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLikelihood.Guilds(init_vals, model = "D0",
                     sadx, sady, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLikelihood.Guilds_+3A_init_vals">init_vals</code></td>
<td>
<p><code>init_vals</code> corresponds to a vector of parameter values in which to start the Maxmimum Likelihood algorithm, depending on the provided model: <br />
- model: &quot;D0&quot; <code>parameters</code> = c(theta, alpha) <br />
- model: &quot;D1&quot; <code>parameters</code> = c(theta, alpha X, alpha Y) <br />
</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds_+3A_model">model</code></td>
<td>
<p> The chosen model to calculate the maximum likelihood for, please note that the vector of parameters should contain the corresponding parameters in the right order. The user can pick one of these models:<br />
-  &quot;D0&quot; <br />
-  &quot;D1&quot; <br />
</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds_+3A_sadx">sadx</code></td>
<td>
<p> The Species Abundance Distribution of guild X</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds_+3A_sady">sady</code></td>
<td>
<p> The Species Abundance Distribution of guild Y</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE flag, indicates whether intermediate output is shown on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list containing the following:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>a vector containing the parameter values at the maximum likelihood</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the likelihood at the corresponding parameter values</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Number of function evaluations required</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>-2:  invalid input<br />
-1:  number of maximum function evaluations exceeded <br />
0:  success: convergence <br />
1:  limit of machine precision reached <br />
</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving a diagnostic message from the optimizer,</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian matrix (not implemented for this package)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  J &lt;- 10000

  theta &lt;- 100
  alpha_x &lt;- 0.1

  simul_data &lt;- generate.Guilds(theta, alpha_x, alpha_x, J)

  #initial parameters for the D0 model c(theta,alpha)
  LL &lt;- maxLikelihood.Guilds(init_vals = c(theta, alpha_x),
                             model = "D0",
                             sadx  = simul_data$guildX,
                             sady  = simul_data$guildY)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxLikelihood.Guilds.Conditional'>
Maximization of the loglikelihood under the Guilds Model, conditioned on guild size.
</h2><span id='topic+maxLikelihood.Guilds.Conditional'></span>

<h3>Description</h3>

<p>This function computes the maximum likelihood estimates of the parameters of the guilds model, conditioned on guild size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLikelihood.Guilds.Conditional(init_vals, model, sadx, sady, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLikelihood.Guilds.Conditional_+3A_init_vals">init_vals</code></td>
<td>
<p><code>init_vals</code> corresponds to a vector of parameter values in which to start the Maxmimum Likelihood algorithm, depending on the provided model: <br />
- model: &quot;D0&quot; <code>parameters</code> = c(theta, alpha) <br />
- model: &quot;D1&quot; <code>parameters</code> = c(theta, alpha X, alpha Y) <br />
</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds.Conditional_+3A_model">model</code></td>
<td>
<p> The chosen model to calculate the maximum likelihood for, please note that the vector of parameters should contain the corresponding parameters in the right order. The user can pick one of these models:<br />
-  &quot;D0&quot; <br />
-  &quot;D1&quot; <br />
</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds.Conditional_+3A_sadx">sadx</code></td>
<td>
<p> The Species Abundance Distribution of guild X</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds.Conditional_+3A_sady">sady</code></td>
<td>
<p> The Species Abundance Distribution of guild Y</p>
</td></tr>
<tr><td><code id="maxLikelihood.Guilds.Conditional_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE flag, indicates whether intermediate output is shown on screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list containing the following:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>a vector containing the parameter values at the maximum likelihood</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the likelihood at the corresponding parameter values</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Number of function evaluations required</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>-2:  invalid input<br />
-1:  number of maximum function evaluations exceeded <br />
0:  success: convergence <br />
1:  limit of machine precision reached <br />
</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving a diagnostic message from the optimizer,</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian matrix (not implemented for this package)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta = 20
alpha = 0.1
initParams &lt;- c(theta, alpha)
maxLikelihood.Guilds.Conditional(initParams,
                                 model = "D0",
                                 sadx  = 1:20,
                                 sady  = 1:20,
                                 verbose = TRUE)
</code></pre>

<hr>
<h2 id='preston_plot'>
Barplot in Preston style of an abundance dataset
</h2><span id='topic+preston_plot'></span>

<h3>Description</h3>

<p>This function first sorts abundances into octaves, and then plots the resulting distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  preston_plot(abund, expected, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preston_plot_+3A_abund">abund</code></td>
<td>
<p>vector containing the number of individuals per species</p>
</td></tr>
<tr><td><code id="preston_plot_+3A_expected">expected</code></td>
<td>
<p>vector containing the expected number of species per octave</p>
</td></tr>
<tr><td><code id="preston_plot_+3A_...">...</code></td>
<td>
<p>further graphical arguments that can be passed to <code>barplot()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thijs Janzen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  theta = 10
  m = 0.1
  J = 1000
  I = m * (J - 1) / (1 - m)
  
  abund &lt;- generate.ESF(theta, I, J)
  par(mfrow = c(1,2))
  preston_plot(abund)
  abund.expect &lt;- expected.SAD(theta, m, J)
  preston_plot(abund, abund.expect)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
