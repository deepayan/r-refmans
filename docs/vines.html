<!DOCTYPE html><html><head><title>Help for package vines</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vines}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#h-methods'><p>Methods for the h-functions</p></a></li>
<li><a href='#hinverse-methods'><p>Methods for the Inverse of the h-functions</p></a></li>
<li><a href='#RVine-classes'><p>Classes for Regular Vines</p></a></li>
<li><a href='#Vine'><p>Create Vine Objects</p></a></li>
<li><a href='#Vine-class'><p>Base Vine Class</p></a></li>
<li><a href='#Vine-distribution'><p>Vine Distribution Functions</p></a></li>
<li><a href='#vineFit'><p>Vine Inference</p></a></li>
<li><a href='#vineFit-class'><p>Class for the Results of Vine Inference</p></a></li>
<li><a href='#vineFitML-class'><p>Class for the Results of Vine Inference by Maximum Likelihood</p></a></li>
<li><a href='#vineGoF'><p>Vine Goodness-of-fit Tests</p></a></li>
<li><a href='#vineGoF-class'><p>Class for the Results of Vine Goodness-of-fit Tests</p></a></li>
<li><a href='#vineLogLik'><p>Vine Log-likelihood Evaluation</p></a></li>
<li><a href='#vineOrder'><p>Select an Order of the Variables</p></a></li>
<li><a href='#vineParameters'><p>Parameters of a Vine</p></a></li>
<li><a href='#vinePIT-methods'><p>Vine Probability Integral Transform Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Dependence Modeling with Vines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the vine graphical model for building
    high-dimensional probability distributions as a factorization of
    bivariate copulas and marginal density functions. This package
    provides S4 classes for vines (C-vines and D-vines) and methods
    for inference, goodness-of-fit tests, density/distribution
    function evaluation, and simulation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yasserglez/vines">https://github.com/yasserglez/vines</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, copula</td>
</tr>
<tr>
<td>Imports:</td>
<td>ADGofTest, cubature, TSP</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Collate:</td>
<td>h.R hinverse.R Vine.R show.R dimnames.R vineParameters.R
vineIter.R vineFit.R vineFitML.R vinePIT.R vineGoF.R
vineOrder.R dvine.R pvine.R rvine.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-07-28 07:04:41 UTC; yasserglez</td>
</tr>
<tr>
<td>Author:</td>
<td>Yasser Gonzalez-Fernandez [aut, cre],
  Marta Soto [aut],
  Joris Meys [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yasser Gonzalez-Fernandez &lt;ygonzalezfernandez@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-07-28 11:49:43</td>
</tr>
</table>
<hr>
<h2 id='h-methods'>Methods for the h-functions</h2><span id='topic+h'></span><span id='topic+h-methods'></span><span id='topic+h+2Ccopula-method'></span><span id='topic+h+2CindepCopula-method'></span><span id='topic+h+2CnormalCopula-method'></span><span id='topic+h+2CtCopula-method'></span><span id='topic+h+2CclaytonCopula-method'></span><span id='topic+h+2CgumbelCopula-method'></span><span id='topic+h+2CfgmCopula-method'></span><span id='topic+h+2CfrankCopula-method'></span><span id='topic+h+2CgalambosCopula-method'></span>

<h3>Description</h3>

<p>The <code class="reqn">h</code> function represents the conditional distribution function of a
bivariate copula and it should be defined for every copula used in
a pair-copula construction. It is defined as the partial derivative of the
distribution function of the copula w.r.t. the second argument
<code class="reqn">h(x,v) = F(x|v) = \partial C(x,v) / \partial v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h(copula, x, v, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h-methods_+3A_copula">copula</code></td>
<td>
<p>A bivariate <code><a href="copula.html#topic+copula-class">copula</a></code> object.</p>
</td></tr>
<tr><td><code id="h-methods_+3A_x">x</code></td>
<td>
<p>Numeric vector with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="h-methods_+3A_v">v</code></td>
<td>
<p>Numeric vector with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="h-methods_+3A_eps">eps</code></td>
<td>
<p>To avoid numerical problems for extreme values, the values of
<code>x</code>, <code>v</code> and return values close to <code>0</code> and <code>1</code> are
substituted by <code>eps</code> and <code>1 - eps</code>, respectively. The default
<code>eps</code> value for most of the copulas is <code>.Machine$double.eps^0.5</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(copula = "copula")</code></dt><dd>
<p>Default definition of the <code class="reqn">h</code> function for a bivariate copula.
This method is used if no particular definition is given for a copula.
The partial derivative is calculated numerically using the
<code><a href="stats.html#topic+numericDeriv">numericDeriv</a></code> function.</p>
</dd>
<dt><code>signature(copula = "indepCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the independence copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v) = x</code>
</p>
</dd>
<dt><code>signature(copula = "normalCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the normal copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \rho) =
      \Phi \left( \frac{\Phi^{-1}(x) - \rho\ \Phi^{-1}(v)}
                       {\sqrt{1-\rho^2}} \right)</code>
</p>
</dd>
<dt><code>signature(copula = "tCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the t copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \rho, \nu) =
      t_{\nu+1} \left( \frac{t^{-1}_{\nu}(x) - \rho\ t^{-1}_{\nu}(v)}
                            {\sqrt{\frac{(\nu+(t^{-1}_{\nu}(v))^2)(1-\rho^2)}
                                        {\nu+1}}} \right)</code>
</p>
</dd>
<dt><code>signature(copula = "claytonCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the Clayton copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \theta) = v^{-\theta-1}(x^{-\theta}+v^{-\theta}-1)^{-1-1/\theta}</code>
</p>
</dd>
<dt><code>signature(copula = "gumbelCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the Gumbel copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \theta) = C(x, v; \theta)\ \frac{1}{v}\ (-\log v)^{\theta-1}
                            \left((-\log x)^{\theta} + (-\log v)^{\theta} \right)^{1/\theta-1}</code>
</p>
</dd>
<dt><code>signature(copula = "fgmCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the Farlie-Gumbel-Morgenstern copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \theta) =
      (1 + \theta \ (-1 + 2v) \ (-1 + x)) \ x</code>
</p>
</dd>
<dt><code>signature(copula = "frankCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the Frank copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \theta) =
      \frac{e^{-\theta v}}
           {\frac{1 - e^{-\theta}}{1 - e^{-\theta x}} + e^{-\theta v} - 1}</code>
</p>
</dd>
<dt><code>signature(copula = "galambosCopula")</code></dt><dd>
<p>The <code class="reqn">h</code> function of the Galambos copula.
</p>
<p style="text-align: center;"><code class="reqn">h(x, v; \theta) =
      \frac{C(x, v; \theta)}{v}
      \left( 1 - \left[ 1 + \left(\frac{-\log v}{-\log x}\right)^{\theta} \right]^{-1-1/\theta} \right)</code>
</p>
</dd>
</dl>



<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Schirmacher, D. and Schirmacher, E. (2008)
Multivariate dependence modeling using pair-copulas.
<em>Enterprise Risk Management Symposium, Chicago</em>.
</p>

<hr>
<h2 id='hinverse-methods'>Methods for the Inverse of the h-functions</h2><span id='topic+hinverse'></span><span id='topic+hinverse-methods'></span><span id='topic+hinverse+2Ccopula-method'></span><span id='topic+hinverse+2CindepCopula-method'></span><span id='topic+hinverse+2CnormalCopula-method'></span><span id='topic+hinverse+2CtCopula-method'></span><span id='topic+hinverse+2CclaytonCopula-method'></span><span id='topic+hinverse+2CfrankCopula-method'></span>

<h3>Description</h3>

<p>The <code class="reqn">h^{-1}</code> function represents the inverse of the <code class="reqn">h</code> function with
respect to its first argument. It should be defined for every copula used
in a pair-copula construction (or it will be evaluated numerically).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hinverse(copula, u, v, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hinverse-methods_+3A_copula">copula</code></td>
<td>
<p>A bivariate <code><a href="copula.html#topic+copula-class">copula</a></code> object.</p>
</td></tr>
<tr><td><code id="hinverse-methods_+3A_u">u</code></td>
<td>
<p>Numeric vector with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="hinverse-methods_+3A_v">v</code></td>
<td>
<p>Numeric vector with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="hinverse-methods_+3A_eps">eps</code></td>
<td>
<p>To avoid numerical problems for extreme values, the values of
<code>u</code>, <code>v</code> and return values close to <code>0</code> and <code>1</code> are
substituted by <code>eps</code> and <code>1 - eps</code>, respectively. The default
<code>eps</code> value for most of the copulas is <code>.Machine$double.eps^0.5</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(copula = "copula")</code></dt><dd>
<p>Default definition of the <code class="reqn">h^{-1}</code> function for a bivariate copula.
This method is used if no particular definition is given for a copula.
The inverse is calculated numerically using the <code><a href="stats.html#topic+uniroot">uniroot</a></code>
function.</p>
</dd>
<dt><code>signature(copula = "indepCopula")</code></dt><dd>
<p>The <code class="reqn">h^{-1}</code> function of the Independence copula.
</p>
<p style="text-align: center;"><code class="reqn">h^{-1}(u, v) = u</code>
</p>
</dd>
<dt><code>signature(copula = "normalCopula")</code></dt><dd>
<p>The <code class="reqn">h^{-1}</code> function of the normal copula.
</p>
<p style="text-align: center;"><code class="reqn">h^{-1}(u, v; \rho) = \Phi \left( \Phi^{-1}(u) \sqrt{1-\rho^2} +
                                           \rho\ \Phi^{-1}(v) \right)</code>
</p>
</dd>
<dt><code>signature(copula = "tCopula")</code></dt><dd>
<p>The <code class="reqn">h^{-1}</code> function of the t copula.
</p>
<p style="text-align: center;"><code class="reqn">h^{-1}(u, v; \rho, \nu) =
      t_{\nu} \left( t^{-1}_{\nu+1}(u)\
                     \sqrt{\frac{(\nu+(t^{-1}_{\nu}(v))^2)(1-\rho^2)}{\nu+1}} +
                     \rho\ t^{-1}_{\nu}(v)
              \right)</code>
</p>
</dd>
<dt><code>signature(copula = "claytonCopula")</code></dt><dd>
<p>The <code class="reqn">h^{-1}</code> function of the Clayton copula.
</p>
<p style="text-align: center;"><code class="reqn">h^{-1}(u, v; \theta) =
      \left( \left( u\ v^{\theta+1}\right)^{-\frac{\theta}{\theta+1}} +
                    1 - v^{-\theta} \right)^{-1/\theta}</code>
</p>
</dd>
<dt><code>signature(copula = "frankCopula")</code></dt><dd>
<p>The <code class="reqn">h^{-1}</code> function of the Frank copula.
</p>
<p style="text-align: center;"><code class="reqn">h^{-1}(u, v; \theta) =
      -\log \left( 1 - \frac{1-e^{-\theta}}
                            {(u^{-1} - 1) e^{-\theta v} + 1} \right) / \theta</code>
</p>
</dd>
</dl>



<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Schirmacher, D. and Schirmacher, E. (2008)
Multivariate dependence modeling using pair-copulas.
<em>Enterprise Risk Management Symposium, Chicago</em>.
</p>

<hr>
<h2 id='RVine-classes'>Classes for Regular Vines</h2><span id='topic+RVine-class'></span><span id='topic+CVine-class'></span><span id='topic+show+2CCVine-method'></span><span id='topic+DVine-class'></span><span id='topic+show+2CDVine-method'></span>

<h3>Description</h3>

<p>Extend the <code><a href="#topic+Vine-class">Vine</a></code> class to represent regular vines.
</p>


<h3>Slots</h3>

<p>See <code><a href="#topic+Vine-class">Vine</a></code> for information about the inherited slots.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "CVine")</code>:
Print a textual representation of the C-vine.</p>
</dd>
</dl>


<dl>
<dt>show</dt><dd><p><code>signature(object = "DVine")</code>:
Print a textual representation of the D-vine.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Vine-class">Vine</a></code>.
</p>

<hr>
<h2 id='Vine'>Create Vine Objects</h2><span id='topic+Vine'></span><span id='topic+CVine'></span><span id='topic+DVine'></span>

<h3>Description</h3>

<p>Functions to create <code><a href="#topic+Vine-class">Vine</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vine(type, dimension = 2, trees = dimension - 1,
     copulas = matrix(list(indepCopula()), 
                      dimension - 1, dimension - 1))
CVine(dimension = 2, trees = dimension - 1,
      copulas = matrix(list(indepCopula()), 
                       dimension - 1, dimension - 1))
DVine(dimension = 2, trees = dimension - 1,
      copulas = matrix(list(indepCopula()), 
                       dimension - 1, dimension - 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vine_+3A_type">type</code></td>
<td>
<p>Type of vine. Supported values: <code>"CVine"</code> and <code>"DVine"</code>.</p>
</td></tr>
<tr><td><code id="Vine_+3A_dimension">dimension</code></td>
<td>
<p>See the documentation of the <code><a href="#topic+Vine-class">Vine</a></code> slot.</p>
</td></tr>
<tr><td><code id="Vine_+3A_trees">trees</code></td>
<td>
<p>See the documentation of the <code><a href="#topic+Vine-class">Vine</a></code> slot.</p>
</td></tr>
<tr><td><code id="Vine_+3A_copulas">copulas</code></td>
<td>
<p>See the documentation of the <code><a href="#topic+Vine-class">Vine</a></code> slot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Vine-class">Vine</a></code>,
<code><a href="#topic+CVine-class">CVine</a></code>,
<code><a href="#topic+DVine-class">DVine</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 3
copulas &lt;- matrix(list(normalCopula(0.5),
                       claytonCopula(2.75),
                       tCopula(0.75, df = 2),
                       NULL),
                  ncol = dimension - 1,
                  nrow = dimension - 1,
                  byrow = TRUE)

Vine("DVine", dimension = dimension, trees = dimension - 1,
     copulas = copulas)
DVine(dimension = dimension, trees = dimension - 1,
      copulas = copulas)
</code></pre>

<hr>
<h2 id='Vine-class'>Base Vine Class</h2><span id='topic+Vine-class'></span><span id='topic+show+2CVine-method'></span><span id='topic+dimnames+3C-+2CVine+2CANY-method'></span><span id='topic+dimnames+3C-+2CVine-method'></span><span id='topic+dimnames+2CVine-method'></span>

<h3>Description</h3>

<p>Base class of all classes that implement vine models in the package. 
It is a virtual class, no objects may be created from it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>. Descriptive name of 
the type of vine: Canonical vine or D-vine.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Dimension of the vine.</p>
</dd>
<dt><code>dimensionNames</code>:</dt><dd><p>Object of class <code>"character"</code>. Names of the 
variables of the vine. It is either an empty character vector or a vector
with one element for each variable of the vine.</p>
</dd>
<dt><code>copulas</code>:</dt><dd><p>Object of class <code>"matrix"</code>. It contains the 
<code><a href="copula.html#topic+copula-class">copula</a></code> objects for each copula in the pair-copula
decomposition. The indexes of the matrix follow the notation used for the 
subscripts of <code class="reqn">\Theta</code> in (Aas et al., 2009).</p>
</dd>
<dt><code>trees</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Number of dependence 
trees of the vine. It should be an integer between <code>0</code> and 
<code>dimension - 1</code>, including both endpoints. Functions acting on
vines assume that copulas in arcs of all trees greater than <code>trees</code> 
are independence copulas.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "Vine")</code>: 
Print a textual representation of the vine.</p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "Vine")</code>: 
Retrieve the names of the variables of the vine.</p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "Vine")</code>: 
Set the names of the variables of the vine.</p>
</dd>
</dl>



<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVine-class">RVine</a></code>,
<code><a href="#topic+CVine-class">CVine</a></code>,
<code><a href="#topic+DVine-class">DVine</a></code>.
</p>

<hr>
<h2 id='Vine-distribution'>Vine Distribution Functions</h2><span id='topic+dvine'></span><span id='topic+dvine-methods'></span><span id='topic+dvine+2CCVine-method'></span><span id='topic+dvine+2CDVine-method'></span><span id='topic+pvine'></span><span id='topic+pvine-methods'></span><span id='topic+pvine+2CCVine-method'></span><span id='topic+pvine+2CDVine-method'></span><span id='topic+rvine'></span><span id='topic+rvine-methods'></span><span id='topic+rvine+2CCVine-method'></span><span id='topic+rvine+2CDVine-method'></span>

<h3>Description</h3>

<p>Density evaluation, distribution function evaluation, and random number generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvine(vine, u)
pvine(vine, u)
rvine(vine, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vine-distribution_+3A_vine">vine</code></td>
<td>
<p>A <code><a href="#topic+Vine-class">Vine</a></code> object.</p>
</td></tr>
<tr><td><code id="Vine-distribution_+3A_u">u</code></td>
<td>
<p>Vector of the same dimension of the vine or a matrix with one column
for each variable of the vine.</p>
</td></tr>
<tr><td><code id="Vine-distribution_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of the <code>dvine</code> function for <code><a href="#topic+CVine-class">CVine</a></code>
and <code><a href="#topic+DVine-class">DVine</a></code> objects is based on the Algorithms 3 and 4 
of (Aas et al. 2009), respectively.
</p>
<p>The <code>pvine</code> function is evaluated through the numerical integration of 
the density function (using the <code><a href="cubature.html#topic+cubature">cubature</a></code> package). This is a 
computationally demanding procedure, even for small dimensions.
</p>
<p>The implementation of the <code>rvine</code> function for <code><a href="#topic+CVine-class">CVine</a></code> 
and <code><a href="#topic+DVine-class">DVine</a></code> objects is based on the Algorithms 1 and 2 
of (Aas et al. 2009), respectively.
</p>


<h3>Value</h3>

<p><code>dnorm</code> returns a vector with the evaluation of the density.
<code>pnorm</code> returns a vector with the evaluation of the distribution 
function. <code>rvine</code> returns a matrix with one column for each variable
of the vine and one row for each observation.
</p>


<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Bedford, T. and Cooke, R. M. (2001) Monte Carlo simulation of vine
dependent random variables for applications in uncertainty analysis. 
In <em>2001 Proceedings of ESREL2001, Turin, Italy</em>.
</p>
<p>Bedford, T. and Cooke, R. M. (2001) Probability density decomposition 
for conditionally dependent random variables modeled by vines. 
<em>Annals of Mathematics and Artificial Intelligence</em> <b>32</b>,
245&ndash;268.
</p>
<p>Kurowicka, D. and Cooke, R. M. (2005) Sampling algorithms for generating 
joint uniform distributions using the vine-copula method. In <em>3rd 
IASC World Conference on Computational Statistics &amp; Data Analysis, 
Limassol, Cyprus</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 3
copulas &lt;- matrix(list(normalCopula(0.5), 
                       claytonCopula(2.75),
                       tCopula(0.75, df = 2), 
                       NULL),
                  ncol = dimension - 1, 
                  nrow = dimension - 1)
vine &lt;- DVine(dimension = dimension, trees = dimension - 1,
              copulas = copulas)
dimnames(vine) &lt;- c("A", "B", "C")

data &lt;- rvine(vine, 1)
dvine(vine, data)
pvine(vine, data)
</code></pre>

<hr>
<h2 id='vineFit'>Vine Inference</h2><span id='topic+vineFit'></span>

<h3>Description</h3>

<p>Estimate a vine model from multivariate data in the unit hypercube. Data can be 
pseudo-observations constructed from empirical or parametric marginal cumulative 
distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vineFit(type, data, method = "ml", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vineFit_+3A_type">type</code></td>
<td>
<p>Type of vine. Supported values: <code>"CVine"</code> and <code>"DVine"</code>.</p>
</td></tr>
<tr><td><code id="vineFit_+3A_data">data</code></td>
<td>
<p>Data matrix of pseudo-observations.</p>
</td></tr>
<tr><td><code id="vineFit_+3A_method">method</code></td>
<td>
<p>Inference method. Supported values: 
<code>"ml"</code> (Maximum Likelihood).</p>
</td></tr>
<tr><td><code id="vineFit_+3A_...">...</code></td>
<td>
<p>Additional arguments for the inference method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"ml"</code> (Maximum Likelihood) method starts with the sequential estimation
procedure described in (Aas et al., 2009) and then executes a numerical
maximization of the full log-likelihood of the vine. The sequential procedure
is used to determine the family and the initial values of the parameters of 
each bivariate copula in the decomposition. Additional arguments for this 
method are:
</p>

<dl>
<dt><code>selectCopula</code></dt><dd><p>Function provided by the user to select the
copulas in the pair-copula construction. This function should return 
a <code><a href="copula.html#topic+copula-class">copula</a></code> object and expect the following arguments.
</p>

<dl>
<dt><code>vine</code></dt><dd><p>Vine object being constructed.</p>
</dd>
<dt><code>j, i</code></dt><dd><p>Indexes of the copula under selection in the matrix of the
<code>copulas</code> slot of the vine.</p>
</dd>
<dt><code>x, y</code></dt><dd><p>Bivariate sample.</p>
</dd>
</dl>

<p>The default value is <code>function (vine, j, i, x, y) indepCopula()</code>
that assigns the independence copula to all the arcs of the vine.</p>
</dd>
<dt><code>trees</code></dt><dd><p>Maximum number of dependence trees of the vine. Independence
copulas will be used in all the arcs of the following trees. The final number
of dependence trees could be smaller because of the use of a truncation method. 
The default value is <code>ncol(data) - 1</code>.</p>
</dd>
<dt><code>truncMethod</code></dt><dd><p>Method used to automatically truncate the vine if
enough dependence is captured in a given number of trees. Supported methods
are <code>"AIC"</code> and <code>"BIC"</code>. See (Brechmann, 2010; Brechmann et al., 2010)
for information about these methods. The default value is <code>""</code> that
means no truncation.</p>
</dd>
<dt><code>optimMethod</code></dt><dd><p><code><a href="stats.html#topic+optim">optim</a></code> method used in the optimization
of the log-likelihood function. If <code>""</code> is specified the optimization
is disabled and the vine calculated using the sequential estimation procedure 
is returned. The default value is <code>"Nelder-Mead"</code>.</p>
</dd>
<dt><code>optimControl</code></dt><dd><p>List of control parameters for <code><a href="stats.html#topic+optim">optim</a></code>.
The default value is <code>list()</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+vineFit-class">vineFit</a></code> object or a subclass with specific 
information about inference method used. The <code>vine</code> slot of this object 
contains the fitted <code><a href="#topic+Vine-class">Vine</a></code> object.
</p>


<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Brechmann, E. C. (2010) Truncated and simplified regular vines 
and their applications. Diploma thesis. <em>Technische 
Universitaet Muenchen</em>.
</p>
<p>Brechmann, E. C. and Czado, C. and Aas, K. (2010) Truncated regular 
vines in high dimensions with application to financial data. 
<em>Norwegian Computing Center, NR</em>. Note SAMBA/60/10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CVine-class">CVine</a></code>,
<code><a href="#topic+DVine-class">DVine</a></code>,
<code><a href="#topic+vineFit-class">vineFit</a></code>,
<code><a href="#topic+vineFitML-class">vineFitML</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(5 * 100), ncol = 5, nrow = 100)
colnames(data) &lt;- c("A", "B", "C", "D", "E")

selectCopula &lt;- function (vine, j, i, x, y) {
    data &lt;- cbind(x, y)
    fit &lt;- fitCopula(normalCopula(), data, method = "itau")
    fit@copula
}
fit &lt;- vineFit("DVine", data, method = "ml", 
               selectCopula = selectCopula, 
               optimMethod = "")

show(fit)
show(fit@vine)
</code></pre>

<hr>
<h2 id='vineFit-class'>Class for the Results of Vine Inference</h2><span id='topic+vineFit-class'></span><span id='topic+show+2CvineFit-method'></span>

<h3>Description</h3>

<p>Base class of all classes providing information about vine inference. 
Objects of this class (or subclasses) are created by calling the 
<code><a href="#topic+vineFit">vineFit</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>vine</code>:</dt><dd><p>Object of class <code><a href="#topic+Vine-class">Vine</a></code>. Fitted vine.</p>
</dd>
<dt><code>observations</code>:</dt><dd><p>Object of class <code>numeric</code>. Number of 
observations in the sample.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>character</code>. Inference method.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "vineFit")</code>: 
Print the result of the vine inference.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+vineFit">vineFit</a></code>,
<code><a href="#topic+vineFitML-class">vineFitML</a></code>.
</p>

<hr>
<h2 id='vineFitML-class'>Class for the Results of Vine Inference by Maximum Likelihood</h2><span id='topic+vineFitML-class'></span><span id='topic+show+2CvineFitML-method'></span>

<h3>Description</h3>

<p>Extends the <code><a href="#topic+vineFit-class">vineFit</a></code> class to include information
about the Maximum Likelihood inference.
</p>


<h3>Slots</h3>

<p>See <code><a href="#topic+vineFit-class">vineFit</a></code> for information about inherited slots.
</p>

<dl>
<dt><code>optimMethod</code>:</dt><dd><p>Object of class <code>character</code>. 
<code><a href="stats.html#topic+optim">optim</a></code> method.</p>
</dd>
<dt><code>optimConv</code>:</dt><dd><p>Object of class <code>numeric</code>. <code><a href="stats.html#topic+optim">optim</a></code> 
convergence code (0 indicates successful completion).</p>
</dd>
<dt><code>startParams</code>:</dt><dd><p>Object of class <code>numeric</code>. Vector with the 
parameters of the copulas in the pair-copula construction calculated using 
the sequential estimation procedure.</p>
</dd>
<dt><code>finalParams</code>:</dt><dd><p>Object of class <code>numeric</code>. Vector with the 
parameters of the copulas in the pair-copula construction after the 
maximization of the log-likelihood.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "vineFitML")</code>: 
Print information about the fitted vine.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+vineFit-class">vineFit</a></code>,
<code><a href="#topic+vineFit">vineFit</a></code>,
<code><a href="#topic+vineParameters">vineParameters</a></code>.
</p>

<hr>
<h2 id='vineGoF'>Vine Goodness-of-fit Tests</h2><span id='topic+vineGoF'></span>

<h3>Description</h3>

<p>Goodness-of-fit tests to verify whether the dependence structure of a sample
is appropriately modeled by vine model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vineGoF(vine, data, method = "PIT", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vineGoF_+3A_vine">vine</code></td>
<td>
<p>A <code><a href="#topic+Vine-class">Vine</a></code> object.</p>
</td></tr>
<tr><td><code id="vineGoF_+3A_data">data</code></td>
<td>
<p>Data matrix of pseudo-observations.</p>
</td></tr>
<tr><td><code id="vineGoF_+3A_method">method</code></td>
<td>
<p>Goodness-of-fit method. Supported values: 
<code>"PIT"</code> (Probability Integral Transform).</p>
</td></tr>
<tr><td><code id="vineGoF_+3A_...">...</code></td>
<td>
<p>Additional arguments for the goodness-of-fit method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"PIT"</code> (Probability Integral Transform) method uses the 
<code><a href="#topic+vinePIT">vinePIT</a></code> function to transform the data into variables which 
are independent and Uniform(0,1) and then use a hypothesis 
test to verify whether the resulting variables are independent and 
Uniform(0,1). The additional parameter <code>statistic</code> specifies 
the test to be applied for this purpose.
</p>

<dl>
<dt><code>statistic</code></dt><dd><p>Statistic used to verify if the transformed variables
are independent and Uniform(0,1). The default value is <code>"Breymann"</code> 
and supported methods are:
</p>

<dl>
<dt><code>"Breymann"</code></dt><dd><p>Test proposed in the Section 7.1 of 
(Aas et al., 2009). See (Breymann et al., 2003) for more information.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+vineGoF-class">vineGoF</a></code> or a subclass with specific information about 
the goodness-of-fit method used. The <code>statistic</code> slot of this object 
contains the value of the statistic and <code>pvalue</code> the p-value.
</p>


<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Breymann, W. and Dias, A. and Embrechts, P. (2003) Dependence 
structures for multivariate high-frequency data in finance. 
<em>Quantitative Finance</em> <b>1</b>, 1&ndash;14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vineGoF-class">vineGoF</a></code>,
<code><a href="#topic+vinePIT">vinePIT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>copula &lt;- normalCopula(c(-0.25, -0.21, 0.34, 0.51, -0.07, -0.18), 
                       dispstr = "un", dim = 4)
data &lt;- rCopula(100, copula)

selectCopula &lt;- function (vine, j, i, x, y) {
    data &lt;- cbind(x, y)
    fit &lt;- fitCopula(normalCopula(), data, method = "itau")
    fit@copula
}
normalCVine &lt;- vineFit("CVine", data, method = "ml",
                       selectCopula = selectCopula,
                       optimMethod = "")@vine
normalDVine &lt;- vineFit("DVine", data, method = "ml",
                       selectCopula = selectCopula,
                       optimMethod = "")@vine
show(normalCVine)
show(normalDVine)

normalCVineGof &lt;- vineGoF(normalCVine, data, method = "PIT",
                          statistic = "Breymann")
normalDVineGof &lt;- vineGoF(normalDVine, data, method = "PIT",
                          statistic = "Breymann")
show(normalCVineGof)
show(normalDVineGof)
</code></pre>

<hr>
<h2 id='vineGoF-class'>Class for the Results of Vine Goodness-of-fit Tests</h2><span id='topic+vineGoF-class'></span><span id='topic+show+2CvineGoF-method'></span>

<h3>Description</h3>

<p>Base class of all classes containing information about vine goodness-of-fit 
tests. Objects of this class (or subclasses) are created by calling the 
<code><a href="#topic+vineGoF">vineGoF</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method</code>:</dt><dd><p>Object of class <code>character</code>.
Goodness-of-fit method.</p>
</dd>
<dt><code>statistic</code>:</dt><dd><p>Object of class <code>numeric</code>. 
Value of the test statistic.</p>
</dd>
<dt><code>pvalue</code>:</dt><dd><p>Object of class <code>numeric</code>. P-value.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "vineGoF")</code>: 
Print the result of the goodness-of-fit test.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+vineGoF">vineGoF</a></code>.
</p>

<hr>
<h2 id='vineLogLik'>Vine Log-likelihood Evaluation</h2><span id='topic+vineLogLik'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood of a <code><a href="#topic+Vine-class">Vine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vineLogLik(vine, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vineLogLik_+3A_vine">vine</code></td>
<td>
<p>A <code><a href="#topic+Vine-class">Vine</a></code> object.</p>
</td></tr>
<tr><td><code id="vineLogLik_+3A_data">data</code></td>
<td>
<p>Data matrix of pseudo-observations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 3
copulas &lt;- matrix(list(normalCopula(0.5), 
                       claytonCopula(2.75),
                       NULL, NULL),
                  ncol = dimension - 1,
                  nrow = dimension - 1,
                  byrow = TRUE)
vine &lt;- DVine(dimension = dimension, trees = 1, 
              copulas = copulas)

data &lt;- matrix(runif(dimension * 100), 
               ncol = dimension, nrow = 100)
               
vineLogLik(vine, data)
</code></pre>

<hr>
<h2 id='vineOrder'>Select an Order of the Variables</h2><span id='topic+vineOrder'></span>

<h3>Description</h3>

<p>Select an order of the variables. The order of the variables determines the 
bivariate dependencies that will be explicit modeled in the first tree of 
the vine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vineOrder(type, data, method = "greedy", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vineOrder_+3A_type">type</code></td>
<td>
<p>Type of vine. Supported values: <code>"CVine"</code> and <code>"DVine"</code>.</p>
</td></tr>
<tr><td><code id="vineOrder_+3A_data">data</code></td>
<td>
<p>Data matrix of pseudo-observations.</p>
</td></tr>
<tr><td><code id="vineOrder_+3A_method">method</code></td>
<td>
<p>Ordering method. Supported values: <code>"random"</code>, 
<code>"greedy"</code>.</p>
</td></tr>
<tr><td><code id="vineOrder_+3A_...">...</code></td>
<td>
<p>Additional arguments for the order method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In D-vines, the order of the variables determines the structure of 
all the trees of the vine. This is not the case for C-vines where 
the root node of each tree can be selected.
</p>
<p>The <code>"random"</code> method returns a random permutation of the variables.
</p>
<p>The <code>"greedy"</code> method returns an order of the variables that intends to
capture as much dependence as possible in the first tree of the vine. The
method finds the order of the variables that defines a tree that maximizes 
a given dependence measure used as edge weights. For C-vines, it is determined 
iteratively checking each variable as root node. For D-vines, it is equivalent 
to solve the traveling salesman problem (TSP), see (Brechmann, 2010) 
for details. The TSP is solved using the cheapest insertion algorithm
implemented by the <code><a href="TSP.html#topic+solve_TSP">solve_TSP</a></code> function of the <span class="pkg">TSP</span> package.
The following are additional parameters for this method.
</p>

<dl>
<dt><code>according</code></dt><dd><p>Dependence measure. The default value is 
<code>"kendall"</code> and supported values are:
</p>

<dl>
<dt><code>"kendall"</code></dt><dd><p>Absolute value of Kendall's <code class="reqn">\tau</code>.</p>
</dd>
<dt><code>"spearman"</code></dt><dd><p>Absolute value of Spearman's <code class="reqn">\rho</code>.</p>
</dd>
<dt><code>"pearson"</code></dt><dd><p>Absolute value of Pearson's product moment
correlation coefficient.</p>
</dd>
<dt><code>"df"</code></dt><dd><p>Smaller degrees of freedom of a bivariate t copula.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Value</h3>

<p>A vector with the ordered indexes of the variables. This vector should be 
used to reorder the variables of the <code>data</code> matrix.
</p>


<h3>References</h3>

<p>Brechmann, E. C. (2010) Truncated and simplified regular vines 
and their applications. Diploma thesis. <em>Technische 
Universitaet Muenchen</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(5 * 100), ncol = 5, nrow = 500)

vineOrder("CVine", data, method = "random")
vineOrder("DVine", data, method = "greedy",
          according = "spearman")
</code></pre>

<hr>
<h2 id='vineParameters'>Parameters of a Vine</h2><span id='topic+vineParameters'></span><span id='topic+vineParameters+3C-'></span>

<h3>Description</h3>

<p>Retrieve or set the parameters of a <code><a href="#topic+Vine-class">Vine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vineParameters(vine)
vineParameters(vine) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vineParameters_+3A_vine">vine</code></td>
<td>
<p>A <code><a href="#topic+Vine-class">Vine</a></code> object.</p>
</td></tr>
<tr><td><code id="vineParameters_+3A_value">value</code></td>
<td>
<p>Vector with the parameters of the copulas in the pair-copula 
construction. This vector is the result of the concatenation of the 
<code>parameters</code> slots of the <code><a href="copula.html#topic+copula-class">copula</a></code> objects in the 
<code>copulas</code> slot of the <code><a href="#topic+Vine-class">Vine</a></code> object (by rows).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 5
copulas &lt;- matrix(c(list(tCopula(-0.25, df = 2),
                         tCopula(-0.5, df = 4),
                         tCopula(0.25, df = 6),
                         tCopula(0.5, df = 8)),
                    rep(list(NULL), 12)),
                  ncol = dimension - 1, 
                  nrow = dimension - 1,
                  byrow = TRUE)
vine &lt;- DVine(dimension = dimension, trees = 1, 
              copulas = copulas)
dimnames(vine) &lt;- c("A", "B", "C", "D", "E")

vineParameters(vine)
show(vine)

vineParameters(vine) &lt;- c(-0.25, 3, -0.5, 5, 0.25, 7, 0.5, 9)

vineParameters(vine)
show(vine)
</code></pre>

<hr>
<h2 id='vinePIT-methods'>Vine Probability Integral Transform Methods</h2><span id='topic+vinePIT'></span><span id='topic+vinePIT-methods'></span><span id='topic+vinePIT+2CCVine-method'></span><span id='topic+vinePIT+2CDVine-method'></span>

<h3>Description</h3>

<p>Probability integral transform (PIT) of (Rosenblatt, 1952) for vine models. 
The PIT converts a set of dependent variables into a new set of variables 
which are independent and uniformly distributed in <code class="reqn">(0,1)</code> under the 
hypothesis that the data follows a given multivariate distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vinePIT(vine, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vinePIT-methods_+3A_vine">vine</code></td>
<td>
<p>A <code><a href="#topic+Vine-class">Vine</a></code> object.</p>
</td></tr>
<tr><td><code id="vinePIT-methods_+3A_u">u</code></td>
<td>
<p>Vector with one component for each variable of the vine or 
a matrix with one column for each variable of the vine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one column for each variable of the vine and one row for 
each observation.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(vine = "CVine")</code></dt><dd><p>PIT algorithm for
<code><a href="#topic+CVine-class">CVine</a></code> objects based on the Algorithm 5 of
(Aas et al., 2009).</p>
</dd>
<dt><code>signature(vine = "DVine")</code></dt><dd><p>PIT algorithm for
<code><a href="#topic+DVine-class">DVine</a></code> objects based on the Algorithm 6 of
(Aas et al., 2009).</p>
</dd>
</dl>


<h3>References</h3>

<p>Aas, K. and Czado, C. and Frigessi, A. and Bakken, H. (2009)
Pair-copula constructions of multiple dependence.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 182&ndash;198.
</p>
<p>Rosenblatt, M. (1952) Remarks on multivariate transformation.
<em>Annals of Mathematical Statistics</em> <b>23</b>, 1052&ndash;1057.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vinePIT">vinePIT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimension &lt;- 3
copulas &lt;- matrix(list(normalCopula(0.5), 
                       claytonCopula(2.75),
                       NULL, NULL),
                  ncol = dimension - 1,
                  nrow = dimension - 1,
                  byrow = TRUE)
vine &lt;- CVine(dimension = dimension, trees = 1,
              copulas = copulas)

data &lt;- matrix(runif(dimension * 100), 
               ncol = dimension, nrow = 100)

vinePIT(vine, data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
