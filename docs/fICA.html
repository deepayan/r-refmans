<!DOCTYPE html><html><head><title>Help for package fICA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fICA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt_fICA'>
<p>Adaptive Deflation-based FastICA Method for Independent Component Analysis</p></a></li>
<li><a href='#compute_alphas'>
<p>Estimation of Alphas in the Asymptotic Covariance Matrix of the Deflation-based FastICA Estimator</p></a></li>
<li><a href='#fICA'>
<p>Symmetric and Deflation-based FastICA Methods for Independent Component Analysis</p></a></li>
<li><a href='#fICA-package'>
<p>Classical, Reloaded and Adaptive FastICA Algorithms</p></a></li>
<li><a href='#nonlinearities'>
<p>Set of Nonlinearities for Adaptive Deflation-based FastICA Method</p></a></li>
<li><a href='#reloaded_fICA'>
<p>Reloaded Deflation-based FastICA Method for Independent Component Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classical, Reloaded and Adaptive FastICA Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-08</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, JADE, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BSSasymp</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for classical symmetric and deflation-based FastICA, reloaded deflation-based FastICA algorithm and an algorithm for adaptive deflation-based FastICA using multiple nonlinearities. For details, see Miettinen et al. (2014) &lt;<a href="https://doi.org/10.1109%2FTSP.2014.2356442">doi:10.1109/TSP.2014.2356442</a>&gt; and Miettinen et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.sigpro.2016.08.028">doi:10.1016/j.sigpro.2016.08.028</a>&gt;. The package is described in Miettinen, Nordhausen and Taskinen (2018) &lt;<a href="https://doi.org/10.32614%2FRJ-2018-046">doi:10.32614/RJ-2018-046</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-08 06:57:20 UTC; knordhau</td>
</tr>
<tr>
<td>Author:</td>
<td>Jari Miettinen <a href="https://orcid.org/0000-0002-3270-7014"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hannu Oja [aut],
  Sara Taskinen <a href="https://orcid.org/0000-0001-9470-7258"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klaus.k.nordhausen@jyu.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-08 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt_fICA'>
Adaptive Deflation-based FastICA Method for Independent Component Analysis
</h2><span id='topic+adapt_fICA'></span><span id='topic+adapt_fICA.default'></span>

<h3>Description</h3>

<p>The adaptive deflation-based FastICA method for the independent component problem. The function estimates the unmixing matrix by finding, for each component separately, the best nonlinearity from a set of nonlinearities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_fICA(X, gs=gf, dgs=dgf, name=gnames, kj=0, inR=TRUE, 
           eps=1e-06, maxiter=100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_fICA_+3A_x">X</code></td>
<td>
<p>a numeric data matrix. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_gs">gs</code></td>
<td>
<p>a list of functions containing the nonlinearities.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_dgs">dgs</code></td>
<td>
<p>a list of functions containing the first derivatives of the nonlinearities.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_name">name</code></td>
<td>
<p>a list of strings containing the names of the nonlinearities.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_kj">kj</code></td>
<td>
<p>defines the initial estimate of the unmixing matrix, see details.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_inr">inR</code></td>
<td>
<p>a logical which indicates whether R or C is used for computations. If FALSE, the default set of nonlinearities <a href="#topic+gf">gf</a> is used.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="adapt_fICA_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The algorithm first finds initial estimates of the sources. The method to find the estimates is decided by the choice of the argument <code>kj</code>. If the value of <code>kj</code> is an integer between 1 and number of the sources, then the method is <code>kj</code>-JADE, otherwise it is FOBI. 
For the meaning of the value <code>kj</code> used as <code>kj</code>-JADE, see the help for <code><a href="JADE.html#topic+k_JADE">k_JADE</a></code>.
</p>


<h3>Value</h3>

<p>A list with class 'bss' containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>gs</code></td>
<td>
<p>nonlinearities that were available.</p>
</td></tr>
<tr><td><code>used_gs</code></td>
<td>
<p>nonlinearities, in order of appearance, that were used. The last row of the unmixing matrix follows directly from the other rows, and hence no nonlinearity is connected to it.</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>the statistics for the choice of the nonlinearities.</p>
</td></tr>
<tr><td><code>init_est</code></td>
<td>
<p>method that was used for the initial estimate (FOBI or k-JADE).</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>estimated source components standardized to have mean 0 and unit variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jari Miettinen</p>


<h3>References</h3>

<p><cite>Hyvarinen, A. and Oja, E. (1997), A fast fixed-point algorithm for independent component analysis, <em>Neural Computation</em>, vol. 9, 1483&ndash;1492.</cite>
</p>
<p><cite>Nordhausen, K., Ilmonen, P., Mandal, A., Oja, H. and Ollila, E. (2011), Deflation-based FastICA reloaded,
in <em>Proc. &quot;19th European Signal Processing Conference 2011 (EUSIPCO 2011)&quot;,</em> Barcelona, 1854&ndash;1858.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Oja, H. and Taskinen, S. (2014), Deflation-based FastICA with adaptive choices of nonlinearities, <em>IEEE Transactions on Signal Processing</em>, 62(21), 5716&ndash;5724.</cite>
</p>


<h3>See Also</h3>

<p><a href="#topic+fICA">fICA</a>, <a href="#topic+nonlinearities">nonlinearities</a>, <a href="JADE.html#topic+FOBI">FOBI</a>, <a href="JADE.html#topic+k_JADE">k_JADE</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(9),3,3)
s1 &lt;- rt(1000,6)
s2 &lt;- rexp(1000,1)
s3 &lt;- runif(1000)

S &lt;- cbind(s1,s2,s3)
X &lt;- S %*% t(A)

res1&lt;-adapt_fICA(X, inR=FALSE)
res1
coef(res1)
plot(res1) 

require(JADE)
MD(coef(res1),A)

# changing the set of candidate nonlinearities

?nonlinearities
g &lt;- function(x){x^2}
dg &lt;- function(x){2*x}
gf_new &lt;- c(gf[-c(5,8,10)],g)
dgf_new &lt;- c(dgf[-c(5,8,10)],g)
gnames_new &lt;- c(gnames[-c(5,8,10)],"skew")

res2&lt;-adapt_fICA(X, gs=gf_new, dgs=dgf_new, name=gnames_new)
res2
MD(coef(res2),A)

# reloaded FastICA using tanh

res3&lt;-adapt_fICA(X, gs=gf[2], dgs=dgf[2], name=gnames[2])
res3
MD(coef(res3),A)
</code></pre>

<hr>
<h2 id='compute_alphas'>
Estimation of Alphas in the Asymptotic Covariance Matrix of the Deflation-based FastICA Estimator
</h2><span id='topic+compute_alphas'></span>

<h3>Description</h3>

<p>Using the estimates of the independent components, the function computes for a given set of nonlinearities, the quantities (alphas). Alphas determine the choices of the nonlinearities and in which order the nonlinearities are used in the adaptive deflation-based FastICA method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_alphas(Z, gs=gf, dgs=dgf, name=gnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_alphas_+3A_z">Z</code></td>
<td>
<p>a numeric matrix of the estimated independent components, which should be standardized so that the mean is zero and the covariance matrix is the identity matrix.</p>
</td></tr>
<tr><td><code id="compute_alphas_+3A_gs">gs</code></td>
<td>
<p>a vector of functions containing the nonlinearities.</p>
</td></tr>
<tr><td><code id="compute_alphas_+3A_dgs">dgs</code></td>
<td>
<p>a vector of functions containing the first derivatives of the nonlinearities.</p>
</td></tr>
<tr><td><code id="compute_alphas_+3A_name">name</code></td>
<td>
<p>a vector of strings containing the names of the nonlinearities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references.</p>


<h3>Value</h3>

<p>A matrix where the ith row gives the estimates of alphas for the ith nonlinearity and the jth column corresponds to the jth component of <code>Z</code>.</p>


<h3>Author(s)</h3>

<p>Jari Miettinen</p>


<h3>References</h3>

<p><cite>Hyvarinen, A. and Oja, E. (1997), A fast fixed-point algorithm for independent component analysis, <em>Neural Computation</em>, vol. 9, 1483&ndash;1492.</cite>
</p>
<p><cite>Nordhausen, K., Ilmonen, P., Mandal, A., Oja, H. and Ollila, E. (2011), Deflation-based FastICA reloaded,
in <em>Proc. &quot;19th European Signal Processing Conference 2011 (EUSIPCO 2011)&quot;,</em> Barcelona, 1854&ndash;1858.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Oja, H. and Taskinen, S. (2014), Deflation-based FastICA with adaptive choices of nonlinearities, <em>IEEE Transactions on Signal Processing</em>, 62(21), 5716&ndash;5724.</cite>
</p>


<h3>See Also</h3>

<p><a href="#topic+fICA">fICA</a>, <a href="#topic+nonlinearities">nonlinearities</a>, <a href="JADE.html#topic+FOBI">FOBI</a>, <a href="JADE.html#topic+k_JADE">k_JADE</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(9),3,3)
s1 &lt;- rt(1000,6)
s2 &lt;- rexp(1000,1)
s3 &lt;- runif(1000)

S &lt;- cbind(s1,s2,s3)
X &lt;- S %*% t(A)

Sest &lt;- fICA(X,method="def")$S

compute_alphas(Sest, gs=gf[1:3], dgs=dgf[1:3], name=gnames[1:3])
</code></pre>

<hr>
<h2 id='fICA'>
Symmetric and Deflation-based FastICA Methods for Independent Component Analysis
</h2><span id='topic+fICA'></span><span id='topic+fICA.default'></span>

<h3>Description</h3>

<p>The symmetric and deflation-based FastICA methods for the independent component problem. The function estimates the unmixing matrix using a single nonlinearity g.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fICA(X, g="tanh", dg=NULL, G=NULL, init=NULL, n.init = 1, method="sym2",
     inR=TRUE, eps=1e-06, maxiter=1000)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fICA_+3A_x">X</code></td>
<td>
<p>a numeric data matrix. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="fICA_+3A_g">g</code></td>
<td>
<p>the nonlinearity, tanh by default, see details.</p>
</td></tr>
<tr><td><code id="fICA_+3A_dg">dg</code></td>
<td>
<p>the first derivative of the nonlinearity, see details.</p>
</td></tr>
<tr><td><code id="fICA_+3A_g">G</code></td>
<td>
<p>the integral function of the nonlinearity, see details.</p>
</td></tr>
<tr><td><code id="fICA_+3A_init">init</code></td>
<td>
<p>a numeric matrix for the initial value of the algorithm</p>
</td></tr>
<tr><td><code id="fICA_+3A_n.init">n.init</code></td>
<td>
<p>a positive integer for the number of initial values in symmetric algorithms, see details.</p>
</td></tr>
<tr><td><code id="fICA_+3A_method">method</code></td>
<td>
<p>squared symmetric (<code>"sym2"</code>), symmetric (<code>"sym"</code>) or deflation-based (<code>"def"</code>)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="fICA_+3A_inr">inR</code></td>
<td>
<p>a logical which indicates whether R or C is used for computations, see details.</p>
</td></tr>
<tr><td><code id="fICA_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="fICA_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deflation-based FastICA estimate depends on the initial value of the unmixing matrix. This is due to the fact that the algorithm does not always find the global maximum of the objective function, but it may stop to local maxima as well. Hence, the deflation-based FastICA estimate is affine equivariant only if the initial value is affine equivariant. Therefore, we recommend the use of <a href="#topic+reloaded_fICA">reloaded_fICA</a> or <a href="#topic+adapt_fICA">adapt_fICA</a>.
</p>
<p>The standard nonlinearities can be chosen by <code>g="pow3"</code>, <code>g="tanh"</code> or <code>g="gaus"</code>. These estimates can be computed either in R or in C (except the squared symmetric). In order to use some other nonlinearity, one has to give the nonlinearity and its derivative as functions (and the integral function when squared symmetric FastICA is computed), and the computations have to be performed in R.
</p>
<p>If the symmetric or squared symmetric algorithm does not converge, one can choose <code>n.init=k</code> for some <code class="reqn">k&gt;1</code>. Then up to <code class="reqn">k</code> random initial values are tried, and if none of them gives a convergent run of the algorithm, the function returns the matrix which gave the largest value of the objective function over all <code class="reqn">k\times maxiter</code> steps.  
</p>


<h3>Value</h3>

<p>A list with class 'bss' containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>nonlinearity used.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>symmetric or deflation-based.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>estimated source components standardized to have mean 0 and unit variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jari Miettinen</p>


<h3>References</h3>

<p><cite>Hyvarinen, A. and Oja, E. (1997), A fast fixed-point algorithm for independent component analysis, <em>Neural Computation</em>, vol. 9, 1483&ndash;1492.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Oja, H., Taskinen, S. and Virta, J. (2015), The squared symmetric FastICA estimator, <em>Signal Processing</em>, vol. 131, 402&ndash;411. </cite>
</p>


<h3>See Also</h3>

<p><a href="#topic+adapt_fICA">adapt_fICA</a>, <a href="#topic+reloaded_fICA">reloaded_fICA</a>, <a href="#topic+nonlinearities">nonlinearities</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># creating some toy data
A&lt;- matrix(rnorm(9),3,3)
s1 &lt;- rt(1000,6)
s2 &lt;- rexp(1000,1)
s3 &lt;- runif(1000)

S &lt;- cbind(s1,s2,s3)
X &lt;- S %*% t(A)

# tanh is the default nonlinearity
res1&lt;-fICA(X,method="sym")
coef(res1)
plot(res1) 
require(JADE)
MD(coef(res1),A)

# nonlinearity pow3 is chosen as follows
res2&lt;-fICA(X,g="pow3",method="sym")
coef(res2)
require(JADE)
MD(coef(res2),A)

# nonlinearity from gf is chosen as follows
res3&lt;-fICA(X,g=gf[[6]],dg=dgf[[6]],method="sym")
coef(res3)
require(JADE)
MD(coef(res3),A)

</code></pre>

<hr>
<h2 id='fICA-package'>
Classical, Reloaded and Adaptive FastICA Algorithms
</h2><span id='topic+fICA-package'></span>

<h3>Description</h3>

<p>Algorithms for classical symmetric and deflation-based FastICA, reloaded deflation-based FastICA algorithm and an algorithm for adaptive deflation-based FastICA using multiple nonlinearities. For details, see Miettinen et al. (2014) &lt;doi:10.1109/TSP.2014.2356442&gt; and Miettinen et al. (2017) &lt;doi:10.1016/j.sigpro.2016.08.028&gt;.  The package is described in Miettinen, Nordhausen and Taskinen (2018) &lt;doi:10.32614/RJ-2018-046&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> fICA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-12-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jari Miettinen, Klaus Nordhausen, Hannu Oja, Sara Taskinen
</p>
<p>Maintainer: Klaus Nordhausen &lt;klaus.k.nordhausen@jyu.fi&gt;
</p>


<h3>References</h3>

<p><cite>Miettinen, J., Nordhausen, K. and Taskinen, S. (2018), fICA: FastICA Algorithms and Their Improved Variants, <em>The R Journal</em>, <b>10</b>, 148&ndash;158, &lt;doi:10.32614/RJ-2018-046&gt;.</cite>
</p>

<hr>
<h2 id='nonlinearities'>
Set of Nonlinearities for Adaptive Deflation-based FastICA Method
</h2><span id='topic+nonlinearities'></span><span id='topic+gf'></span><span id='topic+dgf'></span><span id='topic+Gf'></span><span id='topic+gnames'></span>

<h3>Description</h3>

<p>The default set of nonlinearities with their first derivatives and names used in <code><a href="#topic+adapt_fICA">adapt_fICA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gf

dgf

Gf

gnames
</code></pre>


<h3>Details</h3>

 
<p>The set of nonlinearities includes both well-known functions (<em>pow3</em>, <em>tanh</em> and <em>gaus</em>) and the ones suggested in Miettinen et al. (2014).
</p>
<p>The object <code>gf</code> contains the nonlinearities which are:
</p>

<table>
<tr>
 <td style="text-align: left;"> 
gf[[1]] </td><td style="text-align: left;"> pow3  </td><td style="text-align: left;"> <code class="reqn">x^3</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[2]] </td><td style="text-align: left;"> tanh  </td><td style="text-align: left;"> <code class="reqn">tanh(x)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[3]] </td><td style="text-align: left;"> gaus  </td><td style="text-align: left;"> <code class="reqn">exp(-(x)^2/2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[4]] </td><td style="text-align: left;"> lt0.6 </td><td style="text-align: left;"> <code class="reqn">(x+0.6)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[5]] </td><td style="text-align: left;"> rt0.6 </td><td style="text-align: left;"> <code class="reqn">(x-0.6)_+^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[6]] </td><td style="text-align: left;"> bt    </td><td style="text-align: left;"> <code class="reqn">(x)_+^2-(x)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[7]] </td><td style="text-align: left;"> bt0.2 </td><td style="text-align: left;"> <code class="reqn">(x-0.2)_+^2-(x+0.2)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[8]] </td><td style="text-align: left;"> bt0.4 </td><td style="text-align: left;"> <code class="reqn">(x-0.4)_+^2-(x+0.4)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[9]] </td><td style="text-align: left;"> bt0.6 </td><td style="text-align: left;"> <code class="reqn">(x-0.6)_+^2-(x+0.6)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[10]] </td><td style="text-align: left;"> bt0.8 </td><td style="text-align: left;"> <code class="reqn">(x-0.8)_+^2-(x+0.8)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[11]] </td><td style="text-align: left;"> bt1.0 </td><td style="text-align: left;"> <code class="reqn">(x-1.0)_+^2-(x+1.0)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[12]] </td><td style="text-align: left;"> bt1.2 </td><td style="text-align: left;"> <code class="reqn">(x-1.2)_+^2-(x+1.2)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[13]] </td><td style="text-align: left;"> bt1.4 </td><td style="text-align: left;"> <code class="reqn">(x-1.4)_+^2-(x+1.4)_-^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
gf[[14]] </td><td style="text-align: left;"> bt1.6 </td><td style="text-align: left;"> <code class="reqn">(x-1.6)_+^2-(x+1.6)_-^2</code> 
</td>
</tr>

</table>

<p>The objects <code>dgf</code>, <code>Gf</code> and <code>gnames</code> contain the corresponding first derivatives, integrals and names in the same order.
</p>
<p>For skew sources <em>lt0.6</em>  and <em>rt0.6</em> combined are more efficient than the commonly used <em>skew</em>. The rest of the functions are useful for example for sources with multimodal density functions.  
</p>
<p>The user can easily submit a own set or modify the set suggested here. See the example below and the examples in <code><a href="#topic+adapt_fICA">adapt_fICA</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jari Miettinen</p>


<h3>References</h3>

<p><cite>Hyvarinen, A. and Oja, E. (1997), A fast fixed-point algorithm for independent component analysis, <em>Neural Computation</em>, vol. 9, 1483&ndash;1492.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Oja, H. and Taskinen, S. (2014), Deflation-based FastICA with adaptive choices of nonlinearities, <em>IEEE Transactions on Signal Processing</em>, 62(21), 5716&ndash;5724.</cite>
</p>


<h3>See Also</h3>

<p><a href="#topic+adapt_fICA">adapt_fICA</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># leaving out functions from the default set and adding a new function  
g &lt;- function(x){x^2}
dg &lt;- function(x){2*x}
G &lt;- function(x){x^3/3}

gf_new &lt;- c(gf[-c(6,8,10)],g)
dgf_new &lt;- c(dgf[-c(6,8,10)],dg)
Gf_new &lt;- c(Gf[-c(6,8,10)],G)
gnames_new &lt;- c(gnames[-c(6,8,10)],"skew")
</code></pre>

<hr>
<h2 id='reloaded_fICA'>
Reloaded Deflation-based FastICA Method for Independent Component Analysis
</h2><span id='topic+reloaded_fICA'></span><span id='topic+reloaded_fICA.default'></span>

<h3>Description</h3>

<p>The reloaded and the affine equivariant deflation-based FastICA method for the independent component problem. The function estimates the rows of the unmixing matrix one by one, either in asymptotically optimal order, or so that the objective function is globally maximized at each stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reloaded_fICA(X, g="tanh", dg=NULL, G=NULL, kj=0, method="alpha",
             inR=TRUE, eps=1e-06, maxiter=100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reloaded_fICA_+3A_x">X</code></td>
<td>
<p>a numeric data matrix. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_g">g</code></td>
<td>
<p>the nonlinearity, tanh by default, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_dg">dg</code></td>
<td>
<p>the first derivative of the nonlinearity, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_g">G</code></td>
<td>
<p>the integral of the nonlinearity, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_kj">kj</code></td>
<td>
<p>defines the initial estimate of the unmixing matrix, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_method">method</code></td>
<td>
<p>&quot;alpha&quot; or &quot;G&quot;, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_inr">inR</code></td>
<td>
<p>a logical which indicates whether R or C is used for computations, see details.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="reloaded_fICA_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The algorithm first finds initial estimates of the sources. The method to find the estimates is decided by the choice of the argument <code>kj</code>. If the value of <code>kj</code> is an integer between 1 and number of the sources, then the method is <code>kj</code>-JADE, otherwise it is FOBI. For the meaning of the value <code>kj</code> used as <code>kj</code>-JADE, see the help for <code><a href="JADE.html#topic+k_JADE">k_JADE</a></code>.
</p>
<p>The function has the argument <code>method</code>, which determines the extraction order of the components. If <code>method="alpha"</code>, the components are found in asymptotically optimal order, that is, the reloaded deflation-based FastICA estimate is computed. If <code>method="G"</code>, the objective function is globally maximized at each stage. 
</p>
<p>The standard nonlinearities can be chosen by <code>g="pow3"</code>, <code>g="tanh"</code> or <code>g="gaus"</code>. These estimates can be computed either in R or in C. In order to use some other nonlinearity, one has to give the nonlinearity and its derivative (and integral if <code>method="G"</code>)  as functions, and the computations have to be performed in R.
</p>


<h3>Value</h3>

<p>A list with class 'bss' containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>nonlinearity used.</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>the statistics for the choice of the nonlinearities.</p>
</td></tr>
<tr><td><code>init_est</code></td>
<td>
<p>method that was used for the initial estimate (FOBI or k-JADE).</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>estimated source components standardized to have mean 0 and unit variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jari Miettinen</p>


<h3>References</h3>

<p><cite>Hyvarinen, A. and Oja, E. (1997), A fast fixed-point algorithm for independent component analysis, <em>Neural Computation</em>, vol. 9, 1483&ndash;1492.</cite>
</p>
<p><cite>Nordhausen, K., Ilmonen, P., Mandal, A., Oja, H. and Ollila, E. (2011), Deflation-based FastICA reloaded,
in <em>Proc. &quot;19th European Signal Processing Conference 2011 (EUSIPCO 2011)&quot;,</em> Barcelona, 1854&ndash;1858.</cite>
</p>


<h3>See Also</h3>

<p><a href="#topic+fICA">fICA</a>, <a href="#topic+nonlinearities">nonlinearities</a>, <a href="JADE.html#topic+FOBI">FOBI</a>, <a href="JADE.html#topic+k_JADE">k_JADE</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># creating some toy data
A&lt;- matrix(rnorm(9),3,3)
s1 &lt;- rt(1000,6)
s2 &lt;- rexp(1000,1)
s3 &lt;- runif(1000)

S &lt;- cbind(s1,s2,s3)
X &lt;- S %*% t(A)

# tanh is the default nonlinearity
res1&lt;-reloaded_fICA(X)
coef(res1)
plot(res1) 
require(JADE)
MD(coef(res1),A)

# nonlinearity pow3 and method "G" is chosen as follows
res2&lt;-reloaded_fICA(X,g="pow3",method="G")
coef(res2)
require(JADE)
MD(coef(res2),A)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
