<!DOCTYPE html><html><head><title>Help for package mvpd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvpd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptIntegrate_inf_limPD'><p>Adaptive multivariate integration over hypercubes (admitting infinite limits)</p></a></li>
<li><a href='#dmvss'><p>Multivariate Subgaussian Stable Density</p></a></li>
<li><a href='#fit_mvss'><p>Fit a Multivariate Subgaussian Distribution</p></a></li>
<li><a href='#mvpd'><p>Multivariate Product Distributions</p></a></li>
<li><a href='#pmvss'><p>Multivariate Subgaussian Stable Distribution</p></a></li>
<li><a href='#pmvss_mc'><p>Monte Carlo Multivariate Subgaussian Stable Distribution</p></a></li>
<li><a href='#rmvss'><p>Multivariate Subgaussian Stable Random Variates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multivariate Product Distributions for Elliptically Contoured
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates multivariate subgaussian stable densities 
    and probabilities as well as generates random variates using product 
    distribution theory.  A function for estimating the parameters from 
    data to fit a distribution to data is also provided, using the 
    method from Nolan (2013) &lt;<a href="https://doi.org/10.1007%2Fs00180-013-0396-7">doi:10.1007/s00180-013-0396-7</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats, stabledist, libstable4u, mvtnorm, stats,
cubature, Matrix</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/swihart/mvpd">https://github.com/swihart/mvpd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swihart/mvpd/issues">https://github.com/swihart/mvpd/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-03 12:14:35 UTC; bruce</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruce Swihart <a href="https://orcid.org/0000-0002-4216-9942"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bruce Swihart &lt;bruce.swihart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-03 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptIntegrate_inf_limPD'>Adaptive multivariate integration over hypercubes (admitting infinite limits)</h2><span id='topic+adaptIntegrate_inf_limPD'></span>

<h3>Description</h3>

<p>The function performs adaptive multidimensional integration
(cubature) of (possibly) vector-valued integrands over hypercubes.
It is a wrapper for cubature:::adaptIntegrate, transforming (-)Inf
appropriately as described in cubature's help page (http://ab-initio.mit.edu/wiki/index.php/Cubature#Infinite_intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptIntegrate_inf_limPD(
  f,
  lowerLimit,
  upperLimit,
  ...,
  tol.ai = 1e-05,
  fDim.ai = 1,
  maxEval.ai = 0,
  absError.ai = 0,
  doChecking.ai = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_tol.ai">tol.ai</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_fdim.ai">fDim.ai</code></td>
<td>
<p>The dimension of the integrand, default 1, bears no
relation to the dimension of the hypercube</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_maxeval.ai">maxEval.ai</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 0 implying no limit</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_abserror.ai">absError.ai</code></td>
<td>
<p>The maximum absolute error tolerated</p>
</td></tr>
<tr><td><code id="adaptIntegrate_inf_limPD_+3A_dochecking.ai">doChecking.ai</code></td>
<td>
<p>A flag to be thorough checking inputs to
C routines. A FALSE value results in approximately 9 percent speed
gain in our experiments. Your mileage will of course vary. Default
value is FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## integrate Cauchy Density from -Inf to Inf
adaptIntegrate_inf_limPD(function(x) 1/pi * 1/(1+x^2), -Inf, Inf)
adaptIntegrate_inf_limPD(function(x, scale) 1/(pi*scale) * 1/(1+(x/scale)^2), -Inf, Inf, scale=4)
## integrate Cauchy Density from -Inf to -3
adaptIntegrate_inf_limPD(function(x) 1/pi * 1/(1+x^2), -Inf, -3)$int
stats::pcauchy(-3)
adaptIntegrate_inf_limPD(function(x, scale) 1/(pi*scale) * 1/(1+(x/scale)^2), -Inf, -3, scale=4)$int
stats::pcauchy(-3, scale=4)

</code></pre>

<hr>
<h2 id='dmvss'>Multivariate Subgaussian Stable Density</h2><span id='topic+dmvss'></span>

<h3>Description</h3>

<p>Computes the the density function of the multivariate subgaussian stable
distribution for arbitrary alpha, shape matrices, and location vectors.
See Nolan (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvss(
  x,
  alpha = 1,
  Q = NULL,
  delta = rep(0, d),
  outermost.int = c("stats::integrate", "cubature::adaptIntegrate")[1],
  spherical = FALSE,
  subdivisions.si = 100L,
  rel.tol.si = .Machine$double.eps^0.25,
  abs.tol.si = rel.tol.si,
  stop.on.error.si = TRUE,
  tol.ai = 1e-05,
  fDim.ai = 1,
  maxEval.ai = 0,
  absError.ai = 0,
  doChecking.ai = FALSE,
  which.stable = c("libstable4u", "stabledist")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvss_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_alpha">alpha</code></td>
<td>
<p>default to 1 (Cauchy). Must be 0&lt;alpha&lt;2</p>
</td></tr>
<tr><td><code id="dmvss_+3A_q">Q</code></td>
<td>
<p>Shape matrix.  See Nolan (2013).</p>
</td></tr>
<tr><td><code id="dmvss_+3A_delta">delta</code></td>
<td>
<p>location vector</p>
</td></tr>
<tr><td><code id="dmvss_+3A_outermost.int">outermost.int</code></td>
<td>
<p>select which integration function to use for outermost
integral.  Default is &quot;stats::integrate&quot; and one can specify the following options
with the <code>.si</code> suffix.  For diagonal Q, one can also specify &quot;cubature::adaptIntegrate&quot;
and use the <code>.ai</code> suffix options below (currently there is a bug for non-diagnoal Q).</p>
</td></tr>
<tr><td><code id="dmvss_+3A_spherical">spherical</code></td>
<td>
<p>default is FALSE.  If true, use the spherical transformation.
Results will be identical to spherical = FALSE but may be faster.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_subdivisions.si">subdivisions.si</code></td>
<td>
<p>the maximum number of subintervals.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_rel.tol.si">rel.tol.si</code></td>
<td>
<p>relative accuracy requested.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_abs.tol.si">abs.tol.si</code></td>
<td>
<p>absolute accuracy requested. The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_stop.on.error.si">stop.on.error.si</code></td>
<td>
<p>logical. If true (the default) an error stops the function.
If false some errors will give a result with a warning in the message component.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_tol.ai">tol.ai</code></td>
<td>
<p>The maximum tolerance, default 1e-5.
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_fdim.ai">fDim.ai</code></td>
<td>
<p>The dimension of the integrand, default 1, bears no
relation to the dimension of the hypercube
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_maxeval.ai">maxEval.ai</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 0 implying no limit
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_abserror.ai">absError.ai</code></td>
<td>
<p>The maximum absolute error tolerated
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_dochecking.ai">doChecking.ai</code></td>
<td>
<p>A flag to be thorough checking inputs to
C routines. A FALSE value results in approximately 9 percent speed
gain in our experiments. Your mileage will of course vary. Default
value is FALSE.
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="dmvss_+3A_which.stable">which.stable</code></td>
<td>
<p>defaults to &quot;libstable4u&quot;, other option is &quot;stabledist&quot;.  Indicates which package
should provide the univariate stable distribution in this production distribution form of a univariate
stable and multivariate normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on what is selected for <code>outermost.int</code>.  In the case of the default,
<code>stats::integrate</code>, the value is a list of class &quot;integrate&quot; with components:
</p>

<ul>
<li><p><code>value</code> the final estimate of the integral.
</p>
</li>
<li><p><code>abs.error</code> estimate of the modulus of the absolute error.
</p>
</li>
<li><p><code>subdivisions</code> the number of subintervals produced in the subdivision process.
</p>
</li>
<li><p><code>message</code> &quot;OK&quot; or a character string giving the error message.
</p>
</li>
<li><p><code>call</code> the matched call.
</p>
</li></ul>

<p>Note: The reported <code>abs.error</code> is likely an under-estimate as <code>integrate</code>
assumes the integrand was without error,
which is not the case in this application.
</p>


<h3>References</h3>

<p>Nolan, John P. &quot;Multivariate elliptically contoured stable distributions: theory and estimation.&quot; Computational Statistics 28.5 (2013): 2067-2089.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## print("mvsubgaussPD (d=2, alpha=1.71):")
Q &lt;- matrix(c(10,7.5,7.5,10),2)
mvpd::dmvss(x=c(0,1), alpha=1.71, Q=Q)

## more accuracy = longer runtime
mvpd::dmvss(x=c(0,1),alpha=1.71, Q=Q, abs.tol=1e-8)

Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
## print("mvsubgausPD (d=3, alpha=1.71):")
mvpd::dmvss(x=c(0,1,2), alpha=1.71, Q=Q)
mvpd::dmvss(x=c(0,1,2), alpha=1.71, Q=Q, spherical=TRUE)

## How `delta` works: same as centering
X &lt;- c(1,1,1)
Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
D &lt;- c(0.75, 0.65, -0.35)
mvpd::dmvss(X-D, alpha=1.71, Q=Q)
mvpd::dmvss(X  , alpha=1.71, Q=Q, delta=D)


</code></pre>

<hr>
<h2 id='fit_mvss'>Fit a Multivariate Subgaussian Distribution</h2><span id='topic+fit_mvss'></span>

<h3>Description</h3>

<p>Estimates the parameters (namely, alpha, shape matrix Q, and location vector)
of the multivariate subgaussian
distribution for an input matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mvss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mvss_+3A_x">x</code></td>
<td>
<p>a matrix for which the parameters for a <code>d</code>-dimensional multivariate
subgaussian distribution will be estimated.  The number of columns will be <code>d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the protocols outlined in Nolan (2013), this function uses <code>libstable4u</code>'s univariate
fit functions for each component.
</p>


<h3>Value</h3>

<p>A list with parameters from the column-wise univariate fits and
the multivariate alpha and shape matrix estimates (the <code>univ_deltas</code> are the <code>mult_deltas</code>):
</p>

<ul>
<li> <p><code>univ_alphas</code> - the alphas from the column-wise univariate fits
</p>
</li>
<li> <p><code>univ_betas</code>  - the betas  from the column-wise univariate fits
</p>
</li>
<li> <p><code>univ_gammas</code> - the gammas from the column-wise univariate fits
</p>
</li>
<li> <p><code>univ_deltas</code> - the deltas from the column-wise univariate fits
</p>
</li>
<li> <p><code>mult_alpha</code>  - the mean(univ_alphas); equivalently the multivariate alpha estimate
</p>
</li>
<li> <p><code>mult_Q_raw</code>  - the multivariate shape matrix estimate (before applying <code>nearPD()</code>)
</p>
</li>
<li> <p><code>mult_Q_posdef</code>   - the nearest positive definite multivariate shape matrix estimate, <code>nearPD(mult_Q_raw)</code>
</p>
</li></ul>



<h3>References</h3>

<p>Nolan JP (2013), <em>Multivariate elliptically contoured stable distributions:
theory and estimation</em>. Comput Stat (2013) 28:2067–2089
DOI 10.1007/s00180-013-0396-7
</p>


<h3>See Also</h3>

<p><code>Rfast::mvnorm.mle</code>, <code>alphastable::mfitstab.elliptical</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a 4x4 shape matrix symMat
S &lt;- matrix(rnorm(4*4, mean=2, sd=4),4); 
symMat &lt;- as.matrix(Matrix::nearPD(0.5 * (S + t(S)))$mat)
symMat
## generate 10,000 r.v.'s from 4-dimensional mvss
X &lt;- mvpd::rmvss(1e4, alpha=1.5, Q=symMat, delta=c(1,2,3,4))
## use fit_mvss to recover the parameters, compare to symMat
fmv &lt;- mvpd::fit_mvss(X)
fmv
symMat
## then use the fitted parameters to calculate a probability:
mvpd::pmvss(lower=rep(0,4),
            upper=rep(5,4),
            alpha=fmv$mult_alpha,
            Q=fmv$mult_Q_posdef,
            delta=fmv$univ_deltas,
            maxpts.pmvnorm = 25000*10)


</code></pre>

<hr>
<h2 id='mvpd'>Multivariate Product Distributions</h2><span id='topic+mvpd'></span><span id='topic+mvpd-package'></span>

<h3>Description</h3>

<p>The purpose of this package is to offer density, probability, and
random variate generating (abbreviated as [d/p/r], respectively)
functions for
multivariate distributions that can be represented as a product distribution.
Specifically, the package will primarily focus on the product of a multivariate
normal distribution and a univariate random variable.
These product distributions are called Scale Mixtures of
Multivariate Normal Distributions,
and for particular choices of the univariate random variable distribution the
resultant product distribution may be a family of interest.  For instance,
the square-root of a positive stable random variable multiplied by a
multivariate normal distribution is the multivariate subgaussian stable
distribution. Product
distribution theory is applied for implementing their computation.
</p>


<h3>Multivariate subgaussian stable distributions</h3>

<p><code><a href="#topic+dmvss">dmvss</a></code> &ndash; multivariate subgaussian stable distribution density
</p>
<p><code><a href="#topic+pmvss">pmvss</a></code> &ndash; multivariate subgaussian stable distribution probabilities
</p>
<p><code><a href="#topic+rmvss">rmvss</a></code> &ndash; multivariate subgaussian stable distribution random variates
</p>
<p><code><a href="#topic+pmvss_mc">pmvss_mc</a></code> &ndash; Monte Carlo version of probabilities, using <code>rmvss</code>
</p>
<p><code><a href="#topic+fit_mvss">fit_mvss</a></code> &ndash; Fit a multivariate subgaussian stable distribution (e.g. estimate parameters given data)
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bruce Swihart <a href="mailto:bruce.swihart@gmail.com">bruce.swihart@gmail.com</a> (<a href="https://orcid.org/0000-0002-4216-9942">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/swihart/mvpd">https://github.com/swihart/mvpd</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/swihart/mvpd/issues">https://github.com/swihart/mvpd/issues</a>
</p>
</li></ul>


<hr>
<h2 id='pmvss'>Multivariate Subgaussian Stable Distribution</h2><span id='topic+pmvss'></span>

<h3>Description</h3>

<p>Computes the probabilities for the multivariate subgaussian stable
distribution for arbitrary limits, alpha, shape matrices, and
location vectors.
See Nolan (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvss(
  lower = rep(-Inf, d),
  upper = rep(Inf, d),
  alpha = 1,
  Q = NULL,
  delta = rep(0, d),
  maxpts.pmvnorm = 25000,
  abseps.pmvnorm = 0.001,
  outermost.int = c("stats::integrate", "cubature::adaptIntegrate")[1],
  subdivisions.si = 100L,
  rel.tol.si = .Machine$double.eps^0.25,
  abs.tol.si = rel.tol.si,
  stop.on.error.si = TRUE,
  tol.ai = 1e-05,
  fDim.ai = 1,
  maxEval.ai = 0,
  absError.ai = 0,
  doChecking.ai = FALSE,
  which.stable = c("libstable4u", "stabledist")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvss_+3A_lower">lower</code></td>
<td>
<p>the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_upper">upper</code></td>
<td>
<p>the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_alpha">alpha</code></td>
<td>
<p>default to 1 (Cauchy). Must be 0&lt;alpha&lt;2</p>
</td></tr>
<tr><td><code id="pmvss_+3A_q">Q</code></td>
<td>
<p>Shape matrix.  See Nolan (2013).</p>
</td></tr>
<tr><td><code id="pmvss_+3A_delta">delta</code></td>
<td>
<p>location vector.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_maxpts.pmvnorm">maxpts.pmvnorm</code></td>
<td>
<p>Defaults to 25000.  Passed to the F_G = pmvnorm() in the integrand of the outermost integral.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_abseps.pmvnorm">abseps.pmvnorm</code></td>
<td>
<p>Defaults to 1e-3. Passed to the F_G = pmvnorm() in the integrand of the outermost integral.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_outermost.int">outermost.int</code></td>
<td>
<p>select which integration function to use for outermost
integral.  Default is &quot;stats::integrate&quot; and one can specify the following options
with the <code>.si</code> suffix.  For diagonal Q, one can also specify &quot;cubature::adaptIntegrate&quot;
and use the <code>.ai</code> suffix options below (currently there is a bug for non-diagonal Q).</p>
</td></tr>
<tr><td><code id="pmvss_+3A_subdivisions.si">subdivisions.si</code></td>
<td>
<p>the maximum number of subintervals.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_rel.tol.si">rel.tol.si</code></td>
<td>
<p>relative accuracy requested.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_abs.tol.si">abs.tol.si</code></td>
<td>
<p>absolute accuracy requested. The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_stop.on.error.si">stop.on.error.si</code></td>
<td>
<p>logical. If true (the default) an error stops the function.
If false some errors will give a result with a warning in the message component.
The suffix <code>.si</code> indicates a <code>stats::integrate()</code>
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_tol.ai">tol.ai</code></td>
<td>
<p>The maximum tolerance, default 1e-5.
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_fdim.ai">fDim.ai</code></td>
<td>
<p>The dimension of the integrand, default 1, bears no
relation to the dimension of the hypercube
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_maxeval.ai">maxEval.ai</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 0 implying no limit
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_abserror.ai">absError.ai</code></td>
<td>
<p>The maximum absolute error tolerated
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_dochecking.ai">doChecking.ai</code></td>
<td>
<p>A flag to be thorough checking inputs to
C routines. A FALSE value results in approximately 9 percent speed
gain in our experiments. Your mileage will of course vary. Default
value is FALSE.
The suffix <code>.ai</code> indicates a <code>cubature::adaptIntegrate</code> type
option for the outermost semi-infinite integral in the product distribution formulation.</p>
</td></tr>
<tr><td><code id="pmvss_+3A_which.stable">which.stable</code></td>
<td>
<p>defaults to &quot;libstable4u&quot;, other option is &quot;stabledist&quot;.  Indicates which package
should provide the univariate stable distribution in this production distribution form of a univariate
stable and multivariate normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on what is selected for <code>outermost.int</code>.  In the case of the default,
<code>stats::integrate</code>, the value is a list of class &quot;integrate&quot; with components:
</p>

<ul>
<li><p><code>value</code> the final estimate of the integral.
</p>
</li>
<li><p><code>abs.error</code> estimate of the modulus of the absolute error.
</p>
</li>
<li><p><code>subdivisions</code> the number of subintervals produced in the subdivision process.
</p>
</li>
<li><p><code>message</code> &quot;OK&quot; or a character string giving the error message.
</p>
</li>
<li><p><code>call</code> the matched call.
</p>
</li></ul>

<p>Note: The reported <code>abs.error</code> is likely an under-estimate as <code>integrate</code>
assumes the integrand was without error,
which is not the case in this application.
</p>


<h3>References</h3>

<p>Nolan JP (2013), <em>Multivariate elliptically contoured stable distributions:
theory and estimation</em>. Comput Stat (2013) 28:2067–2089
DOI 10.1007/s00180-013-0396-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## bivariate
U &lt;- c(1,1)
L &lt;- -U
Q &lt;- matrix(c(10,7.5,7.5,10),2)
mvpd::pmvss(L, U, alpha=1.71, Q=Q)

## trivariate
U &lt;- c(1,1,1)
L &lt;- -U
Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
mvpd::pmvss(L, U, alpha=1.71, Q=Q)

## How `delta` works: same as centering
U &lt;- c(1,1,1)
L &lt;- -U
Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
D &lt;- c(0.75, 0.65, -0.35)
mvpd::pmvss(L-D, U-D, alpha=1.71, Q=Q)
mvpd::pmvss(L  , U  , alpha=1.71, Q=Q, delta=D)



</code></pre>

<hr>
<h2 id='pmvss_mc'>Monte Carlo Multivariate Subgaussian Stable Distribution</h2><span id='topic+pmvss_mc'></span>

<h3>Description</h3>

<p>Computes probabilities of the multivariate subgaussian stable
distribution for arbitrary limits, alpha, shape matrices, and
location vectors via Monte Carlo (thus the suffix <code style="white-space: pre;">&#8288;_mc&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvss_mc(
  lower = rep(-Inf, d),
  upper = rep(Inf, d),
  alpha = 1,
  Q = NULL,
  delta = rep(0, d),
  which.stable = c("libstable4u", "stabledist")[1],
  n = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvss_mc_+3A_lower">lower</code></td>
<td>
<p>the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_upper">upper</code></td>
<td>
<p>the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_alpha">alpha</code></td>
<td>
<p>default to 1 (Cauchy). Must be 0&lt;alpha&lt;2</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_q">Q</code></td>
<td>
<p>Shape matrix.  See Nolan (2013).</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_delta">delta</code></td>
<td>
<p>location vector.</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_which.stable">which.stable</code></td>
<td>
<p>defaults to &quot;libstable4u&quot;, other option is &quot;stabledist&quot;.  Indicates which package
should provide the univariate stable distribution in this production distribution form of a univariate
stable and multivariate normal.</p>
</td></tr>
<tr><td><code id="pmvss_mc_+3A_n">n</code></td>
<td>
<p>number of random vectors to be drawn for Monte Carlo calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number between 0 and 1, the estimated probability via Monte Carlo
</p>


<h3>References</h3>

<p>Nolan JP (2013), <em>Multivariate elliptically contoured stable distributions:
theory and estimation</em>. Comput Stat (2013) 28:2067–2089
DOI 10.1007/s00180-013-0396-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## print("mvpd (d=2, alpha=1.71):")
U &lt;- c(1,1)
L &lt;- -U
Q &lt;- matrix(c(10,7.5,7.5,10),2)
mvpd::pmvss_mc(L, U, alpha=1.71, Q=Q, n=1e3)
mvpd::pmvss   (L, U, alpha=1.71, Q=Q)

## more accuracy = longer runtime
mvpd::pmvss_mc(L, U, alpha=1.71, Q=Q, n=1e4)

U &lt;- c(1,1,1)
L &lt;- -U
Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
## print("mvpd: (d=3, alpha=1.71):")
mvpd::pmvss_mc(L, U, alpha=1.71, Q=Q, n=1e3)


</code></pre>

<hr>
<h2 id='rmvss'>Multivariate Subgaussian Stable Random Variates</h2><span id='topic+rmvss'></span>

<h3>Description</h3>

<p>Computes random vectors of the multivariate subgaussian stable
distribution for arbitrary alpha, shape matrices, and
location vectors. See Nolan (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvss(
  n,
  alpha = 1,
  Q = NULL,
  delta = rep(0, d),
  which.stable = c("libstable4u", "stabledist")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvss_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rmvss_+3A_alpha">alpha</code></td>
<td>
<p>default to 1 (Cauchy). Must be 0&lt;<code>alpha</code>&lt;2</p>
</td></tr>
<tr><td><code id="rmvss_+3A_q">Q</code></td>
<td>
<p>Shape matrix.  See Nolan (2013).</p>
</td></tr>
<tr><td><code id="rmvss_+3A_delta">delta</code></td>
<td>
<p>location vector.</p>
</td></tr>
<tr><td><code id="rmvss_+3A_which.stable">which.stable</code></td>
<td>
<p>defaults to <code>"libstable4u"</code>, other option is <code>"stabledist"</code>.  Indicates which package
should provide the univariate stable distribution in this production distribution form of a univariate
stable and multivariate normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>n</code> by <code>d</code> matrix containing multivariate subgaussian stable
random variates where <code>d=nrow(Q)</code>.
</p>


<h3>References</h3>

<p>Nolan JP (2013), <em>Multivariate elliptically contoured stable distributions:
theory and estimation</em>. Comput Stat (2013) 28:2067–2089
DOI 10.1007/s00180-013-0396-7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate 10 random variates of a bivariate mvss
rmvss(n=10, alpha=1.71, Q=matrix(c(10,7.5,7.5,10),2))

## generate 10 random variates of a trivariate mvss
Q &lt;- matrix(c(10,7.5,7.5,7.5,10,7.5,7.5,7.5,10),3)
rmvss(n=10, alpha=1.71, Q=Q)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
