<!DOCTYPE html><html><head><title>Help for package mfdb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mfdb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ewe_model'><p>MareFrame DB Rpath interface</p></a></li>
<li><a href='#gadget_areafile'><p>Gadget area files</p></a></li>
<li><a href='#gadget_directory'><p>Gadget directory objects</p></a></li>
<li><a href='#gadget_file'><p>Gadget file objects</p></a></li>
<li><a href='#gadget_fleetfile'><p>Gadget fleet files</p></a></li>
<li><a href='#gadget_likelihood_component'><p>Gadget likelihood components</p></a></li>
<li><a href='#gadget_stockfile'><p>Gadget stock files</p></a></li>
<li><a href='#mfdb'><p>MareFrame DB class</p></a></li>
<li><a href='#mfdb_aggregate_group'><p>MareFrame DB groups</p></a></li>
<li><a href='#mfdb_aggregate_interval'><p>MareFrame DB intervals</p></a></li>
<li><a href='#mfdb_aggregate_na_group'><p>MareFrame DB aggregate NAs</p></a></li>
<li><a href='#mfdb_aggregate_step_interval'><p>MareFrame DB intervals</p></a></li>
<li><a href='#mfdb_aggregate_unaggregated'><p>MareFrame DB unaggregated data</p></a></li>
<li><a href='#mfdb_bulk'><p>MareFrame DB Dump / Restore</p></a></li>
<li><a href='#mfdb_dplyr'><p>MareFrame DB dplyr interface</p></a></li>
<li><a href='#mfdb_helpers'><p>MareFrame tools &amp; helpers</p></a></li>
<li><a href='#mfdb_helpers_mfdb_concatenate_results'><p>MareFrame Query Utilities</p></a></li>
<li><a href='#mfdb_import_data'><p>MareFrame Data Import functions</p></a></li>
<li><a href='#mfdb_import_taxonomy'><p>MareFrame Taxonomy import functions</p></a></li>
<li><a href='#mfdb_queries'><p>MareFrame DB queries</p></a></li>
<li><a href='#mfdb_sharing'><p>MareFrame DB sharing options</p></a></li>
<li><a href='#mfdb-data'><p>MareFrame DB Datasets</p></a></li>
<li><a href='#mfdb-package'>
<p>MareFrame DB querying library</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MareFrame DB Querying Library</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>7.3-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jamie Lentin &lt;lentinj@shuttlethread.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates and manages a PostgreSQL database suitable for storing fisheries data
             and aggregating ready for use within a Gadget <a href="https://gadget-framework.github.io/gadget2/">https://gadget-framework.github.io/gadget2/</a> model.
             See <a href="https://mareframe.github.io/mfdb/">https://mareframe.github.io/mfdb/</a> for more information.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>logging (&ge; 0.7-103), DBI (&ge; 0.3.1), duckdb (&ge; 0.2.5),
getPass (&ge; 0.1-1), rlang (&ge; 0.4.0), RPostgres (&ge; 1.3.0),
RSQLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr (&ge; 0.8.3), dbplyr (&ge; 2.0.0), knitr, rmarkdown,
unittest (&ge; 1.4)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-21 13:32:16 UTC; lentinj</td>
</tr>
<tr>
<td>Author:</td>
<td>Jamie Lentin [aut, cre, cph],
  Bjarki Thor Elvarsson [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-21 14:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ewe_model'>MareFrame DB Rpath interface</h2><span id='topic+mfdb_rpath_params'></span>

<h3>Description</h3>

<p>Transform the results of MFDB queries for use in an Rpath model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_rpath_params(area_data,
    survey_data,
    catch_data,
    consumption_data,
    create_rpath_params = stop("Set create_rpath_params = Rpath::create.rpath.params"),
    living_groups = character(0),
    detritus_groups = c("Detritus"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewe_model_+3A_area_data">area_data</code></td>
<td>
<p>Results of an <code>mfdb_area_size</code> query, aggregating the whole area</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_survey_data">survey_data</code></td>
<td>
<p>Results of an <code>mfdb_sample_totalweight</code> query, normally for one year, aggregated by the model's functional groups</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_catch_data">catch_data</code></td>
<td>
<p>Results of an <code>mfdb_sample_totalweight</code> query, normally for one year, aggregated by the model's functional groups and 'vessel'</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_consumption_data">consumption_data</code></td>
<td>
<p>Results of an <code>mfdb_stomach_preyweightratio</code> query, aggregated by functional groups</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_living_groups">living_groups</code></td>
<td>
<p>Additional Rpath groups of &quot;Living&quot; type</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_detritus_groups">detritus_groups</code></td>
<td>
<p>Additional Rpath groups of &quot;Detritus&quot; type</p>
</td></tr>
<tr><td><code id="ewe_model_+3A_create_rpath_params">create_rpath_params</code></td>
<td>

<p>RPath isn't currently in a public repository, so to avoid depending on it you need to
give mfdb_rpath_params the Rpath function, i.e. <code>Rpath::create.rpath.params</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EwE requires stanzas and groups of stanzas, these are made up using the first
and any other groupings in MFDB. For example, if <code>survey_data</code> was made
with a query like <code>mfdb_sample_totalweight(mdb, c('species', 'age'), ...)</code>,
then the species will make up the generated stanza_groups, and age will make up
the stanzas within those groups.
</p>
<p><code>catch_data</code> requires data that is also aggregated by vessel, this will be
ignored for the purposes of deciding the stanza/stanza_group.
</p>
<p><code>consumption_data</code> treats prey groupings seperate to predator groupings,
and all will be added to the diet matrix. 
</p>
<p>See <a href="#topic+mfdb_sample_totalweight">mfdb_sample_totalweight</a> for more information on how groupings can be used in
queries.
</p>


<h3>Value</h3>

<p>Returns an Rpath.params object populated with the provided data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See demo/example-ewe.R for a full-length example</code></pre>

<hr>
<h2 id='gadget_areafile'>Gadget area files</h2><span id='topic+gadget_areafile'></span>

<h3>Description</h3>

<p>Structures representing a GADGET area file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_areafile(size, temperature, area = attr(size, 'area'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_areafile_+3A_size">size</code></td>
<td>

<p>data.frame as produced by <code>mfdb_area_size</code>
</p>
</td></tr>
<tr><td><code id="gadget_areafile_+3A_temperature">temperature</code></td>
<td>

<p>data.frame as produced by <code>mfdb_temperature</code>
</p>
</td></tr>
<tr><td><code id="gadget_areafile_+3A_area">area</code></td>
<td>

<p>Optional. <code>mfdb_group</code> that you used to specify area. By default
pulls it from annotations on the <code>size</code> object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once formed, you can then use <code>gadget_dir_write</code> to write this out to a
GADGET areafile.
</p>


<h3>Value</h3>

<p>List of class 'gadget_areafile' that represents the area file contents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Open a temporary database connection
mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# Define 2 areacells of equal size
mfdb_import_area(mdb, data.frame(name=c("divA", "divB"), size=1))

# We want to have 3 area groups, 2 for original cells, one aggregating across the lot
area_group &lt;- mfdb_group(
    divA = c("divA"),
    divB = c("divB"),
    divAB = c("divA", "divB"))

# Make up temperature data
temps &lt;- expand.grid(year=c(1998,2000), month=c(1:12), areacell=c("divA", "divB"))
temps$temperature &lt;- runif(nrow(temps), 5, 10)
mfdb_import_temperature(mdb, temps)

# Create an areafile from 2 mfdb queries
areafile &lt;- gadget_areafile(
    mfdb_area_size(mdb, list(
        area = area_group))[[1]],
    mfdb_temperature(mdb, list(
        year = 1998:2000,
        timestep = mfdb_timestep_quarterly,
        area = area_group))[[1]])
areafile

# Write this to a gadget_directory
gadget_dir_write(gadget_directory(tempfile()), areafile)

# Check data in file matches input data
stopifnot(identical(
    areafile$size,
    c(divA=1, divB=1, divAB=2)))
stopifnot(all.equal(
    mean(areafile$temperature[areafile$temperature$area == 1, 'mean']),
    mean(temps[temps$areacell == 'divA', 'temperature']),
    tolerance = 1e-2))
stopifnot(all.equal(
    mean(areafile$temperature[areafile$temperature$area == 2, 'mean']),
    mean(temps[temps$areacell == 'divB', 'temperature']),
    tolerance = 1e-2))
stopifnot(all.equal(
    mean(areafile$temperature[areafile$temperature$area == 3, 'mean']),
    mean(temps[,'temperature']),
    tolerance = 1e-2))

mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='gadget_directory'>Gadget directory objects</h2><span id='topic+gadget_directory'></span><span id='topic+gadget_dir_write'></span><span id='topic+gadget_dir_read'></span>

<h3>Description</h3>

<p>Structures representing a directory of data files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_directory(dir, mainfile = "main")
gadget_dir_write(gd, obj)
gadget_dir_read(gd, file_name, missing_okay = TRUE, file_type = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_directory_+3A_dir">dir</code></td>
<td>

<p>Name of directory, will be created if it doesn't exist.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_mainfile">mainfile</code></td>
<td>

<p>Name of the GADGET mainfile to use.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_gd">gd</code></td>
<td>

<p>A <code>gadget_directory</code> object.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_obj">obj</code></td>
<td>

<p>The <code>gadget_file</code>, or <code>gadget_likelihood_component</code> to write.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_file_name">file_name</code></td>
<td>

<p>File to read out of the directory and turn into a <code>gadget_file</code>.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_missing_okay">missing_okay</code></td>
<td>

<p>If true, return an empty file instead of complaining that the given
file does not exist.
</p>
</td></tr>
<tr><td><code id="gadget_directory_+3A_file_type">file_type</code></td>
<td>

<p>A character vector that alters how the file is parsed. Currently either
NULL or &quot;bare_component&quot;, which implies we write &quot;something&quot; instead of
&quot;[something]&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions handle reading and writing of files to a directory
containing GADGET model files.
</p>
<p>First a gadget_directory object needs to be created with <code>gadget_directory</code>,
this ensures the directory exists and stores the name of the mainfile to use.
</p>
<p>Any portion of a gadget model can then be written out with <code>gadget_dir_write</code>.
You do not need to tell it which files in the model to update, since this is worked
out based on what you are writing out.
</p>


<h3>Value</h3>

<p><code>gadget_directory</code> returns a list of class 'gadget_directory',
containing the location of the mainfile that the gadget configuration will use.
</p>
<p><code>gadget_dir_write</code> returns NULL
</p>
<p><code>gadget_dir_read</code> returns a gadget_file object from <code>read.gadget_file</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a gadget directory
gd &lt;- gadget_directory(tempfile())

# Read in the likelihood file
likelihood &lt;- gadget_dir_read(gd, 'likelihood')

# Write out an area file to "(tempfile)/areas", replacing any existing file
gadget_dir_write(gd, gadget_file("areas", components = list(list(north = 1:3, south = 4:7))))

# Replace a likelihood component if one already exists with
# the same name/type or append it to the bottom
gadget_dir_write(gd, gadget_likelihood_component("understocking", name = "frank"))
</code></pre>

<hr>
<h2 id='gadget_file'>Gadget file objects</h2><span id='topic+gadget_file'></span><span id='topic+print.gadget_file'></span><span id='topic+as.character.gadget_file'></span><span id='topic+read.gadget_file'></span>

<h3>Description</h3>

<p>Structures representing an individual GADGET data file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_file(file_name, components = list(), data = NULL, file_type = c())
## S3 method for class 'gadget_file'
print(x, ...)
## S3 method for class 'gadget_file'
as.character(x, ...)
read.gadget_file(file_name, file_type = c(), fileEncoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_file_+3A_file_name">file_name</code></td>
<td>

<p>Filename the output should be written to / read from
</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_components">components</code></td>
<td>

<p>A list of lists, representing each component. See details.
</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_data">data</code></td>
<td>

<p>A <code>data.frame</code> representing the tabular data at the end of a file.
</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_file_type">file_type</code></td>
<td>

<p>A character vector that alters how the file is parsed. Currently either
NULL or &quot;bare_component&quot;, which implies we write &quot;something&quot; instead of
&quot;[something]&quot;.
</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_x">x</code></td>
<td>
<p>gadget_file object</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>File's characterset. Defaults to UTF-8</p>
</td></tr>
<tr><td><code id="gadget_file_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For our purposes, a gadget file is broken down into components, where the first
component is any key/value data at the top of the file. Each section separated
by &quot;[something]&quot; is considered a new component. Each component is a list of key
/values, where values can be vectors of multiple values. Also components can
have comments prepended by adding a &quot;preamble&quot; attribute.
</p>
<p>In slight deviation to GADGET spec, we insist that tabular data begins with
&quot;; &ndash; data &ndash;&quot;, to avoid any ambiguity on when it starts.
</p>


<h3>Value</h3>

<p><code>gadget_file</code> Returns a gadget_file object, a list of components.
</p>
<p><code>print.gadget_file</code> Prints the gadget file as it would be written to the
filesystem.
</p>
<p><code>as.character.gadget_file</code> Returns a character string of the gadget file
as it would be written to the filesystem.
</p>
<p><code>read.gadget_file</code> Returns a gadget_file object, a list of components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple key/values
gadget_file("age", components = list(
    list(length = 5, age = 1:5)))

# Multiple components
gadget_file("likelihood", components = list(
    list(),
    component = structure(list(type = "penalty"), preamble = list("comment")),
    component = structure(list(type = "penalty"), preamble = list("", "another comment"))))

# Data
gadget_file("agelen", components = list(
    list(stocknames = "cod")), data = data.frame(
    area = c(102, 103),
    number = c(2345, 5023)))
</code></pre>

<hr>
<h2 id='gadget_fleetfile'>Gadget fleet files</h2><span id='topic+gadget_fleet_component'></span>

<h3>Description</h3>

<p>Structures representing fleet file components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_fleet_component(type,
        name = type,
        livesonareas = unique(data$area),
        multiplicative = 1,
        suitability = NULL,
        fleetfile = 'fleet',
        data = stop("data not provided"),
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_fleetfile_+3A_type">type</code></td>
<td>

<p>Required. Type of fleet component to create, e.g. 'totalfleet'
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_name">name</code></td>
<td>

<p>Optional. A descriptive name for the fleet component, defaults to the type.
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_livesonareas">livesonareas</code></td>
<td>

<p>Optional. Vector of area names, defaults to all unique areas in data.
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_multiplicative">multiplicative</code></td>
<td>

<p>Optional. Defaults to 1
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_suitability">suitability</code></td>
<td>

<p>Optional. Defaults to empty string
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_fleetfile">fleetfile</code></td>
<td>

<p>Optional. The fleet file to put the component in. Defaults to 'fleet'.
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_data">data</code></td>
<td>

<p>Required. The data.frame to use for 'amountfile'. Areas are translated
into integers before adding to amountfile.
</p>
</td></tr>
<tr><td><code id="gadget_fleetfile_+3A_...">...</code></td>
<td>

<p>Extra parameters for the component, see details
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>effortfleet</code> requires the following extra parameters:
</p>

<dl>
<dt>catchability</dt><dd><p>A list of stock names to catchability constants</p>
</dd>
</dl>

<p><code>quotafleet</code> requires the following extra parameters:
</p>

<dl>
<dt>quotafunction</dt><dd><p>Function name, e.g. 'simple'</p>
</dd>
<dt>biomasslevel</dt><dd><p>Vector of biomass levels</p>
</dd>
<dt>quotalevel</dt><dd><p>Vector of fishing levels</p>
</dd>
</dl>



<h3>Value</h3>

<p>A gadget_fleet_component object that can them be added to a fleetfile with
<code>gadget_dir_write</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))
    gd &lt;- gadget_directory(tempfile())

    # Define 2 areacells of equal size
    mfdb_import_area(mdb, data.frame(name=c("divA", "divB"), size=1))

    # Define 2 vessels
    mfdb_import_vessel_taxonomy(mdb, data.frame(
        name = c('1.RSH', '2.COM'),
        full_name = c('Research', 'Commercial'),
        stringsAsFactors = FALSE))

    # Make up some samples
    samples &lt;- expand.grid(
        year = 1998,
        month = 5,
        areacell = c("divA", "divB"),
        species = 'COD',
        vessel = c('1.RSH', '2.COM'),
        length = c(0,40,80))
    samples$count &lt;- runif(nrow(samples), 20, 90)
    mfdb_import_survey(mdb, data_source = "x", samples)

    # Make a 'totalfleet' component
    fc &lt;- gadget_fleet_component(
        'totalfleet',
        name = 'research',
        data = mfdb_sample_count(mdb, c(), list(
            vessel = '1.RSH',
            area = mfdb_group(x = 'divA', y = 'divB'),
            year = 1998,
            step = mfdb_timestep_yearly))[[1]])
    fc

    # Write out to a directory
    gadget_dir_write(gd, fc)

    gadget_fleet_component(
        'effortfleet',
        name = 'commercial',
        suitability = "function constant 4;",
        catchability = list(stockA=4, stockB=5),
        quotafunction = 'simple',
        biomasslevel = c(1000, 2000),
        quotalevel = c(0.1, 0.4, 0.9),
        data = mfdb_sample_count(mdb, c(), list(
            vessel = '2.COM',
            area = mfdb_group(x = 'divA', y = 'divB'),
            year = 1998,
            step = mfdb_timestep_yearly))[[1]])

    gadget_fleet_component(
        'quotafleet',
        name = 'commercial',
        suitability = "function constant 4;",
        catchability = list(stockA=4, stockB=5),
        quotafunction = 'simple',
        biomasslevel = c(1000, 2000),
        quotalevel = c(0.1, 0.4, 0.9),
        data = mfdb_sample_count(mdb, c(), list(
            vessel = '2.COM',
            area = mfdb_group(x = 'divA', y = 'divB'),
            year = 1998,
            step = mfdb_timestep_yearly))[[1]])

    mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='gadget_likelihood_component'>Gadget likelihood components</h2><span id='topic+gadget_likelihood_component'></span>

<h3>Description</h3>

<p>Structures representing a component of a GADGET likelihood file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_likelihood_component(type, weight = 0, name = type,
    likelihoodfile = 'likelihood', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_likelihood_component_+3A_type">type</code></td>
<td>

<p>Type of group to create. One of penalty, understocking, catchstatistics,
catchdistribution, stockdistribution.
</p>
</td></tr>
<tr><td><code id="gadget_likelihood_component_+3A_name">name</code></td>
<td>

<p>A descriptive name for the component
</p>
</td></tr>
<tr><td><code id="gadget_likelihood_component_+3A_weight">weight</code></td>
<td>

<p>A numeric weighting
</p>
</td></tr>
<tr><td><code id="gadget_likelihood_component_+3A_likelihoodfile">likelihoodfile</code></td>
<td>

<p>The likelihood file this component should end up in
</p>
</td></tr>
<tr><td><code id="gadget_likelihood_component_+3A_...">...</code></td>
<td>

<p>Extra parameters for the group. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition, <code>penalty</code> understands:
</p>

<dl>
<dt>data</dt><dd><p>A <code>data.frame</code> with 2 columns, &quot;switch&quot; and &quot;power&quot;</p>
</dd>
</dl>

<p><code>catchstatistics</code> understands:
</p>

<dl>
<dt>data_function</dt><dd><p>The function Gadget should use, by default guesses based on the function that generated <code>data</code></p>
</dd>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
<dt>area</dt><dd><p>An <code>list</code> of areas, taken from <code>attr(data, "area")</code> if not supplied</p>
</dd>
<dt>age</dt><dd><p>An <code>list</code> of ages, taken from <code>attr(data, "age")</code> if not supplied</p>
</dd>
<dt>fleetnames</dt><dd><p>List of fleet names</p>
</dd>
<dt>stocknames</dt><dd><p>List of stock names</p>
</dd>
</dl>

<p><code>catchdistribution</code> understands:
</p>

<dl>
<dt>data_function</dt><dd><p>The function Gadget should use, by default uses sumofsquares</p>
</dd>
<dt>data_function_params</dt><dd><p>Extra parameters to supply to gadget, based on the function</p>
</dd>
<dt>aggregationlevel</dt><dd><p>TRUE or FALSE, defaults to FALSE</p>
</dd>
<dt>overconsumption</dt><dd><p>TRUE or FALSE, defaults to FALSE</p>
</dd>
<dt>epsilon</dt><dd><p>Numeric, defaults to 10</p>
</dd>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
<dt>area</dt><dd><p>An <code>list</code> of areas, taken from <code>attr(data, "area")</code> if not supplied</p>
</dd>
<dt>age</dt><dd><p>An <code>list</code> of ages, taken from <code>attr(data, "age")</code> if not supplied</p>
</dd>
<dt>length</dt><dd><p>An <code>list</code> of lengths, taken from <code>attr(data, "length")</code> if not supplied</p>
</dd>
<dt>fleetnames</dt><dd><p>List of fleet names</p>
</dd>
<dt>stocknames</dt><dd><p>List of stock names</p>
</dd>
</dl>

<p><code>stockdistribution</code> understands:
</p>

<dl>
<dt>data_function</dt><dd><p>The function Gadget should use, by default uses sumofsquares</p>
</dd>
<dt>overconsumption</dt><dd><p>TRUE or FALSE, defaults to FALSE</p>
</dd>
<dt>epsilon</dt><dd><p>Numeric, defaults to 10</p>
</dd>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
<dt>area</dt><dd><p>An <code>list</code> of areas, taken from <code>attr(data, "area")</code> if not supplied</p>
</dd>
<dt>age</dt><dd><p>An <code>list</code> of ages, taken from <code>attr(data, "age")</code> if not supplied</p>
</dd>
<dt>length</dt><dd><p>An <code>list</code> of lengths, taken from <code>attr(data, "length")</code> if not supplied</p>
</dd>
<dt>fleetnames</dt><dd><p>List of fleet names</p>
</dd>
<dt>stocknames</dt><dd><p>List of stock names</p>
</dd>
</dl>

<p><code>surveydistribution</code> understands:
</p>

<dl>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
<dt>area</dt><dd><p>An <code>list</code> of areas, taken from <code>attr(data, "area")</code> if not supplied</p>
</dd>
<dt>length</dt><dd><p>An <code>list</code> of lengths, taken from <code>attr(data, "length")</code> if not supplied</p>
</dd>
<dt>age</dt><dd><p>An <code>list</code> of ages, taken from <code>attr(data, "age")</code> if not supplied</p>
</dd>
<dt>stocknames</dt><dd><p>List of stock names</p>
</dd>
<dt>fittype, slope, intercept</dt><dd><p>Fit options, see GADGET manual</p>
</dd>
<dt>parameters</dt><dd><p>A vector of length 2</p>
</dd>
<dt>suitability</dt><dd><p>A single suitability function</p>
</dd>
<dt>epsilon</dt><dd><p>Numeric, defaults to 10</p>
</dd>
<dt>likelihoodtype</dt><dd><p>String, see GADGET manual</p>
</dd>
</dl>

<p><code>surveyindices</code> understands:
</p>

<dl>
<dt>sitype</dt><dd><p>What data the component is based on, see GADGET manual</p>
</dd>
<dt>biomass</dt><dd><p>0 or 1, defaults to 0</p>
</dd>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
<dt>area</dt><dd><p>An <code>list</code> of areas, taken from <code>attr(data, "area")</code> if not supplied</p>
</dd>
<dt>age</dt><dd><p>An <code>list</code> of ages, taken from <code>attr(data, "age")</code> if not supplied</p>
</dd>
<dt>length</dt><dd><p>An <code>list</code> of lengths, taken from <code>attr(data, "length")</code> if not supplied</p>
</dd>
<dt>fleetnames</dt><dd><p>List of fleet names</p>
</dd>
<dt>stocknames</dt><dd><p>List of stock names</p>
</dd>
<dt>surveynames</dt><dd><p>List of acoustic survey names</p>
</dd>
<dt>fittype, slope, intercept</dt><dd><p>Fit options, see GADGET manual</p>
</dd>
</dl>

<p><code>stomachcontent</code> understands:
</p>

<dl>
<dt>data_function</dt><dd><p>Function GADGET will use</p>
</dd>
<dt>epsilon</dt><dd><p>To be used when calculated probability is low</p>
</dd>
<dt>prey_labels</dt><dd><p>Either a vector of stock names to be used for all preys, or a list to match preys, see below</p>
</dd>
<dt>prey_digestion_coefficients</dt><dd><p>Optional. Either a vector of coefficients fo be used for all preys, or a list to match preys, see below</p>
</dd>
<dt>predator_names</dt><dd><p>Vector of predator stock names</p>
</dd>
<dt>data</dt><dd><p>A <code>data.frame</code> probably generated by <code>mfdb_sample_meanlength_stddev</code></p>
</dd>
</dl>

<p>Both <code>prey_labels</code> and <code>prey_digestion_coefficients</code> allow you to
match parts of prey labels and use repetition. For instance,
<code>list("cod.mat" = "mature_cod", "cod" = "cod", "other")</code> will give
&quot;cod.mat&quot; the label &quot;mature_cod&quot;, &quot;cod.imm&quot; the label &quot;cod&quot;, and anything
else will get &quot;other&quot;. You can also use regular expression syntax, for example
&quot;cod[0-9]&quot;.
</p>
<p><code>migrationpenalty</code> understands:
</p>

<dl>
<dt>stockname</dt><dd><p>Stock name</p>
</dd>
<dt>powercoeffs</dt><dd><p>2 power coefficients</p>
</dd>
</dl>



<h3>Value</h3>

<p>A gadget_likelihood_component object that can then be written to a likelihood
file with <code>gadget_dir_write</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a penalty component
component &lt;- gadget_likelihood_component("penalty",
        name = "bounds",
        weight = "0.5",
        data = data.frame(
            switch = c("default"),
            power = c(2),
            stringsAsFactors = FALSE))
component

# Create an understocking component
component &lt;- gadget_likelihood_component("understocking", name ="understock")
component

# Any example could be added to a file with the following:-
gd &lt;- gadget_directory(tempfile())
gadget_dir_write(gd, component)
</code></pre>

<hr>
<h2 id='gadget_stockfile'>Gadget stock files</h2><span id='topic+gadget_stockfile_extremes'></span><span id='topic+gadget_stockfile_refweight'></span><span id='topic+gadget_stockfile_initialconditions'></span><span id='topic+gadget_stockfile_recruitment'></span>

<h3>Description</h3>

<p>Structures representing a GADGET stock file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gadget_stockfile_extremes(stock_name, data)
gadget_stockfile_refweight(stock_name, data)
gadget_stockfile_initialconditions(stock_name, data)
gadget_stockfile_recruitment(stock_name, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gadget_stockfile_+3A_stock_name">stock_name</code></td>
<td>

<p>A name, e.g. <code>cod.imm</code>, used as the name for the stockfile
</p>
</td></tr>
<tr><td><code id="gadget_stockfile_+3A_data">data</code></td>
<td>

<p>A data.frame used to generate the data. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns required in the <code>data</code> varies depends on which function you
are using.
</p>
<p><code>gadget_stockfile_extremes</code> requires <code>age</code> and <code>length</code> columns
and populates <code>minlength</code>, <code>minage</code>, <code>maxlength</code>, <code>maxage</code>.
The values are obtained by the grouping used, rather than the
maximum values in the data. If you want the minimum and maximum from the data,
query with <code>length = NULL, age = NULL</code>, so the table contains &quot;all&quot;
and the grouping contains the actual minimum and maximum.
</p>
<p><code>gadget_stockfile_refweight</code> requires a <code>length</code> column and a
<code>mean</code> column representing mean weight for that length group. It populates
the <code>refweightfile</code> and <code>dl</code>.
</p>
<p><code>gadget_stockfile_initialconditions</code> requires <code>area</code>, <code>age</code>,
<code>length</code>, <code>number</code> and <code>mean</code> (weight) columns. Populates
initialconditions <code>minlength</code>, <code>minage</code>, <code>maxlength</code>, <code>maxage</code>,
<code>dl</code> and the <code>numberfile</code>. As before, the min/max values are populated
using the groupings you specify, not the min/max available data.
</p>
<p><code>gadget_stockfile_recruitment</code> requires <code>year</code>, <code>step</code>, <code>area</code>,
<code>age</code>, <code>length</code>, <code>number</code> and <code>mean</code> (weight) columns. Populates
<code>doesrenew</code>, <code>minlength</code>, <code>maxlength</code>, <code>dl</code>, <code>numberfile</code>.
</p>


<h3>Value</h3>

<p>The return value is a <code>gadget_stockfile</code> object that can be written
to the filesystem with <code>gadget_dir_write</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# Define 2 areacells of equal size
mfdb_import_area(mdb, data.frame(name=c("divA", "divB"), size=1))

# Make up some samples
samples &lt;- expand.grid(
    year = 1998,
    month = c(1:12),
    areacell = c("divA", "divB"),
    species = 'COD',
    age = c(1:5),
    length = c(0,40,80))
samples$count &lt;- runif(nrow(samples), 20, 90)
mfdb_import_survey(mdb, data_source = "x", samples)

imm_data &lt;- mfdb_sample_meanweight(mdb, c('age', 'length'), list(
    age = NULL, # The age column will say 'all', but will know the min/max
    length = mfdb_step_interval('', 10, to = 100),
    species = 'COD'))

# Write both min/max and refweighfile into our gadget directory
component &lt;- gadget_stockfile_extremes('cod.imm', imm_data[[1]])
component

component &lt;- gadget_stockfile_refweight('cod.imm', imm_data[[1]])
component

gadget_dir_write(gadget_directory(tempfile()), component)

mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='mfdb'>MareFrame DB class</h2><span id='topic+mfdb'></span><span id='topic+mfdb_disconnect'></span>

<h3>Description</h3>

<p>Create a class representing a connection to a MareFrame DB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mfdb(schema_name,
         db_params = list(),
         destroy_schema = FALSE,
         save_temp_tables = FALSE)

    mfdb_disconnect(mdb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_+3A_schema_name">schema_name</code></td>
<td>

<p>This can be one of:
</p>

<ol>
<li><p> Postgresql schema name
</p>
</li>
<li><p> A file path ending with &quot;<code>.sqlite</code>&quot; to connect to a SQLite file database
</p>
</li>
<li><p> A file path ending with &quot;<code>.duckdb</code>&quot; to connect to a DuckDB file database
</p>
</li></ol>

<p>If connecting to a SQLite/DuckDB database, <var>db_params</var> should remain empty (
<var>schema_name</var> will be used as a <code>dbname</code>).
</p>
<p>If connecting to a Postgres database, it can be used to
store any number of case studies, by storing them in separate
<em>schemas</em>. This parameter defines the schema to connect to,
and can contain any lower case characters or underscore.
</p>
</td></tr>
<tr><td><code id="mfdb_+3A_db_params">db_params</code></td>
<td>

<p>Extra parameters to supply to <code>DBI::dbConnect</code>. By default it will
search for a &quot;mf&quot; database locally, but you can override any of the parameters,
in particular <code>host</code>, <code>dbname</code>, <code>user</code>, <code>password</code>.
See <code>?RPostgres::Postgres</code> for more information.
</p>
<p>If <code>dbname</code> looks like a SQLite database filename,
then MFDB will use the <code>RSQLite</code> driver. If <code>dbdir</code> is set, then
MFDB will use the <code>duckdb</code> driver. Otherwise, <code>RPostgres</code> will
be used.
</p>
<p><var>db_params</var> can also be supplied by environment variable, for example
if a <code>MFDB_DBNAME</code> environment variable is set then it will be used
instead of any <code>dbname</code> supplied here.
</p>
</td></tr>
<tr><td><code id="mfdb_+3A_destroy_schema">destroy_schema</code></td>
<td>

<p>Optional boolean. If true, all mfdb tables will be destroyed when
connecting. This allows you to start populating your case study from
scratch if required. The function will return NULL, you need to call
<code>mfdb</code> again to connect, at which point the mfdb tables will be
recreated and you can populate with data again.
</p>
</td></tr>
<tr><td><code id="mfdb_+3A_save_temp_tables">save_temp_tables</code></td>
<td>

<p>Optional boolean. If true, any temporary tables will be made permanent
for later inspection.
</p>
</td></tr>
<tr><td><code id="mfdb_+3A_mdb">mdb</code></td>
<td>

<p>Database connection created by <code>mfdb()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'mfdb' object representing the DB connection</p>


<h3>Examples</h3>

<pre><code class='language-R'># Connect to a SQLite database file
mdb &lt;- mfdb(tempfile(fileext = '.sqlite'))
mfdb_disconnect(mdb)

## Not run: # NB: Requires a PostgreSQL installation, see README

# Connect to local DB, as the "examples" case study
mdb &lt;- mfdb('examples')
mfdb_disconnect(mdb)

# Connect to remote server, will prompt for username/password
if (interactive()) {
    mdb &lt;- mfdb('examples', db_params = list(host = "mfdb.rhi.hi.is"))
}


## End(Not run)
</code></pre>

<hr>
<h2 id='mfdb_aggregate_group'>MareFrame DB groups</h2><span id='topic+mfdb_group'></span><span id='topic+mfdb_timestep_yearly'></span><span id='topic+mfdb_timestep_biannually'></span><span id='topic+mfdb_timestep_quarterly'></span><span id='topic+mfdb_group_numbered'></span><span id='topic+mfdb_bootstrap_group'></span>

<h3>Description</h3>

<p>Represent a grouping of data to be applied when summarising area, timestep,
age or length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Named grouping of discrete items
mfdb_group(...)

# Pre-baked mfdb_groups for timesteps
mfdb_timestep_yearly
mfdb_timestep_biannually
mfdb_timestep_quarterly

# Grouping of discrete items, names generated by prefix
mfdb_group_numbered(prefix, ...)

# make (count) mfdb_groups, by sampling (count) times from (group)
mfdb_bootstrap_group(count, group, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_aggregate_group_+3A_...">...</code></td>
<td>

<p>For <code>mfdb_group</code>, all named arguments are expected to be a named
list of members for that group.
For <code>mfdb_group_numbered</code>, the members do not have to be named, a
name will be generated based on the prefix.
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_group_+3A_prefix">prefix</code></td>
<td>

<p>When generating numeric group names, the character prefix to append to
the beginning.
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_group_+3A_group">group</code></td>
<td>

<p>For <code>mfdb_bootstrap_group</code>, the mfdb_group to do sampling with
replacement from.
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_group_+3A_count">count</code></td>
<td>

<p>For <code>mfdb_bootstrap_group</code>, how many times to sample each member
of the given group.
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_group_+3A_seed">seed</code></td>
<td>

<p>For <code>mfdb_bootstrap_group</code>, if you want your groups to remain
consistent across sessions, then specify a random integer as per RNG.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mfdb_aggregate</code> object that can then be used in querying functions
such as <code>mfdb_sample_count</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Aggregate age into 2 groups. "young" (for ages 1--3) and
## "old" (for ages 4--6)
g1 &lt;- mfdb_group(young = c(1,2,3), old = c(4,5,6))

## Aggregate areas into "area1" and "area2".
g2 &lt;- mfdb_group_numbered("area", c(1011,1012,1013), c(1021,1022))

## Take 3 samples with replacement from each group in area
g3 &lt;- mfdb_bootstrap_group(3, g2)
</code></pre>

<hr>
<h2 id='mfdb_aggregate_interval'>MareFrame DB intervals</h2><span id='topic+mfdb_interval'></span>

<h3>Description</h3>

<p>Represent a uniform or non-uniform interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_interval(prefix, vect, open_ended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_aggregate_interval_+3A_prefix">prefix</code></td>
<td>

<p>(required) A character prefix to prepend to minimum to create list names
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_interval_+3A_vect">vect</code></td>
<td>

<p>(required) A vector representing the minimum for each group, and the maximum
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_interval_+3A_open_ended">open_ended</code></td>
<td>

<p>If TRUE / c('upper'), the last group will ignore it's upper bound and include any value.
If c('lower'), the first group will ignore it's lower bound include everything &lt; the first value in vect.
If c('upper', 'lower'), both the above occur.
This is useful when creating plus groups for GADGET, as GADGET will still be presented a bounded group, but will contain all remaining data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mfdb_aggregate</code> object that can then be used in querying functions such as
<code>mfdb_sample_count</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Make groups of len40 (40--60), len60 (60--80)
g1 &lt;- mfdb_interval("len", c(40, 60, 80))

## Use seq to make life easier
g2 &lt;- mfdb_interval("len", seq(40, 80, by = 20))

## Create groups len40: [40, 60), len60: [60, inf) (but [60, 80) in the GADGET model)
g1 &lt;- mfdb_interval("len", c(40, 60, 80), open_ended = c("upper"))
</code></pre>

<hr>
<h2 id='mfdb_aggregate_na_group'>MareFrame DB aggregate NAs</h2><span id='topic+mfdb_na_group'></span>

<h3>Description</h3>

<p>A decorator for other MFDB attributes to file NAs into another group,
either one created by the main function or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_na_group(sub_aggregate, na_group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_aggregate_na_group_+3A_sub_aggregate">sub_aggregate</code></td>
<td>
<p>An <code>mfdb_aggregate</code> produced by another function, e.g. <code>mfdb_step_interval</code></p>
</td></tr>
<tr><td><code id="mfdb_aggregate_na_group_+3A_na_group">na_group</code></td>
<td>
<p>The group to assign NAs to, e.g. &quot;len_unknown&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NA group won't be added to any aggregate files generated by MFDB, since the
output would be invalid.
</p>


<h3>Value</h3>

<p>An <code>mfdb_aggregate</code> object that can then be used in querying functions such as
<code>mfdb_sample_count</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>length &lt;- mfdb_na_group(mfdb_step_interval("len", 10), 'len_unknown')
</code></pre>

<hr>
<h2 id='mfdb_aggregate_step_interval'>MareFrame DB intervals</h2><span id='topic+mfdb_step_interval'></span>

<h3>Description</h3>

<p>Groups data into uniform intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_step_interval(prefix, by, from = 0, to = NULL, open_ended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_aggregate_step_interval_+3A_prefix">prefix</code></td>
<td>

<p>(required) A character prefix to prepend to minimum to create list names
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_step_interval_+3A_by">by</code></td>
<td>

<p>(required) Increment of the sequence. NB: Must be an integer
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_step_interval_+3A_from">from</code>, <code id="mfdb_aggregate_step_interval_+3A_to">to</code></td>
<td>

<p>Start / end of the sequence. Defaults to 0 / infinity respectively.
</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_step_interval_+3A_open_ended">open_ended</code></td>
<td>

<p>If TRUE / c('upper'), the last group will ignore it's upper bound and include any value.
If c('lower'), the first group will ignore it's lower bound include everything &lt; the first value in vect.
If c('upper', 'lower'), both the above occur.
This is useful when creating plus groups for GADGET, as GADGET will still be presented a bounded group, but will contain all remaining data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mfdb_aggregate</code> object that can then be used in querying functions such as
<code>mfdb_sample_count</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Make groups of len0 (0--5), len5 (5--10), ... len45(45--50)
g1 &lt;- mfdb_step_interval("len", 5, to = 50)

## Make groups of len0 (0--5), len5 (5--10), ... len45(45--50), len50(50--inf)
g2 &lt;- mfdb_step_interval("len", 5, to = 50, open_ended = TRUE)
</code></pre>

<hr>
<h2 id='mfdb_aggregate_unaggregated'>MareFrame DB unaggregated data</h2><span id='topic+mfdb_unaggregated'></span>

<h3>Description</h3>

<p>Tell mfdb functions not to aggregate this column, just return all values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_unaggregated(omitNA = FALSE, like = c(), not_like = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_aggregate_unaggregated_+3A_omitna">omitNA</code></td>
<td>
<p>Skip over rows where column is NA</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_unaggregated_+3A_like">like</code></td>
<td>
<p>Vector of SQL like expressions to check column against</p>
</td></tr>
<tr><td><code id="mfdb_aggregate_unaggregated_+3A_not_like">not_like</code></td>
<td>
<p>Vector of SQL like expressions to check column against</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SQL like expessions can use the wildcards &quot;_&quot; to match any character and
&quot;
</p>


<h3>Value</h3>

<p>An <code>mfdb_aggregate</code> object that can then be used in querying functions such as
<code>mfdb_sample_count</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All vessels with a name ending with 'e' or 'd'
mfdb_unaggregated(like = c("%e", "%d"))
</code></pre>

<hr>
<h2 id='mfdb_bulk'>MareFrame DB Dump / Restore</h2><span id='topic+mfdb_cs_dump'></span><span id='topic+mfdb_cs_restore'></span>

<h3>Description</h3>

<p>Dump / Restore entire case studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_cs_dump(mdb, out_location)
mfdb_cs_restore(mdb, in_location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_bulk_+3A_mdb">mdb</code></td>
<td>

<p>(required) A database connection created by <code>mfdb</code>()
</p>
</td></tr>
<tr><td><code id="mfdb_bulk_+3A_in_location">in_location</code>, <code id="mfdb_bulk_+3A_out_location">out_location</code></td>
<td>

<p>(required) A filesystem directory or '.tar.gz' file to dump / restore database contents.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated: These commands aren't strictly necessary any more. In most
situations it will be easier to use Postgres' <code>pg_dump</code> and <code>pg_restore</code>.
See <a href="#topic+mfdb-package">mfdb-package</a> for some examples of how to do it. These functions
don't offer much more functionality and much slower.
</p>
<p><code>mfdb_cs_dump</code> copies all data from the database/case-study that <code>mdb</code>
is connected to, and writes it out to files in <code>out_location</code>. If this
ends with 'tar.gz', then all files will be put into a tarball with the name
</p>
<p><code>mfdb_cs_restore</code> will remove any case-study data, and replaces it with the
content of <code>in_location</code>, a directory or tarball.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy data from one database to another, note they don't have to be the same type
mdb_out &lt;- mfdb(tempfile(fileext = '.sqlite'))
mdb_in &lt;- mfdb(tempfile(fileext = '.duckdb'))

dump_path &lt;- tempfile(fileext='.tar.gz')
mfdb_cs_dump(mdb_out, dump_path)
mfdb_cs_restore(mdb_in, dump_path)

mfdb_disconnect(mdb_in)
mfdb_disconnect(mdb_out)
</code></pre>

<hr>
<h2 id='mfdb_dplyr'>MareFrame DB dplyr interface</h2><span id='topic+mfdb_dplyr_table'></span><span id='topic+mfdb_dplyr_survey_index'></span><span id='topic+mfdb_dplyr_division'></span><span id='topic+mfdb_dplyr_sample'></span><span id='topic+mfdb_dplyr_predator'></span><span id='topic+mfdb_dplyr_prey'></span>

<h3>Description</h3>

<p>Use mfdb tables with dplyr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_dplyr_table(mdb, table_name, include_cols = all_cols)
mfdb_dplyr_survey_index(mdb, include_cols = all_cols)
mfdb_dplyr_division(mdb, include_cols = all_cols)
mfdb_dplyr_sample(mdb, include_cols = all_cols)
mfdb_dplyr_predator(mdb, include_cols = all_cols)
mfdb_dplyr_prey(mdb, include_cols = all_cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_dplyr_+3A_mdb">mdb</code></td>
<td>
<p>An object created by <code>mfdb</code>()</p>
</td></tr>
<tr><td><code id="mfdb_dplyr_+3A_table_name">table_name</code></td>
<td>
<p>A table name to query in</p>
</td></tr>
<tr><td><code id="mfdb_dplyr_+3A_include_cols">include_cols</code></td>
<td>
<p>Any additonal columns to include in output, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: Whilst these might be handy for exploration, there is no guarantee
that code using these will continue to work from one version of MFDB to the
next.
</p>
<p>There is one function for each measurement table. By default every possible
taxonomy column is included. However this is somewhat inefficient if you do
not require the data, in which case specify the columns requred with
<code>include_cols</code>. See <code>mfdb::mfdb_taxonomy_tables</code> for possible values.
</p>
<p>To query taxonomy tables, use <code>mfdb_dplyr_table</code>, which works for any supplied table name.
See <code>mfdb::mfdb_taxonomy_tables</code> for possible values for <var>table_name</var>.
</p>


<h3>Value</h3>

<p>A dplyr table object, for you to do as you please.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# Include as many columns as possible
mfdb_dplyr_sample(mdb)

# Only include 'data_source' and 'species' columns, as well as measurements
mfdb_dplyr_sample(mdb, c('data_source', 'species'))

# Query the sampling_type table
mfdb_dplyr_table(mdb, 'sampling_type')

mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='mfdb_helpers'>MareFrame tools &amp; helpers</h2><span id='topic+mfdb_find_species'></span>

<h3>Description</h3>

<p>Misc. functions to aid working with an MFDB database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Find species from abbreviated names
mfdb_find_species(partial_name, single_matches_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_helpers_+3A_partial_name">partial_name</code></td>
<td>

<p>Vector of partial species names, e.g. &quot;Gad Mor&quot;, &quot;gad. Mor.&quot;,
&quot;Gadus Mor&quot;, will all match &quot;Cod (Gadus Morhua)&quot;.
</p>
</td></tr>
<tr><td><code id="mfdb_helpers_+3A_single_matches_only">single_matches_only</code></td>
<td>

<p>Logical, default FALSE. If true, return NA for
partial_names with multiple or zero matches.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of all potential id, name &amp; descriptions for each item in
<code>partial_name</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mfdb_find_species(c("gad mor", "tube worms"))
#             gad mor              tube worms              
# id          8791030402           1e+10                   
# name        "COD"                "TBX"                   
# description "Cod (Gadus Morhua)" "Tube Worms (Tubeworms)"

# Can also generate a map to help insert a data.frame of foreign data
stomachs &lt;- read.csv(text = '
stomach_name,species,digestion_stage,length,weight,count
A,Palaemon Elegans,1,1,10,5
A,Palaemon Elegans,1,4,40,1
B,Palaemon Elegans,1,1,10,5
B,Palaemon Elegans,4,1,10,5
B,Palaemon Elegans,5,1,10,NA
B,Palaemon Elegans,5,1,10,NA
C,Crangon Crangon,2,3.5,9.5,3
D,Palaemon Elegans,1,1.4,10,1
D,Crangon Crangon,5,4,40,1
E,Worms,1,1.4,10,1
', stringsAsFactors = TRUE)

# Work out a map from all Prey_Species_Name values to MFDB species codes
species_map &lt;- mfdb_find_species(levels(stomachs$species), single_matches_only = TRUE)['name',]

# Put the new levels back onto the species column
levels(stomachs$species) &lt;- unlist(species_map)

stomachs
</code></pre>

<hr>
<h2 id='mfdb_helpers_mfdb_concatenate_results'>MareFrame Query Utilities</h2><span id='topic+mfdb_concatenate_results'></span>

<h3>Description</h3>

<p>Aggregate data from the database in a variety of ways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_concatenate_results(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_helpers_mfdb_concatenate_results_+3A_...">...</code></td>
<td>
<p>Any number of data.frames produced by mfdb query functions with identical columns, e.g. <code>mfdb_sample_count</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Given any number of data.frames from mfdb query functions with identical
columns, produces a combined data.frame, similar to <code>rbind</code> but
preserving the attributes required to produce aggregation files.
</p>

<hr>
<h2 id='mfdb_import_data'>MareFrame Data Import functions</h2><span id='topic+mfdb_import_temperature'></span><span id='topic+mfdb_import_survey'></span><span id='topic+mfdb_import_survey_index'></span><span id='topic+mfdb_import_stomach'></span>

<h3>Description</h3>

<p>Functions to import data into MareFrame DB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mfdb_import_temperature(mdb, data_in)
    mfdb_import_survey(mdb, data_in, data_source = 'default_sample')
    mfdb_import_survey_index(mdb, data_in, data_source = 'default_index')
    mfdb_import_stomach(mdb, predator_data, prey_data, data_source = "default_stomach")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_import_data_+3A_mdb">mdb</code></td>
<td>

<p>Database connection created by <code>mfdb()</code>.
</p>
</td></tr>
<tr><td><code id="mfdb_import_data_+3A_data_in">data_in</code>, <code id="mfdb_import_data_+3A_predator_data">predator_data</code>, <code id="mfdb_import_data_+3A_prey_data">prey_data</code></td>
<td>

<p>A <code>data.frame</code> of survey data to import, see details.
</p>
</td></tr>
<tr><td><code id="mfdb_import_data_+3A_data_source">data_source</code></td>
<td>

<p>A name for this data, e.g. the filename it came from. Used so you can replace it later without disturbing other data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions will replace existing data in the case study with new data, unless you specify a <code>data_source</code>,
in which case then only existing data with the same <code>data_source</code> will be replaced.
</p>
<p>If you want to remove the data, import empty data.frames with the same <code>data_source</code>.
</p>
<p><code>mfdb_import_temperature</code> imports temperature time-series data for
areacells. The <code>data_in</code> should be a data.frame with the following columns:
</p>

<dl>
<dt>id</dt><dd><p>A numeric ID for this areacell (will be combined with the case study number internally)</p>
</dd>
<dt>year</dt><dd><p>Required. Year each sample was taken, e.g. <code>c(2000,2001)</code></p>
</dd>
<dt>month</dt><dd><p>Required. Month (1&ndash;12) each sample was taken, e.g. <code>c(1,12)</code></p>
</dd>
<dt>areacell</dt><dd><p>Required. Areacell sample was taken within</p>
</dd>
<dt>temperature</dt><dd><p>The temperature at given location/time</p>
</dd>
</dl>

<p><code>mfdb_import_survey</code> imports institution surveys and commercial sampling for your case study. The
<code>data_in</code> should be a data.frame with the following columns:
</p>

<dl>
<dt>institute</dt><dd><p>Optional. An institute name, see mfdb::institute for possible values</p>
</dd>
<dt>gear</dt><dd><p>Optional. Gear name, see mfdb::gear for possible values</p>
</dd>
<dt>vessel</dt><dd><p>Optional. Vessel defined previously with <code>mfdb_import_vessel_taxonomy(...)</code></p>
</dd>
<dt>tow</dt><dd><p>Optional. Tow defined previously with <code>mfdb_import_tow_taxonomy(...)</code></p>
</dd>
<dt>sampling_type</dt><dd><p>Optional. A sampling_type, see mfdb::sampling_type for possible values</p>
</dd>
<dt>year</dt><dd><p>Required. Year each sample was taken, e.g. <code>c(2000,2001)</code></p>
</dd>
<dt>month</dt><dd><p>Required. Month (1&ndash;12) each sample was taken, e.g. <code>c(1,12)</code></p>
</dd>
<dt>areacell</dt><dd><p>Required. Areacell sample was taken within</p>
</dd>
<dt>species</dt><dd><p>Optional, default <code>c(NA)</code>. Species of sample, see mfdb::species for possible values</p>
</dd>
<dt>age</dt><dd><p>Optional, default <code>c(NA)</code>. Age of sample, or mean age</p>
</dd>
<dt>sex</dt><dd><p>Optional, default <code>c(NA)</code>. Sex of sample, see mfdb::sex for possible values</p>
</dd>
<dt>length</dt><dd><p>Optional, default <code>c(NA)</code>. Length of sample / mean length of all samples</p>
</dd>
<dt>length_var</dt><dd><p>Optional, default <code>c(NA)</code>. Sample variance, if data is already aggregated</p>
</dd>
<dt>length_min</dt><dd><p>Optional, default <code>c(NA)</code>. Minimum theoretical length, if data is already aggregated</p>
</dd>
<dt>weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample / mean weight of all samples</p>
</dd>
<dt>weight_var</dt><dd><p>Optional, default <code>c(NA)</code>. Sample variance, if data is already aggregated</p>
</dd>
<dt>weight_total</dt><dd><p>Optional, default <code>c(NA)</code>. Total weight of all samples, can be used with count = NA to represent an unknown number of samples</p>
</dd>
<dt>liver_weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample / mean liver weight of all samples</p>
</dd>
<dt>liver_weight_var</dt><dd><p>Optional, default <code>c(NA)</code>. Sample variance, if data is already aggregated</p>
</dd>
<dt>gonad_weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample / mean gonad weight of all samples</p>
</dd>
<dt>gonad_weight_var</dt><dd><p>Optional, default <code>c(NA)</code>. Sample variance, if data is already aggregated</p>
</dd>
<dt>stomach_weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample / mean stomach weight of all samples</p>
</dd>
<dt>stomach_weight_var</dt><dd><p>Optional, default <code>c(NA)</code>. Sample variance, if data is already aggregated</p>
</dd>
<dt>count</dt><dd><p>Optional, default <code>c(1)</code>. Number of samples this row represents (i.e. if the data is aggregated)</p>
</dd>
</dl>

<p><code>mfdb_import_survey_index</code> adds indicies that can be used as abundance information, for example.
Before using <code>mfdb_import_survey_index</code>, make sure that the <code>index_type</code> you intend to use
exists by using <a href="#topic+mfdb_import_cs_taxonomy">mfdb_import_cs_taxonomy</a>. The <code>data_in</code> should be a data.frame with the
following columns:
</p>

<dl>
<dt>index_type</dt><dd><p>Required. the name of the index data you are storing, e.g. 'acoustic'</p>
</dd>
<dt>year</dt><dd><p>Required. Year each sample was taken, e.g. <code>c(2000,2001)</code></p>
</dd>
<dt>month</dt><dd><p>Required. Month (1&ndash;12) each sample was taken, e.g. <code>c(1,12)</code></p>
</dd>
<dt>areacell</dt><dd><p>Required. Areacell sample was taken within</p>
</dd>
<dt>value</dt><dd><p>Value of the index at this point in space/time</p>
</dd>
</dl>

<p><code>mfdb_import_stomach</code> imports data on predators and prey. The predator and prey
data are stored separately, however they should be linked by the <code>stomach_name</code> column.
If a prey has a stomach name that doesn't match a predator, then an error will be returned.
</p>
<p>The <code>predator_data</code> should be a data.frame with the following columns:
</p>

<dl>
<dt>stomach_name</dt><dd><p>Required. An arbitary name that provides a link between the predator and prey tables</p>
</dd>
<dt>institute</dt><dd><p>Optional. An institute name, see mfdb::institute for possible values</p>
</dd>
<dt>gear</dt><dd><p>Optional. Gear name, see mfdb::gear for possible values</p>
</dd>
<dt>vessel</dt><dd><p>Optional. Vessel defined previously with <code>mfdb_import_vessel_taxonomy(mdb, ...)</code></p>
</dd>
<dt>tow</dt><dd><p>Optional. Tow defined previously with <code>mfdb_import_tow_taxonomy(...)</code></p>
</dd>
<dt>sampling_type</dt><dd><p>Optional. A sampling_type, see mfdb::sampling_type for possible values</p>
</dd>
<dt>year</dt><dd><p>Required. Year each sample was taken, e.g. <code>c(2000,2001)</code></p>
</dd>
<dt>month</dt><dd><p>Required. Month (1&ndash;12) each sample was taken, e.g. <code>c(1,12)</code></p>
</dd>
<dt>areacell</dt><dd><p>Required. Areacell sample was taken within</p>
</dd>
<dt>species</dt><dd><p>Optional, default <code>c(NA)</code>. Species of sample, see mfdb::species for possible values</p>
</dd>
<dt>age</dt><dd><p>Optional, default <code>c(NA)</code>. Age of sample, or mean age</p>
</dd>
<dt>sex</dt><dd><p>Optional, default <code>c(NA)</code>. Sex of sample, see mfdb::sex for possible values</p>
</dd>
<dt>maturity_stage</dt><dd><p>Optional, default <code>c(NA)</code>. Maturity stage of sample, see mfdb::maturity_stage for possible values</p>
</dd>
<dt>stomach_state</dt><dd><p>Optional, default <code>c(NA)</code>. Stomach state of sample, see mfdb::stomach_state for possible values</p>
</dd>
<dt>length</dt><dd><p>Optional, default <code>c(NA)</code>. Length of sample</p>
</dd>
<dt>weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample</p>
</dd>
</dl>

<p>The <code>prey_data</code> should be a data.frame with the following columns:
</p>

<dl>
<dt>stomach_name</dt><dd><p>Required. The stomach name of the predator this was found in</p>
</dd>
<dt>species</dt><dd><p>Optional, default <code>c(NA)</code>. Species of sample, see mfdb::species for possible values</p>
</dd>
<dt>digestion_stage</dt><dd><p>Optional, default <code>c(NA)</code>. Stage of digestion of the sample, see mfdb::digestion_stage for possible values</p>
</dd>
<dt>length</dt><dd><p>Optional, default <code>c(NA)</code>. Length of sample / mean length of all samples</p>
</dd>
<dt>weight</dt><dd><p>Optional, default <code>c(NA)</code>. Weight of sample / mean weight of all samples</p>
</dd>
<dt>weight_total</dt><dd><p>Optional, default <code>c(NA)</code>. Total weight of all samples</p>
</dd>
<dt>count</dt><dd><p>Optional, default <code>c(NA)</code>. Number of samples this row represents (i.e. if the data is aggregated), count = NA represents an unknown number of samples</p>
</dd>
</dl>



<h3>Value</h3>

<p>NULL</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# We need to set-up vocabularies first
mfdb_import_area(mdb, data.frame(
    id = c(1,2,3),
    name = c('35F1', '35F2', '35F3'),
    size = c(5)))
mfdb_import_vessel_taxonomy(mdb, data.frame(
    name = c('1.RSH', '2.COM'),
    stringsAsFactors = FALSE))
mfdb_import_sampling_type(mdb, data.frame(
    name = c("RES", "LND"),
    description = c("Research", "Landings"),
    stringsAsFactors = FALSE))

data_in &lt;- read.csv(text = '
year,month,areacell,species,age,sex,length
1998,1,35F1,COD,3,M,140
1998,1,35F1,COD,3,M,150
1998,1,35F1,COD,3,F,150
')

data_in$institute &lt;- 'MRI'
data_in$gear &lt;- 'GIL'
data_in$vessel &lt;- '1.RSH'
data_in$sampling_type &lt;- 'RES'
mfdb_import_survey(mdb, data_in, data_source = 'cod-1998')

mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='mfdb_import_taxonomy'>MareFrame Taxonomy import functions</h2><span id='topic+mfdb_import_area'></span><span id='topic+mfdb_import_division'></span><span id='topic+mfdb_import_sampling_type'></span><span id='topic+mfdb_import_bait_type_taxonomy'></span><span id='topic+mfdb_import_cs_taxonomy'></span><span id='topic+mfdb_import_gear_taxonomy'></span><span id='topic+mfdb_import_population_taxonomy'></span><span id='topic+mfdb_import_port_taxonomy'></span><span id='topic+mfdb_import_tow_taxonomy'></span><span id='topic+mfdb_import_net_type_taxonomy'></span><span id='topic+mfdb_import_trip_taxonomy'></span><span id='topic+mfdb_import_vessel_taxonomy'></span><span id='topic+mfdb_import_vessel_owner_taxonomy'></span><span id='topic+mfdb_import_species_taxonomy'></span><span id='topic+mfdb_empty_taxonomy'></span>

<h3>Description</h3>

<p>Functions to import taxonomy data into MareFrame DB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mfdb_import_area(mdb, data_in)
    mfdb_import_division(mdb, data_in)
    mfdb_import_sampling_type(mdb, data_in)
    mfdb_import_bait_type_taxonomy(mdb, data_in)
    mfdb_import_population_taxonomy(mdb, data_in)
    mfdb_import_port_taxonomy(mdb, data_in)
    mfdb_import_tow_taxonomy(mdb,  data_in)
    mfdb_import_net_type_taxonomy(mdb, data_in)
    mfdb_import_trip_taxonomy(mdb, data_in)
    mfdb_import_vessel_taxonomy(mdb,  data_in)
    mfdb_import_vessel_owner_taxonomy(mdb,  data_in)

    mfdb_empty_taxonomy(mdb, taxonomy_name)

    mfdb_import_cs_taxonomy(mdb, taxonomy_name, data_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_import_taxonomy_+3A_mdb">mdb</code></td>
<td>

<p>Database connection created by <code>mfdb()</code>.
</p>
</td></tr>
<tr><td><code id="mfdb_import_taxonomy_+3A_taxonomy_name">taxonomy_name</code></td>
<td>

<p>The name of the taxonomy to import, if there isn't a special function for it.
See <code>mfdb:::mfdb_taxonomy_tables</code> for possible values.
</p>
</td></tr>
<tr><td><code id="mfdb_import_taxonomy_+3A_data_in">data_in</code></td>
<td>

<p>A <code>data.frame</code> of data to import, see details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MFDB taxonomies define the values you can use when importing / querying for data.
They need to be populated with the values you need before data is imported. Most
taxonomies are pre-populated by the MFDB package, so you should use the predefined
values. Others however this does not make sense, so should be done separately. This
is what these functions do.
</p>
<p><code>mfdb_import_division</code> is a special case, which imports groupings of areacells
into divisions, if you haven't already done this with <code>mfdb_import_area</code> or your
divisions are too complicated to represent this way. The <code>data_in</code> should be a
list of areacell vectors, with division names. For example,
<code>list(divA = c('45G01', '45G02', '45G03'))</code>
</p>
<p>Beyond this, all functions accept the following columns:
</p>

<dl>
<dt>id</dt><dd><p>Optional. A numeric ID to use internally, defaults to 1..n</p>
</dd>
<dt>name</dt><dd><p>Required. A vector of short names to use in data, e.g. &quot;SEA&quot;</p>
</dd>
<dt>t_group</dt><dd><p>Optional. A vector of the that groups together a set of values</p>
</dd>
</dl>

<p>Note that the database doesn't use your short names internally. This means you can
rename items by changing what <code>name</code> is set to. <code>t_group</code> allows taxonomy
values to be grouped together. For example, giving all vessels in a fleet the same
t_group you can then query the entire fleet as well as individually.
</p>
<p><code>mfdb_import_area</code> imports areacell information for your case study.
Beyond the above, you can also provide the following:
</p>

<dl>
<dt>size</dt><dd><p>The size of the areacell</p>
</dd>
<dt>depth</dt><dd><p>The depth of the areacell</p>
</dd>
<dt>division</dt><dd><p>The name of the division this areacell is part of</p>
</dd>
</dl>

<p><code>mfdb_import_vessel_taxonomy</code> imports names of vessels into the
taxonomy table, so they can be used when importing samples. As well as the above, you can
also specify:
</p>

<dl>
<dt>full_name</dt><dd><p>Optional. The full name of this vessel</p>
</dd>
<dt>length</dt><dd><p>Optional. The length of the vessel in meters</p>
</dd>
<dt>power</dt><dd><p>Optional. The vessel's engine power in KW</p>
</dd>
<dt>tonnage</dt><dd><p>Optional. The vessel's gross tonnage</p>
</dd>
<dt>vessel_owner</dt><dd><p>Optional. The short name of the vessel owner (see <code>mfdb_import_vessel_owner_taxonomy</code>)</p>
</dd>
</dl>

<p><code>mfdb_import_vessel_owner_taxonomy</code> imports names of vessels owners into a
taxonomy table, to be used when importing vessels. As well as name/t_group, you
can also specify:
</p>

<dl>
<dt>full_name</dt><dd><p>Optional. The full name of the owning organisation</p>
</dd>
</dl>

<p><code>mfdb_import_tow_taxonomy</code> imports names of vessels into the
taxonomy table, so they can be used when importing samples. As well as the
above, you can also specify:
</p>

<dl>
<dt>latitude</dt><dd><p>Optional.</p>
</dd>
<dt>longitude</dt><dd><p>Optional.</p>
</dd>
<dt>depth</dt><dd><p>Optional. Depth in meters</p>
</dd>
<dt>length</dt><dd><p>Optional. Length in meters</p>
</dd>
</dl>

<p><code>mfdb_import_port_taxonomy</code> imports names of ports that trips can
start/finish at. As well as id/name, you can provide:
</p>

<dl>
<dt>latitude</dt><dd><p>Optional. Latitutde as real number</p>
</dd>
<dt>longitude</dt><dd><p>Optional. Latitutde as real number</p>
</dd>
<dt>institute</dt><dd><p>Optional. Institute (from institute taxonomy, could be country) responsible for port</p>
</dd>
</dl>

<p><code>mfdb_import_trip_taxonomy</code> imports names of trips that samples can be
labelled part of. As well as id/name, you can provide:
</p>

<dl>
<dt>latitude</dt><dd><p>Optional. Latitutde as real number</p>
</dd>
<dt>longitude</dt><dd><p>Optional. Latitutde as real number</p>
</dd>
<dt>start_date</dt><dd><p>Optional. Start date-time, as <code>YYYY-MM-DD</code> or <code>YYYY-MM-DD HH:MM:SS</code></p>
</dd>
<dt>end_date</dt><dd><p>Optional. End date-time, as <code>YYYY-MM-DD</code> or <code>YYYY-MM-DD HH:MM:SS</code></p>
</dd>
<dt>crew</dt><dd><p>Optional. Number of crew on-board</p>
</dd>
<dt>oil_consumption</dt><dd><p>Optional. Total oil consumption for trip</p>
</dd>
<dt>start_port</dt><dd><p>Optional. Name of port (from port taxonomy) trip started</p>
</dd>
<dt>end_port</dt><dd><p>Optional. Name of port (from port taxonomy) trip finished</p>
</dd>
</dl>

<p><code>mfdb_import_sampling_type</code> imports sampling types so that you can then use
these against records in the <code>sample</code> table. You can also provide:
</p>

<dl>
<dt>description</dt><dd><p>Optional. A vector of descriptive names, e.g. &quot;sea sampling&quot;</p>
</dd>
</dl>

<p><code>mfdb_empty_taxonomy</code> allows you to empty out a taxonomy of previous data.
The import functions insert or update values that already exist, based on the
numeric ID for these values. They do not delete anything, as it may be impossible
to remove rows without destroying existing data.
</p>
<p>However, if e.g. you want to replace the species taxonomy with an entirely different
one you will need to flush it first, before you import any data. Use this function,
then <code>mfdb_import_species_taxonomy</code> to import the new taxonomy.
</p>
<p>NB: This won't be possible if there is some data already using any of the terms. It
is best used before your database is populated.
</p>


<h3>Value</h3>

<p>NULL</p>

<hr>
<h2 id='mfdb_queries'>MareFrame DB queries</h2><span id='topic+mfdb_area_size'></span><span id='topic+mfdb_area_size_depth'></span><span id='topic+mfdb_temperature'></span><span id='topic+mfdb_survey_index_mean'></span><span id='topic+mfdb_survey_index_total'></span><span id='topic+mfdb_sample_count'></span><span id='topic+mfdb_sample_meanlength_stddev'></span><span id='topic+mfdb_sample_meanlength'></span><span id='topic+mfdb_sample_totalweight'></span><span id='topic+mfdb_sample_meanweight'></span><span id='topic+mfdb_sample_meanweight_stddev'></span><span id='topic+mfdb_sample_rawdata'></span><span id='topic+mfdb_sample_scaled'></span><span id='topic+mfdb_stomach_preycount'></span><span id='topic+mfdb_stomach_preymeanlength'></span><span id='topic+mfdb_stomach_preymeanweight'></span><span id='topic+mfdb_stomach_preyweightratio'></span><span id='topic+mfdb_stomach_presenceratio'></span>

<h3>Description</h3>

<p>Aggregate data from the database in a variety of ways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_area_size(mdb, params)
mfdb_area_size_depth(mdb, params)
mfdb_temperature(mdb, params)
mfdb_survey_index_mean(mdb, cols, params, scale_index = NULL)
mfdb_survey_index_total(mdb, cols, params, scale_index = NULL)
mfdb_sample_count(mdb, cols, params, scale_index = NULL)
mfdb_sample_meanlength(mdb, cols, params, scale_index = NULL)
mfdb_sample_meanlength_stddev(mdb, cols, params, scale_index = NULL)
mfdb_sample_totalweight(mdb, cols, params, measurements = c('overall'))
mfdb_sample_meanweight(mdb, cols, params, scale_index = NULL,
                       measurements = c('overall'))
mfdb_sample_meanweight_stddev(mdb, cols, params, scale_index = NULL,
                              measurements = c('overall'))
mfdb_sample_rawdata(mdb, cols, params, scale_index = NULL)
mfdb_sample_scaled(mdb, cols, params, abundance_scale = NULL, scale = 'tow_length')
mfdb_stomach_preycount(mdb, cols, params)
mfdb_stomach_preymeanlength(mdb, cols, params)
mfdb_stomach_preymeanweight(mdb, cols, params)
mfdb_stomach_preyweightratio(mdb, cols, params)
mfdb_stomach_presenceratio(mdb, cols, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_queries_+3A_mdb">mdb</code></td>
<td>
<p>An object created by <code>mfdb</code>()</p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_cols">cols</code></td>
<td>
<p>Any additonal columns to group by, see details.</p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_params">params</code></td>
<td>
<p>A list of parameters, see details.</p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_scale_index">scale_index</code></td>
<td>
<p>Optional. survey_index used to scale results before aggregation, either &quot;tow_length&quot;, &quot;area_size&quot; or from <a href="#topic+mfdb_import_survey_index">mfdb_import_survey_index</a></p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_abundance_scale">abundance_scale</code></td>
<td>
<p>Optional. Same as <code>scale_index</code></p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_scale">scale</code></td>
<td>
<p>Optional. A scale to apply to the resulting values, e.g. 'tow_length'</p>
</td></tr>
<tr><td><code id="mfdb_queries_+3A_measurements">measurements</code></td>
<td>
<p>Optional, default 'overall'. A vector of measurement names to use, one of overall, liver, gonad, stomach</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The items in the <code>params</code> list either restrict data that is returned, or
groups data if they are also in the <code>cols</code> vector, or are 'year',
'timestep', or 'area'.
</p>
<p>If you are grouping by the column, <code>params</code> should contain one of the
following:
</p>

<dl>
<dt>NULL</dt><dd>
<p>Don't do any grouping, instead put 'all' in the resulting column.
For example, <code>age = NULL</code> results in &quot;all&quot;.
</p>
</dd>
<dt>character / numeric vector</dt><dd>
<p>Aggregate all samples together where they match.
For example, <code>year = 1990:2000</code> results in 1990, ... , 2000.
</p>
</dd>
<dt>mfdb_unaggregated()</dt><dd>
<p>Don't do any aggregation for this column, return all possible values.
</p>
</dd>
<dt>mfdb_group()</dt><dd>
<p>Group several discrete items together.
For example, <code>age = mfdb_group(young = 1:3, old = 4:5)</code>
results in &quot;young&quot; and &quot;old&quot;.
</p>
</dd>
<dt>mfdb_interval()</dt><dd>
<p>Group irregular ranges together.
For example, <code>length = mfdb_interval('len', c(0, 10, 100, 1000))</code>
results in &quot;len0&quot;, &quot;len10&quot;, &quot;len100&quot; (1000 is the upper bound to len100).
</p>
</dd>
<dt>mfdb_step_interval()</dt><dd>
<p>Group regular ranges together.
For example, <code>length = mfdb_step_interval('len', to = 100, by = 10)</code>
results in &quot;len0&quot;, &quot;len10&quot;, ... , &quot;len90&quot;.
</p>
</dd>
</dl>

<p>In addition, <code>params</code> can contain other arguments to purely restrict the
data that is returned.
</p>

<dl>
<dt>institute</dt><dd><p>A vector of institute names / countries, see mfdb::institute for possible values</p>
</dd>
<dt>gear</dt><dd><p>A vector of gear names, see mfdb::gear for possible values</p>
</dd>
<dt>vessel</dt><dd><p>A vector of vessel names, see mfdb::vessel for possible values</p>
</dd>
<dt>sampling_type</dt><dd><p>A vector of sampling_type names, see mfdb::sampling_type for possible values</p>
</dd>
<dt>species</dt><dd><p>A vector of species names, see mfdb::species for possible values</p>
</dd>
<dt>sex</dt><dd><p>A vector of sex names, see mfdb::sex for possible values</p>
</dd>
</dl>

<p>To save specifying the same items repeatedly, you can use list
concatenation to keep some defaults, for example:
</p>
<pre>
defaults &lt;- list(year = 1998:2000)
mfdb_sample_meanlength(mdb, c('age'), c(list(), defaults))
</pre>
<p><code>scale_index</code> allows you to scale samples before aggregation. If 
it contains the name of a survey index (see <a href="#topic+mfdb_import_survey_index">mfdb_import_survey_index</a>),
then any counts will be scaled by the value for that areacell before and used in
aggregation / weighted averages. As a special case, you can use &quot;tow_length&quot; to
to scale counts by the tow length.
</p>


<h3>Value</h3>

<p>All will return a list of data.frame objects. If there was no bootstrapping
requested, there will be only one. Otherwise, there will be one for each
sample.
</p>
<p>The columns of these data frames depends on the function called.
</p>

<dl>
<dt>mfdb_area_size</dt><dd>
<p>Returns area, (total area) size
</p>
</dd>
<dt>mfdb_area_size_depth</dt><dd>
<p>Returns area, (total area) size, mean depth, weighted by area size
</p>
</dd>
<dt>mfdb_temperature</dt><dd>
<p>Returns year, step, area, (mean) temperature
</p>
</dd>
<dt>mfdb_survey_index_mean</dt><dd>
<p>Returns year, step, area, (group cols), (mean) survey index
</p>
</dd>
<dt>mfdb_survey_index_total</dt><dd>
<p>Returns year, step, area, (group cols), (sum) survey index
</p>
</dd>
<dt>mfdb_sample_count</dt><dd>
<p>Returns year, step, area, (group cols), number (i.e sum of count)
</p>
</dd>
<dt>mfdb_sample_meanlength</dt><dd>
<p>Return year, step, area, (group cols), number (i.e sum of count), mean (length)
</p>
</dd>
<dt>mfdb_sample_meanlength_stddev</dt><dd>
<p>As mfdb_sample_meanlength, but also returns std. deviation.
</p>
</dd>
<dt>mfdb_sample_totalweight</dt><dd>
<p>Returns year,step,area,(group cols),total (weight of group)
</p>
</dd>
<dt>mfdb_sample_meanweight</dt><dd>
<p>Returns year, step, area, (group cols), number (i.e sum of count), mean (weight)
</p>
</dd>
<dt>mfdb_sample_meanweight_stddev</dt><dd>
<p>As mfdb_sample_meanweight, but also returns std. deviation.
</p>
</dd>
<dt>mfdb_sample_rawdata</dt><dd>
<p>Returns year,step,area,(group cols),number of samples, raw_weight and raw_length.
</p>
<p>NB: No grouping of results is performed, instead all matching table entries are returned
</p>
</dd>
<dt>mfdb_sample_scaled</dt><dd>
<p>Returns year, step, area, (group cols), number (i.e. sum of count, scaled by tow_length), mean_weight (scaled by tow_length)
</p>
</dd>
<dt>mfdb_stomach_preycount</dt><dd>
<p>Returns year, step, area, (group cols), number (of prey found in stomach)
</p>
</dd>
<dt>mfdb_stomach_preymeanlength</dt><dd>
<p>Returns year, step, area, (group cols),
number (of prey found in stomach),
mean_length (of prey found in stomach).
NB: Entries where count is NA (i.e. totals) are ignored with this function.
</p>
</dd>
<dt>mfdb_stomach_preymeanweight</dt><dd>
<p>Returns year, step, area, (group cols),
number (of unique stomachs in group),
mean_weight (per unique stomach).
</p>
</dd>
<dt>mfdb_stomach_preyweightratio</dt><dd>
<p>Returns year, step, area, (group cols), ratio (of selected prey in stomach to all prey by weight)
</p>
</dd>
<dt>mfdb_stomach_presenceratio</dt><dd>
<p>Returns year, step, area, (group cols), ratio (of selected prey in stomach to all prey by count)
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>mdb &lt;- mfdb(tempfile(fileext = '.duckdb'))

# Define 2 areacells of equal size
mfdb_import_area(mdb, data.frame(name=c("divA", "divB"), size=1))

# Make up some samples
samples &lt;- expand.grid(
    year = 1998,
    month = c(1:12),
    areacell = c("divA", "divB"),
    species = 'COD',
    age = c(1:5),
    length = c(0,40,80))
samples$count &lt;- runif(nrow(samples), 20, 90)
mfdb_import_survey(mdb, data_source = "x", samples)

# Query numbers by age and length
agg_data &lt;- mfdb_sample_count(mdb, c('age', 'length'), list(
    length = mfdb_interval("len", seq(0, 500, by = 30)),
    age = mfdb_group('young' = c(1,2), old = 3),
    year = c(1998)))
agg_data

# Use in a catchdistribution likelihood component
gadget_dir_write(gadget_directory(tempfile()), gadget_likelihood_component("catchdistribution",
        name = "cdist",
        weight = 0.9,
        data = agg_data[[1]],
        area = attr(agg_data[[1]], "area"),
        age = attr(agg_data[[1]], "age")))

mfdb_disconnect(mdb)
</code></pre>

<hr>
<h2 id='mfdb_sharing'>MareFrame DB sharing options</h2><span id='topic+mfdb_share_with'></span>

<h3>Description</h3>

<p>Alter database privileges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdb_share_with(mdb, user_or_role, query = TRUE, import = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdb_sharing_+3A_mdb">mdb</code></td>
<td>

<p>(required) A database connection created by <code>mfdb</code>()
</p>
</td></tr>
<tr><td><code id="mfdb_sharing_+3A_user_or_role">user_or_role</code></td>
<td>

<p>(required) Another database user, or a role, or 'public' to share with all users
</p>
</td></tr>
<tr><td><code id="mfdb_sharing_+3A_query">query</code></td>
<td>

<p>Should the user be able to query the current case study?
</p>
</td></tr>
<tr><td><code id="mfdb_sharing_+3A_import">import</code></td>
<td>

<p>Should the user be able to import more data current case study?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This allows you to share case study data between users. This is most useful when using
a shared database. Only the owner of the schema (i.e. the user that created it)
will be able to change table structure (i.e. upgrade MFDB versions).
</p>
<p>By default nothing is shared between users.
</p>


<h3>Value</h3>

<p>NULL</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # NB: Requires a PostgreSQL installation, and creation of extra users

mdb &lt;- mfdb('examples')

mfdb_share_with(mdb, 'gelda') # Allow DB user gelda to query the 'examples' case study data

## End(Not run)</code></pre>

<hr>
<h2 id='mfdb-data'>MareFrame DB Datasets</h2><span id='topic+mfdb-data'></span><span id='topic+case_study'></span><span id='topic+digestion_stage'></span><span id='topic+gear'></span><span id='topic+institute'></span><span id='topic+market_category'></span><span id='topic+maturity_stage'></span><span id='topic+sex'></span><span id='topic+species'></span><span id='topic+stomach_state'></span><span id='topic+vessel_type'></span>

<h3>Description</h3>

<p>Data sets representing the content of taxonomies used in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_study
gear
institute
market_category
maturity_stage
sex
species
vessel_type
</code></pre>


<h3>Details</h3>

<p>All of these tables represent acceptible values for use when importing
data. You can see the content of an individual taxonomy at the R command
line, e.g. <kbd>mfdb::gear</kbd>
</p>
<p>Each of the datasets will have the following columns.
</p>

<dl>
<dt>id</dt><dd><p>A numeric ID to be used internally</p>
</dd>
<dt>name</dt><dd>
<p>An alphanumeric ID to be used when importing and reporting data.
</p>
</dd>
<dt>description</dt><dd>
<p>Some text describing the option.
</p>
</dd>
<dt>t_group</dt><dd>
<p>Groups together several items to query all in one go. e.g. for
institutes you can query 'NOR' to get all institutes in Norway.
</p>
</dd>
</dl>

<p>The taxonomies are used in the following locations:
</p>

<dl>
<dt>case_study</dt><dd>
<p>Possible case studies, use when connecting with <a href="#topic+mfdb">mfdb</a>()
</p>
</dd>
<dt>gear, institute, vessel_type</dt><dd>
<p>Used to describe the dataset being imported with <a href="#topic+mfdb_import_survey">mfdb_import_survey</a>()
</p>
</dd>
<dt>sex, maturity_stage, species</dt><dd>
<p>Used for individual sample points when using <a href="#topic+mfdb_import_survey">mfdb_import_survey</a>()
</p>
</dd>
</dl>


<hr>
<h2 id='mfdb-package'>
MareFrame DB querying library
</h2><span id='topic+mfdb-package'></span>

<h3>Description</h3>

<p>Tools to query a MareFrame DB and reformat results in forms
useful for GADGET and EwE models.
</p>


<h3>Introduction &amp; Schema description</h3>

<p>Before doing anything with <span class="pkg">mfdb</span>, it is worth knowing a bit about how data
is stored. Broadly, there are 2 basic types of table in <span class="pkg">mfdb</span>,
<em>taxonomy</em> and <em>measurement</em> tables.
</p>
<p>The measurement tables store all forms of sample data supported, at the finest
available detail. These are then aggregated when using any of the mfdb query
functions. All measurement data is separated by case study, so multiple case
studies can be loaded into a database without conflicts.
</p>
<p>Taxonomy tables store all possible values for terms and their meaning, to
ensure consistency in the data. For example, &lsquo;<span class="samp">&#8288;species&#8288;</span>&rsquo; stores short-names
and full latin names of all known species to MFDB, to ensure consistency in naming.
</p>
<p>Most Taxonomies have defaults which are populated when the database is created,
and their definitions are stored as data attached to this package. See <a href="#topic+mfdb-data">mfdb-data</a> for more
information on these. Others, such as &lsquo;<span class="samp">&#8288;areacell&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;sampling_type&#8288;</span>&rsquo; are
case study specific, and you will need to define your terms before you can
import data.
</p>


<h3>Importing data</h3>

<p>Unless you are working with a remote database, you will need to populate the
database at least once before you are able to do any querying. The steps your
script needs to do are:
</p>


<h4>Connect to database</h4>

<p>Use the <a href="#topic+mfdb">mfdb</a>() function. This will create tables / populate taxonomies if necessary.
</p>



<h4>Define areas &amp; divisions</h4>

<p><span class="pkg">mfdb</span> models space in the following way:
</p>

<dl>
<dt>areacell</dt><dd>
<p>The finest level of detail stored in the database. Every measurement (e.g.
temperature, length sample) is assigned to an areacell. This will generally
correspond to ICES gridcells, however there is no requirement to do so. You
might augment gridcell information with depth, or include divisions when the
measurement doesn't correlate to a specific areacell.
</p>
</dd>
<dt>division</dt><dd>
<p>Collections of areacells, e.g. ICES subdivisions, or whatever is appropriate.
</p>
</dd>
</dl>

<p>Finally, when querying, divisions are grouped together into named collections,
for instance <code>mfdb_group(north = 1:3, south = 4:6)</code> will put anything in
divisions 1&ndash;3 under an area named &quot;north&quot;, 4&ndash;5 under an area named &quot;south&quot;.
</p>
<p>Before you can upload any measurements, you have to define the areacells
that they will use. You do this using the <a href="#topic+mfdb_import_area">mfdb_import_area</a>() function. This
allows you to import tables of area/division information, such as:
</p>
<p><code>
mfdb_import_area(mdb, data.frame(
    area = c('101', '102', '103', '401','402', '403'),
    division = c('1', '1', '1', '4', '4', '4'),
    ))
</code>
</p>
<p>If you want areas to be part of multiple divisions, then you can use
<a href="#topic+mfdb_import_division">mfdb_import_division</a>() to import extra revisions.
</p>



<h4>Define sampling types</h4>

<p>Any survey data can have a sampling type defined, which then can be used when
querying data. If you want to use a sampling type, then define it using
<a href="#topic+mfdb_import_sampling_type">mfdb_import_sampling_type</a>().
</p>



<h4>Import temperature data</h4>

<p>At this point, you can start uploading actual measurements. The easiest of
which is temperature. Upload a table of areacell/month/temperature data
using <a href="#topic+mfdb_import_temperature">mfdb_import_temperature</a>().
</p>



<h4>Import survey data</h4>

<p>Finally, import any survey data using <a href="#topic+mfdb_import_survey">mfdb_import_survey</a>(). Ideally
upload your data in separate chunks. For example, if you have length and
age-length data, don't combine them in R, upload them separately and both
will be used when querying for length data. This keeps the process simple,
and allows you to swap out data as necessary.
</p>



<h4>Import stomach survey</h4>

<p>Stomach surveys are imported in much the same way, however there are 2 data.frames,
one representing predators, one preys. The column &lsquo;<span class="samp">&#8288;stomach_name&#8288;</span>&rsquo; links the
two, which can contain any numeric / character value, as long as it is unique
for predators and prey measurements are assigned to the correct stomach.
</p>

<p>See <a href="#topic+mfdb_import_survey">mfdb_import_survey</a> for more information or 
<a href="../demo">the demo directory</a> for concrete examples.
</p>


<h4>Dumping / Restoring a DB</h4>

<p>You can also dump/import a dump from another host using the postgres pg_dump
and pg_restore commands. You can dump/restore indvidual schemas (i.e. the 
case study you give to the mfdb() command), to list all the schemas installed
run <code>SELECT DISTINCT(table_schema) FROM information_schema.tables</code> from
psql. Note that if you use <code>mfdb('Baltic')</code>, the Postgres schema name will
be lower-cased.
</p>
<p>Create a dump of your chosen schema with the following command:
</p>
<pre>
pg_dump --schema=baltic -Fc mf &gt; baltic.dump
</pre>
<p>This will make a dump of the &quot;baltic&quot; case study into &quot;baltic.tar&quot;. It can
then be restored onto another computer with the following:
</p>
<pre>
pg_restore --clean -d mf baltic.dump
</pre>
<p>If you already have a baltic schema you wish to preserve, you can rename it
first by issuing <code>ALTER SCHEMA baltic RENAME TO baltic_o</code> in psql. Once
the restore is done you can rename the new schema and put the name of the old
schema back.
</p>



<h3>Querying data</h3>

<p>There are a selection of querying functions available, all of which work
same way. You give a set of parameters, each of which can be a vector of
data you wish returned, for instance <code>year = 1998:2000</code> or
<code>species = c('COD')</code>.
</p>
<p>If also grouping by this column (i.e. 'year', 'timestep', 'area' and any
other columns given, e.g. 'age'), then the parameter will control how this
grouping works, e.g. <code>maturity_stage = mfdb_group(imm = 1, mat = 2:5)</code>
will result in the maturity_stage column having either 'imm' or 'mat'.
These will also be used to generate GADGET aggregation files later.
</p>
<p>For example, the following queries the temperature table:
</p>
<pre>
defaults &lt;- list(
    area = mfdb_group("101" = ),
    timestep = mfdb_timestep_quarterly, # Group months to create 2 timesteps for each year
    year = 1996:2005)
agg_data &lt;- mfdb_temperature(mdb, defaults)
</pre>
<p>All functions will result in a list of data.frame result tables (generally
only one, unless you requested bootstrapping). Each are suitable for
feeding into a gadget function to output into model files.
</p>
<p>See <a href="#topic+mfdb_sample_count">mfdb_sample_count</a> for more information or 
<a href="../demo">the demo directory</a> for concrete examples.
</p>


<h3>Creating GADGET files</h3>

<p>Finally, there are a set of functions that turn the output of queries into
GADGET model files. These work on a <a href="#topic+gadget_directory">gadget_directory</a> object, which
can either be an existing GADGET model to alter, or an empty / nonexistant
directory.
</p>
<p>Generally, the result of an mfdb query will be enough to create a
corresponding GADGET file, for instance, the following will create a GADGET
area file in your gadget directory:
</p>
<pre>
gadget_dir_write(gd,gadget_areafile(
    size = mfdb_area_size(mdb, defaults)[[1]],
    temperature = mfdb_temperature(mdb, defaults)[[1]]))
</pre>
<p>See <a href="#topic+gadget_areafile">gadget_areafile</a> or <a href="#topic+gadget_likelihood_component">gadget_likelihood_component</a> for more
information or <a href="../demo">the demo directory</a> for concrete examples.
</p>


<h4>Stock and fleet files</h4>

<p>Stocks and fleets aren't explicitly defined in the database. Instead, they are
definied by querying on a column that differentiates them. For example, if
your &quot;immature cod&quot; stock is definied as cod that is between maturity stages 1
and 2, then if querying for a stockdistribution component, one could do:
</p>
<pre>
    mfdb_sample_count(mdb, c('maturity_stage', 'age', 'length'), list(
        species = 'COD',
        maturity_stage = c(imm = 1:2, mat = 3:5),
        . . .
    )
</pre>
<p>...and the maturity_stage column will be treated as the stock.
</p>



<h3>Acknowledgements</h3>

<p>This project has received funding from the European Union's Seventh Framework
Programme for research, technological development and demonstration under grant
agreement no.613571.
</p>


<h3>Author(s)</h3>

<p>Jamie Lentin
</p>
<p>Maintainer: Jamie Lentin &lt;jamie.lentin@shuttlethread.com&gt;
</p>


<h3>See Also</h3>

<p><a href="https://github.com/gadget-framework/rgadget">rgadget</a>,
<a href="https://gadget-framework.github.io/gadget2/userguide/">Gadget user guide</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
