<!DOCTYPE html><html><head><title>Help for package jmdem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jmdem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.jmdem'>
<p>Analysis of Deviance for Joint Mean and Dispersion Effect Models Fits</p></a></li>
<li><a href='#jmdem'>
<p>Fitting Joint Mean and Dispersion Effects Models</p></a></li>
<li><a href='#jmdem.control'>
<p>Auxiliary for Controlling JMDEM Fitting</p></a></li>
<li><a href='#jmdem.sim'>
<p>Simulate joint mean and dispersion effects models fits</p></a></li>
<li><a href='#jmdem.summaries'>
<p>Accessing Joint Mean and Dispersion Effect Model Fits</p></a></li>
<li><a href='#model.matrix.jmdem'>
<p>Construct Design Matrices</p></a></li>
<li><a href='#predict.jmdem'>
<p>Predict Method for JMDEM Fits</p></a></li>
<li><a href='#score.jmdem, wald.jmdem'>
<p>Asymptotic tests for fits of joint mean and dispersion effects models</p></a></li>
<li><a href='#stat.anova.jmdem'>
<p>JMDEM Anova Statistics</p></a></li>
<li><a href='#summary.jmdem'>
<p>Summarising Joint Mean and Dispersion Effects Model Fits</p></a></li>
<li><a href='#summary.jmdem.sim'>
<p>Summarising JMDEM Simulations</p></a></li>
<li><a href='#update.jmdem'>
<p>Update and Re-fit a JMDEM Call</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Joint Mean and Dispersion Effects Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Ka Yui Karl Wu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ka Yui Karl Wu &lt;karlwuky@suss.edu.sg&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Joint mean and dispersion effects models fit the mean and dispersion parameters of a response variable by two separate linear models, the mean and dispersion submodels, simultaneously. It also allows the users to choose either the deviance or the Pearson residuals as the response variable of the dispersion submodel. Furthermore, the package provides the possibility to nest the submodels in one another, if one of the parameters has significant explanatory power on the other. Wu &amp; Li (2016) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.04.015">doi:10.1016/j.csda.2016.04.015</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>VGAM, statmod</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-03 15:04:47 UTC; Karl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-04 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.jmdem'>
Analysis of Deviance for Joint Mean and Dispersion Effect Models Fits
</h2><span id='topic+anova.jmdem'></span>

<h3>Description</h3>

<p>Compute an analysis of deviance table for one or more double generalised linear model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
anova(object, ..., test = NULL, type = c("1", "3"), 
      print.results = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.jmdem_+3A_object">object</code>, <code id="anova.jmdem_+3A_...">...</code></td>
<td>
<p>one or several objects of class <code>jmdem</code>, typically the result of a call to <code>jmdem</code>.</p>
</td></tr>
<tr><td><code id="anova.jmdem_+3A_test">test</code></td>
<td>
<p>a character string, (partially) matching one of &quot;<code>Rao</code>&quot; or &quot;<code>Wald</code>&quot;. See <code><a href="#topic+stat.anova.jmdem">stat.anova.jmdem</a></code>.</p>
</td></tr>
<tr><td><code id="anova.jmdem_+3A_type">type</code></td>
<td>
<p>a character string or integer, specifying whether a type &quot;<code>1</code>&quot; (<em>sequential</em>) analysis or a type &quot;<code>3</code>&quot; (<em>partial</em>) analysis should be conducted. It is only relevant if a single object is specified in <code>object</code>. Both numeric and character inputs are allowed. See details for type 1 and type 3 analysis.</p>
</td></tr>
<tr><td><code id="anova.jmdem_+3A_print.results">print.results</code></td>
<td>
<p>logical, <code>TRUE</code> if the result table should be printed directly, <code>FALSE</code> if the results should be saved in an user-defined object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a single object gives a analysis of deviance table for that fit. If type <code>1</code> analysis is specified, a sequential analysis will be conducted. That is, the reductions in the residual deviance as each term of the formula is <em>added</em> in turn are given in as the rows of a table, plus the residual deviances themselves.
</p>
<p>Type <code>3</code> analysis gives the reduction in the residual deviance of the fitted model after <em>removing</em> each term of the formula individually, that in turn are given as the rows of a table.
</p>
<p>If more than one object is specified, the table has a row for the residual degrees of freedom and deviance for each model. For all but the first model, the change in degrees of freedom and deviance is also given. (This only makes statistical sense if the models are nested.) It is conventional to list the models from smallest to largest, but this is up to the user.
</p>
<p>The table will optionally contain &quot;<code>Rao</code>&quot; or &quot;<code>Wald</code>&quot; test statistics (and P values) comparing the model specified in the current row and the row above (type <code>1</code>) or the full model (type <code>3</code>). Both &quot;<code>Rao</code>&quot; and &quot;<code>Wald</code>&quot; test statistics are asymptotically chi-square distributed. &quot;<code>LRT</code>&quot; (Likelihood ratio test) and &quot;<code>F</code>&quot; ((F test) are not included in <code>anova.jmdem</code> because the comparison of the deviances of two joint mean and dispersion effects models is questionable, if not even invalid. One important argument is that the dependent variables of two different dispersion submodels given two different mean submodels are not the identical.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>anova</code>&quot; inheriting from class &quot;<code>data.frame</code>&quot;.
</p>
<p>If <code>print.results = TRUE</code>,
</p>
<table>
<tr><td><code>table.x</code></td>
<td>
<p>the <code>anova</code> table constructed for the mean submodel.</p>
</td></tr>
<tr><td><code>table.z</code></td>
<td>
<p>the <code>anova</code> table constructed for the dispersion submodel.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The comparison between two or more models will only be valid if they are fitted to the same dataset. This may be a problem if there are missing values and <code>R</code>'s default of  <code>na.action = na.omit</code> is used, and  <code>anova</code> will detect this with an error.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Hastie, T. J. and Pregibon, D. (1992). <em>Generalized linear models</em>. Chapter 6 of Statistical Models in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>McCullagh P. and Nelder, J.A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>
<p>Smyth, G.K. (1989). <em>Generalized linear models with varying dispersion</em>. J. R. Statist. Soc. B, <strong>51</strong> (1), 47-60.
</p>
<p>Smyth, G.K., Verbyla, A.P. (1996). <em>A conditional likelihood approach to residual maximum linear estimation in generalized linear models</em>. J. R. Statist. Soc. B, <strong>58</strong> (3), 565-572.
</p>
<p>Smyth, G.K., Verbyla, A.P. (1999). <em>Adjusted likelihood methods for modelling dispersion in generalized linear models</em>. Environmetrics, <strong>10</strong>, 695-709.
</p>
<p>Wu, K.Y.K., Li, W.K. (2016). <em>On a dispersion model with Pearson residual responses</em>. Comput. Statist. Data Anal., <strong>103</strong>, 17-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem">jmdem</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
              
## Run a partial analysis (type 3) with Wald test
anova(fit, test = "Wald", type = 3)
</code></pre>

<hr>
<h2 id='jmdem'>
Fitting Joint Mean and Dispersion Effects Models
</h2><span id='topic+jmdem'></span><span id='topic+jmdem.fit'></span>

<h3>Description</h3>

<p><code>jmdem</code> is used to fit joint mean and dispersion effects models, specified by giving a symbolic description of the linear predictors for the mean and dispersion and a description of the error distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jmdem(mformula, dformula, data, mfamily = gaussian, dfamily = Gamma, 
      weights, subset, dev.type = c("deviance", "pearson"), 
      moffset = NULL, doffset = NULL, mustart = NULL, phistart = NULL, 
      betastart = NULL, lambdastart = NULL, hessian = TRUE, na.action, 
      grad.func = TRUE, fit.method = "jmdem.fit", 
      method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), 
      df.adj = FALSE, disp.adj = FALSE, full.loglik = FALSE, 
      beta.first = TRUE, prefit = TRUE, mcontrasts = NULL, 
      dcontrasts = NULL, control = list(...), 
      minv.method = c("solve", "chol2inv", "ginv"), ...)

jmdem.fit(x, y, z = NULL, weights, mfamily = gaussian, dfamily = Gamma, 
          mu, phi, beta, lambda, moffset = NULL, doffset = NULL, 
          dev.type = c("deviance", "pearson"), hessian = TRUE, 
          method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), 
          disp.adj = FALSE, df.adj = FALSE, full.loglik = FALSE, 
          control = list(), mintercept = TRUE, dintercept = TRUE, 
          grad.func = TRUE, lower = -Inf, upper = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jmdem_+3A_mformula">mformula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the <em>mean</em> submodel to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_dformula">dformula</code></td>
<td>
<p>a symbolic description of the <em>dispersion</em> submodel to be fitted. The details are also given under 'Details'.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>jmdem</code> is called.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_mfamily">mfamily</code></td>
<td>
<p>a description of the error distribution and link function to be used in the <em>mean</em> submodel. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="jmdem_+3A_dfamily">dfamily</code></td>
<td>
<p>a description of the error distribution and link function to be used in the <em>dispersion</em> submodel. (Also see <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="jmdem_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_dev.type">dev.type</code></td>
<td>
<p>a specification of the type of residuals to be used as the response of the <em>dispersion</em> submodel. The ML estimates of the jmdem are the optima of either the quasi-likelihood function for <em>deviance residuals</em>, or the pseudo-likelihood function for <em>Pearson</em> residuals.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_moffset">moffset</code></td>
<td>
<p>an a priori known component to be included in the linear predictor of the <em>mean</em> submodel during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_doffset">doffset</code></td>
<td>
<p>an a priori known component to be included in the linear predictor of the <em>dispersion</em> submodel during fitting. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_mustart">mustart</code>, <code id="jmdem_+3A_mu">mu</code></td>
<td>
<p>a vector of starting values of individual means.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_phistart">phistart</code>, <code id="jmdem_+3A_phi">phi</code></td>
<td>
<p>a vector of starting values of individual dispersion.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_betastart">betastart</code>, <code id="jmdem_+3A_beta">beta</code></td>
<td>
<p>a vector of starting values for the regression parameters of the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_lambdastart">lambdastart</code>, <code id="jmdem_+3A_lambda">lambda</code></td>
<td>
<p>a vector of starting values for the regression parameters of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_hessian">hessian</code></td>
<td>
<p>the method used to compute the information matrix. Hessian matrix will be calculated for <code>"TRUE"</code>, Fisher matrix for <code>"FALSE"</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Another possible value is <code>NULL</code>, no action. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_grad.func">grad.func</code></td>
<td>
<p>the gradient function will be included in the optimisation for the &quot;<code>BFGS</code>&quot;, &quot;<code>CG</code>&quot; and &quot;<code>L-BFGS-B</code>&quot; methods for <code>"TRUE"</code>. If it is <code>NULL</code>, a finite-difference approximation will be used.
</p>
<p>For the &quot;<code>SANN</code>&quot; method it specifies a function to generate a new candidate point. If it is <code>NULL</code> a default Gaussian Markov kernel is used.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_fit.method">fit.method</code></td>
<td>
<p>the method to be used in fitting the model. The default method &quot;<code>jmdem.fit</code>&quot; uses the general-purpose optimisation (<code>optim</code>): the alternative &quot;model.frame&quot; returns the model frame and does no fitting.
</p>
<p>User-supplied fitting functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>jmdem.fit</code>. If specified as a character string it is looked up from within the <em>stats</em> namespace.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_method">method</code></td>
<td>
<p>the method to be used for the optimisation. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_df.adj">df.adj</code></td>
<td>
<p>an adjustment factor for the degrees of freedom <code>(n-p)/n</code>, where <code>n</code> is the number of observations and <code>p</code> is the number of parameters to be estimated in <code>jmdem</code>, will be multiplied to the likelihood function before the optimisation for <code>"TRUE"</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_disp.adj">disp.adj</code></td>
<td>
<p>an adjustment factor for the dispersion weight will be multiplied to the estimated dispersion parameter during the optimisation for <code>"TRUE"</code>. For details, please see McCullagh and Nelder (1989, Ch. 10, P. 362).</p>
</td></tr>
<tr><td><code id="jmdem_+3A_full.loglik">full.loglik</code></td>
<td>
<p>the full likelihood function instead of the quasi- or pseudo-likelihood function will be used for the optimisation for <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_beta.first">beta.first</code></td>
<td>
<p>the mean effects will be estimated (assuming constant sample dispersion) at the initial stage for <code>TRUE</code>. For <code>FALSE</code>, the dispersion effects will be estimated first (assuming constantly zero mean for the whole sample).</p>
</td></tr>
<tr><td><code id="jmdem_+3A_prefit">prefit</code></td>
<td>
<p>a specfication whether <code>jmdem</code> uses <code>glm</code> to prefit the starting values of the mean and dispersion parameters. For <code>FALSE</code>, the initial parameter values of all the regressors are set to zero and the sample mean and sample dispersion will be used as the starting values of the corresponding submodel intercepts instead. If the submodels have no intercept, all parameters will also be set to zero. The sample mean and sample dispersion will then be used as <code>mustart</code> and <code>phistart</code> in the internal computation (they will not be officially recorded in <code>mustart</code> and <code>phistart</code> in the output object). Defaule value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_mcontrasts">mcontrasts</code></td>
<td>
<p>an optional list for the mean effect constrasts. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_dcontrasts">dcontrasts</code></td>
<td>
<p>an optional list for the dispersion effect constrasts. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>jmdem.fit</code> this is passed to <code>jmdem.control</code>.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_minv.method">minv.method</code></td>
<td>
<p>the method used to invert matrices during the estimation process. &quot;<code>solve</code>&quot; gives the solutions of a system of equations, &quot;<code>chol2inv</code>&quot; gives the inverse from Choleski or QR decomposition and &quot;<code>ginv</code>&quot; gives the generalized inverse of a matrix. If none of the methods is specified or if they are specified in a vector such as <code>c("solve", "chol2inv", "ginv")</code>, the matrices will be inverted by the methods in the sequence as given in the vector until it is found.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_x">x</code>, <code id="jmdem_+3A_y">y</code>, <code id="jmdem_+3A_z">z</code></td>
<td>
<p><code>x</code> is a <em>mean</em> submodel's design matrix of dimension <code>n * p</code>, <code>z</code> is a <em>dispersion</em> submodel's design matrix of dimension <code>n * k</code>, and <code>y</code> is a vector of observations of length <code>n</code>. If <code>z</code> is <code>NULL</code>, the <em>dispersion</em> submodel only contains an intercept.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_mintercept">mintercept</code></td>
<td>
<p>a specification whether the intercept term is included in the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_dintercept">dintercept</code></td>
<td>
<p>a specification whether the intercept term is included in the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_lower">lower</code>, <code id="jmdem_+3A_upper">upper</code></td>
<td>
<p>bounds on the variables for the &quot;<code>L-BFGS-B</code>&quot; optimisation method.</p>
</td></tr>
<tr><td><code id="jmdem_+3A_...">...</code></td>
<td>
<p>For <code>control</code>: arguments to be used to form the default control argument if it is not supplied directly. For <code>jmdem</code> and <code>jmdem.fit</code>: further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form <code>response ~ terms</code> where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. 
</p>
<p>A terms specification of the form <code>first + second</code> indicates all the terms in first together with all the terms in second with any duplicates removed. A specification of the form <code>first:second</code> indicates the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification <code>first * second</code> indicates the cross of first and second. This is the same as <code>first + second + first:second</code>.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula.
</p>
<p>An additional term <code>response ~ terms + eta</code> can be added to <code>dformula</code> if the <em>mean</em> submodel is nested in the <em>dispersion</em> submodel in the form such that </p>
<p style="text-align: center;"><code class="reqn">g(E(y_i))=\boldsymbol{x}_i\boldsymbol{\beta}=\eta_i, h(\phi)=\boldsymbol{z}_i\boldsymbol{\lambda}+\eta_i\gamma.</code>
</p>
<p> In the contrary, if the <em>dispersion</em> submodel is nested in the <em>mean</em> submodel such that </p>
<p style="text-align: center;"><code class="reqn">g(E(y_i))=\boldsymbol{x}_i\boldsymbol{\beta}+\delta_i\kappa, h(\phi_i)=\boldsymbol{z}_i\boldsymbol{\lambda}=\delta_i,</code>
</p>
 <p><code>mformula</code> can be specified as <code>response ~ terms + delta</code>.
</p>
<p>Non-<code>NULL</code> weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers <code class="reqn">w_i</code>, that each response <code class="reqn">y_i</code> is the mean of <code class="reqn">w_i</code> unit-weight observations. For a binomial GLM prior weights are used to give the number of trials when the response is the proportion of successes: they would rarely be used for a Poisson GLM.
</p>
<p>If more than one of <code>etastart</code> and <code>mustart</code> is specified, the first in the list will be used. It is often advisable to supply starting values for a quasi family, and also for families with unusual links such as gaussian(&quot;log&quot;).
</p>
<p><code>glm.fit</code> is the workhorse function: it is not normally called directly but can be more efficient where the response vector, design matrix and family have already been calculated.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of estimated coefficients of both the mean and <em>dispersion</em> submodel</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>estimated coefficients of the <em>mean</em> submodel</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>estimated coefficients of the <em>dispersion</em> submodel</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the <em>working</em> residuals, that is the residuals in the final iteration of the <code>optim</code> fit. Depending on the type of deviance specified by <code>dev.type</code>, <code>residuals</code> corresponds to <code>deviance.residuals</code> or <code>pearson.residuals</code>. Since cases with zero weights are omitted, their working residuals are <code>NA</code>.</p>
</td></tr>
<tr><td><code>deviance.residuals</code></td>
<td>
<p>the <em>deviance</em> residuals resulting from the final iteration of the <code>optim</code> fit.</p>
</td></tr>
<tr><td><code>pearson.residuals</code></td>
<td>
<p>the <em>pearson</em> residuals resulting from the final iteration of the <code>optim</code> fit.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the fitted individual dispersion values, obtained by transforming the linear predictors of the <em>dispersion</em> submodel by the corresponding inverse of the link function.</p>
</td></tr>
<tr><td><code>mean.rank</code></td>
<td>
<p>the numeric rank of the fitted <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.rank</code></td>
<td>
<p>the numeric rank of the fitted <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the total numeric rank of the fitted model. <code>mean.rank</code> and <code>dispersion.rank</code> are the corresponding ranks of the fitted <em>mean</em> and <em>dispersion</em> submodels.</p>
</td></tr>
<tr><td><code>mean.family</code></td>
<td>
<p>the <code>family</code> object used for the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.family</code></td>
<td>
<p>the <code>family</code> object used for the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>mean.linear.predictors</code></td>
<td>
<p>the linear fit on link scale of the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.linear.predictors</code></td>
<td>
<p>the linear fit on link scale of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual sum of squares of the complete fitted model.</p>
</td></tr>
<tr><td><code>individual.loglik</code></td>
<td>
<p>individual value of the log-likelihood function given the estimated mean and dispersion.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the <em>Akaike Information Criterion</em>, minus twice the maximised log-likelihood plus twice the number of parameters.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations needed for the fit.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the working weights, that is the weights in the final iteration of the <code>optim</code> fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights initially supplied, a vector of <code>1</code>s if none were.</p>
</td></tr>
<tr><td><code>info.matrix</code></td>
<td>
<p>the information matrix given the estimated model coefficients. The diagonal elements of its inverse are the standard errors of the model parameters.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom of the complete fitted model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the <code>y</code> vector used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the <em>mean</em> submodel design matrix.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the <em>dispersion</em> submodel design matrix.</p>
</td></tr>
<tr><td><code>log.llh</code></td>
<td>
<p>the maximised log-likelihood of the entire sample.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the <code>optim</code> algorithm judged to have converged?</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>logical. Was the gradient function included in the <code>optim</code> algorithm?</p>
</td></tr>
<tr><td><code>deviance.type</code></td>
<td>
<p>the type of redidual deviance specified, it is either &quot;<code>deviance</code>&quot; or &quot;<code>pearson</code>&quot;.</p>
</td></tr>
<tr><td><code>information.type</code></td>
<td>
<p>the type of information matrix specified, it is either &quot;<code>Hessian</code>&quot; or &quot;<code>Fisher</code>&quot;.</p>
</td></tr>
<tr><td><code>dispersion.adjustment</code></td>
<td>
<p>logical. Was the dispersion parameter adjusted by an adjustment factor during the optimisation?</p>
</td></tr>
<tr><td><code>df.adjustment</code></td>
<td>
<p>logical. Was the likelihood function adjusted by the degrees of freedom adjustment factor?</p>
</td></tr>
<tr><td><code>optim.method</code></td>
<td>
<p>the name of the method used in <code>optim</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the control argument used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the evaluated dataset specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code>mean.model</code></td>
<td>
<p>the model frame of the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.model</code></td>
<td>
<p>the model frame of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>mean.formula</code></td>
<td>
<p>the formula of the <em>mean</em> submodel supplied.</p>
</td></tr>
<tr><td><code>dispersion.formula</code></td>
<td>
<p>the formula of the <em>dispersion</em> submodel supplied.</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>the name of the fit function used, currently always &quot;<code>jmdem.fit</code>&quot;.</p>
</td></tr>
<tr><td><code>mean.offset</code></td>
<td>
<p>the offset vector used in the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.offset</code></td>
<td>
<p>the offset vector used in the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.deviance</code></td>
<td>
<p>the deviance sum of squares of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.df.residual</code></td>
<td>
<p>the residual degrees of freedom of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the residual sum of squares of the complete null model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the complete null model.</p>
</td></tr>
<tr><td><code>dispersion.null.deviance</code></td>
<td>
<p>the residual sum of squares of the dispersion null submodel.</p>
</td></tr>
<tr><td><code>dispersion.df.null</code></td>
<td>
<p>the residual degrees of freedom for the dispersion null submodel.</p>
</td></tr>
<tr><td><code>beta.null</code></td>
<td>
<p>the estimated coefficients of the mean null submodel.</p>
</td></tr>
<tr><td><code>lambda.null</code></td>
<td>
<p>the estimated coefficients of the dispersion null submodel.</p>
</td></tr>
<tr><td><code>dispersion.null</code></td>
<td>
<p>the estimated dispersion of the complete null model.</p>
</td></tr>
<tr><td><code>residuals.null</code></td>
<td>
<p>the residuals of the complete null model.</p>
</td></tr>
<tr><td><code>mustart</code></td>
<td>
<p>the vector of starting values for individual means used.</p>
</td></tr>
<tr><td><code>phistart</code></td>
<td>
<p>the vector of starting values for individual dispersion used.</p>
</td></tr>
<tr><td><code>betastart</code></td>
<td>
<p>the vector of starting values for the <em>mean</em> submodel parameters used.</p>
</td></tr>
<tr><td><code>lambdastart</code></td>
<td>
<p>the vector of starting values for the <em>dispersion</em> submodel parameters used.</p>
</td></tr>
<tr><td><code>mean.terms</code></td>
<td>
<p>the terms object used for the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.terms</code></td>
<td>
<p>the terms object used for the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>a record of the levels of the factors used in fitting the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>zlevels</code></td>
<td>
<p>a record of the levels of the factors used in fitting the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>mean.contrasts</code></td>
<td>
<p>the contrasts used for the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code>dispersion.contrasts</code></td>
<td>
<p>the contrasts used for the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>information returned by model.frame on the special handling of <code>NA</code>s.</p>
</td></tr>
<tr><td><code>init.mean.fit</code></td>
<td>
<p>the initial values of the <em>mean</em> submodel coefficients, linear predictors and fitted values.</p>
</td></tr>
<tr><td><code>init.dispersion.fit</code></td>
<td>
<p>the initial values of the <em>dispersion</em> submodel coefficients, linear predictors and fitted values.</p>
</td></tr>
<tr><td><code>matrix.inverse.method</code></td>
<td>
<p>information returned on the method used for inverting matrices during optimisation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Carroll, R.J., Ruppert, D. (1988). <em>Transformation and Weighting in Regression</em>. London: Chapman and Hall.
</p>
<p>Cordeiro, M.G., Simas, A.B. (2009). <em>The distribution of pearson residuals in generalized linear models</em>. Comput. Statist. Data Anal., <strong>53</strong>, 3397-3411.
</p>

<p>McCullagh, P. (1983). <em>Quasi-likelihood functions</em>. Annals of Statistics <strong>11</strong> (1), 59-67.
</p>
<p>McCullagh P. and Nelder, J.A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>
<p>Nash, J.C. (1990). <em>Compact Numerical Methods for Computers. Linear Algebra and Function Minimisation</em>. Adam Hilger.
</p>
<p>Nelder, J.A., Lee, Y., Bergman, B., Hynen, A., Huele, A.F., Engel, J. (1998). <em>Joint modelling of mean and dispersion</em>. Technometrics, <strong>40</strong> (2), 168-175.
</p>

<p>Nelder, J.A., Pregibon, D. (1987). <em>An extended quasi-likelihood function</em>. Biometrika, <strong>74</strong> (2), 221-232.
</p>
<p>Nocedal, J., Wright, S.J. (1999). <em>Numerical Optimization</em>. Springer.
</p>
<p>Smyth, G.K. (1989). <em>Generalized linear models with varying dispersion</em>. J. R. Statist. Soc. B, <strong>51</strong> (1), 47-60.
</p>
<p>Smyth, G.K., Verbyla, A.P. (1996). <em>A conditional likelihood approach to residual maximum linear estimation in generalized linear models</em>. J. R. Statist. Soc. B, <strong>58</strong> (3), 565-572.
</p>
<p>Smyth, G.K., Verbyla, A.P. (1999). <em>Adjusted likelihood methods for modelling dispersion in generalized linear models</em>. Environmetrics, <strong>10</strong>, 695-709.
</p>
<p>Wedderburn, R. (1974). <em>Quasi-likelihood functions, generalized linear models, and the Gauss-Newton method</em>. Biometrika, <strong>61</strong> (3), 439-447.
</p>
<p>Wu, K.Y.K., Li, W.K. (2016). <em>On a dispersion model with Pearson residual responses</em>. Comput. Statist. Data Anal., <strong>103</strong>, 17-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.jmdem">anova.jmdem</a></code>, <code><a href="#topic+summary.jmdem">summary.jmdem</a></code>, etc. for <code>jmdem</code> methods, and the generic functions <code><a href="stats.html#topic+effects">effects</a></code>, <code><a href="stats.html#topic+fitted.values">fitted.values</a></code>, and <code><a href="stats.html#topic+residuals">residuals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit poisson counts by unnested mean and dispersion submodels. 
## Use log-links for both submodels. Set dispersion fitting based 
## on deviance residuals. Use conjugate gradient (CG) as 
## optimisation method.
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
      
## Fit Gaussian responses by nesting dispersion submodel in the mean 
## submodel. Use default link for both submodels. Set dispersion fitting 
## based on pearson residuals. Use quasi-Newton (BFGS) as optimisation 
## method. Adjust degrees of freedom for the likelihood function.
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x + delta, dformula = ~ z, 
                            mfamily = gaussian(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4, 1), 
                            lambda.true = c(2.5, 3), n = 100)

fit &lt;- jmdem(mformula = y ~ x + delta, dformula = ~ z, data = MyData, 
             mfamily = gaussian, dfamily = Gamma, dev.type = "pearson", 
             method = "BFGS", df.adj = TRUE)
</code></pre>

<hr>
<h2 id='jmdem.control'>
Auxiliary for Controlling JMDEM Fitting
</h2><span id='topic+jmdem.control'></span>

<h3>Description</h3>

<p>Auxiliary function for <code><a href="#topic+jmdem">jmdem</a></code> fitting. Typically only used internally by <code><a href="#topic+jmdem.fit">jmdem.fit</a></code>, but may be used to construct a <code>control</code> argument to either function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jmdem.control(maxit = 100, epsilon = 1e-8, prefit.trace = FALSE, 
              fit.trace = FALSE, null.approx = 1e-8, trace = 0, 
              fnscale = -1, parscale = 1, ndeps = 0.001, 
              abstol = -Inf, reltol = sqrt(.Machine$double.eps), 
              alpha = 1, beta = 0.5, gamma = 2, REPORT = 10, 
              type = 1, lmm = 5, factr = 1e+07, pgtol = 0, 
              temp = 10, tmax = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jmdem.control_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximal number of optimisation iterations.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">\epsilon</code>; the iterations converge when <code class="reqn">|dev - dev_{old}|/(|dev| + 0.1) &lt; \epsilon</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_prefit.trace">prefit.trace</code></td>
<td>
<p>logical indicating if output should be produced for each iteration in the <code>prefit</code> process.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_fit.trace">fit.trace</code></td>
<td>
<p>logical indicating if output should be produced for each iteration in the <code>jmdem.fit</code> process.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_null.approx">null.approx</code></td>
<td>
<p>approximisation of zeros to avoid estimation abortion in the case of <code class="reqn">log(0)</code> or <code class="reqn">1/0</code>.</p>
</td></tr>
</table>
<p>The following control arguments are used by <code>optim</code>. Please refer to <code><a href="stats.html#topic+optim">optim</a></code> for details
</p>
<table>
<tr><td><code id="jmdem.control_+3A_trace">trace</code></td>
<td>
<p>non-negative integer. If positive, tracing information on the progress of the optimisation is produced. Higher values may produce more tracing information: for method &quot;<code>L-BFGS-B</code>&quot; there are six levels of tracing.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_fnscale">fnscale</code></td>
<td>
<p>An overall scaling to be applied to the value of <code>fn</code> and <code>gr</code> during optimisation. If negative, turns the problem into a maximisation problem. Optimisation is performed on <code>fn(par)/fnscale</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_parscale">parscale</code></td>
<td>
<p>A vector of scaling values for the parameters. Optimisation is performed on <code>par/parscale</code> and these should be comparable in the sense that a unit change in any element produces about a unit change in the scaled value. Not used (nor needed) for <code>method = "Brent"</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_ndeps">ndeps</code></td>
<td>
<p>A vector of step sizes for the finite-difference approximation to the gradient, on <code>par/parscale</code> scale. Defaults to <code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_abstol">abstol</code></td>
<td>
<p>The absolute convergence tolerance. Only useful for non-negative functions, as a tolerance for reaching zero.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_reltol">reltol</code></td>
<td>
<p>Relative convergence tolerance. The algorithm stops if it is unable to reduce the value by a factor of <code>reltol * (abs(val) + reltol)</code> at a step. Defaults to <code>sqrt(.Machine$double.eps)</code>, typically about <code>1e-8</code>.</p>
</td></tr> 
<tr><td><code id="jmdem.control_+3A_alpha">alpha</code>, <code id="jmdem.control_+3A_beta">beta</code>, <code id="jmdem.control_+3A_gamma">gamma</code></td>
<td>
<p>Scaling parameters for the &quot;<code>Nelder-Mead</code>&quot; method. <code>alpha</code> is the reflection factor (default 1.0), <code>beta</code> the contraction factor (0.5) and <code>gamma</code> the expansion factor (2.0).</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_report">REPORT</code></td>
<td>
<p>The frequency of reports for the &quot;<code>BFGS</code>&quot;, &quot;<code>L-BFGS-B</code>&quot; and &quot;<code>SANN</code>&quot; methods if <code>control$trace</code> is positive. Defaults to every 10 iterations for &quot;<code>BFGS</code>&quot; and &quot;<code>L-BFGS-B</code>&quot;, or every 100 temperatures for &quot;<code>SANN</code>&quot;.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_type">type</code></td>
<td>
<p>for the conjugate-gradients (&quot;<code>CG</code>&quot;) method. Takes value <code>1</code> for the Fletcher-Reeves update, <code>2</code> for Polak-Ribiere and <code>3</code> for Beale-Sorenson.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_lmm">lmm</code></td>
<td>
<p>is an integer giving the number of <code>BFGS</code> updates retained in the &quot;<code>L-BFGS-B</code>&quot; method, It defaults to <code>5</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_factr">factr</code></td>
<td>
<p>controls the convergence of the &quot;<code>L-BFGS-B</code>&quot; method. Convergence occurs when the reduction in the objective is within this factor of the machine tolerance. Default is <code>1e7</code>, that is a tolerance of about <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_pgtol">pgtol</code></td>
<td>
<p>helps control the convergence of the &quot;<code>L-BFGS-B</code>&quot; method. It is a tolerance on the projected gradient in the current search direction. This defaults to zero, when the check is suppressed.</p>
</td></tr> 
<tr><td><code id="jmdem.control_+3A_tmax">tmax</code></td>
<td>
<p>controls the &quot;<code>SANN</code>&quot; method. It is the starting temperature for the cooling schedule. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="jmdem.control_+3A_temp">temp</code></td>
<td>
<p>is the number of function evaluations at each temperature for the &quot;<code>SANN</code>&quot; method. Defaults to <code>10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The control argument of <code>jmdem</code> is by default passed to the control argument of jmdem.fit, which uses its elements as arguments to jmdem.control: the latter provides defaults and sanity checking.
</p>
<p>When <code>trace</code> is true, calls to <code><a href="base.html#topic+cat">cat</a></code> produce the output for each iteration. Hence, <code>options(digits = *)</code> can be used to increase the precision, see the example.</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Belisle, C.J.P. (1992). <em>Convergence theorems for a class of simulated annealing algorithms on Rd</em>. Journal of Applied Probability, <strong>29</strong>, 885-895.
</p>
<p>Byrd, R. H., Lu, P., Nocedal, J. and Zhu, C. (1995). <em>A limited memory algorithm for bound constrained optimisation</em>. SIAM Journal on Scientific Computing, <strong>16</strong>, 1190-1208.
</p>
<p>Fletcher, R. and Reeves, C.M. (1964). <em>Function minimization by conjugate gradients</em>. Computer Journal, <strong>7</strong>, 148-154.
</p>
<p>Hastie, T. J. and Pregibon, D. (1992). <em>Generalized linear models</em>. Chapter 6 of Statistical Models in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>Nash, J.C. (1990). <em>Compact Numerical Methods for Computers. Linear Algebra and Function Minimisation</em>. Adam Hilger.
</p>
<p>Nelder, J.A., Mead, R. (1965). <em>A simplex algorithm for function minimization</em>. Computer Journal, <strong>7</strong>, 308-313.
</p>
<p>Nocedal, J., Wright, S.J. (1999). <em>Numerical Optimisation</em>. Springer.
</p>
<p>Smyth, G.K. (1989). <em>Generalised linear models with varying dispersion</em>. J. R. Statist. Soc. B, <strong>51</strong> (1), 47-60.
</p>
<p>Smyth, G.K., Verbyla, A.P. (1999). <em>Adjusted likelihood methods for modelling dispersion in generalised linear models</em>. Environmetrics, <strong>10</strong>, 695-709.
</p>
<p>Wu, K.Y.K., Li, W.K. (2016). <em>On a dispersion model with Pearson residual responses</em>. Comput. Statist. Data Anal., <strong>103</strong>, 17-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem.fit">jmdem.fit</a></code>, the fitting procedure used by <code><a href="#topic+jmdem">jmdem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...). Limit maximum iteration number to 20 and 
## trace the deviance development in the fitting process
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ s, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ s, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG",
             control = list(maxit = 20, fit.trace = TRUE))

## Change to a small convergence tolerance and trace the optimisation 
## process in optim
jmdem.control(list(epsilon = 1e-14, trace = 1))
</code></pre>

<hr>
<h2 id='jmdem.sim'>
Simulate joint mean and dispersion effects models fits
</h2><span id='topic+jmdem.sim'></span><span id='topic+simdata.jmdem.sim'></span><span id='topic+getdata.jmdem.sim'></span>

<h3>Description</h3>

<p>Simulate iterative <code>jmdem</code> fits on user-defined model settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jmdem.sim(mformula = "y ~ 1 + x", dformula = "~ 1 + z", data = NULL, 
          beta.true, lambda.true, mfamily = gaussian, 
          dfamily = Gamma, dev.type = c("deviance", "pearson"), 
          x.str = list(type = "numeric", random.func = "runif", param = list()), 
          z.str = list(type = "numeric", random.func = "runif", param = list()), 
          n = NULL, simnum = NULL, trace = FALSE, asymp.test = FALSE, 
          weights = NULL, moffset = NULL, doffset = NULL, 
          mustart = NULL, phistart = NULL, betastart = NULL, 
          lambdastart = NULL, hessian = TRUE, na.action, 
          grad.func = TRUE, fit.method = "jmdem.fit", 
          method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), 
          df.adj = FALSE, disp.adj = FALSE, full.loglik = FALSE, 
          mcontrasts = NULL, dcontrasts = NULL, beta.first = TRUE, 
          prefit = TRUE, control = list(...), 
          minv.method = c("solve", "chol2inv", "ginv"), ...)
          
simdata.jmdem.sim(mformula = "y ~ 1 + x", dformula = "~ 1 + z", beta.true, lambda.true, 
                   x.str = list(type = "numeric", random.func = "runif", param = list()), 
                   z.str = list(type = "numeric", random.func = "runif", param = list()), 
                   mfamily = gaussian, dfamily = Gamma, weights = NULL, n, simnum = 1, 
                   moffset = NULL, doffset = NULL)

getdata.jmdem.sim(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jmdem.sim_+3A_mformula">mformula</code></td>
<td>
<p>the user-defined true mean submodel, expressed in form of an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot;. The number of regressors and their interactions can be specified here, but not their true parameter values.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_dformula">dformula</code></td>
<td>
<p>the user-defined true dispersion submodel. See <code>mformula</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_data">data</code></td>
<td>
<p>an optional data frame or list of several data frames. If no data are provided, <code>jmdem.sim</code> will generate its own data for simulation by <code>simdata.jmdem.sim</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_beta.true">beta.true</code></td>
<td>
<p>a vector of the true parameter values of the mean submodel. The number of elements in <code>beta.true</code> must be identical with the number of parameters to be estimated in <code>mformula</code>, including the intercept if there exists one in the model.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_lambda.true">lambda.true</code></td>
<td>
<p>a vector of the true parameter values of the dispersion submodel. The number of elements in <code>lambda.true</code> must be identical with the number of parameters to be estimated in <code>dformula</code>, including the intercept if there exists one in the model.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_mfamily">mfamily</code></td>
<td>
<p>a description of the error distribution and link function to be used in the <em>mean</em> submodel. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_dfamily">dfamily</code></td>
<td>
<p>a description of the error distribution and link function to be used in the <em>dispersion</em> submodel. (Also see <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_dev.type">dev.type</code></td>
<td>
<p>a specification of the type of residuals to be used as the response of the <em>dispersion</em> submodel. The ML estimates of the jmdem are the optima of either the quasi-likelihood function for <em>deviance residuals</em>, or the pseudo-likelihood function for <em>Pearson</em> residuals.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_x.str">x.str</code></td>
<td>
<p>a list of user-specified structure for the generation of the mean submodel design matrix, including the <code>type</code> (numeric, character, logical etc.), an <code>r</code> function (<code>random.func</code>) to generate the values of the regressors and the corresponding parameters (<code>param</code>) to be passed on to (<code>random.func</code>). Note that all  parameters that belong to the same <code>random.func</code> must be put in a <code>list(...)</code>. See details.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_z.str">z.str</code></td>
<td>
<p>a list of user-specified structure for the generation of the dispersion submodel design matrix, including the <code>type</code> (numeric, character, logical etc.), an <code>r</code> function (<code>random.func</code>) to generate the values of the regressors and the corresponding parameters (<code>param</code>) to be passed on to (<code>random.func</code>). Note that all  parameters that belong to the same <code>random.func</code> must be put in a <code>list(...)</code>. See details.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_n">n</code></td>
<td>
<p>a numeric value specifying the sample size in each simulation.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_simnum">simnum</code></td>
<td>
<p>a numeric value specifying the number of simulations.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_trace">trace</code></td>
<td>
<p>a specification whether the estimated coefficients should be printed to screen after each simulation.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_asymp.test">asymp.test</code></td>
<td>
<p>a specification whether the Rao's score and Wald tests should be conducted for each simulation.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_...">...</code></td>
<td>
<p>for <code>control</code>: arguments to be used to form the default control argument if it is not supplied directly. For <code>jmdem.sim</code>: further arguments passed to or from other methods.</p>
</td></tr>
</table>
<p>The following arguments are used for JMDEM fitting. See <code><a href="#topic+jmdem">jmdem</a></code> for details.
</p>
<table>
<tr><td><code id="jmdem.sim_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or -a numeric vector.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_moffset">moffset</code></td>
<td>
<p>an a priori known component to be included in the linear predictor of the <em>mean</em> submodel during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_doffset">doffset</code></td>
<td>
<p>an a priori known component to be included in the linear predictor of the <em>dispersion</em> submodel during fitting. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_mustart">mustart</code></td>
<td>
<p>a vector of starting values of individual means.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_phistart">phistart</code></td>
<td>
<p>a vector of starting values of individual dispersion.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_betastart">betastart</code></td>
<td>
<p>a vector of starting values for the regression parameters of the <em>mean</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_lambdastart">lambdastart</code></td>
<td>
<p>a vector of starting values for the regression parameters of the <em>dispersion</em> submodel.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_hessian">hessian</code></td>
<td>
<p>the method used to compute the information matrix. Hessian matrix will be calculated for <code>"TRUE"</code>, Fisher matrix for <code>"FALSE"</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Another possible value is <code>NULL</code>, no action. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_grad.func">grad.func</code></td>
<td>
<p>the gradient function will be included in the optimisation for the &quot;<code>BFGS</code>&quot;, &quot;<code>CG</code>&quot; and &quot;<code>L-BFGS-B</code>&quot; methods for <code>"TRUE"</code>. If it is <code>NULL</code>, a finite-difference approximation will be used.
</p>
<p>For the &quot;<code>SANN</code>&quot; method it specifies a function to generate a new candidate point. If it is <code>NULL</code> a default Gaussian Markov kernel is used.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_fit.method">fit.method</code></td>
<td>
<p>the method to be used in fitting the model. The default method &quot;<code>jmdem.fit</code>&quot; uses the general-purpose optimisation (<code>optim</code>): the alternative &quot;model.frame&quot; returns the model frame and does no fitting.
</p>
<p>User-supplied fitting functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>jmdem.fit</code>. If specified as a character string it is looked up from within the <em>stats</em> namespace.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_method">method</code></td>
<td>
<p>the method to be used for the optimisation. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_df.adj">df.adj</code></td>
<td>
<p>an adjustment factor for the degrees of freedom <code>(n-p)/n</code>, where <code>n</code> is the number of observations and <code>p</code> is the number of parameters to be estimated in <code>jmdem</code>, will be multiplied to the likelihood function before the optimisation for <code>"TRUE"</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_disp.adj">disp.adj</code></td>
<td>
<p>an adjustment factor for the dispersion weight will be multiplied to the estimated dispersion parameter during the optimisation for <code>"TRUE"</code>. For details, please see McCullagh and Nelder (1989, Ch. 10, P. 362).</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_full.loglik">full.loglik</code></td>
<td>
<p>the full likelihood function instead of the quasi- or pseudo-likelihood function will be used for the optimisation for <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_mcontrasts">mcontrasts</code></td>
<td>
<p>an optional list for the mean effect constrasts. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_dcontrasts">dcontrasts</code></td>
<td>
<p>an optional list for the dispersion effect constrasts. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_beta.first">beta.first</code></td>
<td>
<p>the mean effects will be estimated (assuming constant sample dispersion) at the initial stage for <code>TRUE</code>. For <code>FALSE</code>, the dispersion effects will be estimated first (assuming constantly zero mean for the whole sample).</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_prefit">prefit</code></td>
<td>
<p>a specfication whether <code>jmdem</code> uses <code>glm</code> to prefit the starting values of the mean and dispersion parameters. For <code>FALSE</code>, the initial parameter values of all the regressors are set to zero and the sample mean and sample dispersion will be used as the starting values of the corresponding submodel intercepts instead. If the submodels have no intercept, all parameters will also be set to zero. The sample mean and sample dispersion will then be used as <code>mustart</code> and <code>phistart</code> in the internal computation (they will not be officially recorded in <code>mustart</code> and <code>phistart</code> in the output object). Defaule value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>jmdem.fit</code> this is passed to <code>jmdem.control</code>.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_minv.method">minv.method</code></td>
<td>
<p>the method used to invert matrices during the estimation process. &quot;<code>solve</code>&quot; gives the solutions of a system of equations, &quot;<code>chol2inv</code>&quot; gives the inverse from Choleski or QR decomposition and &quot;<code>ginv</code>&quot; gives the generalised inverse of a matrix. If none of the methods is specified or if they are specified in a vector such as <code>c("solve", "chol2inv", "ginv")</code>, the matrices will be inverted by the methods in the sequence as given in the vector until it is found.</p>
</td></tr>
<tr><td><code id="jmdem.sim_+3A_object">object</code></td>
<td>
<p>one or several objects of class <code>jmdem.sim</code>, typically the result of a call to <code>jmdem.sim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>jmdem.sim</code> simulates the fitting of datasets in which the regressors of the mean and dispersion submodels are generated according to the specification given in <code>x.str</code> and <code>z.str</code>. The response variable will be then generated according to the distribution specified in <code>mfamily</code> with linear predictor of the mean given by <code>mformula</code> and the linear predictor of the dispersion given by <code>dformula</code>.
</p>
<p>The specifications in <code>x.str</code> and <code>z.str</code> are rather flexible if more than one independent variables are included in any of the submodels. For instance, if one of the two independent variables of the mean submodel is numeric generated from the normal distribution of mean 0 and standard deviation 1, and the other one is a 4-level factor <code class="reqn">{0, 1, 2, 3}</code> generated from the uniform distribution, then they can be specified in a vector using <code>c(...)</code>, such as: <code>x.str = list(type = c("numeric", "factor"), random.func = c("rnorm", "runif"), param = c(list(mean = 0, sd = 1), list(min = 0, max = 3)))</code>.
</p>
<p>Note that the higher the number of simulations specified in <code>simnum</code>, the more stabilised are the aggregated simulation results. The larger the sample size in each simulation, the less fluctuated are the estimated results among the simulations.
</p>
<p>Users gain <code>simdata.jmdem.sim</code> higher control on the simulation by generating a number of datasets upon their own settings first, and not running <code>jmdem.sim</code> at the same time. By taking these steps, users also have the flexiblility to edit the datasets according their own individual requirements, before calling them in <code>jmdem.sim</code>.
</p>
<p>Users can also extract the datasets used in <code>jmdem.sim</code> by <code>getdata.jmdem.sim</code>. This function is useful if the datasets are generated in <code>jmdem.sim</code> where users do not have access prior to the simulations. 
</p>
<p><code>getdata.jmdem.sim</code> and <code>simdata.jmdem.sim</code> can also be useful if the users would like to conduct various simulations with different <code>jmdem</code> settings on the same data.
</p>


<h3>Value</h3>

<p>An object of class <code>jmdem.sim</code> contains of a list of <code>jmdem</code> fits with full model information. That means, each element of the <code>jmdem.sim</code> object contains the same attributes as a <code>jmdem</code> object. See <em>values</em> of <code>jmdem</code> for details.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem">jmdem</a></code>, <code><a href="#topic+summary.jmdem.sim">summary.jmdem.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run 10 JMDEM simulations with samples of size 50. The response
## variable is Gaussian with mean beta_0 + beta_1 * x and variance 
## log(sigma^2) = lambda_0 + lambda_1 * z. The observations of 
## the predictor x should be random numbers generated from the normal 
## distribution with mean 0 and standard deviation 2. The observations
## of z are factors with three levels between 0 and 2, generated from 
## the uniform distribution. The true values of the mean submodel's 
## intercept and slope are 1.5 and 4, as well as 2.5, 3 and -0.2 for 
## the dispersion submodel's intercept and slope.
sim &lt;- jmdem.sim(mformula = y ~ x, dformula = ~ z, beta.first = TRUE, 
                 mfamily = gaussian, dfamily = Gamma(link = "log"), 
                 x.str = list(type = "numeric", random.func = "rnorm", 
                              param = list(mean = 0, sd = 2)),
                 z.str = list(type = "factor", random.func = "runif", 
                              param = list(min = 0, max = 2)),
                 beta.true = c(1.5, 4), lambda.true = c(2.5, 3, -0.2), 
                 grad.func = TRUE, method = "BFGS", n = 50,
                 simnum = 10)
</code></pre>

<hr>
<h2 id='jmdem.summaries'>
Accessing Joint Mean and Dispersion Effect Model Fits
</h2><span id='topic+family.jmdem'></span><span id='topic+formula.jmdem'></span><span id='topic+residuals.jmdem'></span>

<h3>Description</h3>

<p>These functions are all <code><a href="utils.html#topic+methods">methods</a></code> for class <code>jmdem</code> or <code>summary.jmdem</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
formula(x, submodel = c("both", "mean", "dispersion"), ...)

## S3 method for class 'jmdem'
family(object, submodel = c("both", "mean", "dispersion"), ...)

## S3 method for class 'jmdem'
residuals(object, type = c("deviance", "pearson", "working",
                           "response", "partial"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jmdem.summaries_+3A_x">x</code>, <code id="jmdem.summaries_+3A_object">object</code></td>
<td>
<p>the function family accesses the family objects which are stored within objects created by <code>jmdem.</code></p>
</td></tr>
<tr><td><code id="jmdem.summaries_+3A_submodel">submodel</code></td>
<td>
<p>character. The family of the specified submodel. For <code>both</code>, the families of the mean and dispersion submodels will be return in a list of 2 elements.</p>
</td></tr>
<tr><td><code id="jmdem.summaries_+3A_type">type</code></td>
<td>
<p>character. For <code>residuals</code>, the type of residuals which should be returned. The alternatives are: &quot;<code>deviance</code>&quot; (default), &quot;<code>pearson</code>&quot;, &quot;<code>working</code>&quot;, &quot;<code>response</code>&quot;, and &quot;<code>partial</code>&quot;.</p>
</td></tr>
<tr><td><code id="jmdem.summaries_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>family</code> is a generic function with methods for class &quot;jmdem&quot;. See <code><a href="stats.html#topic+family">family</a></code> for details.
</p>
<p>Here <code>formula</code> is referred to the case that it is called on a fitted <code>jmdem</code> model object. The default first, depending on the specified <code>submodel</code> argument, looks for a &quot;<code>mean.formula</code>&quot; and/or &quot;<code>dispersion.formula</code>&quot; component of the <code>jmdem</code> object (and evaluates it), then a &quot;<code>mean.terms</code>&quot; and/or &quot;<code>dispersion.terms</code>&quot; component, then a <code>mformula</code> and/or <code>dformula</code> parameter of the call (and evaluates its value) and finally a &quot;<code>formula</code>&quot; attribute.
</p>
<p>The references define the types of residuals: Davison &amp; Snell is a good reference for the usages of each.
</p>
<p>The partial residuals are a matrix of working residuals, with each column formed by omitting a term from the model.
</p>
<p>How <code>residuals</code> treats cases with missing values in the original fit is determined by the <code>na.action</code> argument of that fit. If <code>na.action = na.omit</code> omitted cases will not appear in the residuals, whereas if <code>na.action = na.exclude</code> they will appear, with residual value <code>NA</code>. See also <code><a href="stats.html#topic+naresid">naresid</a></code>.
</p>
<p>For fits done with <code>y = FALSE</code> the response values are computed from other components.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Cox, D. R. and Snell, E. J. (1981). <em>Applied Statistics; Principles and Examples</em>. London: Chapman and Hall.
</p>
<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in S</em>. Wadsworth &amp; Brooks/Cole.
</p>
<p>Davison, A. C. and Snell, E. J. (1991). <em>Residuals and diagnostics</em>. In: Statistical Theory and Modelling. In Honour of Sir David Cox, FRS, eds. Hinkley, D. V., Reid, N. and Snell, E. J., Chapman &amp; Hall.
</p>
<p>Dobson, A. J. (1983). <em>An Introduction to Statistical Modelling</em>. London: Chapman and Hall.
</p>
<p>Hastie, T. J. and Pregibon, D. (1992). <em>Generalized linear models</em>. Chapter 6 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>McCullagh P. and Nelder, J. A. (1989). <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem">jmdem</a></code>, <code><a href="#topic+anova.jmdem">anova.jmdem</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+df.residual">df.residual</a></code>, <code><a href="stats.html#topic+effects">effects</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+weighted.residuals">weighted.residuals</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+residuals.jmdem">residuals.jmdem</a></code>, <code><a href="#topic+summary.jmdem">summary.jmdem</a></code>, <code><a href="stats.html#topic+weights">weights</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The jmdem(...) example
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")

coef(fit)
plot(resid(fit), fitted(fit))
abline(h = 0, lty = 2, col = "gray")
</code></pre>

<hr>
<h2 id='model.matrix.jmdem'>
Construct Design Matrices
</h2><span id='topic+model.matrix.jmdem'></span>

<h3>Description</h3>

<p><code>model.matrix</code> creates a design (or model) matrix, e.g., by expanding factors to a set of dummy variables (depending on the contrasts) and expanding interactions similarly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
model.matrix(object, submodel = c("both", "mean", "dispersion"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.jmdem_+3A_object">object</code></td>
<td>
<p>the function family accesses the family objects which are stored within objects created by <code>jmdem.</code></p>
</td></tr>
<tr><td><code id="model.matrix.jmdem_+3A_submodel">submodel</code></td>
<td>
<p>character. The family of the specified submodel. For <code>both</code>, the families of the mean and dispersion submodels will be return in a list of 2 elements.</p>
</td></tr>
<tr><td><code id="model.matrix.jmdem_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.matrix</code> creates a design matrix from the description given in <code>terms(object)</code>, using the data in <code>data</code> which must supply variables with the same names as would be created by a call to <code>model.frame(object)</code> or, more precisely, by evaluating <code>attr(terms(object), "variables")</code>. 
</p>


<h3>Value</h3>

<p>The design matrix for a regression-like model with the specified formula and data.
</p>
<p>There is an attribute &quot;<code>assign</code>&quot;, an integer vector with an entry for each column in the matrix giving the term in the formula which gave rise to the column. Value <code>0</code> corresponds to the intercept (if any), and positive values to terms in the order given by the <code>term.labels</code> attribute of the <code>terms</code> structure corresponding to object.
</p>
<p>If there are any factors in terms in the model, there is an attribute &quot;<code>contrasts</code>&quot;, a named list with an entry for each factor. This specifies the contrasts that would be used in terms in which the factor is coded by contrasts (in some terms dummy coding may be used), either as a character vector naming a function or as a numeric matrix.</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Chambers, J. M. (1992). <em>Data for models</em>. Chapter 3 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.extract">model.extract</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
              
## Extract the design matrix of the mean submodel
model.matrix(fit, submodel = "mean")
</code></pre>

<hr>
<h2 id='predict.jmdem'>
Predict Method for JMDEM Fits</h2><span id='topic+predict.jmdem'></span>

<h3>Description</h3>

<p>Obtains predictions and optionally estimates standard errors of those predictions from a fitted joint mean and dispersion effect model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
predict(object, newdata = NULL, type = c("link", "response"), 
        se.fit = FALSE, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.jmdem_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from &quot;<code>jmdem</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.jmdem_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.jmdem_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default is on the scale of the linear predictors; the alternative &quot;<code>response</code>&quot; is on the scale of the response variable. Thus for a default binomial model the default predictions are of log-odds (probabilities on logit scale) and <code>type = "response"</code> gives the predicted probabilities.</p>
</td></tr>
<tr><td><code id="predict.jmdem_+3A_se.fit">se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.jmdem_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.jmdem_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for the fit. In that case how cases with missing values in the original fit is determined by the <code>na.action</code> argument of that fit. If <code>na.action = na.omit</code> omitted cases will not appear in the residuals, whereas if <code>na.action = na.exclude</code> they will appear (in predictions and standard errors), with residual value <code>NA</code>. See also <code><a href="stats.html#topic+napredict">napredict</a></code>.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector or matrix of predictions.
</p>
<p>If <code>se.fit = TRUE</code>, a list with components
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Predictions, as for se.fit = FALSE.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Estimated standard errors.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Variables are first looked for in <code>newdata</code> and then searched for in the usual way (which will include the environment of the formula used in the fit). A warning will be given if the variables found are not of the same length as those in <code>newdata</code> if it was supplied.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem">jmdem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
              
## Predict on the scale of the response variable with standard errors.
predict(fit, type = "response", se.fit = TRUE)

## Predict based on a new observation on the scale of the linear 
## predictors with standard errors.
predict(fit, newdata = data.frame(x = -1.5, z = 100), se.fit = TRUE)

</code></pre>

<hr>
<h2 id='score.jmdem+2C+20wald.jmdem'>
Asymptotic tests for fits of joint mean and dispersion effects models
</h2><span id='topic+score.jmdem'></span><span id='topic+wald.jmdem'></span>

<h3>Description</h3>

<p>Computes a score (Rao) or Wald chi-squared test statistics for comparing two <code>jmdem</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.jmdem(object, ...)

wald.jmdem(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.jmdem+2B2C+2B20wald.jmdem_+3A_object">object</code></td>
<td>
<p>a model or <code>list</code> of two or more models fitted by <code>jmdem</code> to be tested. Pairwise tests will be conducted.</p>
</td></tr>
<tr><td><code id="score.jmdem+2B2C+2B20wald.jmdem_+3A_...">...</code></td>
<td>
<p>a <code>list</code> of two or more fitted models to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of model coefficients of length p, <code class="reqn">\Theta = (\theta_1, \ldots, \theta_q, \theta_{q+1}, \ldots, \theta_p)^T</code>, the score and Wald tests are usually used to test the null hypothesis against an alternative
</p>
<p style="text-align: center;"><code class="reqn">H_0: \theta_{q+1} = \ldots = \theta_p = 0 vs. H_0 not true</code>
</p>

<p>Thus, they are asymptotic tests on the explanatory power of one or more regressors. And the result of the score and Wald tests only makes sense if the models involved are nested, i.e. all coefficients of a &quot;smaller&quot; (null, restricted) model are included in a &quot;bigger&quot; (alternative, unrestricted) model.
</p>
<p>The main difference between the score and Wald tests is that the score test only requires the knowledge of the fitted coefficients of the &quot;small&quot; model. The Wald test, on the other hand, only need the estimates of the &quot;bigger&quot; model. Nevertheless, these tests are asymptotically equivalent, i.e. for large samples, the test statistics of these tests on the same set of models should be very close.
</p>
<p>The key assumption is that the coefficient estimates asymptotically follow a (multivariate) normal distribution with mean and variance equal to the model parameters and their variance-covariance matrix.
</p>
<p><code>score.jmdem</code> and <code>wald.jmdem</code> extract the fitted coefficients and their variance-covariance matrix from the model objects, and evaluate the test statistics subsequently. So it is not necessary to specify the coefficients and variance-covariance matrix in the function arguments.
</p>
<p><code>score.jmdem</code> and <code>wald.jmdem</code> only return the test statistics. They are asymptotically chi-square distributed with <code class="reqn">p - q</code> degrees of freedom.
</p>


<h3>Value</h3>

<p><code>score.jmdem</code> and <code>wald.jmdem</code> return a column matrix containing the test statistics of the pairwise comparisons of all models given by the user in <code>object</code> and <code>...</code>.
</p>


<h3>Note</h3>

<p>The score test is sometimes also called the Rao's score test or Lagrange multiplier (LM) test in different literatures.
</p>
<p>Normally, asymptotic tests include likelihood ratio (LR), Rao's score and Wald tests. The likelihood ratio test is omitted here because the comparison of the deviances of two joint mean and dispersion effects models is questionable, if not even invalid. One important argument is that the dependent variables of two different dispersion submodels given two different mean submodels are not the identical.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Engle, R.F. (1983). <em>Wald, Likelihood Ratio, and Lagrange Multiplier Tests in Econometrics</em>. In Intriligator, M. D.; Griliches, Z. <em>Handbook of Econometrics</em>. <strong>II</strong>. Elsevier. pp. 796-801.
</p>
<p>McCullagh P. and Nelder, J.A. (1989) <em>Generalized Linear Models</em>. London: Chapman and Hall.
</p>
<p>Wu, K.Y.K., Li, W.K. (2016). <em>On a dispersion model with Pearson residual responses</em>. Comput. Statist. Data Anal., <strong>103</strong>, 17-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.jmdem">anova.jmdem</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="#topic+jmdem">jmdem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x + delta, dformula = ~ z, 
                            mfamily = gaussian(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4, 1), 
                            lambda.true = c(2.5, 3), n = 100)

fit &lt;- jmdem(mformula = y ~ x + delta, dformula = ~ z, data = MyData, 
             mfamily = gaussian, dfamily = Gamma, dev.type = "pearson", 
             method = "BFGS", df.adj = TRUE)

fit.1 &lt;- update(fit, mformula = . ~ . - delta)

fit.2 &lt;- update(fit.1, mformula = . ~ . - x)

## conduct a Wald tests
wald.jmdem(fit, fit.1, fit.2)

## should deliver the same results as above
wald.jmdem(object = list(fit, fit.1, fit.2))

## conduct the score test and compute the p-value directly.
raotest &lt;- score.jmdem(fit, fit.2)
pchisq(raotest, df = abs(df.residual(fit) - df.residual(fit.2)), 
       lower.tail = FALSE)
</code></pre>

<hr>
<h2 id='stat.anova.jmdem'>
JMDEM Anova Statistics
</h2><span id='topic+stat.anova.jmdem'></span>

<h3>Description</h3>

<p>This is a utility function, used in <code>jmdem</code> method for <code><a href="stats.html#topic+anova">anova</a>(..., test != NULL)</code> and should not be used by the average user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat.anova.jmdem(table, test = c("Rao", "Wald")) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat.anova.jmdem_+3A_table">table</code></td>
<td>
<p>numeric matrix as results from <code><a href="#topic+anova.jmdem">anova.jmdem</a>(..., test = NULL, print.results = FALSE)</code> saved as the attributes <code>table.x</code> or <code>table.z</code>.</p>
</td></tr>
<tr><td><code id="stat.anova.jmdem_+3A_test">test</code></td>
<td>
<p>a character string, partially matching one of &quot;<code>Rao</code>&quot; or &quot;<code>Wald</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which is the original <code>table</code>, augmented by a column of test statistics, depending on the <code>test</code> argument.
</p>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Hastie, T. J. and Pregibon, D. (1992). <em>Generalized linear models</em>. Chapter 6 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.jmdem">anova.jmdem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
              
stat.anova.jmdem(anova(fit, test = "Rao", print.results = FALSE)$table.x)
</code></pre>

<hr>
<h2 id='summary.jmdem'>
Summarising Joint Mean and Dispersion Effects Model Fits
</h2><span id='topic+summary.jmdem'></span><span id='topic+print.summary.jmdem'></span>

<h3>Description</h3>

<p>These functions are all <code><a href="utils.html#topic+methods">methods</a></code> for class <code>jmdem</code> or <code>summary.jmdem</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)
              
## S3 method for class 'summary.jmdem'
print(x, digits = max(3L, getOption("digits") - 3L), 
      scientific = FALSE, symbolic.cor = x$symbolic.cor, 
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.jmdem_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>jmdem</code>&quot;, usually, a result of a call to <code><a href="#topic+jmdem">jmdem</a></code>.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>summary.jmdem</code>&quot;, usually, a result of a call to <code>summary.jmdem</code>.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>	
<tr><td><code id="summary.jmdem_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_scientific">scientific</code></td>
<td>
<p>logical; if <code>TRUE</code>, scientific notation is used when printing.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.jmdem_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.jmdem</code> tries to be smart about formatting the coefficients, standard errors, etc. and additionally gives 'significance stars' if <code>signif.stars</code> is <code>TRUE</code>. The <code>coefficients</code>, <code>mean.coefficients</code> and <code>dispersion.coefficients</code> components of the result give the estimated coefficients and their estimated standard errors, together with their ratio. This third column is labelled <code>t-ratio</code> and a fourth column gives the two-tailed p-value corresponding to the <code>t-ratio</code> based on a Student t distribution.
</p>
<p>Aliased coefficients are omitted in the returned object but restored by the <code>print</code> method.
</p>
<p>Correlations are printed to the same decimal places specified in <code>digits</code> (or symbolically): to see the actual correlations print <code>summary(object)$correlation</code> directly.
</p>
<p>For more details, see <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mean.family</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dispersion.family</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mean.terms</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dispersion.terms</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mean.contrasts</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dispersion.contrasts</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>information.type</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mean.na.action</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dispersion.na.action</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals.</p>
</td></tr>
<tr><td><code>pearson.resid</code></td>
<td>
<p>the pearson residuals.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>the working residuals depends on the setting of <code>deviance.type</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>mean.coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values of the mean submodel.</p>
</td></tr>
<tr><td><code>dispersion.coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-values and p-values of the dispersion submodel.</p>
</td></tr>
<tr><td><code>deviance.type</code></td>
<td>
<p>the type of redidual deviance specified, it is either &quot;<code>deviance</code>&quot; or &quot;<code>pearson</code>&quot;.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p>named logical vector showing if the original coefficients are aliased.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a 3-vector of the rank of the model and the number of residual degrees of freedom, plus number of coefficients (including aliased ones).</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>the estimated covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code>scientific</code></td>
<td>
<p>logical value of using scientific notation when printing.</p>
</td></tr>
<tr><td><code>covmat.method</code></td>
<td>
<p>named method used to invert the covariance matrix.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>(only if correlation is true.) The estimated correlations of the estimated coefficients.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>(only if correlation is true.) The value of the argument symbolic.cor.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem">jmdem</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...)
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
              
## Summarise fit with correlation matrix
summary(fit, correlation = TRUE, digits = 4)
</code></pre>

<hr>
<h2 id='summary.jmdem.sim'>
Summarising JMDEM Simulations
</h2><span id='topic+summary.jmdem.sim'></span><span id='topic+print.summary.jmdem.sim'></span>

<h3>Description</h3>

<p>These functions are all <code><a href="utils.html#topic+methods">methods</a></code> for class <code>jmdem.sim</code> or <code>summary.jmdem.sim</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem.sim'
summary(object, digits = max(3L, getOption("digits") - 3L), 
        scientific = FALSE, pvalue = 0.05, 
        minv.method = c("solve", "chol2inv", "ginv"), 
        other.call = FALSE, details = FALSE, ...)
              
## S3 method for class 'summary.jmdem.sim'
print(x, digits = max(3L, getOption("digits") - 3L), scientific = FALSE, 
      pvalue = 0.05, signif.stars = getOption("show.signif.stars"), 
      other.call = FALSE, details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.jmdem.sim_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>jmdem.sim</code>&quot;, usually, a result of a call to <code><a href="#topic+jmdem.sim">jmdem.sim</a></code>.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>summary.jmdem.sim</code>&quot;, usually, a result of a call to <code>summary.jmdem.sim</code>.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_scientific">scientific</code></td>
<td>
<p>logical; if <code>TRUE</code>, scientific notation is used when printing.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_pvalue">pvalue</code></td>
<td>
<p>a value between 0 and 1. It is used to compute the coverage proportion of the true parameter values by the simulated fits.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_minv.method">minv.method</code></td>
<td>
<p>the method used to invert matrices during the estimation process. &quot;<code>solve</code>&quot; gives the solutions of a system of equations, &quot;<code>chol2inv</code>&quot; gives the inverse from Choleski or QR decomposition and &quot;<code>ginv</code>&quot; gives the generalised inverse of a matrix. If none of the methods is specified or if they are specified in a vector such as <code>c("solve", "chol2inv", "ginv")</code>, the matrices will be inverted by the methods in the sequence as given in the vector until it is found.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_other.call">other.call</code></td>
<td>
<p>logical. If <code>true</code>, the rest of simulation call (i.e. without the mean and dispersion submodel formulas, families, true values) will be shown.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_details">details</code></td>
<td>
<p>logical. If <code>true</code>, coefficients, standard errors, true parameter coverage (TRUE/FALSE) and asymptotic test statistics of each simulation will be listed.</p>
</td></tr>
<tr><td><code id="summary.jmdem.sim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arithmetric mean of the coefficients, standard errors and coverage by the confidence intervals estimated in all simulations will be listed in a table. A detail listing of each simulation's results can be provided if required by <code>details = TRUE</code>. The summary also includes the averages of the Rao's score and Wald test statistics of all simulation fits.
</p>
<p><code>print.summary.jmdem.sim</code> tries to be smart about formatting the coefficients, standard errors, etc according the number of significant <code>digits</code> (default of user-specified) or the usage of <code>scientific</code> notation or not.
</p>


<h3>Value</h3>

<table>
<tr><td><code>digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code>scientific</code></td>
<td>
<p>logical value of using scientific notation when printing.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>logical value of printing details of each simulation.</p>
</td></tr>
<tr><td><code>other.call</code></td>
<td>
<p>logical value of printing other parameters of the simulation call.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>numeric value between 0 and 1 used for the computation of the true parameter coverage.</p>
</td></tr>
<tr><td><code>beta.true</code></td>
<td>
<p>user-defined vector containing the true parameter values of the mean submodel.</p>
</td></tr>
<tr><td><code>lambda.true</code></td>
<td>
<p>user-defined vector containing the true parameter values of the dispersion submodel.</p>
</td></tr>
<tr><td><code>simcall</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mformula</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dformula</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>mfamily</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>dfamily</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>mean and dispersion submodel parameter coefficients fitted in each simulation saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>standard erros of all mean and dispersion submodel parameter coefficients estimated in each simulation saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>a vectror containing the running numbers of each simulation.</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>
<p>confidence intervals of all mean and dispersion submodel parameter coefficients estimated in each simulation saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>coverage</code></td>
<td>
<p>the coverage of all true submodel parameters by the confidence intervals estimated in each simulation saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>asymp.test</code></td>
<td>
<p>Rao's score and Wald test statistics of each simulation saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>average.summary</code></td>
<td>
<p>Arithmetric means of the coefficients, standard errors, confidence interval converage estimated in all simulations saved in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>average.asymp.test</code></td>
<td>
<p>(Arithmetric means of the Rao's score and Wald test statistics estimated in all simulations saved in a <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jmdem.sim">jmdem.sim</a></code>, <code><a href="#topic+jmdem">jmdem</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem.sim(...)
sim &lt;- jmdem.sim(mformula = y ~ x, dformula = ~ z, beta.first = TRUE, 
                 mfamily = gaussian, dfamily = Gamma(link = "log"), 
                 x.str = list(type = "numeric", random.func = "rnorm", 
                              param = list(mean = 0, sd = 2)),
                 z.str = list(type = "factor", random.func = "runif", 
                              param = list(min = 0, max = 2)),
                 beta.true = c(1.5, 4), lambda.true = c(2.5, 3, -0.2), 
                 grad.func = TRUE, method = "BFGS", n = 50,
                 simnum = 10)
                  
## Summarise simulation
summary(sim, details = FALSE, other.call = TRUE)
</code></pre>

<hr>
<h2 id='update.jmdem'>
Update and Re-fit a JMDEM Call
</h2><span id='topic+update.jmdem'></span>

<h3>Description</h3>

<p><code>update</code> will update and (by default) re-fit a model. It does this by extracting the call stored in the object, updating the call and (by default) evaluating that call. Sometimes it is useful to call update with only one argument, for example if the data frame has been corrected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jmdem'
update(object, mformula, dformula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.jmdem_+3A_object">object</code></td>
<td>
<p>An existing fit from a <code>jmdem</code> model function</p>
</td></tr>
<tr><td><code id="update.jmdem_+3A_mformula">mformula</code></td>
<td>
<p>Changes to the formula of the mean submodel - see update.formula for details.</p>
</td></tr>
<tr><td><code id="update.jmdem_+3A_dformula">dformula</code></td>
<td>
<p>Changes to the formula of the dispersion submodel - see update.formula for details.</p>
</td></tr>
<tr><td><code id="update.jmdem_+3A_...">...</code></td>
<td>
<p>Additional arguments to the call, or arguments with changed values. Use <code>name = NULL</code> to remove the argument name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Wu Ka Yui (karlwuky@suss.edu.sg)
</p>


<h3>References</h3>

<p>Chambers, J. M. (1992). <em>Linear models</em>. Chapter 4 of <em>Statistical Models</em> in S eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update.formula">update.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in jmdem(...): Update the dispersion fitting based on Pearson
## residuals and change from Nelder-Mead to BFGS as optimisation method.
MyData &lt;- simdata.jmdem.sim(mformula = y ~ x, dformula = ~ z, 
                            mfamily = poisson(), 
                            dfamily = Gamma(link = "log"), 
                            beta.true = c(0.5, 4), 
                            lambda.true = c(2.5, 3), n = 100)
                            
fit &lt;- jmdem(mformula = y ~ x, dformula = ~ z, data = MyData, 
             mfamily = poisson, dfamily = Gamma(link = "log"), 
             dev.type = "deviance", method = "CG")
             
update(fit, dev.type = "pearson", method = "BFGS")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
