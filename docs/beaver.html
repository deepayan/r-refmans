<!DOCTYPE html><html><head><title>Help for package beaver</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {beaver}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beaver_mcmc'><p>Bayesian Model Averaging of Covariate Adjusted Neg-Binomial Dose-Response</p></a></li>
<li><a href='#data_negbin_emax'><p>Generate data from a negative binomial EMAX model</p></a></li>
<li><a href='#draws'><p>Posterior Draws</p></a></li>
<li><a href='#model_negbin_emax'><p>Negative Binomial EMAX Dose Response</p></a></li>
<li><a href='#model_negbin_exp'><p>Negative Binomial Exponential Dose Response</p></a></li>
<li><a href='#model_negbin_indep'><p>Negative Binomial Independent Dose Response</p></a></li>
<li><a href='#model_negbin_linear'><p>Negative Binomial Linear Dose Response</p></a></li>
<li><a href='#model_negbin_loglinear'><p>Negative Binomial Log-Linear Dose Response</p></a></li>
<li><a href='#model_negbin_logquad'><p>Negative Binomial Log-Quadratic Dose Response</p></a></li>
<li><a href='#model_negbin_quad'><p>Negative Binomial Quadratic Dose Response</p></a></li>
<li><a href='#model_negbin_sigmoid_emax'><p>Negative Binomial Sigmoidal EMAX Dose Response</p></a></li>
<li><a href='#posterior_g_comp'><p>Compute Posterior G-Computation Estimate</p></a></li>
<li><a href='#posterior.beaver_mcmc'><p>Posterior Samples from Bayesian Model Averaging</p></a></li>
<li><a href='#posterior.beaver_mcmc_bma'><p>Posterior Samples from Bayesian Model Averaging</p></a></li>
<li><a href='#pr_eoi'><p>Calculate Probability of Meeting Effect of Interest</p></a></li>
<li><a href='#pr_eoi_g_comp'><p>Calculate Probability of Meeting Effect of Interest using G-Computation</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Model Averaging of Covariate Adjusted Negative-Binomial
Dose-Response</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Dose-response modeling for negative-binomial distributed data with
  a variety of dose-response models. Covariate adjustment and Bayesian
  model averaging is supported. Functions are provided to easily obtain
  inference on the dose-response relationship and plot the dose-response curve.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rich-payne/beaver">https://github.com/rich-payne/beaver</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.1), dplyr (&ge; 1.0), ellipsis (&ge; 0.3), fs (&ge;
1.5), ggplot2 (&ge; 3.3), purrr (&ge; 0.3), rjags (&ge; 4.12), rlang
(&ge; 1.0), stringr (&ge; 1.5), tibble (&ge; 3.1), tidyr (&ge; 1.1),
yodel (&ge; 1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-21 21:43:59 UTC; c050983</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Payne [aut],
  Hollins Showalter [aut, cre],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hollins Showalter &lt;hollins.showalter@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 13:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='beaver_mcmc'>Bayesian Model Averaging of Covariate Adjusted Neg-Binomial Dose-Response</h2><span id='topic+beaver_mcmc'></span>

<h3>Description</h3>

<p>Bayesian Model Averaging of Covariate Adjusted Neg-Binomial Dose-Response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beaver_mcmc(
  data,
  formula = ~1,
  ...,
  n_adapt = 1000,
  n_burn = 1000,
  n_iter = 10000,
  n_chains = 4,
  thin = 1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beaver_mcmc_+3A_data">data</code></td>
<td>
<p>a dataframe with columns &quot;dose&quot;, &quot;response&quot; and any covariates
listed in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_formula">formula</code></td>
<td>
<p>a right-hand sided formula specifying the covariates.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_...">...</code></td>
<td>
<p>candidate models to be included in Bayesian model averaging.
These should be created from calls to the <code style="white-space: pre;">&#8288;model_negbin_*&#8288;</code> functions
(e.g. <code>model_negbin_emax()</code>).</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_n_adapt">n_adapt</code></td>
<td>
<p>the number of iterations used to tune the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_n_burn">n_burn</code></td>
<td>
<p>the number of MCMC iterations used for burn-in.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_n_iter">n_iter</code></td>
<td>
<p>the number of MCMC iterations to save.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_n_chains">n_chains</code></td>
<td>
<p>the number of MCMC chains.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_thin">thin</code></td>
<td>
<p>thinning for the MCMC chain.</p>
</td></tr>
<tr><td><code id="beaver_mcmc_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating if MCMC chain progress output should be
silenced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (with appropriate S3 classes) with the prior and posterior
weights, sampled model index, and individual MCMC fits.
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>
<p>Other posterior calculations: 
<code><a href="#topic+posterior.beaver_mcmc_bma">posterior.beaver_mcmc_bma</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc">posterior.beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior_g_comp">posterior_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi_g_comp">pr_eoi_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi">pr_eoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='data_negbin_emax'>Generate data from a negative binomial EMAX model</h2><span id='topic+data_negbin_emax'></span>

<h3>Description</h3>

<p>Generate data from a negative binomial EMAX model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_negbin_emax(n_per_arm, doses, b1, b2, b3, ps, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_negbin_emax_+3A_n_per_arm">n_per_arm</code></td>
<td>
<p>number of subjects in each dose arm.</p>
</td></tr>
<tr><td><code id="data_negbin_emax_+3A_doses">doses</code></td>
<td>
<p>doses at which to simulate subjects.</p>
</td></tr>
<tr><td><code id="data_negbin_emax_+3A_b1">b1</code>, <code id="data_negbin_emax_+3A_b2">b2</code>, <code id="data_negbin_emax_+3A_b3">b3</code>, <code id="data_negbin_emax_+3A_ps">ps</code></td>
<td>
<p>parameters from which to simulate data.  See model
description below.  If covariates are specified (through <code>x</code>), then
<code>b1</code> should be a vector of length <code>ncol(x)</code>.</p>
</td></tr>
<tr><td><code id="data_negbin_emax_+3A_x">x</code></td>
<td>
<p>the model matrix for the covariates.  Must have the same number of
rows as the total number of subjects
(<code>sum(n_per_arm * rep(1, length(doses)))</code>).  If <code>NULL</code>, then an
intercept term is used by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns &quot;subject&quot;, &quot;dose&quot;, and &quot;response&quot;.
</p>


<h3>Negative Binomial EMAX</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * d_i / (b3 + d_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2) (Truncated to be positive)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is an EMAX
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='draws'>Posterior Draws</h2><span id='topic+draws'></span><span id='topic+draws.beaver_mcmc'></span><span id='topic+draws.beaver_mcmc_bma'></span>

<h3>Description</h3>

<p>Extracts posterior draws and puts them into a dataframe or
tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draws(x, ...)

## S3 method for class 'beaver_mcmc'
draws(x, ...)

## S3 method for class 'beaver_mcmc_bma'
draws(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws_+3A_x">x</code></td>
<td>
<p>MCMC output.</p>
</td></tr>
<tr><td><code id="draws_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>For generic:</dt><dd>
<p>See specific method.
</p>
</dd>
</dl>


<dl>
<dt>For class 'beaver_mcmc':</dt><dd>
<p>A dataframe or tibble of MCMC draws.
</p>
</dd>
</dl>


<dl>
<dt>For class 'beaver_mcmc_bma':</dt><dd>
<p>An error.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='model_negbin_emax'>Negative Binomial EMAX Dose Response</h2><span id='topic+model_negbin_emax'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
an EMAX Model on the mean.  This function is to be used within a call
to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_emax(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  w_prior = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_emax_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_emax_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_emax_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_emax_+3A_sigma_b2">sigma_b2</code>, <code id="model_negbin_emax_+3A_mu_b3">mu_b3</code>, <code id="model_negbin_emax_+3A_sigma_b3">sigma_b3</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_emax_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial EMAX</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * d_i / (b3 + d_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2) (Truncated to be positive)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is an EMAX
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_exp'>Negative Binomial Exponential Dose Response</h2><span id='topic+model_negbin_exp'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
an exponential model on the mean.  This function is to be used within a
call to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_exp(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  w_prior = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_exp_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_exp_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_exp_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_exp_+3A_sigma_b2">sigma_b2</code>, <code id="model_negbin_exp_+3A_mu_b3">mu_b3</code>, <code id="model_negbin_exp_+3A_sigma_b3">sigma_b3</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_exp_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Exponential</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * (1 - exp(-b3 * d_i))</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2) (Truncated to be positive)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is an exponential
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_indep'>Negative Binomial Independent Dose Response</h2><span id='topic+model_negbin_indep'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial
distribution with an independent mean for each dose.
This function is to be used within a call
to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_indep(mu_b1, sigma_b1, mu_b2, sigma_b2, w_prior = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_indep_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_indep_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_indep_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_indep_+3A_sigma_b2">sigma_b2</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_indep_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Independent</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on the <code class="reqn">k</code>th dose.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2_k</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2_k ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is an exponential
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_linear'>Negative Binomial Linear Dose Response</h2><span id='topic+model_negbin_linear'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
an linear model on the mean.  This function is to be used within a call
to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_linear(mu_b1, sigma_b1, mu_b2, sigma_b2, w_prior = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_linear_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_linear_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_linear_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_linear_+3A_sigma_b2">sigma_b2</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_linear_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Linear</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * d_i</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is a linear
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_loglinear'>Negative Binomial Log-Linear Dose Response</h2><span id='topic+model_negbin_loglinear'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
a log-linear model on the mean.  This function is to be used within a call
to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_loglinear(mu_b1, sigma_b1, mu_b2, sigma_b2, w_prior = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_loglinear_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_loglinear_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_loglinear_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_loglinear_+3A_sigma_b2">sigma_b2</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_loglinear_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Log-Linear</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * log(1 + d_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is a log-linear
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_logquad'>Negative Binomial Log-Quadratic Dose Response</h2><span id='topic+model_negbin_logquad'></span>

<h3>Description</h3>

<p>Model settings fora negative binomial distribution assuming
a log-quadratic model on the mean.  This function is to be used within a
call to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_logquad(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  w_prior = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_logquad_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_logquad_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_logquad_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_logquad_+3A_sigma_b2">sigma_b2</code>, <code id="model_negbin_logquad_+3A_mu_b3">mu_b3</code>, <code id="model_negbin_logquad_+3A_sigma_b3">sigma_b3</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_logquad_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Quadratic</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">
    log(\mu_{ij}) = x_{ij} * b1 + b2 * log(1 + d_i) + b3 * log(1 + d_i) ^ 2
  </code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is a quadratic
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_quad'>Negative Binomial Quadratic Dose Response</h2><span id='topic+model_negbin_quad'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
an quadratic model on the mean.  This function is to be used within a call
to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_quad(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  w_prior = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_quad_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_quad_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_quad_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_quad_+3A_sigma_b2">sigma_b2</code>, <code id="model_negbin_quad_+3A_mu_b3">mu_b3</code>, <code id="model_negbin_quad_+3A_sigma_b3">sigma_b3</code></td>
<td>
<p>hyperparameters.  See
the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_quad_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Quadratic</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * d_i + b3 * d_i ^ 2</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is a quadratic
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_sigmoid_emax">model_negbin_sigmoid_emax</a>()</code>
</p>

<hr>
<h2 id='model_negbin_sigmoid_emax'>Negative Binomial Sigmoidal EMAX Dose Response</h2><span id='topic+model_negbin_sigmoid_emax'></span>

<h3>Description</h3>

<p>Model settings for a negative binomial distribution assuming
a Sigmoidal EMAX Model on the mean.  This function is to be used within a
call to <code>beaver_mcmc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_negbin_sigmoid_emax(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  mu_b4,
  sigma_b4,
  w_prior = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_negbin_sigmoid_emax_+3A_mu_b1">mu_b1</code>, <code id="model_negbin_sigmoid_emax_+3A_sigma_b1">sigma_b1</code>, <code id="model_negbin_sigmoid_emax_+3A_mu_b2">mu_b2</code>, <code id="model_negbin_sigmoid_emax_+3A_sigma_b2">sigma_b2</code>, <code id="model_negbin_sigmoid_emax_+3A_mu_b3">mu_b3</code>, <code id="model_negbin_sigmoid_emax_+3A_sigma_b3">sigma_b3</code>, <code id="model_negbin_sigmoid_emax_+3A_mu_b4">mu_b4</code>, <code id="model_negbin_sigmoid_emax_+3A_sigma_b4">sigma_b4</code></td>
<td>
<p>hyperparameters.  See the model description below for context.</p>
</td></tr>
<tr><td><code id="model_negbin_sigmoid_emax_+3A_w_prior">w_prior</code></td>
<td>
<p>the prior weight for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model's prior weight and hyperparameter values.
</p>


<h3>Negative Binomial Sigmoidal EMAX</h3>

<p>Let <code class="reqn">y_{ij}</code> be the <code class="reqn">j</code>th subject on dose <code class="reqn">d_i</code>.
The model is
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} ~ NB(p_i, r_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_i ~ Uniform(0, 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{ij} = (\mu_{ij} * p_i) / (1 - p_i)</code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{ij}) = x_{ij} * b1 + b2 * d_i ^ b4 / (b3 + d_i ^ b4)</code>
</p>

<p style="text-align: center;"><code class="reqn">b1 ~ N(`mu_b1`, `sigma_b1`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b2 ~ N(`mu_b2`, `sigma_b2`^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b3`, `sigma_b3`^2) (Truncated to be positive)</code>
</p>

<p style="text-align: center;"><code class="reqn">b3 ~ N(`mu_b4`, `sigma_b4`^2) (Truncated to be positive)</code>
</p>

<p>The model is parameterized in terms of the mean of the
negative binomial distribution and the usual probability parameter p.
The prior on the mean is an EMAX
model, and the prior on p at each dose is Uniform(0, 1).
The model can adjust for baseline covariates, (</p>
<p style="text-align: center;"><code class="reqn">x_{ij}</code>
</p>
<p>).
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+model_negbin_emax">model_negbin_emax</a>()</code>,
<code><a href="#topic+model_negbin_exp">model_negbin_exp</a>()</code>,
<code><a href="#topic+model_negbin_indep">model_negbin_indep</a>()</code>,
<code><a href="#topic+model_negbin_linear">model_negbin_linear</a>()</code>,
<code><a href="#topic+model_negbin_loglinear">model_negbin_loglinear</a>()</code>,
<code><a href="#topic+model_negbin_logquad">model_negbin_logquad</a>()</code>,
<code><a href="#topic+model_negbin_quad">model_negbin_quad</a>()</code>
</p>

<hr>
<h2 id='posterior_g_comp'>Compute Posterior G-Computation Estimate</h2><span id='topic+posterior_g_comp'></span>

<h3>Description</h3>

<p>Calculate the estimated effect for each observation
at each dose and average over all observations.  This function calculates
the posterior marginal treatment effect at each dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_g_comp(
  x,
  doses = attr(x, "doses"),
  reference_dose = NULL,
  prob = c(0.025, 0.975),
  return_stats = TRUE,
  return_samples = FALSE,
  new_data = NULL,
  reference_type = c("difference", "ratio")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_g_comp_+3A_x">x</code></td>
<td>
<p>an object output from <code>beaver_mcmc()</code> or (internal function)
<code>run_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_doses">doses</code></td>
<td>
<p>doses at which to obtain the posterior.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_reference_dose">reference_dose</code></td>
<td>
<p>dose to which to compare as either a difference or
ratio.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_prob">prob</code></td>
<td>
<p>the percentiles of the posterior to calculate for each dose.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_return_stats">return_stats</code></td>
<td>
<p>logical indicating if the posterior mean and quantiles
should be returned.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if posterior mean samples should
be returned.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_new_data">new_data</code></td>
<td>
<p>a dataframe containing all the variables used in the
covariate adjustments to the model used to obtain <code>x</code>.  Usually this
will be the same dataframe used to fit the model.</p>
</td></tr>
<tr><td><code id="posterior_g_comp_+3A_reference_type">reference_type</code></td>
<td>
<p>whether to provide the posterior of the difference or
the ratio between each dose and the reference dose.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements <code>stats</code> and <code>samples</code>. When using this
function with default settings, <code>samples</code> is NULL and <code>stats</code> is a
dataframe summarizing the posterior samples. <code>stats</code> contains, at a
minimum, the columns &quot;dose&quot;, &quot;value&quot;, and variables corresponding to the
values passed in <code>prob</code> (&quot;2.50%&quot; and &quot;97.50%&quot; by default). When
<code>return_stats</code> is set to <code>FALSE</code>, <code>stats</code> is NULL. When <code>return_samples</code>
is set to <code>TRUE</code>, <code>samples</code> is a dataframe with the posterior samples for
each iteration of the MCMC.
</p>

<dl>
<dt>When x is of class 'beaver_mcmc_bma':</dt><dd>
<p>The dataframe will have, at a minimum, the columns &quot;iter&quot; and &quot;model&quot;,
indicating the MCMC iteration and the model that was used in the
calculations, as well as the columns &quot;dose&quot; and &quot;value&quot;. The functions
used for each model are defined within the <code>model_negbin_XYZ()</code>
functions and used in the <code>beaver_mcmc()</code> function.
</p>
</dd>
<dt>When x is of class 'beaver_mcmc':</dt><dd>
<p>The dataframe will have, at a minimum, the column &quot;iter&quot;, indicating
the MCMC iteration, as well as the columns &quot;dose&quot; and &quot;value&quot;. The
functions used for each model are defined within the
<code>model_negbin_XYZ()</code> functions and used in the <code>run_mcmc()</code> function.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other posterior calculations: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc_bma">posterior.beaver_mcmc_bma</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc">posterior.beaver_mcmc</a>()</code>,
<code><a href="#topic+pr_eoi_g_comp">pr_eoi_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi">pr_eoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='posterior.beaver_mcmc'>Posterior Samples from Bayesian Model Averaging</h2><span id='topic+posterior.beaver_mcmc'></span>

<h3>Description</h3>

<p>Calculate posterior quantities of interest using Bayesian model
averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'beaver_mcmc'
posterior(
  x,
  doses = attr(x, "doses"),
  reference_dose = NULL,
  prob = c(0.025, 0.975),
  return_stats = TRUE,
  return_samples = FALSE,
  new_data = NULL,
  contrast = NULL,
  reference_type = c("difference", "ratio"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.beaver_mcmc_+3A_x">x</code></td>
<td>
<p>an object output from (internal function) <code>run_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_doses">doses</code></td>
<td>
<p>doses at which to obtain the posterior.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_reference_dose">reference_dose</code></td>
<td>
<p>dose to which to compare as either a difference or
ratio.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_prob">prob</code></td>
<td>
<p>the percentiles of the posterior to calculate for each dose.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_return_stats">return_stats</code></td>
<td>
<p>logical indicating if the posterior mean and quantiles
should be returned.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if posterior mean samples should
be returned.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_new_data">new_data</code></td>
<td>
<p>a dataframe for which the posterior will be calculated for
each observation's covariate values.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_contrast">contrast</code></td>
<td>
<p>a matrix containing where each row contains a contrast for
which the posterior will be calculated.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_reference_type">reference_type</code></td>
<td>
<p>whether to provide the posterior of the difference or
the ratio between each dose and the reference dose.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_+3A_...">...</code></td>
<td>
<p>additional arguments will throw an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements <code>stats</code> and <code>samples</code>. When using this
function with default settings, <code>samples</code> is NULL and <code>stats</code> is a
dataframe summarizing the posterior samples. <code>stats</code> contains, at a
minimum, the columns &quot;dose&quot;, &quot;.contrast_index&quot;, &quot;(Intercept)&quot;, &quot;value&quot;,
and variables corresponding to the values passed in <code>prob</code> (&quot;2.50%&quot; and
&quot;97.50%&quot; by default). When <code>return_stats</code> is set to <code>FALSE</code>, <code>stats</code> is
NULL. When <code>return_samples</code> is set to <code>TRUE</code>, <code>samples</code> is a dataframe
with the posterior samples for each iteration of the MCMC. The dataframe
will have, at a minimum, the column &quot;iter&quot;, indicating the MCMC iteration,
as well as the columns &quot;dose&quot;, &quot;.contrast_index&quot;, &quot;(Intercept)&quot;, and
&quot;value&quot;. The functions used for each model are defined within the
<code>model_negbin_XYZ()</code> functions and used in the <code>run_mcmc()</code> function.
</p>


<h3>See Also</h3>

<p>Other posterior calculations: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc_bma">posterior.beaver_mcmc_bma</a>()</code>,
<code><a href="#topic+posterior_g_comp">posterior_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi_g_comp">pr_eoi_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi">pr_eoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='posterior.beaver_mcmc_bma'>Posterior Samples from Bayesian Model Averaging</h2><span id='topic+posterior.beaver_mcmc_bma'></span>

<h3>Description</h3>

<p>Calculate posterior quantities of interest using Bayesian model
averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'beaver_mcmc_bma'
posterior(
  x,
  doses = attr(x, "doses"),
  reference_dose = NULL,
  prob = c(0.025, 0.975),
  return_stats = TRUE,
  return_samples = FALSE,
  new_data = NULL,
  contrast = NULL,
  reference_type = c("difference", "ratio"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_x">x</code></td>
<td>
<p>an object output from <code>beaver_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_doses">doses</code></td>
<td>
<p>doses at which to obtain the posterior.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_reference_dose">reference_dose</code></td>
<td>
<p>dose to which to compare as either a difference or
ratio.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_prob">prob</code></td>
<td>
<p>the percentiles of the posterior to calculate for each dose.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_return_stats">return_stats</code></td>
<td>
<p>logical indicating if the posterior mean and quantiles
should be returned.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if posterior mean samples should
be returned.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_new_data">new_data</code></td>
<td>
<p>a dataframe for which the posterior will be calculated for
each observation's covariate values.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_contrast">contrast</code></td>
<td>
<p>a matrix containing where each row contains a contrast for
which the posterior will be calculated.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_reference_type">reference_type</code></td>
<td>
<p>whether to provide the posterior of the difference or
the ratio between each dose and the reference dose.</p>
</td></tr>
<tr><td><code id="posterior.beaver_mcmc_bma_+3A_...">...</code></td>
<td>
<p>additional arguments will throw an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements <code>stats</code> and <code>samples</code>. When using this
function with default settings, <code>samples</code> is NULL and <code>stats</code> is a
dataframe summarizing the posterior samples. <code>stats</code> contains, at a
minimum, the columns &quot;dose&quot;, &quot;.contrast_index&quot;, &quot;(Intercept)&quot;, &quot;value&quot;,
and variables corresponding to the values passed in <code>prob</code> (&quot;2.50%&quot; and
&quot;97.50%&quot; by default). When <code>return_stats</code> is set to <code>FALSE</code>, <code>stats</code> is
NULL. When <code>return_samples</code> is set to <code>TRUE</code>, <code>samples</code> is a dataframe
with the posterior samples for each iteration of the MCMC. The dataframe
will have, at a minimum, the columns &quot;iter&quot; and &quot;model&quot;, indicating the
MCMC iteration and the model that was used in the calculations, as well as
the columns &quot;dose&quot;, &quot;.contrast_index&quot;, &quot;(Intercept)&quot;, and &quot;value&quot;. The
functions used for each model are defined within the <code>model_negbin_XYZ()</code>
functions and used in the <code>beaver_mcmc()</code> function.
</p>


<h3>See Also</h3>

<p>Other posterior calculations: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc">posterior.beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior_g_comp">posterior_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi_g_comp">pr_eoi_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi">pr_eoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='pr_eoi'>Calculate Probability of Meeting Effect of Interest</h2><span id='topic+pr_eoi'></span>

<h3>Description</h3>

<p>Calculate a posterior quantity such as
Pr(trt_arm1 - trt_arm2 &gt; eoi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_eoi(
  x,
  eoi,
  doses = attr(x, "doses"),
  reference_dose = NULL,
  new_data = NULL,
  contrast = NULL,
  reference_type = c("difference", "ratio"),
  direction = c("greater", "less")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_eoi_+3A_x">x</code></td>
<td>
<p>an object output from <code>beaver_mcmc()</code> or (internal function)
<code>run_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_eoi">eoi</code></td>
<td>
<p>effects of interest in the probability equation.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_doses">doses</code></td>
<td>
<p>doses at which to obtain the posterior.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_reference_dose">reference_dose</code></td>
<td>
<p>dose to which to compare as either a difference or
ratio.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_new_data">new_data</code></td>
<td>
<p>a dataframe for which the posterior will be calculated for
each observation's covariate values.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_contrast">contrast</code></td>
<td>
<p>a matrix containing where each row contains a contrast for
which the posterior will be calculated.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_reference_type">reference_type</code></td>
<td>
<p>whether to provide the posterior of the difference or
the ratio between each dose and the reference dose.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_direction">direction</code></td>
<td>
<p>calculate whether the posterior quantity is greater or less
than the eoi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe or tibble with the posterior quantities.
</p>


<h3>See Also</h3>

<p>Other posterior calculations: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc_bma">posterior.beaver_mcmc_bma</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc">posterior.beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior_g_comp">posterior_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi_g_comp">pr_eoi_g_comp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='pr_eoi_g_comp'>Calculate Probability of Meeting Effect of Interest using G-Computation</h2><span id='topic+pr_eoi_g_comp'></span>

<h3>Description</h3>

<p>Calculate a posterior quantity such as
Pr(trt_arm1 - trt_arm2 &gt; eoi) based on the posterior marginal treatment
effect at each dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_eoi_g_comp(
  x,
  eoi,
  doses = attr(x, "doses"),
  reference_dose = NULL,
  new_data = NULL,
  reference_type = c("difference", "ratio"),
  direction = c("greater", "less")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_eoi_g_comp_+3A_x">x</code></td>
<td>
<p>an object output from <code>beaver_mcmc()</code> or (internal function)
<code>run_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_eoi">eoi</code></td>
<td>
<p>effects of interest in the probability equation.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_doses">doses</code></td>
<td>
<p>doses at which to obtain the posterior.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_reference_dose">reference_dose</code></td>
<td>
<p>dose to which to compare as either a difference or
ratio.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_new_data">new_data</code></td>
<td>
<p>a dataframe containing all the variables used in the
covariate adjustments to the model used to obtain <code>x</code>.  Usually this
will be the same dataframe used to fit the model.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_reference_type">reference_type</code></td>
<td>
<p>whether to provide the posterior of the difference or
the ratio between each dose and the reference dose.</p>
</td></tr>
<tr><td><code id="pr_eoi_g_comp_+3A_direction">direction</code></td>
<td>
<p>calculate whether the posterior quantity is greater or less
than the eoi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe or tibble with the posterior quantities.
</p>


<h3>See Also</h3>

<p>Other posterior calculations: 
<code><a href="#topic+beaver_mcmc">beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc_bma">posterior.beaver_mcmc_bma</a>()</code>,
<code><a href="#topic+posterior.beaver_mcmc">posterior.beaver_mcmc</a>()</code>,
<code><a href="#topic+posterior_g_comp">posterior_g_comp</a>()</code>,
<code><a href="#topic+pr_eoi">pr_eoi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The {beaver} package, by definition, performs MCMC for multiple models.
# Even with a small number of chains/burn-ins/samples, a minimally illustrative
# example requires &gt;5s to run.

library(dplyr)

# No covariates----

set.seed(100)

df &lt;- data_negbin_emax(
  n_per_arm = 10,
  doses = 0:3,
  b1 = 0,
  b2 = 2.5,
  b3 = 0.5,
  ps = 0.75
)

df %&gt;%
  group_by(dose) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ 1,
  data = df,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc$w_post

draws &lt;- try(draws(mcmc)) #draws() is intended for single model fits only
draws_emax &lt;- draws(mcmc$models$emax$mcmc)
draws_linear &lt;- draws(mcmc$models$linear$mcmc)
draws_quad &lt;- draws(mcmc$models$quad$mcmc)
draws_exp &lt;- draws(mcmc$models$exp$mcmc)

post &lt;- posterior(
  mcmc,
  contrast = matrix(1, 1, 1),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc,
  eoi = c(5, 8),
  contrast = matrix(1, 1, 1),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp &lt;- posterior_g_comp(
  mcmc,
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc,
  eoi = c(5, 8),
  new_data = df,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc, contrast = matrix(1, 1, 1))

# With covariates----

set.seed(1000)

x &lt;-
  data.frame(
    gender = factor(sample(c("F", "M"), 40, replace = TRUE))
  ) %&gt;%
  model.matrix(~ gender, data = .)

df_cov &lt;-
  data_negbin_emax(
    n_per_arm = 10,
    doses = 0:3,
    b1 = c(0, 0.5),
    b2 = 2.5,
    b3 = 0.5,
    ps = 0.75,
    x = x
  ) %&gt;%
  mutate(
    gender = case_when(
      genderM == 1 ~ "M",
      TRUE ~ "F"
    ),
    gender = factor(gender)
  ) %&gt;%
  select(subject, dose, gender, response)

df_cov %&gt;%
  group_by(dose, gender) %&gt;%
  summarize(
    mean = mean(response),
    se = sd(response) / sqrt(n()),
    .groups = "drop"
  )

mcmc_cov &lt;- beaver_mcmc(
  emax = model_negbin_emax(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  linear = model_negbin_linear(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    w_prior = 1 / 4
  ),
  quad = model_negbin_quad(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 1.5,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  exp = model_negbin_exp(
    mu_b1 = 0,
    sigma_b1 = 10,
    mu_b2 = 0,
    sigma_b2 = 10,
    mu_b3 = 0,
    sigma_b3 = 3,
    w_prior = 1 / 4
  ),
  formula = ~ gender,
  data = df_cov,
  n_iter = 1e2,
  n_chains = 1,
  quiet = TRUE
)

mcmc_cov$w_post

draws_cov &lt;- try(draws(mcmc_cov)) #draws() is intended for single model fits only
draws_cov_emax &lt;- draws(mcmc_cov$models$emax$mcmc)
draws_cov_linear &lt;- draws(mcmc_cov$models$linear$mcmc)
draws_cov_quad &lt;- draws(mcmc_cov$models$quad$mcmc)
draws_cov_exp &lt;- draws(mcmc_cov$models$exp$mcmc)

post_cov &lt;- posterior(
  mcmc_cov,
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  doses = 0:3,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi(
  mcmc_cov,
  eoi = c(5, 8),
  contrast = matrix(c(1, 1, 0, 1), 2, 2),
  reference_dose = 0,
  reference_type = "difference"
)

post_g_comp_cov &lt;- posterior_g_comp(
  mcmc_cov,
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

pr_eoi_g_comp(
  mcmc_cov,
  eoi = c(5, 8),
  new_data = df_cov,
  reference_dose = 0,
  reference_type = "difference"
)

plot(mcmc_cov, new_data = df_cov, type = "g-comp")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+posterior'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>yodel</dt><dd><p><code><a href="yodel.html#topic+posterior">posterior</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
