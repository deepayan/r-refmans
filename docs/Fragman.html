<!DOCTYPE html><html><head><title>Help for package Fragman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Fragman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange.jm'>
<p>Arrange data converted to joinmap code into a joinmap readable file</p></a></li>
<li><a href='#best.layout'><p>complementary tools for layout</p></a></li>
<li><a href='#big.peaks.col'><p>Peak search by first derivatives</p></a></li>
<li><a href='#detect.ladder'><p>Ladder detection by correlation or confidence intervals</p></a></li>
<li><a href='#find.ladder'><p>Ladder detection by correlation or confidence intervals</p></a></li>
<li><a href='#Fragman-package'><p>Fragment analysis and automatic scoring</p></a></li>
<li><a href='#get.scores'><p>complementary tools</p></a></li>
<li><a href='#homo.panel'><p>complementary tools</p></a></li>
<li><a href='#homogenize.to.parentals'><p>complementary tools</p></a></li>
<li><a href='#jm.conv'>
<p>Scores to JoinMap converter</p></a></li>
<li><a href='#ladder.corrector'><p>Ladder corrector attached to R environment</p></a></li>
<li><a href='#ladder.info.attach'><p>Ladder detection and attachment to R environment</p></a></li>
<li><a href='#lapply_pb'><p>complementary tools for Fragman</p></a></li>
<li><a href='#letter.to.jm'>
<p>Letter to JoinMap code converter</p></a></li>
<li><a href='#my.plants'>
<p>Cranberry biparental population</p></a></li>
<li><a href='#num.to.lett'>
<p>Number to Letter code converter</p></a></li>
<li><a href='#overview'><p>Assesing several plants with an overview</p></a></li>
<li><a href='#overview2'><p>Assesing several plants with an overview</p></a></li>
<li><a href='#plot.fsa_stored'><p>plot form fsa files stored with storing.inds</p></a></li>
<li><a href='#pullup'><p>Applying pullup to channels/colors</p></a></li>
<li><a href='#read.abif'><p>Read ABIF formatted files</p></a></li>
<li><a href='#reals'><p>Finding the real peaks</p></a></li>
<li><a href='#saturate'><p>Checking and correcting saturated peaks</p></a></li>
<li><a href='#score.markers'><p>Fragment analysis scoring</p></a></li>
<li><a href='#separate'><p>Separating peaks by a shift window</p></a></li>
<li><a href='#storing.inds'><p>Extracting channel information</p></a></li>
<li><a href='#threshs'><p>Customizing thresholds</p></a></li>
<li><a href='#transfft'><p>Applying the fourier transformation to a data frame</p></a></li>
<li><a href='#transp'><p>Creating color with transparency</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fragment Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanny Covarrubias-Pazaran, Luis Diaz-Garcia, Brandon Schlautman, Walter Salazar, Juan Zalapa.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanny Covarrubias-Pazaran &lt;covarrubiasp@wisc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs fragment analysis using genetic data coming from capillary electrophoresis machines. These are files with FSA extension which stands for FASTA-type file, and .txt files from Beckman CEQ 8000 system, both contain DNA fragment intensities read by machinery. In addition to visualization, it performs automatic scoring of SSRs (Sample Sequence Repeats; a type of genetic marker very common across the genome) and other type of PCR markers (standing for Polymerase Chain Reaction) in biparental populations such as F1, F2, BC (backcross), and diversity panels (collection of genetic diversity).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.wisc.edu">http://www.wisc.edu</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-13 14:19:14 UTC; cova_ruber</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-14 13:00:52 UTC</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
</table>
<hr>
<h2 id='arrange.jm'>
Arrange data converted to joinmap code into a joinmap readable file 
</h2><span id='topic+arrange.jm'></span>

<h3>Description</h3>

<p>This function converts a data frame containing the joinmap code into the readable file for joinmap. This format still needs some extra information, specifically the header indicating the population type, no.loci and no. of individuals, please check file examples included in JoinMap software. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.jm(x, par=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.jm_+3A_x">x</code></td>
<td>
<p>A data frame containing the scores in jm coding.
</p>
</td></tr>
<tr><td><code id="arrange.jm_+3A_par">par</code></td>
<td>
<p>A TRUE/FALSE value indicating if the data returned should include the parents or not, the dafault value is FALSE, indicating that the first 2 individuals will not be included.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a new data frame
</p>

<dl>
<dt>joinmap</dt><dd><p> A new data frame with markers in joinmap readable format</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- data.frame(cbind(a=rep(150, 96), b=c(rep(100,48), rep(150,48)))); xx[1,] &lt;- c(150,150)
xx2 &lt;- cbind(jm.conv(xx), jm.conv(xx), jm.conv(xx))
xx3 &lt;- arrange.jm(xx2, par=FALSE) 
xx3[,1:10]
</code></pre>

<hr>
<h2 id='best.layout'>complementary tools for layout</h2><span id='topic+best.layout'></span>

<h3>Description</h3>

<p>This function just find the best layout fit for a number of plots desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.layout(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.layout_+3A_x">x</code></td>
<td>
<p>A scalar value indicating the number of plots desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details
</p>


<h3>Value</h3>

<p>Returns the best layout
</p>

<dl>
<dt>res</dt><dd><p>the number of rows and columns giving the best fit</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>best.layout(9)
</code></pre>

<hr>
<h2 id='big.peaks.col'>Peak search by first derivatives</h2><span id='topic+big.peaks.col'></span>

<h3>Description</h3>

<p>This function find all peaks by taking the first derivative based on 'rle' function. Is used in different Fragma functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>big.peaks.col(x,tre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="big.peaks.col_+3A_x">x</code></td>
<td>
<p>A vector of heights or intensities</p>
</td></tr>
<tr><td><code id="big.peaks.col_+3A_tre">tre</code></td>
<td>
<p>A scalar value deciding when peaks will be ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>Retuns the biggest peaks for a vector of intensities.
</p>

<dl>
<dt>out</dt><dd><p> a vector of positions where the derivative is zero and therefore a peak was found</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
big.peaks.col(my.plants[[1]][,1],100)#for any color
</code></pre>

<hr>
<h2 id='detect.ladder'>Ladder detection by correlation or confidence intervals</h2><span id='topic+detect.ladder'></span>

<h3>Description</h3>

<p>This function takes a vector of color heights/intensities from the fragment analysis containing the ladder/standard channel, and detects the biggest peaks where the derivative is equal zero and uses the information from the expected weights for the ladder to construct confidence intervals in order to detect the ladder peaks.
</p>
<p>Please! if using the confidence interval method (&quot;ci&quot;), which is NOT the default,  once you have found the best parameters for the arguments to match your ladder using this function, please pass those values to all the posterior functions, making sure the 'dev' argument is passed to the new functions. If using the correlation method (&quot;cor&quot;), don't worry about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
detect.ladder(stored, ind=1, ladder, channel.ladder=dim(stored[[1]])[2],
              ci.upp=1.96, ci.low=1.96, draw=TRUE, dev=50, warn=TRUE, 
              init.thresh=250,sep.index=8, method="cor", avoid=1500, who="sample")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.ladder_+3A_stored">stored</code></td>
<td>
<p>Lis of dataframes obtained by using the <code><a href="#topic+storing.inds">storing.inds</a></code> function.</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_ind">ind</code></td>
<td>
<p>The individual that you wish to analyze for assessing that the ladder was correctly detected.</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_ladder">ladder</code></td>
<td>
<p>Vector containing the expected weights of the dna fragments of the ladder in use</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>A scalar value indicating in which channel or color the ladder was read</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_ci.upp">ci.upp</code></td>
<td>
<p>A scalar value indicating how many standar errors will be used to detect peaks when checking the height of the ladder peaks(upper bound). To be used in the <code><a href="#topic+find.ladder">find.ladder</a></code> function</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_ci.low">ci.low</code></td>
<td>
<p>A scalar value indicating how many standar errors will be used to detect peaks when checking the height of the ladder peaks(lower bound). To be used in the 'find.ladder' function</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_draw">draw</code></td>
<td>
<p>A TRUE/FALSE value indicating if the plot for the ladder found should be printed or not</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_dev">dev</code></td>
<td>
<p>A scalar value indicating the number of indexes to be used as peak separation when deciding the ladder peaks. Some ladders contain dna fragments of very closed weights and modifying this parameter helps to detect them correctly</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_warn">warn</code></td>
<td>
<p>A TRUE/FALSE value indicating if warnings should be provided when detecting the ladder</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_init.thresh">init.thresh</code></td>
<td>
<p>An initial value of color intensity to be used when detecting the ladder, could be really important for the correlation method</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_sep.index">sep.index</code></td>
<td>
<p>A scalar value indicating how many indexes should be allowed to considered a true peak from noisy peaks</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_method">method</code></td>
<td>
<p>An argument indicating one of the 2 methods available; &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_who">who</code></td>
<td>
<p>A name to indicate which sample is being analyzed</p>
</td></tr>
<tr><td><code id="detect.ladder_+3A_avoid">avoid</code></td>
<td>
<p>A scalar value indicating how many indexes should be avoided when the method of correlation fails to find peaks and a random sample will be drawn from the existing peaks. The default is 1500 indexes which will samples peaks avoiding the first 1500 indexes which is usually related to noisy area in some ladders.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The peaks are detected by default using a correlation method bu the user can use confidence intervals if desired.
</p>


<h3>Value</h3>

<p>If parameters are indicated correctly the function returns:
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.ladder &lt;- c(120, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
# looking at the first individual
detect.ladder(stored=my.plants, ind=1, ladder=my.ladder)
</code></pre>

<hr>
<h2 id='find.ladder'>Ladder detection by correlation or confidence intervals</h2><span id='topic+find.ladder'></span>

<h3>Description</h3>

<p>This function takes a vector of color heights/intensities from the fragment analysis containing the ladder/standard channel, and detects the biggest peaks where the derivative is equal zero and uses the information from the expected weights for the ladder to construct confidence intervals in order to detect the ladder peaks.
</p>
<p>Please! if using the confidence interval method (&quot;ci&quot;), which is not the default, once you have found the best parameters for the arguments to match your ladder using this function, please pass those values to all the posterior functions, please make sure the 'dev' argument is passed to the new functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.ladder(x, ladder, draw=TRUE, dev=50, warn=TRUE, init.thresh=NULL, 
            sep.index=8, method=NULL, reducing=NULL, who="sample", 
            attempt=10, cex.title=0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.ladder_+3A_x">x</code></td>
<td>
<p>Vector of heights from the ladder channel. See example to see how to access to it.</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_ladder">ladder</code></td>
<td>
<p>Vector containing the expected weights of the dna fragments of the ladder in use</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_draw">draw</code></td>
<td>
<p>A TRUE/FALSE value indicating if the plot for the ladder found should be printed or not</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_dev">dev</code></td>
<td>
<p>A scalar value indicating the number of indexes to be used as peak separation when deciding the ladder peaks. Some ladders contain dna fragments of very closed weights and modifying this parameter helps to detect them correctly</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_warn">warn</code></td>
<td>
<p>A TRUE/FALSE value indicating if warnings should be provided when detecting the ladder</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_init.thresh">init.thresh</code></td>
<td>
<p>An initial value of color intensity to be used when detecting the ladder</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_sep.index">sep.index</code></td>
<td>
<p>A scalar value indicating how many indexes should be allowed to considered a true peak from noisy peaks</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_method">method</code></td>
<td>
<p>An argument indicating one of the 2 methods available; &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_who">who</code></td>
<td>
<p>A name to indicate which sample is being analyzed</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_attempt">attempt</code></td>
<td>
<p>A scalar value indicating how many attempts should be made to find the real ladder peaks. By default is 7 attempts, which means that will try to build the model assuming that the first peak found in the ladder is the corresponding first peak of the expected ladder, then moves to the 2nd peak until the 7th and the seven models are compared picking the most likely model based on the R2 value for each of the models.</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_reducing">reducing</code></td>
<td>
<p>A vector of values to reduce the search of peaks to certain indexes in the x axis. Default is NULL so it looks for all peaks for matching the ladder.</p>
</td></tr>
<tr><td><code id="find.ladder_+3A_cex.title">cex.title</code></td>
<td>
<p>A scalar value indicating how big the title (name of the sample) in the plot should be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We have implemented 3 methods for sizing the ladder, each with their advantages and disadvantages. The default method named &quot;red&quot; which stands for &quot;reduction&quot; detect the region where peaks exist (in indexes) in the ladder channel and assumes that your ladder should have some equivalence in indexes and creates an 'expected ladder', then the putative ladder moves along the peak region and correlations and squared distances to the closest peaks are calculated. We have define the coefficient of similarity (CS) as cor(x,y)/var(z), where:
</p>
<p>cor(x,y) are the correlations between expected and observed peaks, and
var(z)  is the sum of squares between the differences of expected and observed peaks.
</p>
<p>This value usually let us identify the most likely peaks and then all possible combinations for those peaks are computed followed by exhaustive correlations of those combinations with the actual ladder. The highest correlation usually points to the right peaks, which is selected.
</p>
<p>In addition the method &quot;cor&quot; is the previous version to &quot;red&quot; which doesn't reduce the search of peaks and computes all possible combinations of peaks from the beggining, with the drawback that slows down the detection process especially when the ladder intensities are low and noisy peaks exist in abundance.
</p>
<p>The last method that has been superseded by the previous 2 is the &quot;ci&quot; method based on confidence intervals, which assumes that real ladder peaks have more or less the same intensity and a they can be found by finding the median intensity and computing a 90 percent confidence interval to find the rest of the peaks. This method has been proved to fail when the first condition is broken and ladder have real peaks with intensities greater than the expected.
</p>


<h3>Value</h3>

<p>If parameters are indicated correctly the function returns:
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
find.ladder(my.plants[[1]][,4], ladder=my.ladder)
</code></pre>

<hr>
<h2 id='Fragman-package'>Fragment analysis and automatic scoring</h2><span id='topic+Fragman'></span>

<h3>Description</h3>

<p>Fragman is a package designed for Fragment analysis and automatic scoring of biparental populations (such as F1, F2, BC types) and populations for diversity studies. The program is designed to read files with FSA extension (which stands for FASTA-type file and contains lectures for DNA fragments), and .txt files from Beckman CEQ 8000 system, and extract the DNA intensities from the channels/colors where they are located, based on ABi machine plattforms to perform sizing and allele scoring. 
</p>
<p>The core of the package and the workflow of the fragment analysis rely in the following 4 functions; 
</p>
<p>1) <code><a href="#topic+storing.inds">storing.inds</a></code>(function in charge of reading the FSA or txt(CQS) files and storing them with a list structure)
</p>
<p>2) <code><a href="#topic+ladder.info.attach">ladder.info.attach</a></code> (uses the information read from the FSA files and a vector containing the ladder information (DNA size of the fragments) and matches the peaks from the channel where the ladder was run with the DNA sizes for all samples. Then loads such information in the R environment for the use of posterior functions)
</p>
<p>3) <code><a href="#topic+overview2">overview2</a></code> (create friendly plots for any number of individuals specified  and can be used to design panels (<code><a href="#topic+overview2">overview2</a></code>) for posterior automatic scoring (like licensed software does), or make manual scoring (<code><a href="#topic+overview">overview</a></code>) of individuals such as parents of biparental populations or diversity populations)
</p>
<p>4) The <code><a href="#topic+score.markers">score.markers</a></code> (function score the alleles by finding the peaks provided in the panel (if provided), otherwise returns all peaks present in the channel). Thisfinal function can be automatized if several markers are located in the same channel by creating lists of panels taking advantage of R capabilities and data structures.
</p>
<p>** Sometimes during the ladder sizing process some samples can go wrong for several reasons related to the sample quality (low intensity in ladder channel, extreme number of noisy peaks, etc.), because of that we have introduced <code><a href="#topic+ladder.corrector">ladder.corrector</a></code> function which allows the user to correct the bad samples by clicking over the real peaks, by default the <code><a href="#topic+ladder.info.attach">ladder.info.attach</a></code> function returns the names of the samples that had a low correlation with the expected peaks.
</p>
<p>When automatic scoring is not desired the function <code><a href="#topic+overview">overview</a></code> can be used for getting an interactive session and click over the peaks (using the <code><a href="graphics.html#topic+locator">locator</a></code> function) in order to get the allele sizes.
</p>


<h3>Contact</h3>

<p>Feel free to contact us with questions and improvement suggestions at:
</p>
<p>covarrubiasp@wis.edu
</p>
<p>Just send a sample file with your question to recreate the issue or bug reported along with vector for your ladder.
</p>


<h3>Citation</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran, Luis Diaz-Garcia, Brandon Schlautman, Walter Salazar, Juan Zalapa.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>See Also</h3>

<p>http://cggl.horticulture.wisc.edu/home-page/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ================================= ##
## ================================= ##
## Fragment analysis requires 
## 1) loading your data
## 2) matching your ladder
## 3) define a panel for scoring
## 4) score the samples
## ================================= ##
## ================================= ##

#####################
## 1) Load your data
#####################

### you would use something like:
# folder &lt;- "~/myfolder"
# my.plants &lt;- storing.inds(folder)
### here we just load our sample data and use the first 2 plants

?my.plants
data(my.plants)
my.plants &lt;- my.plants[1:2]
class(my.plants) &lt;- "fsa_stored"
# plot(my.plants) # to visualize the raw data

#######################
## 2) Match your ladder
#######################

### create a vector indicating the sizes of your ladder and do the match

my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
ladder.info.attach(stored=my.plants, ladder=my.ladder)

### matching your ladder is a critical step and should only happen once per batch of 
### samples read

###****************************************************************************************###
### OPTIONAL:
### If the ladder.info attach function detects some bad samples 
### that you can correct them manually using
### the ladder.corrector() function
### For example to correct one sample in the previous data
### ladder.corrector(stored=my.plants, 
#to.correct="FHN152-CPN01_01A_GH1x35_152-148-209_717-704-793_367-382-381.fsa", 
#ladder=my.ladder)
###****************************************************************************************###

#######################
## 3) Define a panel
#######################

### In fragment analysis you usually design a panel where you indicate
### which peaks are real. You may use the overview2 function which plots all the
### plants in the channel you want in the base pair range you want

overview2(my.inds=my.plants, channel = 2:3, ladder=my.ladder, init.thresh=5000)

### You can click on the peaks you think are real, given that the ones
### suggested by the program may not be correct. This can be done by using the 
### 'locator' function and press 'Esc' when you're done, i.e.:
# my.panel &lt;- locator(type="p", pch=20, col="red")$x
### That way you can click over the peaks and get the sizes
### in base pairs stored in a vector named my.panel

### Just for demonstration purposes I will use the suggested peaks by 
### the program using overview2, which will return a vector with 
### expected DNA sizes to be used in the next step for scoring
### we'll do it in the 160-190 bp region

my.panel &lt;- overview2(my.inds=my.plants, channel = 3, 
                    ladder=my.ladder, init.thresh=7000, 
                    xlim=c(160,190)); my.panel

##########################
## 4) Score the samples
##########################

### When a panel is created is time to score the samples by providing the initial
### data we read, the ladder vector, the panel vector, and our specifications
### of channel to score (other arguments are available)

### Here we will score our samples for channel 3 with our panel created previously

res &lt;- score.markers(my.inds=my.plants, channel = 3, panel=my.panel$channel_3,
                ladder=my.ladder, electro=FALSE)

### Check the plots and make sure they were scored correctly. In case some samples 
### are wrong you might want to use the locator function again and figure out 
### the size of your peaks. To extract your peaks in a data.frame do the following:

final.results &lt;- get.scores(res)
final.results 
</code></pre>

<hr>
<h2 id='get.scores'>complementary tools</h2><span id='topic+get.scores'></span>

<h3>Description</h3>

<p>This function extracts the information from auto.score and score.easy functions and fits everything in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.scores(my.scores, mark = "mark")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.scores_+3A_my.scores">my.scores</code></td>
<td>
<p>List of individuals which contains at the same time a list of positions, heights and weights for the fragment analysis</p>
</td></tr>
<tr><td><code id="get.scores_+3A_mark">mark</code></td>
<td>
<p>A vector of names of the markers scored in the panel or the parents</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nomajor details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a data frame containing
</p>

<dl>
<dt>$da</dt><dd><p>A dataframe containing the ssr calls</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here "a" is a similar ouptput to the `score.easy` function
par1 &lt;- list(pos=c(3100, 3240), hei=c(22917,20563), wei=c(202,212))
par2 &lt;- list(pos=c(3100, 3240), hei=c(22917,20563), wei=c(202,214))
a &lt;- list(i1=par1, i2=par2)
get.scores(a)
</code></pre>

<hr>
<h2 id='homo.panel'>complementary tools</h2><span id='topic+homo.panel'></span>

<h3>Description</h3>

<p>This functions takes a list of positions, heights and weights for ssr calls of a certain plant and uses panel information and a window to homogenize the weights of base pairs to the panel calls provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homo.panel(x, panel, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homo.panel_+3A_x">x</code></td>
<td>
<p>list of positions, heights and weights</p>
</td></tr>
<tr><td><code id="homo.panel_+3A_panel">panel</code></td>
<td>
<p>different dna sizes usually obtained by using overview and locator functions</p>
</td></tr>
<tr><td><code id="homo.panel_+3A_window">window</code></td>
<td>
<p>window in base pairs indicating when should be considered the same panel allele</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the panel provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#No example provided, internally working to round to the closest parent ssr call.
x &lt;- 1:10

</code></pre>

<hr>
<h2 id='homogenize.to.parentals'>complementary tools</h2><span id='topic+homogenize.to.parentals'></span>

<h3>Description</h3>

<p>This functions takes a list of positions, heights and weights for ssr calls of a certain plant and uses parental information and a window to homogenize to the parent calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogenize.to.parentals(x, parents, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogenize.to.parentals_+3A_x">x</code></td>
<td>
<p>list of positions, heights and weights</p>
</td></tr>
<tr><td><code id="homogenize.to.parentals_+3A_parents">parents</code></td>
<td>
<p>different parental calls</p>
</td></tr>
<tr><td><code id="homogenize.to.parentals_+3A_window">window</code></td>
<td>
<p>window in base pairs indicating when should be considered the same allele</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#No example provided, internally working to round to the closest parent ssr call.
x &lt;- 1:10

</code></pre>

<hr>
<h2 id='jm.conv'>
Scores to JoinMap converter
</h2><span id='topic+jm.conv'></span>

<h3>Description</h3>

<p>This function converts a data frame containing the scores from score.easy to a new data frame with joinmap calls. The parents need to be provided in the first and second row. Currently only works for CP type of crosses. From CP type to F2 and BC2 is straight forward.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jm.conv(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jm.conv_+3A_a">a</code></td>
<td>
<p>A data frame containing the scores from score.easy function extracted from get.scores function containing the parental calls in the first 2 rows.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a new data frame
</p>

<dl>
<dt>res</dt><dd><p> A new data frame with markers in joinmap format</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- data.frame(cbind(a=rep(150, 96), b=c(rep(100,48), rep(150,48))))
jm.conv(xx)
# try using apply to a dataframe
</code></pre>

<hr>
<h2 id='ladder.corrector'>Ladder corrector attached to R environment</h2><span id='topic+ladder.corrector'></span>

<h3>Description</h3>

<p>This function was designed to correct manually samples that could not be correctly detected by the <code><a href="#topic+ladder.info.attach">ladder.info.attach</a></code> function and allows the user to select manually the peaks he knows are the correct peaks. This function uses the output of the <code><a href="#topic+ladder.info.attach">ladder.info.attach</a></code> function which is basically a vector with the names of the samples that were too dificult for the algorithm to find. The console will draw a plot and will ask the user to click over the peaks expected for a ladder provided, once the user is done should press the 'esc' key and continue to the next sample. This process is repeated until the all samples with the names provided are adjusted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladder.corrector(stored, to.correct, ladder, 
      thresh=200, env = parent.frame(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladder.corrector_+3A_stored">stored</code></td>
<td>
<p>List with the channels information from the individuals specified, usually coming from the <code><a href="#topic+storing.inds">storing.inds</a></code> function output.</p>
</td></tr>
<tr><td><code id="ladder.corrector_+3A_to.correct">to.correct</code></td>
<td>
<p>Vector containing the names ofthe samples to be corrected and usually the output of the <code><a href="#topic+ladder.info.attach">ladder.info.attach</a></code> function.</p>
</td></tr>
<tr><td><code id="ladder.corrector_+3A_ladder">ladder</code></td>
<td>
<p>Vector containing the expected weights of the dna fragments of the ladder in use.</p>
</td></tr>
<tr><td><code id="ladder.corrector_+3A_thresh">thresh</code></td>
<td>
<p>A scalar value indicating the minimum value in RFUs to look for peaks to match the user-selected peaks with the program recognized peaks.</p>
</td></tr>
<tr><td><code id="ladder.corrector_+3A_env">env</code></td>
<td>
<p> this is used to detect the environment of the user and load the result in the same environment.</p>
</td></tr>
<tr><td><code id="ladder.corrector_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once the user has selected the right peaks the function will fix the ladder and attach such information to the R environment.
</p>


<h3>Value</h3>

<p>This function does not produce any output.
</p>

<dl>
<dt>$data</dt><dd><p>the program will attach the information to the R environment</p>
</dd>
</dl>



<h3>References</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.plants &lt;- my.plants[1:2]
my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
ladder.info.attach(stored=my.plants, ladder=my.ladder, ladd.init.thresh=300)
## now if something goes wrong use the corrector:
#ladder.corrector(stored=my.plants, 
#to.correct="FHN152-CPN01_01A_GH1x35_152-148-209_717-704-793_367-382-381.fsa", 
#ladder=my.ladder)
</code></pre>

<hr>
<h2 id='ladder.info.attach'>Ladder detection and attachment to R environment</h2><span id='topic+ladder.info.attach'></span>

<h3>Description</h3>

<p>This function uses the information stored by the <code><a href="#topic+storing.inds">storing.inds</a></code> function and a vector specifying the ladder/standard and finds the real peaks corresponding to the expected weights. The user may use this function to be able to load the ladder information in the global environment of R, so when using the <code><a href="#topic+overview">overview</a></code> or <code><a href="#topic+score.markers">score.markers</a></code> functions calculations will be performed faster, if the function is not used the program will calculate the ladder information each time <code><a href="#topic+overview">overview</a></code> or <code><a href="#topic+score.markers">score.markers</a></code> functions are used. 
</p>
<p>NOTE: THE STEP OF MATCHING THE LADDER WITH YOUR SAMPLES USING THE &lsquo;ladder.info.attach' FUNCTION IS CRITICAL. IF YOU HAVE ANY PROBLEM TRY MODIFYING THE ARGUMENT &rsquo;method', WITH THE 2 MOST EFFECTIVE METHODS method=&quot;iter&quot; OR method=&quot;iter2&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladder.info.attach(stored, ladder, channel.ladder=NULL, 
                  method="iter2", ladd.init.thresh=NULL, 
                  env = parent.frame(), prog=TRUE, 
                  draw=TRUE, attempt=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladder.info.attach_+3A_stored">stored</code></td>
<td>
<p>List with the channels information from the individuals specified, usually coming from the <code><a href="#topic+storing.inds">storing.inds</a></code> function output.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_ladder">ladder</code></td>
<td>
<p>Vector containing the expected weights of the dna fragments of the ladder in use.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>A scalar value indicating in which channel or color the ladder was read</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_method">method</code></td>
<td>
<p>An argument indicating one of the methods available; &quot;iter&quot; makes an iterative procedure to find the ladder, &quot;iter2&quot; the same but backwards, &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments. The default allows the program to pick among &quot;iter&quot; and &quot;iter2&quot;. Older methods have been depreciated.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_ladd.init.thresh">ladd.init.thresh</code></td>
<td>
<p> A value of intensity to detect peaks in the internal use of the <code><a href="#topic+find.ladder">find.ladder</a></code> function. We recommend not to deal to much with it unless you identified special situations with your ladder</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_env">env</code></td>
<td>
<p> this is used to detect the environment of the user and load the result in the same environment.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_prog">prog</code></td>
<td>
<p> A TRUE/FALSE value indicating if a progress bar should be drawn while processing the samples in order to assess the time it takes to find the ladder. The dafault value is TRUE but usually this makes the process slower. Please feel free to set it equal FALSE if the number of samples is quite large and speed is a concern.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_draw">draw</code></td>
<td>
<p> A TRUE/FALSE value indicating if a plot showing the peaks matched with your ladder should be drawn. The dafault value is FALSE to avoid extra delay. Please feel free to set it equal TRUE if you prefer to assess the sizing process.</p>
</td></tr>
<tr><td><code id="ladder.info.attach_+3A_attempt">attempt</code></td>
<td>
<p>A scalar value indicating how many attempts should be made to find the real ladder peaks when using the &quot;iter&quot; and &quot;iter2&quot; methods. By default is 7 attempts, which means that will try to build the model assuming that the first peak found in the ladder is the corresponding first peak of the expected ladder, then moves to the 2nd peak until the 7th and the seven models are compared picking the most likely model based on the R2 value for each of the models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method &quot;ci&quot; has been depreciated, currently the method &quot;iter2&quot; is the default and uses the ladder provided and observed peaks to match them using an iterative procedure based on least squares.
</p>


<h3>Value</h3>

<p>If parameters are indicated correctly the function returns:
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.plants &lt;- my.plants[1:2]
my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
ladder.info.attach(stored=my.plants, ladder=my.ladder)
</code></pre>

<hr>
<h2 id='lapply_pb'>complementary tools for Fragman</h2><span id='topic+lapply_pb'></span>

<h3>Description</h3>

<p>This function is a wrapper of lapply function that allows the drawing of a progress bar to assess the speed of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_pb (X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapply_pb_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an expression object. See see <code><a href="base.html#topic+lapply">lapply</a></code>.</p>
</td></tr>
<tr><td><code id="lapply_pb_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each element of X: see <code><a href="base.html#topic+lapply">lapply</a></code>.</p>
</td></tr>
<tr><td><code id="lapply_pb_+3A_...">...</code></td>
<td>
<p>passes another arguments to the typical lapply function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details
</p>


<h3>Value</h3>

<p>Performs lapply drawing a progress bar
</p>

<dl>
<dt>res</dt><dd><p>the same result than using lapply</p>
</dd>
</dl>



<h3>References</h3>

<p>See see <code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- sapply(1:200, function(x) list(rnorm(1000)))
lapply_pb(l, mean)
</code></pre>

<hr>
<h2 id='letter.to.jm'>
Letter to JoinMap code converter
</h2><span id='topic+letter.to.jm'></span>

<h3>Description</h3>

<p>This function converts a vector of ssr calls in letter format to joinmap code using information from mother and father provided in first and second row respectively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>letter.to.jm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="letter.to.jm_+3A_x">x</code></td>
<td>
<p>A vector of ssr calls in letter format or snp types, mother and father of the population should be in 1st and 2nd position respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If numeric data exists first needs to be converted to letter code in order to use this function.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>$y</dt><dd><p> A vector with ssr calls in joinmap format</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- data.frame(cbind(a=rep(150, 96), b=c(rep(100,48), rep(150,48))))
xx1 &lt;- num.to.lett(xx)
letter.to.jm(unlist(xx1))
# try using apply to a dataframe
</code></pre>

<hr>
<h2 id='my.plants'>
Cranberry biparental population
</h2><span id='topic+my.plants'></span>

<h3>Description</h3>

<p>This dataset are 60 individuals from a progeny coming from the cross of 2 cranberry plants. Six SSR markers were run, 2 in the first channel (blue), 2 in the second channel (green), 2 in the third channel (yellow) and the Roxtrash375 ladder was run in the fourth channel (red). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("my.plants")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;my.plants&quot;
</p>


<h3>Details</h3>

<p>The data is basically the raw FSA files coming from the ABi machine. No more details for this data.
</p>


<h3>Source</h3>

<p>This data was generated by the Cranberry Genomics Lab.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragma: An R package for fragment analysis. http://horticulture.wisc.edu/cggl/ZalapaLab/People.html. 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
## look at the list structure
str(my.plants) 
</code></pre>

<hr>
<h2 id='num.to.lett'>
Number to Letter code converter
</h2><span id='topic+num.to.lett'></span>

<h3>Description</h3>

<p>This function converts dataframes with rounded calls (numeric format in 2 cells), to letter format based on the GBS pipeline developed by Elshire et al. (2011) which can be used as intermediate step to transform to joinmap and Onemap formats, it requires mother and father in first and second row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.to.lett(xx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.to.lett_+3A_xx">xx</code></td>
<td>
<p>matrix with numbers, every 2 columns is a marker and each row is an individual, parents are located in the first 2 rows</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>xx2</dt><dd><p> matrix coded in letter format where each column is a marker and each row is an individual</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- data.frame(cbind(a=rep(150, 96), b=c(rep(100,48), rep(150,48))))
num.to.lett(xx)
</code></pre>

<hr>
<h2 id='overview'>Assesing several plants with an overview</h2><span id='topic+overview'></span>

<h3>Description</h3>

<p>This function uses information from the FSA files read from <code><a href="#topic+storing.inds">storing.inds</a></code> function and creates a plot to assess graphically the peaks of several plants in certain channel in order to score manually or assess the parental fragments in the case of biparentla ppulations. If you desire to create a panel you may want to take a look at <code><a href="#topic+overview2">overview2</a></code>. The function contains several defaults in most of the arguments, please check arguments but in general.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview(my.inds, channel = 1, n.inds = c(1:length(my.inds)), 
        xlimi=c(min(ladder),max(ladder)), ladder, channel.ladder=dim(my.inds[[1]])[2], 
        ploidy=2, dev=50, method="iter", 
        init.thresh=200, ladd.init.thresh=200, warn=TRUE, my.palette=NULL,
        env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overview_+3A_my.inds">my.inds</code></td>
<td>
<p>List with the channels information from the individuals specified, usually coming from the <code><a href="#topic+storing.inds">storing.inds</a></code> function output</p>
</td></tr>
<tr><td><code id="overview_+3A_channel">channel</code></td>
<td>
<p>The channel you wish to analyze, usually 1 is blue, 2 is green, 3 is yellow, 4 is red and so on</p>
</td></tr>
<tr><td><code id="overview_+3A_n.inds">n.inds</code></td>
<td>
<p>Vector specifying the plants to be scored</p>
</td></tr>
<tr><td><code id="overview_+3A_xlimi">xlimi</code></td>
<td>
<p>A vector containing the base pair interval where the plot should be drawn</p>
</td></tr>
<tr><td><code id="overview_+3A_ladder">ladder</code></td>
<td>
<p>A vector containing the expected weights for the ladder peaks that will be found the using the <code><a href="#topic+find.ladder">find.ladder</a></code> function</p>
</td></tr>
<tr><td><code id="overview_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>A scalar value indicating in which channel or color the ladder was read</p>
</td></tr>
<tr><td><code id="overview_+3A_ploidy">ploidy</code></td>
<td>
<p>A scalar value indicating the ploidy of the organism to be scored</p>
</td></tr>
<tr><td><code id="overview_+3A_dev">dev</code></td>
<td>
<p>A scalar value indicating the number of indexes to be used as peak separation when deciding the ladder peaks, for more details check <code><a href="#topic+find.ladder">find.ladder</a></code> function</p>
</td></tr>
<tr><td><code id="overview_+3A_method">method</code></td>
<td>
<p>An argument indicating one of the 2 methods available; &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments</p>
</td></tr>
<tr><td><code id="overview_+3A_init.thresh">init.thresh</code></td>
<td>
<p> An initial value of intensity to detect peaks. We recommend not to deal to much with unless you have highly controlled dna concentrations in your experiment</p>
</td></tr>
<tr><td><code id="overview_+3A_ladd.init.thresh">ladd.init.thresh</code></td>
<td>
<p> A value of intensity to detect peaks in the internal use of the <code><a href="#topic+find.ladder">find.ladder</a></code> function. We recommend not to deal to much with it unless you identified special situations with your ladder</p>
</td></tr>
<tr><td><code id="overview_+3A_warn">warn</code></td>
<td>
<p>A TRUE/FALSE value indicating if warnings should be provided when detecting the ladder</p>
</td></tr>
<tr><td><code id="overview_+3A_my.palette">my.palette</code></td>
<td>
<p>A character vector with the colors to be used when drawing the RFU plots. If NULL it will use the programmed palette.</p>
</td></tr>
<tr><td><code id="overview_+3A_env">env</code></td>
<td>
<p> this is used to detect the environment of the user and load the result in the same environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If rarguments are correct the function returns a list containing
</p>

<dl>
<dt>$plot</dt><dd><p> Returns a plot joining the channel for the plants specified for the color desired and the peaks found by the function using the parameters specified</p>
</dd>
<dt>$nana</dt><dd><p> Returns a vector with the names of the plants specified in the function</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.plants &lt;- my.plants[1:10]
my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
overview(my.inds=my.plants, channel = 1, n.inds = c(1:5), ladder=my.ladder, xlim=c(200,220))
# now use:
# locator(type="p", pch=20, col="red")$x
# to click over the peaks and get the sizes in base pairs
# when you are done make sure you press the "Esc" key, 
# do not push the stop button, some versions of R usually crash 
# by stopping instead of pressing 'Esc'.
</code></pre>

<hr>
<h2 id='overview2'>Assesing several plants with an overview</h2><span id='topic+overview2'></span>

<h3>Description</h3>

<p>This function uses information from the FSA files read from <code><a href="#topic+storing.inds">storing.inds</a></code> function and creates an overlapping plot to assess graphically the peaks of several plants in certain channel in order to create a panel for the scoring functions <code><a href="#topic+score.markers">score.markers</a></code>. The function contains several defaults in most of the arguments, please check arguments but in general you only need the first 4 arguments to create a panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview2(my.inds, channel = 1, ladder, xlim = NULL, ylim = NULL, 
        n.inds = NULL, channel.ladder = NULL, ploidy = 2, 
        method="iter2", init.thresh=NULL, ladd.init.thresh=200, 
        lwd=.25, warn=TRUE, min.panel=100, suggested=TRUE, 
        env = parent.frame(), my.palette=NULL, verbose=TRUE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overview2_+3A_my.inds">my.inds</code></td>
<td>
<p>List with the channels information from the individuals specified, usually coming from the <code><a href="#topic+storing.inds">storing.inds</a></code> function output</p>
</td></tr>
<tr><td><code id="overview2_+3A_channel">channel</code></td>
<td>
<p>The channel/color you wish to analyze, usually 1 is blue, 2 is green, 3 is yellow, 4 is red and so on</p>
</td></tr>
<tr><td><code id="overview2_+3A_ladder">ladder</code></td>
<td>
<p>A vector containing the expected weights for the ladder peaks that will be found the using the <code><a href="#topic+find.ladder">find.ladder</a></code> function</p>
</td></tr>
<tr><td><code id="overview2_+3A_xlim">xlim</code></td>
<td>
<p>A vector containing the base pair interval where the plot should be drawn</p>
</td></tr>
<tr><td><code id="overview2_+3A_ylim">ylim</code></td>
<td>
<p>A vector containing the intensity interval where the plot should be drawn</p>
</td></tr>
<tr><td><code id="overview2_+3A_n.inds">n.inds</code></td>
<td>
<p>Vector specifying the plants to be scored</p>
</td></tr>
<tr><td><code id="overview2_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>A scalar value indicating in which channel or color the ladder was read</p>
</td></tr>
<tr><td><code id="overview2_+3A_ploidy">ploidy</code></td>
<td>
<p>A scalar value indicating the ploidy of the organism to be scored</p>
</td></tr>
<tr><td><code id="overview2_+3A_method">method</code></td>
<td>
<p>An argument indicating one of the 2 methods available; &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments</p>
</td></tr>
<tr><td><code id="overview2_+3A_init.thresh">init.thresh</code></td>
<td>
<p> An initial value of intensity to detect peaks. We recommend not to deal to much with unless you have highly controlled dna concentrations in your experiment</p>
</td></tr>
<tr><td><code id="overview2_+3A_ladd.init.thresh">ladd.init.thresh</code></td>
<td>
<p> A value of intensity to detect peaks in the internal use of the <code><a href="#topic+find.ladder">find.ladder</a></code> function. We recommend not to deal to much with it unless you identified special situations with your ladder</p>
</td></tr>
<tr><td><code id="overview2_+3A_lwd">lwd</code></td>
<td>
<p> The width of the line</p>
</td></tr>
<tr><td><code id="overview2_+3A_warn">warn</code></td>
<td>
<p>A TRUE/FALSE value indicating if warnings should be provided when detecting the ladder</p>
</td></tr>
<tr><td><code id="overview2_+3A_min.panel">min.panel</code></td>
<td>
<p>A scalar value indicating which peak values should be ignored when creating a panel. If 'xlim' values are specified the 'min.panel' value is ignored and instead the panel peaks provided by the program are based in the region where you are zooming in.</p>
</td></tr>
<tr><td><code id="overview2_+3A_suggested">suggested</code></td>
<td>
<p> a TRUE/FALSE value statement declaring if you want the program to return suggested peaks for your panel. The default is TRUE but can be anoying if the program draws too many peaks.</p>
</td></tr>
<tr><td><code id="overview2_+3A_env">env</code></td>
<td>
<p> this is used to detect the environment of the user and load the result in the same environment.</p>
</td></tr>
<tr><td><code id="overview2_+3A_my.palette">my.palette</code></td>
<td>
<p>A character vector with the colors to be used when drawing the RFU plots. If NULL it will use the programmed palette.</p>
</td></tr>
<tr><td><code id="overview2_+3A_verbose">verbose</code></td>
<td>
<p>A TRUE/FALSE statement indicating if the function should return informative messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If rarguments are correct the function returns a list containing
</p>

<dl>
<dt>$plot</dt><dd><p> Returns a plot joining the channel for the plants specified for the color desired and the peaks found by the function using the parameters specified</p>
</dd>
<dt>$nana</dt><dd><p> Returns a vector with the names of the plants specified in the function</p>
</dd>
</dl>



<h3>References</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
my.plants &lt;- my.plants[1]
my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
overview2(my.inds=my.plants, channel = 1, ladder=my.ladder, lwd=1)
# now use:
# my.panel &lt;- locator(type="p", pch=20, col="red")$x
# to click over the peaks and get the sizes in base pairs
# when you are done make sure you press the "Esc" key, do not push the stop button

## to look at many channels at the same time you 
## can use the par(new=TRUE) and a for loop

for(u in 1:4){
  overview2(my.inds=my.plants, channel = u, ladder=my.ladder, lwd=1,
            xlim=c(240,350), ylim=c(0,30000))
  par(new=TRUE)
}

</code></pre>

<hr>
<h2 id='plot.fsa_stored'>plot form fsa files stored with storing.inds</h2><span id='topic+plot.fsa_stored'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"fsa_stored"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsa_stored'
plot(x, lay=c(2,1), channel=NULL, cex.legend=.5, ncol.legend=4,lims=NULL, color=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fsa_stored_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fsa_stored"</code></p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_lay">lay</code></td>
<td>
<p>layout for the numberof plots to visualize.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_channel">channel</code></td>
<td>
<p>if preferred a single channel can be specified.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_cex.legend">cex.legend</code></td>
<td>
<p>value of the size of the legend.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>number of columns to divide the legend.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_lims">lims</code></td>
<td>
<p>equivalen to ylim argument in plot, xlim still can be used.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_color">color</code></td>
<td>
<p>specific colors to use in case the user don't want the default palete.</p>
</td></tr>
<tr><td><code id="plot.fsa_stored_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias <a href="mailto:covarrubiasp@wisc.edu">covarrubiasp@wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Fragman">Fragman</a></code></p>

<hr>
<h2 id='pullup'>Applying pullup to channels/colors</h2><span id='topic+pullup'></span>

<h3>Description</h3>

<p>This function takes a matrix of DNA intensities and merge all the channels (columns) to identify overall peaks and then creates a window moving from peak to peak looking for the channel where this peak is real and adjust the intensities in the other channels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullup(mati, plotting=FALSE, channel=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullup_+3A_mati">mati</code></td>
<td>
<p> matrix of intensities where each column is a channel/color for a given sample.</p>
</td></tr>
<tr><td><code id="pullup_+3A_plotting">plotting</code></td>
<td>
<p> a TRUE/FALSE value indicating if the results from adjusting the intensities should be drawn or not.</p>
</td></tr>
<tr><td><code id="pullup_+3A_channel">channel</code></td>
<td>
<p> a numeric value indicating which of the channles/color (column) allocates the ladder intensties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns:
</p>

<dl>
<dt>mati</dt><dd><p> A new matrix of DNA intensities corrected for overlapping of wavelenth readings in different channels.</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
layout(matrix(1:2,2,1))
# without pull up adjustment
plot(my.plants[[1]][,1], type="l", col="blue", xlim=c(2750,2850))
lines(my.plants[[1]][,2], col="green")
lines(my.plants[[1]][,3], col="gold")
## adjusted
yy &lt;- pullup(my.plants[[1]])
plot(yy[,1], type="l", col="blue", xlim=c(2750,2850))
lines(yy[,2], col="green")
lines(yy[,3], col="gold")
# general view
yy1 &lt;- pullup(my.plants[[1]], plotting=TRUE)
</code></pre>

<hr>
<h2 id='read.abif'>Read ABIF formatted files</h2><span id='topic+read.abif'></span>

<h3>Description</h3>

<p>ABIF stands for Applied Biosystem Inc. Format, a binary fromat modeled after TIFF format.
Corresponding files usually have an .ab1 or .fsa extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.abif(filename, max.bytes.in.file = file.info(filename)$size, 
 pied.de.pilote = 1.2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.abif_+3A_filename">filename</code></td>
<td>
<p>The name of the file.</p>
</td></tr>
<tr><td><code id="read.abif_+3A_max.bytes.in.file">max.bytes.in.file</code></td>
<td>
<p>The size in bytes of the file, defaulting to what is returned by file.info</p>
</td></tr>	
<tr><td><code id="read.abif_+3A_pied.de.pilote">pied.de.pilote</code></td>
<td>
<p>Safety factor: the argument readBin is set as pied.de.pilote*max.bytes.in.file.</p>
</td></tr>	
<tr><td><code id="read.abif_+3A_verbose">verbose</code></td>
<td>
<p>logical [FALSE]. If TRUE verbose mode is on.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>All data are imported into memory, there is no attempt to read items on the fly.
</p>


<h3>Value</h3>

<p>A list with three components: Header which is a list that contains various low-level information,
among which numelements is the number of elements in the directory and dataoffset
the offset to find the location of the directory. Directory is a data.frame for the directory
of the file with the number of row being the number of elements in the directory and the 7
columns describing various low-level information about the elements.  
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Anonymous (2006) Applied Biosystem Genetic Analysis Data File Format.
Available at <a href="http://www.appliedbiosystems.com/support/software_community/ABIF_File_Format.pdf">http://www.appliedbiosystems.com/support/software_community/ABIF_File_Format.pdf</a>.
Last visited on 03-NOV-2008.
</p>
<p>The figure in the example section is an attempt to reproduce figure 1A from:
</p>
<p>Krawczyk, J.,  Goesmann, A., Nolte, R., Werber, M., Weisshaar, B. (2009)
Trace2PS and FSA2PS: two software toolkits for converting trace and fsa files to PostScript format.
<em>Source Code for Biology and Medicine</em>, <b>4</b>:4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#No examples provided, please download seqinr package for going deeper in this function.

</code></pre>

<hr>
<h2 id='reals'>Finding the real peaks</h2><span id='topic+reals'></span>

<h3>Description</h3>

<p>This function takes a list with the information of positions, heights and weights for an individual and using the panel information finds the real peaks by using the separate function and getting the tallest peaks in the confidence interval constructed for the heights in the inteval of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reals(x, panel=c(100:400), shi=1, ploidy=2, left.cond=c(0.4,3), 
      right.cond=0.2, window=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reals_+3A_x">x</code></td>
<td>
<p>List with 3 elements; the information of positions, heights and weights for an individual in certain channel</p>
</td></tr>
<tr><td><code id="reals_+3A_panel">panel</code></td>
<td>
<p>A vector containing the base pair interval where the peaks should be searched for</p>
</td></tr>
<tr><td><code id="reals_+3A_shi">shi</code></td>
<td>
<p>The number of base pairs to be used for discarding neighboring peaks to the tallest peaks, i.e. if 2 peaks are 0.3 bp together the smalles will be discarded</p>
</td></tr>
<tr><td><code id="reals_+3A_ploidy">ploidy</code></td>
<td>
<p>A scalar value indicating the ploidy of the organism to be scored</p>
</td></tr>
<tr><td><code id="reals_+3A_left.cond">left.cond</code></td>
<td>
<p>A percentage value indicating when peaks to the leaft of the tallest peaks should be considered real based on the height, i.e. a very close peak right before the tallest peak if smaller than the tallest (half the size of the tallest one will be real or not)</p>
</td></tr>
<tr><td><code id="reals_+3A_right.cond">right.cond</code></td>
<td>
<p>A percentage value indicating when peaks to the right of the tallest peaks should be considered real based on the height, i.e. a very close peak right after the tallest peak if smaller than the tallest (half the size of the tallest one will be real or not)</p>
</td></tr>
<tr><td><code id="reals_+3A_window">window</code></td>
<td>
<p>A value in base pairs indicating how much is the error for detecting a peak in a sample that was provided in the panelas a real peak</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
x &lt;- big.peaks.col(my.plants[[1]][,1],100)#for any color
#reals(x, panel=c(260,280), shi=1, ploidy=2) 
#still needs weight information in order to find the reals, 
#works internally of score.easy function
</code></pre>

<hr>
<h2 id='saturate'>Checking and correcting saturated peaks</h2><span id='topic+saturate'></span>

<h3>Description</h3>

<p>This function takes a vector of intensities and looks for peaks above 8000 RFUs and correct for possible splits at the top of the peaks by inverting the vally between splitted peaks and correcting the peak. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saturate(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saturate_+3A_y">y</code></td>
<td>
<p> a vector containing the DNA intensities for the capillary electrophoresis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns:
</p>

<dl>
<dt>$y</dt><dd><p> A new vector of DNA intensities adjusted for saturated peaks over 8000 RFUs.</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
y &lt;- my.plants[[1]][,3]
layout(matrix(1:2,2,1))
plot(y, type="l", xlim=c(2750,2850))
y2 &lt;- saturate(y=y)
plot(y2, type="l", xlim=c(2750,2850))
</code></pre>

<hr>
<h2 id='score.markers'>Fragment analysis scoring</h2><span id='topic+score.markers'></span>

<h3>Description</h3>

<p>This function uses information from the fsa files read from <code><a href="#topic+storing.inds">storing.inds</a></code> function and does the ssr calling in the channel specified and returns the index position, height and base pair position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.markers(my.inds, channel = 1, n.inds = NULL, panel=NULL, shift=0.8,
          ladder, channel.ladder=NULL, 
          ploidy=2, left.cond=c(0.6,3), right.cond=0.35, warn=FALSE, 
          window=0.5, init.thresh=200, ladd.init.thresh=200, 
          method="iter2", env = parent.frame(), my.palette=NULL,
          plotting=TRUE,  electro=FALSE, pref=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.markers_+3A_my.inds">my.inds</code></td>
<td>
<p>List with the channels information from the individuals specified, usually coming from the <code><a href="#topic+storing.inds">storing.inds</a></code> function output</p>
</td></tr>
<tr><td><code id="score.markers_+3A_channel">channel</code></td>
<td>
<p>The channel you wish to analyze, usually 1 is blue, 2 is green, 3 is yellow, 4 is red and so on</p>
</td></tr>
<tr><td><code id="score.markers_+3A_n.inds">n.inds</code></td>
<td>
<p>Vector specifying the plants to be scored</p>
</td></tr>
<tr><td><code id="score.markers_+3A_panel">panel</code></td>
<td>
<p>A vector containing the base pair interval where the peaks should be searched for</p>
</td></tr>
<tr><td><code id="score.markers_+3A_shift">shift</code></td>
<td>
<p>The number of base pairs to be used for discarding neighboring peaks to the tallest peaks, i.e. if 2 peaks are 0.3 bp together the smalles will be discarded</p>
</td></tr>
<tr><td><code id="score.markers_+3A_ladder">ladder</code></td>
<td>
<p>A vector containing the expected weights for the ladder peaks that will be found the using the <code><a href="#topic+find.ladder">find.ladder</a></code> function</p>
</td></tr>
<tr><td><code id="score.markers_+3A_channel.ladder">channel.ladder</code></td>
<td>
<p>A scalar value indicating in which channel or color the ladder was read</p>
</td></tr>
<tr><td><code id="score.markers_+3A_ploidy">ploidy</code></td>
<td>
<p>A scalar value indicating the ploidy of the organism to be scored to decide the maximum number of peaks the program should look for. TO BE IMPLEMENTED SOON. STILL NOT FUNCTIONAL.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_left.cond">left.cond</code></td>
<td>
<p>A percentage value (0-1) indicating when peaks to the left of the tallest peaks should be considered real based on the height, i.e. a value of 0.5 would mean that a close peak (to the left of the tallest peak) will be picked only if such peak is at least 50 percent as tall with respect to the tallest peak. The second argument is the number of base pair indicating when peaks to the left of the tallest peaks should be considered real based on the distance, i.e. a value of 3 would mean that a close peak (to the left of the tallest peak) will be picked only if such peak is at least 3 base pairs far away from the tallest peak</p>
</td></tr>
<tr><td><code id="score.markers_+3A_right.cond">right.cond</code></td>
<td>
<p>A percentage value (0-1) indicating when peaks to the right of the tallest peaks should be considered real based on the height, i.e. a value of 0.5 would mean that a close peak (to the right of the tallest peak) will be picked only if such peak is at least 50 percent as tall with respect to the tallest peak.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_warn">warn</code></td>
<td>
<p>A TRUE/FALSE value indicating if warnings should be provided when detecting the ladder</p>
</td></tr>
<tr><td><code id="score.markers_+3A_window">window</code></td>
<td>
<p>A value in base pairs indicating how much is the error for detecting a peak in a sample when providing a panel with expected peaks.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_init.thresh">init.thresh</code></td>
<td>
<p> An initial value of intensity to detect peaks. We recommend not to deal to much with it unless you have highly controlled dna concentrations in your experiment.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_ladd.init.thresh">ladd.init.thresh</code></td>
<td>
<p> If samples were not sized using the info.ladder.attach function this value will be used to detect ladder peaks. Internally the program will use the <code><a href="#topic+find.ladder">find.ladder</a></code> function. We recommend not to deal to much with it unless you identified special situations with your ladder</p>
</td></tr>
<tr><td><code id="score.markers_+3A_method">method</code></td>
<td>
<p>If samples were not sized using the info.ladder.attach function this method will be used to detect ladder peaks. An argument indicating one of the 3 methods available; &quot;cor&quot; makes all possible combination of peaks and searches exhaustive correlations to find the right peaks corresponsding to the expected DNA weights, or &quot;ci&quot; constructing confidence intervals to look for peaks meeting the conditions specified in the previous arguments, &quot;iter2&quot; an iterative procedure looking for the most likely peaks meeting your ladder expectation. Default is &quot;iter2&quot;.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_env">env</code></td>
<td>
<p> this is used to detect the environment of the user and load the result in the same environment. Don't mess with it please.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_my.palette">my.palette</code></td>
<td>
<p>A character vector with the colors to be used when drawing the RFU plots. If NULL it will use the programmed palette.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_plotting">plotting</code></td>
<td>
<p> a TRUE/FALSE value indicating if the plots should be drawn or not. The default value is TRUE.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_electro">electro</code></td>
<td>
<p>A TRUE/FALSE value indicating if the electrogram/gel should be drawn or not. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="score.markers_+3A_pref">pref</code></td>
<td>
<p>A scalar value indicating how many plots should be drawn in the output plotting. The dafault is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method &quot;ci&quot; has been depreciated, currently the method &quot;iter2&quot; is the default and uses the ladder provided and observed peaks to match them using an iterative procedure based on least squares.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a plot and a list containing
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ================================= ##
## ================================= ##
## Fragment analysis requires 
## 1) loading your data
## 2) matching your ladder
## 3) define a panel for scoring
## 4) score the samples
## ================================= ##
## ================================= ##

#####################
## 1) Load your data
#####################

### you would use something like:
# folder &lt;- "~/myfolder"
# my.plants &lt;- storing.inds(folder)
### here we just load our sample data and use the first 2 plants

?my.plants
data(my.plants)
my.plants &lt;- my.plants[1:2]
class(my.plants) &lt;- "fsa_stored"

#######################
## 2) Match your ladder
#######################

### create a vector indicating the sizes of your ladder and do the match

my.ladder &lt;- c(50, 75, 100, 125, 129, 150, 175, 200, 225, 250, 275, 300, 325, 350, 375)
ladder.info.attach(stored=my.plants, ladder=my.ladder)

### matching your ladder is a critical step and should only happen once per batch of 
### samples read

###****************************************************************************************###
### OPTIONAL:
### If the ladder.info attach function detects some bad samples 
### that you can correct them manually using
### the ladder.corrector() function
### For example to correct one sample in the previous data
### ladder.corrector(stored=my.plants, 
#to.correct="FHN152-CPN01_01A_GH1x35_152-148-209_717-704-793_367-382-381.fsa", 
#ladder=my.ladder)
###****************************************************************************************###

#######################
## 3) Define a panel
#######################

### In fragment analysis you usually design a panel where you indicate
### which peaks are real. You may use the overview2 function which plots all the
### plants in the channel you want in the base pair range you want

overview2(my.inds=my.plants, channel = 2:3, ladder=my.ladder, init.thresh=5000)

### You can click on the peaks you think are real, given that the ones
### suggested by the program may not be correct. This can be done by using the 
### 'locator' function and press 'Esc' when you're done, i.e.:
# my.panel &lt;- locator(type="p", pch=20, col="red")$x
### That way you can click over the peaks and get the sizes
### in base pairs stored in a vector named my.panel

### Just for demonstration purposes I will use the suggested peaks by 
### the program using overview2, which will return a vector with 
### expected DNA sizes to be used in the next step for scoring
### we'll do it in the 160-190 bp region

my.panel &lt;- overview2(my.inds=my.plants, channel = 3, 
                    ladder=my.ladder, init.thresh=7000, 
                    xlim=c(160,190)); my.panel

##########################
## 4) Score the samples
##########################

### When a panel is created is time to score the samples by providing the initial
### data we read, the ladder vector, the panel vector, and our specifications
### of channel to score (other arguments are available)

### Here we will score our samples for channel 3 with our panel created previously

res &lt;- score.markers(my.inds=my.plants, channel = 3, panel=my.panel$channel_3,
                ladder=my.ladder, electro=FALSE)

### Check the plots and make sure they were scored correctly. In case some samples 
### are wrong you might want to use the locator function again and figure out 
### the size of your peaks. To extract your peaks in a data.frame do the following:

final.results &lt;- get.scores(res)
final.results 
</code></pre>

<hr>
<h2 id='separate'>Separating peaks by a shift window</h2><span id='topic+separate'></span>

<h3>Description</h3>

<p>This function takes a list with positions, heights and weights called &quot;g&quot; and using a shift in base pairs determines when 2 neighboring peaks should be considered only one by getting the tallest peak. For example two peaks found at 173 and 173.5 base pairs are unlikely to be 2 different peaks, therefore only the tallest peak will pe chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate(g, shift=1, type="bp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_+3A_g">g</code></td>
<td>
<p>List with 3 elements; the information of positions, heights and weights for an individual in certain channel</p>
</td></tr>
<tr><td><code id="separate_+3A_shift">shift</code></td>
<td>
<p>The number of base pairs to be used for discarding neighboring peaks to the tallest peaks, i.e. if 2 peaks are 0.3 bp together the smalles will be discarded</p>
</td></tr>
<tr><td><code id="separate_+3A_type">type</code></td>
<td>
<p>A word indicating if the shift to be used should be used in base pairs or in index. The use is &quot;bp&quot; or &quot;ind&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a new list containing
</p>

<dl>
<dt>$pos</dt><dd><p>the index positions for the intensities</p>
</dd>
<dt>$hei</dt><dd><p>the intensities for the fragments found</p>
</dd>
<dt>$wei</dt><dd><p>the putative weights in base pairs based on the ladder provided</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
x &lt;- big.peaks.col(my.plants[[1]][,1],100)#for any color
#separate(x, shift=1, type="bp") #still needs weight information
</code></pre>

<hr>
<h2 id='storing.inds'>Extracting channel information</h2><span id='topic+storing.inds'></span>

<h3>Description</h3>

<p>This function reads the FSA files using a function named 'read.abif' from another R package called seqinr. This will extract the information of the DNA intensities of the capillary electrophoresis and will store it in a data structure know in R as a list. The usage of the function and the arguments it takes are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storing.inds(folder, channels=NULL, fourier=TRUE, 
            saturated=TRUE, lets.pullup=TRUE, 
            plotting=FALSE, rawPlot=FALSE,
            llength=3000, ulength=80000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storing.inds_+3A_folder">folder</code></td>
<td>
<p>A path/directory where the FSA files are located. We recommend to use the Seession tab -&gt; Set working directory and provide that folder as an argument</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_channels">channels</code></td>
<td>
<p>A scalar value indicating how many channels/colors should be found in the FSA files, usually people using the rox375 ladder in the red channel have 4 channels, people using the LIZ ladder have 5 channels. The default is the last channel.</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_fourier">fourier</code></td>
<td>
<p>A FALSE/TRUE value indicating if data should be smooth aplying a Fourier transormation using 40 percent of the lowest frequencies. The dafault is TRUE</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_saturated">saturated</code></td>
<td>
<p>A FALSE/TRUE value indicating if data should be checked and treated for saturated peaks above 8000 RFU which usually split at the top in 2 different peaks. The dafault is TRUE</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_lets.pullup">lets.pullup</code></td>
<td>
<p>A FALSE/TRUE value indicating if data should be treated for noise from channel to channel known as pull up or pull down peaks since wavelengths where the dyes are read usually overlap (blue-&gt;green-&gt;yellow-&gt;red-&gt;orange. The dafault is TRUE</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_plotting">plotting</code></td>
<td>
<p>A FALSE/TRUE value indicating if results after data cleaning steps should be plotted to asses graphically how data was handled. The dafault is FALSE</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_rawplot">rawPlot</code></td>
<td>
<p>A FALSE/TRUE value indicating if a plot drawing all vectors read should be plotted. The dafault is FALSE since this consumes a lot of memory.</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_llength">llength</code></td>
<td>
<p>A numeric value indicating how small can be the number of indexes in each channel. Default is 3000 indexes for small runs.</p>
</td></tr>
<tr><td><code id="storing.inds_+3A_ulength">ulength</code></td>
<td>
<p>A numeric value indicating how big can be the number of indexes in each channel. Default is 80000 indexes for long runs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correct the function returns a list containing
</p>

<dl>
<dt>all.inds.mats</dt><dd><p>A list where each element is a data frame containing the &quot;n&quot; channels of an individual</p>
</dd>
</dl>



<h3>References</h3>

<p>We have spent valuable time developing this package, please cite it in your publication:
</p>
<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
### the correct way to do it for a population of inds with 
### 4 colors + ladder= 5 would be:
# my.plants &lt;- storing.inds(folder)
</code></pre>

<hr>
<h2 id='threshs'>Customizing thresholds</h2><span id='topic+threshs'></span>

<h3>Description</h3>

<p>This function takes data contained in a list with 2 elements, the first containing the position in base pairs and the heights of the positions and given a panel finds the best minimum threshold by creating a confidence interval in order to get only the real peaks. Implemented internally of auto,score and score.easy function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshs(my.plant, min.thre=200, panel, ci=1.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshs_+3A_my.plant">my.plant</code></td>
<td>
<p>List with 2 elements; the position in base pairs and the heights associated with them</p>
</td></tr>
<tr><td><code id="threshs_+3A_min.thre">min.thre</code></td>
<td>
<p>Starting threshold to find the peaks and refine the search</p>
</td></tr>
<tr><td><code id="threshs_+3A_panel">panel</code></td>
<td>
<p>Two scalar values indicatin the interval where the peaks should be found</p>
</td></tr>
<tr><td><code id="threshs_+3A_ci">ci</code></td>
<td>
<p>Scalar value indicating the number of standard errors to be used when creating the confidence interval for ssr calling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns a list containing
</p>

<dl>
<dt>$newthre</dt><dd><p> A scalar value indicating the new threshold to be used when calling the real peaks</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
# implemented internally of auto,score and score.easy function
# threshs(my.plant, min.thre=200, panel=(260,290), ci=1.9)
</code></pre>

<hr>
<h2 id='transfft'>Applying the fourier transformation to a data frame</h2><span id='topic+transfft'></span>

<h3>Description</h3>

<p>This function takes a vector and applies a fourier transformation in order to smooth the peaks usinf the fft function in the base package. Use only top 40 percent of the lowest frequencies. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfft(sn, top=0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transfft_+3A_sn">sn</code></td>
<td>
<p> a numeric vector containing the DNA intensities for the capillary electrophoresis.</p>
</td></tr>
<tr><td><code id="transfft_+3A_top">top</code></td>
<td>
<p> percent of lowest frequencies that should be used for the fourier transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns:
</p>

<dl>
<dt>$y</dt><dd><p> A new vector of DNA intensities smoothed to avoid extra noisy peaks.</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(my.plants)
g1 &lt;- transfft(my.plants[[1]][,4], top=0.8)
g2 &lt;- transfft(my.plants[[1]][,4], top=0.4)
g3 &lt;- transfft(my.plants[[1]][,4], top=0.1)
layout(matrix(1:3,3,1))
plot(g1, type="l")
lines(g2, col="red")
lines(g3, col="blue")
par1 &lt;- c("top=0.8", "top=0.4", "top=0.1")
par2 &lt;- c("black", "red", "blue")
par3 &lt;- c(1,1,1)
legend("topright", legend=par1, col=par2, bty = "n", lty=par3, lwd=par3, cex=0.75)
</code></pre>

<hr>
<h2 id='transp'>Creating color with transparency</h2><span id='topic+transp'></span>

<h3>Description</h3>

<p>This function takes a color and returns the same with a certain alpha grade transparency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transp(col, alpha=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transp_+3A_col">col</code></td>
<td>
<p>Color to be used for transparency</p>
</td></tr>
<tr><td><code id="transp_+3A_alpha">alpha</code></td>
<td>
<p>Grade of transparency desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns:
</p>

<dl>
<dt>$res</dt><dd><p> A new color with certain grade of transparency</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G, Diaz-Garcia L, Schlautman B, Salazar W, Zalapa J. Fragman: An R package for fragment analysis. 2016. BMC Genetics 17(62):1-8.
</p>
<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transp("red", alpha=0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
