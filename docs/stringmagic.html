<!DOCTYPE html><html><head><title>Help for package stringmagic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringmagic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stringmagic-package'><p>String operations and interpolation: magic edition</p></a></li>
<li><a href='#cat_magic_alias'><p>Display messages using interpolated strings</p></a></li>
<li><a href='#parse_regex_pattern'><p><code>stringmagic</code>'s regular expression parser</p></a></li>
<li><a href='#paste_conditional'><p>Paste a string vector conditionally</p></a></li>
<li><a href='#string_clean_alias'><p>Cleans a character vector from multiple patterns</p></a></li>
<li><a href='#string_extract'><p>Extracts a pattern from a character vector</p></a></li>
<li><a href='#string_fill'><p>Fills a character string up to a size</p></a></li>
<li><a href='#string_get'><p>Gets elements of a character vector</p></a></li>
<li><a href='#string_is'><p>Detects whether a pattern is in a character string</p></a></li>
<li><a href='#string_magic'><p>String interpolation with operation chaining</p></a></li>
<li><a href='#string_magic_alias'><p>Create <code>string_magic</code> aliases with custom defaults</p></a></li>
<li><a href='#string_magic_register_fun'><p>Register custom operations to apply them in <code>string_magic</code></p></a></li>
<li><a href='#string_ops_alias'><p>Chains basic operations to character vectors</p></a></li>
<li><a href='#string_split'><p>Splits a character string wrt a pattern</p></a></li>
<li><a href='#string_split2df'><p>Splits a character vector into a data frame</p></a></li>
<li><a href='#string_vec_alias'><p>Efficient creation of string vectors with optional interpolation</p></a></li>
<li><a href='#timer_magic'><p>Sets up a timer that can be used within <code style="white-space: pre;">&#8288;_magic&#8288;</code> functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Character String Operations and Interpolation, Magic Edition</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp(&ge; 1.0.5), utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, data.table</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs complex string operations compactly and efficiently. Supports string interpolation jointly with over 50 string operations. Also enhances regular string functions (like grep() and co). See an introduction at <a href="https://lrberge.github.io/stringmagic/">https://lrberge.github.io/stringmagic/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lrberge/stringmagic/issues">https://github.com/lrberge/stringmagic/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lrberge.github.io/stringmagic/">https://lrberge.github.io/stringmagic/</a>,
<a href="https://github.com/lrberge/stringmagic">https://github.com/lrberge/stringmagic</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-29 21:41:14 UTC; lrberge</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurent R Berge <a href="https://orcid.org/0000-0003-2736-1917"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Morgan Jacob [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurent R Berge &lt;laurent.berge@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-30 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stringmagic-package'>String operations and interpolation: magic edition</h2><span id='topic+stringmagic'></span><span id='topic+stringmagic-package'></span>

<h3>Description</h3>

<p>The stringmagic package introduces a new language tailored to create complex character strings.
Use the function string_magic to interpolate a variable inside a character string and to apply,
on-the-fly, any arbitrary string operation.
</p>


<h3>Details</h3>

<p>It supports over 50 basic operations, seamless customization, nesting,
pluralization, and much more. Writing complex character strings has never been that easy!
</p>
<p>To get an overview of the package: see the <a href="https://lrberge.github.io/stringmagic/index.html">Readme</a>.
To get started with string_magic,
see <a href="https://lrberge.github.io/stringmagic/articles/guide_string_magic.html">the vignette</a>.
</p>
<p>This package also enhances regular string functions (like grep and co) with
specialized functions to:
</p>

<ul>
<li><p> detect combinations of regular expressions
</p>
</li>
<li><p> chain basic string operations
</p>
</li>
<li><p> clean character string vectors
</p>
</li></ul>

<p>See more in the <a href="https://lrberge.github.io/stringmagic/articles/guide_string_tools.html">dedicated vignette</a>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>
<p>For a few functions (e.g. string_split2df) I use internally an algorithm to turn vectors
into indexes (i.e. integer vectors of the same length ranging to 1 to the number of groups).
This algorithm was inspired by Sebastian Krantz's <a href="https://cran.r-project.org/package=collapse">collapse</a>
(if you don't know about it, you should definitely check it out!) who uses an algorithm
from Morgan Jacob's <a href="https://cran.r-project.org/package=kit">kit</a> package.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lrberge.github.io/stringmagic/">https://lrberge.github.io/stringmagic/</a>
</p>
</li>
<li> <p><a href="https://github.com/lrberge/stringmagic">https://github.com/lrberge/stringmagic</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lrberge/stringmagic/issues">https://github.com/lrberge/stringmagic/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cat_magic_alias'>Display messages using interpolated strings</h2><span id='topic+cat_magic_alias'></span><span id='topic+message_magic_alias'></span><span id='topic+cat_magic'></span><span id='topic+catma'></span><span id='topic+message_magic'></span><span id='topic+mema'></span>

<h3>Description</h3>

<p>Utilities to display messages using <code>string_magic</code> interpolation and operations to generate the message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_magic_alias(
  .sep = "",
  .end = "",
  .width = FALSE,
  .leader = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .namespace = NULL
)

message_magic_alias(
  .sep = "",
  .end = "\n",
  .width = FALSE,
  .leader = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .namespace = NULL
)

cat_magic(
  ...,
  .sep = "",
  .end = "",
  .width = FALSE,
  .leader = "",
  .envir = parent.frame(),
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .help = NULL,
  .namespace = NULL
)

catma(
  ...,
  .sep = "",
  .end = "",
  .width = FALSE,
  .leader = "",
  .envir = parent.frame(),
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .help = NULL,
  .namespace = NULL
)

message_magic(
  ...,
  .sep = "",
  .end = "\n",
  .width = NULL,
  .leader = "",
  .envir = parent.frame(),
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .help = NULL,
  .namespace = NULL
)

mema(
  ...,
  .sep = "",
  .end = "\n",
  .width = NULL,
  .leader = "",
  .envir = parent.frame(),
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .collapse = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .help = NULL,
  .namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_magic_alias_+3A_.sep">.sep</code></td>
<td>
<p>Character scalar, default is the empty string <code>""</code>. It is used to collapse all
the elements in <code>...</code> before applying any operation.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.end">.end</code></td>
<td>
<p>Character scalar, default is <code>""</code> (the empty string). This string
will be collated at the end of the message (a common alternative is <code>"\n"</code>).</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.width">.width</code></td>
<td>
<p>Can be 1) a positive integer, 2) a number in (0;1), 3) <code>FALSE</code> (default
for <code>cat_magic</code>), or 4) <code>NULL</code> (default for <code>message_magic</code>). It represents the target
width of the message on the user console. Newlines will be added <em>between words</em> to fit the
target width.
</p>

<ol>
<li><p> positive integer: number of characters
</p>
</li>
<li><p> number (0;1): fraction of the screen
</p>
</li>
<li> <p><code>FALSE</code>: does not add newlines
</p>
</li>
<li> <p><code>NULL</code>: the min between 120 characters and 90% of the screen width
</p>
</li></ol>

<p>Note that you can use the special variable <code>.sw</code> to refer to the screen width. Hence the value
<code>NULL</code> is equivalent to using <code>min(120, 0.9*.sw)</code>.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.leader">.leader</code></td>
<td>
<p>Character scalar, default is <code>TRUE</code>. Only used if argument <code>.width</code> is not <code>FALSE</code>.
Whether to add a leading character string right after the extra new lines.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.vectorize">.vectorize</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, Further, elements in <code>...</code> are
NOT collapsed together, but instead vectorised.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.delim">.delim</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("{", "}")</code>. Defines
the opening and the closing delimiters for interpolation.
</p>
<p>If of length 1, it must be of the form: 1) the opening delimiter,
2) a single space, 3) the closing delimiter. Ex: <code>".[ ]"</code> is equivalent to <code>c(".[", "]")</code>.
The default value is equivalent to <code>"{ }"</code>.
</p>
<p>[ ]: R:%20
[&quot;, &quot;]: R:%22,%20%22</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.last">.last</code></td>
<td>
<p>Character scalar, a function, or <code>NULL</code> (default). If provided and character:
it must be an <code>string_magic</code> chain of operations of the form <code>"'arg1'op1, op2, etc"</code>. All these operations
are applied just before returning the vector. If a function,
it will be applied to the resulting vector.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.collapse">.collapse</code></td>
<td>
<p>Character scalar, default is <code>NULL</code>. If provided, the character vector
that should be returned is collapsed with the value of this argument. This leads
to return a string of length 1.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.trigger">.trigger</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code>, this function is not run. Can be
useful in debugging situations where we want conditional evaluations.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.check">.check</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to enable error-handling (i.e.
human readable error messages).
Without error-handling you can save something of the order of 40us. Useful only
in long loops.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.namespace">.namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_...">...</code></td>
<td>
<p>Character scalars that will be collapsed with the argument <code>sep</code>. Note that
named arguments are used for substitution.
</p>
<p>To interpolate, you can
use <code>"{x}"</code> within each character string to insert the value of <code>x</code> in the string.
You can add string operations in each <code>"{}"</code> instance with the syntax <code>"'arg'op ? x"</code>
(resp. <code>"'arg'op ! x"</code>) to apply the operation <code>'op'</code> with the argument <code>'arg'</code> to <code>x</code>
(resp. the verbatim of <code>x</code>). Otherwise, what to say? Ah, nesting is enabled, and since
there's over 50 operators, it's a bit complicated to sort you out in this small space.
</p>
<p>Use the argument <code>.help = "keyword"</code> (or <code>.help = TRUE</code>) to obtain a selective help
from the main documentation.
</p>
<p>Note that in interpolations you have access to the special variables: <code>.now</code> and <code>.date</code>
to get the current time; and the special function <code>.now("format")</code> to
format the time. Ex: <code>.now('%Y-%m %H:%m')</code>.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.envir">.envir</code></td>
<td>
<p>An environment used to evaluate the variables in <code>"{}"</code>. By default the variables are
evaluated using the environment from where the function is called or using the named
arguments passed to the function.</p>
</td></tr>
<tr><td><code id="cat_magic_alias_+3A_.help">.help</code></td>
<td>
<p>Character scalar or <code>TRUE</code>, default is <code>NULL</code>. This argument
is used to generate a dynamic help on the console. If <code>TRUE</code>, the user can select which
topic to read from the main documentation, with the possibility to search for keywords and
navigate the help pages. If a character scalar, then a regex search is perfomed on the main
documentation and any section containining a match is displayed. The user can easily
navigate across matches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are <code><a href="base.html#topic+cat">base::cat()</a></code>/<code><a href="base.html#topic+message">message()</a></code> wrappers aroung <code><a href="#topic+string_magic">string_magic()</a></code>. There is one notable difference
with respect to <code>cat</code>/<code>message</code>. It's the ability to add newlines after words for
the message to fit a target width. This is controlled with the argument <code>.width</code>. This is
active by default for <code>message_magic</code> (default is <code>.width = NULL</code> which leads to the
minimum betwen 120 characters and 90% of the screen width).
</p>
<p>You can very easily change the default values with the alias generators <code>cat_magic_alias</code> and
<code>message_magic_alias</code>.
</p>
<p><code style="white-space: pre;">&#8288;[Advanced]&#8288;</code> A note for package developers who would use these functions <strong>and</strong>
also use custom <code>string_magic</code> operations created with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or
<code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>. To ensure forward compatibility the new operations created
should be defined in the package namespace (see the <em>ad hoc</em> section in <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> help).
To access these operators in their specific namespaces, you must use an alias with
<code>cat_magic_alias</code> or <code>message_magic_alias</code> with the argument <code>.namespace = "myPackageName"</code>
(to avoid having to provide the <code>.namespace</code> argument repeatedly).
</p>


<h3>Value</h3>

<p>The functions <code>cat_magic()</code> and <code>message_magic()</code> do not return anything, they simply print on the console.
</p>
<p>The function <code>cat_magic_alis()</code> returns a function behaving identically to <code><a href="#topic+cat_magic">cat_magic()</a></code> but for which the
default values have been altered.
Same for <code>message_magic_alias()</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cat_magic_alias()</code>: Create an alias of <code>cat_magic</code> with custom defaults
</p>
</li>
<li> <p><code>message_magic_alias()</code>: Create an alias of <code>message_magic</code> with custom defaults
</p>
</li>
<li> <p><code>catma()</code>: Alias to <code>cat_magic</code>
</p>
</li>
<li> <p><code>message_magic()</code>: Display messages using interpolated strings
</p>
</li>
<li> <p><code>mema()</code>: Alias to <code>message_magic</code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other tools with aliases: 
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
start = Sys.time()
Sys.sleep(0.05)
message_magic("This example has run in {difftime ? start}.")

cat_magic("Let's write a very long message to illustrate how .width work.", 
          .width = 40)

# Let's add a leader
cat_magic("Let's write a very long message to illustrate how `.width` work.", 
          "And now we add `.leader`.", .width = 40, .leader = "#&gt; ")

# newlines respect the introductory spaces
cat_magic("Here's a list:", 
          "    + short item", 
          "    + this is a very long item that likely overflows", 
         .width = 30, .sep = "\n")

#
# define custom defaults
#

# Unhappy about the default values? Create an alias!

# Here we change the defaults to mimic the printing of a column
cat_column = cat_magic_alias(.sep = "\n", .end = "\n", .vectorize = TRUE, 
                            .last = "fill.center, ' + 'paste.both")

cat_column("code string_magic", "write the docs", "write the vignettes")

</code></pre>

<hr>
<h2 id='parse_regex_pattern'><code>stringmagic</code>'s regular expression parser</h2><span id='topic+parse_regex_pattern'></span>

<h3>Description</h3>

<p>Parse regular expression with custom flags and obtain the final pattern
to be parsed as well as the vector of flags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_regex_pattern(
  pattern,
  authorized_flags,
  parse_flags = TRUE,
  parse_logical = TRUE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_regex_pattern_+3A_pattern">pattern</code></td>
<td>
<p>Character scalar, the regular expression pattern to parse.</p>
</td></tr>
<tr><td><code id="parse_regex_pattern_+3A_authorized_flags">authorized_flags</code></td>
<td>
<p>Character vector representing the flags to be parsed.
Use the empty string if no flags are allowed.</p>
</td></tr>
<tr><td><code id="parse_regex_pattern_+3A_parse_flags">parse_flags</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to parse the
optional regex flags.</p>
</td></tr>
<tr><td><code id="parse_regex_pattern_+3A_parse_logical">parse_logical</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to parse logical
regex operations, similarly to <code><a href="#topic+string_get">string_get()</a></code>.</p>
</td></tr>
<tr><td><code id="parse_regex_pattern_+3A_envir">envir</code></td>
<td>
<p>An environment, default is <code>parent.frame()</code>. Only used if the flag
<code>magic</code> is present, it is used to find the variables to be interpolated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal tool that is exposed in order to facilitate checking what's going on.
</p>
<p>There is no error handling.
</p>


<h3>Value</h3>

<p>This function always returns a list of 4 elements:
</p>

<ul>
<li> <p><code>flags</code>: the character vector of flags. If no flags were found, this is the empty string.
</p>
</li>
<li> <p><code>patterns</code>: the vector of regex patterns.
</p>
</li>
<li> <p><code>is_or</code>: logical vector of the same length as <code>patterns</code>. Indicates for each
pattern if it should be attached to the previous patterns with a logical OR (<code>FALSE</code>
means a logical <code>AND</code>).
</p>
</li>
<li> <p><code>is_not</code>: logical vector of the same length as <code>patterns</code>. Indicates for each pattern
if it should be negated.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parse_regex_pattern("f/hello", c("fixed", "ignore"))

x = "john"
parse_regex_pattern("fm/{x} | Doe", c("fixed", "ignore", "magic"))

</code></pre>

<hr>
<h2 id='paste_conditional'>Paste a string vector conditionally</h2><span id='topic+paste_conditional'></span>

<h3>Description</h3>

<p>Easily reconstruct a string vector that has been split with <code><a href="#topic+string_split2df">string_split2df()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_conditional(x, id, sep = " ", names = TRUE, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_conditional_+3A_x">x</code></td>
<td>
<p>A character vector or a formula. If a vector: it represents the
values to be pasted together.
If a formula, it must be of the form
<code>my_string ~ id1 + id2</code> with on the left the character vector and on the right
the (possibly many) identifiers. If a formula, the argument <code>id</code> must be a
data frame.</p>
</td></tr>
<tr><td><code id="paste_conditional_+3A_id">id</code></td>
<td>
<p>A vector of identifiers, a list of identifiers (can be a data frame),
or a <code>data.frame</code>. The identifiers can be a vector or a list of vectors. They represent
which elements of <code>x</code> are to be pasted together.
</p>
<p>When <code>x</code> is a formula, then <code>id</code> must be a data.frame containing the variables in
the formula.</p>
</td></tr>
<tr><td><code id="paste_conditional_+3A_sep">sep</code></td>
<td>
<p>A character scalar, default is <code>" "</code>. The value used to paste together
the elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="paste_conditional_+3A_names">names</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to add, as names, the values of
the identifiers.</p>
</td></tr>
<tr><td><code id="paste_conditional_+3A_sort">sort</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to sort the results according to
the identifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector. If the argument <code>names</code> is <code>TRUE</code> (default), the vector will have
names equal to the values of the identifiers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# let's paste together the letters of the alphabet

# first we create the identifier
id = rep(1:2, each = 13)
setNames(id, letters)

# now we conditionally paste together the letters
paste_conditional(letters, id, "")

#
# using a formula

# we create a small data set based on mtcars
base_cars = within(mtcars, carname &lt;- row.names(mtcars))
base_cars = head(base_cars, 10)

# we use two identifiers
paste_conditional(carname ~ gear + carb, base_cars, sep = ", ")



</code></pre>

<hr>
<h2 id='string_clean_alias'>Cleans a character vector from multiple patterns</h2><span id='topic+string_clean_alias'></span><span id='topic+string_clean'></span><span id='topic+string_replace'></span><span id='topic+stclean'></span><span id='topic+streplace'></span>

<h3>Description</h3>

<p>Recursively cleans a character vector from several patterns. Quickly handle the
tedious task of data cleaning by taking advantage of the syntax.
You can also apply all sorts of cleaning operations by summoning <code><a href="#topic+string_ops">string_ops()</a></code> operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_clean_alias(
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  namespace = NULL
)

string_clean(
  x,
  ...,
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame(),
  namespace = NULL
)

string_replace(
  x,
  pattern,
  replacement = "",
  pipe = " =&gt; ",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame()
)

stclean(
  x,
  ...,
  replacement = "",
  pipe = " =&gt; ",
  split = ",[ \n\t]+",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame(),
  namespace = NULL
)

streplace(
  x,
  pattern,
  replacement = "",
  pipe = " =&gt; ",
  ignore.case = FALSE,
  fixed = FALSE,
  word = FALSE,
  total = FALSE,
  single = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_clean_alias_+3A_replacement">replacement</code></td>
<td>
<p>Character scalar, default is the empty string. It represents the default
value by which the patterns found in the character strings will be replaced. For example
<code>string_clean(x, "e", replacement = "a")</code> turn all letters &quot;e&quot; in <code>x</code> into &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_pipe">pipe</code></td>
<td>
<p>Character scalar, default is <code>" =&gt; "</code>. If thevalue of <code>pipe</code> is found in a pattern,
then the string is split w.r.t. the pipe and anything after the pipe becomes the replacement.
</p>
<p>For example in <code>string_clean(x, "e =&gt; a")</code> the default pipe is found in &quot;e =&gt; a&quot;, so the pattern
&quot;e&quot; will be replaced with &quot;a&quot;. In other terms, this is equivalent to <code>string_clean(x, "e", replacement = "a")</code>.
Example changing the pipe: you can obtain the previous result with <code>string_clean(x, "e|&gt;a", pipe = "|&gt;")</code>.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_split">split</code></td>
<td>
<p>Character scalar, default is <code>",[ \t\n]+"</code> (which means a comma followed with spaces
and/or new lines). By default the patterns to be replaced are comma separated, that is
the pattern is split w.r.t. the argument <code>split</code> and a replacement is done for each sub-pattern.
</p>
<p>Use <code>NULL</code> or the empty string to disable pattern separation.
</p>
<p>For example: let's look at <code>string_clean(x, "w/one, two =&gt; three")</code>. First the flag &quot;word&quot; is extracted from
the pattern (see arg. <code>...</code>) as well as the replacement (see arg. <code>pipe</code>), leading to &quot;one, two&quot; the
pattern to be replaced. Then the pattern is split w.r.t. <code>split</code>, leading
to two patterns &quot;one&quot; and &quot;two&quot;. Hence the words (thanks to the flag &quot;w&quot;) &quot;one&quot; and &quot;two&quot; from
the string <code>x</code> will be replaced with &quot;three&quot;.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_fixed">fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_total">total</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then when a pattern is found
in a string, the full string is replaced (instead of just the pattern). Note, <em>importantly</em>,
that when <code>total = TRUE</code> you can use logical operators in the patterns.
</p>
<p>Example: <code>string_clean(x, "wi/ &amp; two, three &amp; !four =&gt; ", total = TRUE)</code></p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_single">single</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether, in substitutions, to stop at
the first match found. Ex: <code>string_clean("abc", "[[:alpha:]] =&gt; _", single = TRUE)</code> leads
to <code>"_bc"</code>, while <code>string_clean("abc", "[[:alpha:]] =&gt; _")</code> leads to <code>"___"</code>.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_namespace">namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.
</p>
<p>If so pass the name of your package in this argument so that your function can access
the new <code>string_magic</code> operations defined within your package.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_...">...</code></td>
<td>
<p>Character scalars representing patterns. A pattern is of the form
&quot;flags/pat1, pat2 =&gt; replacement&quot;. This means that patterns 'pat1' and 'pat2' will be replaced
with the string 'replacement'. By default patterns are comma separated and the replacement comes
after a ' =&gt; ' (see args <code>split</code> and <code>pipe</code> to change this). By default the replacement is the empty string
(so &quot;pat1, pat2&quot; <em>removes</em> the patterns).
</p>
<p>Available regex flags are: 'word' (add word boundaries), 'ignore' (the case), 'fixed' (no regex),
'total', 'single' and 'magic'.
The flag <code>total</code> leads to a <em>total replacement</em> of the string if the pattern is found.
The flag 'magic' allows to interpolate variables within the pattern.  Use flags
with comma separation (&quot;word, total/pat&quot;) or use only their initials (&quot;wt/pat&quot;).
</p>
<p>Starting with an '@' leads to operations in <code><a href="#topic+string_ops">string_ops()</a></code>. Ex: &quot;@ascii, lower, ws&quot; turns
the string into ASCII, lowers the case and normalizes white spaces (see help of <code><a href="#topic+string_ops">string_ops()</a></code>).</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
<tr><td><code id="string_clean_alias_+3A_pattern">pattern</code></td>
<td>
<p>A character scalar containing a regular expression pattern to be replaced.
You can write the replacement directly in the string after a pipe: ' =&gt; ' (see arg. <code>pipe</code> to change this).
By default the replacement is the empty string (so &quot;pat1&quot; <em>removes</em> the pattern).
</p>
<p>Available regex flags are: 'word' (add word boundaries), 'ignore' (the case), 'fixed' (no regex),
'total', 'single' and 'magic'.
The flag <code>total</code> leads to a <em>total replacement</em> of the string if the pattern is found.
The flag 'magic' allows to interpolate variables within the pattern.  Use flags
with comma separation (&quot;word, total/pat&quot;) or use only their initials (&quot;wt/pat&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The main usage returns a character vector of the same length as the vector in input.
Note, however, that since you can apply arbitrary <code><a href="#topic+string_ops">string_ops()</a></code> operations, the length and type
of the final vector may depend on those (if they are used).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_clean_alias()</code>: Create a <code>string_clean</code> alias with custom defaults
</p>
</li>
<li> <p><code>string_replace()</code>: Simplified version of <code>string_clean</code>
</p>
</li>
<li> <p><code>stclean()</code>: Alias to <code>string_clean</code>
</p>
</li>
<li> <p><code>streplace()</code>: Alias to <code>string_replace</code>
</p>
</li></ul>


<h3>Regular expression flags specific to replacement</h3>

<p>This function benefits from two specific regex flags: &quot;total&quot; and &quot;single&quot;.
</p>

<ul>
<li><p> &quot;total&quot; replaces the <em>complete string</em> if the pattern is found (remember that the
default behavior is to replace just the pattern).
</p>
</li>
<li><p> &quot;single&quot; performs a single substitution for each string element and stops there.
Only the first match of each string is replaced. Technically we use <code><a href="base.html#topic+grep">base::sub()</a></code>
internally instead of <code><a href="base.html#topic+grep">base::gsub()</a></code>.
</p>
</li></ul>



<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c("hello world  ", "it's 5 am....")

# we clean the o's and the points (we use 'fixed' to trigger fixed-search)
string_clean(x, "o", "f/.")
# equivalently
string_clean(x, "fixed/o, .")
# equivalently
string_clean(x, "o, .", fixed = TRUE)
# equivalently
string_clean(x, "o", ".", fixed = TRUE)

#
# chaining operations: example using cars
#

cars = row.names(mtcars)
new = string_clean(cars, 
           # replace strings containing "Maz" with Mazda
           "total/Maz =&gt; Mazda", 
           # replace the word 'Merc' with Mercedes
           "wi/merc =&gt; Mercedes",
           # replace strings containing "Merc" and a digit followed with an 'S'
           "t/Merc &amp; \\dS =&gt; Mercedes S!",
           # put to lower case, remove isolated characters and normalize white spaces
           "@lower, ws.isolated")

cbind(cars, new)


</code></pre>

<hr>
<h2 id='string_extract'>Extracts a pattern from a character vector</h2><span id='topic+string_extract'></span><span id='topic+stextract'></span>

<h3>Description</h3>

<p>Extracts the first, or several, patterns from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_extract(
  x,
  pattern,
  single = FALSE,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  unlist = FALSE,
  envir = parent.frame()
)

stextract(
  x,
  pattern,
  single = FALSE,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  unlist = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_extract_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_extract_+3A_pattern">pattern</code></td>
<td>
<p>A character scalar. It represents the pattern
to be extracted from <code>x</code>. By default
this is a regular expression. You can use flags in the pattern in
the form <code style="white-space: pre;">&#8288;flag1, flag2/pattern&#8288;</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
single (select only the first element), and magic (add interpolation with <code>{}</code>) . Example:
if <code>"ignore/hello"</code> and <code style="white-space: pre;">&#8288;x = "Hello world&#8288;</code> extracted text is <code>"Hello"</code>.
Shortcut: use the first letters of the flags. Ex: &quot;iw/one&quot; will extract the word
&quot;one&quot; (flags 'ignore' + 'word').</p>
</td></tr>
<tr><td><code id="string_extract_+3A_single">single</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, only the first pattern
that is detected will be returned. Note that in that case, a character vector is returned
of the same length as the vector in input.</p>
</td></tr>
<tr><td><code id="string_extract_+3A_simplify">simplify</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If <code>TRUE</code>, then when the vector input <code>x</code>
is of length 1, a character vector is returned instead of a list.</p>
</td></tr>
<tr><td><code id="string_extract_+3A_fixed">fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td></tr>
<tr><td><code id="string_extract_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_extract_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_extract_+3A_unlist">unlist</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, the function <code>unlist</code> is applied
to the resulting list, leading to a character vector in output (instead of a list).</p>
</td></tr>
<tr><td><code id="string_extract_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned by this functions can be a list or a character vector.
</p>
<p>If <code>single = TRUE</code>, a character vector is returned, containing the value of the first match.
If no match is found, an empty string is returned.
</p>
<p>If <code>single = FALSE</code> (the default) and <code>simplify = TRUE</code> (default), the object returned is:
</p>

<ul>
<li><p> a character vector if <code>x</code>, the vector in input, is of length 1: the character vector contains
all the matches and is of length 0 if no match is found.
</p>
</li>
<li><p> a list of the same length as <code>x</code>. The ith element of the list is a character vector
of the matches for the ith element of <code>x</code>.
</p>
</li></ul>

<p>If <code>single = FALSE</code> (default) and <code>simplify = FALSE</code>, the object returned is always a list.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stextract()</code>: Alias to <code>string_extract</code>
</p>
</li></ul>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
cars = head(row.names(mtcars))

# Let's extract the first word:
string_extract(cars, "\\w+", single = TRUE)

# same using flags
string_extract(cars, "s/\\w+")

# extract all words composed on only letters
# NOTE: we use the flag word (`w/`)
string_extract(cars, "w/[[:alpha:]]+")

# version without flag:
string_extract(cars, "\\b[[:alpha:]]+\\b")

# If a vector of length 1 =&gt; a vector is returned
greet = "Hi Tom, how's Mary doing?"
string_extract(greet, "w/[[:upper:]]\\w+")

# version with simplify = FALSE =&gt; a list is returned
string_extract(greet, "w/[[:upper:]]\\w+", simplify = FALSE)

</code></pre>

<hr>
<h2 id='string_fill'>Fills a character string up to a size</h2><span id='topic+string_fill'></span>

<h3>Description</h3>

<p>Fills a character string up to a size and handles multibyte encodings
(differently from sprintf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_fill(
  x = "",
  n = NULL,
  symbol = " ",
  right = FALSE,
  center = FALSE,
  na = "NA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_fill_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_fill_+3A_n">n</code></td>
<td>
<p>Integer scalar, possibly equal to <code>NULL</code> (default). The size up to which the character
vector will be filled. If <code>NULL</code> (default), it is set to the largest width in the character vector <code>x</code>.
To handle how the character is filled, see the arguments <code>symbol</code>, <code>right</code> and <code>center</code>.</p>
</td></tr>
<tr><td><code id="string_fill_+3A_symbol">symbol</code></td>
<td>
<p>Character scalar of length 1, default is a space (&quot; &quot;). It is the symbol with which
the string will be filled.</p>
</td></tr>
<tr><td><code id="string_fill_+3A_right">right</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then the filling of the string is
done from the left, leading to right-alignment.</p>
</td></tr>
<tr><td><code id="string_fill_+3A_center">center</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then the filling of the string will
be balanced so as to center the strings.</p>
</td></tr>
<tr><td><code id="string_fill_+3A_na">na</code></td>
<td>
<p>Character scalar or <code>NA</code>. Default is &quot;NA&quot; (a character string!). What happens to NAs: by default
they are replaced by the character string &quot;NA&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you use character filling of the form <code>sprintf("% 20s", x)</code> with <code style="white-space: pre;">&#8288;x``containing multibyte characters, you may be suprised that all character strings do not end up at the same lenght (the occurrence of this problem depends on many things: encodings are a mess). &#8288;</code>string_fill'
uses only base R functions to compensate this. It is slightly slower but, in general, safer.
</p>
<p>It also looks a bit like <code><a href="base.html#topic+format">base::format()</a></code>, but slightly different (and a bit faster, but more restrictive).
</p>


<h3>Value</h3>

<p>This functions returns a character vector of the same lenght as the vector in input.
</p>


<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c("apple", "pineapple") 

# simple fill with blank
cat(paste0(string_fill(x), ":", c(3, 7), "€"), sep = "\n")

# center fill
cat(paste0(string_fill(x, center = TRUE), ":", c(3, 7), "€"), sep = "\n")

# changing the length of the fill and the symbol used for filling
cat(paste0(string_fill(x), ":", 
           string_fill(c(3, 7), 3, "0", right = TRUE), "€"), sep = "\n")

# na behavior: default/NA/other
x = c("hello", NA) 
string_fill(x)
string_fill(x, na = NA)
string_fill(x, na = "(missing)")


</code></pre>

<hr>
<h2 id='string_get'>Gets elements of a character vector</h2><span id='topic+string_get'></span><span id='topic+stget'></span>

<h3>Description</h3>

<p>Convenient way to get elements from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_get(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  seq = FALSE,
  seq.unik = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

stget(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  seq = FALSE,
  seq.unik = FALSE,
  pattern = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_get_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_get_+3A_...">...</code></td>
<td>
<p>Character scalars representing the patterns to be found. By default they are (perl) regular-expressions.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: &quot;ignore/sepal&quot; would get &quot;Sepal.Length&quot; (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: &quot;if/dt[&quot; would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with &quot;&quot;.</p>
</td></tr>
<tr><td><code id="string_get_+3A_fixed">fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td></tr>
<tr><td><code id="string_get_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_get_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_get_+3A_or">or</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. In the presence of two or more patterns,
whether to combine them with a logical &quot;or&quot; (the default is to combine them with a logical &quot;and&quot;).</p>
</td></tr>
<tr><td><code id="string_get_+3A_seq">seq</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. The argument <code>pattern</code> accepts a vector of
patterns which are combined with an <code>and</code> by default. If <code>seq = TRUE</code>, then it is like
if <code>string_get</code> was called sequentially with its results stacked. See examples.</p>
</td></tr>
<tr><td><code id="string_get_+3A_seq.unik">seq.unik</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. The argument <code>...</code> (or the argument <code>pattern</code>) accepts
a vector of patterns which are combined with an <code>and</code> by default. If <code>seq.unik = TRUE</code>, then
<code>string_get</code> is called sequentially with its results stacked, and <code>unique()</code> is
applied in the end. See examples.</p>
</td></tr>
<tr><td><code id="string_get_+3A_pattern">pattern</code></td>
<td>
<p>(If provided, elements of <code>...</code> are ignored.) A character vector representing the
patterns to be found. By default a (perl) regular-expression search is triggered.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: &quot;ignore/sepal&quot; would get &quot;Sepal.Length&quot; (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: &quot;if/dt[&quot; would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with &quot;&quot;.</p>
</td></tr>
<tr><td><code id="string_get_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to <code><a href="#topic+string_is">string_is()</a></code>.
</p>


<h3>Value</h3>

<p>It always return a character vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stget()</code>: Alias to <code>string_get</code>
</p>
</li></ul>


<h3>Caching</h3>

<p>In an exploratory stage, it can be useful to quicky get values from a vector with the
least hassle as possible. Hence <code>string_get</code> implements caching, so that users do not need
to repeat the value of the argument <code>x</code> in successive function calls, and can concentrate
only on the selection patterns.
</p>
<p>Caching is a feature only available when the user calls <code>string_get</code> from the global environment.
If that feature were available in regular code, it would be too dangerous, likely leading to hard to debug bugs.
Hence caching is disabled when used within code (i.e. inside a function or inside an
automated script), and function calls without the main argument will lead to errors in such scripts.
</p>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rownames(mtcars)

# find all Mazda cars
string_get(x, "Mazda")
# same with ignore case flag
string_get(x, "i/mazda")

# all cars containing a single digit (we use the 'word' flag)
string_get(x, "w/\\d")

# finds car names without numbers AND containing `u`
string_get(x, "!\\d", "u")
# equivalently
string_get(x, "!\\d &amp; u")

# Stacks all Mazda and Volvo cars. Mazda first
string_get(x, "Mazda", "Volvo", seq = TRUE)

# Stacks all Mazda and Volvo cars. Volvo first
string_get(x, "Volvo", "Mazda", seq = TRUE)

# let's get the first word of each car name
car_first = string_ops(x, "extract.first")
# we select car brands ending with 'a', then ending with 'i'
string_get(car_first, "a$", "i$", seq = TRUE)
# seq.unik is similar to seq but applies unique()
string_get(car_first, "a$", "i$", seq.unik = TRUE)

#
# flags
#

# you can combine the flags
x = string_magic("/One, two, one... Two!, Microphone, check")
# regular
string_get(x, "one")
# ignore case
string_get(x, "i/one")
# + word boundaries
string_get(x, "iw/one")

# you can escape the meaning of ! with backslashes
string_get(x, "\\!")

#
# Caching
#

# Caching is enabled when the function is used interactively
# so you don't need to repeat the argument 'x'
# Mostly useful at an exploratory stage

if(interactive() &amp;&amp; is.null(sys.calls())){
   
   # first run, the data is cached
   string_get(row.names(mtcars), "i/vol")

   # now you don't need to specify the data
   string_get("i/^m &amp; 4")
}




</code></pre>

<hr>
<h2 id='string_is'>Detects whether a pattern is in a character string</h2><span id='topic+string_is'></span><span id='topic+string_any'></span><span id='topic+string_all'></span><span id='topic+string_which'></span><span id='topic+st_is'></span><span id='topic+st_any'></span><span id='topic+st_all'></span><span id='topic+stwhich'></span>

<h3>Description</h3>

<p>Function that detects if one or more patterns are in a string. The patterns can be
chained, by default this is a regex search but special flags be triggered with a
specific syntax, supports negation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_is(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame(),
  last = NULL
)

string_any(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

string_all(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

string_which(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

st_is(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame(),
  last = NULL
)

st_any(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

st_all(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)

stwhich(
  x,
  ...,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  or = FALSE,
  pattern = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_is_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_is_+3A_...">...</code></td>
<td>
<p>Character scalars representing the patterns to be found. By default they are (perl) regular-expressions.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: &quot;ignore/sepal&quot; would get &quot;Sepal.Length&quot; (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: &quot;if/dt[&quot; would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with &quot;&quot;.</p>
</td></tr>
<tr><td><code id="string_is_+3A_fixed">fixed</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to trigger a fixed search instead of a
regular expression search (default).</p>
</td></tr>
<tr><td><code id="string_is_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_is_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_is_+3A_or">or</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. In the presence of two or more patterns,
whether to combine them with a logical &quot;or&quot; (the default is to combine them with a logical &quot;and&quot;).</p>
</td></tr>
<tr><td><code id="string_is_+3A_pattern">pattern</code></td>
<td>
<p>(If provided, elements of <code>...</code> are ignored.) A character vector representing the
patterns to be found. By default a (perl) regular-expression search is triggered.
Use ' &amp; ' or ' | ' to chain patterns and combine their result logically (ex: <code>'[[:alpha:]] &amp; \\d'</code> gets strings
containing both letters and numbers). You can negate by adding a <code>!</code> first (ex: <code>"!sepal$"</code> will
return <code>TRUE</code> for strings that do not end with <code>"sepal"</code>).
Add flags with the syntax 'flag1, flag2/pattern'. Available flags are: 'fixed', 'ignore', 'word' and 'magic'.
Ex: &quot;ignore/sepal&quot; would get &quot;Sepal.Length&quot; (wouldn't be the case w/t 'ignore').
Shortcut: use the first letters of the flags. Ex: &quot;if/dt[&quot; would get <code>"DT[i = 5]"</code> (flags 'ignore' + 'fixed').
For 'word', it adds word boundaries to the pattern. The <code>magic</code> flag first interpolates
values directly into the pattern with &quot;&quot;.</p>
</td></tr>
<tr><td><code id="string_is_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
<tr><td><code id="string_is_+3A_last">last</code></td>
<td>
<p>A function or <code>NULL</code> (default). If a function, it will be applied to the vector
just before returning it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal function used to find the patterns is <code><a href="base.html#topic+grep">base::grepl()</a></code> with <code>perl = TRUE</code>.
</p>


<h3>Value</h3>

<p>It returns a logical vector of the same length as <code>x</code>.
</p>
<p>The function <code>string_which</code> returns a numeric vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_any()</code>: Detects if at least one element of a vector matches a regex pattern
</p>
</li>
<li> <p><code>string_all()</code>: Detects if all elements of a vector match a regex pattern
</p>
</li>
<li> <p><code>string_which()</code>: Returns the indexes of the values in which a pattern is detected
</p>
</li>
<li> <p><code>st_is()</code>: Alias to <code>string_is</code>
</p>
</li>
<li> <p><code>st_any()</code>: Alias to <code>string_any</code>
</p>
</li>
<li> <p><code>st_all()</code>: Alias to <code>string_all</code>
</p>
</li>
<li> <p><code>stwhich()</code>: Alias to <code>string_which</code>
</p>
</li></ul>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# NOTA: using `string_get` instead of `string_is` may lead to a faster understanding 
#       of the examples 

x = string_vec("One, two, one... two, microphone, check")

# default is regular expression search
# =&gt; 3 character items
string_is(x, "^...$")

# to trigger fixed search use the flag 'fixed'
string_is(x, "fixed/...")
# you can just use the first letter
string_is(x, "f/...")

# to negate, use '!' as the first element of the pattern
string_is(x, "f/!...")

# you can combine several patterns with " &amp; " or " | "
string_is(x, "one &amp; c")
string_is(x, "one | c")

#
# word: adds word boundaries
#

# compare
string_is(x, "one")
# with
string_is(x, "w/one")

# words can be chained with commas (it is like an OR logical operation)
string_is(x, "w/one, two")
# compare with
string_is(x, "w/one &amp; two")
# remember that you can still negate
string_is(x, "w/one &amp; !two")

# you can combine the flags
# compare
string_is(x, "w/one")
# with
string_is(x, "wi/one")

#
# the `magic` flag
#

p = "one"
string_is(x, "m/{p}")
# Explanation:
# - "p" is interpolated into "one"
# - we get the equivalent: string_is(x, "one")


#
# string_which
#

# it works exactly the same way as string_is
# Which are the items containing an 'e' and an 'o'?
string_which(x, "e", "o")
# equivalently
string_which(x, "e &amp; o")


</code></pre>

<hr>
<h2 id='string_magic'>String interpolation with operation chaining</h2><span id='topic+string_magic'></span><span id='topic+.string_magic'></span><span id='topic+sma'></span>

<h3>Description</h3>

<p>This is firstly a string interpolation tool. On top of this it can apply, and chain, over 50
basic string operations to the interpolated variables. Advanced support for pluralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_magic(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .post = NULL,
  .nest = FALSE,
  .collapse = NULL,
  .invisible = FALSE,
  .default = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .class = NULL,
  .help = NULL,
  .namespace = NULL
)

.string_magic(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .collapse = NULL,
  .last = NULL,
  .nest = FALSE,
  .trigger = TRUE,
  .namespace = NULL
)

sma(
  ...,
  .envir = parent.frame(),
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .post = NULL,
  .nest = FALSE,
  .collapse = NULL,
  .invisible = FALSE,
  .default = NULL,
  .trigger = TRUE,
  .check = TRUE,
  .class = NULL,
  .help = NULL,
  .namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_magic_+3A_...">...</code></td>
<td>
<p>Character scalars that will be collapsed with the argument <code>sep</code>. Note that
named arguments are used for substitution.
</p>
<p>To interpolate, you can
use <code>"{x}"</code> within each character string to insert the value of <code>x</code> in the string.
You can add string operations in each <code>"{}"</code> instance with the syntax <code>"'arg'op ? x"</code>
(resp. <code>"'arg'op ! x"</code>) to apply the operation <code>'op'</code> with the argument <code>'arg'</code> to <code>x</code>
(resp. the verbatim of <code>x</code>). Otherwise, what to say? Ah, nesting is enabled, and since
there's over 50 operators, it's a bit complicated to sort you out in this small space.
</p>
<p>Use the argument <code>.help = "keyword"</code> (or <code>.help = TRUE</code>) to obtain a selective help
from the main documentation.
</p>
<p>Note that in interpolations you have access to the special variables: <code>.now</code> and <code>.date</code>
to get the current time; and the special function <code>.now("format")</code> to
format the time. Ex: <code>.now('%Y-%m %H:%m')</code>.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.envir">.envir</code></td>
<td>
<p>An environment used to evaluate the variables in <code>"{}"</code>. By default the variables are
evaluated using the environment from where the function is called or using the named
arguments passed to the function.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.sep">.sep</code></td>
<td>
<p>Character scalar, default is the empty string <code>""</code>. It is used to collapse all
the elements in <code>...</code> before applying any operation.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.vectorize">.vectorize</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, Further, elements in <code>...</code> are
NOT collapsed together, but instead vectorised.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.delim">.delim</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("{", "}")</code>. Defines
the opening and the closing delimiters for interpolation.
</p>
<p>If of length 1, it must be of the form: 1) the opening delimiter,
2) a single space, 3) the closing delimiter. Ex: <code>".[ ]"</code> is equivalent to <code>c(".[", "]")</code>.
The default value is equivalent to <code>"{ }"</code>.
</p>
<p>[ ]: R:%20
[&quot;, &quot;]: R:%22,%20%22</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.last">.last</code></td>
<td>
<p>Character scalar, a function, or <code>NULL</code> (default). If provided and character:
it must be an <code>string_magic</code> chain of operations of the form <code>"'arg1'op1, op2, etc"</code>. All these operations
are applied just before returning the vector. If a function,
it will be applied to the resulting vector.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.post">.post</code></td>
<td>
<p>Function or <code>NULL</code> (default). If not <code>NULL</code>, this function will be applied
after all the processing, just before returning the object. This function can have
extra arguments which will be caught directly in the <code>...</code> argument of <code>string_magic</code>.
For example if <code>.post = head</code>, you can directly pass the argument <code>n = 3</code> to <code>string_magic</code>'s arguments.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.nest">.nest</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, it will nest the original string within
interpolation delimiters, so that you can apply operations directly on the string. Example:
<code>string_magic("upper ! hello")</code> returns &quot;upper ! hello&quot;, while <code>string_magic("upper ! hello", .nest = TRUE)</code>
returns <code>"HELLO"</code>.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.collapse">.collapse</code></td>
<td>
<p>Character scalar, default is <code>NULL</code>. If provided, the character vector
that should be returned is collapsed with the value of this argument. This leads
to return a string of length 1.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.invisible">.invisible</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether the object returned should be
invisible (i.e. not printed on the console).</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.default">.default</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If provided, it must be
a sequence of <code>string_magic</code> operations. It will be applied as a default to any interpolation.
Ex: if <code>x = 1:2</code>, then <code>string_magic("x = {x}", .default = "enum")</code> leads to &quot;x = 1 and 2&quot;,
and is equivalent to <code>string_magic("x = {enum?x}")</code>. Note that this default operations does
not apply to nested expressions. That is <code>string_magic("{!x{1:2}}", .default = "enum")</code> leads
to <code>c("x1", "x2")</code> and NOT <code>"x1 and 2"</code>.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.trigger">.trigger</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code>, this function is not run. Can be
useful in debugging situations where we want conditional evaluations.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.check">.check</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to enable error-handling (i.e.
human readable error messages).
Without error-handling you can save something of the order of 40us. Useful only
in long loops.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.class">.class</code></td>
<td>
<p>Character vector representing the class to give to the object returned.
By default it is <code>NULL</code>. Note that the class <code>string_magic</code> has a specific <code>print</code> method, usually
nicer for small vectors (it <code><a href="base.html#topic+cat">base::cat()</a></code>s the elements).</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.help">.help</code></td>
<td>
<p>Character scalar or <code>TRUE</code>, default is <code>NULL</code>. This argument
is used to generate a dynamic help on the console. If <code>TRUE</code>, the user can select which
topic to read from the main documentation, with the possibility to search for keywords and
navigate the help pages. If a character scalar, then a regex search is perfomed on the main
documentation and any section containining a match is displayed. The user can easily
navigate across matches.</p>
</td></tr>
<tr><td><code id="string_magic_+3A_.namespace">.namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are over 50 basic string operations, it supports pluralization, string operations can be
nested, operations can be applied group-wise or conditionally and
operators have sensible defaults.
You can also declare your own operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.
They will be seamlessly integrated to <code>string_magic</code>.
</p>
<p>The function <code>.string_magic</code> (prefixed with a dot) is a leaner version of the function <code>string_magic</code>.
It does the same operations but with the following differences:
</p>

<ul>
<li><p> there is no error handling: meaning that the error messages, if any, will be poor and
hard to understand
</p>
</li>
<li><p> default options are not applied: hence the user must always explicitly provide the arguments
</p>
</li></ul>

<p>This leads to a faster processing time (of about 50 microseconds) at the cost of user experience.
</p>
<p>If you want to change the default values of <code>string_magic</code> (like changing the delimiter), use
the function <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code>.
</p>
<p>Use the argument <code>.help</code> to which
you can pass keywords or regular expressions and fecth select pieces from the main documentation.
</p>


<h3>Value</h3>

<p>It returns a character vector whose length depends on the elements and operations in the interpolations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_magic()</code>: String interpolation with operation chaining
</p>
</li>
<li> <p><code>.string_magic()</code>: A simpler version of <code>string_magic</code> without any error handling to save a few micro seconds
</p>
</li>
<li> <p><code>sma()</code>: Alias to <code>string_magic</code>
</p>
</li></ul>


<h3>Interpolation and string operations</h3>

<p>Principle:
</p>
<p>To interpolate a variable, say <code>x</code>, simply use <code>{x}</code>. For example <code style="white-space: pre;">&#8288;x = "world"; string_magic("hello {x}")&#8288;</code> leads
to &quot;hello world&quot;.
</p>
<p>To any interpolation you can add operations. Taking the previous example, say we want to display
&quot;hello W O R L D&quot;. This means upper casing all letters of the interpolated variable and adding a space between
each of them. Do you think we can do that? Of course yes:
<code>string_magic("hello {upper, ''s, c ? x}")</code>. And that's it.
</p>
<p>Now let's explain what happened. Within the <code>{}</code> <em>box</em>, we first write a set of
operations, here &quot;upper, &rdquo;s, c&quot;, then add &quot;?&quot; and finally write
the variable to interpolate, &quot;x&quot;.  The operations (explained in more details
below) are <code>upper</code>, upper-casing all letters, &rdquo;s: splitting
with the empty string, 'c': concatenating with spaces the vector of string that was just split.
The question mark means that the expression coming after it is to be evaluated
(this is opposed to the exclamation mark presented next).
</p>
<p>The syntax is always the same: <code>{operations ? expression}</code>, where the operations section
is a <em>comma separated</em> list of operations.
These operations are of the form <code style="white-space: pre;">&#8288;'arg'op&#8288;</code>, with <code>arg</code> the argument to the operator
code <code>op</code>. These operations are performed sequantially from left to right.
</p>
<p>Some operations, like <code>upper</code>, accept options. You attach options to an operation
with a dot followed by the option name. Formally: <code>op.option1.option2</code>, etc.
Example: <code style="white-space: pre;">&#8288;x = "hi there. what's up? fine." ; string_magic("He said: {upper.sentence, Q ? x}")&#8288;</code>.
Leads to: <code style="white-space: pre;">&#8288;He said: "Hi there. What's up? Fine."&#8288;</code>.
</p>
<p>Both operators and options are partially matched. So <code>string_magic("He said: {up.s, Q ? x}")</code> would
also work.
</p>


<h3>Verbatim interpolation and nesting</h3>

<p>Principle:
</p>
<p>Instead of interpolating a variable, say <code>x</code>, with <code>{x}</code>, you can use an exclamation
mark to trigger varbatim evaluation.
For example <code>string_magic("hello {!x}")</code> would lead to &quot;hello x&quot;. It's a
bit disappointing, right? What's the point of doing that? Wait until the next two paragraphs.
</p>
<p>Verbatim evaluation is a powerful way to apply operations to plain text. For example:
<code>string_magic("hello {upper, ''s, c ! world}")</code> leads to &quot;hello W O R L D&quot;.
</p>
<p>(A note in passing. The spaces surrounding the exclamation mark are non necessary,
but when one space is present on both sides of the <code>!</code>, then the verbatim
expression only begins after it. Ex: <code>"{upper! hi}"</code> leads to &quot; HI&quot; while <code>"{upper ! hi}"</code>
leads to &quot;HI&quot; and <code>"{upper !  hi}"</code> leads to &quot; HI&quot;.)
</p>
<p>The second advantage of verbatim evaluations is <em>nesting</em>. Anything in a verbatim
expression is evaluated with the function <code>string_magic</code>.
This means that any <em>box</em> will be evaluated as previously described. Let's
give an example. You want to write the expression of a polynomial of order n: a + bx + cx^2 + etc.
You can do that with nesting. Assume we have <code>n = 2</code>.
</p>
<p>Then <code>string_magic("poly({n}): {' + 'c ! {letters[1 + 0:n]}x^{0:n}}")</code> leads to
&quot;poly(2): ax^0 + bx^1 + cx^2&quot;.
</p>
<p>How does it work? The verbatim expression (the one following the exclamation mark),
here <code>"{letters[1 + 0:n]}x^{0:n}"</code>, is evaluated with <code>string_magic</code>.
<code>string_magic("{letters[1 + 0:n]}x^{0:n}")</code> leads to the vector c(&quot;ax^0&quot;, &quot;bx^1&quot;, &quot;cx^2&quot;).
</p>
<p>The operation <code style="white-space: pre;">&#8288;' + 'c&#8288;</code> then concatenates (or collapses) that vector with ' + '.
This value is then appended to the previous string.
</p>
<p>We could refine by adding a cleaning operation in which we replace &quot;x^0&quot; and &quot;^1&quot;
by the empty string. Let's do it:
</p>
<p><code>string_magic("poly({n}): {' + 'c, 'x\\^0|\\^1'r ! {letters[1 + 0:n]}x^{0:n}}")</code> leads to
&quot;poly(2): a + bx + cx^2&quot;, what we wanted.
</p>
<p>You can try to write a function to express the polynomial as before: although it is
a simple task, my guess is that it will require more typing.
</p>


<h3>Operations</h3>

<p>General syntax:
</p>
<p>As seen in the previous sections, within a <em>box</em> (i.e. <code>"{}"</code>), multiple operations
can be performed.
We can do so by stacking the operations codes and in a comma separated enumeration.
Operations can have arguments, and operations can also have options. The general
syntax, with argument and options, is:
</p>
<p><code style="white-space: pre;">&#8288;{'arg1'op1.optionA.optionB, arg2 op2.optionC, &#8288;</code>arg3<code style="white-space: pre;">&#8288;op3, 51op4 ? x}&#8288;</code>
</p>
<p>The argument can appear in four forms: a) inside single or double quotes just
before the operation name (<code>arg1</code> above),
b) verbatim, separated with a space, just before the operation name (<code>arg2</code> above),
c) inside bactick quotes the argument is evaluated from the environment (<code>arg3</code> above),
or d) when the argument is an integer it can be juxtaposed to the opeation name (like in <code>op4</code> above).
</p>
<p>The options are always dot separated and attached to the operation name, they are
specific to each operation.
</p>
<p>Both the operation name and the option names are partially matched.
</p>


<h3>Basic string operations</h3>

<p>This section describes some of the most common string operations: extracting, replacing, collapsing, splitting, etc.
These functions accept generic flags (&quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot;) in their patterns (syntax: &quot;flags/pattern&quot;).
Please see the dedicated section for more information on flags.
</p>

<ul>
<li><p> s, split, S, Split: splits the string according to a pattern.
The operations have different defaults: <code>' '</code>
for <code>s</code> and 'split', and <code>',[ \t\n]*'</code> for <code>S</code> and 'Split' (i.e. comma separation).
Ex.1: <code>string_magic("{S ! romeo, juliet}")</code> leads to the vector c(&quot;romeo&quot;, &quot;juliet&quot;).
Ex.2: <code>string_magic("{'f/+'s, '-'c ! 5 + 2} = 3")</code> leads to &quot;5 - 2 = 3&quot; (note the flag &quot;fixed&quot; in <code>s</code>'s pattern).
</p>
</li>
<li><p> c, C: to concatenate multiple strings into a single one. The two operations are
identical, only their default change. c: default is <code>' '</code>, C: default is <code>', | and '</code>.
The syntax of the argument is 's1' or 's1|s2'. s1 is the string used to concatenate
(think <code>paste(x, collapse = s1)</code>). In arguments of the form <code>'s1|s2'</code>, <code>s2</code> will be used to concatenate the last two elements.
Ex.1: <code style="white-space: pre;">&#8288;x = 1:4; string_magic("Et {' et 'c ? x}!")&#8288;</code> leads to &quot;Et 1 et 2 et 3 et 4!&quot;.
Ex.2: <code>string_magic("Choose: {', | or 'c ? 2:4}?")</code> leads to &quot;Choose: 2, 3 or 4?&quot;.
</p>
</li>
<li><p> x, X: extracts patterns from a string. Both have the same default: <code>'[[:alnum:]]+'</code>.
<code>x</code> extracts the first match while <code>X</code> extracts <strong>all</strong> the matches.
Ex.1: <code style="white-space: pre;">&#8288;x = c("6 feet under", "mahogany") ; string_magic("{'\\w{3}'x ? x}")&#8288;</code> leads to the vector c(&quot;fee&quot;, &quot;mah&quot;).
Ex2.: <code style="white-space: pre;">&#8288;x = c("6 feet under", "mahogany") ; string_magic("{'\\w{3}'X ? x}")&#8288;</code> leads to the
vector c(&quot;fee&quot;, &quot;und&quot;, &quot;mah&quot;, &quot;oga&quot;).
</p>
</li>
<li><p> extract: extracts multiple patterns from a string, this is an alias to the operation <code>X</code> described above.
Use the option &quot;first&quot; to extract only the first match for each string (behavior becomes like <code>x</code>).
Ex: <code style="white-space: pre;">&#8288;x = c("margo: 32, 1m75", "luke doe: 27, 1m71") ; string_magic("{'^\\w+'extract ? x} is {'\\d+'extract.first ? x}")&#8288;</code>
leads to c(&quot;margo is 32&quot;, &quot;luke is 27&quot;).
</p>
</li>
<li><p> r, R: replacement within a string. The two operations are identical and have no default.
The syntax is <code>'old'</code> or <code>'old =&gt; new'</code> with <code>'old'</code> the pattern to find and <code>new</code> the replacement. If <code>new</code> is missing, it is
considered the empty string. This operation also accepts the flag &quot;total&quot; which instruct to
replace the fulll string in case the pattern is found.
Ex.1: <code>string_magic("{'e'r ! Where is the letter e?}")</code> leads to &quot;Whr is th lttr ?&quot;.
Ex.2: <code>string_magic("{'(?&lt;!\\b)e =&gt; a'R ! Where is the letter e?}")</code> leads to &quot;Whara is tha lattar e?&quot;.
Ex.3: <code>string_magic("{'t/e =&gt; here'r ! Where is the letter e?}")</code> leads to &quot;here&quot;.
</p>
</li>
<li><p> clean: replacement with a string. Similar to the operation <code>r</code>, except that here the comma is
a pattern separator, see detailed explanations in <code><a href="#topic+string_clean">string_clean()</a></code>. Ex: <code>string_magic("{'f/[, ]'clean ! x[a]}")</code>
leads to &quot;xa&quot;.
</p>
</li>
<li><p> get: restricts the string only to values respecting a pattern. This operation has no default.
Accepts the options &quot;equal&quot; and &quot;in&quot;.
By default it uses the same syntax as <code><a href="#topic+string_get">string_get()</a></code> so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option &quot;equal&quot; is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option &quot;in&quot; is used, the argument is first split with respect to commas
and then set inclusion is tested.
Example: <code style="white-space: pre;">&#8288;x = row.names(mtcars) ; string_magic("Mercedes models: {'Merc &amp; [[:alpha:]]$'get, '^.+ 'r, C ? x}")&#8288;</code>
leads to &quot;Mercedes models: 240D, 280C, 450SE, 450SL and 450SLC&quot;.
</p>
</li>
<li><p> is: detects if a pattern is present in a string, returns a logical vector. This operation has no default.
Accepts the options &quot;equal&quot; and &quot;in&quot;.
By default it uses the same syntax as <code><a href="#topic+string_is">string_is()</a></code> so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option &quot;equal&quot; is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option &quot;in&quot; is used, the argument is first split with respect to commas
and then set inclusion is tested.
Mostly useful as the final operation in a <code><a href="#topic+string_ops">string_ops()</a></code> call.
Example: <code style="white-space: pre;">&#8288;x = c("Mark", "Lucas") ; string_magic("Mark? {'i/mark'is, C ? x}")&#8288;</code> leads to &quot;Mark? TRUE and FALSE&quot;.
</p>
</li>
<li><p> which: returns the index of string containing a specified pattern. With no default, can be applied
to a logical vector directly.
By default it uses the same syntax as string_which() so that you can use regex flags and
include logical operations with <code>' &amp; '</code> and <code>' | '</code> to detect patterns.
If the option &quot;equal&quot; is used, a simple string equality with the argument is tested (hence
no flags are accepted). If the option &quot;in&quot; is used, the argument is first split with respect to commas
and then set inclusion is tested.
Mostly useful as the final operation in a <code><a href="#topic+string_ops">string_ops()</a></code> call.
Ex.1: <code style="white-space: pre;">&#8288;x = c("Mark", "Lucas") ; string_magic("Mark is number {'i/mark'which ? x}.")&#8288;</code> leads to
&quot;Mark is number 1.&quot;.
</p>
</li></ul>



<h3>Operations changing the length or the order</h3>


<ul>
<li><p> first: keeps only the first <code>n</code> elements. Example: <code>string_magic("First 3 numbers: {3 first, C ? mtcars$mpg}.")</code>
leads to &quot;First 3 numbers: 21, 21 and 22.8.&quot;. Negative numbers as argument remove the
first <code>n</code> values. You can add a second argument in the form <code style="white-space: pre;">&#8288;'n1|n2'first&#8288;</code> in which case the first <code>n1</code> and last
<code>n2</code> values are kept; <code>n1</code> and <code>n2</code> must be positive numbers.
</p>
</li>
<li><p> K, Ko, KO: keeps only the first <code>n</code> elements; has more options than <code>first</code>. The syntax is <code style="white-space: pre;">&#8288;'n'K&#8288;</code>,
<code style="white-space: pre;">&#8288;'n|s'K&#8288;</code>, <code style="white-space: pre;">&#8288;'n||s'K&#8288;</code>. The values Ko and KO only accept the two first syntax (with <code>n</code> only).
<code>n</code> provides the number of elements to keep. If <code>s</code> is provided and the number of
elements are greater than <code>n</code>, then in 'n|s' the string <code>s</code> is added at the end, and
if 'n||s' the string s replaces the nth element.
The string <code>s</code> accepts specials values:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;:n:&#8288;</code> or <code style="white-space: pre;">&#8288;:N:&#8288;</code> which gives the total number of items in digits or letters (N)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;:rest:&#8288;</code> or <code style="white-space: pre;">&#8288;:REST:&#8288;</code> which gives the number of elements that have been truncated in digits or letters (REST)
Ex: <code>string_magic("{'3|:rest: others'K ? 1:200}")</code> leads to the vector <code>c("1", "2", "3", "197 others")</code>.
</p>
</li>
<li><p> The operator 'n'Ko is like <code style="white-space: pre;">&#8288;'n||:rest: others'K&#8288;</code> and 'n'KO is like <code style="white-space: pre;">&#8288;'n||:REST: others'K&#8288;</code>.
</p>
</li></ul>

</li>
<li><p> last: keeps only the last <code>n</code> elements. Example: <code>string_magic("Last 3 numbers: {3 last, C ? mtcars$mpg}.")</code>
leads to &quot;Last 3 numbers: 19.7, 15 and 21.4.&quot;. Negative numbers as argument remove the
last <code>n</code> values.
</p>
</li>
<li><p> sort: sorts the vector in increasing order. Accepts optional arguments and the option &quot;num&quot;.
Example: <code style="white-space: pre;">&#8288;x = c("sort", "me") ; string_magic("{sort, c ? x}")&#8288;</code> leads to &quot;me sort&quot;.
If an argument is provided, it must be a regex pattern that will be applied to
the vector using <code><a href="#topic+string_clean">string_clean()</a></code>. The sorting will be applied to the modified version of the vector
and the original vector will be ordered according to this sorting.
Ex: <code>x = c("Jon Snow", "Khal Drogo")</code>; <code>string_magic("{'.+ 'sort, C?x}")</code> leads to
&quot;Khal Drogo and Jon Snow&quot;. The option &quot;num&quot; sorts over a numeric version
(with silent conversion) of the vector and reorders the original vector accordingly.
Values which could not be converted are last.
<strong>Important note</strong>: the sorting operation is applied before any character conversion.
If previous operations were applied, it is likely that numeric data were transformed to character.
Note the difference: <code style="white-space: pre;">&#8288;x = c(20, 100, 10); string_magic("{sort, ' + 'c ? x}")&#8288;</code> leads to &quot;10 + 20 + 100&quot;
while <code>string_magic("{n, sort, ' + 'c ? x}")</code> leads to &quot;10 + 100 + 20&quot; because the operation &quot;n&quot;
first transformed the numeric vector into character.
</p>
</li>
<li><p> dsort: sorts the vector in decreasing order. It accepts an optional argument and
the option &quot;num&quot;. Example: <code>string_magic("5 = {dsort, ' + 'c ? 2:3}")</code>
leads to &quot;5 = 3 + 2&quot;. See the operation &quot;sort&quot; for a description of the argument and the option.
</p>
</li>
<li><p> rev: reverses the vector. Example: <code>string_magic("{rev, ''c ? 1:3}")</code> leads to &quot;321&quot;.
</p>
</li>
<li><p> unik: makes the string vector unique. Example: <code>string_magic("Iris species: {unik, C ? iris$Species}.")</code>
leads to &quot;Iris species: setosa, versicolor and virginica.&quot;.
</p>
</li>
<li><p> each: repeats each element of the vector <code>n</code> times. Option &quot;c&quot; then collapses the full vector
with the empty string as a separator. Ex.1: <code>string_magic("{/x, y}{2 each ? 1:2}")</code> leads to the
vector <code>c("x1", "y1", "x2", "y2")</code>. Ex.2: <code>string_magic("Large number: 1{5 each.c ! 0}")</code> leads to
&quot;Large number: 100000&quot;.
</p>
</li>
<li><p> times: repeats the vector sequence <code>n</code> times. Option &quot;c&quot; then collapses the full vector
with the empty string as a separator. Example: <code>string_magic("What{6 times.c ! ?}")</code> leads to &quot;What??????&quot;.
</p>
</li>
<li><p> rm: removes elements from the vector. Options: &quot;empty&quot;, &quot;blank&quot;, &quot;noalpha&quot;, &quot;noalnum&quot;, &quot;all&quot;.
The <em>optional</em> argument represents the pattern used to detect strings to be deleted.
Ex.1: <code>x = c("Luke", "Charles")</code>; <code>string_magic("{'i/lu'rm ? x}")</code> leads to &quot;charles&quot;. By default it removes
empty strings. Option &quot;blank&quot; removes strings containing only blank characters (spaces, tab, newline).
Option &quot;noalpha&quot; removes strings not containing letters. Option &quot;noalnum&quot; removes strings not
containing alpha numeric characters. Option &quot;all&quot; removes all strings (useful in conditions, see
the dedicated section). If an argument is provided, only the options &quot;empty&quot; and &quot;blank&quot; are available.
Ex.2: <code>x = c("I want to enter.", "Age?", "21")</code>; <code>string_magic("Nightclub conversation: {rm.noalpha, c ! - {x}}")</code>
leads to &quot;Nightclub conversation: - I want to enter. - Age?&quot;
</p>
</li>
<li><p> nuke: removes all elements, equivalent to <code>rm.all</code> but possibly more explicit (not sure).
Useful in conditions, see the dedicated section.
Example: <code style="white-space: pre;">&#8288;x = c(5, 7, 453, 647); string_magic("Small numbers only: {if(.&gt;20 ; nuke), C ? x}")&#8288;</code> leads
to &quot;Small numbers only: 5 and 7&quot;;
</p>
</li>
<li><p> insert: inserts a new element to the vector. Options: &quot;right&quot; and &quot;both&quot;. Option &quot;right&quot; adds
the new element to the right. Option &quot;both&quot; inserts the new element on the two sides of the vector.
Example: <code>string_magic("{'3'insert.right, ' + 'c ? 1:2}")</code> leads to &quot;1 + 2 + 3&quot;.
</p>
</li>
<li> <p><code>dp</code> or <code>deparse</code>: Deparses an object and keeps only the first characters of
the deparsed string. Accepts a number as argument. In that case only the first <code>n</code>
characters are kept. Accepts option <code>long</code>: in that case all the
lines of the deparsed object are first collapsed.
Example: <code style="white-space: pre;">&#8288;fml = y ~ x1 + x2; string_magic("The estimated model is {dp ? fml}.")&#8288;</code>
</p>
</li></ul>



<h3>Formatting operations</h3>


<ul>
<li><p> lower: lower cases the full string.
</p>
</li>
<li><p> upper: upper cases the full string. Options: &quot;first&quot; and &quot;sentence&quot;.
Option &quot;first&quot; upper cases only the first character. Option &quot;sentence&quot;
upper cases the first letter after punctuation.
Ex: <code style="white-space: pre;">&#8288;x = "hi. how are you? fine." ; string_magic("{upper.sentence ? x}")&#8288;</code> leads
to &quot;Hi. How are you? Fine.&quot;.
</p>
</li>
<li><p> title: applies a title case to the string. Options: &quot;force&quot; and &quot;ignore&quot;.
Option &quot;force&quot; first puts everything to lowercase before applying the title case.
Option &quot;ignore&quot; ignores a few small prepositions (&quot;a&quot;, &quot;the&quot;, &quot;of&quot;, etc).
Ex: <code style="white-space: pre;">&#8288;x = "bryan is in the KITCHEN" ; string_magic("{title.force.ignore ? x}")&#8288;</code> leads to &quot;Bryan Is in the Kitchen&quot;.
</p>
</li>
<li><p> ws: normalizes whitespaces (WS). It trims the whitespaces on the edges and transforms any succession
of whitespaces into a single one. Can also be used to further clean the string with its options.
Options: &quot;punct&quot;, &quot;digit&quot;, &quot;isolated&quot;. Option &quot;punct&quot; cleans the punctuation. Option &quot;digit&quot; cleans digits.
Option &quot;isolated&quot; cleans isolated letters. WS normalization always come after any of these options.
<strong>Important note:</strong> punctuation (or digits) are replaced with WS and <strong>not</strong>
the empty string. This means that <code>string_magic("ws.punct ! Meg's car")</code> will become &quot;Meg s car&quot;.
</p>
</li>
<li><p> trimws: trims the white spaces on both ends of the strings.
</p>
</li>
<li><p> q, Q, bq: to add quotes to the strings. q: single quotes, Q: double quotes, bq:
back quotes. <code style="white-space: pre;">&#8288;x = c("Mark", "Pam"); string_magic("Hello {q, C ? x}!")&#8288;</code> leads to &quot;Hello 'Mark' and 'Pam'!&quot;.
</p>
</li>
<li><p> format, Format: applies the base R's function <code><a href="base.html#topic+format">base::format()</a></code> to the string.
By default, the values are left aligned, <em>even numbers</em> (differently from <code><a href="base.html#topic+format">base::format()</a></code>'s behavior).
The upper case command (<code>Format</code>) applies right alignment. Options: &quot;0&quot;, &quot;zero&quot;, &quot;right&quot;, &quot;center&quot;.
Options &quot;0&quot; or &quot;zero&quot; fills the blanks with 0s: useful to format numbers. Option &quot;right&quot; right aligns,
and &quot;center&quot; centers the strings.
Ex: <code style="white-space: pre;">&#8288;x = c(1, 12345); string_magic("left: {format.0, q, C ? x}, right: {Format, q, C ? x}")&#8288;</code>
leads to &quot;left: '000001' and '12,345', right: '     1' and '12,345'&quot;.
</p>
</li>
<li><p> %: applies <code><a href="base.html#topic+sprintf">base::sprintf()</a></code> formatting. The syntax is 'arg'% with arg an sprintf formatting,
or directly the sprint formatting, e.g. <code style="white-space: pre;">&#8288;% 5s&#8288;</code>. Example: <code>string_magic("pi = {%.3f ? pi}")</code> leads
to &quot;pi = 3.142&quot;.
</p>
</li>
<li><p> stopwords: removes basic English stopwords (the snowball list is used).
The stopwords are replaced with an empty space but the left and right WS are
untouched. So WS normalization may be needed (see operation <code>ws</code>).
<code style="white-space: pre;">&#8288;x = c("He is tall", "He isn't young"); string_magic("Is he {stop, ws, C ? x}?")&#8288;</code> leads to &quot;Is he tall and young?&quot;.
</p>
</li>
<li><p> ascii: turns all letters into ASCII with transliteration. Failed translations
are transformed into question marks. Options: &quot;silent&quot;, &quot;utf8&quot;. By default, if some conversion fails
a warning is prompted. Option &quot;silent&quot; disables the warning in case of failed conversion. The conversion
is done with <code><a href="base.html#topic+iconv">base::iconv()</a></code>, option &quot;utf8&quot; indicates that the source endocing is UTF-8, can be useful
in some cases.
</p>
</li>
<li><p> n: formats integers by adding a comma to separate thousands. Options: &quot;letter&quot;, &quot;upper&quot;, &quot;0&quot;, &quot;zero&quot;.
The option &quot;letter&quot; writes the number in letters (large numbers keep their numeric format). The option
&quot;upper&quot; is like the option &quot;letter&quot; but uppercases the first letter. Options &quot;0&quot; or &quot;zero&quot; left pads
numeric vectors with 0s. Ex.1: <code style="white-space: pre;">&#8288;x = 5; string_magic("He's {N ? x} years old.")&#8288;</code> leads to &quot;He's five years old.&quot;.
Ex.2: <code style="white-space: pre;">&#8288;x = c(5, 12, 52123); string_magic("She owes {n.0, '$'paste, C ? x}.")&#8288;</code> leads to
&quot;She owes $5, $12 and $52,123.&quot;.
</p>
</li>
<li><p> N: same as <code>n</code> but automatically adds the option &quot;letter&quot;.
</p>
</li>
<li><p> nth: when applied to a number, these operators write them as a rank. Options: &quot;letter&quot;,
&quot;upper&quot;, &quot;compact&quot;.
Ex.1: <code style="white-space: pre;">&#8288;n = c(3, 7); string_magic("They finished {nth, enum ? n}!")&#8288;</code> leads to &quot;They finished 3rd and 7th!&quot;.
Option &quot;letter&quot; tries to write the numbers in letters, but note that it stops at 20. Option &quot;upper&quot;
is the same as &quot;letter&quot; but uppercases the first letter. Option &quot;compact&quot; aggregates
consecutive sequences in the form &quot;start_n_th to end_n_th&quot;.
Ex.2: <code>string_magic("They arrived {nth.compact ? 5:20}.")</code> leads to &quot;They arrived 5th to 20th.&quot;.
Nth: same as <code>nth</code>, but automatically adds the option &quot;letter&quot;. Example:
<code style="white-space: pre;">&#8288;n = c(3, 7); string_magic("They finished {Nth, enum ? n}!")&#8288;</code> leads to &quot;They finished third and seventh!&quot;.
</p>
</li>
<li><p> ntimes: write numbers in the form <code>n</code> times. Options: &quot;letter&quot;, &quot;upper&quot;. Option
&quot;letter&quot; writes the number in letters (up to 100). Option &quot;upper&quot; does the same as &quot;letter&quot;
and uppercases the first letter. Example: <code>string_magic("They lost {C ! {ntimes ? c(1, 12)} against {S!Real, Barcelona}}.")</code>
leads to &quot;They lost once against Real and 12 times against Barcelona.&quot;.
</p>
</li>
<li><p> Ntimes: same as <code>ntimes</code> but automatically adds the option &quot;letter&quot;.
Example: <code style="white-space: pre;">&#8288;x = 5; string_magic("This paper was rejected {Ntimes ? x}...")&#8288;</code> leads to
&quot;This paper was rejected five times...&quot;.
</p>
</li>
<li><p> firstchar, lastchar: to select the first/last characters of each element.
Ex: <code>string_magic("{19 firstchar, 9 lastchar ! This is a very long sentence}")</code> leads to &quot;very long&quot;.
Negative numbers remove the first/last characters.
</p>
</li>
<li><p> k: to keep only the first n characters (like <code>firstchar</code> but with more options). The
argument can be of the form <code style="white-space: pre;">&#8288;'n'k&#8288;</code>, <code style="white-space: pre;">&#8288;'n|s'k&#8288;</code> or <code style="white-space: pre;">&#8288;'n||s'k&#8288;</code> with <code>n</code> a number and <code>s</code> a string.
<code>n</code> provides the number of characters to keep. Optionnaly, only for strings whose
length is greater than <code>n</code>, after truncation, the string <code>s</code> can be appended at the end.
The difference between 'n|s' and 'n||s' is that in the second case the strings
will always be of maximum size <code>n</code>, while in the first case they can be of length <code>n + nchar(s)</code>.
Ex: <code>string_magic("{4k ! long sentence}")</code> leads to &quot;long&quot;,  <code>string_magic("{'4|..'k ! long sentence}") </code>
leads to &quot;long..&quot;, <code>string_magic("{'4||..'k ! long sentence}")</code> leads to &quot;lo..&quot;.
</p>
</li>
<li><p> fill: fills the character strings up to a size. Options: &quot;right&quot;, &quot;center&quot;.
Accepts arguments of the form <code>'n'</code> or <code>'n|s'</code>, with <code>n</code> a number and <code>s</code> a symbol.
Default is left-alignment of the strings.
Option &quot;right&quot; right aligns and &quot;center&quot; centers the strings. When using <code>'n|s'</code>, the symbol <code>s</code>
is used for the filling. By default if no argument is provided, the
maximum size of the character string is used. See help for <code><a href="#topic+string_fill">string_fill()</a></code> for more information.
Ex.1: <code>string_magic("Numbers: {'5|0'fill.right, C ? c(1, 55)}")</code> leads to &quot;Numbers: 00001 and 00055&quot;.
</p>
</li>
<li><p> paste, append: pastes some character to all elements of the string. This operation has no default.
Options: &quot;both&quot;, &quot;right&quot;, &quot;front&quot;, &quot;back&quot;, &quot;delete&quot;. By default, a string is pasted on the left.
Option &quot;right&quot; pastes on the right and &quot;both&quot; pastes on both sides. Option &quot;front&quot; only
pastes on the first element while option &quot;back&quot; only pastes on the last element. Option &quot;delete&quot;
first replaces all elements with the empty string.
Example: <code>string_magic("6 = {'|'paste.both, ' + 'c ? -3:-1}")</code> leads to &quot;6 = |-3| + |-2| + |-1|&quot;.
The argument can be of the form <code>s</code> or <code>s1|s2</code>. If of the second form, this is equivalent
to chaining two <code>paste</code> operations, once on the left and once on the right: <code style="white-space: pre;">&#8288;'s1'paste, 's2'paste.right&#8288;</code>.
</p>
</li>
<li><p> join: joins lines ending with a double backslash. Ex: <code>x = "the sun \\\n is shining"</code>;
<code>string_magic("{join ? x}")</code> leads to &quot;the sun is shining&quot;.
</p>
</li>
<li><p> escape: adds backslashes in front of specific characters. Options <code>"nl"</code>, <code>"tab"</code>.
Option <code>"nl"</code> escapes the newlines (<code style="white-space: pre;">&#8288;\n&#8288;</code>), leading them to be displayed as <code>"\\\\n"</code>.
Option <code>"tab"</code> does the same for tabs (<code>"\t"</code>). This is useful to make the value free
of space formatters.
The default behavior is to escape both newlines and tabs.
</p>
</li></ul>



<h3>Other operations</h3>


<ul>
<li><p> num: converts to numeric. Options: &quot;warn&quot;, &quot;soft&quot;, &quot;rm&quot;, &quot;clear&quot;. By default, the conversion
is performed silently and elements that failed to convert are turned into NA.
Option &quot;warns&quot; displays a warning if the conversion to numeric fails.
Option &quot;soft&quot; does not convert if the conversion of at least one element fails.
Option &quot;rm&quot; converts and removes the elements that could not be converted.
Option &quot;clear&quot; turns failed conversions into the empty string, and hence lead to a character vector.
Example: <code style="white-space: pre;">&#8288;x = c(5, "six"); string_magic("Compare {num, C, q ? x} with {num.rm, C, q ? x}.")&#8288;</code> leads to
&quot;Compare '5 and NA' with '5'.&quot;, and <code>string_magic("Compare {num.soft, C, q ? x} with {clear, C, q ? x}.")</code>
leads to &quot;Compare '5 and six' with '5 and '.&quot;.
</p>
</li>
<li><p> enum: enumerates the elements. It creates a single string containing the comma
separated list of elements.
If there are more than 7 elements, only the first 6 are shown and the number of
items left is written.
For example <code>string_magic("enum ? 1:5")</code> leads to &quot;1, 2, 3, 4, and 5&quot;.
You can add the following options by appending the letter to enum after a dot:
</p>

<ul>
<li><p> q, Q, or bq: to quote the elements
</p>
</li>
<li><p> or, nor: to finish with an 'or' (or 'nor') instead of an 'and'
</p>
</li>
<li><p> comma: to finish the enumeration with &quot;, &quot; instead of &quot;, and&quot;.
</p>
</li>
<li><p> i, I, a, A, 1: to enumerate with this prefix, like in: i) one, and ii) two
</p>
</li>
<li><p> a number: to tell the number of items to display
Ex.1: <code style="white-space: pre;">&#8288;x = c("Marv", "Nancy"); string_magic("The main characters are {enum ? x}.")&#8288;</code> leads to
&quot;The main characters are Marv and Nancy.&quot;.
Ex.2: <code style="white-space: pre;">&#8288;x = c("orange", "milk", "rice"); string_magic("Shopping list: {enum.i.q ? x}.")&#8288;</code> leads to
&quot;Shopping list: i) 'orange', ii) 'milk', and iii) 'rice'.&quot;
</p>
</li></ul>

</li>
<li><p> len: gives the length of the vector. Options &quot;letter&quot;, &quot;upper&quot;, &quot;num&quot;.
Option &quot;letter&quot; writes the length in words (up to 100). Option &quot;upper&quot; is the same
as letter but uppercases the first letter.
By default, commas are added to separate thousands. Use uption &quot;num&quot; to preserve
a regular numeric format.
Example: <code>string_magic("Size = {len ? 1:5000}")</code> leads to &quot;Size = 5,000&quot;.
</p>
</li>
<li><p> width: formats the string to fit a given width by cutting at word boundaries.
Accepts arguments of the form <code>'n'</code> or <code>'n|s'</code>, with <code>n</code> a number and <code>s</code> a string.
An argument of the form <code>'n|s'</code> will add <code>s</code> at the beginning of each line. Further,
by default a trailing white space is added to <code>s</code>; to remove this
behavior, add an underscore at the end of it.
The argument <code>n</code> is either
an integer giving the target character width (minimum is 15), or it can be a fraction expressing the
target size as a fraction of the current screen. Finally it can be an expression that
uses the variable <code>.sw</code> which will capture the value of the current screen width.
Ex.1: <code>string_magic("{15 width ! this is a long sentence}")</code> leads to &quot;this is a long\nsentence&quot;.
Ex.2: <code>string_magic("{15 width.#&gt; ! this is a long sentence}")</code> leads to &quot;#&gt; this is a long\n#&gt; sentence&quot;.
</p>
</li>
<li><p> difftime: displays a formatted time difference. Option &quot;silent&quot; does not report a warning if the
operation fails. It accepts either objects of class <code>POSIXt</code> or <code>difftime</code>.
Example: <code style="white-space: pre;">&#8288;x = Sys.time() ; Sys.sleep(0.5) ; string_magic("Time: {difftime ? x}")&#8288;</code> leads to something
like &quot;Time: 514ms&quot;.
</p>
</li></ul>



<h3>Group-wise operations</h3>

<p>In <code>string_magic</code>, the splitting operation <code>s</code> (or <code>S</code>) keeps a memory of the strings
that were split. Use the tilde operator, of the form <code style="white-space: pre;">&#8288;~(op1, op2)&#8288;</code>, to apply operations
group-wise, to each of the split strings.
</p>
<p>Better with an example. <code>x = c("Oreste, Hermione", "Hermione, Pyrrhus", "Pyrrhus, Andromaque") ;</code>
<code>string_magic("Troubles ahead: {S, ~(' loves 'c), C ? x}.")</code> leads to
&quot;Troubles ahead: Oreste loves Hermione, Hermione loves Pyrrhus and Pyrrhus loves Andromaque.&quot;.
</p>
<p>Almost all operations can be applied group-wise (although only operations changing the order or
the length of the strings really matter).
</p>


<h3>Conditional operations</h3>

<p>There are two operators to apply operations conditionally: <code>if</code> and <code>vif</code>, the latter
standing for <em>verbatim if</em>.
</p>
<p>The syntax of <code>if</code> is <code style="white-space: pre;">&#8288;if(cond ; ops_true ; ops_false)&#8288;</code> with <code>cond</code> a
condition (i.e. logical operation) on the value being interpolated, <code>ops_true</code> a comma-separated
sequence of operations if the condition is <code>TRUE</code> and <code>ops_false</code> an <em>optional</em> a sequence of
operations if the condition is <code>FALSE</code>.
</p>
<p>Ex.1: Let's take a sentence, delete words of less than 4 characters, and trim
words of 7+ characters.
x = &quot;Songe Cephise a cette nuit cruelle qui fut pour tout un peuple une nuit eternelle&quot;
<code>string_magic("{' 's, if(.nchar&lt;=4 ; nuke ; '7|..'k), c ? x}")</code>.
Let's break it down. First the sentence is split w.r.t. spaces, leading to a vector
of words. Then we use the special variable <code>.nchar</code> in <code>if</code>'s condition to refer
to the number of characters of the current vector (the words). The words with
less than 4 characters are nuked (i.e. removed), and the other words are
trimmed at 7 characters. Finally the modified vector of words is collapsed with
the function <code>c</code>, leading to the result.
</p>
<p>The condition <code>cond</code> accepts the following special values: <code>.</code> (the dot), <code>.nchar</code>, <code>.C</code>, <code>.len</code>, <code>.N</code>.
The dot, <code>.</code>, refers to the current vector. <code>.nchar</code> represent the number of characters
of the current vector (equivalent to <code>nchar(.)</code>). <code>.C</code> is an alias to <code>.nchar</code>.
<code>.len</code> represent the length of the current vector (equivalent to <code>length(.)</code>).
<code>.N</code> is an alias to <code>.len</code>.
</p>
<p>If a condition leads to a result of length 1, then the operations are applied to
the full string vector and not element-wise (as was the case in Ex.1). Contrary to element-wise conditions
for which operations modifying the length of the vectors are forbidden (apart from nuking),
such operations are fine in full-string conditions.
</p>
<p>Ex.2: <code>x = string_magic("x{1:10}")</code>; <code>string_magic("y = {if(.N&gt;4 ; 3 first, '...'insert.right), ' + 'c ? x}")</code>
leads to &quot;y = x1 + x2 + x3 + ...&quot;. the same opration applied to <code>x = string_magic("x{1:4}")</code>
leads to &quot;y = x1 + x2 + x3 + x4&quot;.
</p>
<p>For <code>vif</code>, the syntax is <code style="white-space: pre;">&#8288;vif(cond ; verb_true ; verb_false)&#8288;</code> with <code>verb_true</code>
a verbatim value with which the vector will be replaced if the condition is <code>TRUE</code>.
This is similar for <code>verb_false</code>. The condition works as in <code>if</code>.
</p>
<p>Ex.3: <code style="white-space: pre;">&#8288;x = c(1, 25, 12, 6) ; string_magic("Values: {vif(.&lt;10 ; &lt;10), C ? x}")&#8288;</code> leads to
&quot;Values: &lt;10, 25, 12 and &lt;10&quot;. As we can see values lower than 10 are replaced
with &quot;&lt;10&quot; while other values are not modified.
</p>
<p>Ex.4: <code>x = string_magic("x{1:10}")</code>; <code>string_magic("y = {vif(.N&gt;4 ; {S!{x[1]}, ..., {last?x}}), ' + 'c ? x}")</code>
leads to &quot;y = x1 + ... + x10&quot;.
Let's break it down. If the length of the vector is greater than 4 (here it's 10), then
the full string is replaced with <code>"{S!{x[1]}, ..., {last?x}}"</code>. Interpolation applies to
such string. Hence the split operation <code>S</code> breaks the string w.r.t.
the commas (default behavior), leading to the vector <code>c("{x[1]}", "...", "{last?x}")</code>. Since the
string contains curly brackets, interpolation is applied again. This leads to
the vector <code>c("x1", "...", "x10")</code>. Finally, this vector is collapsed with ' + ' leading
to the final string.
Note that there are many ways to get to the same result. Here is another example:
<code>string_magic("y = {vif(.N&gt;4 ; {x[1]} + ... + {last?x} ; {' + 'c ? x}) ? x}")</code>.
</p>
<p>The <code>vif</code> condition allows the use of '.' to refer to the current value in
<code>verb_true</code> and <code>verb_false</code>, as illustrated by the last example:
</p>
<p>Ex.5: <code>string_magic("{4 last, vif(. %% 2 ; x{.} ; y{rev?.}), C ? 1:11}")</code>
leads to &quot;y10, x9, y8 and x11&quot;.
</p>


<h3>Special interpolation</h3>

<p>if-else:
</p>
<p>Using an ampersand (&quot;&amp;&quot;) as the first character of an interpolation leads to an <em>if-else</em> operation.
Using two ampersands (&quot;&amp;&amp;&quot;) leads to a slightly different operation described at the end of this section.
</p>
<p>The syntax is as follows: <code style="white-space: pre;">&#8288;{&amp;cond ; verb_true ; verb_false}&#8288;</code> with <code>cond</code> a
condition (i.e. logical operation) on the value being interpolated, <code>verb_true</code>
a verbatim value with which the vector will be replaced if the condition is <code>TRUE</code> and
<code>verb_false</code> an <em>optional</em> verbatim value with which the vector will be replaced if the condition is <code>FALSE</code>.
If not provided, <code>verb_false</code> is considered to be the empty string unless the operator is
the double ampersand described at the end of this section.
</p>
<p>Note that in <code>cond</code>, you can use the function <code>len</code>, an alias to <code>length</code>.
</p>
<p>Ex.1: <code>x = 1:5</code>; <code>string_magic("x is {&amp;len(x)&lt;10 ; short ; {`log10(.N)-1`times, ''c ! very }long}")</code>
leads to &quot;x is short&quot;. With <code>x = 1:50</code>, it leads to &quot;x is long&quot;, and to &quot;x is very very long&quot;
if <code>x = 1:5000</code>.
</p>
<p>If a condition leads to a result of length 1, the full string is replaced by the verbatim
expression. Further, this expression will be interpolated if requested. This was the case
in Ex.1 where <code>verb_false</code> was interpolated.
</p>
<p>If the condition's length is greater than 1, then each logical values equal to <code>TRUE</code> is replaced
by <code>verb_true</code>, and <code>FALSE</code> or <code>NA</code> values are replaced with <code>verb_false</code>. Note,
importantly, that <strong>no interpolation is perfomed in that case</strong>.
</p>
<p>Ex.2: <code style="white-space: pre;">&#8288;x = 1:3 ; string_magic("x is {&amp;x == 2 ; two ; not two}")&#8288;</code> leads to the vector
<code>c("x is not two", "x is two", "x is not two")</code>.
</p>
<p>In that example, when x is odd, it is replaced with &quot;odd&quot;, and when even it is
replaced with the elements of y.
</p>
<p>Using the two ampersand operator (&quot;&amp;&amp;&quot;) is like the simple ampersand version but the
default for <code>verb_false</code> is the variable used in the condition itself. So the syntax is
<code style="white-space: pre;">&#8288;{&amp;&amp;cond ; verb_true}&#8288;</code> and <em>it does not accept</em> <code>verb_false</code>.
</p>
<p>Ex.3: <code style="white-space: pre;">&#8288;i = 3 ; string_magic("i = {&amp;&amp;i == 3 ; three}")&#8288;</code> leads to &quot;i = three&quot;, and to &quot;i = 5&quot; if <code>i = 5</code>.
</p>
<p>Pluralization:
</p>
<p>There is advanced support for pluralization which greatly facilitates the writing of messages
in natural language.
</p>
<p>There are two ways to pluralize: over length or over value. To trigger a &quot;pluralization&quot; interpolation
use as first character:
</p>

<ul>
<li> <p><code>$</code> to pluralize over the length of a variable (see Ex.2)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;#&#8288;</code> to pluralize over the value of a variable (see Ex.1)
</p>
</li></ul>

<p>Ex.1: <code style="white-space: pre;">&#8288;x = 5; string_magic("I bought {N?x} book{#s}.")&#8288;</code> leads to &quot;I bought five books.&quot;.
If <code>x = 1</code>, this leads to &quot;I bought one book.&quot;.
</p>
<p>The syntax is <code style="white-space: pre;">&#8288;{#plural_ops ? variable}&#8288;</code> or <code style="white-space: pre;">&#8288;{#plural_ops}&#8288;</code> where <code>plural_ops</code> are
specific pluralization operations which will be described below.
The pluralization is perfomed <em>always</em> with respect to the value of a variable.
You can either add the variable explicitly (<code style="white-space: pre;">&#8288;{#plural_ops ? variable}&#8288;</code>) or refer
to it implicitly (<code style="white-space: pre;">&#8288;{#plural_ops}&#8288;</code>). If implicit, then the algorithm will look at the
previous variable that was interpolated and pluralize over it. This is exaclty what happens in
Ex.1 where <code>x</code> was interpolated in <code>{N?x}</code> and plural operation <code>s</code> in <code style="white-space: pre;">&#8288;{#s}&#8288;</code> then applied to
<code>x</code>. It was equivalent to have <code style="white-space: pre;">&#8288;{#s ? x}&#8288;</code>. If a variable wasn't interpolated before, then
the next interpolated variable will be used (see Ex.2). If no variable is interpolated
at all, an error is thrown.
</p>
<p>Ex.2: <code style="white-space: pre;">&#8288;x = c("J.", "M."); string_magic("My BFF{$s, are} {C?x}!")&#8288;</code> leads to &quot;My BFFs are J. and M.!&quot;.
If &quot;x = &quot;S.&quot;, this leads to &quot;My BFF is S.!&quot;.
</p>
<p>Pluralizing accepts the following operations:
</p>

<ul>
<li><p> s, es: adds an &quot;s&quot; (or &quot;es&quot;) if it is plural (&gt; 1), nothing otherwise. Accepts the option <code>0</code> or <code>zero</code> which
treats a 0-length or a 0-value as plural.
</p>
</li>
<li><p> y or ies: adds an 'y' if singular and 'ies' if plural (&gt;1). Accepts the option <code>0</code> or <code>zero</code> which
treats a 0-length or a 0-value as plural.
</p>
</li>
<li><p> enum: enumerates the elements (see help for the regular operation <code>enum</code>)
</p>
</li>
<li><p> n, N, len, Len: add the number of elements (&quot;len&quot;) or the value (&quot;n&quot;) of the variable as a formatted number or
in letters (upper case versions). Accepts the options <code>letter</code> (to write in letter)
and <code>upper</code> (to uppercase the first letter).
</p>
</li>
<li><p> nth, ntimes: writes the value of the variable as an order (nth) or a frequence (ntimes). Accepts the option <code>letter</code>
to write the numbers in letters (uppercase version of the operator does the same).
</p>
</li>
<li><p> is, or any verb: conjugates the verb appropriately
</p>
</li></ul>

<p>You can chain operations, in that case a whitespace is automatically added between them.
</p>
<p>Ex.3: <code style="white-space: pre;">&#8288;x = c(7, 3, 18); string_magic("The winning number{$s, is, enum ? sort(x)}.")&#8288;</code>
leads to &quot;The winning numbers are 3, 7 and 18.&quot;. With <code>x = 7</code> this leads to
&quot;The winning number is 7.&quot;.
</p>
<p>On top of the previous operations, there is a special operation allowing to add verbatim text depending on
the situation. The syntax is as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;(s1;s2)&#8288;</code>: adds verbatim 's1' if singular and 's2' if plural (&gt;1)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(s1;s2;s3)&#8288;</code>: adds verbatim 's1' if zero, 's2' if singular (=1) and 's3' if plural
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(s1;;s3)&#8288;</code>: adds verbatim 's1' if zero, 's3' if singular or plural (i.e. &gt;=1)
</p>
</li></ul>

<p>These case-dependent verbatim values <strong>are interpolated</strong> (if appropriate). In these interpolations
you need not refer explicitly to the variable for pluralization interpolations.
</p>
<p>Ex.4: <code style="white-space: pre;">&#8288;x = 3; string_magic("{#(Sorry, nothing found.;;{#N.upper} match{#es, were} found.)?x}")&#8288;</code> leads to
&quot;Three matches were found.&quot;. If &quot;x = 1&quot;, this leads to &quot;One match was found.&quot; and if &quot;x = 0&quot; this leads
to &quot;Sorry, nothing found.&quot;.
</p>


<h3>Escaping and special cases</h3>

<p>The opening and closing brakets, <code>{}</code>, are special characters and cannot be used as regular text.
To bypass their special meaning, you need to escape them with a double backslash.
</p>
<p>Ex.1: <code>string_magic("open = \\\\{, close = }")</code> leads to <code>"open = {, close = }"</code>.
Ex.2: <code>string_magic("many {5 times.c ! \\\\}}")</code> leads to <code style="white-space: pre;">&#8288;many }}}}}&#8288;</code>.
</p>
<p>You only need to escape the special delimiters which the algorithm is currently looking for.
As you can see, you don't need to escape the closing bracket in Ex.1 since no box
was open. On the other hand, you need to escape it in Ex.2.
</p>
<p>Alternatively, use the argument <code>.delim</code> to set custom delimiters.
</p>
<p>Ex.3: <code>string_magic("I {'can {write} {{what}} I want'}")</code> leads to <code>"I can {write} {{what}} I want"</code>.
</p>
<p>Since <code>{expr}</code> evaluates <code>expr</code>, the stuff inside the <em>box</em>, you can pass a
character string and it will stay untouched.
</p>
<p>In the few operations expecting a semi-colon (if-else and pluralization), it can also be
escaped with a double backslash.
</p>
<p>In interpolations, the exclamation mark (<code>!</code>) signals a verbatim expression. But what
if you use it to mean the logical operation <em>not</em> in an operation-free interpolation?
In that case, you need a hack: use a question mark (<code style="white-space: pre;">&#8288;?&#8288;</code>) first to indicate to the
algorithm that you want to evaluate the expression.
</p>
<p>Ex.4: <code>string_magic("{!TRUE} is {?!TRUE}")</code> leads to &quot;TRUE is FALSE&quot;. The first expression is
taken verbatim while the second is evaluated.
</p>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# BASIC USAGE ####
#

x = c("Romeo", "Juliet")

# {x} inserts x
string_magic("Hello {x}!")

# elements in ... are collapsed with "" (default)
string_magic("Hello {x[1]}, ",
    "how is {x[2]} doing?")

# Splitting a comma separated string
# The mechanism is explained later
string_vec("J. Mills, David, Agnes, Dr Strong")

# Nota: this is equivalent to (explained later)
string_magic("{', *'S ! J. Mills, David, Agnes, Dr Strong}")

#
# Applying low level operations to strings
#

# Two main syntax:

# A) expression evaluation
# {operation ? x}
#            | |
#            |  \-&gt; the expression to be evaluated
#             \-&gt; ? means that the expression will be evaluated

# B) verbatim
# {operation ! x}
#            | |
#            |  \-&gt; the expression taken as verbatim (here 'x')
#             \-&gt; ! means that the expression is taken as verbatim

# operation: usually 'arg'op with op an operation code.

# Example: splitting
x = "hello dear"
string_magic("{' 's ? x}")
# x is split by ' '

string_magic("{' 's ! hello dear}")
# 'hello dear' is split by ' '
# had we used ?, there would have been an error


# There are 50+ string operators
# Operators usually have a default value
# Operations can have options
# Operations can be chained by separating them with a comma

# Example: default of 's' is ' ' + chaining with collapse
string_magic("{s, ' my 'c ! hello dear}")

#
# Nesting
#

# {operations ! s1{expr}s2}
#             |   |
#             |    \-&gt; expr will be interpolated then added to the string
#              \-&gt; nesting requires verbatim evaluation: '!'

string_magic("The variables are: {C ! x{1:4}}.")

# This one is ugly but it shows triple nesting
string_magic("The variables are: {ws, C ! {2 times ! x{1:4}}{','s, 4 each !  ,_sq}}.")

#
# Splitting
#

# s: split with fixed pattern, default is ' '
string_magic("{s ! a b c}")
string_magic("{' b 's !a b c}")

# S: same as 's' but default is ',[ \t\n]*'
string_magic("{S !a, b, c}")
string_magic("{'[[:punct:] ]+'S ! a! b; c}")

# add regex flags: e.g. fixed search
string_magic("{'f/.'s ! hi.there}")


#
# Collapsing
#

# c and C do the same, their default is different
# syntax: 's1|s2' with
# - s1 the string used for collapsing
# - s2 (optional) the string used for the last collapse

# c: default is ' '
string_magic("{c ? 1:3}")

# C: default is ', | and '
string_magic("{C ? 1:3}")

string_magic("{', | or 'c ? 1:4}")

#
# Extraction
#

# extract: to extract patterns (option first)
# x: alias to extract.first
# X: alias to extract
# syntax: 'pattern'x
# Default is '[[:alnum:]]+'

x = "This years is... 2020"
string_magic("{x ? x}") # similar to string_magic("{extract.first ? x}")
string_magic("{X ? x}") # similar to string_magic("{extract ? x}")

string_magic("{'\\d+'x ? x}")

#
# STRING FORMATTING ####
#

#
# upper, lower, title

# upper case the first letter
string_magic("{upper.first ! julia mills}")

# title case
string_magic("{title ! julia mills}")

# upper all letters
string_magic("{upper ! julia mills}")

# lower case
string_magic("{lower ! JULIA MILLS}")

#
# q, Q, bq: single, double, back quote

string_magic("{S, q, C ! Julia, David, Wilkins}")
string_magic("{S, Q, C ! Julia, David, Wilkins}")
string_magic("{S, bq, C ! Julia, David, Wilkins}")

#
# format, Format: formats the string to fit the same length

# format: the right side is filled with blanks
# Format: the left side is filled with blanks, the string is right aligned

score = c(-10, 2050)
nm = c("Wilkins", "David")
string_magic("Monopoly scores:\n{'\n'c ! - {format ? nm}: {Format ? score} US$}")

# OK that example may have been a bit too complex,
# let's make it simple:

string_magic("Scores: {format ? score}")
string_magic("Names: {Format ? nm}")

#
# ws: white space normalization

# ws: suppresses trimming white spaces + normalizes successive white spaces
# Add the following options in any order to:
# - punct: remove punctuation
# - digit: remove digits
# - isolated: remove isolated characters

string_magic("{ws ! The   white  spaces are now clean.  }")

string_magic("{ws.punct ! I, really -- truly; love punctuation!!!}")

string_magic("{ws.digit ! 1, 2, 12, a microphone check!}")

string_magic("{ws.i ! 1, 2, 12, a microphone check!}")

string_magic("{ws.d.i ! 1, 2, 12, a microphone check!}")

string_magic("{ws.p.d.i ! 1, 2, 12, a microphone check!}")

#
# %: applies sprintf formatting

 # add the formatting as a regular argument
string_magic("pi = {'.2f'% ? pi}")
# or right after the %
string_magic("pi = {%.2f ? pi}")

#
# paste: appends text on each element
# Accepts the options: right, both, front and back
# It accepts the special values :1:, :i:, :I:, :a:, :A: to create enumerations

# adding '|' on both sides
string_magic("{'|'paste.both, ' + 'c ! x{1:4}}")


# Enumerations
acad = string_vec("you like admin, you enjoy working on weekends, you really love emails")
string_magic("Main reasons to pursue an academic career:\n {':i:) 'paste, C ? acad}.")

# You can also use the enum command
string_magic("Main reasons to pursue an academic career:\n {enum.i ? acad}.")

#
# stopwords: removes basic English stopwords
# the list is from the Snowball project:
#  http://snowball.tartarus.org/algorithms/english/stop.txt

string_magic("{stop, ws ! It is a tale told by an idiot, ",
                         "full of sound and fury, signifying nothing.}")

#
# k: keeps the first n characters
# syntax: nk: keeps the first n characters
#         'n|s'k: same + adds 's' at the end of shortened strings
#         'n||s'k: same but 's' counts in the n characters kept

words = string_vec("short, constitutional")
string_magic("{5k ? words}")

string_magic("{'5|..'k ? words}")

string_magic("{'5||..'k ? words}")

#
# K: keeps the first n elements
# syntax: nK: keeps the first n elements
#         'n|s'K: same + adds the element 's' at the end
#         'n||s'K: same but 's' counts in the n elements kept
#
# Special values :rest: and :REST:, give the number of items dropped

bx = string_vec("Pessac Leognan, Saint Emilion, Marguaux, Saint Julien, Pauillac")
string_magic("Bordeaux wines I like: {3K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3|etc..'K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3||etc..'K, ', 'C ? bx}.")

string_magic("Bordeaux wines I like: {'3|and at least :REST: others'K, ', 'C ? bx}.")

#
# Ko, KO: special operator which keeps the first n elements and adds "others"
# syntax: nKo
# KO gives the rest in letters

string_magic("Bordeaux wines I like: {4KO, C ? bx}.")

#
# r, R: string replacement 
# syntax: 's'R: deletes the content in 's' (replaces with the empty string)
#         's1 =&gt; s2'R replaces s1 into s2

string_magic("{'e'r, ws ! The letter e is deleted}")

# adding a perl look-behind
string_magic("{'(?&lt;! )e'r !The letter e is deleted}")

string_magic("{'e =&gt; a'r !The letter e becomes a}")

string_magic("{'([[:alpha:]]{3})[[:alpha:]]+ =&gt; \\1.'r ! Trimming the words}")

# Alternative way with simple operations: split, shorten, collapse
string_magic("{s, '3|.'k, c ! Trimming the words}")

#
# times, each
# They accept the option c to collapse with the empty string

string_magic("N{10 times.c ! o}!")

string_magic("{3 times.c ? 1:3}")
string_magic("{3 each.c ? 1:3}")

#
# erase: replaces the items by the empty string
# -&gt; useful in conditions

string_magic("{erase ! I am going to be annihilated}")

#
# ELEMENT MANIPULATION ####
#

#
# rm: removes the elements
# Its (optional) argument is a regular expression giving which element to remove
# Many options: "empty", "blank", "noalpha", "noalnum", "all" 

x = c("Destroy", "All")
string_magic("{'A'rm ? x}")

string_magic("{rm.all ? x}")

x = string_vec("1, 12, 123, 1234, 123456, 1234567")
# we delete elements whose number of characters is lower or equal to 3
# =&gt; see later section CONDITIONS
string_magic("{if(.nchar &gt; 3 ; nuke) ? x}")

#
# PLURALIZATION ####
#

# Two ways to enable pluralization:
# {$ command}: means the plural is decuced from the length of the variable
# {# command}: means the plural is decuced from the value of the variable

# Explanatory example
x = c("Eschyle", "Sophocle", "Euripide")
n = 37
string_magic("The author{$s, enum, have ? x} written {#N ? n} play{#s}.")

x = "Laurent Berge"
n = 0
string_magic("The author{$s, enum, have ? x} written {#N ? n} play{#s}.")

# How does it work?
# First is {$s, enum, have ? x}.
# The commands `s`, `enum` and `have` are applied to `x` which must come after a `?`
#    =&gt; there the plural (whether an s is added and how to conjugate the verb have) depends
#       on the **length** of the vector `x`
#
# Second comes {#N ? n}.
# The double dollar sign means that the command `N` will be applied to the **value** n.
# The value must come after the `?`
#
# Third is {#s}.
# The object to which `s` should be applied is missing (there is no `? n`).
# The default is to apply the command to the previous object. In this case,
#  this is `n`.

# Another similar example illustrating that we need not express the object several times:
x = c("Eschyle", "Sophocle", "Euripide")
string_magic("The {Len ? x} classic author{$s, are, enum}.")



#
# ARGUMENTS FROM THE ENVIRONMENT ####
#

# Arguments can be evaluated from the calling environment.
# Simply use backticks instead of quotes.

dollar = 6
reason = "glory"
string_magic("Why do you develop packages? For {`dollar`times.c ! $}?",
    "For money? No... for {upper,''s, c ? reason}!", .sep = "\n")

#
# Alias generation
#

# Let's create a formula filler
# - we use .local_ops to create the ad hoc operation "add" which adds variables
# - we transform into a formula ex post

fml = string_magic_alias(.post = as.formula, .local_ops = list(add = "' + 'collapse"))

# example with mtcars
lhs = "mpg"
rhs = c("hp", "drat")
fml("{lhs} ~ {add?rhs} + am")
   

</code></pre>

<hr>
<h2 id='string_magic_alias'>Create <code>string_magic</code> aliases with custom defaults</h2><span id='topic+string_magic_alias'></span>

<h3>Description</h3>

<p>Utility to easily create <code>string_magic</code> aliases with custom default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_magic_alias(
  .sep = "",
  .vectorize = FALSE,
  .delim = c("{", "}"),
  .last = NULL,
  .post = NULL,
  .default = NULL,
  .nest = FALSE,
  .invisible = FALSE,
  .local_ops = NULL,
  .collapse = NULL,
  .check = TRUE,
  .class = NULL,
  .namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_magic_alias_+3A_.sep">.sep</code></td>
<td>
<p>Character scalar, default is the empty string <code>""</code>. It is used to collapse all
the elements in <code>...</code> before applying any operation.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.vectorize">.vectorize</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, Further, elements in <code>...</code> are
NOT collapsed together, but instead vectorised.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.delim">.delim</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("{", "}")</code>. Defines
the opening and the closing delimiters for interpolation.
</p>
<p>If of length 1, it must be of the form: 1) the opening delimiter,
2) a single space, 3) the closing delimiter. Ex: <code>".[ ]"</code> is equivalent to <code>c(".[", "]")</code>.
The default value is equivalent to <code>"{ }"</code>.
</p>
<p>[ ]: R:%20
[&quot;, &quot;]: R:%22,%20%22</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.last">.last</code></td>
<td>
<p>Character scalar, a function, or <code>NULL</code> (default). If provided and character:
it must be an <code>string_magic</code> chain of operations of the form <code>"'arg1'op1, op2, etc"</code>. All these operations
are applied just before returning the vector. If a function,
it will be applied to the resulting vector.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.post">.post</code></td>
<td>
<p>Function or <code>NULL</code> (default). If not <code>NULL</code>, this function will be applied
after all the processing, just before returning the object. This function can have
extra arguments which will be caught directly in the <code>...</code> argument of <code>string_magic</code>.
For example if <code>.post = head</code>, you can directly pass the argument <code>n = 3</code> to <code>string_magic</code>'s arguments.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.default">.default</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If provided, it must be
a sequence of <code>string_magic</code> operations. It will be applied as a default to any interpolation.
Ex: if <code>x = 1:2</code>, then <code>string_magic("x = {x}", .default = "enum")</code> leads to &quot;x = 1 and 2&quot;,
and is equivalent to <code>string_magic("x = {enum?x}")</code>. Note that this default operations does
not apply to nested expressions. That is <code>string_magic("{!x{1:2}}", .default = "enum")</code> leads
to <code>c("x1", "x2")</code> and NOT <code>"x1 and 2"</code>.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.nest">.nest</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, it will nest the original string within
interpolation delimiters, so that you can apply operations directly on the string. Example:
<code>string_magic("upper ! hello")</code> returns &quot;upper ! hello&quot;, while <code>string_magic("upper ! hello", .nest = TRUE)</code>
returns <code>"HELLO"</code>.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.invisible">.invisible</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether the object returned should be
invisible (i.e. not printed on the console).</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.local_ops">.local_ops</code></td>
<td>
<p>Named list or <code>NULL</code> (default). If provided, it must be a list
of the form <code>list(alias1 = ops1, alias2 = ops2)</code> where alias is the name of the newly defined
operator an <code>ops</code> is a character scalar representing the associated string_magic operations.
Ex: <code>list(add = "' + 'collapse")</code> creates the operation <code>add</code> which collapses the
string with pluses. All operations created here are only available to the
generated function.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.collapse">.collapse</code></td>
<td>
<p>Character scalar, default is <code>NULL</code>. If provided, the character vector
that should be returned is collapsed with the value of this argument. This leads
to return a string of length 1.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.check">.check</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to enable error-handling (i.e.
human readable error messages).
Without error-handling you can save something of the order of 40us. Useful only
in long loops.</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.class">.class</code></td>
<td>
<p>Character vector representing the class to give to the object returned.
By default it is <code>NULL</code>. Note that the class <code>string_magic</code> has a specific <code>print</code> method, usually
nicer for small vectors (it <code><a href="base.html#topic+cat">base::cat()</a></code>s the elements).</p>
</td></tr>
<tr><td><code id="string_magic_alias_+3A_.namespace">.namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function if you want to change <code>string_magic</code> default values. For example,
if you want the interpolation to be done with <code>"{{}}"</code> (instead of <code>{}</code>) or if you want the
default separation to be the space (instead of the empty string). See the example.
</p>


<h3>Value</h3>

<p>This function returns a function which will behave in the same way as <code><a href="#topic+string_magic">string_magic()</a></code>
</p>


<h3>Writing a package using <code>string_magic</code></h3>

<p>If you want to use <code>string_magic</code> in your package and want to make use of custom operations:
</p>

<ul>
<li><p> place any <code>string_magic_register_fun</code> and <code>string_magic_register_ops</code> in your <code>.onLoad</code> function
(see <code>help("onLoad")</code>). The .onLoad function is run whenever the package is loaded
for the first time. It's a function that you can place anywhere in your <code style="white-space: pre;">&#8288;R/*&#8288;</code> files
and which looks like this:
</p>
</li></ul>

<div class="sourceCode r"><pre>.onLoad = function(libname, pkgname){
  # string_magic custom operations
  string_magic_register_ops("'80|-'fill", "h1")

  invisible()
}
</pre></div>

<ul>
<li><p> if you don't want to place the <code style="white-space: pre;">&#8288;string_magic_register_*&#8288;</code> functions in the .onLoad function,
you can, but then you <strong>must</strong> provide the argument <code>namespace</code>:
</p>
</li></ul>

<div class="sourceCode r"><pre>string_magic_register_ops("'80|-'fill", "h1", namespace = "myPackageName")
</pre></div>

<ul>
<li><p> you must create an <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> to create an alias to <code><a href="#topic+string_magic">string_magic()</a></code> and use the
argument <code>.namespace = "myPackageName"</code>. Use this opportunity to change the
defaults if you wish. You can even override the <code>string_magic</code> function:
</p>
</li></ul>

<div class="sourceCode r"><pre># creating an alias with the same name + changing the delimiter
string_magic = stringmagic::string_magic_alias(.namespace = "myPackageName", .delim = "{{ }}")
</pre></div>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Other related to string_magic: 
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun</a>()</code>
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# we create the function sma2 with different defaults
sma2 = string_magic_alias(.delim = ".[ ]", .sep = " ", .class = "string_magic")

person = "john doe"
sma2("Hello", ".[title ? person]")

# you can use the arguments whose default has been changed
sma2("Hello", ".[title ? person]", .sep = ": ")



</code></pre>

<hr>
<h2 id='string_magic_register_fun'>Register custom operations to apply them in <code>string_magic</code></h2><span id='topic+string_magic_register_fun'></span><span id='topic+string_magic_register_ops'></span>

<h3>Description</h3>

<p>Extends the capabilities of <code><a href="#topic+string_magic">string_magic()</a></code> by adding any custom operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_magic_register_fun(fun, alias, valid_options = NULL, namespace = NULL)

string_magic_register_ops(ops, alias, namespace = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_magic_register_fun_+3A_fun">fun</code></td>
<td>
<p>A function which must have at least the arguments 'x' and '...'.
Additionnaly, it can have the arguments: 'argument', 'options', 'group', 'group_flag'.
This function must return a vector.
This function will be internally called by <code>string_magic</code> in the form
<code>fun(x, argument, options, group, group_flag)</code>.<code>x</code>: the value to which the
operation applies. <code>argument</code>: the quoted <code>string_magic</code> argument (always character).
<code>options</code>: a character vector of <code>string_magic</code> options. The two last arguments are of use
only in group-wise operations if <code>fun</code> changes the lengths of vectors. <code>group</code>: an index of
the group to which belongs each observation (integer). <code>group_flag</code>: value between 0
and 2; 0: no grouping operation requested; 1: keep track of groups; 2: apply grouping.</p>
</td></tr>
<tr><td><code id="string_magic_register_fun_+3A_alias">alias</code></td>
<td>
<p>Character scalar, the name of the operation.</p>
</td></tr>
<tr><td><code id="string_magic_register_fun_+3A_valid_options">valid_options</code></td>
<td>
<p>A character vector or NULL (default). Represents a list of
valid options for the operation. This is used: a) to enable auto-completion,
b) for error-handling purposes.</p>
</td></tr>
<tr><td><code id="string_magic_register_fun_+3A_namespace">namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
If the function <code style="white-space: pre;">&#8288;string_magic_register_*&#8288;</code> is located in the <code>onLoad</code> function (see <code>help("onLoad")</code>),
there is nothing to do. Otherwise, pass the name of your package in this argument to
make all the new operation definitions scoped (i.e. only your package can access it and
it can't be messed up by end users).</p>
</td></tr>
<tr><td><code id="string_magic_register_fun_+3A_ops">ops</code></td>
<td>
<p>Character scalar representing a valid chain of <code>string_magic</code> operations. It should
be of the form <code>"op1, 'arg'op2, etc"</code>. For example <code>"'80|-'fill"</code> fills the line
with dashes up to 80 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We try to strongly check the new operations since it's always better to find out problems
sooner than later. This means that when the function is defined, it is also
tested.
</p>
<p>If you pass a function, note that it should work for non-character arguments in <code>x</code>.
</p>


<h3>Value</h3>

<p>These function do not return anything. They register new operations to be used in the
<code>string_magic</code> family of functions by placing them in the options (later fetched by
<code>string_magic()</code> at run-time).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_magic_register_ops()</code>: Create new combinations of <code>string_magic</code> operations
</p>
</li></ul>


<h3>Writing a package using <code>string_magic</code></h3>

<p>If you want to use <code>string_magic</code> in your package and want to make use of custom operations:
</p>

<ul>
<li><p> place any <code>string_magic_register_fun</code> and <code>string_magic_register_ops</code> in your <code>.onLoad</code> function
(see <code>help("onLoad")</code>). The .onLoad function is run whenever the package is loaded
for the first time. It's a function that you can place anywhere in your <code style="white-space: pre;">&#8288;R/*&#8288;</code> files
and which looks like this:
</p>
</li></ul>

<div class="sourceCode r"><pre>.onLoad = function(libname, pkgname){
  # string_magic custom operations
  string_magic_register_ops("'80|-'fill", "h1")

  invisible()
}
</pre></div>

<ul>
<li><p> if you don't want to place the <code style="white-space: pre;">&#8288;string_magic_register_*&#8288;</code> functions in the .onLoad function,
you can, but then you <strong>must</strong> provide the argument <code>namespace</code>:
</p>
</li></ul>

<div class="sourceCode r"><pre>string_magic_register_ops("'80|-'fill", "h1", namespace = "myPackageName")
</pre></div>

<ul>
<li><p> you must create an <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> to create an alias to <code><a href="#topic+string_magic">string_magic()</a></code> and use the
argument <code>.namespace = "myPackageName"</code>. Use this opportunity to change the
defaults if you wish. You can even override the <code>string_magic</code> function:
</p>
</li></ul>

<div class="sourceCode r"><pre># creating an alias with the same name + changing the delimiter
string_magic = stringmagic::string_magic_alias(.namespace = "myPackageName", .delim = "{{ }}")
</pre></div>


<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>Other related to string_magic: 
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# let's create an operation that adds markdown emphasis
# to elements of a vector

# A) define the function
fun_emph = function(x, ...) paste0("*", x, "*")

# B) register it
string_magic_register_fun(fun_emph, "emph")

# C) use it
x = string_vec("right, now")
string_magic("Take heed, {emph, c? x}.")

#
# now let's add the option "strong"
fun_emph = function(x, options, ...) {
  if("strong" %in% options){
    paste0("***", x, "***")
  } else {
    paste0("*", x, "*")
  }
}

string_magic_register_fun(fun_emph, "emph", "strong")

x = string_vec("right, now")
string_magic("Take heed, {emph.strong, c? x}.")

#
# now let's add an argument
fun_emph = function(x, argument, options, ...){
  arg = argument
  if(nchar(arg) == 0) arg = "*"
  
  if("strong" %in% options){
    arg = paste0(rep(arg, 3), collapse = "")
  }
  
  paste0(arg, x, arg)
}

string_magic_register_fun(fun_emph, "emph", "strong")

x = string_vec("right, now")
string_magic("Take heed, {'_'emph.s, c? x}.")

#
# using string_magic_register_ops
#

# create a 'header' maker
string_magic_register_ops("tws, '# 'paste, ' 'paste.right, '40|-'fill", "h1")
cat_magic("{h1 ! My title}\n my content")




</code></pre>

<hr>
<h2 id='string_ops_alias'>Chains basic operations to character vectors</h2><span id='topic+string_ops_alias'></span><span id='topic+string_ops'></span><span id='topic+st_ops'></span>

<h3>Description</h3>

<p>Simple tool to perform multiple operations to character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_ops_alias(op = NULL, pre_unik = NULL, namespace = NULL)

string_ops(
  x,
  ...,
  op = NULL,
  pre_unik = NULL,
  namespace = NULL,
  envir = parent.frame()
)

st_ops(
  x,
  ...,
  op = NULL,
  pre_unik = NULL,
  namespace = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_ops_alias_+3A_op">op</code></td>
<td>
<p>Character <strong>vector</strong> or <code>NULL</code> (default). Character scalar containing the comma separated values
of operations to perform to the vector. The 50+ operations are detailed in the help
page of <code><a href="#topic+string_magic">string_magic()</a></code>. Note that if this argument is provided, then the values in
<code>...</code> are ignored.</p>
</td></tr>
<tr><td><code id="string_ops_alias_+3A_pre_unik">pre_unik</code></td>
<td>
<p>Logical scalar, default is <code>NULL</code>. Whether to first unique the vector
before applying the possibly costly string operations, and merging back the result.
For very large vectors with repeated values the time gained can be substantial. By
default, this is <code>TRUE</code> for vector of length 1M or more.</p>
</td></tr>
<tr><td><code id="string_ops_alias_+3A_namespace">namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.
</p>
<p>If so pass the name of your package in this argument so that your function can access
the new <code>string_magic</code> operations defined within your package.</p>
</td></tr>
<tr><td><code id="string_ops_alias_+3A_x">x</code></td>
<td>
<p>A character vector. If not a character vector but atomistic (i.e. not a list),
it will be converted to a character vector.</p>
</td></tr>
<tr><td><code id="string_ops_alias_+3A_...">...</code></td>
<td>
<p>Character <strong>scalars</strong>. Character scalar containing the comma separated values
of operations to perform to the vector. The 50+ operations are detailed in the help
page of <code><a href="#topic+string_magic">string_magic()</a></code>.</p>
</td></tr>
<tr><td><code id="string_ops_alias_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper around string_magic. Formally, <code>string_ops(x, "op1, op2")</code>
is equivalent to <code>string_magic("{op1, op2 ? x}")</code>.
</p>


<h3>Value</h3>

<p>In general it returns a character vector. It may be of a length different from the original
one, depending on the operations performed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_ops_alias()</code>: <code>string_ops</code> alias with custom defaults
</p>
</li>
<li> <p><code>st_ops()</code>: Alias to <code>string_ops</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent R. Berge
</p>


<h3>See Also</h3>

<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data on car models
cars = row.names(mtcars)

# let's get the brands starting with an "m"
string_ops(cars, "'i/^m'get, x, unik")

# Explainer:
# 'i/^m'get: keeps only the elements starting with an m,
#            i/ is the 'regex-flag' "ignore" to ignore the case
#            ^m means "starts with an m" in regex language
# x: extracts the first pattern. The default pattern is "[[:alnum:]]+"
#    which means an alpha-numeric word
# unik: applies unique() to the vector
# =&gt; see help in ?string_magic for more details on the operations


# let's get the 3 largest numbers appearing in the car models
string_ops(cars, "'\\d+'x, rm, unik, num, dsort, 3 first")

# Explainer:
# '\d+'x: extracts the first pattern, the pattern meaning "a succession"
#          of digits in regex language
# rm: removes elements equal to the empty string (default behavior)
# unik: applies unique() to the vector
# num: converts to numeric
# dsort: sorts in decreasing order
# 3 first: keeps only the first three elements

# You can use several character vectors as operations:
string_ops(cars, 
           "'\\d+'x, rm, unik",
           "num, dsort, 3 first")

</code></pre>

<hr>
<h2 id='string_split'>Splits a character string wrt a pattern</h2><span id='topic+string_split'></span><span id='topic+stsplit'></span>

<h3>Description</h3>

<p>Splits a character string with respect to pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_split(
  x,
  split,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame()
)

stsplit(
  x,
  split,
  simplify = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_split_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="string_split_+3A_split">split</code></td>
<td>
<p>A character scalar. Used to split the character vectors. By default
this is a regular expression. You can use flags in the pattern in the form <code style="white-space: pre;">&#8288;flag1, flag2/pattern&#8288;</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
magic (add interpolation with <code>"{}"</code>). Example:
if &quot;ignore/hello&quot; and the text contains &quot;Hello&quot;, it will be split at &quot;Hello&quot;.
Shortcut: use the first letters of the flags. Ex: &quot;iw/one&quot; will split at the word
&quot;one&quot; (flags 'ignore' + 'word').</p>
</td></tr>
<tr><td><code id="string_split_+3A_simplify">simplify</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If <code>TRUE</code>, then when the vector input <code>x</code>
is of length 1, a character vector is returned instead of a list.</p>
</td></tr>
<tr><td><code id="string_split_+3A_fixed">fixed</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to consider the argument <code>split</code>
as fixed (and not as a regular expression).</p>
</td></tr>
<tr><td><code id="string_split_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_split_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_split_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>simplify = TRUE</code> (default), the object returned is:
</p>

<ul>
<li><p> a character vector if <code>x</code>, the vector in input, is of length 1: the character vector contains
the result of the split.
</p>
</li>
<li><p> a list of the same length as <code>x</code>. The ith element of the list is a character vector
containing the result of the split of the ith element of <code>x</code>.
</p>
</li></ul>

<p>If <code>simplify = FALSE</code>, the object returned is always a list.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stsplit()</code>: Alias to <code>string_split</code>
</p>
</li></ul>


<h3>Generic regular expression flags</h3>

<p>All <code>stringmagic</code> functions support generic flags in regular-expression patterns.
The flags are useful to quickly give extra instructions, similarly to <em>usual</em>
<a href="https://javascript.info/regexp-introduction">regular expression flags</a>.
</p>
<p>Here the syntax is &quot;flag1, flag2/pattern&quot;. That is: flags are a comma separated list of flag-names
separated from the pattern with a slash (<code>/</code>). Example: <code>string_which(c("hello...", "world"), "fixed/.")</code> returns <code>1</code>.
Here the flag &quot;fixed&quot; removes the regular expression meaning of &quot;.&quot; which would have otherwise meant <em>&quot;any character&quot;</em>.
The no-flag verion <code>string_which(c("hello...", "world"), ".")</code> returns <code>1:2</code>.
</p>
<p>Alternatively, and this is recommended, you can collate the initials of the flags instead of using a
comma separated list. For example: &quot;if/dt[&quot; will apply the flags &quot;ignore&quot; and &quot;fixed&quot; to the pattern &quot;dt[&quot;.
</p>
<p>The four flags always available are: &quot;ignore&quot;, &quot;fixed&quot;, &quot;word&quot; and &quot;magic&quot;.
</p>

<ul>
<li><p> &quot;ignore&quot; instructs to ignore the case. Technically, it adds the perl-flag &quot;(?i)&quot;
at the beginning of the pattern.
</p>
</li>
<li><p> &quot;fixed&quot; removes the regular expression interpretation, so that the characters &quot;.&quot;, &quot;$&quot;, &quot;^&quot;, &quot;[&quot;
(among others) lose their special meaning and are treated for what they are: simple characters.
</p>
</li>
<li><p> &quot;word&quot; adds word boundaries (<code>"\\b"</code> in regex language) to the pattern. Further, the comma (<code>","</code>)
becomes a word separator. Technically, &quot;word/one, two&quot; is treated as &quot;\b(one|two)\b&quot;. Example:
<code>string_clean("Am I ambushed?", "wi/am")</code> leads to &quot; I ambushed?&quot; thanks to the flags &quot;ignore&quot; and &quot;word&quot;.
</p>
</li>
<li><p> &quot;magic&quot; allows to interpolate variables inside the pattern before regex interpretation.
For example if <code>letters = "aiou"</code> then <code>string_clean("My great goose!", "magic/[{letters}] =&gt; e")</code>
leads to <code>"My greet geese!"</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
time = "This is the year 2024."

# we break the sentence
string_split(time, " ")

# simplify = FALSE leads to a list
string_split(time, " ", simplify = FALSE)

# let's break at "is"
string_split(time, "is")

# now breaking at the word "is"
# NOTE: we use the flag `word` (`w/`)
string_split(time, "w/is")

# same but using a pattern from a variable
# NOTE: we use the `magic` flag
pat = "is"
string_split(time, "mw/{pat}")


</code></pre>

<hr>
<h2 id='string_split2df'>Splits a character vector into a data frame</h2><span id='topic+string_split2df'></span><span id='topic+string_split2dt'></span>

<h3>Description</h3>

<p>Splits a character vector and formats the resulting substrings into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_split2df(
  x,
  data = NULL,
  split = NULL,
  id = NULL,
  add.pos = FALSE,
  id_unik = TRUE,
  fixed = FALSE,
  ignore.case = FALSE,
  word = FALSE,
  envir = parent.frame(),
  dt = FALSE,
  ...
)

string_split2dt(
  x,
  data = NULL,
  split = NULL,
  id = NULL,
  add.pos = FALSE,
  id_unik = TRUE,
  fixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_split2df_+3A_x">x</code></td>
<td>
<p>A character vector or a two-sided formula. If a two-sided formula, then the
argument <code>data</code> must be provided since the variables will be fetched in there.
A formula is of the form <code>char_var ~ id1 + id2</code> where <code>char_var</code> on the left is a
character variable and on the right <code>id1</code> and <code>id2</code> are identifiers which will be
included in the resulting table. Alternatively, you can provide identifiers via
the argument <code>id</code>.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_data">data</code></td>
<td>
<p>Optional, only used if the argument <code>x</code> is a formula. It should
contain the variables of the formula.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_split">split</code></td>
<td>
<p>A character scalar. Used to split the character vectors. By default
this is a regular expression. You can use flags in the pattern in the form <code style="white-space: pre;">&#8288;flag1, flag2/pattern&#8288;</code>.
Available flags are <code>ignore</code> (case), <code>fixed</code> (no regex), word (add word boundaries),
magic (add interpolation with <code>"{}"</code>). Example:
if &quot;ignore/hello&quot; and the text contains &quot;Hello&quot;, it will be split at &quot;Hello&quot;.
Shortcut: use the first letters of the flags. Ex: &quot;iw/one&quot; will split at the word
&quot;one&quot; (flags 'ignore' + 'word').</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_id">id</code></td>
<td>
<p>Optional. A character vector or a list of vectors. If provided, the
values of <code>id</code> are considered as identifiers that will be included in the resulting table.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_add.pos">add.pos</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to include the position of each split element.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_id_unik">id_unik</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. In the case identifiers are provided,
whether to trigger a message if the identifiers are not unique. Indeed, if
the identifiers are not unique, it is not possible to reconstruct the original texts.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_fixed">fixed</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to consider the argument <code>split</code>
as fixed (and not as a regular expression).</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then case insensitive search is triggered.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_word">word</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then a) word boundaries are added to the pattern,
and b) patterns can be chained by separating them with a comma, they are combined with an OR logical operation.
Example: if <code>word = TRUE</code>, then pattern = &quot;The, mountain&quot; will select strings containing either the word
'The' or the word 'mountain'.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the interpolations if the flag <code>"magic"</code> is provided.
Default is <code>parent.frame()</code>.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_dt">dt</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to return a <code>data.table</code>. See also the function <code>string_split2dt</code>.</p>
</td></tr>
<tr><td><code id="string_split2df_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>data.frame</code> or a <code>data.table</code> which will contain: i) <code>obs</code>: the observation index,
ii) <code>pos</code>: the position of the text element in the initial string (optional, via add.pos),
iii) the text element, iv) the identifier(s) (optional, only if <code>id</code> was provided).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_split2dt()</code>: Splits a string vector and returns a <code>data.table</code>
</p>
</li></ul>


<h3>See Also</h3>

<p>String operations: <code><a href="#topic+string_is">string_is()</a></code>, <code><a href="#topic+string_get">string_get()</a></code>, <code><a href="#topic+string_clean">string_clean()</a></code>, <code><a href="#topic+string_split2df">string_split2df()</a></code>.
Chain basic operations with <code><a href="#topic+string_ops">string_ops()</a></code>. Clean character vectors efficiently
with <code><a href="#topic+string_clean">string_clean()</a></code>.
</p>
<p>Use <code><a href="#topic+string_vec">string_vec()</a></code> to create simple string vectors.
</p>
<p>String interpolation combined with operation chaining: <code><a href="#topic+string_magic">string_magic()</a></code>. You can change <code>string_magic</code>
default values with <code><a href="#topic+string_magic_alias">string_magic_alias()</a></code> and add custom operations with <code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code>.
</p>
<p>Display messages while benefiting from <code>string_magic</code> interpolation with <code><a href="#topic+cat_magic">cat_magic()</a></code> and <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c("Nor rain, wind, thunder, fire are my daughters.",
      "When my information changes, I alter my conclusions.")

id = c("ws", "jmk")

# we split at each word
string_split2df(x, "[[:punct:] ]+")

# we add the 'id'
string_split2df(x, "[[:punct:] ]+", id = id)

# TO NOTE:
# - the second argument is `data`
# - when it is missing, the argument `split` becomes implicitly the second
# - ex: above we did not use `split = "[[:punct:] ]+"`

#
# using the formula

base = data.frame(text = x, my_id = id)
string_split2df(text ~ my_id, base, "[[:punct:] ]+")

#
# with 2+ identifiers

base = within(mtcars, carname &lt;- rownames(mtcars))

# we have a message because the identifiers are not unique
string_split2df(carname ~ am + gear + carb, base, " +")

# adding the position of the words &amp; removing the message
string_split2df(carname ~ am + gear + carb, base, " +", id_unik = FALSE, add.pos = TRUE)


</code></pre>

<hr>
<h2 id='string_vec_alias'>Efficient creation of string vectors with optional interpolation</h2><span id='topic+string_vec_alias'></span><span id='topic+string_vec'></span><span id='topic+stvec'></span>

<h3>Description</h3>

<p>Create string vectors in multiple ways: 1) add successive string elements (like in <code>c()</code>),
or 2) write a character string that will be broken with respect to commas
(<code>"hi, there"</code> becomes <code>c("hi", "there")</code>), or 3) interpolate variables in
character strings (<code>"x{1:2}"</code> becomes <code>c("x1", "x2")</code>) with full access to
<code><a href="#topic+string_magic">string_magic()</a></code> operations, or any combination of the three.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_vec_alias(
  .cmat = FALSE,
  .nmat = FALSE,
  .df = FALSE,
  .df.convert = TRUE,
  .last = NULL,
  .delim = c("{", "}"),
  .split = TRUE,
  .protect.vars = TRUE,
  .sep = NULL,
  .collapse = NULL,
  .namespace = NULL
)

string_vec(
  ...,
  .cmat = FALSE,
  .nmat = FALSE,
  .df = FALSE,
  .df.convert = TRUE,
  .delim = c("{", "}"),
  .envir = parent.frame(),
  .split = TRUE,
  .protect.vars = TRUE,
  .sep = NULL,
  .last = NULL,
  .collapse = NULL,
  .namespace = NULL
)

stvec(
  ...,
  .cmat = FALSE,
  .nmat = FALSE,
  .df = FALSE,
  .df.convert = TRUE,
  .delim = c("{", "}"),
  .envir = parent.frame(),
  .split = TRUE,
  .protect.vars = TRUE,
  .sep = NULL,
  .last = NULL,
  .collapse = NULL,
  .namespace = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_vec_alias_+3A_.cmat">.cmat</code></td>
<td>
<p>Logical scalar (default is <code>FALSE</code>), integer or complex with integer values.
If <code>TRUE</code>, we try to coerce the result into a <strong>character</strong> matrix. The number of rows and columns
is deduced from the look of the arguments. An integer indicates the number of rows.
If a complex, the imaginary part represents the number of columns. Ex: <code>5i</code> means
5 columns, <code>3 + 2i</code> means 3 rows and 2 columns.
</p>
<p>The matrix is always filled by row.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.nmat">.nmat</code></td>
<td>
<p>Logical scalar (default is <code>FALSE</code>), integer or complex with integer values.
If <code>TRUE</code>, we try to coerce the result into a <strong>numeric</strong> matrix. The number of rows and columns
is deduced from the look of the arguments. An integer indicates the number of rows.
If a complex, the imaginary part represents the number of columns. Ex: <code>5i</code> means
5 columns, <code>3 + 2i</code> means 3 rows and 2 columns.
</p>
<p>The matrix is always filled by row. Non numbers are silently turned to NA.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.df">.df</code></td>
<td>
<p>Logical scalar (default is <code>FALSE</code>), integer, complex with integer values, or
character vector.
If <code>TRUE</code>, we try to coerce the result into a <code>data.frame</code>. The number of rows and columns
is deduced from the look of the arguments. An integer indicates the number of rows.
If a complex, the imaginary part represents the number of columns. Ex: <code>5i</code> means
5 columns, <code>3 + 2i</code> means 3 rows and 2 columns.
</p>
<p>If a character vector: it should give the column names. Note that if the vector
is of length 1, its values are comma separated (i.e. the value <code>"id, name"</code> is
identical to <code>c("id", "name")</code>).
</p>
<p>Note that the columns that can be converted to numeric are converted to numeric.
The other columns are in string form. Monitor this behavior with <code>.df.convert</code>.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.df.convert">.df.convert</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Only used when the result is
to be converted to a data frame (with the argument <code>.df</code>). If <code>TRUE</code>, any column
looking like a numeric vector is converted to numeric. Otherwise all columns
are character strings.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.last">.last</code></td>
<td>
<p>Character scalar, a function, or <code>NULL</code> (default). If provided and character:
it must be an <code>string_magic</code> chain of operations of the form <code>"'arg1'op1, op2, etc"</code>. All these operations
are applied just before returning the vector. If a function,
it will be applied to the resulting vector.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.delim">.delim</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("{", "}")</code>. Defines
the opening and the closing delimiters for interpolation.
</p>
<p>If of length 1, it must be of the form: 1) the opening delimiter,
2) a single space, 3) the closing delimiter. Ex: <code>".[ ]"</code> is equivalent to <code>c(".[", "]")</code>.
The default value is equivalent to <code>"{ }"</code>.
</p>
<p>[ ]: R:%20
[&quot;, &quot;]: R:%22,%20%22</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.split">.split</code></td>
<td>
<p>Logical or a character symbol, default is <code>TRUE</code>. If <code>TRUE</code>,
the character vectors are split with respect to commas (default). If <code>FALSE</code>, no
splitting is performed. If a character symbol, the string vector will be split
according to this symbol. Note that any space after the symbol (including tabs and
newlines) is discarded.
</p>
<p>Ex: by default <code>string_vec("hi, there")</code> leads to the vector <code>c("hi", "there")</code>.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.protect.vars">.protect.vars</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If <code>TRUE</code>, then only
arguments equal to a &quot;natural&quot; character scalar are comma-split and interpolated,
other arguments are not touched. Ex: <code>string_vec("x{1:5}")</code> will lead to a vector of
length 5 (&quot;x1&quot; to &quot;x5&quot;), while <code>z = "x{1:5}"</code> followed by <code>string_vec(z)</code> leads
to a vector of length 1: <code>"x{1:5}"</code>. If <code>FALSE</code>, comma-splitting and interpolation
is performed on all variables.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.sep">.sep</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If not <code>NULL</code>, the function
<code><a href="base.html#topic+paste">base::paste()</a></code> is applied to the resulting vector with <code>sep = .sep</code>.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.collapse">.collapse</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If not <code>NULL</code>, the function
<code><a href="base.html#topic+paste">base::paste()</a></code> is applied to the resulting vector with <code>collapse = .collapse</code>.
</p>
<p>If so, pass the name of your package in this argument so that your function can access
the new <code>string_magic</code> operations defined within your package.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.namespace">.namespace</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). <strong>Only useful for package developers.</strong>
As a regular end-user you shouldn't care! If your package uses <code>string_magic</code>, you should care.
It is useful <strong>only</strong> if your package uses 'custom' <code>string_magic</code> operations, set with
<code><a href="#topic+string_magic_register_fun">string_magic_register_fun()</a></code> or <code><a href="#topic+string_magic_register_ops">string_magic_register_ops()</a></code>.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_...">...</code></td>
<td>
<p>Character vectors that will be vectorized. If commas are present in the
character vector, it will be split with respect to commas and following blanks.
The vectors can contain any interpolation in the form <code>"{var}"</code> and
any <code><a href="#topic+string_magic">string_magic()</a></code> operation can be applied. To change the delimiters for interpolation,
see <code>.delim</code>. Named arguments are used in priority for variable substitution,
otherwise the value of the variables to be interpolated are fetched in the calling environment
(see argument <code>.envir</code>).
</p>
<p>Note, importantly, that interpolation and comma splitting are performed on &quot;natural&quot; vectors only.
That is: <code>string_vec("x{1:5}")</code> will lead to a vector of length 5 (&quot;x1&quot; to &quot;x5&quot;), while <code>z = "x{1:5}"</code>
followed by <code>string_vec(z)</code> leads to a vector of length 1: <code>"x{1:5}"</code>. To change this behavior and
obtain equivalent results, use <code>.protect.vars = FALSE</code>.</p>
</td></tr>
<tr><td><code id="string_vec_alias_+3A_.envir">.envir</code></td>
<td>
<p>An environment used to evaluate the variables in <code>"{}"</code>. By default the variables are
evaluated using the environment from where the function is called or using the named
arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main objective of this function is to simplify the creation of small character vectors.
By default, you can pass a character string of length 1 with values separated with commas
and a character vector will be returned.
</p>
<p>You can use interpolation using curly brackets (see <code>string_magic()</code>). You can pass
values for the interpolation directly in the arguments (this is why all
arguments start with a dot).
</p>
<p>By default character values containing commas are split with respect to the commas
to create vectors. To change this behavior, see the argument <code>.split</code>.
</p>
<p>The default of the argument <code>.protect.vars</code> is <code>FALSE</code> so as to avoid unwanted
comma-splitting and interpolations. The main use case of this function is
the creation of small string vectors, which can be written directly at
function call.
</p>
<p>Customize the default of this function with <code><a href="#topic+string_vec_alias">string_vec_alias()</a></code>.
</p>


<h3>Value</h3>

<p>By default this function returns a string vector, the length of which depends on the arguments.
</p>
<p>This result can be processed with the arguments <code>cmat</code>, <code>nmat</code> and <code>.df</code> which will
try to coerce the result into a character matrix, a numeric matrix , or a data frame, respectively.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>string_vec_alias()</code>: Create <code>string_vec</code> aliases with custom defaults
</p>
</li>
<li> <p><code>stvec()</code>: Alias to <code>string_vec</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Other tools with aliases: 
<code><a href="#topic+cat_magic_alias">cat_magic_alias</a>()</code>,
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# illustrating comma-splitting and interpolation
string_vec("x1, y2, z{4:5}")

# variable protection
x = "x{1:5}"
string_vec(x, "y{1:2}")

# without protection =&gt; interpolation takes place
string_vec(x, "y{1:2}", .protect.vars = FALSE)

# removing comma splitting
string_vec("Hi, said Charles.", "Hi, said {girl}.", girl = "Julia", .split = FALSE)

# changing the delimiters for interpolation
pkg = "\\usepackage[usenames,dvipsnames]{xcolor}"
string_vec("\\usepackage{.[S!graphicx, fourier, standalone]}", 
           pkg, .delim = ".[ ]")

#
# Customization
#

# Unhappy about the defaults? Create an alias!

# we create a "matrix generator"
matgen = string_vec_alias(.nmat = TRUE, .last = "'\n'split")

matgen("5, 4, 3
        8, 6, 2")

</code></pre>

<hr>
<h2 id='timer_magic'>Sets up a timer that can be used within <code style="white-space: pre;">&#8288;_magic&#8288;</code> functions</h2><span id='topic+timer_magic'></span>

<h3>Description</h3>

<p>Sets up a timer which can later be summoned by <code><a href="#topic+string_magic">string_magic()</a></code> functions via
the <code>.timer</code>, <code>.timer_lap</code> and <code>.timer_total</code> variables. Useful to report
timings within functions with the function <code><a href="#topic+cat_magic">cat_magic()</a></code> or <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timer_magic()
</code></pre>


<h3>Details</h3>

<p>This functions sets up a timer with <code><a href="base.html#topic+Sys.time">base::Sys.time()</a></code>. This timer can then be tracked
and modified with the <code>.timer</code>, <code>.timer_lap</code> and <code>.timer_total</code> variables within
<code><a href="#topic+cat_magic">cat_magic()</a></code> or <code><a href="#topic+message_magic">message_magic()</a></code>.
</p>
<p>Note that the timer is precise at +/- 1ms, hence it should <strong>not</strong> be used to time
algorithms with very short execution times.
</p>
<p>It works by saving the current system time in R options (<code>stringmagic_timer</code> and <code>stringmagic_timer_origin</code>).
Hence, since it uses options, it should not be used in parallel processes.
</p>


<h3>Value</h3>

<p>This function does not return anything and is only intended to be used in
conjunction with future calls of <code><a href="#topic+string_magic">string_magic()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Other tools with aliases: 
<code><a href="#topic+string_clean_alias">string_clean_alias</a>()</code>,
<code><a href="#topic+string_magic">string_magic</a>()</code>,
<code><a href="#topic+string_magic_alias">string_magic_alias</a>()</code>,
<code><a href="#topic+string_ops_alias">string_ops_alias</a>()</code>,
<code><a href="#topic+string_vec_alias">string_vec_alias</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple example where we time the execution of some elements in a function
# we trigger the message conditionally on the value of the argument `debug`.
rnorm_crossprod = function(n, mean = 0, sd = 1, debug = FALSE){
  # we set the timer
  timer_magic()
  # we compute some stuff
  x = rnorm(n, mean, sd)
  # we can report the time with .timer
  message_magic("{15 align ! Generation}: {.timer}", .trigger = debug)
  
  res = x %*% x
  message_magic("{15 align ! Product}: {.timer}",
                "{15 align ! Total}: {.timer_total}", 
                .sep = "\n", .trigger = debug)
  res
}

rnorm_crossprod(1e5, TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
