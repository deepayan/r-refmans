<!DOCTYPE html><html><head><title>Help for package custom.gauss.quad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {custom.gauss.quad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#custom'><p>Custom-Made Gauss Quadrature Nodes and Weights</p></a></li>
<li><a href='#custom.gauss.quad-package'><p>custom.gauss.quad: Custom Made Gauss Quadrature Nodes and Weights</p></a></li>
<li><a href='#moments'><p>Moments Computed in Multiple Precision Using the Package Rmpfr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Custom Made Gauss Quadrature Nodes and Weights</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Kabaila &lt;p.kabaila@latrobe.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Use the high-precision arithmetic provided by the R package 'Rmpfr' 
    to compute a custom-made Gauss quadrature nodes and weights, 
    with up to 33 nodes, using a moment-based method via moment 
    determinants. Paul Kabaila (2022) &lt;<a href="https://arxiv.org/abs/2211.04729">arXiv:2211.04729</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpfr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 02:47:08 UTC; Kabaila</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Kabaila <a href="https://orcid.org/0000-0002-9205-668X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-16 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='custom'>Custom-Made Gauss Quadrature Nodes and Weights</h2><span id='topic+custom'></span>

<h3>Description</h3>

<p>For the nonnegative weight function specified by <code>which.f</code> and given
number <code>n</code> of nodes, the function <code>custom</code> computes the
Gauss quadrature nodes <code>asNumeric.nodes</code> and corresponding weights
<code>asNumeric.weights</code> which are double precision vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom(which.f, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_+3A_which.f">which.f</code></td>
<td>
<p>a list specifying the nonnegative integrable
weight function <code class="reqn">f</code>, with the following three components:
(i)  name (in the form of a character string),
(ii) support specified by a 2-vector of the endpoints of the interval,
(iii) parameter vector when <code class="reqn">f</code> belongs to a family of
weight functions and is specified by the value of this
parameter vector (if <code class="reqn">f</code> is already fully specified
then the parameter vector is set to <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="custom_+3A_n">n</code></td>
<td>
<p>number of Gauss quadrature nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that we wish to evaluate
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} g(x) f(x) dx,</code>
</p>

<p>where <code class="reqn">f</code> is a specified nonnegative integrable
weight function. The Gauss quadrature approximation to this
integral has the form
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n \lambda_i \, g(\tau_i),</code>
</p>

<p>where <code class="reqn">\tau_1, \dots, \tau_n</code> are called the nodes
and <code class="reqn">\lambda_1, \dots, \lambda_n</code> are called the
corresponding weights. This approximation is exact
whenever <code class="reqn">g</code> is a polynomial of degree less
than or equal to <code class="reqn">2n - 1</code>.
</p>
<p>If <code class="reqn">f</code> takes a form that leads to Gauss quadrature
rules with nodes that are the roots of classical orthogonal
polynomials of a continuous variable then these rules
(such as Gauss Legendre, Gauss Hermite and Gauss Laguerre) are
readily accessible to statisticians via <code>R</code> packages
such as <code>statmod</code>.
If, however, <code class="reqn">f</code> does not take one of these
particular forms then the Gauss quadrature nodes and weights
need to be custom-made.
</p>
<p><code>custom</code> computes the Gauss quadrature nodes
and weights, for given <code>n</code>, using a user-supplied formula
for the <code class="reqn">r</code>'th moment
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} x^r f(x) dx</code>
</p>

<p>for all nonnegative integers <code class="reqn">r</code>. This formula must be inserted
by the user into the code for the function
<code>moments</code> and must be able to be computed
to an arbitrary number of bits (<code>nbits</code>) of precision
using the <code>R</code> package <code>Rmpfr</code>.
</p>
<p>To obtain some assurance that the Gauss quadrature nodes
and weights are computed to sufficient precision for subsequent
double precision computations in <code>R</code>, these nodes and
weights are computed for the increasing numbers of bits of
precision given in the 5-vector <code>nbits.vec</code> and the results
compared. This comparison results in the criteria
<code>max.abs.diffs.nodes</code>, <code>sum.abs.diffs.weights</code>,
<code>L.nodes</code> and <code>L.weights</code> described in detail by
Kabaila (2022). The execution times for various parts of the
code are stored in <code>mat.timings</code> whose components are
described by Kabaila (2022).
</p>
<p><code>list.Gauss.nodes[[i]]</code> and <code>list.Gauss.weights[[i]]</code>
are the <code>n</code>-vectors of Gauss quadrature nodes and weights,
respectively, computed using <code>nbits.vec[i]</code> bits of precision
(<code>i=1,...,5</code>).
</p>
<p>The most accurate approximations to the Gauss quadrature nodes and weights are
<code>list.Gauss.nodes[[5]]</code> and <code>list.Gauss.weights[[5]]</code>. These are
converted to double precision by applying the <code>asNumeric</code>
function from the <code>R</code> package <code>Rmpfr</code>, resulting
in <code>asNumeric.nodes</code> and <code>asNumeric.weights</code>, respectively.
</p>


<h3>Value</h3>

<p>A list with the following elements:
<code>which.f</code>,
<code>n</code>,
<code>nbits.vec</code>,
<code>list.Gauss.nodes</code>,
<code>list.Gauss.weights</code>,
<code>mat.timings</code>,
<code>max.abs.diffs.nodes</code>,
<code>sum.abs.diffs.weights</code>,
<code>L.nodes</code>,
<code>L.weights</code>,
<code>asNumeric.nodes</code>,
<code>asNumeric.weights</code>.
</p>


<h3>References</h3>

<p>Kabaila, P. (2022) Custom-made Gauss quadrature for statisticians. arXiv:2211.04729
</p>


<h3>See Also</h3>

<p><code>moments</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose that the weight function f is the probability density
# function of a random variable with the same probability
# distribution as R divided by the square root of m, where R has a
# chi distribution with m degrees of freedom.
# Also suppose that we wish to compute the Gauss quadrature nodes
# and weights, for number of nodes n = 5, when the parameter m = 160.
# The r th moment can be computed to an arbitrary number of bits of
# precision using the R package Rmpfr. We describe the weight function
# f using the following R commands:

m &lt;- 160
which.f &lt;- list(name="scaled.chi.pdf", support=c(0, Inf),
parameters=m)

# Here, "scaled.chi.pdf" is the name (a character string) that we
# have given to the weight function f. The R function moments includes
# the code needed to compute the r th moment to an arbitrary number
# of bits of precision using the R package Rmpfr.
# We compute the Gauss quadrature node and weight, for the toy example
# with number of nodes n=1, using the following R commands:

n &lt;- 1
gauss.list &lt;- custom(which.f, n)
old &lt;- options(digits = 17)
gauss.list$asNumeric.nodes
gauss.list$asNumeric.weights
options(old)

# These commands take less than 1 second to run. The resulting
# of node and corresponding weight in double precision are:
# &gt; gauss.list$asNumeric.nodes
# [1] 0.99843873022375829
# &gt; gauss.list$asNumeric.weights
# [1] 1

# The computation times for number of nodes n=5, 17 and 33 are roughly
# 160 seconds, 31 minutes and 5 hours,respectively.
#
# We compute the Gauss quadrature nodes and weights, for number of
# nodes n=5, using the following R commands:

n &lt;- 5
gauss.list &lt;- custom(which.f, n)
old &lt;- options(digits = 17)
gauss.list$asNumeric.nodes
gauss.list$asNumeric.weights
options(old)

# These commands take roughly 3 minutes to run. The resulting vectors
# of nodes and corresponding weights in double precision are:
# &gt; gauss.list$asNumeric.nodes
# [1] 0.84746499810651410 0.92785998378868118 1.00262691212158761
# [4] 1.07930375924992528 1.16628363226782716
# &gt; gauss.list$asNumeric.weights
# [1] 0.0144433732487188448 0.2483585328946608384 0.5305446123744097520
# [4] 0.1977278905956056654 0.0089255908866048821


</code></pre>

<hr>
<h2 id='custom.gauss.quad-package'>custom.gauss.quad: Custom Made Gauss Quadrature Nodes and Weights</h2><span id='topic+custom.gauss.quad'></span><span id='topic+custom.gauss.quad-package'></span>

<h3>Description</h3>

<p>Use the high-precision arithmetic provided by the R package 'Rmpfr' to compute a custom-made Gauss quadrature nodes and weights, with up to 33 nodes, using a moment-based method via moment determinants. Paul Kabaila (2022) <a href="https://arxiv.org/abs/2211.04729">arXiv:2211.04729</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul Kabaila <a href="mailto:p.kabaila@latrobe.edu.au">p.kabaila@latrobe.edu.au</a> (<a href="https://orcid.org/0000-0002-9205-668X">ORCID</a>)
</p>

<hr>
<h2 id='moments'>Moments Computed in Multiple Precision Using the Package Rmpfr</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>This module computes the <code>r</code>'th moment
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} x^r f(x) dx,</code>
</p>

<p>where <code class="reqn">f</code> is the weight function (specified by the list <code>which.f</code>), for any nonnegative integer <code>r</code> using <code>nbits</code> bits of precision for its computation, via the <code>R</code> package <code>Rmpfr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(which.f, r, nbits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_+3A_which.f">which.f</code></td>
<td>
<p>a list specifying the nonnegative integrable
weight function <code class="reqn">f</code>, with the following 3 components:
(i)  name (in the form of a character string),
(ii) support specified by a 2-vector of the endpoints of the interval,
(iii)  parameter vector when <code class="reqn">f</code> belongs to a family of
weight functions and is specified by the value of this
parameter vector (if <code class="reqn">f</code> is already fully specified
then the parameter vector is set to <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="moments_+3A_r">r</code></td>
<td>
<p>nonnegative integer, specifying that it is the <code>r</code>'th moment for the weight function <code class="reqn">f</code> that is to be computed</p>
</td></tr>
<tr><td><code id="moments_+3A_nbits">nbits</code></td>
<td>
<p>number of bits in the multiple precision numbers used by the <code>R</code> package <code>Rmpfr</code>
to carry out the computation of the <code>r</code>'th moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose, for example, that we wish to find the Gauss quadrature nodes and weights
for the weight function <code class="reqn">f</code> that is the probability density function of a random
variable with the same distribution as <code class="reqn">R/m^{1/2}</code> where <code class="reqn">R</code> has a
<code class="reqn">\chi_m</code> distribution (i.e. <code class="reqn">R^2</code> has a <code class="reqn">\chi_m^2</code> distribution).
In this case, the <code>r</code>'th moment is
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{\infty} x^r f(x) dx
    = \left(\frac{2}{m} \right)^{r/2}
    \frac{\Gamma((r+m)/2)}{\Gamma(m/2)},</code>
</p>

<p>which can be computed to an arbitrary number of bits of precision
<code>nbits</code> using the <code>R</code> package <code>Rmpfr</code>.
In this case, we specify this weight function <code class="reqn">f</code> by first
assigning the value of <code>m</code> and then using the <code>R</code> command
</p>
<p><code>which.f &lt;- list(name="scaled.chi.pdf", support=c(0, Inf), parameters=m)</code>
</p>
<p>The code within the function <code>moments</code> used to compute the
<code class="reqn">r</code>'th moment, to an arbitrary number of bits of precision
<code>nbits</code> using the package <code>Rmpfr</code>, is listed in the
Examples section.
</p>


<h3>Value</h3>

<p>The <code>r</code>'th moment with number of bits of precision
<code>nbits</code> used in its computation, via the <code>R</code> package <code>Rmpfr</code>
</p>


<h3>See Also</h3>

<p><code>custom</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The code for the function moments must include a section
# that computes the r th moment to an arbitrary number of bits
# of precision nbits using the R package Rmpfr for the particular
# weight function f of interest.
# Suppose that the weight function f is the probability density
# function of a random variable with the same probability
# distribution as R divided by the square root of m, where R has a
# chi distribution with m degrees of freedom.
# The code for the function moments includes the following:
#
#    if (which.f$name == "scaled.chi.pdf"){
#    m &lt;- which.f$parameters
#    if (r == 0){
#    return(mpfr(1, nbits))
#    }
#    mp.2 &lt;- mpfr(2, nbits)
#    mp.r &lt;- mpfr(r, nbits)
#    mp.m &lt;- mpfr(m, nbits)
#    term1 &lt;- (mp.r/ mp.2) * log(mp.2 / mp.m)
#    term2 &lt;- lgamma((mp.r + mp.m) / mp.2)
#    term3 &lt;- lgamma(mp.m / mp.2)
#    return(exp(term1 + term2 - term3))
#    }

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
