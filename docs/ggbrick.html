<!DOCTYPE html><html lang="en"><head><title>Help for package ggbrick</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggbrick}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brick_row'><p>Brick row</p></a></li>
<li><a href='#build_wall'><p>Build the wall</p></a></li>
<li><a href='#build_wall_waffle'><p>Build the wall</p></a></li>
<li><a href='#coord_brick'><p>Cartesian coordinates with fixed &quot;aspect ratio&quot;</p></a></li>
<li><a href='#GeomBrick'><p>GeomBrick</p></a></li>
<li><a href='#GeomBrick0'><p>GeomBrick</p></a></li>
<li><a href='#GeomWaffle'><p>GeomBrick</p></a></li>
<li><a href='#GeomWaffle0'><p>GeomBrick</p></a></li>
<li><a href='#half_brick_row'><p>half brick row</p></a></li>
<li><a href='#make_new_fill'><p>Fill</p></a></li>
<li><a href='#robust_random'><p>Robust random</p></a></li>
<li><a href='#robust_round'><p>Robust round</p></a></li>
<li><a href='#stat_brick'><p>stat_brick</p></a></li>
<li><a href='#stat_waffle'><p>stat_brick</p></a></li>
<li><a href='#switch_pos'><p>Switch position for soft random</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Waffle Style Chart with a Brick Layout in 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Oehm &lt;danieloehm@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A new take on the bar chart. Similar to a waffle style chart but
  instead of squares the layout resembles a brick wall.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, dplyr, purrr, glue</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 05:41:08 UTC; danie</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Oehm [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='brick_row'>Brick row</h2><span id='topic+brick_row'></span>

<h3>Description</h3>

<p>Brick row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brick_row(
  layer,
  bpl,
  brick_height = 1,
  brick_width = 2.5,
  gap = 0.125,
  width = 0.9,
  .geom = "brick"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brick_row_+3A_layer">layer</code></td>
<td>
<p>Brick layer.</p>
</td></tr>
<tr><td><code id="brick_row_+3A_bpl">bpl</code></td>
<td>
<p>Number of bricks in the layer.</p>
</td></tr>
<tr><td><code id="brick_row_+3A_brick_height">brick_height</code></td>
<td>
<p>Brick height.</p>
</td></tr>
<tr><td><code id="brick_row_+3A_brick_width">brick_width</code></td>
<td>
<p>Brick width.</p>
</td></tr>
<tr><td><code id="brick_row_+3A_gap">gap</code></td>
<td>
<p>Gap between the bricks.</p>
</td></tr>
<tr><td><code id="brick_row_+3A_width">width</code></td>
<td>
<p>Column width</p>
</td></tr>
<tr><td><code id="brick_row_+3A_.geom">.geom</code></td>
<td>
<p>Geom type for layering. Either 'brick' or 'brick_waffle'</p>
</td></tr>
</table>

<hr>
<h2 id='build_wall'>Build the wall</h2><span id='topic+build_wall'></span>

<h3>Description</h3>

<p>Build the wall
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_wall(n_bricks, height, bpl, gap = NULL, width = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_wall_+3A_n_bricks">n_bricks</code></td>
<td>
<p>Number of bricks</p>
</td></tr>
<tr><td><code id="build_wall_+3A_height">height</code></td>
<td>
<p>Height of the wall.</p>
</td></tr>
<tr><td><code id="build_wall_+3A_bpl">bpl</code></td>
<td>
<p>Bricks per layer</p>
</td></tr>
<tr><td><code id="build_wall_+3A_gap">gap</code></td>
<td>
<p>The space between bricks.</p>
</td></tr>
<tr><td><code id="build_wall_+3A_width">width</code></td>
<td>
<p>Column_width</p>
</td></tr>
</table>

<hr>
<h2 id='build_wall_waffle'>Build the wall</h2><span id='topic+build_wall_waffle'></span>

<h3>Description</h3>

<p>Build the wall
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_wall_waffle(n_bricks, height, bpl, gap = NULL, width = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_wall_waffle_+3A_n_bricks">n_bricks</code></td>
<td>
<p>Number of bricks</p>
</td></tr>
<tr><td><code id="build_wall_waffle_+3A_height">height</code></td>
<td>
<p>Height of the wall.</p>
</td></tr>
<tr><td><code id="build_wall_waffle_+3A_bpl">bpl</code></td>
<td>
<p>Bricks per layer</p>
</td></tr>
<tr><td><code id="build_wall_waffle_+3A_gap">gap</code></td>
<td>
<p>The space between bricks.</p>
</td></tr>
<tr><td><code id="build_wall_waffle_+3A_width">width</code></td>
<td>
<p>Column width.</p>
</td></tr>
</table>

<hr>
<h2 id='coord_brick'>Cartesian coordinates with fixed &quot;aspect ratio&quot;</h2><span id='topic+coord_brick'></span><span id='topic+coord_waffle'></span>

<h3>Description</h3>

<p>A fixed scale coordinate system forces a specified ratio similar to
<code>coord_fixed</code>. It holds the coordinates fixed at the right ratio
to ensure each brick is of the right dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_brick(
  bricks_per_layer = 4,
  ratio = NULL,
  xlim = NULL,
  ylim = NULL,
  expand = TRUE,
  clip = "on",
  width = 0.9
)

coord_waffle(
  bricks_per_layer = 4,
  ratio = NULL,
  xlim = NULL,
  ylim = NULL,
  expand = TRUE,
  clip = "on",
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coord_brick_+3A_bricks_per_layer">bricks_per_layer</code></td>
<td>
<p>Number of bricks per layer. Should match the <code>bricks_per_layer</code>
specification in <code>geom_brick</code>. Default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="coord_brick_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio, expressed as <code>y / x</code></p>
</td></tr>
<tr><td><code id="coord_brick_+3A_xlim">xlim</code>, <code id="coord_brick_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_brick_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="coord_brick_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins.</p>
</td></tr>
<tr><td><code id="coord_brick_+3A_width">width</code></td>
<td>
<p>Column width. If using a different <code>width</code> in <code>geom_brick</code>
use the same <code>width</code> here to ensure correct scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ensures that the ranges of axes are equal to the specified ratio by

library(ggplot2)
library(dplyr)

# create a base plot
plt &lt;- mpg %&gt;%
  count(class, drv) %&gt;%
  ggplot() +
  geom_brick(aes(class, n, fill = drv), bricks_per_layer = 6)

# view the base plot
plt

# View the base plot with fixed coords
# Ensure `bricks_per_layer` matches the geom
plt %&gt;%
  coord_brick(6)

# The same using `geom_waffle`
mpg %&gt;%
  count(class, drv) %&gt;%
  ggplot() +
  geom_waffle(aes(class, n, fill = drv), bricks_per_layer = 6) +
  coord_waffle(6)
</code></pre>

<hr>
<h2 id='GeomBrick'>GeomBrick</h2><span id='topic+GeomBrick'></span>

<h3>Description</h3>

<p>GeomBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomBrick
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomBrick</code> (inherits from <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='GeomBrick0'>GeomBrick</h2><span id='topic+GeomBrick0'></span>

<h3>Description</h3>

<p>GeomBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomBrick0
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomBrick0</code> (inherits from <code>GeomBrick</code>, <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='GeomWaffle'>GeomBrick</h2><span id='topic+GeomWaffle'></span>

<h3>Description</h3>

<p>GeomBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomWaffle
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomWaffle</code> (inherits from <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='GeomWaffle0'>GeomBrick</h2><span id='topic+GeomWaffle0'></span>

<h3>Description</h3>

<p>GeomBrick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomWaffle0
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomWaffle0</code> (inherits from <code>GeomWaffle</code>, <code>GeomRect</code>, <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='half_brick_row'>half brick row</h2><span id='topic+half_brick_row'></span>

<h3>Description</h3>

<p>half brick row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half_brick_row(
  layer,
  bpl,
  brick_height = 1,
  brick_width = 2.5,
  gap = 0.125,
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="half_brick_row_+3A_layer">layer</code></td>
<td>
<p>Brick layer.</p>
</td></tr>
<tr><td><code id="half_brick_row_+3A_bpl">bpl</code></td>
<td>
<p>Number of bricks in the layer.</p>
</td></tr>
<tr><td><code id="half_brick_row_+3A_brick_height">brick_height</code></td>
<td>
<p>Brick height.</p>
</td></tr>
<tr><td><code id="half_brick_row_+3A_brick_width">brick_width</code></td>
<td>
<p>Brick width.</p>
</td></tr>
<tr><td><code id="half_brick_row_+3A_gap">gap</code></td>
<td>
<p>Gap between the bricks.</p>
</td></tr>
<tr><td><code id="half_brick_row_+3A_width">width</code></td>
<td>
<p>Column_width</p>
</td></tr>
</table>

<hr>
<h2 id='make_new_fill'>Fill</h2><span id='topic+make_new_fill'></span>

<h3>Description</h3>

<p>Makes the vector for the fill aesthetic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_new_fill(fill, n, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_new_fill_+3A_fill">fill</code></td>
<td>
<p>The fill vector.</p>
</td></tr>
<tr><td><code id="make_new_fill_+3A_n">n</code></td>
<td>
<p>Vector representing the number of bricks for the fill level.</p>
</td></tr>
<tr><td><code id="make_new_fill_+3A_val">val</code></td>
<td>
<p>Vector of length the same as fill of with 1 o 0.5 for whole or half bricks.</p>
</td></tr>
</table>

<hr>
<h2 id='robust_random'>Robust random</h2><span id='topic+robust_random'></span>

<h3>Description</h3>

<p>Ensures the half bricks are randomised in pairs to preserve the total
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_random(x, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_random_+3A_x">x</code></td>
<td>
<p>x.</p>
</td></tr>
<tr><td><code id="robust_random_+3A_val">val</code></td>
<td>
<p>Value.</p>
</td></tr>
</table>

<hr>
<h2 id='robust_round'>Robust round</h2><span id='topic+robust_round'></span>

<h3>Description</h3>

<p>Robust round
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_round(x, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_round_+3A_x">x</code></td>
<td>
<p>Vector of values.</p>
</td></tr>
<tr><td><code id="robust_round_+3A_n">N</code></td>
<td>
<p>Value to preserve sum to.</p>
</td></tr>
</table>

<hr>
<h2 id='stat_brick'>stat_brick</h2><span id='topic+stat_brick'></span><span id='topic+brick'></span><span id='topic+geom_brick'></span><span id='topic+geom_brick0'></span>

<h3>Description</h3>

<p>Creates a 'waffle' style chart with the aesthetic of a brick wall. Usage is
similar to <code>geom_col</code> where you supply counts as the height of the bar. Each
whole brick represents 1 unit. Two half bricks equal one whole brick. Where
the count exceeds the number of brick layers, the number of bricks is scaled
to retain the brick wall aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_brick(
  mapping = NULL,
  data = NULL,
  geom = "rect",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.9,
  bricks_per_layer = 4,
  type = "ordered",
  gap = NULL,
  ...
)

geom_brick(
  mapping = NULL,
  data = NULL,
  stat = "brick",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  bricks_per_layer = 4,
  width = 0.9,
  type = "ordered",
  gap = NULL,
  ...
)

geom_brick0(
  mapping = NULL,
  data = NULL,
  stat = "brick",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  bricks_per_layer = 4,
  type = "ordered",
  gap = 0,
  width = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_brick_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_geom">geom</code></td>
<td>
<p>Geom</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> removes <code>NA</code>s from the data.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_width">width</code></td>
<td>
<p>Column width. Default value is <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_bricks_per_layer">bricks_per_layer</code></td>
<td>
<p>The number of bricks per layer. Default 4.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_type">type</code></td>
<td>
<p>The type of fill ordering. one of 'ordered', 'random' or 'soft_random', Default 'ordered'</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_gap">gap</code></td>
<td>
<p>The space between bricks.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_...">...</code></td>
<td>
<p>Dots.</p>
</td></tr>
<tr><td><code id="stat_brick_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Aesthetics</h3>

<p><code>geom_brick()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>group
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>linewidth
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(dplyr)
mpg %&gt;%
  count(class, drv) %&gt;%
  ggplot() +
  geom_brick(aes(class, n, fill = drv)) +
  coord_brick()
</code></pre>

<hr>
<h2 id='stat_waffle'>stat_brick</h2><span id='topic+stat_waffle'></span><span id='topic+waffle'></span><span id='topic+geom_waffle'></span><span id='topic+geom_waffle0'></span>

<h3>Description</h3>

<p>Creates a 'waffle' style chart with the aesthetic of a brick wall. Usage is
similar to <code>geom_col</code> where you supply counts as the height of the bar. Each
whole brick represents 1 unit. Two half bricks equal one whole brick. Where
the count exceeds the number of brick layers, the number of bricks is scaled
to retain the brick wall aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_waffle(
  mapping = NULL,
  data = NULL,
  geom = "rect",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  bricks_per_layer = 4,
  type = "ordered",
  gap = NULL,
  width = 0.9,
  ...
)

geom_waffle(
  mapping = NULL,
  data = NULL,
  stat = "waffle",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  bricks_per_layer = 4,
  type = "ordered",
  gap = NULL,
  width = 0.9,
  ...
)

geom_waffle0(
  mapping = NULL,
  data = NULL,
  stat = "waffle",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  bricks_per_layer = 4,
  type = "ordered",
  gap = 0,
  width = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_waffle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_geom">geom</code></td>
<td>
<p>Geom</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> removes <code>NA</code>s from the data.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_bricks_per_layer">bricks_per_layer</code></td>
<td>
<p>The number of bricks per layer. Default 4.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_type">type</code></td>
<td>
<p>The type of fill ordering. one of 'ordered', 'random' or 'soft_random', Default 'ordered'</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_gap">gap</code></td>
<td>
<p>The space between bricks.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_width">width</code></td>
<td>
<p>Column width. Default <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_...">...</code></td>
<td>
<p>Dots.</p>
</td></tr>
<tr><td><code id="stat_waffle_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Aesthetics</h3>

<p><code>geom_waffle()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li><p><strong>x</strong>
</p>
</li>
<li><p><strong>y</strong>
</p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>group
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>linewidth
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(dplyr)
mpg %&gt;%
  count(class, drv) %&gt;%
  ggplot() +
  geom_waffle(aes(class, n, fill = drv)) +
  coord_waffle()
</code></pre>

<hr>
<h2 id='switch_pos'>Switch position for soft random</h2><span id='topic+switch_pos'></span>

<h3>Description</h3>

<p>Switch position for soft random
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_pos(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch_pos_+3A_x">x</code></td>
<td>
<p>Vector to switch values in.</p>
</td></tr>
<tr><td><code id="switch_pos_+3A_n">n</code></td>
<td>
<p>Number to switch.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
