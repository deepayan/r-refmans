<!DOCTYPE html><html><head><title>Help for package bigBits</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigBits}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bigBits-package'>
<p>Perform Boolean Operations on Large Numbers</p></a></li>
<li><a href='#base2base'>
<p>Function which converts arbitrary-size integers from any base to any base.</p></a></li>
<li><a href='#bigAnd'>
<p>Functions to perform binary operations on integers of arbitrary size, and of arbitrary base (up to 36).</p></a></li>
<li><a href='#buildBinaries'>
<p>Function to convert values to binary form</p></a></li>
<li><a href='#fracB2B'>
<p>Function which converts fractions (between 1 and 0) from any base to any other base.</p></a></li>
<li><a href='#noExp'>
<p>Function to convert character-string numbers in exponential notation to &quot;pure&quot; integers.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform Boolean Operations on Large Numbers</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-27</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of Boolean operators which accept integers of any size, in any base from 2 to 36, including 2's complement format, and perform actions like "AND," "OR", "NOT", "SHIFTR/L" etc. The output can be in any base specified. A direct base to base converter is included. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpfr, gmp, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 11:53:47 UTC; cgw</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Witthoft [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Witthoft &lt;cellocgw@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 13:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bigBits-package'>
Perform Boolean Operations on Large Numbers
</h2><span id='topic+bigBits-package'></span><span id='topic+bigBits'></span>

<h3>Description</h3>

<p>A set of Boolean operators which accept integers of any size, in any base from 2 to 36, including 2's complement format, and perform actions like &quot;AND,&quot; &quot;OR&quot;, &quot;NOT&quot;, &quot;SHIFTR/L&quot; etc. The output can be in any base specified. A direct base to base converter is included. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bigBits</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Perform Boolean Operations on Large Numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-06-27</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given = "Carl", family = "Witthoft", email = "cellocgw@gmail.com", role = c("aut", "cre")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A set of Boolean operators which accept integers of any size, in any base from 2 to 36, including 2's complement format, and perform actions like "AND," "OR", "NOT", "SHIFTR/L" etc. The output can be in any base specified. A direct base to base converter is included. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rmpfr, gmp, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Carl Witthoft [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Carl Witthoft &lt;cellocgw@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h3>Author(s)</h3>

<p>Carl Witthoft [aut, cre]
</p>
<p>Maintainer: Carl Witthoft &lt;cellocgw@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two's_complement</a> 
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+bitwAnd">bitwAnd</a></code> and other &quot;bitw*&quot; functions
</p>

<hr>
<h2 id='base2base'>
Function which converts arbitrary-size integers from any base to any base. 
</h2><span id='topic+base2base'></span>

<h3>Description</h3>

<p>This function accepts inputs in  any base from 2 through 36 and produces the same value in any selected base from 2 through 36. This includes options for signed and 2s complement binary data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base2base(x,frombase=10, tobase=2, classOut=c('bigz', 'mpfr',
 'numeric','character') , binSize = 0, inTwosComp = FALSE,
   outTwosComp = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base2base_+3A_x">x</code></td>
<td>

<p>A value or vector or list of values which are to be converted. The class can generally be numeric, mpfr, bigz, or character strings. Any fractional part is removed, leaving just the integer portion.  See Details for more information. 
</p>
</td></tr>
<tr><td><code id="base2base_+3A_frombase">frombase</code></td>
<td>

<p>The base of the input <code>x</code>. If the contents of <code>x</code> are incompatible with the specified base, a warning is issued and that value is skipped (i.e. if <code>x</code> has multiple values, <code>base2base</code> will keep running and process the other values). Default is 10
</p>
</td></tr>
<tr><td><code id="base2base_+3A_tobase">tobase</code></td>
<td>

<p>The desired base of the output. Default is 2.
</p>
</td></tr>
<tr><td><code id="base2base_+3A_classout">classOut</code></td>
<td>

<p>Specify the class of the output. This only has meaning when <code>tobase</code> is 10; all other bases are returned as character strings. Warning: if the input is larger than the max integer size on your system and &quot;numeric&quot; is selected, there will be a roundoff/truncation error.  
</p>
</td></tr>
<tr><td><code id="base2base_+3A_binsize">binSize</code></td>
<td>

<p>Specifies how many digits are to be generated.  If this value is less than that necessary to contain the output value, the number of digits will be increased to match.  If the output is binary, the final number of digits is expanded to a 4*N value. The default is zero, which allows the function to calculate the minimum  bits required. Note: for obvious reasons, this only applies to character-class outputs. 
</p>
</td></tr>
<tr><td><code id="base2base_+3A_intwoscomp">inTwosComp</code></td>
<td>

<p>Only checked if <code>frombase</code> is 2.  If FALSE, (the default), the input is  positive unless a negative sign is present.  If TRUE, the input is handled as a 2s complement binary. 
</p>
</td></tr>
<tr><td><code id="base2base_+3A_outtwoscomp">outTwosComp</code></td>
<td>

<p>Only checked if <code>tobase</code> is 2.  If FALSE, (the default), the output, if negative, includes a &quot;-&quot; sign.  If TRUE,  a 2's complement binary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, when submitting an input in other than base 10, it's safest to provide a character string(s). There is some automagical conversion that will take, e.g., a numeric  <code>364</code> with <code>frombase = 8</code> and treat as base 8 (thus decimal 244), but this is not guaranteed.  Further, keep in mind that numeric values with more than roughly 16 digits will likely run into floating-point precision errors. For base-10 inputs, use of <code>bigz</code> form is recommended. 
Inputs in hex format must be character strings.  This is because the command parser converts, e.g.,  0x3a, to the decimal value 58 prior to passing the value to the function body.  Since, as noted above, <code>base2base</code> will attempt to convert a numeric input into the value in the base specified,  <code>base2base(0x3a, inbase= 16, ...)</code> will in fact process the input as  58hex, i.e. 88 decimal. 
</p>


<h3>Value</h3>

<p>A list containing the converted value(s). Unless <code>tobase</code> is 10, each element is a character string.  When <code>tobase</code> is equal to 10, the output class is specified with the argument <code>classOut</code> .  
Note: if an input or output is incompatible with the specified input or output base, a dummy value &quot;%no&quot; if character, or &quot;NA&quot; if a number-like class,  is returned along with a warning message describing the error. 
</p>


<h3>Author(s)</h3>

<p>Author and Maintainer:Carl Witthoft <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strtoi">strtoi</a></code>
<code><a href="base.html#topic+as.hexmode">as.hexmode</a></code>
<code>fracB2B</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(base2base(12.4e1,10,16))
(base2base(12.4e-2,10,16))
(base2base(101101,2,10))  # magic. it works!!!
(base2base('1111',2,2,inTwosComp=TRUE, outTwosComp=TRUE))
(base2base('0111',2,2,inTwosComp=TRUE, outTwosComp=TRUE))
(base2base('1111',2,2,inTwosComp=TRUE, outTwosComp=FALSE))
(base2base('0111',2,2,inTwosComp=TRUE, outTwosComp= FALSE))
(base2base(1e55,10,16)) #loses precision before even starting
(base2base('1e55',10,16)) #works
(base2base('1767707668033969' , 10, 36))
</code></pre>

<hr>
<h2 id='bigAnd'>
Functions to perform binary operations on integers of arbitrary size, and of arbitrary base (up to 36). 
</h2><span id='topic+bigAnd'></span><span id='topic+bigOr'></span><span id='topic+bigXor'></span><span id='topic+bigNot'></span><span id='topic+bigShiftL'></span><span id='topic+bigShiftR'></span><span id='topic+bigRotate'></span>

<h3>Description</h3>

<p>These functions extend the capabilities of the matching base <code>bitw*</code> functions (which are limited to 32-bit integers).  Not only can any integer be processed, at least up to the machine limits as determined with the <code>gmp</code> library, but the inputs and outputs can be in any base. Further, both unsigned (a minus sign indicates negative) and 2s complement base-2 values are allowed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigOr(x, y, inBase = 10, outBase = 10, inTwosComp = TRUE) 
bigAnd(x, y, inBase = 10, outBase = 10,  inTwosComp = TRUE) 
bigXor(x, y, inBase = 10, outBase = 10, inTwosComp = TRUE) 
bigNot(x,inBase=10,outBase=10,binSize = 32,inTwosComp = TRUE,outTwosComp = TRUE)
bigShiftL(x, shift = 1,  inBase = 10 , outBase = 10, binSize = 32, inTwosComp = TRUE) 
bigShiftR(x, shift = 1,  inBase = 10, outBase = 10, binSize = 32, inTwosComp = TRUE) 
bigRotate(x, shift,  inBase = 10,binSize = 32, outBase = 10, inTwosComp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigAnd_+3A_x">x</code>, <code id="bigAnd_+3A_y">y</code></td>
<td>
<p> The integers to be processed. These can be numeric, integer, <code>mpfr</code>, <code>bigz</code> , or character class. These two items must be of the same class. List variables are acceptable so long as the contents are all of one class. 
They can be any base from 2 through 36 as specified by <code>inBase</code>. 
If these are character strings, formats such as &quot;-37e+5&quot; or &quot;0x4e&quot; (for hex data) are accepted. 
See the Details section for the capabilities and limits on &quot;translation&quot; of inputs.  If the lengths of <code>x</code> and <code>y</code> differ, the shorter one will be silently recycled.  
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_inbase">inBase</code></td>
<td>

<p>Specify the designated base of the input(s) .  Default is 10.
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_outbase">outBase</code></td>
<td>

<p>Specify the designated base of the output(s) .  Default is 10.
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_intwoscomp">inTwosComp</code></td>
<td>

<p>When <code>inBase</code> is 2,  the input(s) is treated as being in 2s complement format when this is TRUE (the default). Otherwise the input(s) is treated as a  positive base-2 value unless a negative sign is present. .  If <code>inBase</code> is not equal to 2, this arg is ignored. 
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_binsize">binSize</code></td>
<td>

<p>Specify the number of binary bits for the output calculation. If this is set to zero (the default), the minimum number is set to 4*N such that the current value of the input and output is containable.  But see the Details section for a discussion of 2s complement behavior. 
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_outtwoscomp">outTwosComp</code></td>
<td>

<p>Whent <code>outBase</code> is 2, return the 2s complement version of the value(s). Default is TRUE; when False, return a  binary value(s) with a negative sign as necessary. 
</p>
</td></tr>
<tr><td><code id="bigAnd_+3A_shift">shift</code></td>
<td>

<p>The number of bits to shift the input by. Only positive values are allowed for  <code>bigShiftL</code> and <code>bigShiftR</code>, which  shift to the &quot;left&quot; and &quot;right&quot; respectively.
<code>bigRotate</code> accepts positive or negative values and rotates in the prescribed direction accordingly. See the Details section for comments on 2s complement inputs. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs, when not in base 10, are expected to follow the common encoding where the letters &quot;a&quot; through &quot;z&quot; correspond to the decimal values 10 through 35.  Values in bases greater than 10 must be character strings. 
If the input is base 16 ('hex'), the character string can begin with or without '0x'.
Inputs specified as base 2 through 10 can be provided in any of the numeric formats and the functions automagically interpret them correctly. For example, when  <code>x</code> is numeric  1101 and  <code>inBase</code> is 2 , the functions will interpret the input as 13 if <code>inTwosComp</code> is FALSE and as -3 if TRUE. 
</p>
<p>Shifting to the right when 2s complement is in use can lead to unexpected results. <code>bigShiftR</code> assumes 32-bit binary 2scomp for compatibility with <code><a href="base.html#topic+bitwShiftR">bitwShiftR</a></code>. But for an arbitrarily large binary 2s complement input, the output, for a shift of one, will move -1 (11111...) to 2^(N-1) -1 , where N is the number of bits including the sign bit. <code>bigShiftR</code> defaults to max(32, min_needed_for_magnitude_of_x) bits.
Similarly, <code>bigShiftL</code> by default provides sufficient bits to handle the shifted value. This is unlike <code><a href="base.html#topic+bitwShiftL">bitwShiftL</a></code> which  returns the value of the 32 LSBs (in 2s complement form) if the shifted value exceeds 2^31-1 .  If <code>binSize</code> is not zero (the default), <code>bigShiftL</code> will truncate to the specified bit size (or 32, whichever is greater).
</p>
<p><code>bigRotate</code> converts input 2s complement binaries to unsigned binaries (with a negative sign when needed).  This is because the behavior of different compilers with respect to rotating 2s complement binary data can be different or even unspecified.  When the input is negative (in any base), the rotation is applied to the positive unsigned binary equivalent and a negative sign attached to the output.  In particular, this means that 2s complement output is disallowed. 
</p>
<p>Note that, for compability with the base <code>bitw*</code> functions, the value is internally extended to (at least) 32 bits prior to bitwise operations. In particular, the value of the NOT function when 2s complement is in use depends on the specified size of the binary data. 
Remember that there will be precision errors if large numerics are entered, possibly leading to roundoff errors.  In general, it is safer to enter values in <code>bigz</code> format or as character strings. 
</p>


<h3>Value</h3>

<p>A list object with one value per entry, corresponding to the input value(s) of x (or y if y is the longer input). In most cases the entries are character strings.  However, if the input and the output are specified as base 10, then the output is converted to the class of the input.  
</p>


<h3>Author(s)</h3>

<p>Author and Maintainer:Carl Witthoft <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+bitwAnd">bitwAnd</a></code> and other &quot;bitw*&quot; functions
</p>

<hr>
<h2 id='buildBinaries'>
Function to convert values to binary form
</h2><span id='topic+buildBinaries'></span>

<h3>Description</h3>

<p>This function is intended primarily for internal use by the <code>big*</code> Boolean functions. Its job is to take an input in any base, in almost any class (numeric, character, etc) and generate the binary form of the same value. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBinaries(x, y= NULL,inBase, inTwosComp = FALSE, binSize = 32)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildBinaries_+3A_x">x</code>, <code id="buildBinaries_+3A_y">y</code></td>
<td>

<p>The values to be converted.  Typically these are the <code>x,y</code> values provided to one of the Boolean functions in this package. If only <code>x</code> is input, <code>y</code> defaults to <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="buildBinaries_+3A_inbase">inBase</code></td>
<td>

<p>The base (2 thru 36) of the input values.
</p>
</td></tr>
<tr><td><code id="buildBinaries_+3A_intwoscomp">inTwosComp</code></td>
<td>

<p>When the input <code>inBase</code> is 2, this specifies whether the input is positive unless a negative sign is present, or 2's complement format . </p>
</td></tr>
<tr><td><code id="buildBinaries_+3A_binsize">binSize</code></td>
<td>

<p>The minimum number of bits to use for the output binary data. If insufficient for the size of the input(s), this will be increased to the next 4*N size. When there are two inputs, both outputs are set to the same number of bits. ~
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>xbin</code></td>
<td>
<p>A vector of numeric ones and zeroes representing the binary form of <code>x</code>
</p>
</td></tr>
<tr><td><code>ybin</code></td>
<td>
<p>A vector of numeric ones and zeroes representing the binary form of <code>y</code>. If the input is NULL,  a single value of <code>0</code> is returned. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Author and Maintainer:Carl Witthoft <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
buildBinaries(73,-73,inBase=10)

</code></pre>

<hr>
<h2 id='fracB2B'>
Function which converts fractions (between 1 and 0) from any base to any other base. 
</h2><span id='topic+fracB2B'></span>

<h3>Description</h3>

<p>This function accepts inputs in any base from 2 through 36 and generates the fractional portion of the input values in any selected base from 2 through 36. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fracB2B( x, inBase = 10, outBase = 16, maxdig = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fracB2B_+3A_x">x</code></td>
<td>

<p>A value or vector or list of values which are to be converted. The class can generally be numeric, mpfr,bigz,bigq, or character strings. Any integer part is removed, as only the fractional part is converted with this function.  See Details for more information. 
</p>
</td></tr>
<tr><td><code id="fracB2B_+3A_inbase">inBase</code></td>
<td>

<p>The base of the input <code>x</code>, in the range 2 through 36. If the contents of <code>x</code> are incompatible with the specified base, a warning is issued and that value is skipped (i.e. if <code>x</code> has multiple values, <code>base2base</code> will keep running and process the other values). Default is 10.
</p>
</td></tr>
<tr><td><code id="fracB2B_+3A_outbase">outBase</code></td>
<td>

<p>The desired base of the output, in the range 2 through 36. Default is 16.
</p>
</td></tr>
<tr><td><code id="fracB2B_+3A_maxdig">maxdig</code></td>
<td>

<p>The maximum number of digits to return in each result. This avoids an infinite loop when a given decimal does not terminate in the output base. The default value of <code>0</code> causes the function to generate a &quot;reasonable&quot; estimate for the number of places needed to maintain precision. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, it's safest to provide a character string(s). There is some automagical conversion that will take, e.g., a numeric <code>364</code> with <code>inBase = 8</code> and treat as base 8 (thus decimal 244), but this is not guaranteed. Further, keep in mind that numeric values with more than roughly 16 digits will likely run into floating-point precision errors. 
Inputs in any base greater than 10 must be character strings. This is because the command parser converts, e.g., 0x3a, to the decimal value 58 prior to passing the value to the function body. 
</p>


<h3>Value</h3>

<p>A vector containing the converted value(s) as strings. A negative sign is included for negative inputs. 
</p>


<h3>Author(s)</h3>

<p>Author and Maintainer:Carl Witthoft <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>See Also</h3>

<p><code>base2base</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fracB2B(12.43e2,10,16)) # no decimal part
(fracB2B(12.43e-2,10,16))
(fracB2B(101.101,2,10)) # magic. it works!!!
fracB2B('.357') # "0.5b64"
fracB2B('.357',maxdig = 10) #"0.5b645a1cac"
fracB2B(".5b64",16,10)
fracB2B(".5b645a1cac",16,10)
</code></pre>

<hr>
<h2 id='noExp'>
Function to convert character-string numbers in exponential notation to &quot;pure&quot; integers. 
</h2><span id='topic+noExp'></span>

<h3>Description</h3>

<p>This is a helper function for <code><a href="#topic+base2base">base2base</a></code>. When an input value is a character string with exponential notation, e.g.,  &quot;2.65e4&quot; , this function rebuilds the character string as a pure integer, e.g., &quot;26500&quot; . Decimal portions are removed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noExp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noExp_+3A_x">x</code></td>
<td>

<p>An input character string, assumed only to contain numerals 0-9, &quot;+,-,e,E&quot; and the decimal separator character defined in the current locale.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both input and output must be base 10, as exponentiation in other bases is outside the current scope of this package. 
</p>


<h3>Value</h3>

<p>A character string representing the input as an integer written &quot;longhand,&quot; i.e. no exponent. This string will contain only numerals and possibly a lead minus sign in the case of negative inputs.  
</p>


<h3>Author(s)</h3>

<p>Author and Maintainer:Carl Witthoft <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
noExp('37e3')
noExp('-2.345e4')
# this returns zero
noExp('234e-5')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
