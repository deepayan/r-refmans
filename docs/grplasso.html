<!DOCTYPE html><html><head><title>Help for package grplasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grplasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grpl.control'><p>Options for the Group Lasso Algorithm</p></a></li>
<li><a href='#grpl.control-class'><p>Class &quot;grpl.control&quot;: Options for the Group Lasso Algorithm</p></a></li>
<li><a href='#grpl.model'><p>Group Lasso Models</p></a></li>
<li><a href='#grpl.model-class'><p>Class &quot;grpl.model&quot;: Group Lasso Models</p></a></li>
<li><a href='#grplasso'><p>Function to Fit a Solution of a Group Lasso Problem</p></a></li>
<li><a href='#grplasso-internal'><p>Internal grplasso Functions</p></a></li>
<li><a href='#grplasso-package'>
<p>Fitting User-Specified Models with Group Lasso Penalty</p></a></li>
<li><a href='#lambdamax'><p>Function to Find the Maximal Value of the Penalty Parameter Lambda</p></a></li>
<li><a href='#plot.grplasso'><p>Plots the Solution Path of a grplasso Object</p></a></li>
<li><a href='#predict.grplasso'><p>Predict Method for grplasso Objects</p></a></li>
<li><a href='#splice'><p>Dataset of Human Donor Splice Sites</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting User-Specified Models with Group Lasso Penalty</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Meier</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Meier &lt;meier@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits user-specified (GLM-) models with group lasso penalty.</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-07 15:36:15 UTC; meierluk</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-07 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='grpl.control'>Options for the Group Lasso Algorithm</h2><span id='topic+grpl.control'></span>

<h3>Description</h3>

<p>Definition of options such as bounds on the Hessian,
convergence criteria and output management for the group lasso algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpl.control(save.x = FALSE, save.y = TRUE,
             update.hess = c("lambda", "always"), update.every = 3,
             inner.loops = 10, line.search = TRUE, max.iter = 500,
             tol = 5 * 10^-8, lower = 10^-2, upper = Inf, beta = 0.5,
             sigma = 0.1, trace = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpl.control_+3A_save.x">save.x</code></td>
<td>
<p>a logical indicating whether the design matrix should be saved.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_save.y">save.y</code></td>
<td>
<p>a logical indicating whether the response should be saved.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_update.hess">update.hess</code></td>
<td>
<p>should the hessian be updated in each
iteration (&quot;always&quot;)? update.hess = &quot;lambda&quot; will update
the Hessian once for each component of the penalty
parameter &quot;lambda&quot; based on the parameter estimates
corresponding to the previous value of the penalty
parameter.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_update.every">update.every</code></td>
<td>
<p>Only used if update.hess = &quot;lambda&quot;. E.g. set to 3
if you want to update the Hessian only every third grid point.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_inner.loops">inner.loops</code></td>
<td>
<p>How many loops should be done (at maximum) when solving
only the active set (without considering the remaining
predictors). Useful if the number of predictors is large. Set to 0
if no inner loops should be performed.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_line.search">line.search</code></td>
<td>
<p>Should line searches be performed?</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of loops through all groups</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance; the smaller the more precise, see
details below.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_lower">lower</code></td>
<td>
<p>lower bound for the diagonal approximation of the
corresponding block submatrix of the Hessian of the negative
log-likelihood function.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_upper">upper</code></td>
<td>
<p>upper bound for the diagonal approximation of the
corresponding block submatrix of the Hessian of the negative
log-likelihood function.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_beta">beta</code></td>
<td>
<p>scaling factor <code class="reqn">\beta &lt; 1</code> of the Armijo line search.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_sigma">sigma</code></td>
<td>
<p><code class="reqn">0 &lt; \sigma &lt; 1</code> used in the Armijo line search.</p>
</td></tr>
<tr><td><code id="grpl.control_+3A_trace">trace</code></td>
<td>
<p>integer. <code>0</code> omits any output, <code>1</code> prints the
current lambda value, <code>2</code> prints the improvement in the
objective function after each sweep through all the parameter groups
and additional information.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For the convergence criteria see chapter 8.2.3.2 of Gill et
al. (1981).</p>


<h3>Value</h3>

<p>An object of class <code>grpl.control</code>.
</p>


<h3>References</h3>

<p>Philip E. Gill, Walter Murray and Margaret H. Wright (1981)
<em>Practical Optimization</em>, Academic Press.
</p>
<p>Dimitri P. Bertsekas (2003) <em>Nonlinear Programming</em>, Athena Scientific.</p>

<hr>
<h2 id='grpl.control-class'>Class &quot;grpl.control&quot;: Options for the Group Lasso Algorithm</h2><span id='topic+grpl.control-class'></span>

<h3>Description</h3>

<p>Objects of class &quot;grpl.control&quot; define options such as bounds on the Hessian,
convergence criteria and output management for the Group Lasso algorithm.
</p>


<h3>Details</h3>

<p>For the convergence criteria see chapter 8.2.3.2 of Gill et
al. (1981).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>grpl.control(...)</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>save.x</code></dt><dd><p>a logical indicating whether the design matrix
should be saved.</p>
</dd> 
<dt><code>save.y</code></dt><dd><p>a logical indicating whether the response should
be saved.</p>
</dd> 
<dt><code>update.hess</code></dt><dd><p>should the hessian be updated in each
iteration (&quot;always&quot;)? update.hess = &quot;lambda&quot; will update
the Hessian once for each component of the penalty
parameter &quot;lambda&quot; based on the parameter estimates
corresponding to the previous value of the penalty
parameter.</p>
</dd>
<dt><code>update.every</code></dt><dd><p>Only used if update.hess = &quot;lambda&quot;. E.g. set to 3
if you want to update the Hessian only every third grid point.</p>
</dd>
<dt><code>inner.loops</code></dt><dd><p>How many loops should be done (at maximum)
when solving only the active set (without considering the remaining
predictors). Useful if the number of predictors is large. Set to 0
if no inner loops should be performed.</p>
</dd>
<dt><code>line.search</code></dt><dd><p>Should line searches be performed?</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Maximal number of loops through all groups</p>
</dd>
<dt><code>tol</code></dt><dd><p>convergence tolerance; the smaller the more precise.</p>
</dd>
<dt><code>lower</code></dt><dd><p>lower bound for the diagonal approximation of the
corresponding block submatrix of the Hessian of the negative
log-likelihood function.</p>
</dd>
<dt><code>upper</code></dt><dd><p>upper bound for the diagonal approximation of the
corresponding block submatrix of the Hessian of the negative
log-likelihood function.</p>
</dd>
<dt><code>beta</code></dt><dd><p>scaling factor <code class="reqn">\beta &lt; 1</code> of the Armijo line search.</p>
</dd>
<dt><code>sigma</code></dt><dd><p><code class="reqn">0 &lt; \sigma &lt; 1</code> used in the Armijo line search.</p>
</dd>
<dt><code>trace</code></dt><dd><p>integer. <code>1</code> prints the current lambda value,
<code>2</code> prints the improvement in the objective function after each
sweep through all the parameter groups and additional information.</p>
</dd>
</dl>



<h3>References</h3>

<p>Philip E. Gill, Walter Murray and Margaret H. Wright (1981)
<em>Practical Optimization</em>, Academic Press.
</p>
<p>Dimitri P. Bertsekas (2003) <em>Nonlinear Programming</em>, Athena Scientific.</p>

<hr>
<h2 id='grpl.model'>Group Lasso Models</h2><span id='topic+grpl.model'></span><span id='topic+LogReg'></span><span id='topic+LinReg'></span><span id='topic+PoissReg'></span>

<h3>Description</h3>

<p>Generates models to be used for the group lasso algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpl.model(invlink, link, nloglik, ngradient, nhessian, check,
           name = "user-specified", comment = "user-specified")
LogReg()
LinReg()
PoissReg()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpl.model_+3A_invlink">invlink</code></td>
<td>
<p>a function with arguments <code>eta</code>
implementing the inverse link function.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_link">link</code></td>
<td>
<p>a function with arguments <code>mu</code>
implementing the link function.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_nloglik">nloglik</code></td>
<td>
<p>a function with arguments <code>y</code>, <code>mu</code> and
<code>weights</code> implementing the <em>negative</em> log-likelihood function.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_ngradient">ngradient</code></td>
<td>
<p>a function with arguments <code>x</code>, <code>y</code>,
<code>mu</code> and <code>weights</code> 
implementing the <em>negative</em> gradient of the log-likelihood function.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_nhessian">nhessian</code></td>
<td>
<p>a function with arguments <code>x</code>, <code>mu</code> and
<code>weights</code> implementing the <em>negative</em> hessian of the
log-likelihood function.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_check">check</code></td>
<td>
<p>a function with argument <code>y</code> to check whether the
response has the correct format.</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_name">name</code></td>
<td>
<p>a character name</p>
</td></tr>
<tr><td><code id="grpl.model_+3A_comment">comment</code></td>
<td>
<p>a character comment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grpl.model</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    LogReg()
</code></pre>

<hr>
<h2 id='grpl.model-class'>Class &quot;grpl.model&quot;: Group Lasso Models</h2><span id='topic+grpl.model-class'></span><span id='topic+show+2Cgrpl.model-method'></span>

<h3>Description</h3>

<p>Objects of class &quot;grpl.model&quot; define link function, negative
log-likelihood and corresponding gradient and Hessian for the model to
be used in a group lasso problem.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>grpl.model(...)</code></p>


<h3>Slots</h3>


<dl>
<dt><code>invlink</code></dt><dd><p>a function with arguments <code>eta</code>
implementing the inverse link function.</p>
</dd>
<dt><code>link</code></dt><dd><p>a function with arguments <code>mu</code>
implementing the link function.</p>
</dd>
<dt><code>nloglik</code></dt><dd><p>a function with arguments <code>y</code>, <code>mu</code> and
<code>weights</code> implementing the <em>negative</em>
log-likelihood function.</p>
</dd> 
<dt><code>ngradient</code></dt><dd><p>a function with arguments <code>x</code>, <code>y</code>,
<code>mu</code> and <code>weights</code> 
implementing the <em>negative</em> gradient of the log-likelihood function.</p>
</dd> 
<dt><code>nhessian</code></dt><dd><p>a function with arguments <code>x</code>, <code>mu</code> and
<code>weights</code> implementing the <em>negative</em> hessian of the
log-likelihood function.</p>
</dd>
<dt><code>check</code></dt><dd><p>a function with argument <code>y</code> to check
whether the response has the correct format.</p>
</dd>
<dt><code>name</code></dt><dd><p>a character name</p>
</dd>
<dt><code>comment</code></dt><dd><p>a character comment</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>object</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  LogReg()
</code></pre>

<hr>
<h2 id='grplasso'>Function to Fit a Solution of a Group Lasso Problem</h2><span id='topic+grplasso'></span><span id='topic+grplasso.default'></span><span id='topic+grplasso.formula'></span>

<h3>Description</h3>

<p>Fits the solution of a group lasso problem for a model of type
<code>grpl.model</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>grplasso(x, ...)

## S3 method for class 'formula'
grplasso(formula, nonpen = ~ 1, data, weights,
         subset, na.action, lambda, coef.init, penscale = sqrt,
         model = LogReg(), center = TRUE, standardize = TRUE,
         control = grpl.control(), contrasts = NULL, ...)

## Default S3 method:
grplasso(x, y, index, weights = rep(1, length(y)), offset = rep(0,
         length(y)), lambda, coef.init = rep(0, ncol(x)),
         penscale = sqrt, model = LogReg(), center = TRUE,
         standardize = TRUE, control = grpl.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grplasso_+3A_x">x</code></td>
<td>
<p>design matrix (including intercept)</p>
</td></tr>
<tr><td><code id="grplasso_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="grplasso_+3A_formula">formula</code></td>
<td>
<p><code>formula</code> of the penalized variables. The response
has to be on the left hand side of <code>~</code>.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_nonpen">nonpen</code></td>
<td>
<p><code>formula</code> of the nonpenalized variables. This will
be added to the <code>formula</code> argument above and doesn't need to have the
response on the left hand side.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_index">index</code></td>
<td>
<p>vector which defines the grouping of the
variables. Components sharing the same
number build a group. Non-penalized coefficients are marked with
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_weights">weights</code></td>
<td>
<p>vector of observation weights.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_offset">offset</code></td>
<td>
<p>vector of offset values; needs to have the same length as the
response vector.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_lambda">lambda</code></td>
<td>
<p>vector of penalty parameters. Optimization starts with
the first component. See details below.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_coef.init">coef.init</code></td>
<td>
<p>initial vector of parameter estimates corresponding
to the first component in the vector <code>lambda</code>.</p>
</td></tr> 
<tr><td><code id="grplasso_+3A_penscale">penscale</code></td>
<td>
<p>rescaling function to adjust the value of the penalty
parameter to the degrees of freedom of the parameter group. See the
reference below.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_model">model</code></td>
<td>
<p>an object of class <code><a href="#topic+grpl.model">grpl.model</a></code> implementing
the negative log-likelihood, gradient, hessian etc. See the
documentation of <code><a href="#topic+grpl.model">grpl.model</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_center">center</code></td>
<td>
<p>logical. If true, the columns of the design matrix will be
centered (except a possible intercept column).</p>
</td></tr>
<tr><td><code id="grplasso_+3A_standardize">standardize</code></td>
<td>
<p>logical. If true, the design matrix will be
blockwise orthonormalized such that for each block <code class="reqn">X^TX = n 1</code>
(*after* possible centering).</p>
</td></tr>
<tr><td><code id="grplasso_+3A_control">control</code></td>
<td>
<p>options for the fitting algorithm, see
<code><a href="#topic+grpl.control">grpl.control</a></code>.</p>
</td></tr>
<tr><td><code id="grplasso_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the 'contrasts.arg' of
'model.matrix.default'.</p>
</td></tr>  
<tr><td><code id="grplasso_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the functions defined
in <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>grplasso.formula</code>, the grouping of the variables is
derived from the type of the variables: The dummy variables of a
factor will be automatically treated as a group. 
</p>
<p>The optimization process starts using the first component of
<code>lambda</code> as penalty parameter <code class="reqn">\lambda</code> and with starting
values defined in <code>coef.init</code> for the parameter vector. Once
fitted, the next component of <code>lambda</code> is considered as penalty
parameter with starting values defined as the (fitted) coefficient
vector based on the previous component of <code>lambda</code>.
</p>


<h3>Value</h3>

<p>A <code>grplasso</code> object is returned, for which <code>coef</code>,
<code>print</code>, <code>plot</code> and <code>predict</code> methods exist.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>coefficients with respect to the <em>original</em> input
variables (even if <code>standardize = TRUE</code> is used for fitting).</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>vector of lambda values where coefficients were calculated.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>grouping index vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lukas Meier, <a href="mailto:meier@stat.math.ethz.ch">meier@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Lukas Meier, Sara van de Geer and Peter B\&quot;uhlmann (2008), <em>The
Group Lasso for Logistic Regression</em>, Journal of the Royal
Statistical Society, 70 (1), 53 - 71</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Logistic Group Lasso on the splice data set
data(splice)

## Define a list with the contrasts of the factors
contr &lt;- rep(list("contr.sum"), ncol(splice) - 1)
names(contr) &lt;- names(splice)[-1]

## Fit a logistic model 
fit.splice &lt;- grplasso(y ~ ., data = splice, model = LogReg(), lambda = 20,
                       contrasts = contr, center = TRUE, standardize = TRUE)

## Perform the Logistic Group Lasso on a random dataset
set.seed(79)

n &lt;- 50  ## observations
p &lt;- 4   ## variables

## First variable (intercept) not penalized, two groups having 2 degrees
## of freedom each

index &lt;- c(NA, 2, 2, 3, 3)

## Create a random design matrix, including the intercept (first column)
x &lt;- cbind(1, matrix(rnorm(p * n), nrow = n))
colnames(x) &lt;- c("Intercept", paste("X", 1:4, sep = ""))

par &lt;- c(0, 2.1, -1.8, 0, 0)
prob &lt;- 1 / (1 + exp(-x %*% par))
mean(pmin(prob, 1 - prob)) ## Bayes risk
y &lt;- rbinom(n, size = 1, prob = prob) ## binary response vector

## Use a multiplicative grid for the penalty parameter lambda, starting
## at the maximal lambda value
lambda &lt;- lambdamax(x, y = y, index = index, penscale = sqrt,
                    model = LogReg()) * 0.5^(0:5)

## Fit the solution path on the lambda grid
fit &lt;- grplasso(x, y = y, index = index, lambda = lambda, model = LogReg(),
                penscale = sqrt,
                control = grpl.control(update.hess = "lambda", trace = 0))

## Plot coefficient paths
plot(fit)
</code></pre>

<hr>
<h2 id='grplasso-internal'>Internal grplasso Functions</h2><span id='topic+blockstand'></span><span id='topic+create.design'></span>

<h3>Description</h3>

<p>Internal grplasso functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockstand(x, ipen.which, inotpen.which)
create.design(m, formula, nonpen  = ~ 1, data, weights, subset,
              na.action, contrasts, env)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='grplasso-package'>
Fitting User-Specified Models with Group Lasso Penalty
</h2><span id='topic+grplasso-package'></span>

<h3>Description</h3>

<p>Fits user-specified (GLM-) models with group lasso penalty.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> grplasso</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Fitting User-Specified Models with Group Lasso Penalty</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-05-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Lukas Meier</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Lukas Meier &lt;meier@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Fits user-specified (GLM-) models with group lasso penalty.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
grpl.control            Options for the Group Lasso Algorithm
grpl.control-class      Class "grpl.control": Options for the Group
                        Lasso Algorithm
grpl.model              Group Lasso Models
grpl.model-class        Class "grpl.model": Group Lasso Models
grplasso                Function to Fit a Solution of a Group Lasso
                        Problem
grplasso-package        Fitting User-Specified Models with Group Lasso
                        Penalty
lambdamax               Function to Find the Maximal Value of the
                        Penalty Parameter Lambda
plot.grplasso           Plots the Solution Path of a grplasso Object
predict.grplasso        Predict Method for grplasso Objects
splice                  Dataset of Human Donor Splice Sites
</pre>
<p>The best entry point for the package are the examples in the help
file of the function <code><a href="#topic+grplasso">grplasso</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Meier
</p>
<p>Maintainer: Lukas Meier &lt;meier@stat.math.ethz.ch&gt;
</p>


<h3>References</h3>

<p>Lukas Meier, Sara van de Geer and Peter B\&quot;uhlmann (2008), <em>The
Group Lasso for Logistic Regression</em>, Journal of the Royal
Statistical Society, 70 (1), 53 - 71</p>

<hr>
<h2 id='lambdamax'>Function to Find the Maximal Value of the Penalty Parameter Lambda</h2><span id='topic+lambdamax'></span><span id='topic+lambdamax.default'></span><span id='topic+lambdamax.formula'></span>

<h3>Description</h3>

<p>Determines the value of the penalty parameter lambda when
the first penalized parameter group enters the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdamax(x, ...)

## S3 method for class 'formula'
lambdamax(formula, nonpen = ~1, data, weights, subset,
          na.action, coef.init, penscale = sqrt, model = LogReg(),
          center = TRUE, standardize = TRUE, contrasts = NULL,
          nlminb.opt = list(), ...)

## Default S3 method:
lambdamax(x, y, index, weights = rep(1, length(y)),
          offset = rep(0, length(y)), coef.init = rep(0, ncol(x)),
          penscale = sqrt, model = LogReg(), center = TRUE,
          standardize = TRUE, nlminb.opt = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdamax_+3A_x">x</code></td>
<td>
<p>design matrix (including intercept)</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_formula">formula</code></td>
<td>
<p><code>formula</code> of the penalized variables. The response
has to be on the left hand side of '~'.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_nonpen">nonpen</code></td>
<td>
<p><code>formula</code> of the nonpenalized variables. This will
be added to the <code>formula</code> argument above and doesn't need to have the
response on the left hand side.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_index">index</code></td>
<td>
<p>vector which defines the grouping of the
variables. Components sharing the same
number build a group. Non-penalized coefficients are marked with
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_weights">weights</code></td>
<td>
<p>vector of observation weights.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_offset">offset</code></td>
<td>
<p>vector of offset values.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_coef.init">coef.init</code></td>
<td>
<p>initial parameter vector. Penalized groups are discarded.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_penscale">penscale</code></td>
<td>
<p>rescaling function to adjust the value of the penalty
parameter to the degrees of freedom of the parameter group. See the
reference below.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_model">model</code></td>
<td>
<p>an object of class <code><a href="#topic+grpl.model">grpl.model</a></code> implementing
the negative log-likelihood, gradient, hessian etc. See
<code><a href="#topic+grpl.model">grpl.model</a></code> for more details.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_center">center</code></td>
<td>
<p>logical. If true, the columns of the design matrix will be
centered (except a possible intercept column).</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_standardize">standardize</code></td>
<td>
<p>logical. If true, the design matrix will be blockwise
orthonormalized, such that for each block <code class="reqn">X^TX = n 1</code>
(*after* possible centering).</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_contrasts">contrasts</code></td>
<td>
<p>an (optional) list with the contrasts for the factors
in the model.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_nlminb.opt">nlminb.opt</code></td>
<td>
<p>arguments to be supplied to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="lambdamax_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the functions defined
in <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+nlminb">nlminb</a></code> to optimize the non-penalized parameters.</p>


<h3>Value</h3>

<p>An object of type numeric is returned.</p>


<h3>References</h3>

<p>Lukas Meier, Sara van de Geer and Peter B\&quot;uhlmann (2008), <em>The
Group Lasso for Logistic Regression</em>, Journal of the Royal
Statistical Society, 70 (1), 53 - 71</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(splice)
lambdamax(y ~ ., data = splice, model = LogReg(), center = TRUE,
          standardize = TRUE)
</code></pre>

<hr>
<h2 id='plot.grplasso'>Plots the Solution Path of a grplasso Object</h2><span id='topic+plot.grplasso'></span>

<h3>Description</h3>

<p>Plots the solution path of a <code>grplasso</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grplasso'
plot(x, type = "coefficients", col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.grplasso_+3A_x">x</code></td>
<td>
<p>a <code>grplasso</code> object</p>
</td></tr>
<tr><td><code id="plot.grplasso_+3A_type">type</code></td>
<td>
<p>type = &quot;coefficients&quot; plots coefficients with respect to
the input variables, even if <code>standardize = TRUE</code> is used in
<code>grplasso</code>.</p>
</td></tr>
<tr><td><code id="plot.grplasso_+3A_col">col</code></td>
<td>
<p>a vector indicating the color of the different group
paths. The length should equal the number of <em>groups</em>. The same 
ordering as in the vector <code>index</code> is used with the exception
that the unpenalized coefficients are grouped at the beginning of
the vector.</p>
</td></tr>
<tr><td><code id="plot.grplasso_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to the plotting functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(splice)

contr &lt;- list(Pos.1 = "contr.sum", Pos.2 = "contr.sum")
lambda &lt;- lambdamax(y ~ Pos.1 * Pos.2, data = splice, model = LogReg(),
                    contrasts = contr, standardize = TRUE) * 0.8^(0:8)

fit &lt;- grplasso(y ~ Pos.1 * Pos.2, data = splice, model = LogReg(),
                lambda = lambda, contrasts = contr, standardize = TRUE,
                control = grpl.control(trace = 0, inner.loops = 0,
                update.every = 1, update.hess = "lambda"))
plot(fit, log = "x")
</code></pre>

<hr>
<h2 id='predict.grplasso'>Predict Method for grplasso Objects</h2><span id='topic+predict.grplasso'></span>

<h3>Description</h3>

<p>Obtains predictions from a <code>grplasso</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grplasso'
predict(object, newdata, type = c("link", "response"),
        na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.grplasso_+3A_object">object</code></td>
<td>
<p>a <code>grplasso</code> object</p>
</td></tr>
<tr><td><code id="predict.grplasso_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> or design matrix of new observations</p>
</td></tr>
<tr><td><code id="predict.grplasso_+3A_type">type</code></td>
<td>
<p>the type of prediction. <code>type = "link"</code> is on the
scale of linear predictors, whereas <code>type = "response"</code> is on
the scale of the response variable, i.e. <code>type = "response"</code>
applies the inverse link function to the linear predictors.</p>
</td></tr>
<tr><td><code id="predict.grplasso_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.grplasso_+3A_...">...</code></td>
<td>
<p>other options to be passed to the predict function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose <em>columns</em> correspond to the different values of
the penalty parameter <code>lambda</code> of the <code>grplasso</code> object.
</p>


<h3>Note</h3>

<p>If <code>newdata</code> is given, offsets specified by <code>offset</code> in the
fit by <code>grplasso.default</code> will not be included in predictions,
whereas those specified by an offset term in the formula will be considered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grplasso">grplasso</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(splice)

contr &lt;- rep(list("contr.sum"), ncol(splice) - 1)
names(contr) &lt;- names(splice)[-1]

fit &lt;- grplasso(y ~ ., data = splice, model = LogReg(), lambda = 10,
                contrasts = contr, standardize = TRUE)

pred &lt;- predict(fit)
pred.resp &lt;- predict(fit, type = "response")

## The following points should lie on the sigmoid curve
plot(pred, pred.resp)
</code></pre>

<hr>
<h2 id='splice'>Dataset of Human Donor Splice Sites</h2><span id='topic+splice'></span>

<h3>Description</h3>

<p>Dataset of 400 human donor splice sites with a sequence length of 7 base
pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(splice)</code></pre>


<h3>Format</h3>


<dl>
<dt>y</dt><dd><p>binary response. True (1) or false (0) splice site.</p>
</dd>
<dt>Pos.x</dt><dd><p>DNA letter (A, C, G, T) at position x, where x ranges
from 1 to 7.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The dataset is a random subset of the MEMset Donor dataset
used in Gene et al. (2004). 
</p>


<h3>References</h3>

<p>Gene, Y. and Burge, C. (2004) <em>Maximum Entropy Modeling
of Short Sequence Motifs with Applications to RNA Splicing Signals</em>,
Journal of Computational Biology, 11, 475 - 494.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(splice)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
