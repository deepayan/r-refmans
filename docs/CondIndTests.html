<!DOCTYPE html><html><head><title>Help for package CondIndTests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CondIndTests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CondIndTest'><p>Wrapper function for conditional independence tests.</p></a></li>
<li><a href='#fishersTestExceedance'><p>Fishers test to test whether the exceedance of the conditional quantiles</p>
is independent of the categorical variable E.</a></li>
<li><a href='#fTestTargetY'><p>F-test for a nested model comparison.</p></a></li>
<li><a href='#InvariantConditionalQuantilePrediction'><p>Invariant conditional quantile prediction.</p></a></li>
<li><a href='#InvariantEnvironmentPrediction'><p>Invariant environment prediction.</p></a></li>
<li><a href='#InvariantResidualDistributionTest'><p>Invariant residual distribution test.</p></a></li>
<li><a href='#InvariantTargetPrediction'><p>Invariant target prediction.</p></a></li>
<li><a href='#KCI'><p>Kernel conditional independence test.</p></a></li>
<li><a href='#ksResidualDistributions'><p>Kolmogorov-Smirnov test to compare residual distributions</p></a></li>
<li><a href='#leveneAndWilcoxResidualDistributions'><p>Levene and wilcoxon test to compare first and second moments of residual distributions</p></a></li>
<li><a href='#propTestTargetE'><p>Proportion test to compare two misclassification rates.</p></a></li>
<li><a href='#ResidualPredictionTest'><p>Residual prediction test.</p></a></li>
<li><a href='#wilcoxTestTargetY'><p>Wilcoxon test to compare two mean squared error rates.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Conditional Independence Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-11-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Heinze-Deml &lt;heinzedeml@stat.math.ethz.ch&gt;, 
  Jonas Peters &lt;jonas.peters@math.ku.dk&gt;,
  Asbjoern Marco Sinius Munk &lt;fgp998@alumni.ku.dk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Heinze-Deml &lt;heinzedeml@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Code for a variety of nonlinear conditional independence tests: 
  Kernel conditional independence test (Zhang et al., UAI 2011, &lt;<a href="https://arxiv.org/abs/1202.3775">arXiv:1202.3775</a>&gt;),
  Residual Prediction test (based on Shah and Buehlmann, &lt;<a href="https://arxiv.org/abs/1511.03334">arXiv:1511.03334</a>&gt;),
  Invariant environment prediction,
  Invariant target prediction,
  Invariant residual distribution test,
  Invariant conditional quantile prediction (all from Heinze-Deml et al., &lt;<a href="https://arxiv.org/abs/1706.08576">arXiv:1706.08576</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, randomForest, quantregForest, lawstat, RPtests,
caTools, mgcv, MASS, kernlab, pracma, mize</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/christinaheinze/nonlinearICP-and-CondIndTests">https://github.com/christinaheinze/nonlinearICP-and-CondIndTests</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/christinaheinze/nonlinearICP-and-CondIndTests/issues">https://github.com/christinaheinze/nonlinearICP-and-CondIndTests/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-11 16:14:39 UTC; heinzec</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-12 06:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='CondIndTest'>Wrapper function for conditional independence tests.</h2><span id='topic+CondIndTest'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondIndTest(Y, E, X, method = "KCI", alpha = 0.05,
  parsMethod = list(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CondIndTest_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector or a matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector or a matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_x">X</code></td>
<td>
<p>An n-dimensional vector or a matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_method">method</code></td>
<td>
<p>The conditional indepdence test to use, can be one of
<code>"KCI"</code>, <code>"InvariantConditionalQuantilePrediction"</code>, <code>"InvariantEnvironmentPrediction"</code>,
<code>"InvariantResidualDistributionTest"</code>, <code>"InvariantTargetPrediction"</code>, <code>"ResidualPredictionTest"</code>.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_parsmethod">parsMethod</code></td>
<td>
<p>Named list to pass options to <code>method</code>.</p>
</td></tr>
<tr><td><code id="CondIndTest_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value of the test (<code>pvalue</code>) and possibly additional
entries, depending on the output of the chosen conditional independence test in <code>method</code>.
</p>


<h3>References</h3>

<p>Please cite
C. Heinze-Deml, J. Peters and N. Meinshausen: &quot;Invariant Causal Prediction for Nonlinear Models&quot;,
<a href="https://arxiv.org/abs/1706.08576">arXiv:1706.08576</a>
and the corresponding reference for the conditional independence test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
set.seed(1)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- 4 + 2 * Z + rnorm(n)
Y &lt;- 3 * X^2 + Z + rnorm(n)
test1 &lt;- CondIndTest(X,Y,Z, method = "KCI")
cat("These data come from a distribution, for which X and Y are NOT
cond. ind. given Z.")
cat(paste("The p-value of the test is: ", test1$pvalue))

# Example 2
set.seed(1)
Z &lt;- rnorm(n)
X &lt;- 4 + 2 * Z + rnorm(n)
Y &lt;- 3 + Z + rnorm(n)
test2 &lt;- CondIndTest(X,Y,Z, method = "KCI")
cat("The data come from a distribution, for which X and Y are cond.
ind. given Z.")
cat(paste("The p-value of the test is: ", test2$pvalue))

</code></pre>

<hr>
<h2 id='fishersTestExceedance'>Fishers test to test whether the exceedance of the conditional quantiles
is independent of the categorical variable E.</h2><span id='topic+fishersTestExceedance'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantConditionalQuantilePrediction</code>
to test whether the exceedance of the conditional quantiles
is independent of the categorical variable E.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishersTestExceedance(Y, predicted, E, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fishersTestExceedance_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="fishersTestExceedance_+3A_predicted">predicted</code></td>
<td>
<p>A matrix with n rows. The columns contain predictions for different
conditional quantiles of Y|X.</p>
</td></tr>
<tr><td><code id="fishersTestExceedance_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. <code>E</code> needs to be a factor.</p>
</td></tr>
<tr><td><code id="fishersTestExceedance_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

<hr>
<h2 id='fTestTargetY'>F-test for a nested model comparison.</h2><span id='topic+fTestTargetY'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantTargetPrediction</code> to test
whether out-of-sample prediction performance is better when using X and E as predictors for Y,
compared to using X only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fTestTargetY(Y, predictedOnlyX, predictedXE, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fTestTargetY_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="fTestTargetY_+3A_predictedonlyx">predictedOnlyX</code></td>
<td>
<p>Predictions for Y based on predictors in X only.</p>
</td></tr>
<tr><td><code id="fTestTargetY_+3A_predictedxe">predictedXE</code></td>
<td>
<p>Predictions for Y based on predictors in X and E.</p>
</td></tr>
<tr><td><code id="fTestTargetY_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
<tr><td><code id="fTestTargetY_+3A_...">...</code></td>
<td>
<p>The dimensions of X (df) and E (dimE) need to be passed via the ...
argument to allow for coherent interface of fTestTargetY and wilcoxTestTargetY.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

<hr>
<h2 id='InvariantConditionalQuantilePrediction'>Invariant conditional quantile prediction.</h2><span id='topic+InvariantConditionalQuantilePrediction'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvariantConditionalQuantilePrediction(Y, E, X, alpha = 0.05,
  verbose = FALSE, test = fishersTestExceedance,
  mtry = sqrt(NCOL(X)), ntree = 100, nodesize = 5, maxnodes = NULL,
  quantiles = c(0.1, 0.5, 0.9), returnModel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. If <code>test = fishersTestExceedance</code>, E needs
to be a factor.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_test">test</code></td>
<td>
<p>Unconditional independence test that tests whether exceedence is
independent of E. Defaults to <code>fishersTestExceedance</code>.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_mtry">mtry</code></td>
<td>
<p>Random forest parameter: Number of variables randomly sampled as
candidates at each split. Defaults to <code>sqrt(NCOL(X))</code>.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_ntree">ntree</code></td>
<td>
<p>Random forest parameter: Number of trees to grow. Defaults to 100.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_nodesize">nodesize</code></td>
<td>
<p>Random forest parameter: Minimum size of terminal nodes.  Defaults to 5.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Random forest parameter: Maximum number of terminal nodes trees in the forest can have.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_quantiles">quantiles</code></td>
<td>
<p>Quantiles for which to test independence between exceedence and E.
Defaults to <code>c(0.1, 0.5, 0.9)</code>.</p>
</td></tr>
<tr><td><code id="InvariantConditionalQuantilePrediction_+3A_returnmodel">returnModel</code></td>
<td>
<p>If <code>TRUE</code>, the fitted quantile regression forest model
will be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
</p>
</li>
<li> <p><code>model</code> The fitted quantile regression forest model if <code>returnModel = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 1000
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantConditionalQuantilePrediction(Y, as.factor(E), X)

# Example 2
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * E + rnorm(n)
InvariantConditionalQuantilePrediction(Y, as.factor(E), X)

</code></pre>

<hr>
<h2 id='InvariantEnvironmentPrediction'>Invariant environment prediction.</h2><span id='topic+InvariantEnvironmentPrediction'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvariantEnvironmentPrediction(Y, E, X, alpha = 0.05, verbose = FALSE,
  trainTestSplitFunc = caTools::sample.split,
  argsTrainTestSplitFunc = list(Y = E, SplitRatio = 0.8),
  test = propTestTargetE, mtry = sqrt(NCOL(X)), ntree = 100,
  nodesize = 5, maxnodes = NULL, permute = TRUE,
  returnModel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. If <code>test = propTestTargetE</code>, E needs
to be a factor.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_traintestsplitfunc">trainTestSplitFunc</code></td>
<td>
<p>Function to split sample. Defaults to stratified sampling
using <code>caTools::sample.split</code>, assuming E is a factor.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_argstraintestsplitfunc">argsTrainTestSplitFunc</code></td>
<td>
<p>Arguments for sampling splitting function.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_test">test</code></td>
<td>
<p>Unconditional independence test that tests whether the out-of-sample
prediction accuracy is the same when using X only vs. X and Y as predictors for E.
Defaults to <code>propTestTargetE</code>.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_mtry">mtry</code></td>
<td>
<p>Random forest parameter: Number of variables randomly sampled as
candidates at each split.  Defaults to <code>sqrt(NCOL(X))</code>.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_ntree">ntree</code></td>
<td>
<p>Random forest parameter: Number of trees to grow. Defaults to 100.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_nodesize">nodesize</code></td>
<td>
<p>Random forest parameter: Minimum size of terminal nodes. Defaults to 5.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Random forest parameter: Maximum number of terminal nodes trees in the forest can have.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_permute">permute</code></td>
<td>
<p>Random forest parameter: If <code>TRUE</code>, model that would use X only
for predicting Y also includes a random permutation of E. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="InvariantEnvironmentPrediction_+3A_returnmodel">returnModel</code></td>
<td>
<p>If <code>TRUE</code>, the fitted quantile regression forest model
will be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
</p>
</li>
<li> <p><code>model</code> The fitted models if <code>returnModel = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 1000
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantEnvironmentPrediction(Y, as.factor(E), X)

# Example 2
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * E + rnorm(n)
InvariantEnvironmentPrediction(Y, as.factor(E), X)

# Example 3
E &lt;- rnorm(n)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantEnvironmentPrediction(Y, E, X, test = wilcoxTestTargetY)
InvariantEnvironmentPrediction(Y, X, E, test = wilcoxTestTargetY)
</code></pre>

<hr>
<h2 id='InvariantResidualDistributionTest'>Invariant residual distribution test.</h2><span id='topic+InvariantResidualDistributionTest'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvariantResidualDistributionTest(Y, E, X, alpha = 0.05,
  verbose = FALSE, fitWithGam = TRUE,
  test = leveneAndWilcoxResidualDistributions, colNameNoSmooth = NULL,
  mtry = sqrt(NCOL(X)), ntree = 100, nodesize = 5, maxnodes = NULL,
  returnModel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvariantResidualDistributionTest_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. E needs to be a factor.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_fitwithgam">fitWithGam</code></td>
<td>
<p>If <code>TRUE</code>, a GAM is used for the nonlinear regression, else
a random forest is used. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_test">test</code></td>
<td>
<p>Unconditional independence test that tests whether residual distribution is
invariant across different levels of E. Defaults to <code>leveneAndWilcoxResidDistributions</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_colnamenosmooth">colNameNoSmooth</code></td>
<td>
<p>Gam parameter: Name of variables that should enter linearly into the model.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_mtry">mtry</code></td>
<td>
<p>Random forest parameter: Number of variables randomly sampled as
candidates at each split. Defaults to <code>sqrt(NCOL(X))</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_ntree">ntree</code></td>
<td>
<p>Random forest parameter: Number of trees to grow. Defaults to 100.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_nodesize">nodesize</code></td>
<td>
<p>Random forest parameter: Minimum size of terminal nodes. Defaults to 5.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Random forest parameter: Maximum number of terminal nodes trees in the forest can have.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="InvariantResidualDistributionTest_+3A_returnmodel">returnModel</code></td>
<td>
<p>If <code>TRUE</code>, the fitted quantile regression forest model
will be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
</p>
</li>
<li> <p><code>model</code> The fitted model if <code>returnModel = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
n &lt;- 1000
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantResidualDistributionTest(Y, as.factor(E), X)
InvariantResidualDistributionTest(Y, as.factor(E), X, test = ksResidualDistributions)

# Example 2
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * E + rnorm(n)
InvariantResidualDistributionTest(Y, as.factor(E), X)
InvariantResidualDistributionTest(Y, as.factor(E), X, test = ksResidualDistributions)
</code></pre>

<hr>
<h2 id='InvariantTargetPrediction'>Invariant target prediction.</h2><span id='topic+InvariantTargetPrediction'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvariantTargetPrediction(Y, E, X, alpha = 0.05, verbose = FALSE,
  fitWithGam = TRUE, trainTestSplitFunc = caTools::sample.split,
  argsTrainTestSplitFunc = NULL, test = fTestTargetY,
  colNameNoSmooth = NULL, mtry = sqrt(NCOL(X)), ntree = 100,
  nodesize = 5, maxnodes = NULL, permute = TRUE,
  returnModel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvariantTargetPrediction_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector or an nxq dimensional matrix or dataframe.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_fitwithgam">fitWithGam</code></td>
<td>
<p>If <code>TRUE</code>, a GAM is used for the nonlinear regression, else
a random forest is used. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_traintestsplitfunc">trainTestSplitFunc</code></td>
<td>
<p>Function to split sample. Defaults to stratified sampling
using <code>caTools::sample.split</code>, assuming E is a factor.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_argstraintestsplitfunc">argsTrainTestSplitFunc</code></td>
<td>
<p>Arguments for sampling splitting function.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_test">test</code></td>
<td>
<p>Unconditional independence test that tests whether the out-of-sample
prediction accuracy is the same when using X only vs. X and E as predictors for Y.
Defaults to <code>fTestTargetY</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_colnamenosmooth">colNameNoSmooth</code></td>
<td>
<p>Gam parameter: Name of variables that should enter linearly into the model.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_mtry">mtry</code></td>
<td>
<p>Random forest parameter: Number of variables randomly sampled as
candidates at each split. Defaults to <code>sqrt(NCOL(X))</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_ntree">ntree</code></td>
<td>
<p>Random forest parameter: Number of trees to grow. Defaults to 100.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_nodesize">nodesize</code></td>
<td>
<p>Random forest parameter: Minimum size of terminal nodes. Defaults to 5.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Random forest parameter: Maximum number of terminal nodes trees in the forest can have.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_permute">permute</code></td>
<td>
<p>Random forest parameter: If <code>TRUE</code>, model that would use X only
for predicting Y also includes a random permutation of E. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="InvariantTargetPrediction_+3A_returnmodel">returnModel</code></td>
<td>
<p>If <code>TRUE</code>, the fitted quantile regression forest model
will be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
</p>
</li>
<li> <p><code>model</code> The fitted models if <code>returnModel = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 1000
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantTargetPrediction(Y, as.factor(E), X)
InvariantTargetPrediction(Y, as.factor(E), X, test = wilcoxTestTargetY)

# Example 2
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * E + rnorm(n)
InvariantTargetPrediction(Y, as.factor(E), X)
InvariantTargetPrediction(Y, as.factor(E), X, test = wilcoxTestTargetY)

# Example 3
E &lt;- rnorm(n)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
InvariantTargetPrediction(Y, E, X)
InvariantTargetPrediction(Y, X, E)
InvariantTargetPrediction(Y, E, X, test = wilcoxTestTargetY)
InvariantTargetPrediction(Y, X, E, test = wilcoxTestTargetY)
</code></pre>

<hr>
<h2 id='KCI'>Kernel conditional independence test.</h2><span id='topic+KCI'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X. The distribution of the test
statistic under the null hypothesis equals an infinite weighted sum of chi squared variables. This distribution
can either be approximated by a gamma distribution or by a Monte Carlo approach. This version includes an
implementation of choosing the hyperparameters by Gaussian Process regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KCI(Y, E, X, width = 0, alpha = 0.05, unbiased = FALSE,
  gammaApprox = TRUE, GP = TRUE, nRepBs = 5000, lambda = 0.001,
  thresh = 1e-05, numEig = NROW(Y), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KCI_+3A_y">Y</code></td>
<td>
<p>A vector of length n or a matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="KCI_+3A_e">E</code></td>
<td>
<p>A vector of length n or a matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="KCI_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="KCI_+3A_width">width</code></td>
<td>
<p>Kernel width; if it is set to zero, the width is chosen automatically (default: 0).</p>
</td></tr>
<tr><td><code id="KCI_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (default: 0.05).</p>
</td></tr>
<tr><td><code id="KCI_+3A_unbiased">unbiased</code></td>
<td>
<p>A boolean variable that indicates whether a bias correction should be applied (default: FALSE).</p>
</td></tr>
<tr><td><code id="KCI_+3A_gammaapprox">gammaApprox</code></td>
<td>
<p>A boolean variable that indicates whether the null distribution is approximated by a Gamma
distribution. If it is FALSE, a Monte Carlo approach is used (default: TRUE).</p>
</td></tr>
<tr><td><code id="KCI_+3A_gp">GP</code></td>
<td>
<p>Flag whether to use Gaussian Process regression to choose the hyperparameters</p>
</td></tr>
<tr><td><code id="KCI_+3A_nrepbs">nRepBs</code></td>
<td>
<p>Number of draws for the Monte Carlo approach (default: 500).</p>
</td></tr>
<tr><td><code id="KCI_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter (default: 1e-03).</p>
</td></tr>
<tr><td><code id="KCI_+3A_thresh">thresh</code></td>
<td>
<p>Threshold for eigenvalues. Whenever eigenvalues are computed, they are set to zero if they are
smaller than thresh times the maximum eigenvalue (default: 1e-05).</p>
</td></tr>
<tr><td><code id="KCI_+3A_numeig">numEig</code></td>
<td>
<p>Number of eigenvalues computed (only relevant for computing the distribution under the hypothesis
of conditional independence) (default: length(Y)).</p>
</td></tr>
<tr><td><code id="KCI_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>testStatistic</code> the statistic Tr(K_(ddot(Y)|X) * K_(E|X))
</p>
</li>
<li> <p><code>criticalValue</code> the critical point at the p-value equal to alpha;
obtained by a Monte Carlo approach if <code>gammaApprox = FALSE</code>, otherwise obtained by Gamma approximation.
</p>
</li>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
It is obtained by a Monte Carlo approach if <code>gammaApprox = FALSE</code>, 
otherwise obtained by Gamma approximation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 100
E &lt;- rnorm(n)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
KCI(Y, E, X)
KCI(Y, X, E)

</code></pre>

<hr>
<h2 id='ksResidualDistributions'>Kolmogorov-Smirnov test to compare residual distributions</h2><span id='topic+ksResidualDistributions'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantResidualDistributionTest</code>
to test whether residual distribution remains invariant across different levels
of E.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksResidualDistributions(Y, predicted, E, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksResidualDistributions_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="ksResidualDistributions_+3A_predicted">predicted</code></td>
<td>
<p>An n-dimensional vector of predictions for Y.</p>
</td></tr>
<tr><td><code id="ksResidualDistributions_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. <code>E</code> needs to be a factor.</p>
</td></tr>
<tr><td><code id="ksResidualDistributions_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

<hr>
<h2 id='leveneAndWilcoxResidualDistributions'>Levene and wilcoxon test to compare first and second moments of residual distributions</h2><span id='topic+leveneAndWilcoxResidualDistributions'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantResidualDistributionTest</code>
to test whether residual distribution remains invariant across different levels
of E.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leveneAndWilcoxResidualDistributions(Y, predicted, E, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leveneAndWilcoxResidualDistributions_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="leveneAndWilcoxResidualDistributions_+3A_predicted">predicted</code></td>
<td>
<p>An n-dimensional vector of predictions for Y.</p>
</td></tr>
<tr><td><code id="leveneAndWilcoxResidualDistributions_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector. <code>E</code> needs to be a factor.</p>
</td></tr>
<tr><td><code id="leveneAndWilcoxResidualDistributions_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

<hr>
<h2 id='propTestTargetE'>Proportion test to compare two misclassification rates.</h2><span id='topic+propTestTargetE'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantEnvironmentPrediction</code> to test
whether out-of-sample performance is better when using X and Y as predictors for E,
compared to using X only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propTestTargetE(E, predictedOnlyX, predictedXY, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propTestTargetE_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="propTestTargetE_+3A_predictedonlyx">predictedOnlyX</code></td>
<td>
<p>Predictions for E based on predictors in X only.</p>
</td></tr>
<tr><td><code id="propTestTargetE_+3A_predictedxy">predictedXY</code></td>
<td>
<p>Predictions for E based on predictors in X and Y.</p>
</td></tr>
<tr><td><code id="propTestTargetE_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

<hr>
<h2 id='ResidualPredictionTest'>Residual prediction test.</h2><span id='topic+ResidualPredictionTest'></span>

<h3>Description</h3>

<p>Tests the null hypothesis that Y and E are independent given X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResidualPredictionTest(Y, E, X, alpha = 0.05, verbose = FALSE,
  degree = 4, basis = c("nystrom", "nystrom_poly", "fourier",
  "polynomial", "provided")[1], resid_type = "OLS", XBasis = NULL,
  noiseMat = NULL, getnoiseFct = function(n, ...) {     rnorm(n) },
  argsGetNoiseFct = NULL, nSim = 100, funcOfRes = function(x) {    
  abs(x) }, useX = TRUE, returnXBasis = FALSE,
  nSub = ceiling(NROW(X)/4), ntree = 100, nodesize = 5,
  maxnodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ResidualPredictionTest_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_e">E</code></td>
<td>
<p>An n-dimensional vector or an nxq dimensional matrix or dataframe.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_x">X</code></td>
<td>
<p>A matrix or dataframe with n rows and p columns.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, intermediate output is provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_degree">degree</code></td>
<td>
<p>Degree of polynomial to use if  <code>basis="polynomial"</code> or  <code>basis="nystrom_poly"</code>.
Defaults to 4.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_basis">basis</code></td>
<td>
<p>Can be one of  <code>"nystrom","nystrom_poly","fourier","polynomial","provided"</code>. Defaults to  <code>"nystrom"</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_resid_type">resid_type</code></td>
<td>
<p>Can be  <code>"Lasso"</code> or  <code>"OLS"</code>. Defaults to  <code>"OLS"</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_xbasis">XBasis</code></td>
<td>
<p>Basis if  <code>basis="provided"</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_noisemat">noiseMat</code></td>
<td>
<p>Matrix with simulated noise. Defaults to NULL in which case the
simulation is performed inside the function.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_getnoisefct">getnoiseFct</code></td>
<td>
<p>Function to use to generate the noise matrix. Defaults to <code>function(n, ...){rnorm(n)}</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_argsgetnoisefct">argsGetNoiseFct</code></td>
<td>
<p>Arguments for <code>getnoiseFct</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_nsim">nSim</code></td>
<td>
<p>Number of simulations to use. Defaults to 100.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_funcofres">funcOfRes</code></td>
<td>
<p>Function of residuals to use in addition to predicting the
conditional mean. Defaults to <code>function(x){abs(x)}</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_usex">useX</code></td>
<td>
<p>Set to <code>TRUE</code> if the predictors in X should also be used when
predicting the scaled residuals with E. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_returnxbasis">returnXBasis</code></td>
<td>
<p>Set to <code>TRUE</code> if basis expansion should be returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_nsub">nSub</code></td>
<td>
<p>Number of random features to use if  <code>basis</code> is one of  <code>"nystrom","nystrom_poly"</code> or  <code>"fourier"</code>.
Defaults to <code>ceiling(NROW(X)/4)</code>.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_ntree">ntree</code></td>
<td>
<p>Random forest parameter: Number of trees to grow. Defaults to 500.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_nodesize">nodesize</code></td>
<td>
<p>Random forest parameter: Minimum size of terminal nodes. Defaults to 5.</p>
</td></tr>
<tr><td><code id="ResidualPredictionTest_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Random forest parameter: Maximum number of terminal nodes trees in the forest can have.
Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>pvalue</code> The p-value for the null hypothesis that Y and E are independent given X.
</p>
</li>
<li> <p><code>XBasis</code> Basis expansion if <code>returnXBasis</code> was set to <code>TRUE</code>.
</p>
</li>
<li> <p><code>fctBasisExpansion</code> Function used to create basis expansion if basis is not  <code>"provided"</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 100
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * (X)^2 + rnorm(n)
ResidualPredictionTest(Y, as.factor(E), X)

# Example 2
E &lt;- rbinom(n, size = 1, prob = 0.2)
X &lt;- 4 + 2 * E + rnorm(n)
Y &lt;- 3 * E + rnorm(n)
ResidualPredictionTest(Y, as.factor(E), X)

# not run:
# # Example 3
# E &lt;- rnorm(n)
# X &lt;- 4 + 2 * E + rnorm(n)
# Y &lt;- 3 * (X)^2 + rnorm(n)
# ResidualPredictionTest(Y, E, X)
# ResidualPredictionTest(Y, X, E)
</code></pre>

<hr>
<h2 id='wilcoxTestTargetY'>Wilcoxon test to compare two mean squared error rates.</h2><span id='topic+wilcoxTestTargetY'></span>

<h3>Description</h3>

<p>Used as a subroutine in <code>InvariantTargetPrediction</code> to test
whether out-of-sample performance is better when using X and E as predictors for Y,
compared to using X only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcoxTestTargetY(Y, predictedOnlyX, predictedXE, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcoxTestTargetY_+3A_y">Y</code></td>
<td>
<p>An n-dimensional vector.</p>
</td></tr>
<tr><td><code id="wilcoxTestTargetY_+3A_predictedonlyx">predictedOnlyX</code></td>
<td>
<p>Predictions for Y based on predictors in X only.</p>
</td></tr>
<tr><td><code id="wilcoxTestTargetY_+3A_predictedxe">predictedXE</code></td>
<td>
<p>Predictions for Y based on predictors in X and E.</p>
</td></tr>
<tr><td><code id="wilcoxTestTargetY_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> if output should be printed.</p>
</td></tr>
<tr><td><code id="wilcoxTestTargetY_+3A_...">...</code></td>
<td>
<p>Argument to allow for coherent interface of fTestTargetY and wilcoxTestTargetY.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the p-value for the test.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
