<!DOCTYPE html><html><head><title>Help for package MRPC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MRPC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdjustMatrix'>
<p>Adjust the columns of the input matrix same as in the reference matrix</p></a></li>
<li><a href='#aSHD'>
<p>Adjusted structural hamming distance (aSHD)</p></a></li>
<li><a href='#CompareMethodsNodeOrdering'><p>Comparison of inference accuracy using the same data but with different node orderings.</p></a></li>
<li><a href='#CompareMethodsVStructure'>
<p>Comparison of inference accuracy of different methods on data with and without a v-structure</p></a></li>
<li><a href='#CutModules'>
<p>Cut a numeric variable into intervals</p></a></li>
<li><a href='#data_examples'>
<p>Example data under simple and complex models</p></a></li>
<li><a href='#data_GEUVADIS'>
<p>GEUVADIS data with 62 eQTL-gene sets</p></a></li>
<li><a href='#data_GEUVADIS_combined'>
<p>Combined genotype and gene expression data from 62 eQTL-gene sets in 373 Europeans from GEUVADIS</p></a></li>
<li><a href='#data_with_outliers'>
<p>Example data with outliers</p></a></li>
<li><a href='#data_without_outliers'>
<p>Example data without outliers</p></a></li>
<li><a href='#EdgeOrientation'>
<p>Perform edge orientation under the MRPC algorithm</p></a></li>
<li><a href='#empty'>
<p>Check empty matrix</p></a></li>
<li><a href='#IdentifyAssociatedPCs'>
<p>Identifyprincipal components (PCs) that are significantly associated with eQTLs and genes</p></a></li>
<li><a href='#ModiSkeleton'>
<p>Infer a graph skeleton (undirected graph)</p></a></li>
<li><a href='#mpinv'>
<p>Calculate the inverse matrix</p></a></li>
<li><a href='#MRPC'>
<p>Infer a causal network using the MRPC algorithm</p></a></li>
<li><a href='#MRPCclass-class'><p>Class of MRPC algorithm results</p></a></li>
<li><a href='#MRPCtruth'>
<p>Graphs used as truth in simulation</p></a></li>
<li><a href='#PlotDendrogram'>
<p>Plot a dendrogram and display node groups in colored modules</p></a></li>
<li><a href='#PlotGraphWithModules'>
<p>Plot a graph with nodes in modules indicated by colors</p></a></li>
<li><a href='#RecallPrecision'>
<p>Calculate recall and precision for two graphs</p></a></li>
<li><a href='#RobustCor'>
<p>Calculate robust correlation matrix</p></a></li>
<li><a href='#seqDiff'>
<p>Deviation between two graphs represented by two sequences</p></a></li>
<li><a href='#SeqFDR'>
<p>Sequential FDR</p></a></li>
<li><a href='#simu_data_layered'>
<p>Data for the layered model</p></a></li>
<li><a href='#simu_data_M0'>
<p>Data for Model 0</p></a></li>
<li><a href='#simu_data_M1'>
<p>Data for Model 1</p></a></li>
<li><a href='#simu_data_M2'>
<p>Data for Model 2</p></a></li>
<li><a href='#simu_data_M3'>
<p>Data for Model 3</p></a></li>
<li><a href='#simu_data_M4'>
<p>Data for Model 4</p></a></li>
<li><a href='#simu_data_multiparent'>
<p>Data for the multiple-parent model</p></a></li>
<li><a href='#simu_data_starshaped '>
<p>Data for the star model</p></a></li>
<li><a href='#SimulateData'>
<p>Simulate data under certain graphs</p></a></li>
<li><a href='#SimulateData1P'>
<p>Simulate data for a node with one parent</p></a></li>
<li><a href='#SimulateData2P'>
<p>Simulate data for a node with two parents</p></a></li>
<li><a href='#SimulateData3P'>
<p>Simulate data for a node with three parents</p></a></li>
<li><a href='#SimulateDataNP'>
<p>Simulate data for a node with no parent</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-07</td>
</tr>
<tr>
<td>Title:</td>
<td>PC Algorithm with the Principle of Mendelian Randomization</td>
</tr>
<tr>
<td>Author:</td>
<td>Md Bahadur Badsha [aut,cre],Evan A Martin [ctb] and Audrey Qiuyan Fu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Audrey Fu &lt;audreyqyfu@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A PC Algorithm with the Principle of Mendelian Randomization. This package implements the MRPC 
            (PC with the principle of Mendelian randomization) algorithm to infer causal graphs. It also 
            contains functions to simulate data under a certain topology, to visualize a graph in different 
            ways, and to compare graphs and quantify the differences. 
            See Badsha and Fu (2019) &lt;<a href="https://doi.org/10.3389%2Ffgene.2019.00460">doi:10.3389/fgene.2019.00460</a>&gt;,Badsha, Martin and Fu (2021) &lt;<a href="https://doi.org/10.3389%2Ffgene.2021.651812">doi:10.3389/fgene.2021.651812</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>bnlearn,compositions,dynamicTreeCut,GGally,fastcluster,gtools,graph,graphics,Hmisc,methods,mice,
network,pcalg,psych,Rgraphviz,stats,sna,utils,WGCNA,plyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-09 23:04:20 UTC; audreyq.fu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 14:32:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdjustMatrix'>
Adjust the columns of the input matrix same as in the reference matrix
</h2><span id='topic+AdjustMatrix'></span>

<h3>Description</h3>

<p>We adjusted the columns of the input matrix to have the same ordering as in the reference matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdjustMatrix(reference, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdjustMatrix_+3A_reference">reference</code></td>
<td>
<p>The reference matrix.</p>
</td></tr>
<tr><td><code id="AdjustMatrix_+3A_input">input</code></td>
<td>
<p>The input matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reference matrix 
                  
reference &lt;- matrix(0,nrow=4,ncol = 4)
colnames(reference) &lt;- c("V1","T1","T2","T3")
rownames(reference) &lt;- colnames(reference)
   
# Adjacency matrix for reference  
reference[1,2] &lt;- 1
reference[2,3] &lt;- 1
reference[3,4] &lt;- 1

# Input matrix 
input &lt;- matrix(0,
                nrow = 4,
                ncol = 4)
colnames(input) &lt;- c("V1","T2","T3","T1")
rownames(input) &lt;- colnames(input)
   
# Adjacency matrix for input
input[1,2] &lt;- 1
input[2,3] &lt;- 1
input[3,4] &lt;- 1

# Adjust the columns of the input matrix same as in the reference matrix
AdjustMatrix &lt;- AdjustMatrix (reference, input)

</code></pre>

<hr>
<h2 id='aSHD'>
Adjusted structural hamming distance (aSHD) 
</h2><span id='topic+aSHD'></span>

<h3>Description</h3>

<p>The SHD as implemented in the R package pcalg (Kalisch et al., 2012) and bnlearn(Scutari, 2010), counts how many differences exist between two directed graphs. This distance is 1 if an edge exists in one graph but is missing in the other, or if the direction of an edge is different between the two graphs. The larger this distance is the more different the two graphs are. We adjusted the SHD to reduce the penalty of having the wrong direction of an edge to 0.5. For example, between two graphs V &ndash;&gt; T1 &lt;&ndash; T2 and V &ndash;&gt; T1 &ndash;&gt; T2, the SHD is 1 and the aSHD is 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aSHD(g1, g2, GV,edge.presence = 1.0, edge.direction = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aSHD_+3A_g1">g1</code></td>
<td>

<p>First graph object
</p>
</td></tr>
<tr><td><code id="aSHD_+3A_g2">g2</code></td>
<td>

<p>Second graph object
</p>
</td></tr>
<tr><td><code id="aSHD_+3A_gv">GV</code></td>
<td>
<p>The number of genetic variants (SNPs/indels/CNV/eQTL) in the input data matrix. For example, if the data has one genetic variant, first column, then GV = 1, if 2, 1st and 2nd column, then GV = 2, and so on.
</p>
</td></tr>
<tr><td><code id="aSHD_+3A_edge.presence">edge.presence</code></td>
<td>

<p>The weight for an edge being present.
</p>
</td></tr>
<tr><td><code id="aSHD_+3A_edge.direction">edge.direction</code></td>
<td>

<p>The weight for the edge direction.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>2. Scutari M (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># True model (V1 --&gt; T1 --&gt; T2 --&gt; T3)
tarmat_s1 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s1) &lt;- c("V1", "T1", "T2", "T3")

rownames(tarmat_s1) &lt;- colnames(tarmat_s1)

# Create an adjacency matrix for the true graph
tarmat_s1[1, 2] &lt;- 1
tarmat_s1[2, 3] &lt;- 1
tarmat_s1[3, 4] &lt;- 1

# Graph object of the true graph
Truth &lt;- as(tarmat_s1,
            "graphNEL")


# Inferred graph (V1 --&gt; T1 &lt;-- T2 --&gt; T3)
tarmat_s2 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s2) &lt;-c ("V1", "T1", "T2", "T3")

rownames(tarmat_s2) &lt;- colnames(tarmat_s2)

# Create an adjacency matrix for the inferred graph
tarmat_s2[1, 2] &lt;- 1
tarmat_s2[3, 2] &lt;- 1
tarmat_s2[3, 4] &lt;- 1

# Graph objects for the inferred graph
Inferred &lt;- as(tarmat_s2,
               "graphNEL")

Distance &lt;- aSHD(Truth,
                 Inferred,
                 GV = 1,
                 edge.presence = 1.0,
                 edge.direction = 0.5)

</code></pre>

<hr>
<h2 id='CompareMethodsNodeOrdering'>Comparison of inference accuracy using the same data but with different node orderings.</h2><span id='topic+CompareMethodsNodeOrdering'></span>

<h3>Description</h3>

<p>Investigate the performance of five methods on the same data but with different node orderings: <a href="#topic+MRPC">MRPC</a> (Badsha and Fu, 2019; Badsha et al., 2021), <a href="S4Vectors.html#topic+pc">pc</a>, implemented in <code>pcalg</code> (Kalisch et al., 2012), and pc.stable, mmpc, mmhc, and hc, the last four all implemented in <code>bnlearn</code> (Scutari, 2010). See details in Badsha et al.(2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareMethodsNodeOrdering(N, signal, model, n_data, n_nodeordering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareMethodsNodeOrdering_+3A_n">N</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="CompareMethodsNodeOrdering_+3A_signal">signal</code></td>
<td>
<p>The signal strength which is the coefficient of the parent nodes in the linear model.</p>
</td></tr>
<tr><td><code id="CompareMethodsNodeOrdering_+3A_model">model</code></td>
<td>
<p>Either 'truth1' or 'truth2' to specify the model to generate data from.</p>
</td></tr>
<tr><td><code id="CompareMethodsNodeOrdering_+3A_n_data">n_data</code></td>
<td>
<p>The number of independent data sets to generate.</p>
</td></tr>
<tr><td><code id="CompareMethodsNodeOrdering_+3A_n_nodeordering">n_nodeordering</code></td>
<td>
<p>The number of times to reorder the nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We generated different data sets from each of the two graphs (V1&ndash;&gt;T1&ndash;&gt;T2&ndash;&gt;T3 and V1&ndash;&gt;T1&lt;&ndash;T2&ndash;&gt;T3), where V1 is the genetic varitant node and T1, T2 and T3 are the phenotype nodes. For each data set, we reordered the columns of the data matrix with different permutations of the T nodes, and thus generated new permuted data sets. We then applied all the methods to each of the data sets (restricting edge direction wherever necessary and possible), obtained different inferred graphs, and counted the number of unique graphs among the inferred graphs for each data set. 
</p>
<p>The output is the number of unique graphs inferred by each method across all permutations.The columns are indicates which methods (MRPC, pc, pc.stable, mmpc mmhc, and hc), and each rows are indicates the independent data sets under different node orderings. See details in Badsha et al., 2018.
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>4. Scutari M (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
# Load the libraries
library(MRPC)    #  MRPC
library(pcalg)   #  pc
library(bnlearn) #  pc.stable, mmpc, mmhc, and hc

# For demonstration purposes, only 10 data sets
# are simulated from truth1 (V1--&gt;T1--&gt;T2--&gt;T3) 
# with sample size N = 100, signal = 1.0, 
# and 6 different T nodes orderings
Output &lt;- CompareMethodsNodeOrdering(N = 100,
                                     signal = 1.0, 
                                     model = 'truth1',
                                     n_data = 10,
                                     n_nodeordering = 6)


  </code></pre>

<hr>
<h2 id='CompareMethodsVStructure'>
Comparison of inference accuracy of different methods on data with and without a v-structure
</h2><span id='topic+CompareMethodsVStructure'></span>

<h3>Description</h3>

<p>This function compares inference accuracy on graphs with and without a v-structure in terms of recall and precision by six methods <a href="#topic+MRPC">MRPC</a>, <a href="S4Vectors.html#topic+pc">pc</a>, pc.stable, mmpc, mmhc, and hc, across multiple data sets. See details in Badsha and Fu (2019) and Badsha et al.(2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareMethodsVStructure(N, signal, model, includeGV, ita)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareMethodsVStructure_+3A_n">N</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="CompareMethodsVStructure_+3A_signal">signal</code></td>
<td>

<p>The coefficient of parent nodes in the linear model. For example, strong = 1.0, moderate = 0.5, and weak = 0.2.
</p>
</td></tr>
<tr><td><code id="CompareMethodsVStructure_+3A_model">model</code></td>
<td>

<p>The graph from which the data is generated.  Specifically, two graphs are considered here: 'model 1' (V1-&gt;T1-&gt;T2), which does not contain a v-structure, and 'model 2' (V1-&gt;T1&lt;-T2), which is a v-structure.
</p>
</td></tr>
<tr><td><code id="CompareMethodsVStructure_+3A_includegv">includeGV</code></td>
<td>

<p>If TRUE, include edges involving genetic variants (GVs) when comparing the true and inferred graphs. If FALSE, exclude such edges.  
</p>
</td></tr>
<tr><td><code id="CompareMethodsVStructure_+3A_ita">ita</code></td>
<td>
<p>Number of independent data sets to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a matrix, where the rows are the six methods: MRPC, pc, pc.stable, mmpc, mmhc, and hc, and the columns are the mean of recall, sd of recall, mean of precision, and sd of precision, respectively. Mean and sd are calculated across all the simulated data sets. For methods from the bnlearn package (pc.stable, mmpc, mmhc, and hc), we apply the blacklist argument to exclude edges pointing at the genetic variant, and therefore evaluate recall and precision including the edges involving these edges (i.e., includeGV = TRUE).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>4. Scutari M (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>See Also</h3>

<p><a href="#topic+RecallPrecision">RecallPrecision</a>: Performance evaluation in terms of recall and precision.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
 
# Load the libraries
library(MRPC)     # MRPC
library(pcalg)    # pc
library(bnlearn)  # pc.stable, mmpc, mmhc and hc

# For demonstration purposes, only 10 data sets 
# are simulated here 
# with sample size N = 100 and signal = 1

# Comparison of inference accuracy on 
# model 1 (mediation)
Result1 &lt;- CompareMethodsVStructure(N = 100, 
                                    signal = 1.0,
                                    'model1', 
                                    includeGV = TRUE,
                                    ita = 10)

# Comparison of inference accuracy on 
# model 2 (v-structure)
Result2 &lt;- CompareMethodsVStructure(N = 100, 
                                    signal = 1.0,
                                    'model2',
                                    includeGV = TRUE,
                                    ita = 10)


  </code></pre>

<hr>
<h2 id='CutModules'>
Cut a numeric variable into intervals
</h2><span id='topic+CutModules'></span>

<h3>Description</h3>

<p>Similar to <a href="Hmisc.html#topic+cut2">cut2</a> function with some modification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CutModules(x, cuts, m, g, levels.mean = FALSE, digits, minmax = TRUE,
    oneval = TRUE, onlycuts = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CutModules_+3A_x">x</code></td>
<td>

<p>Numeric vector to classify into intervals.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_cuts">cuts</code></td>
<td>

<p>Cut points
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_m">m</code></td>
<td>

<p>Desired minimum number of observations in a group.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_g">g</code></td>
<td>

<p>Number of quantile groups.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_levels.mean">levels.mean</code></td>
<td>

<p>Set to TRUE to make the new categorical vector have levels attribute that is the group means of x instead of interval endpoint labels.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_digits">digits</code></td>
<td>

<p>Number of significant digits to use in constructing levels. The default is 3, and 5 if levels.mean = TRUE.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_minmax">minmax</code></td>
<td>

<p>If cuts is specified but min(x) &lt; min(cuts) or max(x) &gt; max(cuts) augments cuts to include min and max x.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_oneval">oneval</code></td>
<td>

<p>If an interval contains only one unique value, the interval will be labeled with the formatted version of that value instead of the interval endpoints unless oneval = FALSE.
</p>
</td></tr>
<tr><td><code id="CutModules_+3A_onlycuts">onlycuts</code></td>
<td>

<p>Set to TRUE to only return the vector of computed cuts. This consists of the interior values plus outer ranges.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>

<hr>
<h2 id='data_examples'>
Example data under simple and complex models
</h2><span id='topic+data_examples'></span>

<h3>Description</h3>

<p>Example data under the simple and complex graphs. Data may be continuous or discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data_examples)
</code></pre>


<h3>Details</h3>

<p>For each model, the graph and a simulated data matrix are available for both continuous and discrete data. 
</p>
<p><b>For continuous data with genetic information</b>: 1000 samples in row and 6 variables in column. First two columns are the genetic variants and remaning columns are gene expression.
</p>
<p><b>Continuous data without genetic information</b>: 1000 samples in row and 8 variables in column.
</p>
<p><b>Discrete data with genetic information</b>: 1000 samples in row and 6 variables in column. First column is the genetic variant and remaning columns are the gene expression.
</p>
<p><b>Discrete data without genetic information</b>: 1000 samples in row and 5 variables in column.
</p>
<p><b>Continuous data with genetic information for complex model</b>: 1000 samples in row and 22 variables in column. First 14 column is the genetic variants and remaning columns are the genes expression.   
</p>


<h3>Value</h3>

<p>A list that containing the numeric data matrix and components of a graph.
</p>

<ul>
<li> <p><code>simple</code>: Simple model.
</p>
</li>
<li> <p><code>complex</code>: Complex model.
</p>
</li>
<li> <p><code>cont</code>: Continuous.
</p>
</li>
<li> <p><code>disc</code>: Discrete.
</p>
</li>
<li> <p><code>withGV</code>: With genetic information.
</p>
</li>
<li> <p><code>withoutGV</code>: Without genetic information.
</p>
</li>
<li> <p><code>data</code>: Data matrix.
</p>
</li>
<li> <p><code>graph</code>: Components of a graph.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Continuous data with genetic varitant (GV)
# load the data
data("data_examples")  
data &lt;- data_examples$simple$cont$withGV$data
# Extract the sample size
n &lt;- nrow(data)  

# Extract the node/column names
V &lt;- colnames(data)  

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
data.mrpc.cont.withGV &lt;- MRPC(data = data,
                              suffStat = suffStat_C, 
                              GV = 2,
                              FDR = 0.05, 
                              indepTest = 'gaussCItest',
                              labels = V,
                              FDRcontrol = 'LOND',
                              verbose = FALSE)
# Plot the results
par(mfrow = c(1, 2))
# plot the true graph
plot(data_examples$simple$cont$withGV$graph,
     main = "truth") 
# plot the inferred graph
plot(data.mrpc.cont.withGV,
     main = "inferred")    


# Continuous data without genetic information
# load the data
data("data_examples")    
data &lt;- data_examples$simple$cont$withoutGV$data
  
# Extract the sample size
n &lt;- nrow(data) 

# Extract the node/column names
V &lt;- colnames(data)

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
data.mrpc.cont.withoutGV &lt;- MRPC(data = data,
                                 suffStat = suffStat_C, 
                                 GV = 0,
                                 FDR = 0.05,
                                 indepTest = 'gaussCItest',
                                 labels = V, 
                                 FDRcontrol = 'LOND',
                                 verbose = FALSE)
# Plot the results
par(mfrow = c(1, 2))
# plot the true graph
plot(data_examples$simple$cont$withoutGV$graph,
     main = "truth") 
# plot the inferred graph
plot(data.mrpc.cont.withoutGV,
     main = "inferred") 

# Discrete data with genetic information
# load the data
data("data_examples")     
data &lt;- data_examples$simple$disc$withGV$data
  
# Extract the sample size
n &lt;- nrow(data)  

# Extract the node/column names
V &lt;- colnames(data)

suffStat_C &lt;- list (dm = data, adaptDF = FALSE, n.min = 1000)

# Infer the graph by MRPC
data.mrpc.disc.withGV &lt;- MRPC(data = data,
                              suffStat = suffStat_C, 
                              GV = 1,
                              FDR = 0.05, 
                              indepTest = 'disCItest',
                              labels = V, 
                              FDRcontrol = 'LOND',
                              verbose = FALSE)
# Plot the results
par (mfrow = c(1, 2))
# plot the true graph
plot(data_examples$simple$disc$withGV$graph,
     main = "truth") 
# Plot the inferred causal graph
plot(data.mrpc.disc.withGV,
     main = "inferred") 

# Discrete data without genetic information
# load the data
data("data_examples")    
data &lt;- data_examples$simple$disc$withoutGV$data
  
# Extract the sample size
n &lt;- nrow (data)  

# Extract the node/column names
V &lt;- colnames(data)   

suffStat_C &lt;- list (dm = data, adaptDF = FALSE, n.min = 1000)

# Infer the graph by MRPC
data.mrpc.disc.withoutGV &lt;- MRPC(data = data,
                                 suffStat = suffStat_C, 
                                 GV = 1,
                                 FDR = 0.05, 
                                 indepTest = 'disCItest',
                                 labels = V, 
                                 FDRcontrol = 'LOND',
                                 verbose = FALSE)
# Plot the results
par(mfrow = c(1, 2))
# plot the true graph
plot(data_examples$simple$disc$withoutGV$graph,
     main = "truth") 
# plot the inferred graph
plot(data.mrpc.disc.withoutGV,
     main = "inferred") 

# Continuous data with genetic information for complex model
# load the data
data("data_examples")   

# Graph without clustering
plot(data_examples$complex$cont$withGV$graph) 

# Adjacency matrix from directed example graph
Adj_directed &lt;- as(data_examples$complex$cont$withGV$graph,
                   "matrix")

# Plot of dendrogram with modules colors of nodes
PlotDendrogramObj &lt;- PlotDendrogram(Adj_directed,
                                    minModuleSize = 5)
                  
# Visualization of inferred graph with modules colors
PlotGraphWithModulesObj &lt;- PlotGraphWithModules(Adj_directed,
                                                PlotDendrogramObj,
                                                GV = 14,
                                                node.size = 8,
                                                arrow.size = 5,
                                                label.size = 3,
                                                alpha = 1) 
# plot 
plot(PlotGraphWithModulesObj)

# Run MRPC on the complex data set with ADDIS as the FDR control method.
data &lt;- data_examples$complex$cont$withGV$data
n &lt;- nrow (data)        # Number of rows
V &lt;- colnames(data)     # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
MRPC.addis &lt;- MRPC(data,
                   suffStat = suffStat_C,
                   GV = 14,
                   FDR = 0.05,
                   indepTest = 'gaussCItest',
                   labels = V,
                   FDRcontrol = 'ADDIS',
                   tau = 0.5,
                   lambda = 0.25,
                   verbose = FALSE)
                   
# Plot the true and inferred graphs.
par(mfrow = c(1, 2))
plot(data_examples$complex$cont$withGV$graph,
     main = 'True graph')
plot(MRPC.addis,
     main = 'Inferred graph')

## End(Not run)
  </code></pre>

<hr>
<h2 id='data_GEUVADIS'>
GEUVADIS data with 62 eQTL-gene sets 
</h2><span id='topic+data_GEUVADIS'></span>

<h3>Description</h3>

<p>The GEUVADIS (Lappalainen et al., 2013) data (i.e., gene expression) measured in Lymphoblastoid Cell Lines (LCLs) on a subset of individuals from the 1,000 Genomes Project including 373 Europeans and 89 Africans.
</p>


<h3>Details</h3>

<p>The GEUVADIS (Genetic European Variation in Disease) project identified eQTLs across the human genome. Among these eQTLs, ~70 have more than one target gene. Additionally, we found 62 unique eQTLs which exhibit pleiotropy. We extracted the genotypes of these 62 eQTLs and the expression of the target genes for 373 Europeans and 89 Africans (see Badsha and Fu, 2019; Badsha et al., 2021).
</p>


<h3>Value</h3>

<p>A list that contains 62 eQTL-gene sets data for 373 Europeans and 89 Africans.
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Lappalainen T, et al. (2013). Transcriptome and genome sequencing uncovers functional variation in humans. Nature, 501, 506-511.
</p>
<p>2. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>3. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data for 373 Europeans of eQTL #1
data_GEUVADIS$Data_Q1$Data_EUR

# Data for 89 Africans of eQTL #1
data_GEUVADIS$Data_Q1$Data_AFR
</code></pre>

<hr>
<h2 id='data_GEUVADIS_combined'>
Combined genotype and gene expression data from 62 eQTL-gene sets in 373 Europeans from GEUVADIS
</h2><span id='topic+data_GEUVADIS_combined'></span>

<h3>Description</h3>

<p>The genotype and gene expression data of 62 eQTL-gene sets in 373 Europeans from the GEUVADIS consortium (Lappalainen et al., 2013) are combined into one data matrix.  Each of these eQTLs has been identified to be associated with more than one gene (see details in Badsha and Fu, 2019).
</p>


<h3>Details</h3>

<p>The data set contains 373 samples in rows and 194 variables (62 eQTLs and 132 genes) in columns. Specifically, the columns are: eQTL1, gene1 for eQTL1, gene2 for eQTL1, eQTL2, gene1 for eQTL2, gene2 for eQTL2 and so on. 
</p>
<p>For analysis, we account for potential confounding variables as additional nodes in the graph.  To do so, we first perform Principal Component Analysis (PCA) on the entire gene expression matrix from the European samples in GEUVADIS, and extract the top 10 PCs as potential confounding variables.  We next examine the statistical association between each of the top PCs and the eQTL-gene sets, and identify statistically significant associations (accounting for multiple testing with the q vlaue method).  We then apply MRPC to each eQTL-gene set with its associated PCs. See details in the examples below. Also see Badsha and Fu (2019) and Badsha et al. (2021).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Lappalainen T, et al. (2013). Transcriptome and genome sequencing uncovers functional variation in humans. Nature, 501, 506-511.
</p>
<p>2. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>3. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>


<h3>See Also</h3>

<p><a href="#topic+data_GEUVADIS">data_GEUVADIS</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Examining principal components (PCs) as potential confounders in analysis of the GEUVADIS data
  
library(MRPC) # MRPC

# Load genomewide gene expression data in GEUVADIS 
# 373 individuals
# 23722 genes
data_githubURL &lt;- "https://github.com/audreyqyfu/mrpc_data/raw/master/data_GEUVADIS_allgenes.RData"
load(url(data_githubURL))

# Run PCA
library(stats) # prcomp
PCs &lt;- prcomp(data_GEUVADIS_allgenes,scale=TRUE)
# Extract the PCs 
PCs_matrix &lt;- PCs$x

# Load the 62 eQTL-gene sets
# 373 individuals
# 194 variables (eQTLs=62 and genes=132)
data("data_GEUVADIS_combined")  

# Identify PCs that are significantly associated with eQTL-gene sets
# Compute the correlation and corresponding p values between the top PCs and the eQTLs and genes
library(psych) # to use corr.test
no_PCs &lt;- 10   
corr_PCs &lt;- corr.test(PCs_matrix[,1:no_PCs],data_GEUVADIS_combined)
# The correlation matrix
corr_matrix &lt;- corr_PCs$r
# The p values
Pvalues &lt;- corr_PCs$p
# Apply the q value method at FDR of 0.05
library(WGCNA) # qvalue
qobj &lt;- qvalue(Pvalues, fdr.level=0.05,robust = TRUE) 

# Significant associations
Significant_asso &lt;- qobj$significant
List_significant_asso &lt;- which(Significant_asso, arr.ind = TRUE, useNames = TRUE)
# 1st column contains the PCs
# 2nd column contains the associated eQTLs or genes
List_significant_asso[1:10,]

# Examples of eQTLs or genes that are significantly associated with selected PCs
# PC1
eqtl.genes_PC1 &lt;- colnames(data_GEUVADIS_combined)[List_significant_asso 
                           [which(List_significant_asso[,1]=="1"),2]]
print(eqtl.genes_PC1)
# PC2
eqtl.genes_PC2 &lt;- colnames(data_GEUVADIS_combined)[List_significant_asso 
                           [which(List_significant_asso[,1]=="2"),2]]
print(eqtl.genes_PC2)
# PC3
eqtl.genes_PC3 &lt;- colnames(data_GEUVADIS_combined)[List_significant_asso 
                           [which(List_significant_asso[,1]=="3"),2]]
print(eqtl.genes_PC3)


#------------- 
# Example 1 
# Gene SBF2-AS1 is significantly associated with PC2 
print(eqtl.genes_PC2[24])

# Gene SBF2-AS1 is in the eQTL-gene set #50 with snp rs7124238 and gene SWAP70
data_GEU_Q50 &lt;- data_GEUVADIS$Data_Q50$Data_EUR
colnames(data_GEU_Q50) &lt;- c("rs7124238","SBF2-AS1","SWAP70")

# Analyze the eQTL-gene set without PC2
n &lt;- nrow (data_GEU_Q50)        # Number of rows
V &lt;- colnames(data_GEU_Q50)     # Column names

# Calculate Pearson correlation
suffStat_C_Q50 &lt;- list(C = cor(data_GEU_Q50, use = 'pairwise.complete.obs'),
                       n = n)

# Infer the graph by MRPC 
MRPC.fit_withoutPC_GEU_Q50 &lt;- MRPC(data_GEU_Q50, 
                                  suffStat = suffStat_C_Q50, 
                                  GV = 1, 
                                  FDR = 0.05, 
                                  indepTest = 'gaussCItest', 
                                  labels = V,  
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Analyze the eQTL-gene set with PC2
data_withPC_Q50 &lt;- cbind(data_GEU_Q50,PCs_matrix[,2])
colnames(data_withPC_Q50)[4] &lt;- "PC2"

n &lt;- nrow (data_withPC_Q50)        # Number of rows
V &lt;- colnames(data_withPC_Q50)     # Column names

# Calculate Pearson correlation
suffStat_C_withPC_Q50 &lt;- list(C = cor(data_withPC_Q50, use = 'pairwise.complete.obs'),  
                              n = n)

# Infer the graph by MRPC
MRPC.fit_withPC_GEU_Q50 &lt;- MRPC(data_withPC_Q50, 
                                suffStat = suffStat_C_withPC_Q50, 
                                GV = 1, 
                                FDR = 0.05, 
                                indepTest = 'gaussCItest', 
                                labels = V,  
                                FDRcontrol = 'LOND', 
                                verbose = FALSE)

# Plot inferred graphs 
par(mfrow=c(1,2))
plot(MRPC.fit_withoutPC_GEU_Q50,
     main = "Without PC" )
plot(MRPC.fit_withPC_GEU_Q50,
     main = "Without PC")

#------------- 
# Example 2
# Gene LCMT2 is significantly associated with PC1 
print(eqtl.genes_PC1[8])

# Gene LCMT2 is in the eQTL-gene set #29 with snp rs2278858 and gene ADAL 
data_GEU_Q29 &lt;- data_GEUVADIS$Data_Q29$Data_EUR
colnames(data_GEU_Q29) &lt;- c("rs2278858", "LCMT2", "ADAL")

# Analyze the eQTL-gene set without PC1
n &lt;- nrow (data_GEU_Q29)        # Number of rows
V &lt;- colnames(data_GEU_Q29)     # Column names

# Calculate Pearson correlation
suffStat_C_Q29 &lt;- list(C = cor(data_GEU_Q29, use = 'pairwise.complete.obs'),
                       n = n)

# Infer the graph by MRPC
MRPC.fit_withoutPC_GEU_Q29 &lt;- MRPC(data_GEU_Q29, 
                                   suffStat = suffStat_C_Q29, 
                                   GV = 1, 
                                   FDR = 0.05, 
                                   indepTest = 'gaussCItest', 
                                   labels = V,  
                                   FDRcontrol = 'LOND', 
                                   verbose = FALSE)
 
# Analyze the eQTL-gene set with PC1
data_withPC_Q29 &lt;- cbind(data_GEU_Q29,PCs_matrix[,1])
colnames(data_withPC_Q29)[4] &lt;- "PC1"

n &lt;- nrow (data_withPC_Q29)        # Number of rows
V &lt;- colnames(data_withPC_Q29)     # Column names

# Calculate Pearson correlation
suffStat_C_withPC_Q29 &lt;- list(C = cor(data_withPC_Q29, use = 'pairwise.complete.obs'),
                              n = n)

# Infer graph by MRPC
MRPC.fit_withPC_GEU_Q29 &lt;- MRPC(data_withPC_Q29, 
                                suffStat = suffStat_C_withPC_Q29, 
                                GV = 1, 
                                FDR = 0.05, 
                                indepTest = 'gaussCItest', 
                                labels = V,  
                                FDRcontrol = 'LOND', 
                                verbose = FALSE)
 
# Plot inferred graphs 
par(mfrow=c(1,2))
plot(MRPC.fit_withoutPC_GEU_Q29,
     main = "Without PC" )
plot(MRPC.fit_withPC_GEU_Q29,
     main = "With PC")

#------------- 
# Example 3
# Genes SERPINB8 and HMSD are significantly associated with PC2 
print(eqtl.genes_PC2[c(20,21)])

# Genes SERPINB8 and HMSD are in the eQTL-gene set #43 with snp rs55928920 
data_GEU_Q43 &lt;- data_GEUVADIS$Data_Q43$Data_EUR
colnames(data_GEU_Q43) &lt;- c("rs55928920",	"SERPINB8",	"HMSD")

# Analyze the eQTL-gene set without PC2
n &lt;- nrow (data_GEU_Q43)        # Number of rows
V &lt;- colnames(data_GEU_Q43)     # Column names

# Calculate Pearson correlation
suffStat_C_Q43 &lt;- list(C = cor(data_GEU_Q43, use = 'pairwise.complete.obs'), 
                       n = n)

# Infer the graph by MRPC
MRPC.fit_withoutPC_GEU_Q43 &lt;- MRPC(data_GEU_Q43, 
                                   suffStat = suffStat_C_Q43, 
                                   GV = 1, 
                                   FDR = 0.05, 
                                   indepTest = 'gaussCItest', 
                                   labels = V,  
                                   FDRcontrol = 'LOND', 
                                   verbose = FALSE)
 
# Analyze the eQTL-gene set with PC2
data_withPC_Q43 &lt;- cbind(data_GEU_Q43,PCs_matrix[,2])
colnames(data_withPC_Q43)[4] &lt;- "PC2"

n &lt;- nrow (data_withPC_Q43)        # Number of rows
V &lt;- colnames(data_withPC_Q43)     # Column names

# Calculate Pearson correlation
suffStat_C_withPC_Q43 &lt;- list(C = cor(data_withPC_Q43, use = 'pairwise.complete.obs'), 
                              n = n)

# Infer the graph by MRPC
MRPC.fit_withPC_GEU_Q43 &lt;- MRPC(data_withPC_Q43, 
                                suffStat = suffStat_C_withPC_Q43, 
                                GV = 1, 
                                FDR = 0.05, 
                                indepTest = 'gaussCItest', 
                                labels = V,  
                                FDRcontrol = 'LOND', 
                                verbose = FALSE)

# Plot inferred graphs
par(mfrow=c(1,2))
plot(MRPC.fit_withoutPC_GEU_Q43,
     main = "Without PC" )
plot(MRPC.fit_withPC_GEU_Q43,
     main = "With PC")

#------------- 
# Example 4
# Gene PLAC8 is significantly associated with PC2 and PC3
print(eqtl.genes_PC2[17])
print(eqtl.genes_PC3[12])

# Gene PLAC8 is in the eQTL-gene set  #34 with snp rs28718968 and gene COQ2 
data_GEU_Q34 &lt;- data_GEUVADIS$Data_Q34$Data_EUR
colnames(data_GEU_Q34) &lt;- c("rs28718968",	"COQ2", "PLAC8")

# Analyze the eQTL-gene set without PC2 and PC3
n &lt;- nrow (data_GEU_Q34)        # Number of rows
V &lt;- colnames(data_GEU_Q34)     # Column names

# Calculate Pearson correlation
suffStat_C_Q34 &lt;- list(C = cor(data_GEU_Q34, use = 'pairwise.complete.obs'), 
                       n = n)

# Infer the graph by MRPC
MRPC.fit_withoutPC_GEU_Q34 &lt;- MRPC(data_GEU_Q34, 
                                   suffStat = suffStat_C_Q34, 
                                   GV = 1, 
                                   FDR = 0.05, 
                                   indepTest = 'gaussCItest', 
                                   labels = V,  
                                   FDRcontrol = 'LOND', 
                                   verbose = FALSE)
 
# Analyze the eQTL-gene set with PC2 and PC3
data_withPC_Q34 &lt;- cbind(data_GEU_Q34,PCs_matrix[,c(2,3)])
colnames(data_withPC_Q34)[4:5] &lt;- c("PC2", "PC3")

n &lt;- nrow (data_withPC_Q34)        # Number of rows
V &lt;- colnames(data_withPC_Q34)     # Column names

# Calculate Pearson correlation
suffStat_C_withPC_Q34 &lt;- list(C = cor(data_withPC_Q34, use = 'pairwise.complete.obs'), 
                              n = n)

# Infer the graph by MRPC
MRPC.fit_withPC_GEU_Q34 &lt;- MRPC(data_withPC_Q34, 
                                suffStat = suffStat_C_withPC_Q34, 
                                GV = 1, 
                                FDR = 0.05, 
                                indepTest = 'gaussCItest', 
                                labels = V,  
                                FDRcontrol = 'LOND', 
                                verbose = FALSE)

# Plot inferred graphs 
par(mfrow=c(1,2))
plot(MRPC.fit_withoutPC_GEU_Q34,
     main = "Without PC" )
plot(MRPC.fit_withPC_GEU_Q34,
     main = "With PC")

#-------------
# Example 5
# Genes PIP4P1 and PNP are significantly associated with PC1 and PC3, respectively.
print(eqtl.genes_PC1[1])
print(eqtl.genes_PC3[7])

# Genes PIP4P1 and PNP are in the eQTL-gene set #8 with snp rs11305802 and gene  AL355075.3 
data_GEU_Q8 &lt;- data_GEUVADIS$Data_Q8$Data_EUR
colnames(data_GEU_Q8) &lt;- c("rs11305802","PIP4P1", "AL355075.3", "PNP")

# Analyze the eQTL-gene set without PC1 and PC3
n &lt;- nrow (data_GEU_Q8)        # Number of rows
V &lt;- colnames(data_GEU_Q8)     # Column names

# Calculate Pearson correlation
suffStat_C_Q8 &lt;- list(C = cor(data_GEU_Q8, use = 'pairwise.complete.obs'), 
                      n = n)

# Infer the graph by MRPC
MRPC.fit_withoutPC_GEU_Q8 &lt;- MRPC(data_GEU_Q8, 
                                  suffStat = suffStat_C_Q8, 
                                  GV = 1, 
                                  FDR = 0.05, 
                                  indepTest = 'gaussCItest', 
                                  labels = V,  
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)
 
# Analyze the eQTL-gene set with PC1 and PC3
data_withPC_Q8 &lt;- cbind(data_GEU_Q8,PCs_matrix[,c(1,3)])
colnames(data_withPC_Q8)[5:6] &lt;- c("PC1","PC3")


n &lt;- nrow (data_withPC_Q8)        # Number of rows
V &lt;- colnames(data_withPC_Q8)     # Column names

# Calculate Pearson correlation
suffStat_C_withPC_Q8 &lt;- list(C = cor(data_withPC_Q8, use = 'pairwise.complete.obs'), 
                             n = n)

# Infer the graph by MRPC
MRPC.fit_withPC_GEU_Q8 &lt;- MRPC(data_withPC_Q8, 
                               suffStat = suffStat_C_withPC_Q8, 
                               GV = 1, 
                               FDR = 0.05, 
                               indepTest = 'gaussCItest', 
                               labels = V,  
                               FDRcontrol = 'LOND', 
                               verbose = FALSE)
# Plot inferred graphs 
par(mfrow=c(1,2))
plot(MRPC.fit_withoutPC_GEU_Q8,
     main = "Without PC" )
plot(MRPC.fit_withPC_GEU_Q8,
     main = "With PC")


## End(Not run)
</code></pre>

<hr>
<h2 id='data_with_outliers'>
Example data with outliers
</h2><span id='topic+data_with_outliers'></span>

<h3>Description</h3>

<p>The data contain two genotype nodes, V1 and V2, and three phenotype nodes, T1, T2 and T3. The genotype nodes are discrete, whereas the phenotype nodes are continuous. The data matrix includes 10 outliers (noises) generated from a uniform distribution. The example code below compares the performance of <a href="#topic+MRPC">MRPC</a>, <a href="S4Vectors.html#topic+pc">pc</a>, pc.stable, mmpc, mmhc, and hc on this data set.
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# Load packages

library(MRPC)     # MRPC
library(pcalg)    # pc
library(bnlearn)  # pc.stable, mmpc, mmhc, and hc


# Truth without outlier
tarmat &lt;- matrix(0,
                 nrow = ncol(data_with_outliers),
                 ncol = ncol(data_with_outliers))
colnames(tarmat) &lt;- colnames(data_with_outliers)
rownames(tarmat) &lt;- colnames(data_with_outliers)

tarmat[1,2] &lt;- 1
tarmat[2,1] &lt;- 1
tarmat[1,3] &lt;- 1
tarmat[4,3] &lt;- 1
tarmat[4,5] &lt;- 1

# Graph
Truth &lt;- as(tarmat,
            "graphNEL")

# Data without outliers
n &lt;- nrow(data_without_outliers)     # Number of rows
V &lt;- colnames(data_without_outliers) # Column names

# Calculate Pearson correlation
suffStat_C1 &lt;- list(C = cor(data_without_outliers),
                    n = n)

# Infer the graph by MRPC
MRPC.fit_withoutoutliers &lt;- MRPC (data_without_outliers, 
                                  suffStat = suffStat_C1, 
                                  GV = 2, 
                                  FDR = 0.05, 
                                  indepTest ='gaussCItest', 
                                  labels = V, 
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Infer the graph by pc 
pc.fit_withoutoutliers &lt;- pc(suffStat = suffStat_C1,
                            indepTest = gaussCItest,
                            alpha = 0.05, 
                            labels = V,
                            verbose = FALSE)

# arcs not to be included from gene expression to genotype for blacklist argument 
# in pc.stable and mmpc

GV &lt;- 2
to &lt;- rep (colnames (data_without_outliers)[1:GV], each = (ncol (data_without_outliers) - GV))
from &lt;- rep (colnames (data_without_outliers)[(GV + 1):ncol (data_without_outliers)], GV)
bl &lt;- cbind (from, to)

# Infer the graph by pc.stable
pc.stable_withoutoutliers &lt;- pc.stable (data.frame (data_without_outliers), 
                                        blacklist = bl, 
                                        alpha = 0.05, 
                                        debug = FALSE, 
                                        undirected = FALSE)
# Infer the graph by mmpc
mmpc_withoutoutliers &lt;- mmpc (data.frame (data_without_outliers), 
                              blacklist = bl, 
                              alpha = 0.05, 
                              debug = FALSE, 
                              undirected = FALSE)
# Infer the graph by mmhc
mmhc_withoutoutliers &lt;- mmhc (data.frame (data_without_outliers), 
                              blacklist = bl, 
                              debug = FALSE)
# Infer the graph by hc
hc_withoutoutliers &lt;- hc (data.frame (data_without_outliers), 
                          blacklist = bl, 
                          debug = FALSE)


# Data with outliers
n &lt;- nrow (data_with_outliers)    # Number of rows
V &lt;- colnames(data_with_outliers) # Column names

# Calculate Pearson correlation
suffStat_C2 &lt;- list (C = cor (data_with_outliers), 
                     n = n)

# Infer the graph by MRPC
MRPC.fit_withoutliers_C2 &lt;- MRPC (data_with_outliers, 
                                  suffStat = suffStat_C2, 
                                  GV = 2, 
                                  FDR = 0.05, 
                                  indepTest ='gaussCItest', 
                                  labels = V, 
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Infer the graph by pc
pc.fit_withoutliers_C2 &lt;- pc (suffStat = suffStat_C2, 
                              indepTest = gaussCItest, 
                              alpha = 0.05, 
                              labels = V, 
                              verbose = FALSE)

# arcs not to be included from gene expression to genotype for blacklist argument 
# in pc.stable and mmpc

GV &lt;- 2
to &lt;- rep (colnames (data_with_outliers)[1:GV], each = (ncol (data_with_outliers) - GV))
from &lt;- rep (colnames (data_with_outliers)[(GV + 1):ncol (data_with_outliers)], GV)
bl &lt;- cbind (from, to)

# Infer the graph by pc.stable
pc.stable_withoutliers_C2 &lt;- pc.stable (data.frame (data_with_outliers), 
                                        blacklist = bl, 
                                        alpha = 0.05, 
                                        B = NULL, 
                                        max.sx = NULL, 
                                        debug = FALSE, 
                                        undirected = FALSE)
# Infer the graph by mmpc
mmpc_withoutliers_C2 &lt;- mmpc (data.frame (data_with_outliers), 
                              blacklist = bl, 
                              alpha = 0.05, 
                              B = NULL, 
                              max.sx = NULL, 
                              debug = FALSE, 
                              undirected = FALSE)
# Infer the graph by mmhc
mmhc_withoutliers_C2 &lt;- mmhc (data.frame (data_with_outliers), 
                              blacklist = bl, 
                              debug = FALSE)


# Infer the graph by hc
hc_withoutliers_C2 &lt;- hc (data.frame (data_with_outliers), 
                          blacklist = bl, 
                          debug = FALSE)

# Calculate robust correlation (Beta = 0.005)
Rcor_R1 &lt;- RobustCor (data_with_outliers, 0.005)
suffStat_R1 &lt;- list (C = Rcor_R1$RR, 
                     n = n)

# Infer the graph by MRPC with robust correlation
MRPC.fit_withoutliers_R1 &lt;- MRPC (data_with_outliers, 
                                  suffStat = suffStat_R1, 
                                  GV = 2, 
                                  FDR = 0.05, 
                                  indepTest = 'gaussCItest', 
                                  labels = V, 
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Infer the graph by pc with robust correlation
pc.fit_withoutliers_R1 &lt;- pc (suffStat = suffStat_R1, 
                              indepTest = gaussCItest, 
                              alpha = 0.05, 
                              labels = V, 
                              verbose = FALSE)


# True graph
plot (Truth, main = "Truth")

#-------------
# Plot inferred graphs
par (mfrow = c (2,6))

# Data without outliers
# Inference with Pearson correlation
plot (MRPC.fit_withoutoutliers, main = "MRPC")
plot (pc.fit_withoutoutliers, main = "pc")
graphviz.plot (pc.stable_withoutoutliers, main = "pc.stable")
graphviz.plot (mmpc_withoutoutliers, main = "mmpc")
graphviz.plot (mmhc_withoutoutliers, main = "mmhc")
graphviz.plot (hc_withoutoutliers, main = "hc")


# Data with outliers
# Inference with Pearson correlation
plot (MRPC.fit_withoutliers_C2, main = " ")
plot (pc.fit_withoutliers_C2, main = " ")
graphviz.plot (pc.stable_withoutliers_C2, main = " ")
graphviz.plot (mmpc_withoutliers_C2, main = " ")
graphviz.plot (mmhc_withoutliers_C2, main = " ")
graphviz.plot (hc_withoutliers_C2, main = " ")

#-------------
# Data with outliers
# Inference with robust correlation
par (mfrow = c (1,2))
plot (MRPC.fit_withoutliers_R1, main = "MRPC")
plot (pc.fit_withoutliers_R1, main = "pc")


## End(Not run)
  </code></pre>

<hr>
<h2 id='data_without_outliers'>
Example data without outliers
</h2><span id='topic+data_without_outliers'></span>

<h3>Description</h3>

<p>The data contain two genotype nodes, V1 and V2, and three phenotype nodes, T1, T2 and T3. The code below compares the performance of <a href="#topic+MRPC">MRPC</a>, <a href="S4Vectors.html#topic+pc">pc</a> pc.stable, mmpc, mmhc, and hc on this data set.
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# Load packages

library(MRPC)     # MRPC
library(pcalg)    # pc
library(bnlearn)  # pc.stable, mmpc, mmhc, and hc

# Truth without outlier
tarmat &lt;- matrix(0,
                 nrow = ncol(data_with_outliers),
                 ncol = ncol(data_with_outliers))
                
colnames(tarmat) &lt;- colnames(data_with_outliers)
rownames(tarmat) &lt;- colnames(data_with_outliers)

tarmat[1,2] &lt;- 1
tarmat[2,1] &lt;- 1
tarmat[1,3] &lt;- 1
tarmat[4,3] &lt;- 1
tarmat[4,5] &lt;- 1

Truth &lt;- as(tarmat,
            "graphNEL")

# Data without outliers
n &lt;- nrow(data_without_outliers)     # Number of rows
V &lt;- colnames(data_without_outliers) # Column names

# Calculate Pearson correlation
suffStat_C1 &lt;- list(C = cor(data_without_outliers),
                    n = n)

# Infer the graph by MRPC
MRPC.fit_withoutoutliers &lt;- MRPC (data_without_outliers, 
                                  suffStat = suffStat_C1, 
                                  GV = 2, 
                                  FDR = 0.05, 
                                  indepTest ='gaussCItest', 
                                  labels = V, 
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Infer the graph by pc with Pearson correlation
pc.fit_withoutoutliers &lt;- pc(suffStat = suffStat_C1,
                            indepTest = gaussCItest,
                            alpha = 0.05, 
                            labels = V,
                            verbose = FALSE)

# arcs not to be included from gene expression to genotype for blacklist argument 
# in pc.stable and mmpc

GV &lt;- 2
to &lt;- rep (colnames (data_without_outliers)[1:GV], each = (ncol (data_without_outliers) - GV))
from &lt;- rep (colnames (data_without_outliers)[(GV + 1):ncol (data_without_outliers)], GV)
bl &lt;- cbind (from, to)

# Infer the graph by pc.stable
pc.stable_withoutoutliers &lt;- pc.stable (data.frame (data_without_outliers), 
                                        blacklist = bl, 
                                        alpha = 0.05, 
                                        debug = FALSE, 
                                        undirected = FALSE)
# Infer the graph by mmpc
mmpc_withoutoutliers &lt;- mmpc (data.frame (data_without_outliers), 
                              blacklist = bl, 
                              alpha = 0.05, 
                              debug = FALSE, 
                              undirected = FALSE)
# Infer the graph by mmhc
mmhc_withoutoutliers &lt;- mmhc (data.frame (data_without_outliers), 
                              blacklist = bl, 
                              debug = FALSE)
# Infer the graph by hc
hc_withoutoutliers &lt;- hc (data.frame (data_without_outliers), 
                          blacklist = bl, 
                          debug = FALSE)
# True graph
plot (Truth, main = "Truth")

#-------------
# Plot inferred graphs
par (mfrow = c (2,3))

# Data without outliers
# Inference with Pearson correlation
plot (MRPC.fit_withoutoutliers, main = "MRPC")
plot (pc.fit_withoutoutliers, main = "pc")
graphviz.plot (pc.stable_withoutoutliers, main = "pc.stable")
graphviz.plot (mmpc_withoutoutliers, main = "mmpc")
graphviz.plot (mmhc_withoutoutliers, main = "mmhc")
graphviz.plot (hc_withoutoutliers, main = "hc")

## End(Not run)
  </code></pre>

<hr>
<h2 id='EdgeOrientation'>
Perform edge orientation under the MRPC algorithm
</h2><span id='topic+EdgeOrientation'></span>

<h3>Description</h3>

<p>This function performs the second step of the <a href="#topic+MRPC">MRPC</a> algorithm where it determines the edge direction in the graph skeleton inferred by the function <a href="#topic+ModiSkeleton">ModiSkeleton</a>. If the data contain genetic variants, this function first determines the edges between genetic variants and phenotype nodes based on the principle of Mendelian randomization. Next it identifies potential v-structures and orients the edges in them. For the remaining edges, it examines triplets in turn to see whether a triplet is compatible with one of the basic models. See the references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgeOrientation(gInput, GV, suffStat, FDR, alpha, indepTest, 
                FDRcontrol = c("LOND", "ADDIS", "NONE"), 
                tau = 0.5, lambda = 0.25, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeOrientation_+3A_ginput">gInput</code></td>
<td>
<p>Object containing the skeleton and marginal and conditional independence information.
</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_gv">GV</code></td>
<td>
<p>The number of genetic variants (SNPs/indels/CNV/eQTL) in the input data matrix. For example, if the data has one genetic variant, first column, then GV = 1, if 2, 1st and 2nd Column, then GV = 2, and so on.
</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics. When the data is continuous or can be viewed as continuous, this list contains the correlation matrix of the data and the sample size, which are the necessary elements for the conditional independence tests in gaussCItest. When the data is discrete, this list contains the entire dataset.
</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_fdr">FDR</code></td>
<td>

<p>False discovery rate (number between 0 and 1). If FDR = 0.05, this ensures that the FDR remains below 0.05.</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (number in (0,1) for the individual tests.</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_indeptest">indepTest</code></td>
<td>
<p>A <a href="base.html#topic+function">function</a> for testing conditional independence. It is used to test the conditional independence of x and y given S, called as indepTest(x, y, S, suffStat). Where, x and y are variables, and S is a vector, possibly empty, of variables. suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence. There are three options for different data types, for example, Gaussian data = gaussCItest, discrete data = disCItest and Binary data = binCItest. See help(gaussCItest)</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_fdrcontrol">FDRcontrol</code></td>
<td>
<p>A character string specifying whether online FDR control should be applied, and if so, what method to use. The two FDR control options are &quot;LOND&quot; (Javanmard and Montanari, 2015) or &quot;ADDIS&quot; (Tian and Ramdas, 2019). If &quot;NONE&quot; is specified, the type I error rate &quot;alpha&quot; will be used for each test.</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_tau">tau</code></td>
<td>
<p>A number between 0 and 1. This value is used to determine if a p-value will be considered for testing. For example, if a p-value is greater than tau then it is discarded and no test will be performed.</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and tau. This value is used to determine if a p-value is a candidate for rejection. For example, if a p-value is smaller than lambda then it can be rejected when testing the hypothesis (if the p-value is smaller than alphai).</p>
</td></tr>
<tr><td><code id="EdgeOrientation_+3A_verbose">verbose</code></td>
<td>
<p>(optional) 1: detailed output is provided; 0: No output is provided</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The orientation of the edge directions based on the principle of Mendelian randomization involves four cases, which are four of the five basic models in Badsha and Fu (2019) and Badsha et al.(2021). For example, we consider x to be a genetic variant, y and z the phenotype nodes.
</p>
<p>The four cases are as follows:
</p>
<p><b>Case-1</b>: Relation between x, genetic variant, and the other nodes. Then genetic variant will regulate the other node, genes, and direction will be genetic variant &ndash;&gt; other node. Note that if the data has more than one genetic variant and there is an edge between two genetic variants, then direction will be genetic variant &lt;&ndash;&gt; genetic variant, which indicates that there is evidence that the two genetic variants are not independent, but we do not have enough information to determine which genetic variant is the regulator and which is the target.
</p>
<p><b>Case-2</b>: If y and z are adjacent and, x and z are conditionally independent given y, then gene y will regulate the expression of gene z and the edge direction will be y &ndash;&gt; z.
</p>
<p><b>Case-3</b>: If y and z are adjacent and, x and z are conditionally dependent given y, then gene z will regulate the expression of gene y and the edge direction will be z &ndash;&gt; y.
</p>
<p><b>Case-4</b>: If y and z are adjacent and x and y are conditionally dependent given z and x and z are conditionally dependent given y, then the edge direction will be y &lt;&ndash;&gt; z.
</p>


<h3>Value</h3>

<p>An object that contains an estimate of the equivalence class of the underlying DAG.
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>A <a href="base.html#topic+call">call</a> object: the original function call.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The sample 
size used to estimate the graph.</p>
</dd>
<dt><code>max.ord</code>:</dt><dd><p>The 
maximum size of the conditioning set used 
in the conditional independence tests of   
the first part of the algorithm.</p>
</dd>
<dt><code>n.edgetests</code>:</dt><dd><p>The number of 
conditional independence tests performed by
the first part of the algorithm.</p>
</dd>
<dt><code>sepset</code>:</dt><dd><p>Separation sets.</p>
</dd>
<dt><code>pMax</code>:</dt><dd><p>A square matrix
, where the (i, j)th entry contains the 
maximal p-value of all conditional
independence tests for edge i&ndash;j.</p>
</dd>
<dt><code>graph</code>:</dt><dd><p>An object of class <code>"graph"</code>:
The undirected or partially directed graph that was estimated.</p>
</dd>
<dt><code>zMin</code>:</dt><dd><p>Deprecated.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>The number of tests that have been performed.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The level of significance 
for the current test.</p>
</dd>
<dt><code>R</code>:</dt><dd><p>All of the decisions made from tests that have been performed. A 1 indicates a rejected null hypothesis and 0 represents a null hypothesis that was not rejected.</p>
</dd>
<dt><code>K</code>:</dt><dd><p>The total number of rejections.</p>
</dd>
<dt><code>pval</code>:</dt><dd><p>A vector of p-values calculated for each test.</p>
</dd>
<dt><code>normalizer</code>:</dt><dd><p>The value that ensures the vector gammai sums to one.</p>
</dd>
<dt><code>exponent</code>:</dt><dd><p>The exponent of the p-series used to calculate each value of the gammai vector.</p>
</dd>
<dt><code>alphai</code>:</dt><dd><p>A vector containing the alpha value calculated for each test.</p>
</dd>
<dt><code>kappai</code>:</dt><dd><p>A vector containing the iteration at which each rejected test occurs.</p>
</dd>
<dt><code>kappai_star</code>:</dt><dd><p>Each element of this vector is the sum of the Si vector up to the iteration at which each rejection occurs.</p>
</dd>
<dt><code>Ci</code>:</dt><dd><p>A vector indicating whether or not a p-value is a candidate for being rejected.</p>
</dd>
<dt><code>Si</code>:</dt><dd><p>A vector indicating whether or not a p-value was discarded.</p>
</dd>
<dt><code>Ci_plus</code>:</dt><dd><p>Each element of this vector represents the number of times each kappai value was counted when calculating each alphai value.</p>
</dd>
<dt><code>gammai</code>:</dt><dd><p>The elements of this vector are the values of the p-series 0.4374901658/(m^(1.6)), where m is the iteration at which each test is performed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R Package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Javanmard A and Montanari A (2015). On Online Control of False Discovery Rate. arXiv:150206197 [statME].
</p>
<p>4. Tian J and Ramdas A (2019). ADDIS: an adaptive discarding algorithm for online FDR control with conservative nulls. In Advances in Neural Information Processing Systems (pp. 9388-9396).
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a>; <a href="#topic+ModiSkeleton">ModiSkeleton</a>; <a href="#topic+SimulateData">SimulateData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model 1 (mediation)
Truth &lt;- MRPCtruth$M1   # Truth for model 1

# The 1st column of the data matrix is a genetic variant
# and the remaining columns are gene expression nodes.
data &lt;- simu_data_M1 # load data for model 1
n &lt;- nrow (data)        # Number of row
V &lt;- colnames(data)     # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer a graph skeleton
Skel.fit &lt;- ModiSkeleton(data, 
                         suffStat = suffStat_C, 
                         FDR = 0.05, 
                         indepTest = 'gaussCItest',
                         labels = V,
                         FDRcontrol = 'LOND', 
                         verbose = FALSE)

# Edge Orientation
Edge_orientation &lt;- EdgeOrientation(Skel.fit, 
                                    suffStat = suffStat_C, 
                                    GV = 1,
                                    FDR = 0.05,
                                    indepTest = 'gaussCItest', 
                                    FDRcontrol = 'LOND',
                                    verbose = FALSE)
# Plot the results
par(mfrow = c(1, 2))
plot(Truth,
     main = "(A) Truth")
plot(Edge_orientation,
     main = "(B) MRPC ")

# Other models are available and may be called as follows:
# Model 0
# Truth &lt;- MRPCtruth$M0
# data &lt;- simu.data_M0

# Model 2
# Truth &lt;- MRPCtruth$M2
# data &lt;- simu_data_M2

# Model 3
# Truth &lt;- MRPCtruth$M3
# data &lt;- simu_data_M3

# Model 4
# Truth &lt;- MRPCtruth$M4
# data &lt;- simu_data_M4

# Model Multiparent
# Truth &lt;- MRPCtruth$Multiparent
# data &lt;- simu_data_multiparent

# Model Star
# Truth &lt;- MRPCtruth$Star
# data &lt;- simu_data_starshaped

# Model Layered
# Truth &lt;- MRPCtruth$Layered
# data &lt;- simu_data_layered


## End(Not run)
</code></pre>

<hr>
<h2 id='empty'>
Check empty matrix
</h2><span id='topic+empty'></span>

<h3>Description</h3>

<p>Need for check empty matrix.
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>

<hr>
<h2 id='IdentifyAssociatedPCs'>
Identifyprincipal components (PCs) that are significantly associated with eQTLs and genes
</h2><span id='topic+IdentifyAssociatedPCs'></span>

<h3>Description</h3>

<p>This function identifies PCs that are significantly associated the eQTLs or genes, and merge the associated PCs with the data on the eQTL and genes.  PCs may be derived from Principal Component Analysis (PCA) of the entire gene expression matrix, and may be viewed as potential confounders in the sequent causal network analysis on the eQTLs and genes.  See details in Badsha and Fu (2019) and Badsha et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdentifyAssociatedPCs(PCs.matrix,no.PCs,data,fdr.level,corr.threshold,corr.value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdentifyAssociatedPCs_+3A_pcs.matrix">PCs.matrix</code></td>
<td>
<p>A matrix of PCs.</p>
</td></tr>
<tr><td><code id="IdentifyAssociatedPCs_+3A_no.pcs">no.PCs</code></td>
<td>
<p>Number of top PCs to test for association. The default is 10.</p>
</td></tr>
<tr><td><code id="IdentifyAssociatedPCs_+3A_data">data</code></td>
<td>
<p>Data of the eQTLs and genes, containing the genotypes of the eQTLs and the expression of the genes.</p>
</td></tr>
<tr><td><code id="IdentifyAssociatedPCs_+3A_fdr.level">fdr.level</code></td>
<td>
<p>(optional) The false discover rate (FDR) for association tests. Must be in (0,1]. The default is &quot;0.05&quot;.</p>
</td></tr>
<tr><td><code id="IdentifyAssociatedPCs_+3A_corr.threshold">corr.threshold</code></td>
<td>
<p>(optional). The default is &quot;FALSE&quot;. If &quot;TRUE&quot; then a constraint on the correlation between a PC and an eQTL or a gene is applied in addition to the FDR control.</p>
</td></tr>
<tr><td><code id="IdentifyAssociatedPCs_+3A_corr.value">corr.value</code></td>
<td>
<p>The threshold for the Pearson correlation between a PC and an eQTL or a gene when <code>corr.threshold</code> is &quot;TRUE&quot;. The default is 0.3.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> of object that containing the following:
</p>

<ul>
<li> <p><code>AssociatedPCs</code>: All the PCs that are significantly associated with the eQTLs and genes.
</p>
</li>
<li> <p><code>data.withPC</code>: The data matrix that contains eQTLs, gene expression, and associated PCs.
</p>
</li>
<li> <p><code>corr.PCs</code>: The matrix of correlations between PCs and eQTLs/genes.
</p>
</li>
<li> <p><code>PCs.asso.list</code>: List of all associated PCs for each of the eQTLs and genes.
</p>
</li>
<li> <p><code>qobj</code>: The output from applying the qvalue function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>


<h3>See Also</h3>

<p><a href="#topic+data_GEUVADIS_combined">data_GEUVADIS_combined</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Load genomewide gene expression data in GEUVADIS 
# 373 individuals
# 23722 genes
data_githubURL &lt;- "https://github.com/audreyqyfu/mrpc_data/raw/master/data_GEUVADIS_allgenes.RData"
load(url(data_githubURL))
PCs &lt;- prcomp(data_GEUVADIS_allgenes,scale=TRUE)
# Extract the PCs matrix 
PCs.matrix &lt;- PCs$x

# The eQTL-gene set contains eQTL rs7124238 and genes SBF1-AS1 and SWAP70

data_GEU_Q50 &lt;- data_GEUVADIS$Data_Q50$Data_EUR
colnames(data_GEU_Q50) &lt;- c("rs7124238","SBF2-AS1","SWAP70")
data &lt;- data_GEU_Q50

# Identify associated PCs for this eQTL-gene set

Output &lt;- IdentifyAssociatedPCs(PCs.matrix,no.PCs=10,data,fdr.level=0.05,corr.threshold=TRUE
,corr.value = 0.3)

# Gene SBF2-AS1 is significantly associated with PC2 
# Data with PC2 as a potential confounder

data_withPC &lt;- Output$data.withPC

n &lt;- nrow(data_withPC)         # Number of rows
V &lt;- colnames(data_withPC)     # Column names

# Calculate Pearson correlation for MRPC analysis

suffStat &lt;- list(C = cor(data_withPC,use = "complete.obs"),
                 n = n)

# Infer the graph by MRPC 

MRPC.fit_FDR&lt;- MRPC(data_withPC,
                    suffStat,
                    GV = 1,
                    FDR = 0.05,
                    indepTest = 'gaussCItest',
                    labels = V,
                    FDRcontrol = 'LOND',
                    verbose = TRUE)
                    
plot(MRPC.fit_FDR, main="MRPC with PCs (potential confounders)")


## End(Not run)
</code></pre>

<hr>
<h2 id='ModiSkeleton'>
Infer a graph skeleton (undirected graph)
</h2><span id='topic+ModiSkeleton'></span>

<h3>Description</h3>

<p>This function implements the MRPC algorithm in Badsha and Fu (2019) and Badsha et al. (2021) to infers a graph skeleton (i.e., an undirected graph). It is based on the function skeleton from the <code>pcalg</code> package (Kalisch et al., 2012). Both functions perform marginal and conditional indpenendence tests. However, <code>ModiSkeleton</code> implements an online false discovery rate (FDR) control method in order to control the overall FDR, whereas skeleton controls only the type I error rate for each individual test. See details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModiSkeleton(data, suffStat, FDR, alpha, indepTest, labels, p,
             method = c("stable", "original", "stable.fast"),
             m.max = Inf, fixedGaps = NULL, fixedEdges = NULL,
             NAdelete = TRUE, FDRcontrol = c("LOND", "ADDIS", "NONE"),
             tau, lambda, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<p>Many arguments are similar to those in skeleton and <a href="S4Vectors.html#topic+pc">pc</a> in the <code>pcalg</code> package. Several arguments here are also arguments for the function <a href="#topic+MRPC">MRPC</a>.
</p>
<table>
<tr><td><code id="ModiSkeleton_+3A_data">data</code></td>
<td>

<p>Data matrix, where the rows are samples and the columns are features (e.g., genetic variants (GVs) and phenotypes). Columns are for GVs, if available, appear before other columns for phenotypes (e.g., gene expression). For example, if there is one GV, then the first column of the data matrix is the GV and the remaining columns are the gene expression data.
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics. When the data is continuous or can be viewed as continuous, this list contains the correlation matrix of the data and the sample size, which are the necessary elements for the conditional independence tests in gaussCItest. When the data is discrete, this list contains the entire dataset.  
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_fdr">FDR</code></td>
<td>

<p>Desired overall FDR level.
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual tests.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_indeptest">indepTest</code></td>
<td>
<p>Name of the statistical test. It is used to test the independence of x and y given S, where x and y are variables and S is a vector, possibly empty, of variables. The return value of indepTest is the p-value of the test for conditional independence.  Different tests may used for different data types. For example, <code>indepTest='gaussCItest'</code> for Gaussian data, <code>indepTest='disCItest'</code> for discrete data, and <code>indepTest='binCItest'</code> for binary data. See additional details in help(gaussCItest).
</p>
<p>ci.test in the <code>bnlearn</code> package (Marco Scutari, 2010) may also be used for testing conditional independence and return a p-value. The default test statistic is the mutual information for categorical variables, the Jonckheere-Terpstra test for ordered factors and the linear correlation for continuous variables. See help(ci.test).
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_labels">labels</code></td>
<td>
<p>A character vector of names of variables (nodes). These are typically the column names of the data matrix.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_p">p</code></td>
<td>
<p>(optional) The number of variables (nodes). Need to be specified if the labels are not provided, in which case the labels are set to 1:p.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_method">method</code></td>
<td>

<p>(optional) Character string specifying method. The default, &quot;stable&quot; provides an order-independent skeleton.
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_m.max">m.max</code></td>
<td>

<p>(optional) Maximum size of the conditioning sets that are considered in the conditional independence tests.
</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>(optional) A logical matrix of dimension p*p. If entry [x, y], [y, x], or both are TRUE, the edge x&mdash;y is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_fixededges">fixedEdges</code></td>
<td>
<p> (optional) A logical matrix of dimension p*p. If entry [x, y], [y, x], or both are TRUE, the edge x&mdash;y is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_nadelete">NAdelete</code></td>
<td>
<p>(optional) If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_fdrcontrol">FDRcontrol</code></td>
<td>
<p>A character string specifying whether online FDR control should be applied, and if so, what method to use. The two FDR control options are &quot;LOND&quot; (Javanmard and Montanari, 2015) or &quot;ADDIS&quot; (Tian and Ramdas, 2019). If &quot;NONE&quot; is specified, the type I error rate &quot;alpha&quot; will be used for each test.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_tau">tau</code></td>
<td>
<p>A number between 0 and 1. This value is used to determine if a p-value will be considered for testing. For example, if a p-value is greater than tau then it is discarded and no test will be performed.</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_lambda">lambda</code></td>
<td>
<p>A number between 0 and tau. This value is used to determine if a p-value is a candidate for rejection. For example, if a p-value is smaller than lambda then it can be rejected when testing the hypothesis (if the p-value is smaller than alphai).</p>
</td></tr>
<tr><td><code id="ModiSkeleton_+3A_verbose">verbose</code></td>
<td>

<p>(optional) If TRUE, detailed output is provided. Default is FALSE for no output details
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+ModiSkeleton">ModiSkeleton</a> function incorporates sequential hypothesis testing to infer the graph skeleton. This function starts with a complete graph (all nodes are connected with undirected edges) and performs a series of marginal and conditional independence tests, removing the corresponding edge if the test is not rejected.
</p>
<p><b>First</b>, all pairs of nodes are tested for marginal independence. If two nodes x and y are judged to be marginally independent at a type I error rate alpha, the edge between them is deleted and the empty set is saved as separation sets S[x, y] and S[y, x]. After all pairs have been tested for marginal independence, some edges may be removed.
</p>
<p><b>Second</b>, nodes (x, y) with an edge are tested for conditional independence given all subsets of the neighboring nodes. If there is any node z such that x and y are conditionally independent given z, the edge between x and y is removed and node z is saved as separation set, sepset, S[x, y] and S[y, x]. The algorithm continues in this way by increasing the size of the conditioning set step by step. The algorithm stops if all adjacency sets in the current graph are smaller than the size of the conditioning set. The result is the skeleton in which every edge is still undirected.
</p>
<p>Unlike existing algorithms, which control only the type I error rate for each individual test, MRPC implements the LOND (Level On the Number of Discoveries) method (Javanmard and Montanari, 2015), which is a sequential hypothesis testing procedure and sets value of alpha for each test based on the number of discoveries (i.e., rejections), to control the overall false discovery rate.
</p>


<h3>Value</h3>

<p>An object containing an estimate of the skeleton of the underlying DAG as follow:
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>A <a href="base.html#topic+call">call</a> object: the original function call.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The sample 
size used to estimate the graph.</p>
</dd>
<dt><code>max.ord</code>:</dt><dd><p>The 
maximum size of the conditioning set used 
in the conditional independence tests of   
the first part of the algorithm.</p>
</dd>
<dt><code>n.edgetests</code>:</dt><dd><p>The number of 
conditional independence tests performed by
the first part of the algorithm.</p>
</dd>
<dt><code>sepset</code>:</dt><dd><p>Separation sets.</p>
</dd>
<dt><code>pMax</code>:</dt><dd><p>A square matrix
, where the (i, j)th entry contains the 
maximum p-value of all conditional
independence tests for edge i&ndash;j.</p>
</dd>
<dt><code>graph</code>:</dt><dd><p>Object of class <code>"graph"</code>:
The undirected or partially directed graph that was estimated.</p>
</dd>
<dt><code>zMin</code>:</dt><dd><p>Deprecated.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>The number of tests that have been performed.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The level of significance 
for the current test.</p>
</dd>
<dt><code>R</code>:</dt><dd><p>All of the decisions made from tests that have been performed. A 1 indicates a rejected null hypothesis and 0 represents a null hypothesis that was not rejected.</p>
</dd>
<dt><code>K</code>:</dt><dd><p>The total number of rejections.</p>
</dd>
<dt><code>pval</code>:</dt><dd><p>A vector of p-values calculated for each test.</p>
</dd>
<dt><code>normalizer</code>:</dt><dd><p>The value that ensures the vector gammai sums to one.</p>
</dd>
<dt><code>exponent</code>:</dt><dd><p>The exponent of the p-series used to calculate each value of the gammai vector.</p>
</dd>
<dt><code>alphai</code>:</dt><dd><p>A vector containing the alpha value calculated for each test.</p>
</dd>
<dt><code>kappai</code>:</dt><dd><p>A vector containing the iteration at which each rejected test occurs.</p>
</dd>
<dt><code>kappai_star</code>:</dt><dd><p>Each element of this vector is the sum of the Si vector up to the iteration at which each rejection occurs.</p>
</dd>
<dt><code>Ci</code>:</dt><dd><p>A vector indicating whether or not a p-value is a candidate for being rejected.</p>
</dd>
<dt><code>Si</code>:</dt><dd><p>A vector indicating whether or not a p-value was discarded.</p>
</dd>
<dt><code>Ci_plus</code>:</dt><dd><p>Each element of this vector represents the number of times each kappai value was counted when calculating each alphai value.</p>
</dd>
<dt><code>gammai</code>:</dt><dd><p>The elements of this vector are the values of the p-series 0.4374901658/(m^(1.6)), where m is the iteration at which each test is performed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Javanmard A and Montanari A (2015). On Online Control of False Discovery Rate. arXiv:150206197 [statME].
</p>
<p>4. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>5. Tian J and Ramdas A (2019). ADDIS: an adaptive discarding algorithm for online FDR control with conservative nulls. In Advances in Neural Information Processing Systems (pp. 9388-9396).
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a>; <a href="#topic+EdgeOrientation">EdgeOrientation</a>; <a href="#topic+SimulateData">SimulateData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Model 1 (mediation)

# The 1st column of the data matrix is a genetic variant
# and the remaining columns are gene expression nodes.
data &lt;- simu_data_M1 # load data for model 1
n &lt;- nrow(data)      # Number of row
V &lt;- colnames(data)  # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer a graph skeleton
Skel.fit &lt;- ModiSkeleton(data, 
                         suffStat = suffStat_C,
                         FDR = 0.05, 
                         indepTest = 'gaussCItest',
                         labels = V, 
                         FDRcontrol = 'LOND', 
                         verbose = FALSE)

# Plot the results

plot(Skel.fit@graph,
     main ="Estimated Skeleton")

# Other models are available and may be called as follows:
# Model 0
# data &lt;- simu_data_M0

# Model 2
# data &lt;- simu_data_M2

# Model 3
# data &lt;- simu_data_M3

# Model 4
# data &lt;- simu_data_M4

# Model Multiparent
# data &lt;- simu_data_multiparent

# Model Star
# data &lt;- simu_data_starshaped

# Model Layered
# data &lt;- simu_data_layered


## End(Not run)
</code></pre>

<hr>
<h2 id='mpinv'>
Calculate the inverse matrix
</h2><span id='topic+mpinv'></span>

<h3>Description</h3>

<p>This function calculates the inverse of the non-square matrix as part of the calculation of the robust correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpinv(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpinv_+3A_x">X</code></td>
<td>

<p>Data Matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Inversematrix &lt;- mpinv(simu_data_M0)
</code></pre>

<hr>
<h2 id='MRPC'>
Infer a causal network using the MRPC algorithm
</h2><span id='topic+MRPC'></span>

<h3>Description</h3>

<p>This function is used to infer a causal network (or a causal graph) with directed and undirected edges from observational data. It implements the MRPC (PC with the principle of Mendelian randomization) algorithm described in Badsha and Fu (2019) and Badsha et al.(2021), and the implementation is based on the <a href="S4Vectors.html#topic+pc">pc</a> algorithm in the <code>pcalg</code> package. The MRPC algorithm contains four major updates over the <a href="S4Vectors.html#topic+pc">pc</a> algorithm: (i) incorporating a sequential testing method to control the False Discovery Rate (FDR), (ii) improved v-structure identification; (iii) allowing for calculation of robust correlation to reduce the impact of outliers, and (iv) a new procedure for edge orientation based on the principle of Mendelian randomization (PMR) (Badsha and Fu, 2019; Badsha et al., 2021). See details below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRPC(data, suffStat, GV, FDR = 0.05, alpha = 0.05, indepTest, labels, p,
    FDRcontrol = c("LOND", "ADDIS", "NONE"), tau = 0.5, lambda = 0.25,
    verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<p>This function is based on the <a href="S4Vectors.html#topic+pc">pc</a> function in the <code>pcalg</code> package. Therefore, many arguments are similar to those in <a href="S4Vectors.html#topic+pc">pc</a>.
</p>
<table>
<tr><td><code id="MRPC_+3A_data">data</code></td>
<td>

<p>Data matrix, where the rows are observations and the columns are features (i.e., variables, or nodes). If genetic variants (GVs) are included, then the columns start from GVs (e.g., single-nucleotide polymorphisms, or SNPs; insertions and deletions, or indels; copy number variation, or CNVs; and expression quantitative trait loci, or eQTLs to genes), and followed by phenotypes (e.g., gene expression). For example, if the data contains one GV, then the first column of the input matrix is the GV and the remaining columns are the gene expression data.
</p>
</td></tr>
<tr><td><code id="MRPC_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics. When the data is continuous or can be viewed as continuous, this list contains the correlation matrix of the data and the sample size, which are the necessary elements for the conditional independence tests in gaussCItest. When the data is discrete, this list contains the entire dataset.
</p>
</td></tr> 
<tr><td><code id="MRPC_+3A_gv">GV</code></td>
<td>
<p>The number of genetic variants (SNPs/indels/CNV/eQTLs) in the input data matrix. For example, if the data has one variant, which is in the first column, then GV = 1. If there are two variants, which are in the first and second Columns, then GV = 2. If there are no variants, then GV = 0.
</p>
</td></tr>
<tr><td><code id="MRPC_+3A_fdr">FDR</code></td>
<td>
<p>Need to specify the desired level of the overall false discovery rate. 
</p>
</td></tr>
<tr><td><code id="MRPC_+3A_alpha">alpha</code></td>
<td>
<p>A scalar in [0,1]. The type I error rate for each individual test.</p>
</td></tr>
<tr><td><code id="MRPC_+3A_indeptest">indepTest</code></td>
<td>
<p>A <a href="base.html#topic+function">function</a> for testing conditional independence. It is used to test the conditional independence of x and y given S, called as indepTest(x, y, S, suffStat). Where, x and y are variables, and S is a vector, possibly empty, of variables. suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence. The different indepTest is used for different data types, for example, Gaussian data = gaussCItest, Discrete data = disCItest and Binary data = binCItest. See help(gaussCItest)
</p>
<p>The ci.test (Marco Scutari, 2010) is also used for testing conditional independence and return value of indepTest is the p-value. If none is specified, the default test statistic is the mutual information for categorical variables, the Jonckheere-Terpstra test for ordered factors and the linear correlation for continuous variables.See help(ci.test)
</p>
<p>Remember that need to specify the which indepTest would like for independence testing. For example, if you would like to use gaussCItest you would type indepTest = 'gaussCItest' into the function otherwise indepTest = 'citest'. Note that, we used gaussCItest to compare our <a href="#topic+MRPC">MRPC</a> with the existing <a href="S4Vectors.html#topic+pc">pc</a>, because of ci.test is not robust. See details in example.
</p>
</td></tr>
<tr><td><code id="MRPC_+3A_labels">labels</code></td>
<td>
<p>A character vector of variable, or node, names. All variables are denoted in column in the input matrix.</p>
</td></tr>
<tr><td><code id="MRPC_+3A_p">p</code></td>
<td>
<p>(optional) The number of variables, or nodes. May be specified if the labels are not provided, in which case the labels are set to 1:p.</p>
</td></tr>
<tr><td><code id="MRPC_+3A_fdrcontrol">FDRcontrol</code></td>
<td>
<p>A character string specifying whether online FDR control should be applied, and if so, what method to use. The two FDR control options are &quot;LOND&quot; (Javanmard and Montanari, 2015) or &quot;ADDIS&quot; (Tian and Ramdas, 2019). If &quot;NONE&quot; is specified, the type I error rate &quot;alpha&quot; will be used for each test.</p>
</td></tr>
<tr><td><code id="MRPC_+3A_tau">tau</code></td>
<td>
<p>(optional) A scalar between 0 and 1. This value is used to determine if a p-value will be considered for testing, when FDRcontrol=&quot;ADDIS&quot;. For example, if a p-value is greater than tau then it is discarded and no test will be performed.</p>
</td></tr>
<tr><td><code id="MRPC_+3A_lambda">lambda</code></td>
<td>
<p>(optional) A scalar between 0 and tau. This value is used to determine if a p-value is a candidate for rejection, when FDRcontrol=&quot;ADDIS&quot;. For example, if a p-value is smaller than lambda then it can be rejected when testing the hypothesis (if the p-value is smaller than alphai).</p>
</td></tr>
<tr><td><code id="MRPC_+3A_verbose">verbose</code></td>
<td>
<p>(optional) If TRUE, detailed output is provided. The default is FALSE which does not print output details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PC algorithm is computationally efficient for learning a directed acyclic graph (Spirtes et al., 2000).  Several variants of the original PC algorithms are available (Kalisch and Buhlmann, 2007; Kalisch et al., 2012). Similar to these PC-like algorithms, our MRPC algorithm also contains two main steps:
</p>
<p><b>Step-1</b>: Inference of the graph skeleton.  A graph skeleton is an undirected graph with edges that are supported by the data.  Similar to existing PC-like algorithms, we perform statistical tests for marginal and conditional independence tests.  If the null hypothesis of independence is not rejected, then the corresponding edge is removed and never tested again.  
</p>
<p>However, unlike existing algorithms, which control only the type I error rate for each individual test, MRPC implements the LOND (Level On the Number of Discoveries) method (Javanmard and Montanari, 2015), which is a sequential hypothesis testing procedure and sets the significance level for each test based on the number of discoveries (i.e., rejections), to control the overall false discovery rate (FDR).  See <a href="#topic+ModiSkeleton">ModiSkeleton</a>.
</p>
<p>Genome data may have outliers that drastically alter the topology of the inferred graph. MRPC allows for the estimate of robust correlation, which may be the substitute of the Pearson correlation as the input to graph inference (Badsha et al., 2013).    
</p>
<p><b>Step-2</b>: Edge orientation.  With the graph skeleton inferred from Step 1, we orient each edge that is present in the graph.  MRPC is fundamentally different from algorithms in the <code>pcalg</code> (Kalisch and Buhlmann, 2007; Kalisch et al., 2012) and <code>bnlearn</code> (Scutari, 2010) packages in the following ways (see <a href="#topic+EdgeOrientation">EdgeOrientation</a>):
</p>
<p>(i) When analyzing genomic data, genetic variants provide additional information that helps distinguish the casual direction between two genes.  Our MRPC algorithm incorporates the principle of Mendelian randomization in graph inference, which greatly reduces the space of possible graphs and increases the inference efficiency.
</p>
<p>(ii) Next or if the input is not genomic data, we search for possible triplets 
that may form a v-structure (e.g.,X&ndash;&gt;Y&lt;&ndash;Z). We check conditional test results
from step I to see whether X and Z are independent given Y. If they are, then 
this is not a v-structure; alternative models for the triplet may be any of the 
following three Markov equivalent graphs: X&ndash;&gt;Y&ndash;&gt;Z, X&lt;&ndash;Y&lt;&ndash;Z, and 
X&lt;&ndash;Y&ndash;&gt;Z. If this test is not performed in the first step, we conduct it in 
this step. This step improves the accuracy of the v-structure identification over
existing methods. 
</p>
<p>(iii) If there are undirected edges after steps (i) and (ii), we examine iteratively triplets of nodes with at least one directed edge and no more than one undirected edge. We check the marginal and conditional test results from Step I to determine which of the basic models is consistent with the test results. It is plausible that some undirected edges cannot be oriented, and we leave them as undirected.
</p>


<h3>Value</h3>

<p>An object of <a href="base.html#topic+class">class</a> that contains an estimate of the equivalence class of the underlying DAG.
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>a <a href="base.html#topic+call">call</a> object: the original function call.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The sample 
size used to estimate the graph.</p>
</dd>
<dt><code>max.ord</code>:</dt><dd><p>The 
maximum size of the conditioning set used 
in the conditional independence tests in   
the first part of the algorithm.</p>
</dd>
<dt><code>n.edgetests</code>:</dt><dd><p>The number of 
conditional independence tests performed by
the first part of the algorithm.</p>
</dd>
<dt><code>sepset</code>:</dt><dd><p>Separation sets.</p>
</dd>
<dt><code>pMax</code>:</dt><dd><p>A numeric square matrix
, where the (i, j)th entry contains the 
maximal p-value of all conditional
independence tests for edge i&ndash;j.</p>
</dd>
<dt><code>graph</code>:</dt><dd><p>Object of class <code>"graph"</code>:
the undirected or partially directed graph that was estimated.</p>
</dd>
<dt><code>zMin</code>:</dt><dd><p>Deprecated.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>The number of tests that have been performed.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The level of significance 
for the current test.</p>
</dd>
<dt><code>R</code>:</dt><dd><p>All of the decisions made from tests that have been performed. A 1 indicates a rejected null hypothesis and 0 represents a null hypothesis that was not rejected.</p>
</dd>
<dt><code>K</code>:</dt><dd><p>The total number of rejections.</p>
</dd>
<dt><code>pval</code>:</dt><dd><p>A vector of p-values calculated for each test.</p>
</dd>
<dt><code>normalizer</code>:</dt><dd><p>The value that ensures the vector gammai sums to one.</p>
</dd>
<dt><code>exponent</code>:</dt><dd><p>The exponent of the p-series used to calculate each value of the gammai vector.</p>
</dd>
<dt><code>alphai</code>:</dt><dd><p>A vector containing the alpha value calculated for each test.</p>
</dd>
<dt><code>kappai</code>:</dt><dd><p>A vector containing the iteration at which each rejected test occurs.</p>
</dd>
<dt><code>kappai_star</code>:</dt><dd><p>Each element of this vector is the sum of the Si vector up to the iteration at which each rejection occurs.</p>
</dd>
<dt><code>Ci</code>:</dt><dd><p>A vector indicating whether or not a p-value is a candidate for being rejected.</p>
</dd>
<dt><code>Si</code>:</dt><dd><p>A vector indicating whether or not a p-value was discarded.</p>
</dd>
<dt><code>Ci_plus</code>:</dt><dd><p>Each element of this vector represents the number of times each kappai value was counted when calculating each alphai value.</p>
</dd>
<dt><code>gammai</code>:</dt><dd><p>The elements of this vector are the values of the p-series 0.4374901658/(m^(1.6)), where m is the iteration at which each test is performed.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>
<p>3. Badsha MB, Mollah MN, Jahan N and Kurata H (2013). Robust complementary hierarchical clustering for gene expression data analysis by beta-divergence. J Biosci Bioeng, 116(3): 397-407.
</p>
<p>4. Javanmard A and Montanari A (2015). On Online Control of False Discovery Rate. arXiv:150206197 [statME].
</p>
<p>5. Kalisch M and Buhlmann P (2007). Estimating High-Dimensional Directed Acyclic Graphs with the PC-Algorithm, Journal of Machine Learning Research, 8, 613-636.
</p>
<p>6. Kalisch M, Machler M, Colombo D, Maathuis MH and Buhlmann P (2012). Causal Inference Using Graphical Models with the R Package pcalg. Journal of Statistical Software, 47, 26.
</p>
<p>7. Scutari M (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>
<p>8. Spirtes P, Glymour C and Scheines R (2000). Causation, Prediction, and Search, 2nd edition. The MIT Press.
</p>
<p>9. Tian J and Ramdas A (2019). ADDIS: an adaptive discarding algorithm for online FDR control with conservative nulls. In Advances in Neural Information Processing Systems (pp. 9388-9396).
</p>


<h3>See Also</h3>

<p><a href="#topic+ModiSkeleton">ModiSkeleton</a> for inferring a graph skeleton (i.e., an undirected graph); <a href="#topic+EdgeOrientation">EdgeOrientation</a> for edge orientation in the inferred graph skeleton; <a href="#topic+SimulateData">SimulateData</a> for generating data under a topology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Load packages

# Compare six methods on simulated data:
# MRPC, 
# pc in pcalg (Kalisch et al., 2012), 
# and pc.stable, mmpc mmhc and hc in bnlearn (Scutari, 2010)

library(MRPC)     # MRPC
library(pcalg)    # pc
library(bnlearn)  # pc.stable, mmpc, mmhc and hc

####################################--&gt;    
# Load simulated data
# Model 1 (mediation)
Truth &lt;- MRPCtruth$M1   # Truth for model 1

# The 1st column of the data matrix is a genetic variant
# and the remaining columns are gene expression nodes.
data &lt;- simu_data_M1    # load data for model 1
n &lt;- nrow (data)        # Number of rows
V &lt;- colnames(data)     # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
# using the LOND method for FDR control
MRPC.fit &lt;- MRPC(data,
                suffStat = suffStat_C,
                GV = 1,
                FDR = 0.05,
                indepTest = 'gaussCItest',
                labels = V,
                FDRcontrol = 'LOND',
                verbose = FALSE)

# Infer the graph by pc
pc.fit &lt;- pc(suffStat = suffStat_C,
             indepTest = gaussCItest,
             alpha = 0.05,
             labels = V,
             verbose = FALSE)

# arcs (from gene expression to genotype) to be excluded 
# in pc.stable and mmpc 
bl &lt;- data.frame (from = colnames (data)[-1], 
                  to = 'V1')

# Infer the graph by pc.stable
pc.stable.fit &lt;- pc.stable(data.frame(data),
                           blacklist = bl,
                           undirected = FALSE) 

# Infer the graph by mmpc
mmpc.fit &lt;- mmpc(data.frame(data),
                 blacklist = bl,
                 undirected = FALSE,
                 debug = FALSE) 

# Infer the graph by mmhc
mmhc.fit &lt;- mmhc(data.frame(data),
                 blacklist = bl,
                 debug = FALSE)

# Infer the graph by hc
hc.fit &lt;- hc (data.frame (data), 
                          blacklist = bl, 
                          debug = FALSE)

# Plot the inferred graphs
par(mfrow = c(1, 7))
plot(Truth,
     main = "(A) Truth")
plot(MRPC.fit,
     main = "(B) MRPC")
plot(pc.fit,
    main ="(C) pc")
graphviz.plot(pc.stable.fit,
    main = "(D) pc.stable")
graphviz.plot(mmpc.fit,
    main = "(E) mmpc")
graphviz.plot(mmhc.fit,
    main = "(F) mmhc")
graphviz.plot(hc.fit,
    main = "(G) hc")
####################################&lt;--    


####################################--&gt;    
# Use alpha, instead of FDR control
# in MRPC

# Model 1
Truth &lt;- MRPCtruth$M1   # Truth for model 1
data &lt;- simu_data_M1    # load data for model 1
n &lt;- nrow (data)        # Number of rows
V &lt;- colnames(data)     # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
# using the LOND method for FDR control
MRPC.fit &lt;- MRPC(data,
                suffStat = suffStat_C,
                GV = 1,
                alpha = 0.01,
                indepTest = 'gaussCItest',
                labels = V,
                FDRcontrol = 'NONE',
                verbose = FALSE)
                
# The inferred adjacency matrix
as(MRPC.fit@graph, "matrix")
####################################&lt;--    


####################################--&gt;    
# Run MRPC on the complex data set with ADDIS as the FDR control method.
data &lt;- data_examples$complex$cont$withGV$data
n &lt;- nrow (data)        # Number of rows
V &lt;- colnames(data)     # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data),
                   n = n)

# Infer the graph by MRPC
MRPC.addis &lt;- MRPC(data,
                   suffStat = suffStat_C,
                   GV = 14,
                   FDR = 0.05,
                   indepTest = 'gaussCItest',
                   labels = V,
                   FDRcontrol = 'ADDIS',
                   tau = 0.5,
                   lambda = 0.25,
                   verbose = FALSE)
                   
# Plot the true and inferred graphs.
par(mfrow = c(1, 2))
plot(data_examples$complex$cont$withGV$graph,
     main = 'True graph')
plot(MRPC.addis,
     main = 'Inferred graph')
    
# Other graph visualizations 
# Adjacency matrix from directed graph
Adj_directed &lt;- as(MRPC.addis@graph,
                   "matrix")

# Plot of dendrogram with modules of different colors
PlotDendrogramObj &lt;- PlotDendrogram(Adj_directed,
                                    minModuleSize = 5)
                  
# Visualization of inferred graph with module colors
PlotGraphWithModulesObj &lt;- PlotGraphWithModules(Adj_directed,
                                                PlotDendrogramObj,
                                                GV = 14,
                                                node.size = 8,
                                                arrow.size = 5,
                                                label.size = 3,
                                                alpha = 1) 

plot(PlotGraphWithModulesObj)
####################################&lt;--    


####################################--&gt;    
# Other models are available and may be called as follows:
# Model 0
# Truth &lt;- MRPCtruth$M0
# data &lt;- simu_data_M0

# Model 2
# Truth &lt;- MRPCtruth$M2
# data &lt;- simu_data_M2

# Model 3
# Truth &lt;- MRPCtruth$M3
# data &lt;- simu_data_M3

# Model 4
# Truth &lt;- MRPCtruth$M4
# data &lt;- simu_data_M4

# Model Multiparent
# Truth &lt;- MRPCtruth$Multiparent
# data &lt;- simu_data_multiparent

# Model Star
# Truth &lt;- MRPCtruth$Star
# data &lt;- simu_data_starshaped

# Model Layered
# Truth &lt;- MRPCtruth$Layered
# data &lt;- simu_data_layered
####################################&lt;--    


####################################--&gt;    
# Discrete data with genetic variants
data &lt;- data_examples$simple$disc$withGV$data

n &lt;- nrow (data)    # Sample size
V &lt;- colnames (data) # Node labels

# need different suffStat for discrete data
suffStat &lt;- list (dm = data, adaptDF = FALSE, n.min = 1000) 

# Infer the graph by MRPC
data.mrpc.disc.withGV &lt;- MRPC (data, 
                               suffStat = suffStat, 
                               GV = 1, 
                               FDR = 0.05, 
                               indepTest = 'disCItest', 
                               labels = V, 
                               FDRcontrol = 'LOND', 
                               verbose = FALSE)


# Discrete data without genetic variants
data &lt;- data_examples$simple$disc$withoutGV$data

n &lt;- nrow (data)    # Sample size
V &lt;- colnames (data) # Node labels

suffStat &lt;- list (dm = data, adaptDF = FALSE)

# Infer the graph by MRPC
data.mrpc.disc.withoutGV &lt;- MRPC (data, 
                                  suffStat = suffStat, 
                                  GV = 0, 
                                  FDR = 0.05, 
                                  indepTest = 'disCItest', 
                                  labels = V, 
                                  FDRcontrol = 'LOND', 
                                  verbose = FALSE)

# Plots of true and inferred graphs on discrete data
par (mfrow = c (2,2))
plot (data_examples$simple$disc$withGV$graph, main = "truth")
plot (data.mrpc.disc.withGV, main = "inferred")
plot (data_examples$simple$disc$withoutGV$graph, main = "truth")
plot (data.mrpc.disc.withoutGV, main = "inferred")
####################################&lt;--    


## End(Not run)
    </code></pre>

<hr>
<h2 id='MRPCclass-class'>Class of MRPC algorithm results</h2><span id='topic+MRPCclass-class'></span><span id='topic+plot+2CMRPCclass+2CANY-method'></span><span id='topic+show+2CMRPCclass-method'></span><span id='topic+summary+2CMRPCclass-method'></span><span id='topic+print.MRPCclass'></span>

<h3>Description</h3>

<p>This class of objects is returned by the functions
<code><a href="#topic+ModiSkeleton">ModiSkeleton</a></code> and <code><a href="#topic+MRPC">MRPC</a></code> to represent the (ModiSkeleton) of an estimated DAG similarly from <code>pcAlgo-class</code>. Objects of this class have methods for the functions plot, show and
summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'MRPCclass,ANY'
plot(x, y, main = NULL,
     zvalue.lwd = FALSE, lwd.max = 7, labels = NULL, ...)
## S3 method for class 'MRPCclass'
print(x, amat = FALSE, zero.print = ".", ...)

## S4 method for signature 'MRPCclass'
summary(object, amat = TRUE, zero.print = ".", ...)
## S4 method for signature 'MRPCclass'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRPCclass-class_+3A_x">x</code>, <code id="MRPCclass-class_+3A_object">object</code></td>
<td>
<p>a <code>"MRPCclass"</code> object.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_y">y</code></td>
<td>
<p>(generic <code>plot()</code> argument; unused).</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_main">main</code></td>
<td>
<p>main title for the plot (with an automatic default).</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_zvalue.lwd">zvalue.lwd</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the line width
(<code>lwd</code>) of the edges should be made proportional to the entries
of matrix <code>zMin</code> (originally) or derived from matrix <code>pMax</code>.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_lwd.max">lwd.max</code></td>
<td>
<p>maximal <code>lwd</code> to be used, if <code>zvalue.lwd</code> is true.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_labels">labels</code></td>
<td>
<p>if non-<code>NULL</code>, these are used to define node attributes
<code>nodeAttrs</code> and <code>attrs</code>, passed to <code><a href="Rgraphviz.html#topic+agopen">agopen</a>()</code>
from package <span class="pkg">Rgraphviz</span>.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_amat">amat</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the adjacency matrix
should be printed as well.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_zero.print">zero.print</code></td>
<td>
<p>String for printing <code>0</code> (&lsquo;zero&rsquo;) entries
in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="MRPCclass-class_+3A_...">...</code></td>
<td>
<p>(optional) Further arguments passed from and to methods.</p>
</td></tr>
</table>


<h3>Creation of objects</h3>

<p>Objects are typically created as result from
<code>skeleton()</code> or <code><a href="S4Vectors.html#topic+pc">pc</a>()</code>, but could be
be created by calls of the form <code>new("MRPCclass", ...)</code>.
</p>


<h3>Slots</h3>

<p>The slots <code>call</code>, <code>n</code>, <code>max.ord</code>, <code>n.edgetests</code>,
<code>sepset</code>, <code>pMax</code>, <code>graph</code>, <code>zMin</code>, <code>test</code>, <code>alpha</code> and <code>R</code> are inherited class.
</p>
<p>In addition, <code>"MRPCclass"</code> has slots
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>a <a href="base.html#topic+call">call</a> object: the original function call.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The sample 
size used to estimate the graph.</p>
</dd>
<dt><code>max.ord</code>:</dt><dd><p>The 
maximum size of the conditioning set used 
in the conditional independence tests of   
the first part of the algorithm.</p>
</dd>
<dt><code>n.edgetests</code>:</dt><dd><p>The number of 
conditional independence tests performed by
the first part of the algorithm.</p>
</dd>
<dt><code>sepset</code>:</dt><dd><p>Separation sets.</p>
</dd>
<dt><code>pMax</code>:</dt><dd><p>A square matrix
, where the (i, j)th entry contains the 
maximum p-value of all conditional
independence tests for edge i&ndash;j.</p>
</dd>
<dt><code>graph</code>:</dt><dd><p>Object of class <code>"graph"</code>:
The undirected or partially directed graph that was estimated.</p>
</dd>
<dt><code>zMin</code>:</dt><dd><p>Deprecated.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>The number of tests that have been performed.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>The level of significance 
for the current test.</p>
</dd>
<dt><code>R</code>:</dt><dd><p>All of the decisions made from tests that have been performed. A 1 indicates a rejected null hypothesis and 0 represents a null hypothesis that was not rejected.</p>
</dd>
<dt><code>K</code>:</dt><dd><p>The total number of rejections.</p>
</dd>
<dt><code>pval</code>:</dt><dd><p>A vector of p-values calculated for each test.</p>
</dd>
<dt><code>normalizer</code>:</dt><dd><p>The value that ensures the gammai vector sums to one.</p>
</dd>
<dt><code>exponent</code>:</dt><dd><p>The exponent of the p-series used to calculate each value of the gammai vector.</p>
</dd>
<dt><code>alphai</code>:</dt><dd><p>A vector containing the alpha value calculated for each test.</p>
</dd>
<dt><code>kappai</code>:</dt><dd><p>A vector containing the iteration at which each rejected test occurs.</p>
</dd>
<dt><code>kappai_star</code>:</dt><dd><p>Each element of this vector is the sum of the Si vector up to the iteration at which each rejection occurs.</p>
</dd>
<dt><code>Ci</code>:</dt><dd><p>A vector indicating whether or not a p-value is a candidate for being rejected.</p>
</dd>
<dt><code>Si</code>:</dt><dd><p>A vector indicating whether or not a p-value was discarded.</p>
</dd>
<dt><code>Ci_plus</code>:</dt><dd><p>Each element of this vector represents the number of times each kappai value was counted when calculating each alphai value.</p>
</dd>
<dt><code>gammai</code>:</dt><dd><p>The elements of this vector are the values of the p-series 0.4374901658/(m^(1.6)), where m is the iteration at which each test is performed.</p>
</dd>
<dt><code>gammai_sum</code>:</dt><dd><p>The sum of the gammai vector. This value is used in calculating the alphai value at each iteration.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "MRPCclass")</code>: Plot the resulting
graph. If argument <code>"zvalue.lwd"</code> is true, the
linewidth an edge reflects <code>zMin</code>, so that
thicker lines indicate more reliable dependencies. The argument
<code>"lwd.max"</code> controls the maximum linewidth.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MRPCclass")</code>: Show basic properties of
the fitted object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "MRPCclass")</code>: Show details of
the fitted object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a>, <a href="#topic+ModiSkeleton">ModiSkeleton</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showClass("MRPCclass")

# Generate a MRPCclass object
data &lt;- simu_data_M1 # load data for model 1
n &lt;- nrow(data)      # Number of rows
V &lt;- colnames(data)  # Column names

# Calculate Pearson correlation
suffStat_C &lt;- list(C = cor(data), 
                   n = n)

# Infer the graph by MRPC
MRPC.fit &lt;- MRPC(data, 
                 suffStat_C, 
                 GV = 1,
                 FDR = 0.05, 
                 indepTest ='gaussCItest',
                 labels = V, 
                 FDRcontrol = 'LOND',
                 verbose = FALSE)


# Use methods of class MRPCclass
show(MRPC.fit)

plot(MRPC.fit)
summary(MRPC.fit)

# Access slots of this object
(g  &lt;- MRPC.fit@graph)
str(ss &lt;- MRPC.fit@sepset, max = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='MRPCtruth'>
Graphs used as truth in simulation
</h2><span id='topic+MRPCtruth'></span>

<h3>Description</h3>

<p>Topologies of the five basic models and three common graphs in biology: namely the multi-parent graph, the star graph and the layered graph. See details in Badsha and Fu (2019).
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("MRPCtruth") # load data

# Plots
par(mfrow = c(2, 4))
plot(MRPCtruth$M0,
     main = "Model0")
plot(MRPCtruth$M1,
     main = "Model1")
plot(MRPCtruth$M2,
     main = "Model2")
plot(MRPCtruth$M3,
     main = "Model3")
plot(MRPCtruth$M4,
     main = "Model4")
plot(MRPCtruth$Multiparent,
     main = "Multiparent")
plot(MRPCtruth$Star,
     main = "Star")
plot(MRPCtruth$Layered,
     main = "Layered")
     

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotDendrogram'>
Plot a dendrogram and display node groups in colored modules
</h2><span id='topic+PlotDendrogram'></span>

<h3>Description</h3>

<p>Generate a dendrogram of nodes with dissimilarity based on topological overlap, and group nodes into modules indicated by colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDendrogram(Adj_directed, minModuleSize, groupLabels = " ", 
               dendroLabels = FALSE, hclustHang = 0.03, 
               dendroAddGuide = FALSE, dendroGuideHang = 0.05, 
               dendroMain = "Dendrogram with modules of nodes in colors", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDendrogram_+3A_adj_directed">Adj_directed</code></td>
<td>

<p>Adjacency matrix from directed graph
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_minmodulesize">minModuleSize</code></td>
<td>

<p>Minimum module size.
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_grouplabels">groupLabels</code></td>
<td>

<p>Argument for plotDendroAndColors. Labels for the colorings given in colors. The labels will be printed to the left of the color rows in the plot. 
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_dendrolabels">dendroLabels</code></td>
<td>

<p>Argument for plotDendroAndColors. Dendrogram labels. 
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_hclusthang">hclustHang</code></td>
<td>

<p>Argument <code>hang</code> for <a href="stats.html#topic+plot.hclust">plot.hclust</a>. The fraction of the plot height by which labels should hang below the rest of the plot. 
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_dendroaddguide">dendroAddGuide</code></td>
<td>

<p>Argument <code>addGuide</code> for plotDendroAndColors. Logical: should vertical &quot;guide lines&quot; be added to the dendrogram plot? The lines make it easier to identify color codes with individual samples. 
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_dendroguidehang">dendroGuideHang</code></td>
<td>

<p>Argument <code>guideHang</code> for plotDendroAndColors. The fraction of the dendrogram height to leave between the top end of the guide line and the dendrogram merge height.  
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_dendromain">dendroMain</code></td>
<td>

<p>Argument <code>main</code> for <a href="stats.html#topic+plot.hclust">plot.hclust</a>. Title of the plot.  
</p>
</td></tr>
<tr><td><code id="PlotDendrogram_+3A_...">...</code></td>
<td>

<p>Additional plotting arguments for plotDendroAndColors and <a href="stats.html#topic+plot.hclust">plot.hclust</a>.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the graph objects as follows:
</p>

<ul>
<li> <p><code>PlotDendrogramObj</code>: An object of class &quot;graph&quot; of the estimated graph.
</p>
</li>
<li> <p><code>dynamicColors</code>: A list of colors with corresponding nodes.
</p>
</li>
<li> <p><code>GroupMods</code>: Dynamic tree cut to identify modules whose phenotype profiles are very similar.
</p>
</li>
<li> <p><code>GroupModsColors</code>: A table for number of nodes with corresponding colors.
</p>
</li>
<li> <p><code>Adj_symmetric_matrix</code>: A symmetric matrix from ddjacency matrix of directed graph.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812. 
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Adjacency matrix from directed example graph
Adj_directed &lt;- as(data_examples$complex$cont$withGV$graph,
                   "matrix")

# Plot of dendrogram with modules colors of nodes
PlotDendrogramObj &lt;- PlotDendrogram(Adj_directed,
                                    minModuleSize = 5)
                                    

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotGraphWithModules'>
Plot a graph with nodes in modules indicated by colors 
</h2><span id='topic+PlotGraphWithModules'></span>

<h3>Description</h3>

<p>Visualization of a graph with nodes in modules inferred from the clustering dendrogram by <a href="#topic+PlotDendrogram">PlotDendrogram</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGraphWithModules(Adj_directed, PlotDendrogramObj, 
                     GV, node.size = 8, arrow.size = 5,
                     label.size = 3,alpha = 1,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGraphWithModules_+3A_adj_directed">Adj_directed</code></td>
<td>

<p>Adjacency matrix of a graph.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_plotdendrogramobj">PlotDendrogramObj</code></td>
<td>

<p>The graphical objects from <a href="#topic+PlotDendrogram">PlotDendrogram</a>.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_gv">GV</code></td>
<td>

<p>The number of genetic variants (SNPs/indels/CNVs/eQTL) in the input data matrix. For example, if the data has one SNPs/indels/CNV/eQTL in the first column, then GV = 1, if 2 SNPs/indels/CNVs/eQTL in the 1st and 2nd Column, then GV = 2, and so on. If no GV then GV = 0.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_node.size">node.size</code></td>
<td>

<p>The size of the nodes in the graph. Defaults to 8.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_arrow.size">arrow.size</code></td>
<td>

<p>The size of the arrows for directed network edges, in points. Defaults to 5.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_label.size">label.size</code></td>
<td>

<p>The size of the node labels in points, as a numeric value, a vector of numeric values, or as a vertex attribute containing numeric values. Defaults to 3.
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_alpha">alpha</code></td>
<td>

<p>The level of transparency of the edges and nodes. Defaults to 1 (no transparency).
</p>
</td></tr>
<tr><td><code id="PlotGraphWithModules_+3A_...">...</code></td>
<td>

<p>Other arguments passed to ggnet2.
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>PlotGraphWithModulesObj</code>: An object of class &quot;graph&quot; of the graph.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812. 
</p>


<h3>See Also</h3>

<p><a href="#topic+PlotDendrogram">PlotDendrogram</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Adjacency matrix from a graph in the example
Adj_directed &lt;- as(data_examples$complex$cont$withGV$graph,
                   "matrix")

# A clustering dendrogram with nodes grouped in colored modules
PlotDendrogramObj &lt;- PlotDendrogram(Adj_directed,
                                    minModuleSize = 5)
                  
# A graph object with nodes in modules
PlotGraphWithModulesObj &lt;- PlotGraphWithModules(Adj_directed,
                                                PlotDendrogramObj,
                                                GV = 14,
                                                node.size = 8,
                                                arrow.size = 5,
                                                label.size = 3,
                                                alpha = 1) 

# Plot the graph with nodes in different colors
plot(PlotGraphWithModulesObj) 

## End(Not run)
</code></pre>

<hr>
<h2 id='RecallPrecision'>
Calculate recall and precision for two graphs
</h2><span id='topic+RecallPrecision'></span>

<h3>Description</h3>

<p>This function counts the number of true and false positives, and calculates recall (i.e., power) and precision (i.e., 1-FDR), which are defined as follows:
</p>
<p>Recall = (# edges correctly identified in inferred graph) / (# edges in true graph). 
</p>
<p>Precision = (# edges correctly identified in inferred graph) / (# edges in inferred graph).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RecallPrecision(g1, g2, GV, includeGV, edge.presence = 1.0, edge.direction = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RecallPrecision_+3A_g1">g1</code></td>
<td>

<p>First graph object, from the true graph
</p>
</td></tr>
<tr><td><code id="RecallPrecision_+3A_g2">g2</code></td>
<td>

<p>Second graph object, from the inferred graph
</p>
</td></tr>
<tr><td><code id="RecallPrecision_+3A_gv">GV</code></td>
<td>

<p>The number of genetic variants (SNPs/indels/CNV/eQTLs) in the input data matrix. For example, if the data has one variant, which is in the first column, then GV = 1. If there are two variants, which are in the first and second Columns, then GV = 2. If there are no variants, then GV = 0.
</p>
</td></tr>
<tr><td><code id="RecallPrecision_+3A_includegv">includeGV</code></td>
<td>

<p>If TRUE, include edges involving genetic variants (GV) when calculating recall and precision. If FALSE, exclude edges involving genetic variants (GV) when calculating recall and precision.
</p>
</td></tr>
<tr><td><code id="RecallPrecision_+3A_edge.presence">edge.presence</code></td>
<td>

<p>The weight for an edge being present.
</p>
</td></tr>
<tr><td><code id="RecallPrecision_+3A_edge.direction">edge.direction</code></td>
<td>

<p>The weight for the edge direction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider it more important to be able to identify the presence of an edge than to also get the direct correct. Therefore, we assign 1 as the default to an edge with the correct direction and 0.5 to an edge with the wrong direction or no direction (Badsha and Fu, 2019; Badsha et al., 2021).
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> of object that containing the following:
</p>

<ul>
<li> <p><code>Matrix</code>: Results store for TP and FP
</p>
</li>
<li> <p><code>TP</code>: Total found edges in the inferred graph and edge exists in the true graph.
</p>
</li>
<li> <p><code>FP</code>: Total found edges in the inferred graph but no edge exists in the true graph.
</p>
</li>
<li> <p><code>NTE</code>: Total number of edges in the true graph.
</p>
</li>
<li> <p><code>NIE</code>: Total number of edges in the inferred graph.
</p>
</li>
<li> <p><code>Recall</code>: Power, or sensitivity measures how many edges from the true graph a method can recover.
</p>
</li>
<li> <p><code>Precision</code>: Measures how many correct edges are recovered in the inferred graph.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812.
</p>


<h3>See Also</h3>

<p><a href="#topic+aSHD">aSHD</a>: adjusted Structural Hamming Distance (aSHD)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# True model
# True graph (V1 --&gt; T1 --&gt; T2 --&gt; T3) 
# Where V1 is a genetic variant (GV) and T1, T2, and T3 are phenotypes
tarmat_s1 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s1) &lt;- c("V1", "T1", "T2", "T3")
rownames(tarmat_s1) &lt;- colnames(tarmat_s1)

# Create an adjacency matrix for the true graph
tarmat_s1[1, 2] &lt;- 1
tarmat_s1[2, 3] &lt;- 1
tarmat_s1[3, 4] &lt;- 1

# Graph object of the true graph
Truth &lt;- as(tarmat_s1,
            "graphNEL")

# Inferred graph (V1 --&gt; T1 &lt;-- T2 --&gt; T3)
# Where V1 is a genetic variant (GV) and T1, T2, and T3 are phenotypes
tarmat_s2 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s2) &lt;- c("V1", "T1", "T2", "T3")
rownames(tarmat_s2) &lt;- colnames(tarmat_s2)

# Create an adjacency matrix for the inferred graph
tarmat_s2[1, 2] &lt;- 1
tarmat_s2[3, 2] &lt;- 1
tarmat_s2[3, 4] &lt;- 1

# Graph objects for the inferred graph
Inferred &lt;- as(tarmat_s2,
               "graphNEL")
         
# Recall and Precision
Recall_Precision &lt;- RecallPrecision(Truth,
                                   Inferred,
                                   GV = 1,
                                   includeGV = TRUE,
                                   edge.presence = 1.0,
                                   edge.direction = 0.5)
</code></pre>

<hr>
<h2 id='RobustCor'>
Calculate robust correlation matrix
</h2><span id='topic+RobustCor'></span>

<h3>Description</h3>

<p>Calculate robust correlation matrix based on beta value. The value of beta plays a key role in the performance of the robust method, which controls the tradeoff between the robustness and efficiency of the estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RobustCor(xx, Beta, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RobustCor_+3A_xx">xx</code></td>
<td>

<p>Data matrix
</p>
</td></tr>
<tr><td><code id="RobustCor_+3A_beta">Beta</code></td>
<td>

<p>Tuning parameter, between 0 and 1, if 0 then equal to nonrobust, classical method. We suggest using, Beta = 0.005 in both without and with outliers in simulation study. This value should reflect the amount of outliers in the data. Whereas a large value increases robustness, it reduces sensitivity of identifying an edge. We need a more principled way to determine this value.
</p>
</td></tr>
<tr><td><code id="RobustCor_+3A_plot">plot</code></td>
<td>

<p>To set no plotting as the default for weight vs gene index.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We take a robust approach and calculate the robust correlation matrix (Badsha et al., 2013) on which the series of hypothesis testing is performed. The performance of the robust correlation method depends on the values of the tuning parameter beta. It controls the tradeoff between robustness and efficiency of estimators. This method shows high performance for a wide range of beta. The values of beta lies between 0 and 1, such that a large value of beta decreases the efficiency, while it increases the robustness of an estimator, and vice-versa for a small value of beta. Thus, we need to select an optimal beta to obtain both high robustness and efficiency, while it depends on the initialization of model parameters, data contamination rates, types of data contamination, types of datasets, and so on. We used the beta value from Badsha et al., 2013. The robust method reduces to the classical method (Biased estimator) with the tuning parameter beta &ndash;&gt;0. When the data matrix contains missing values, we perform imputation using the R package mice (Buuren and Groothuis-Oudshoorn, 2011).
</p>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> of objects as follows:
</p>

<ul>
<li> <p><code>RR</code>: Robust correlation matrix.
</p>
</li>
<li> <p><code>M</code>: Robust mean vector.
</p>
</li>
<li> <p><code>V</code>: Robust covariance matrix.
</p>
</li>
<li> <p><code>Wt</code>: Weight for each observation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB, Mollah MN, Jahan N and Kurata H (2013). Robust complementary hierarchical clustering for gene expression data analysis by beta-divergence. J Biosci Bioeng, 116(3): 397-407.
</p>
<p>2. Van Buuren S and Groothuis-Oudshoorn K (2011). mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software, 45(3), 1-67. http://www.jstatsoft.org/v45/i03/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
RobustCor_objects &lt;- RobustCor(simu_data_M0,
                               Beta = 0.005,
                               plot = FALSE)
               
Rcorr &lt;- RobustCor_objects $RR  # Correlation matrix

## End(Not run)
</code></pre>

<hr>
<h2 id='seqDiff'>
Deviation between two graphs represented by two sequences
</h2><span id='topic+seqDiff'></span>

<h3>Description</h3>

<p>This function evaluates whether two graphs are identical. Each graph is represented first by a binary vector, which is the vectorized adjacency matrix, and then converted to a decimal number. The difference in the decimal numberes is the deviation between the two graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqDiff(g1, g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqDiff_+3A_g1">g1</code></td>
<td>

<p>Adjacency matrix from the first graph object.
</p>
</td></tr>
<tr><td><code id="seqDiff_+3A_g2">g2</code></td>
<td>

<p>Adjacency matrix from the second graph object.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# True model
# True graph (V1 --&gt; T1 --&gt; T2 --&gt; T3)
tarmat_s1 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s1) &lt;- c("V1", "T1", "T2", "T3")
rownames(tarmat_s1) &lt;- colnames(tarmat_s1)

# Create an adjacency matrix for the true graph
tarmat_s1[1, 2] &lt;- 1
tarmat_s1[2, 3] &lt;- 1
tarmat_s1[3, 4] &lt;- 1

# Inferred graph (V1 --&gt; T1 &lt;-- T2 --&gt; T3)
tarmat_s2 &lt;- matrix(0,
                    nrow = 4,
                    ncol = 4)
                    
colnames(tarmat_s2) &lt;-c ("V1", "T1", "T2", "T3")
rownames(tarmat_s2) &lt;- colnames(tarmat_s2)

# Create an adjacency matrix for the inferred graph
tarmat_s2[1, 2] &lt;- 1
tarmat_s2[3, 2] &lt;- 1
tarmat_s2[3, 4] &lt;- 1

# Deviation of the inferred graph from the true graph.
Results &lt;- seqDiff(tarmat_s2,
                   tarmat_s1)
         
</code></pre>

<hr>
<h2 id='SeqFDR'>
Sequential FDR
</h2><span id='topic+SeqFDR'></span>

<h3>Description</h3>

<p>Sequential FDR method that controls the FDR and mFDR in an online manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqFDR(m, FDR, a=2, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeqFDR_+3A_m">m</code></td>
<td>

<p>The number of current the test.
</p>
</td></tr>
<tr><td><code id="SeqFDR_+3A_fdr">FDR</code></td>
<td>

<p>FDR level.
</p>
</td></tr>
<tr><td><code id="SeqFDR_+3A_a">a</code></td>
<td>

<p>A constant.
</p>
</td></tr>
<tr><td><code id="SeqFDR_+3A_r">R</code></td>
<td>

<p>All of the decisions from the tests that have already been performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We used the LOND (significance Levels based On Number of Discoveries) algorithm that controls FDR in an online manner (Javanmard and Montanari, 2015). The significance level (i.e., the type I error rate) is dynamic and based on the total number of discoveries made so far. 
</p>


<h3>Value</h3>

<p>The value of alpha.
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Javanmard A and Montanari A (2015). On Online Control of False Discovery Rate. arXiv:150206197.
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a> for estimating a DAG using the Mendelian Randomization (MR) based (MRPC) algorithm; <a href="#topic+ModiSkeleton">ModiSkeleton</a> for estimating a skeleton using modified skeleton function.
</p>

<hr>
<h2 id='simu_data_layered'>
Data for the layered model
</h2><span id='topic+simu_data_layered'></span>

<h3>Description</h3>

<p>Data simulated under the layered Model.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_M0'>
Data for Model 0
</h2><span id='topic+simu_data_M0'></span>

<h3>Description</h3>

<p>Data simulated under Model 0.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_M1'>
Data for Model 1
</h2><span id='topic+simu_data_M1'></span>

<h3>Description</h3>

<p>Data simulated under Model 1.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_M2'>
Data for Model 2
</h2><span id='topic+simu_data_M2'></span>

<h3>Description</h3>

<p>Data simulated under Model 2.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_M3'>
Data for Model 3
</h2><span id='topic+simu_data_M3'></span>

<h3>Description</h3>

<p>Data simulated under Model 3.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_M4'>
Data for Model 4
</h2><span id='topic+simu_data_M4'></span>

<h3>Description</h3>

<p>Data simulated under Model 4.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_multiparent'>
Data for the multiple-parent model
</h2><span id='topic+simu_data_multiparent'></span>

<h3>Description</h3>

<p>Data simulated under the multiple-parent model, where a phenotype node has multiple parent nodes.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='simu_data_starshaped+20'>
Data for the star model
</h2><span id='topic+simu_data_starshaped'></span>

<h3>Description</h3>

<p>Data simulated under the star model, where one gene has more than two children.
</p>


<h3>Details</h3>

<p>The columns of the data matrix are the genetic variant (V node) and phenotype nodes (T nodes).
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a>.
</p>

<hr>
<h2 id='SimulateData'>
Simulate data under certain graphs
</h2><span id='topic+SimulateData'></span>

<h3>Description</h3>

<p>This function simulates data using linear models for several graphs: the five basic topologies and three topologies that are common in biology, namely the multi-parent graph, the star graph and the layered graph. See details in Badsha and Fu (2019) and Badsha et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateData(N, p, model, b0.1, b1.1, b1.2, b1.3, sd.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData_+3A_n">N</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_p">p</code></td>
<td>
<p>Population frequency of the reference allele. Real number between 0 to 1, which is the number of a particular allele is present.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_model">model</code></td>
<td>
<p>The model for which data will be simulated. For example, if you want to generate data for model 0 you would type 'model0' into the function.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_b0.1">b0.1</code></td>
<td>
<p>Intercept of b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_b1.1">b1.1</code></td>
<td>
<p>Slope of P1 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_b1.2">b1.2</code></td>
<td>
<p>Slope of P2 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_b1.3">b1.3</code></td>
<td>
<p>Slope of P3 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData_+3A_sd.1">sd.1</code></td>
<td>
<p>Standard deviation for corresponding data generated nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first column of the input matrix is a genetic variant and the remaining columns are gene expression nodes.
</p>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>References</h3>

<p>1. Badsha MB and Fu AQ (2019). Learning causal biological networks with the principle of Mendelian randomization. Frontiers in Genetics, 10:460.
</p>
<p>2. Badsha MB, Martin EA and Fu AQ (2021). MRPC: An R package for inference of causal graphs. Frontiers in Genetics, 10:651812. 
</p>


<h3>See Also</h3>

<p><a href="#topic+MRPC">MRPC</a>; <a href="#topic+SimulateDataNP">SimulateDataNP</a>, which simulates data for a node with no parent; <a href="#topic+SimulateData1P">SimulateData1P</a> for a node with one parent; <a href="#topic+SimulateData2P">SimulateData2P</a> for a node with two parents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When there is one genetic variant, the 1st column of
# the simulated data matrix will be the variant and the remaining
# columns are the gene expression nodes.


## Model 0
simu_data_M0 &lt;- SimulateData(N = 10^3, 
                             p = 0.45,
                             'model0', 
                             b0.1 = 0,
                             b1.1 = 1, 
                             b1.2 = 1,
                             b1.3 = 1, 
                             sd.1 = 1)
                             
## Model 1
simu_data_M1 &lt;- SimulateData(N = 10^3, 
                             p = 0.45,
                             'model1', 
                             b0.1 = 0,
                             b1.1 = 1, 
                             b1.2 = 1,
                             b1.3 = 1, 
                             sd.1 = 1)
                             
## Model 2
simu_data_M2 &lt;- SimulateData(N = 10^3, 
                             p = 0.45,
                             'model2', 
                             b0.1 = 0,
                             b1.1 = 1, 
                             b1.2 = 1,
                             b1.3 = 1, 
                             sd.1 = 1)
                             
## Model 3
simu_data_M3 &lt;- SimulateData(N = 10^3, 
                             p = 0.45,
                             'model3', 
                             b0.1 = 0,
                             b1.1 = 1, 
                             b1.2 = 1,
                             b1.3 = 1, 
                             sd.1 = 1)
                             
## Model 4
simu_data_M4 &lt;- SimulateData(N = 10^3, 
                             p = 0.45,
                             'model4', 
                             b0.1 = 0,
                             b1.1 = 1, 
                             b1.2 = 1,
                             b1.3 = 1, 
                             sd.1 = 1)
                             
## Multiple Parent Model
simu_data_multiparent &lt;- SimulateData(N = 10^3, 
                                      p = 0.45,
                                      'multiparent', 
                                      b0.1 = 0,
                                      b1.1 = 1, 
                                      b1.2 = 1,
                                      b1.3 = 1, 
                                      sd.1 = 1)

## Star Model
simu_data_starshaped &lt;- SimulateData(N = 10^3, 
                                     p = 0.45,
                                     'starshaped', 
                                     b0.1 = 0,
                                     b1.1 = 1, 
                                     b1.2 = 1,
                                     b1.3 = 1, 
                                     sd.1 = 1)

## Layered Model
simu_data_layered &lt;- SimulateData(N = 10^3, 
                                  p = 0.45,
                                  'layered', 
                                  b0.1 = 0,
                                  b1.1 = 1, 
                                  b1.2 = 1,
                                  b1.3 = 1, 
                                  sd.1 = 1)
</code></pre>

<hr>
<h2 id='SimulateData1P'>
Simulate data for a node with one parent
</h2><span id='topic+SimulateData1P'></span>

<h3>Description</h3>

<p>Simulate data for a node with one parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateData1P(N, P1, b0.1, b1.1, sd.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData1P_+3A_n">N</code></td>
<td>

<p>Number of observations
</p>
</td></tr>
<tr><td><code id="SimulateData1P_+3A_p1">P1</code></td>
<td>
<p>Data vector of the parent node P1.</p>
</td></tr>
<tr><td><code id="SimulateData1P_+3A_b0.1">b0.1</code></td>
<td>
<p>Intercept of b0.1 + b1.1*P1, where P1 is the parent of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData1P_+3A_b1.1">b1.1</code></td>
<td>
<p>Slope of P1 for b0.1 + b1.1*P1, where P1 is the parent of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData1P_+3A_sd.1">sd.1</code></td>
<td>
<p>Standard deviation for corresponding data generated nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a> for simulated data generating function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data1P &lt;- SimulateData1P(N = 10^3, 
                         P1 = 1, 
                         b0.1 = 0, 
                         b1.1 = 1, 
                         sd.1 = 1)
</code></pre>

<hr>
<h2 id='SimulateData2P'>
Simulate data for a node with two parents
</h2><span id='topic+SimulateData2P'></span>

<h3>Description</h3>

<p>Simulate data for a node with two parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateData2P(N, P1, P2, b0.1, b1.1, b1.2, sd.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData2P_+3A_n">N</code></td>
<td>

<p>Number of observations
</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_p1">P1</code></td>
<td>
<p>Data vector of the parent node, P1.</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_p2">P2</code></td>
<td>
<p>Data vector of the parent node, P2.</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_b0.1">b0.1</code></td>
<td>
<p>Intercept of b0.1 + b1.1*P1 + b1.2*P2, where P1 and P2 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_b1.1">b1.1</code></td>
<td>
<p>Slope of P1 for b0.1 + b1.1*P1+ b1.2*P2, where P1 and P2 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_b1.2">b1.2</code></td>
<td>
<p>Slope of P2 for b0.1 + b1.1*P1 + b1.2*P2, where P1 and P2 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData2P_+3A_sd.1">sd.1</code></td>
<td>
<p>Standard deviation for corresponding data generated nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a> for simulated data generating function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data2P &lt;- SimulateData2P(N = 10^3, 
                         P1 = 1, 
                         P2 = 1, 
                         b0.1 = 0, 
                         b1.1 = 1, 
                         b1.2 = 1, 
                         sd.1 = 1)
</code></pre>

<hr>
<h2 id='SimulateData3P'>
Simulate data for a node with three parents
</h2><span id='topic+SimulateData3P'></span>

<h3>Description</h3>

<p>Simulate data for a node with three parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SimulateData3P(N, P1, P2, P3, b0.1, b1.1, b1.2, b1.3, sd.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateData3P_+3A_n">N</code></td>
<td>

<p>Number of observations.
</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_p1">P1</code></td>
<td>
<p>Data vector of the parent node, P1.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_p2">P2</code></td>
<td>
<p>Data vector of the parent node, P2.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_p3">P3</code></td>
<td>
<p>Data vector of the parent node, P3.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_b0.1">b0.1</code></td>
<td>
<p>Intercept of b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_b1.1">b1.1</code></td>
<td>
<p>Slope of P1 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_b1.2">b1.2</code></td>
<td>
<p>Slope of P2 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_b1.3">b1.3</code></td>
<td>
<p>Slope of P3 for b0.1 + b1.1*P1 + b1.2*P2 + b1.3*P3, where P1, P2, and P3 are the parents of the corresponding node.</p>
</td></tr>
<tr><td><code id="SimulateData3P_+3A_sd.1">sd.1</code></td>
<td>
<p>Standard deviation for corresponding data generated node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a> for simulated data generating function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data3P &lt;- SimulateData3P(N = 10^3, 
                         P1 = 1, 
                         P2 = 1, 
                         P3 = 1, 
                         b0.1 = 0, 
                         b1.1 = 1, 
                         b1.2 = 1, 
                         b1.3 = 1, 
                         sd.1 = 1)
</code></pre>

<hr>
<h2 id='SimulateDataNP'>
Simulate data for a node with no parent
</h2><span id='topic+SimulateDataNP'></span>

<h3>Description</h3>

<p>Simulate data for a node with no parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateDataNP(N, b0.1, sd.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateDataNP_+3A_n">N</code></td>
<td>

<p>Number of observations
</p>
</td></tr>
<tr><td><code id="SimulateDataNP_+3A_b0.1">b0.1</code></td>
<td>
<p>Intercept of the corresponding simulated node.</p>
</td></tr>
<tr><td><code id="SimulateDataNP_+3A_sd.1">sd.1</code></td>
<td>
<p>Standard deviation for corresponding data generated node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector
</p>


<h3>Author(s)</h3>

<p>Md Bahadur Badsha (mbbadshar@gmail.com)
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateData">SimulateData</a> for simulated data generating function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DataNP &lt;- SimulateDataNP(N = 10^3, 
                       b0.1 = 0, 
                       sd.1 = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
