<!DOCTYPE html><html><head><title>Help for package ecodist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecodist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addord'>
<p>Fit new points to an existing NMDS configuration.</p></a></li>
<li><a href='#bcdist'><p> Bray-Curtis distance</p></a></li>
<li><a href='#bump'><p>Nine-bump spatial pattern</p></a></li>
<li><a href='#bump.pmgram'><p>Nine-bump spatial pattern</p></a></li>
<li><a href='#cor2m'><p> Two-matrix correlation table</p></a></li>
<li><a href='#corgen'><p> Generate correlated data</p></a></li>
<li><a href='#crosstab'><p> Data formatting</p></a></li>
<li><a href='#dim.dist'><p> Dimension of a distance object</p></a></li>
<li><a href='#distance'><p> Calculate dissimilarity/distance metrics</p></a></li>
<li><a href='#ecodist-package'>
<p>Dissimilarity-Based Functions for Ecological Analysis</p></a></li>
<li><a href='#fixdmat'><p> Distance matrix conversion</p></a></li>
<li><a href='#full'><p> Full symmetric matrix</p></a></li>
<li><a href='#graze'><p> Site information and grazed vegetation data.</p></a></li>
<li><a href='#iris.fit'><p>Example of adding to an ordination</p></a></li>
<li><a href='#iris.nmds'><p>Example for nmds</p></a></li>
<li><a href='#iris.vf'><p>Example for vector fitting on ordination</p></a></li>
<li><a href='#iris.vfrot'><p>Example for vector fitting on rotated ordination</p></a></li>
<li><a href='#lower'><p> Lower-triangular matrix</p></a></li>
<li><a href='#mantel'><p> Mantel test</p></a></li>
<li><a href='#mgram'><p> Mantel correlogram</p></a></li>
<li><a href='#mgroup'><p> Mantel test for groups</p></a></li>
<li><a href='#min.nmds'><p> Find minimum stress configuration</p></a></li>
<li><a href='#MRM'><p> Multiple Regression on distance Matrices</p></a></li>
<li><a href='#nmds'><p> Non-metric multidimensional scaling</p></a></li>
<li><a href='#pathdist'>
<p>Graph extension of dissimilarities</p></a></li>
<li><a href='#pco'><p> Principal coordinates analysis</p></a></li>
<li><a href='#plot.mgram'><p> Plot a Mantel correlogram</p></a></li>
<li><a href='#plot.nmds'><p> Plot information about NMDS ordination</p></a></li>
<li><a href='#plot.vf'><p> Plots fitted vectors onto an ordination diagram</p></a></li>
<li><a href='#pmgram'><p> Piecewise multivariate correlogram</p></a></li>
<li><a href='#relrange'>
<p>Relativize a compositional data matrix.</p></a></li>
<li><a href='#residuals.mgram'><p> Residuals of a Mantel correlogram</p></a></li>
<li><a href='#rotate2d'>
<p>Rotate a 2D ordination.</p></a></li>
<li><a href='#vf'><p> Vector fitting</p></a></li>
<li><a href='#xdistance'>
<p>Cross-distance between two datasets.</p></a></li>
<li><a href='#xmantel'><p> Cross-Mantel test</p></a></li>
<li><a href='#xmgram'><p>Cross-Mantel correlogram</p></a></li>
<li><a href='#z.no'><p>Example for pmgram</p></a></li>
<li><a href='#z.z1'><p>Example for pmgram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Dissimilarity-Based Functions for Ecological Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Sarah Goslee [aut, cre],
  Dean Urban [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sarah Goslee &lt;Sarah.Goslee@usda.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Dissimilarity-based analysis functions including ordination and Mantel test functions, intended for use with spatial and community ecological data. The original package description is in Goslee and Urban (2007) &lt;<a href="https://doi.org/10.18637%2Fjss.v022.i07">doi:10.18637/jss.v022.i07</a>&gt;, with further statistical detail in Goslee (2010) &lt;<a href="https://doi.org/10.1007%2Fs11258-009-9641-0">doi:10.1007/s11258-009-9641-0</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/phiala/ecodist/issues">https://github.com/phiala/ecodist/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 14:30:01 UTC; sarahg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addord'>
Fit new points to an existing NMDS configuration.
</h2><span id='topic+addord'></span>

<h3>Description</h3>

<p>Uses a brute force algorithm to find the location for each new point that minimizes overall stress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addord(origconf, fulldat, fulldist, isTrain, bfstep = 10, maxit = 50, epsilon = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addord_+3A_origconf">origconf</code></td>
<td>

<p>The original ordination configuration.
</p>
</td></tr>
<tr><td><code id="addord_+3A_fulldat">fulldat</code></td>
<td>

<p>The dataset containing original and new points.
</p>
</td></tr>
<tr><td><code id="addord_+3A_fulldist">fulldist</code></td>
<td>

<p>A dissimilarity matrix calculated on <code>fulldat</code>.
</p>
</td></tr>
<tr><td><code id="addord_+3A_istrain">isTrain</code></td>
<td>

<p>A boolean vector of length <code>nrow(fulldat)</code> indicating which rows were training data used in determining <code>origconf</code> (TRUE), or are new points (FALSE).
</p>
</td></tr>
<tr><td><code id="addord_+3A_bfstep">bfstep</code></td>
<td>

<p>A tuning parameter for the brute force algorithm describing the size of grid to use.
</p>
</td></tr>
<tr><td><code id="addord_+3A_maxit">maxit</code></td>
<td>

<p>The maximum number of iterations to use.
</p>
</td></tr>
<tr><td><code id="addord_+3A_epsilon">epsilon</code></td>
<td>

<p>Tolerance value for convergence.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A region comprising the original ordination configuration plus one standard deviation is divided into a grid of <code>bfstep</code> rows and columns. For a new point, the grid cell with the lowest stress is identified. That cell is divided into a finer grid, and the lowest-stress cell identified. This process is repeated up to <code>maxit</code> times, or until stress changes less than <code>epsilon</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fullfitconf</code></td>
<td>
<p>The new ordination configuration containing training and new points.</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>The stress value for each point.</p>
</td></tr>
<tr><td><code>isTrain</code></td>
<td>
<p>The boolean vector indicating training set membership, for reference.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# rotate the configuration to maximize variance
iris.rot &lt;- princomp(iris.nmin)$scores

# rotation preserves distance apart in ordination space
cor(dist(iris.nmin), dist(iris.rot))

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

# repeat for the rotated ordination
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vfrot &lt;- vf(iris.rot, iris[,1:4], nperm=1000)
### save(iris.vfrot, file="ecodist/data/iris.vfrot.rda")
data(iris.vfrot)

par(mfrow=c(1,2))
plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)
plot(iris.rot, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="Rotated NMDS")
plot(iris.vfrot)

####### addord example

# generate new data points to add to the ordination
# this might be new samples, or a second dataset

iris.new &lt;- structure(list(Sepal.Length = c(4.6, 4.9, 5.4, 5.2, 6, 6.5, 6, 
6.8, 7.3), Sepal.Width = c(3.2, 3.5, 3.6, 2.3, 2.8, 3, 2.7, 3.1, 
3.2), Petal.Length = c(1.2, 1.5, 1.5, 3.5, 4.1, 4.2, 4.8, 5, 
5.7), Petal.Width = c(0.26, 0.26, 0.26, 1.2, 1.3, 1.4, 1.8, 2, 
2), Species = structure(c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L), .Label = c("setosa", 
"versicolor", "virginica"), class = "factor")), .Names = c("Sepal.Length", 
"Sepal.Width", "Petal.Length", "Petal.Width", "Species"), class = "data.frame", row.names = c(NA, 
-9L))

# provide a dist object containing original and new data
# provide a logical vector indicating which samples were used to
# construct the original configuration

iris.full &lt;- rbind(iris, iris.new)
all.d &lt;- dist(iris.full[,1:4])
is.orig &lt;- c(rep(TRUE, nrow(iris)), rep(FALSE, nrow(iris.new)))

### addord() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.fit &lt;- addord(iris.nmin, iris.full[,1:4], all.d, is.orig, maxit=100)
### save(iris.fit, file="ecodist/data/iris.fit.rda")
data(iris.fit)

plot(iris.fit$conf, col=iris.full$Species, pch=c(18, 4)[is.orig + 1], xlab="NMDS 1", ylab="NMDS 2")
title("Demo: adding points to an ordination")
legend("bottomleft", c("Training set", "Added point"), pch=c(4, 18))
legend("topright", levels(iris$Species), fill=1:3)

</code></pre>

<hr>
<h2 id='bcdist'> Bray-Curtis distance </h2><span id='topic+bcdist'></span>

<h3>Description</h3>

<p>Returns the Bray-Curtis (also known as Sorenson, 1 - percent similarity) pairwise distances for the objects in the data. It is duplicated by functionality within <code><a href="#topic+distance">distance</a></code> but remains for backward compatibility and because it is substantially faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcdist(x, rmzero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcdist_+3A_x">x</code></td>
<td>
<p> matrix or data frame with rows as samples and columns as variables (such as 
species). Distances will be calculated for each pair of rows. </p>
</td></tr>
<tr><td><code id="bcdist_+3A_rmzero">rmzero</code></td>
<td>
<p> If rmzero=TRUE, empty rows will be removed from the data before 
distances are calculated. Otherwise, the distance between two empty rows is assumed to be 0 (the default). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a column-order lower-triangular distance matrix. The returned object has an attribute, Size, giving the number of objects, that is, nrow(x). The length of the vector that is returned is nrow(x)*(nrow(x)-1)/2. 
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+dist">dist</a></code>,  <code><a href="#topic+distance">distance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graze)
system.time(graze.bc &lt;- bcdist(graze[, -c(1:2)]))
# equivalent to but much faster than:
system.time(graze.bc2 &lt;- distance(graze[, -c(1:2)], "bray-curtis"))

all.equal(graze.bc, graze.bc2)

</code></pre>

<hr>
<h2 id='bump'>Nine-bump spatial pattern</h2><span id='topic+bump'></span>

<h3>Description</h3>

<p>A two-dimensional artificial &quot;landscape&quot; illustrating the kind of spatial pattern that might be seen across mountain peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bump)</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:25, 1:25] 2 2 2 2 2 2 2 2 2 2 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:25] &quot;1&quot; &quot;3&quot; &quot;5&quot; &quot;7&quot; ...
..$ : chr [1:25] &quot;V1&quot; &quot;V3&quot; &quot;V5&quot; &quot;V7&quot; ...
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bump.pmgram">bump.pmgram</a></code>, <code><a href="#topic+pmgram">pmgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bump)
image(bump)
</code></pre>

<hr>
<h2 id='bump.pmgram'>Nine-bump spatial pattern</h2><span id='topic+bump.pmgram'></span>

<h3>Description</h3>

<p>An object of class mgram for use in the example for <code><a href="#topic+pmgram">pmgram</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bump.pmgram)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+pmgram">pmgram</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bump">bump</a></code>, <code><a href="#topic+pmgram">pmgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bump)

par(mfrow=c(1, 2))
image(bump, col=gray(seq(0, 1, length=5)))

z &lt;- as.vector(bump)
x &lt;- rep(1:25, times=25)
y &lt;- rep(1:25, each=25)

X &lt;- col(bump)
Y &lt;- row(bump)
# calculate dissimilarities for data and space
geo.dist &lt;- dist(cbind(as.vector(X), as.vector(Y)))
value.dist &lt;- dist(as.vector(bump))

### pgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### bump.pmgram &lt;- pmgram(value.dist, geo.dist, nperm=10000)
### save(bump.pmgram, file="ecodist/data/bump.pmgram.rda")

data(bump.pmgram)
plot(bump.pmgram)

</code></pre>

<hr>
<h2 id='cor2m'> Two-matrix correlation table </h2><span id='topic+cor2m'></span>

<h3>Description</h3>

<p>Generate a correlation table between the variables of
two data sets, originally for comparing species abundances and
environmental variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2m(x, y, trim = TRUE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2m_+3A_x">x</code></td>
<td>
<p> A matrix or data frame of environmental (or other)
variables matching the sites of x </p>
</td></tr>
<tr><td><code id="cor2m_+3A_y">y</code></td>
<td>
<p> A matrix or data frame of species (or other) variables </p>
</td></tr>
<tr><td><code id="cor2m_+3A_trim">trim</code></td>
<td>
<p> If trim is TRUE, set rho&lt;critical value(alpha) to 0 </p>
</td></tr>
<tr><td><code id="cor2m_+3A_alpha">alpha</code></td>
<td>
<p> alpha p-value to use with trim, by default 0.05 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>cor2m generates a correlation table between the variables of
two matrices. The original use case is to compare species
abundances and environmental variables. It results in a data frame
with species (or the first matrix) as columns and environmental
variables (or the second matrix) as rows, so it's easy to scan.
Correlations less than a user-specified alpha (0.05 by default)
can be set to NA.  cor2m generates a correlation table between
the variables of two matrices. The original use case is to compare
species abundances and environmental variables. The result has
species (or the first matrix) as columns and environmental
variables (or the second matrix) as rows, so it's easy to scan.
Correlations less than a user-specified alpha can be set to NA.
If trim, correlations less than the critical value for the
provided alpha are set to to NA. The critical value is computed
as a t-test with n-2 df.
cor2m(x, y, trim=FALSE) is equivalent to cor(x, y)
</p>


<h3>Value</h3>

<p>Returns a data frame of correlations between the variables
of 2 data frames.
</p>


<h3>Author(s)</h3>

<p> Dean Urban </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graze)
speciesdata &lt;- graze[, 3:7]
envdata &lt;- graze[, 1:2]
sppenv.cor &lt;- cor2m(envdata, speciesdata)
print(sppenv.cor, na.print="")
</code></pre>

<hr>
<h2 id='corgen'> Generate correlated data </h2><span id='topic+corgen'></span>

<h3>Description</h3>

<p>Generate correlated data of a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  corgen(len, x, r, population = FALSE, epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corgen_+3A_len">len</code></td>
<td>
<p> Length of vectors. </p>
</td></tr>
<tr><td><code id="corgen_+3A_x">x</code></td>
<td>
<p> Independent data. If x is specified, the population
parameter is automatically set to TRUE. </p>
</td></tr>
<tr><td><code id="corgen_+3A_r">r</code></td>
<td>
<p> Desired correlation between data vectors. </p>
</td></tr>
<tr><td><code id="corgen_+3A_population">population</code></td>
<td>
<p> TRUE for vectors drawn from two populations
with correlation r, otherwise r is the sample correlation. </p>
</td></tr>
<tr><td><code id="corgen_+3A_epsilon">epsilon</code></td>
<td>
<p> Desired tolerance. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either x or len must be specified.
If epsilon = 0, it has no effect, otherwise the
sampling process is repeated until the sample correlation is
within epsilon of r. This option allows the production of
exactly-correlated data, within the limits of epsilon. Setting
epsilon &gt; 0 invalidates the population setting; data will be
correlated within that range, rather than sampled from that population.If epsilon = 0, it has no effect, otherwise the
sampling process is repeated until the sample correlation is
within epsilon of r. This option allows the production of
exactly-correlated data, within the limits of epsilon. Setting
epsilon &gt; 0 invalidates the population setting; data will be
correlated within that range, rather than sampled from that population.If epsilon = 0, it has no effect, otherwise the
sampling process is repeated until the sample correlation is
within epsilon of r. This option allows the production of
exactly-correlated data, within the limits of epsilon. Setting
epsilon &gt; 0 invalidates the population setting; data will be
correlated within that range, rather than sampled from that population.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>First data vector, either generated by corgen or given by the user. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Second data vector. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create two random variables of length 100 with correlation
# of 0.10 +/- 0.01
xy &lt;- corgen(len=100, r=.1, epsilon=0.01)
with(xy, cor(x, y))

# create two random variables of length 100 drawn from a population with
# a correlation of -0.82
xy &lt;- corgen(len=100, r=-0.82, population=TRUE)
with(xy, cor(x, y))

# create a variable y within 0.01 of the given correlation to x
x &lt;- 1:100
y &lt;- corgen(x=x, r=.5, epsilon=.01)$y
cor(x, y)
</code></pre>

<hr>
<h2 id='crosstab'> Data formatting </h2><span id='topic+crosstab'></span>

<h3>Description</h3>

<p>Converts field data of the form site, species, observation into a site
by species data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosstab(rowlab, collab, values, type = "sum", data, allrows, allcols,
na.as.0 = TRUE, check.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosstab_+3A_rowlab">rowlab</code></td>
<td>
<p> row labels, e.g. site names. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_collab">collab</code></td>
<td>
<p> column labels, e.g. species names. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_values">values</code></td>
<td>
<p> data values. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_data">data</code></td>
<td>
<p> optional data frame from which to take rowlab,
collab and/or values. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_type">type</code></td>
<td>
<p> function to use to combine data, one of &quot;sum&quot;
(default), &quot;min&quot;, &quot;max&quot;, &quot;mean&quot;, &quot;count&quot;. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_allrows">allrows</code></td>
<td>
<p> optional, list of all desired row names that
may not appear in rowlab. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_allcols">allcols</code></td>
<td>
<p> optional, list of all desired column names
that may not appear in collab. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_na.as.0">na.as.0</code></td>
<td>
<p> if TRUE, all NA values are replaced with 0. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_check.names">check.names</code></td>
<td>
<p> if FALSE, data frame names are not checked
for syntactic validity, so that they match the input categories.
Otherwise make.names() is used to adjust them. </p>
</td></tr>
<tr><td><code id="crosstab_+3A_...">...</code></td>
<td>
<p> optional arguments to the function specified in type,
such as na.rm=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Field data are often recorded as a separate row for each
site-species combination. This function reformats such data into
a data frame for further analysis based on unique row and column labels.
The three vectors should all be the same length (including duplicates).
The three vectors may also be provided as names of columns in the data
frame specified by the data argument.
</p>
<p>If allrows or allcols exists, rows and/or columns of zeros are inserted
for any elements of allrows/allcols not present in rowlab/collab.
</p>
<p>If values is missing the number of occurrences of combinations of rowlab
and collab will be returned. Thus, crosstab(rowlab, collab) is equivalent
to table(rowlab, collab).
</p>
<p>If type is &quot;count&quot;, the unique combinations of rowlab, collab and values
will be returned.
</p>


<h3>Value</h3>

<p>data frame with rowlab as row headings, collab as columns,
and values as the data.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a random example
plotnames &lt;- rep(1:5, each = 6)
speciesnames &lt;- rep(c("A", "B", "C"), 10)
freqdata &lt;- runif(30)

# number of samples of each species and plot
crosstab(plotnames, speciesnames)

# can use the data argument
speciesdata &lt;- data.frame(plots = plotnames, species = speciesnames,
  freq = freqdata, stringsAsFactors=FALSE)

# mean frequency by species and plot
crosstab(plots, species, freq, data=speciesdata, type="mean")

# can specify additional possible row or column levels
crosstab(plots, species, freq, data=speciesdata, type="mean", allcols=LETTERS[1:5])
</code></pre>

<hr>
<h2 id='dim.dist'> Dimension of a distance object </h2><span id='topic+dim.dist'></span>

<h3>Description</h3>

<p>Returns NULL for the dimensions of a distance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dist'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.dist_+3A_x">x</code></td>
<td>
<p> object of class <code>dist</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spdep package overwrites the base R behavior of dim.dist() to return c(n, n) where n is the size of the full matrix. The base R behavior returns NULL. This function restores base R behavior within ecodist, because otherwise spdep being loaded breaks ecodist functionality.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data(graze)
	dim(dist(graze))

</code></pre>

<hr>
<h2 id='distance'> Calculate dissimilarity/distance metrics </h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>This function calculates a variety of dissimilarity or distance metrics. Although it duplicates the functionality of dist() and bcdist(), it is written in such a way that new metrics can easily be added.
distance() was written for extensibility and understandability, and is not necessarily an efficient choice for use with large matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, method = "euclidean", sprange=NULL, spweight=NULL, icov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p> matrix or data frame with rows as samples and columns as variables (such as
species). Distances will be calculated for each pair of rows. </p>
</td></tr>
<tr><td><code id="distance_+3A_method">method</code></td>
<td>
<p> Currently 7 dissimilarity metrics can be calculated: &quot;euclidean&quot;, &quot;bray-curtis&quot;, &quot;manhattan&quot;, &quot;mahalanobis&quot; (squared Mahalanobis distance), &quot;jaccard&quot;, &quot;difference&quot;, &quot;sorensen&quot;, &quot;gower&quot;, &quot;modgower10&quot; (modified Gower, base 10), &quot;modgower2&quot; (modified Gower, base 2). Partial matching will work for selecting a method.</p>
</td></tr>
<tr><td><code id="distance_+3A_sprange">sprange</code></td>
<td>
<p>Gower dissimilarities offer the option of dividing by the species range. If sprange=NULL no range is used. If sprange is a vector of length nrow(x) it is used for standardizing the dissimilarities.</p>
</td></tr>
<tr><td><code id="distance_+3A_spweight">spweight</code></td>
<td>
<p>Euclidean, Manhattan, and Gower dissimilarities allow weighting. If spweight=NULL, no weighting is used. If spweight=&quot;absence&quot;, then W=0 if both species are absent and 1 otherwise, thus deleting joint absences.</p>
</td></tr>
<tr><td><code id="distance_+3A_icov">icov</code></td>
<td>
<p>Optional covariance matrix; only used if method=&quot;mahalanobis&quot; since Mahalanobis distance requires calculating the variance-covariance matrix for the entire dataset. Providing icov directly makes it possible to calculate distances for a subset of the full dataset.</p>
</td></tr>
<tr><td><code id="distance_+3A_inverted">inverted</code></td>
<td>
<p>If TRUE, the optional covariance matrix for method=&quot;mahalanobis&quot; is not inverted before solving. Providing an inverted matrix may speed up calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a lower-triangular distance matrix as an object of class &quot;dist&quot;.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+dist">dist</a></code>,  <code><a href="#topic+bcdist">bcdist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.bc &lt;- distance(iris[, 1:4], "bray-curtis")

# The effect of specifying icov:

# calculate Mahalanobis distance for the full iris dataset
iris.md &lt;- full(distance(iris[, 1:4], "mahal"))
iris.md[1, 2] # Mahalanobis distance between samples 1 and 2 

# calculate Mahalanobis for just one species
setosa.md &lt;- full(distance(iris[iris$Species == "setosa", 1:4], "mahal"))
setosa.md[1, 2] # Mahalanobis distance between samples 1 and 2 

# use the covariance matrix for the full dataset to scale for one species
setosa.scaled.md &lt;- full(distance(iris[iris$Species == "setosa", 1:4],
  "mahal", icov=var(iris[,1:4])))
setosa.scaled.md[1, 2] # Mahalanobis distance between samples 1 and 2 

</code></pre>

<hr>
<h2 id='ecodist-package'>
Dissimilarity-Based Functions for Ecological Analysis
</h2><span id='topic+ecodist-package'></span><span id='topic+ecodist'></span>

<h3>Description</h3>

<p>Dissimilarity-based analysis functions including ordination and Mantel test functions, intended for use with spatial and community data.
</p>


<h3>Details</h3>

<p>This package contains well-established dissimilarity-based ecological analyses, such as <code><a href="#topic+nmds">nmds</a></code> and <code><a href="#topic+mantel">mantel</a></code>, and experimental/research analyses such as <code><a href="#topic+xmantel">xmantel</a></code>. Helper functions such as <code><a href="#topic+crosstab">crosstab</a></code> and <code><a href="#topic+cor2m">cor2m</a></code> facilitate analysis of community data.
</p>
<p>Because many of the analyses are time-consuming, this package includes worked examples that can be loaded using <code>data()</code>.
</p>

<p>Index of help topics:
</p>
<pre>
MRM                     Multiple Regression on distance Matrices
addord                  Fit new points to an existing NMDS
                        configuration.
bcdist                  Bray-Curtis distance
bump                    Nine-bump spatial pattern
bump.pmgram             Nine-bump spatial pattern
cor2m                   Two-matrix correlation table
corgen                  Generate correlated data
crosstab                Data formatting
dim.dist                Dimension of a distance object
distance                Calculate dissimilarity/distance metrics
ecodist-package         Dissimilarity-Based Functions for Ecological
                        Analysis
fixdmat                 Distance matrix conversion
full                    Full symmetric matrix
graze                   Site information and grazed vegetation data.
iris.fit                Example of adding to an ordination
iris.nmds               Example for nmds
iris.vf                 Example for vector fitting on ordination
iris.vfrot              Example for vector fitting on rotated
                        ordination
lower                   Lower-triangular matrix
mantel                  Mantel test
mgram                   Mantel correlogram
mgroup                  Mantel test for groups
min.nmds                Find minimum stress configuration
nmds                    Non-metric multidimensional scaling
pathdist                Graph extension of dissimilarities
pco                     Principal coordinates analysis
plot.mgram              Plot a Mantel correlogram
plot.nmds               Plot information about NMDS ordination
plot.vf                 Plots fitted vectors onto an ordination diagram
pmgram                  Piecewise multivariate correlogram
relrange                Relativize a compositional data matrix.
residuals.mgram         Residuals of a Mantel correlogram
rotate2d                Rotate a 2D ordination.
vf                      Vector fitting
xdistance               Cross-distance between two datasets.
xmantel                 Cross-Mantel test
xmgram                  Cross-Mantel correlogram
z.no                    Example for pmgram
z.z1                    Example for pmgram
</pre>


<h3>Author(s)</h3>

 
<p>Sarah Goslee and Dean Urban 
</p>
<p>Maintainer: Sarah Goslee &lt;Sarah.Goslee@ars.usda.gov&gt;
</p>

<hr>
<h2 id='fixdmat'> Distance matrix conversion </h2><span id='topic+fixdmat'></span>

<h3>Description</h3>

<p>Convert a row-order lower-triangular distance matrix to a full symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fixdmat(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixdmat_+3A_v">v</code></td>
<td>
<p> lower-triangular distance matrix in row order. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>R distance functions such as dist and bcdist return a lower
triangular distance matrix in column order. Some other programs
return the lower triangular matrix in row order. To use this
matrix in R functions, it must be converted from row order
to column order.
</p>


<h3>Value</h3>

<p>full symmetric distance matrix.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lower">lower</a></code>,  <code><a href="#topic+full">full</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x.vec &lt;- seq_len(6)
x.vec

# Make an R-style column order symmetric matrix
full(x.vec)

# Extract the lower triangle from a symmetric matrix
# in column order
lower(full(x.vec))

# Convert to or from a row order symmetric matrix
fixdmat(x.vec)
lower(fixdmat(x.vec))

fixdmat(c(1, 2, 4, 3, 5, 6))
</code></pre>

<hr>
<h2 id='full'> Full symmetric matrix </h2><span id='topic+full'></span>

<h3>Description</h3>

<p>Convert a column order distance matrix to a full symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  full(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_+3A_v">v</code></td>
<td>
<p> lower-triangular column order distance matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a column order lower-triangular distance matrix as
written by R functions into a symmetric matrix.
Note that <code>lower()</code> used on a 1x1 matrix will return the single
element, which may not be the correct behavior in all cases,
while <code>full()</code> used on a single element will return a 2x2 matrix.
</p>


<h3>Value</h3>

<p>full symmetric matrix.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lower">lower</a></code>, <code><a href="#topic+fixdmat">fixdmat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Given a vector:
x.vec &lt;- seq_len(6)
x.vec

# Make an R-style column order symmetric matrix
full(x.vec)

# Extract the lower triangle from a symmetric matrix
# in column order
lower(full(x.vec))

# Convert to or from a row order symmetric matrix
fixdmat(x.vec)
lower(fixdmat(x.vec))

fixdmat(c(1, 2, 4, 3, 5, 6))
</code></pre>

<hr>
<h2 id='graze'> Site information and grazed vegetation data. </h2><span id='topic+graze'></span>

<h3>Description</h3>

<p>This data frame contains site location, landscape context and dominant plant species abundances for 25 of the plant species found in 50 grazed pastures in the northeastern United States. Elements are the mean values for canopy cover for ten 0.5 x 2 m quadrats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graze)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 25 variables.
</p>

<dl>
<dt><code>sitelocation</code></dt><dd><p>Site location along a geographic gradient.</p>
</dd>
<dt><code>forestpct</code></dt><dd><p>Percentage forest cover within a 1-km radius.</p>
</dd>
<dt><code>ACMI2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>ANOD</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>ASSY</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>BRIN2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>CIAR4</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>CIIN</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>CIVU</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>DAGL</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>ELRE4</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>GAMO</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>LOAR10</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>LOCO6</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>LOPE</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>OXST</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>PLMA2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>POPR</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>PRVU</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>RAAC3</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>RUCR</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>SORU2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>STGR</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>TAOF</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>TRPR2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>TRRE3</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
<dt><code>VEOF2</code></dt><dd><p>Percentage canopy cover.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Site locations fall along a southwest-northeast transect through the northeastern United States. This is a synthetic gradient calculated from latitude and longitude.
Forest landcover is taken from the USGS 1992 National Land Cover Dataset. All forest classes were combined, and the percentage within 1 km of the sample sites was calculated using a GIS.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>Source</h3>

<p>Details of these data are available in Tracy and Sanderson (2000) and Goslee and Sanderson (2010).
The 1992 NLCD data can be obtained from http://www.mrlc.gov/.
Species codes are from http://plants.usda.gov (2010). 
</p>


<h3>References</h3>

<p>Tracy, B.F. and M.A. Sanderson. 2000. Patterns of plant species richness in pasture lands of the northeast United States. Plant Ecology 149:169-180.
</p>
<p>Goslee, S.C., Sanderson, M.A. 2010. Landscape Context and Plant Community Composition in Grazed Agricultural Systems. Landscape Ecology 25:1029-1039.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graze)
</code></pre>

<hr>
<h2 id='iris.fit'>Example of adding to an ordination</h2><span id='topic+iris.fit'></span>

<h3>Description</h3>

<p>A fitted ordination for use in the example for <code><a href="#topic+addord">addord</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris.fit)</code></pre>


<h3>Format</h3>

<p>The format of this object is a list with:
X1, X2, etc: ordination configuration: coordinates for each point.
stress: goodness of fit for each point.
isTrain: logical vector indicating whether each point was used in the original ordination. 
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code>, <code><a href="#topic+addord">addord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# generate new data points to add to the ordination
# this might be new samples, or a second dataset

iris.new &lt;- structure(list(Sepal.Length = c(4.6, 4.9, 5.4, 5.2, 6, 6.5, 6, 
6.8, 7.3), Sepal.Width = c(3.2, 3.5, 3.6, 2.3, 2.8, 3, 2.7, 3.1, 
3.2), Petal.Length = c(1.2, 1.5, 1.5, 3.5, 4.1, 4.2, 4.8, 5, 
5.7), Petal.Width = c(0.26, 0.26, 0.26, 1.2, 1.3, 1.4, 1.8, 2, 
2), Species = structure(c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L), .Label = c("setosa", 
"versicolor", "virginica"), class = "factor")), .Names = c("Sepal.Length", 
"Sepal.Width", "Petal.Length", "Petal.Width", "Species"), class = "data.frame",
row.names = c(NA, -9L))

# provide a dist object containing original and new data
# provide a logical vector indicating which samples were used to
# construct the original configuration

iris.full &lt;- rbind(iris, iris.new)
all.d &lt;- dist(iris.full[,1:4])
is.orig &lt;- c(rep(TRUE, nrow(iris)), rep(FALSE, nrow(iris.new)))

### addord() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.fit &lt;- addord(iris.nmin, iris.full[,1:4], all.d, is.orig, maxit=100)
### save(iris.fit, file="ecodist/data/iris.fit.rda")
data(iris.fit)

plot(iris.fit$conf, col=iris.full$Species, pch=c(18, 4)[is.orig + 1],
    xlab="NMDS 1", ylab="NMDS 2")
title("Demo: adding points to an ordination")
legend("bottomleft", c("Training set", "Added point"), pch=c(4, 18))
legend("topright", levels(iris$Species), fill=1:3)

</code></pre>

<hr>
<h2 id='iris.nmds'>Example for nmds</h2><span id='topic+iris.nmds'></span>

<h3>Description</h3>

<p>An object of class nmds for use in the example for <code><a href="#topic+nmds">nmds</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris.nmds)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+nmds">nmds</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)


</code></pre>

<hr>
<h2 id='iris.vf'>Example for vector fitting on ordination</h2><span id='topic+iris.vf'></span>

<h3>Description</h3>

<p>An object of class vf for use in the examples for <code><a href="#topic+nmds">nmds</a></code> and  <code><a href="#topic+vf">vf</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris.vf)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+vf">vf</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code>,  <code><a href="#topic+vf">vf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# rotate the configuration to maximize variance
iris.rot &lt;- princomp(iris.nmin)$scores

# rotation preserves distance apart in ordination space
cor(dist(iris.nmin), dist(iris.rot))

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)

</code></pre>

<hr>
<h2 id='iris.vfrot'>Example for vector fitting on rotated ordination</h2><span id='topic+iris.vfrot'></span>

<h3>Description</h3>

<p>An object of class vf for use in the examples for <code><a href="#topic+nmds">nmds</a></code> and  <code><a href="#topic+vf">vf</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris.vfrot)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+vf">vf</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code>,  <code><a href="#topic+vf">vf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# rotate the configuration to maximize variance
iris.rot &lt;- princomp(iris.nmin)$scores

# rotation preserves distance apart in ordination space
cor(dist(iris.nmin), dist(iris.rot))

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

# repeat for the rotated ordination
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vfrot &lt;- vf(iris.rot, iris[,1:4], nperm=1000)
### save(iris.vfrot, file="ecodist/data/iris.vfrot.rda")
data(iris.vfrot)

par(mfrow=c(1,2))
plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)
plot(iris.rot, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="Rotated NMDS")
plot(iris.vfrot)

</code></pre>

<hr>
<h2 id='lower'> Lower-triangular matrix </h2><span id='topic+lower'></span>

<h3>Description</h3>

<p>Convert a symmetric distance matrix to a column order lower triangular matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lower(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower_+3A_m">m</code></td>
<td>
<p> a symmetric distance matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a symmetric matrix, for example a dissimilarity matrix,
into a column order lower-triangular matrix. This may be useful
to format the input for certain clustering and ordination functions.
Note that <code>lower()</code> used on a 1x1 matrix will return the single
element, which may not be the correct behavior in all cases,
while <code>full()</code> used on a single element will return a 2x2 matrix.
</p>


<h3>Value</h3>

<p>column order lower triangular matrix.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+full">full</a></code>, <code><a href="#topic+fixdmat">fixdmat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x.vec &lt;- seq_len(6)
x.vec

# Make an R-style column order symmetric matrix
full(x.vec)

# Extract the lower triangle from a symmetric matrix
# in column order
lower(full(x.vec))

# Convert to or from a row order symmetric matrix
fixdmat(x.vec)
lower(fixdmat(x.vec))

fixdmat(c(1, 2, 4, 3, 5, 6))
</code></pre>

<hr>
<h2 id='mantel'> Mantel test </h2><span id='topic+mantel'></span>

<h3>Description</h3>

<p>Simple and partial Mantel tests, with options for ranked data, permutation tests, and bootstrapped confidence limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel(formula = formula(data), data, nperm = 1000,
    mrank = FALSE, nboot = 500, pboot = 0.9, cboot = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel_+3A_formula">formula</code></td>
<td>
<p> formula describing the test to be conducted. For this test, y ~ x will perform a simple Mantel test, while y ~ x + z1 + z2 + z3 will do a partial Mantel test of the relationship between x and y given z1, z2, z3. All variables can be either a distance matrix of class dist or vectors of dissimilarities. </p>
</td></tr>
<tr><td><code id="mantel_+3A_data">data</code></td>
<td>
<p> an optional dataframe containing the variables in the model as columns of dissimilarities. By default the variables are taken from the current environment. </p>
</td></tr>
<tr><td><code id="mantel_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="mantel_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used. </p>
</td></tr>
<tr><td><code id="mantel_+3A_nboot">nboot</code></td>
<td>
<p> number of iterations to use for the bootstrapped confidence limits. If set to 0,
the bootstrapping will be omitted. </p>
</td></tr>
<tr><td><code id="mantel_+3A_pboot">pboot</code></td>
<td>
<p> the level at which to resample the data for the bootstrapping procedure. </p>
</td></tr>
<tr><td><code id="mantel_+3A_cboot">cboot</code></td>
<td>
<p> the level of the confidence limits to estimate. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only one independent variable is given, the simple Mantel r (r12) is calculated. If 
more than one independent variable is given, the partial Mantel r  (ryx|x1 ...) is 
calculated by permuting one of the original dissimilarity matrices.
The bootstrapping is actually resampling without replacement, because duplication of 
samples is not useful in a dissimilarity context (the dissimilarity of a sample with 
itself is zero). Resampling within dissimilarity values is inappropriate, just as for 
permutation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mantelr</code></td>
<td>
<p>Mantel coefficient.</p>
</td></tr>
<tr><td><code>pval1</code></td>
<td>
<p>one-tailed p-value (null hypothesis: r &lt;= 0).</p>
</td></tr>
<tr><td><code>pval2</code></td>
<td>
<p>one-tailed p-value (null hypothesis: r &gt;= 0).</p>
</td></tr>
<tr><td><code>pval3</code></td>
<td>
<p>two-tailed p-value (null hypothesis: r = 0).</p>
</td></tr>
<tr><td><code>llim</code></td>
<td>
<p>lower confidence limit.</p>
</td></tr>
<tr><td><code>ulim</code></td>
<td>
<p>upper confidence limit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Mantel, N. 1967. The detection of disease clustering and a generalized
regression approach. Cancer Research 27:209-220.
</p>
<p>Smouse, P.E., J.C. Long and R.R. Sokal. 1986. Multiple regression and correlation
extensions of the Mantel test of matrix correspondence. Systematic Zoology 35:62
7-632.
</p>
<p>Goslee, S.C. and Urban, D.L. 2007. The ecodist package for dissimilarity-based analysis
of ecological data. Journal of Statistical Software 22(7):1-19.
</p>
<p>Goslee, S.C. 2010. Correlation analysis of dissimilarity matrices. Plant
Ecology 206(2):279-286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mgram">mgram</a></code>, <code><a href="#topic+mgroup">mgroup</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(graze)

grasses &lt;- graze[, colnames(graze) %in% c("DAGL", "LOAR10", "LOPE", "POPR")]
legumes &lt;- graze[, colnames(graze) %in% c("LOCO6", "TRPR2", "TRRE3")]

grasses.bc &lt;- bcdist(grasses)
legumes.bc &lt;- bcdist(legumes)

space.d &lt;- dist(graze$sitelocation)
forest.d &lt;- dist(graze$forestpct)

# Mantel test: is the difference in forest cover between sites
# related to the difference in grass composition between sites?
mantel(grasses.bc ~ forest.d)

# Mantel test: is the geographic distance between sites
# related to the difference in grass composition between sites?
mantel(grasses.bc ~ space.d)

# Partial Mantel test: is the difference in forest cover between sites
# related to the difference in grass composition once the
# linear effects of geographic distance are removed?
mantel(grasses.bc ~ forest.d + space.d)


# Mantel test: is the difference in forest cover between sites
# related to the difference in legume composition between sites?
mantel(legumes.bc ~ forest.d)

# Mantel test: is the geographic distance between sites
# related to the difference in legume composition between sites?
mantel(legumes.bc ~ space.d)

# Partial Mantel test: is the difference in forest cover between sites
# related to the difference in legume composition once the
# linear effects of geographic distance are removed?
mantel(legumes.bc ~ forest.d + space.d)


# Is there nonlinear pattern in the relationship with geographic distance?
par(mfrow=c(2, 1))
plot(mgram(grasses.bc, space.d, nclass=8))
plot(mgram(legumes.bc, space.d, nclass=8))
</code></pre>

<hr>
<h2 id='mgram'> Mantel correlogram </h2><span id='topic+mgram'></span>

<h3>Description</h3>

<p>Calculates simple Mantel correlograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgram(species.d, space.d, breaks, nclass, stepsize, equiprobable = FALSE, nperm = 1000,
    mrank = FALSE, nboot = 500, pboot = 0.9, cboot = 0.95,
    alternative = "two.sided", trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgram_+3A_species.d">species.d</code></td>
<td>
<p> lower-triangular dissimilarity matrix. </p>
</td></tr>
<tr><td><code id="mgram_+3A_space.d">space.d</code></td>
<td>
<p> lower-triangular matrix of geographic distances. </p>
</td></tr>
<tr><td><code id="mgram_+3A_breaks">breaks</code></td>
<td>
<p> locations of class breaks. If specified, overrides nclass and stepsize. </p>
</td></tr>
<tr><td><code id="mgram_+3A_nclass">nclass</code></td>
<td>
<p> number of distance classes. If not specified, Sturge's rule will be used
to determine an appropriate number of classes. </p>
</td></tr>
<tr><td><code id="mgram_+3A_stepsize">stepsize</code></td>
<td>
<p> width of each distance class. If not specified, nclass and the range of space.d will be used to calculate an appropriate default. </p>
</td></tr>
<tr><td><code id="mgram_+3A_equiprobable">equiprobable</code></td>
<td>
<p> if TRUE, create nclass classes of equal number of distances; if FALSE, create nclass classes of equal width </p>
</td></tr>  
<tr><td><code id="mgram_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="mgram_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used. </p>
</td></tr>
<tr><td><code id="mgram_+3A_nboot">nboot</code></td>
<td>
<p> number of iterations to use for the bootstrapped confidence limits. If set to 0,
the bootstrapping will be omitted. </p>
</td></tr>
<tr><td><code id="mgram_+3A_pboot">pboot</code></td>
<td>
<p> the level at which to resample the data for the bootstrapping procedure. </p>
</td></tr>
<tr><td><code id="mgram_+3A_cboot">cboot</code></td>
<td>
<p> the level of the confidence limits to estimate. </p>
</td></tr>
<tr><td><code id="mgram_+3A_alternative">alternative</code></td>
<td>
<p> default is &quot;two.sided&quot;, and returns p-values for H0: rM = 0. The alternative is &quot;one.sided&quot;, which returns p-values for H0: rM &lt;= 0. </p>
</td></tr>
<tr><td><code id="mgram_+3A_trace">trace</code></td>
<td>
<p> if TRUE, returns progress indicators. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates Mantel correlograms, and tests the hypothesis that the mean compositional dissimilarity within a distance class differs from the mean of all the other distance classes combined. The Mantel correlogram is essentially a multivariate autocorrelation function. The Mantel r represents the dissimilarity in variable composition  (often species composition) at a particular lag distance, and significance is tested in reference to all distance classes.
</p>


<h3>Value</h3>

<p>Returns an object of class mgram, which is a list with two elements.
mgram is a matrix with one row for each distance class and 6 columns:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>midpoint of the distance class.</p>
</td></tr>
<tr><td><code>ngroup</code></td>
<td>
<p>number of distances in that class.</p>
</td></tr>
<tr><td><code>mantelr</code></td>
<td>
<p>Mantel r value.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value for the test chosen.</p>
</td></tr>
<tr><td><code>llim</code></td>
<td>
<p>lower bound of confidence limit for mantelr.</p>
</td></tr>
<tr><td><code>ulim</code></td>
<td>
<p>upper bound of confidence limit for mantelr.</p>
</td></tr>
</table>
<p>resids is NA for objects calculated by mgram().
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Legendre, P. and M. Fortin. 1989. Spatial pattern and ecological analysis.
Vegetatio 80:107-138. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mantel">mantel</a></code>, <code><a href="#topic+plot.mgram">plot.mgram</a></code>, <code><a href="#topic+pmgram">pmgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate a simple surface
x &lt;- matrix(1:10, nrow=10, ncol=10, byrow=FALSE)
y &lt;- matrix(1:10, nrow=10, ncol=10, byrow=TRUE)
z &lt;- x + 3*y
image(z)

# analyze the pattern of z across space
space &lt;- cbind(as.vector(x), as.vector(y))
z &lt;- as.vector(z)
space.d &lt;- distance(space, "eucl")
z.d &lt;- distance(z, "eucl")
z.mgram &lt;- mgram(z.d, space.d, nperm=0)
plot(z.mgram)

#

data(graze)
space.d &lt;- dist(graze$sitelocation)
forest.d &lt;- dist(graze$forestpct)

grasses &lt;- graze[, colnames(graze) %in% c("DAGL", "LOAR10", "LOPE", "POPR")]
legumes &lt;- graze[, colnames(graze) %in% c("LOCO6", "TRPR2", "TRRE3")]

grasses.bc &lt;- bcdist(grasses)
legumes.bc &lt;- bcdist(legumes)

# Does the relationship of composition with distance vary for
# grasses and legumes?
par(mfrow=c(2, 1))
plot(mgram(grasses.bc, space.d, nclass=8))
plot(mgram(legumes.bc, space.d, nclass=8))

</code></pre>

<hr>
<h2 id='mgroup'> Mantel test for groups </h2><span id='topic+mgroup'></span>

<h3>Description</h3>

<p>Mantel test across one or more group contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgroup(edist, groups, nperm = 1000, mrank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgroup_+3A_edist">edist</code></td>
<td>
<p> a dist object or lower triangular distance vector. </p>
</td></tr>
<tr><td><code id="mgroup_+3A_groups">groups</code></td>
<td>
<p> a vector of group memberships (numeric, character, or 
factor), or a matrix or data frame with columns describing multiple 
sets of groups. </p>
</td></tr>
<tr><td><code id="mgroup_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the 
permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="mgroup_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mgroup</code> returns the Mantel correlations for group contrast 
matrices computed from cluster groups across a range of clustering 
levels.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nclust</code></td>
<td>
<p>Number of groups tested.</p>
</td></tr>
<tr><td><code>mantelr</code></td>
<td>
<p>Mantel coefficient.</p>
</td></tr>
<tr><td><code>pval1</code></td>
<td>
<p>one-tailed p-value (null hypothesis: r &lt;= 0).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Legendre, P. and M. Fortin. 1989. Spatial pattern and ecological 
analysis. Vegetatio 80:107-138. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mantel">mantel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using a model matrix to test group membership

data(iris)
iris.d &lt;- dist(iris[,1:4])
mgroup(iris.d, iris[,5])

# clustering-based example

data(graze)
graze.d &lt;- dist(graze[, -c(1:2)])
graze.hclust &lt;- hclust(graze.d)

clust.groups &lt;- data.frame(
	k2 = cutree(graze.hclust, k = 2),
	k4 = cutree(graze.hclust, k = 4),
	k6 = cutree(graze.hclust, k = 6),
	k8 = cutree(graze.hclust, k = 8))

mgroup(graze.d, clust.groups, nperm=1000)

</code></pre>

<hr>
<h2 id='min.nmds'> Find minimum stress configuration </h2><span id='topic+min.nmds'></span><span id='topic+nmds.min'></span>

<h3>Description</h3>

<p>Finds minimum stress configuration from output of nmds()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nmds'
min(..., na.rm = FALSE, dims = 2)
nmds.min(x, dims = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min.nmds_+3A_...">...</code></td>
<td>
<p> output from nmds() </p>
</td></tr>
<tr><td><code id="min.nmds_+3A_x">x</code></td>
<td>
<p> output from nmds() </p>
</td></tr>
<tr><td><code id="min.nmds_+3A_dims">dims</code></td>
<td>
<p> desired dimensionality of result. If dims = 0 then the overall minimum stress configuration is chosen. By default, the best two-dimensional configuration is returned. </p>
</td></tr>
<tr><td><code id="min.nmds_+3A_na.rm">na.rm</code></td>
<td>
<p>Not used; there should be no NA values in a NMDS configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For back-compatibility, the <code>nmds.min</code> function remains.
</p>


<h3>Value</h3>

<p>Configuration of minimum stress ordination (dataframe of
coordinates). The stress and r^2 for the minimum stress configuration are stored as attributes.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

</code></pre>

<hr>
<h2 id='MRM'> Multiple Regression on distance Matrices </h2><span id='topic+MRM'></span>

<h3>Description</h3>

<p>Multiple regression on distance matrices (MRM) using permutation tests of significance for regression coefficients and R-squared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRM(formula = formula(data), data, nperm = 1000,
	method = "linear", mrank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRM_+3A_formula">formula</code></td>
<td>
<p> formula describing the test to be conducted. </p>
</td></tr>
<tr><td><code id="MRM_+3A_data">data</code></td>
<td>
<p> an optional dataframe containing the variables in the model as columns of dissimilarities. By default the variables are taken from the current environment. </p>
</td></tr>
<tr><td><code id="MRM_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="MRM_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used.  </p>
</td></tr>
<tr><td><code id="MRM_+3A_method">method</code></td>
<td>
<p> if &quot;linear&quot;, the default, uses multiple regression analysis. If &quot;logistic&quot;, performs logistic regression with appropriate permutation testing. Note that this may be substantially slower.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs multiple regression on distance matrices following the methods outlined in Legendre et al. 1994. Specificaly, the permutation test uses a pseudo-t test to assess significance, rather than using the regression coefficients directly.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coef</code></td>
<td>
<p>A matrix with regression coefficients and associated p-values from the permutation test (using the pseudo-t of Legendre et al. 1994).</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>Regression R-squared and associated p-value from the permutation test (linear only). </p>
</td></tr>
<tr><td><code>F.test</code></td>
<td>
<p>F-statistic and p-value for overall F-test for lack of fit (linear only).</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>Residual deviance, degrees of freedom, and associated p-value (logistic only).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p>Lichstein, J. 2007. Multiple regression on distance matrices: A multivariate spatial analysis tool. Plant Ecology 188: 117-131.
</p>
<p>Legendre, P.; Lapointe, F. and Casgrain, P. 1994. Modeling brain evolution from behavior: A permutational regression approach. Evolution 48: 1487-1499.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mantel">mantel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(graze)

  # Abundance of this grass is related to forest cover but not location
  MRM(dist(LOAR10) ~ dist(sitelocation) + dist(forestpct), data=graze, nperm=10)

  # Abundance of this legume is related to location but not forest cover
  MRM(dist(TRRE3) ~ dist(sitelocation) + dist(forestpct), data=graze, nperm=10)

  # Compare to presence/absence of grass LOAR10 using logistic regression
  LOAR10.presence &lt;- ifelse(graze$LOAR10 &gt; 0, 1, 0)
  MRM(dist(LOAR10.presence) ~ dist(sitelocation) + dist(forestpct), 
  	data=graze, nperm=10, method="logistic")
</code></pre>

<hr>
<h2 id='nmds'> Non-metric multidimensional scaling </h2><span id='topic+nmds'></span>

<h3>Description</h3>

<p>Non-metric multidimensional scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmds(dmat, mindim = 1, maxdim = 2, nits = 10, iconf, epsilon = 1e-12,
    maxit = 500, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmds_+3A_dmat">dmat</code></td>
<td>
<p> lower-triangular dissimilarity matrix. </p>
</td></tr>
<tr><td><code id="nmds_+3A_mindim">mindim</code></td>
<td>
<p> optional, minimum number of dimensions to use. </p>
</td></tr>
<tr><td><code id="nmds_+3A_maxdim">maxdim</code></td>
<td>
<p> optional, maximum number of dimensions to use. </p>
</td></tr>
<tr><td><code id="nmds_+3A_nits">nits</code></td>
<td>
<p> optional, number of separate ordinations to use. </p>
</td></tr>
<tr><td><code id="nmds_+3A_iconf">iconf</code></td>
<td>
<p> optional, initial configuration. If not specified, then a random configuration is used. </p>
</td></tr>
<tr><td><code id="nmds_+3A_epsilon">epsilon</code></td>
<td>
<p> optional, acceptable difference in stress. </p>
</td></tr>
<tr><td><code id="nmds_+3A_maxit">maxit</code></td>
<td>
<p> optional, maximum number of iterations. </p>
</td></tr>
<tr><td><code id="nmds_+3A_trace">trace</code></td>
<td>
<p> if TRUE, will write progress indicator to the screen. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of NMDS is to find a configuration in a given number of dimensions which preserves rank-order dissimilarities as closely as possible. The number of dimensions must be specified in advance. Because NMDS is prone to finding local minima, several random starts must be used. 
Stress is used as the measure of goodness of fit. A lower stress indicates a better match between dissimilarity and ordination. As of ecodist 1.9, the stress calculation used is the same as in <code>MASS:isoMDS</code>. In previous versions it was monotonically related, so the same configurations were produced, but the absolute value was different.
</p>


<h3>Value</h3>

<table>
<tr><td><code>conf</code></td>
<td>
<p>list of configurations, each in the same units as the original dissimilarities.</p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p>list of final stress values.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>total variance explained by each configuration.</p>
</td></tr>
</table>
<p>The first results are for the lowest number of dimensions (total number is (mindim - maxdim + 1) * nits).
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Kruskal, J.B. 1964. Multidimensional scaling by optimizing goodness of fit to a
nonmetric hypothesis. Psychometrika 29:1-27.
</p>
<p>Minchin, P.R. 1987. An evaluation of the relative robustness of techniques for ecological ordination. Vegetatio 96:89-108. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.nmds">plot.nmds</a></code>, <code><a href="#topic+min.nmds">min.nmds</a></code>, <code><a href="#topic+vf">vf</a></code>, <code><a href="#topic+addord">addord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# rotate the configuration to maximize variance
iris.rot &lt;- princomp(iris.nmin)$scores

# rotation preserves distance apart in ordination space
cor(dist(iris.nmin), dist(iris.rot))

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

# repeat for the rotated ordination
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vfrot &lt;- vf(iris.rot, iris[,1:4], nperm=1000)
### save(iris.vfrot, file="ecodist/data/iris.vfrot.rda")
data(iris.vfrot)

par(mfrow=c(1,2))
plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)
plot(iris.rot, col=as.numeric(iris$Species), pch=as.numeric(iris$Species),
    main="Rotated NMDS")
plot(iris.vfrot)


# generate new data points to add to the ordination
# this might be new samples, or a second dataset

iris.new &lt;- structure(list(Sepal.Length = c(4.6, 4.9, 5.4, 5.2, 6, 6.5, 6, 
6.8, 7.3), Sepal.Width = c(3.2, 3.5, 3.6, 2.3, 2.8, 3, 2.7, 3.1, 
3.2), Petal.Length = c(1.2, 1.5, 1.5, 3.5, 4.1, 4.2, 4.8, 5, 
5.7), Petal.Width = c(0.26, 0.26, 0.26, 1.2, 1.3, 1.4, 1.8, 2, 
2), Species = structure(c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L), .Label = c("setosa", 
"versicolor", "virginica"), class = "factor")), .Names = c("Sepal.Length", 
"Sepal.Width", "Petal.Length", "Petal.Width", "Species"), class = "data.frame",
row.names = c(NA, -9L))

# provide a dist object containing original and new data
# provide a logical vector indicating which samples were used to
# construct the original configuration

iris.full &lt;- rbind(iris, iris.new)
all.d &lt;- dist(iris.full[,1:4])
is.orig &lt;- c(rep(TRUE, nrow(iris)), rep(FALSE, nrow(iris.new)))

### addord() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.fit &lt;- addord(iris.nmin, iris.full[,1:4], all.d, is.orig, maxit=100)
### save(iris.fit, file="ecodist/data/iris.fit.rda")
data(iris.fit)

plot(iris.fit$conf, col=iris.full$Species, pch=c(18, 4)[is.orig + 1],
    xlab="NMDS 1", ylab="NMDS 2")
title("Demo: adding points to an ordination")
legend("bottomleft", c("Training set", "Added point"), pch=c(4, 18))
legend("topright", levels(iris$Species), fill=1:3)
</code></pre>

<hr>
<h2 id='pathdist'>
Graph extension of dissimilarities
</h2><span id='topic+pathdist'></span>

<h3>Description</h3>

<p>Uses the shortest path connecting sites to estimate the distance between samples with pairwise distances greater than maxv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathdist(v, maxv = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathdist_+3A_v">v</code></td>
<td>

<p>lower-triangular distance vector, possibly as produced by dist() or distance().
</p>
</td></tr>
<tr><td><code id="pathdist_+3A_maxv">maxv</code></td>
<td>

<p>cutoff for distances: values greater or equal to this will be estimated from the minimum spanning tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairwise samples with no species will have distances greater than a cutoff. A distance-weighted graph connecting these samples by way of intermediate samples with some species in common can be used to interpolate distances by adding up the path length connecting those samples. 
This function will fail if there are completely disconnected subsets.
</p>


<h3>Value</h3>

<p>Returns a lower-triangular distance matrix.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# samples 1 and 2, and 3 and 4, have no species in common
	x &lt;- matrix(c(	1, 0, 1, 0,
			0, 1, 0, 1,
			1, 0, 0, 0,
			0, 1, 1, 1,
			1, 1, 1, 0,
			1, 0, 1, 1,
			0, 0, 1, 1), ncol = 4, byrow = TRUE)

	# the maximum Jaccard distance is 1
	# regardless of how different the samples are
	x.jd &lt;- dist(x, "binary")

	# estimate the true distance between those pairs
	# by following the shorted path along connected sites
	pathdist(x.jd)

</code></pre>

<hr>
<h2 id='pco'> Principal coordinates analysis </h2><span id='topic+pco'></span>

<h3>Description</h3>

<p>Principal coordinates analysis (classical scaling).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pco(x, negvals = "zero", dround = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pco_+3A_x">x</code></td>
<td>
<p> a lower-triangular dissimilarity matrix. </p>
</td></tr>
<tr><td><code id="pco_+3A_negvals">negvals</code></td>
<td>
<p> if = &quot;zero&quot; sets all negative eigenvalues to zero;
if = &quot;rm&quot; corrects for negative eigenvalues using method
1 of Legendre and Anderson 1999. </p>
</td></tr>
<tr><td><code id="pco_+3A_dround">dround</code></td>
<td>
<p> if greater than 0, attempts to correct for round-off error by
rounding to that number of places. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCO (classical scaling, metric multidimensional scaling) is very similar to principal components analysis, but allows the use of any dissimilarity metric.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>
<p>eigenvalue for each component. This is a measure of the variance explained by each dimension.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>eigenvectors. data frame with columns containing the scores for that dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+princomp">princomp</a></code>, <code><a href="#topic+nmds">nmds</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.d &lt;- dist(iris[,1:4])
iris.pco &lt;- pco(iris.d)

# scatterplot of the first two dimensions
plot(iris.pco$vectors[,1:2], col=as.numeric(iris$Species),
  pch=as.numeric(iris$Species), main="PCO", xlab="PCO 1", ylab="PCO 2")
</code></pre>

<hr>
<h2 id='plot.mgram'> Plot a Mantel correlogram </h2><span id='topic+plot.mgram'></span>

<h3>Description</h3>

<p>Plot a Mantel correlogram from an object of S3 class <code>mgram</code>, using solid symbols for significant values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgram'
plot(x, pval = 0.05, xlab = "Distance", ylab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgram_+3A_x">x</code></td>
<td>
<p> an object of class <code>mgram</code> </p>
</td></tr>
<tr><td><code id="plot.mgram_+3A_pval">pval</code></td>
<td>
<p> cut-off level for statistical significance. </p>
</td></tr>
<tr><td><code id="plot.mgram_+3A_xlab">xlab</code></td>
<td>
<p> x-axis label. </p>
</td></tr>
<tr><td><code id="plot.mgram_+3A_ylab">ylab</code></td>
<td>
<p> y-axis label. </p>
</td></tr>
<tr><td><code id="plot.mgram_+3A_...">...</code></td>
<td>
<p> optional, any additional graphics parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>draws a plot (graphics device must be active).
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mgram">mgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate a simple surface
x &lt;- matrix(1:10, nrow=10, ncol=10, byrow=FALSE)
y &lt;- matrix(1:10, nrow=10, ncol=10, byrow=TRUE)
z &lt;- x + 3*y
image(z)

# analyze the pattern of z across space
space &lt;- cbind(as.vector(x), as.vector(y))
z &lt;- as.vector(z)
space.d &lt;- distance(space, "eucl")
z.d &lt;- distance(z, "eucl")
z.mgram &lt;- mgram(z.d, space.d, nperm=0)
plot(z.mgram)

#

data(graze)
space.d &lt;- dist(graze$sitelocation)
forest.d &lt;- dist(graze$forestpct)

grasses &lt;- graze[, colnames(graze) %in% c("DAGL", "LOAR10", "LOPE", "POPR")]
legumes &lt;- graze[, colnames(graze) %in% c("LOCO6", "TRPR2", "TRRE3")]

grasses.bc &lt;- bcdist(grasses)
legumes.bc &lt;- bcdist(legumes)

# Does the relationship of composition with distance vary for
# grasses and legumes?
par(mfrow=c(2, 1))
plot(mgram(grasses.bc, space.d, nclass=8))
plot(mgram(legumes.bc, space.d, nclass=8))

</code></pre>

<hr>
<h2 id='plot.nmds'> Plot information about NMDS ordination </h2><span id='topic+plot.nmds'></span>

<h3>Description</h3>

<p>Graphical display of stress and r2 for NMDS ordination along number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nmds'
plot(x, plot = TRUE, xlab = "Dimensions", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nmds_+3A_x">x</code></td>
<td>
<p> an object of S3 class <code>nmds</code>, created by <code>nmds()</code> </p>
</td></tr>
<tr><td><code id="plot.nmds_+3A_plot">plot</code></td>
<td>
<p> optional, if TRUE a figure is produced </p>
</td></tr>
<tr><td><code id="plot.nmds_+3A_xlab">xlab</code></td>
<td>
<p> optional, label for x axis of graph </p>
</td></tr>
<tr><td><code id="plot.nmds_+3A_...">...</code></td>
<td>
<p> optional, other graphics parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a two-panel plot with stress and r2 for ordination by number of dimensions. Points show the mean value; lines indicate minimum and maximum.
</p>


<h3>Author(s)</h3>

<p> Dean Urban </p>


<h3>See Also</h3>

 <p><code><a href="#topic+nmds">nmds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

</code></pre>

<hr>
<h2 id='plot.vf'> Plots fitted vectors onto an ordination diagram </h2><span id='topic+plot.vf'></span>

<h3>Description</h3>

<p>Add vector fitting arrows to an existing ordination plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vf'
plot(x, pval = NULL, r = NULL, cex = 0.8, ascale = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vf_+3A_x">x</code></td>
<td>
<p> an object of S3 class <code>vf</code>, created by <code>vf()</code> </p>
</td></tr>
<tr><td><code id="plot.vf_+3A_pval">pval</code></td>
<td>
<p> optional, critical p-value for choosing variables to plot </p>
</td></tr>
<tr><td><code id="plot.vf_+3A_r">r</code></td>
<td>
<p> optional, minimum Mantel r for choosing variables to plot </p>
</td></tr>
<tr><td><code id="plot.vf_+3A_cex">cex</code></td>
<td>
<p> text size </p>
</td></tr>
<tr><td><code id="plot.vf_+3A_ascale">ascale</code></td>
<td>
<p> optional, proportion of plot area to use when calculating arrow length </p>
</td></tr>
<tr><td><code id="plot.vf_+3A_...">...</code></td>
<td>
<p> optional, other graphics parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds arrows to an existing ordination plot. Only arrows with a p-value less than pval are added. By default, all variables are shown.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+vf">vf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of multivariate analysis using built-in iris dataset
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)
plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)

</code></pre>

<hr>
<h2 id='pmgram'> Piecewise multivariate correlogram </h2><span id='topic+pmgram'></span>

<h3>Description</h3>

<p>This function calculates simple and partial piecewise multivariate correlograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmgram(data, space, partial, breaks, nclass, stepsize, equiprobable = FALSE, 
  resids = FALSE, nperm = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmgram_+3A_data">data</code></td>
<td>
<p> lower-triangular dissimilarity matrix. This can be either an object of class dist (treated as one column) or a matrix or data frame with one or two columns, each of which is an independent lower-triangular dissimilarity in vector form. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_space">space</code></td>
<td>
<p> lower-triangular matrix of geographic distances. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_partial">partial</code></td>
<td>
<p> optional, lower-triangular dissimilarity matrix of ancillary data. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_breaks">breaks</code></td>
<td>
<p> locations of class breaks. If specified, overrides nclass and stepsize. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_nclass">nclass</code></td>
<td>
<p> number of distance classes. If not specified, Sturge's rule will be used
to determine an appropriate number of classes. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_stepsize">stepsize</code></td>
<td>
<p> width of each distance class. If not specified, nclass and the range of space.d will be used to calculate an appropriate default. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_equiprobable">equiprobable</code></td>
<td>
<p> if TRUE, create nclass classes of equal number of distances; if FALSE, create nclass classes of equal width </p>
</td></tr>  
<tr><td><code id="pmgram_+3A_resids">resids</code></td>
<td>
<p> if resids=TRUE, will return the residuals for each distance class. Otherwise returns 0. </p>
</td></tr>
<tr><td><code id="pmgram_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard Mantel correlogram calculated by <code><a href="#topic+mgram">mgram</a></code> tests the hypothesis that the mean compositional dissimilarity within a distance class differs from the mean of all the other distance classes combined. This function instead produces a piecewise correlogram by testing the relationship between dissimilarities within each distance class on its own, without reference to relationships across other distance classes.
</p>
<p>This function does four different analyses:
If data has 1 column and partial is missing,
calculates a multivariate correlogram for data.
</p>
<p>If data has 2 columns and partial is missing,
calculates a piecewise Mantel cross-correlogram, calculating the Mantel r between
the two columns for each distance class separately.
</p>
<p>If data has 1 column and partial exists,
calculates a partial multivariate correlogram based on residuals of data ~ partial.
</p>
<p>If data has 2 columns and partial exists,
does a partial Mantel cross-correlogram,
calculating partial Mantel r for each distance class separately.
</p>
<p>The Iwt statistic used for the multivariate correlograms is not the standard Mantel r. For one variable, using Euclidean distance, this metric converges on the familiar Moran autocorrelation. Like the Moran autocorrelation function, this statistic usually falls between -1 and 1, but is not bounded by those limits. Unlike the Moran function, this correlogram can be used for multivariate data, and can be extended to partial tests.
</p>
<p>The Mantel r is used for piecewise cross-correlograms.
</p>
<p>The comparisons in <code>vignette("dissimilarity", package="ecodist")</code> may help.
</p>


<h3>Value</h3>

<p>Returns a object of class mgram, which is a list containing two objects:
mgram is a matrix with one row for each distance class and 4 columns:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>midpoint of the distance class.</p>
</td></tr>
<tr><td><code>ngroup</code></td>
<td>
<p>number of distances in that class.</p>
</td></tr>
<tr><td><code>piecer or Iwt</code></td>
<td>
<p>Mantel r value or appropriate statistic  (see Details).</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>two-sided p-value.</p>
</td></tr>
</table>
<p>resids is a vector of the residuals (if calculated) and can be accessed with the <code>residuals()</code> method.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mgram">mgram</a></code>, <code><a href="#topic+mantel">mantel</a></code>, <code><a href="#topic+residuals.mgram">residuals.mgram</a></code>, <code><a href="#topic+plot.mgram">plot.mgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bump)

par(mfrow=c(1, 2))
image(bump, col=gray(seq(0, 1, length=5)))

z &lt;- as.vector(bump)
x &lt;- rep(1:25, times=25)
y &lt;- rep(1:25, each=25)

X &lt;- col(bump)
Y &lt;- row(bump)
# calculate dissimilarities for data and space
geo.dist &lt;- dist(cbind(as.vector(X), as.vector(Y)))
value.dist &lt;- dist(as.vector(bump))

### pmgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### bump.pmgram &lt;- pmgram(value.dist, geo.dist, nperm=10000)

data(bump.pmgram)
plot(bump.pmgram)

#### Partial pmgram example

# generate a simple surface
# with complex nonlinear spatial pattern

x &lt;- matrix(1:25, nrow=25, ncol=25, byrow=FALSE)
y &lt;- matrix(1:25, nrow=25, ncol=25, byrow=TRUE)

# create z1 and z2 as functions of x, y
# and scale them to [0, 1]
z1 &lt;- x + 3*y
z2 &lt;- y - cos(x)

z1 &lt;- (z1 - min(z1)) / (max(z1) - min(z1))
z2 &lt;- (z2 - min(z2)) / (max(z2) - min(z2))

z12 &lt;- (z1 + z2*2)/3

# look at patterns

layout(matrix(c(
1, 1, 2, 2,
1, 1, 2, 2,
3, 3, 4, 4, 
3, 3, 5, 5), nrow=4, byrow=TRUE))


image(z1, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z2, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z12, col=gray(seq(0, 1, length=20)), zlim=c(0,1))

# analyze the pattern of z across space
z1 &lt;- as.vector(z1)
z2 &lt;- as.vector(z2)
z12 &lt;- as.vector(z12)
z1.d &lt;- dist(z1)
z2.d &lt;- dist(z2)
z12.d &lt;- dist(z12)

space &lt;- cbind(as.vector(x), as.vector(y))
space.d &lt;- dist(space)

# take partial correlogram without effects of z1
### pmgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.no &lt;- pmgram(z12.d, space.d, nperm=1000, resids=FALSE)
### save(z.no, file="ecodist/data/z.no.rda")
data(z.no)
plot(z.no)


# take partial correlogram of z12 given z1
### pmgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.z1 &lt;- pmgram(z12.d, space.d, z2.d, nperm=1000, resids=FALSE)
### save(z.z1, file="ecodist/data/z.z1.rda")
data(z.z1)
plot(z.z1)

</code></pre>

<hr>
<h2 id='relrange'>
Relativize a compositional data matrix.
</h2><span id='topic+relrange'></span>

<h3>Description</h3>

<p>Relativizes the range of each column of a data frame or matrix x to 0-1. If globalmin and/or globalmax are provided, those are used to scale the columns, for instance to scale a subset to match a larger sample. If they are NA, the minimum and maximum values for each column are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relrange(x, globalmin = NA, globalmax = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrange_+3A_x">x</code></td>
<td>

<p>The data frame or matrix to be relativized.
</p>
</td></tr>
<tr><td><code id="relrange_+3A_globalmin">globalmin</code></td>
<td>

<p>A value other than the population minimum to be used. Should be the same length as the number of columns of x.
</p>
</td></tr>
<tr><td><code id="relrange_+3A_globalmax">globalmax</code></td>
<td>

<p>A value other than the population maximum to be used. Should be the same length as the number of columns of x.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Relativizes the data using the minimum and maximum values. If globalmin and global max are not used, the range will be 0-1 for each variable. This can be useful for putting disparate variables to the same magnitude while keeping all non-negative values.
</p>


<h3>Value</h3>

<p>Returns an object of the same class as x (matrix or data frame) with the columns rescaled.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	x &lt;- matrix(1:15, ncol = 3)

	# uses min and max of the data
	relrange(x)

	# uses min and max determined by other knowledge of the variables
	relrange(x, globalmin = c(0, 0, 0), globalmax = c(6, 10, 20))
</code></pre>

<hr>
<h2 id='residuals.mgram'> Residuals of a Mantel correlogram </h2><span id='topic+residuals.mgram'></span>

<h3>Description</h3>

<p>Extracts residuals from an S3 object of class <code>mgram</code> (only relevant for objects created by <code>pmgram{}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgram'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mgram_+3A_object">object</code></td>
<td>
<p> an object of class <code>mgram</code> </p>
</td></tr>
<tr><td><code id="residuals.mgram_+3A_...">...</code></td>
<td>
<p> additional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pmgram">pmgram</a></code>, <code><a href="#topic+mgram">mgram</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Partial pmgram example

# generate a simple surface
# with complex nonlinear spatial pattern

x &lt;- matrix(1:10, nrow=10, ncol=10, byrow=FALSE)
y &lt;- matrix(1:10, nrow=10, ncol=10, byrow=TRUE)

# create z1 and z2 as functions of x, y
# and scale them to [0, 1]
z1 &lt;- x + 3*y
z2 &lt;- y - cos(x)

z1 &lt;- (z1 - min(z1)) / (max(z1) - min(z1))
z2 &lt;- (z2 - min(z2)) / (max(z2) - min(z2))

z12 &lt;- (z1 + z2*2)/3

# analyze the pattern of z across space
z1 &lt;- as.vector(z1)
z2 &lt;- as.vector(z2)
z12 &lt;- as.vector(z12)
z1.d &lt;- dist(z1)
z2.d &lt;- dist(z2)
z12.d &lt;- dist(z12)

space &lt;- cbind(as.vector(x), as.vector(y))
space.d &lt;- dist(space)

# take partial correlogram of z12 given z1
z.z1 &lt;- pmgram(z12.d, space.d, z2.d, nperm=0, resids=TRUE)
summary(residuals(z.z1))

</code></pre>

<hr>
<h2 id='rotate2d'>
Rotate a 2D ordination.
</h2><span id='topic+rotate2d'></span>

<h3>Description</h3>

<p>Rotates a two-dimensional ordination configuration to place the direction indicated along the horizontal axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate2d(ord, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate2d_+3A_ord">ord</code></td>
<td>

<p>A matrix or data frame with two columns, or a vf object, containing the points of an ordination configuration.
</p>
</td></tr>
<tr><td><code id="rotate2d_+3A_x">x</code></td>
<td>

<p>The coordinates of a point in the ordination space. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The configuration ord is rotated so that the vector defined by c(0, 0), and x is along the horizontal axis. This can be useful for placing a specific variable, for instance from vf(), in a consistent direction across multiple ordinations. Doing so can facilitate interpretation.
</p>


<h3>Value</h3>

<p>A rotated data frame of coordinates of the same size as ord and in the same order. If ord was produced by vf(), the complete vf object is returned.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vf">vf</a></code>, <code><a href="#topic+nmds">nmds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of multivariate analysis using built-in iris dataset
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)

# rotate configuration so Sepal Width is along the horizontal axis

iris.nmin.rot &lt;- rotate2d(iris.nmin, iris.vf[2, 1:2])
iris.vf.rot &lt;- rotate2d(iris.vf, iris.vf[2, 1:2])

plot(iris.nmin.rot, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf.rot)

</code></pre>

<hr>
<h2 id='vf'> Vector fitting </h2><span id='topic+vf'></span>

<h3>Description</h3>

<p>Fits ancillary variables to an ordination configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vf(ord, vars, nperm = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vf_+3A_ord">ord</code></td>
<td>
<p> matrix containing a 2-dimensional ordination result with axes as columns. </p>
</td></tr>
<tr><td><code id="vf_+3A_vars">vars</code></td>
<td>
<p> matrix with ancillary variables as columns. </p>
</td></tr>
<tr><td><code id="vf_+3A_nperm">nperm</code></td>
<td>
<p> number of permutation for the significance test. If nperm = 0, the test will be omitted. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vector fitting finds the maximum correlation of the individual variables with a configuration of samples in ordination space. 
</p>


<h3>Value</h3>

<p>an object of class vf, which is a data frame with the first 2 columns containing the scores for every variable in each of the 2 dimensions of the ordination space. r is the maximum correlation of the variable with the ordination space, and pval is the result of the permutation test.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Jongman, R.H.G., C.J.F. ter Braak and O.F.R. van Tongeren. 1995. Data analysis in community and landscape ecology. Cambridge University Press, New York. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.vf">plot.vf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of multivariate analysis using built-in iris dataset
data(iris)
iris.d &lt;- dist(iris[,1:4])

### nmds() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.nmds &lt;- nmds(iris.d, nits=20, mindim=1, maxdim=4)
### save(iris.nmds, file="ecodist/data/iris.nmds.rda")
data(iris.nmds)

# examine fit by number of dimensions
plot(iris.nmds)

# choose the best two-dimensional solution to work with
iris.nmin &lt;- min(iris.nmds, dims=2)

# fit the data to the ordination as vectors
### vf() is timeconsuming, so this was generated
### in advance and saved.
### set.seed(1234)
### iris.vf &lt;- vf(iris.nmin, iris[,1:4], nperm=1000)
### save(iris.vf, file="ecodist/data/iris.vf.rda")
data(iris.vf)

plot(iris.nmin, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf)

# rotate configuration so Sepal Width is along the horizontal axis

iris.nmin.rot &lt;- rotate2d(iris.nmin, iris.vf[2, 1:2])
iris.vf.rot &lt;- rotate2d(iris.vf, iris.vf[2, 1:2])

plot(iris.nmin.rot, col=as.numeric(iris$Species), pch=as.numeric(iris$Species), main="NMDS")
plot(iris.vf.rot)

</code></pre>

<hr>
<h2 id='xdistance'>
Cross-distance between two datasets.
</h2><span id='topic+xdistance'></span>

<h3>Description</h3>

<p>Pairwise dissimilarity calculation between rows of one dataset and rows of another, for instance across different sampling periods for the same set of sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdistance(x, y, method = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xdistance_+3A_x">x</code></td>
<td>
<p>A site by species or other matrix or data frame.</p>
</td></tr>
<tr><td><code id="xdistance_+3A_y">y</code></td>
<td>
<p>A a second site by species dataset, which must have at least the same columns.</p>
</td></tr>
<tr><td><code id="xdistance_+3A_method">method</code></td>
<td>
<p>This function calls <code><a href="#topic+distance">distance</a></code> to do the calculations, and will accept any symmetric method used there, currently: &quot;euclidean&quot;, &quot;bray-curtis&quot;, &quot;manhattan&quot;, &quot;mahalanobis&quot; (squared Mahalanobis distance), &quot;jaccard&quot;, &quot;sorensen&quot;, &quot;gower&quot;, &quot;modgower10&quot; (modified Gower, base 10), &quot;modgower2&quot; (modified Gower, base 2). Partial matching will work for selecting a method.
The asymmetric &quot;difference&quot; method will not work for calculating cross-distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate rowwise dissimilarities between any pair of matrices or data frames with the same number of columns.
Note that the cross-dissimilarity functions are for research purposes, and are not well-tested.
</p>


<h3>Value</h3>

<p>A non-symmetric and possibly not square matrix of dissimilarities of class <code>xdist</code>, where <code>result &lt;- xdistance(x, y)</code> produces a matrix with <code>result[a, b]</code> containing the dissimilarity between <code>x[a, ]</code> and <code>y[b, ]</code>.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+xmantel">xmantel</a></code>, <code><a href="#topic+xmgram">xmgram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graze)

### EXAMPLE 1: Square matrices

# take two subsets of sites with different dominant grass abundances
# use cut-offs that produce equal numbers of sites
dom1 &lt;- subset(graze, POPR &gt; 50 &amp; DAGL &lt; 20) #  8 sites
dom2 &lt;- subset(graze, POPR &lt; 50 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd)
xmantel(dom.xd ~ forest.xd + sitelocation.xd)

plot(xmgram(dom.xd, sitelocation.xd))


### EXAMPLE 2: Non-square matrices

# take two subsets of sites with different dominant grass abundances
# this produces a non-square matrix

dom1 &lt;- subset(graze, POPR &gt; 45 &amp; DAGL &lt; 20) # 13 sites
dom2 &lt;- subset(graze, POPR &lt; 45 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd, dims=c(13, 8))
xmantel(dom.xd ~ forest.xd + sitelocation.xd, dims=c(13, 8))

plot(xmgram(dom.xd, sitelocation.xd))
</code></pre>

<hr>
<h2 id='xmantel'> Cross-Mantel test </h2><span id='topic+xmantel'></span>

<h3>Description</h3>

<p>Simple and partial cross-Mantel tests, with options for ranked data and permutation tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmantel(formula = formula(data), data, dims = NA,
   nperm = 1000, mrank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmantel_+3A_formula">formula</code></td>
<td>
<p> formula describing the test to be conducted. For this test, y ~ x will perform a simple Mantel test, while y ~ x + z1 + z2 + z3 will do a partial Mantel test of the relationship between x and y given z1, z2, z3. All variables should be either non-symmetric square cross-dissimilary matrices of class xdist, or vector forms thereof. </p>
</td></tr>
<tr><td><code id="xmantel_+3A_data">data</code></td>
<td>
<p> an optional dataframe containing the variables in the model as columns of dissimilarities. By default the variables are taken from the current environment. </p>
</td></tr>
<tr><td><code id="xmantel_+3A_dims">dims</code></td>
<td>
<p> if the dissimilarity matrices are not square, the dimensions must be provided as <code>c(nrow, ncol)</code></p>
</td></tr>
<tr><td><code id="xmantel_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="xmantel_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only one independent variable is given, the simple Mantel r (r12) is calculated. If more than one independent variable is given, the partial Mantel r  (ryx|x1 ...) is calculated by permuting one of the original dissimilarity matrices.
Note that the cross-dissimilarity functions are for research purposes, and are not well-tested.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mantelr</code></td>
<td>
<p>Mantel coefficient.</p>
</td></tr>
<tr><td><code>pval1</code></td>
<td>
<p>one-tailed p-value (null hypothesis: r &lt;= 0).</p>
</td></tr>
<tr><td><code>pval2</code></td>
<td>
<p>one-tailed p-value (null hypothesis: r &gt;= 0).</p>
</td></tr>
<tr><td><code>pval3</code></td>
<td>
<p>two-tailed p-value (null hypothesis: r = 0).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

  <p><code><a href="#topic+xdistance">xdistance</a></code>, <code><a href="#topic+xmgram">xmgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(graze)

### EXAMPLE 1: Square matrices

# take two subsets of sites with different dominant grass abundances
# use cut-offs that produce equal numbers of sites
dom1 &lt;- subset(graze, POPR &gt; 50 &amp; DAGL &lt; 20) #  8 sites
dom2 &lt;- subset(graze, POPR &lt; 50 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd)
xmantel(dom.xd ~ forest.xd + sitelocation.xd)

plot(xmgram(dom.xd, sitelocation.xd))


### EXAMPLE 2: Non-square matrices

# take two subsets of sites with different dominant grass abundances
# this produces a non-square matrix

dom1 &lt;- subset(graze, POPR &gt; 45 &amp; DAGL &lt; 20) # 13 sites
dom2 &lt;- subset(graze, POPR &lt; 45 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd, dims=c(13, 8))
xmantel(dom.xd ~ forest.xd + sitelocation.xd, dims=c(13, 8))

plot(xmgram(dom.xd, sitelocation.xd))
</code></pre>

<hr>
<h2 id='xmgram'>Cross-Mantel correlogram </h2><span id='topic+xmgram'></span>

<h3>Description</h3>

<p>Calculates simple Mantel correlograms from cross-distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmgram(species.xd, space.xd, breaks, nclass, stepsize, equiprobable = FALSE, nperm = 1000,
    mrank = FALSE, alternative = "two.sided", trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmgram_+3A_species.xd">species.xd</code></td>
<td>
<p> non-symmetric square cross-distance matrix. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_space.xd">space.xd</code></td>
<td>
<p> non-symmetric square matrix of geographic distances. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_breaks">breaks</code></td>
<td>
<p> locations of class breaks. If specified, overrides nclass and stepsize. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_nclass">nclass</code></td>
<td>
<p> number of distance classes. If not specified, Sturge's rule will be used
to determine an appropriate number of classes. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_stepsize">stepsize</code></td>
<td>
<p> width of each distance class. If not specified, nclass and the range of space.d will be used to calculate an appropriate default. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_equiprobable">equiprobable</code></td>
<td>
<p> if TRUE, create nclass classes of equal number of distances; if FALSE, create nclass classes of equal width </p>
</td></tr>  
<tr><td><code id="xmgram_+3A_nperm">nperm</code></td>
<td>
<p> number of permutations to use. If set to 0, the permutation test will be omitted. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_mrank">mrank</code></td>
<td>
<p> if this is set to FALSE (the default option), Pearson correlations will be used. If
set to TRUE, the Spearman correlation (correlation ranked distances) will be used. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_alternative">alternative</code></td>
<td>
<p> default is &quot;two.sided&quot;, and returns p-values for H0: rM = 0. The alternative is &quot;one.sided&quot;, which returns p-values for H0: rM &lt;= 0. </p>
</td></tr>
<tr><td><code id="xmgram_+3A_trace">trace</code></td>
<td>
<p> if TRUE, returns progress indicators. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates cross-Mantel correlograms. The Mantel correlogram is essentially a multivariate autocorrelation function.
The Mantel r represents the dissimilarity in variable composition  (often
species composition) at a particular lag distance.
Note that the cross-dissimilarity functions are for research purposes, and are not well-tested.
</p>


<h3>Value</h3>

<p>Returns an object of class mgram, which is a list with two elements.
mgram is a matrix with one row for each distance class and 6 columns:
</p>
<table>
<tr><td><code>lag</code></td>
<td>
<p>midpoint of the distance class.</p>
</td></tr>
<tr><td><code>ngroup</code></td>
<td>
<p>number of distances in that class.</p>
</td></tr>
<tr><td><code>mantelr</code></td>
<td>
<p>Mantel r value.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value for the test chosen.</p>
</td></tr>
</table>
<p>resids is NA for objects calculated by mgram().
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>References</h3>

<p> Legendre, P. and M. Fortin. 1989. Spatial pattern and ecological analysis.
Vegetatio 80:107-138. </p>


<h3>See Also</h3>

<p><code><a href="#topic+xdistance">xdistance</a></code> <code><a href="#topic+xmantel">xmantel</a></code>, <code><a href="#topic+plot.mgram">plot.mgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Need to develop a cross-dissimilarity example
data(graze)

### EXAMPLE 1: Square matrices

# take two subsets of sites with different dominant grass abundances
# use cut-offs that produce equal numbers of sites
dom1 &lt;- subset(graze, POPR &gt; 50 &amp; DAGL &lt; 20) #  8 sites
dom2 &lt;- subset(graze, POPR &lt; 50 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd)
xmantel(dom.xd ~ forest.xd + sitelocation.xd)

plot(xmgram(dom.xd, sitelocation.xd))


### EXAMPLE 2: Non-square matrices

# take two subsets of sites with different dominant grass abundances
# this produces a non-square matrix

dom1 &lt;- subset(graze, POPR &gt; 45 &amp; DAGL &lt; 20) # 13 sites
dom2 &lt;- subset(graze, POPR &lt; 45 &amp; DAGL &gt; 20) #  8 sites

# first two columns are site info
dom.xd &lt;- xdistance(dom1[, -c(1,2)], dom2[, -c(1,2)], "bray")

# environmental and spatial distances; preserve rownames
forest.xd &lt;- xdistance(dom1[, "forestpct", drop=FALSE], 
    dom2[, "forestpct", drop=FALSE])
sitelocation.xd &lt;- xdistance(dom1[, "sitelocation", drop=FALSE], 
    dom2[, "sitelocation", drop=FALSE])

# permutes rows and columns of full nonsymmetric matrix
xmantel(dom.xd ~ forest.xd, dims=c(13, 8))
xmantel(dom.xd ~ forest.xd + sitelocation.xd, dims=c(13, 8))

plot(xmgram(dom.xd, sitelocation.xd))
</code></pre>

<hr>
<h2 id='z.no'>Example for pmgram</h2><span id='topic+z.no'></span>

<h3>Description</h3>

<p>An object of class mgram for use in the example for <code><a href="#topic+pmgram">pmgram</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(z.no)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+pmgram">pmgram</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pmgram">pmgram</a></code>, <code><a href="#topic+z.z1">z.z1</a></code>, </p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Partial pmgram example

# generate a simple surface
# with complex nonlinear spatial pattern

x &lt;- matrix(1:25, nrow=25, ncol=25, byrow=FALSE)
y &lt;- matrix(1:25, nrow=25, ncol=25, byrow=TRUE)

# create z1 and z2 as functions of x, y
# and scale them to [0, 1]
z1 &lt;- x + 3*y
z2 &lt;- y - cos(x)

z1 &lt;- (z1 - min(z1)) / (max(z1) - min(z1))
z2 &lt;- (z2 - min(z2)) / (max(z2) - min(z2))

z12 &lt;- (z1 + z2*2)/3

# look at patterns

layout(matrix(c(
1, 1, 2, 2,
1, 1, 2, 2,
3, 3, 4, 4, 
3, 3, 5, 5), nrow=4, byrow=TRUE))

image(z1, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z2, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z12, col=gray(seq(0, 1, length=20)), zlim=c(0,1))

# analyze the pattern of z across space
z1 &lt;- as.vector(z1)
z2 &lt;- as.vector(z2)
z12 &lt;- as.vector(z12)
z1.d &lt;- dist(z1)
z2.d &lt;- dist(z2)
z12.d &lt;- dist(z12)

space &lt;- cbind(as.vector(x), as.vector(y))
space.d &lt;- dist(space)

# take partial correlogram without effects of z1
### pgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.no &lt;- pmgram(z12.d, space.d, nperm=1000, resids=FALSE)
### save(z.no, file="ecodist/data/z.no.rda")
plot(z.no)

# take partial correlogram of z12 given z1
### pgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.z1 &lt;- pmgram(z12.d, space.d, z2.d, nperm=1000, resids=FALSE)
### save(z.z1, file="ecodist/data/z.z1.rda")
plot(z.z1)
</code></pre>

<hr>
<h2 id='z.z1'>Example for pmgram</h2><span id='topic+z.z1'></span>

<h3>Description</h3>

<p>An object of class mgram for use in the example for <code><a href="#topic+pmgram">pmgram</a></code>. Many of the functions in <code>ecodist</code> take a long time to run, so prepared examples have been included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(z.z1)</code></pre>


<h3>Format</h3>

<p>See <code><a href="#topic+pmgram">pmgram</a></code> for current format specification.
</p>


<h3>Author(s)</h3>

<p> Sarah Goslee </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pmgram">pmgram</a></code>, <code><a href="#topic+z.no">z.no</a></code>, </p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Partial pmgram example

# generate a simple surface
# with complex nonlinear spatial pattern

x &lt;- matrix(1:25, nrow=25, ncol=25, byrow=FALSE)
y &lt;- matrix(1:25, nrow=25, ncol=25, byrow=TRUE)

# create z1 and z2 as functions of x, y
# and scale them to [0, 1]
z1 &lt;- x + 3*y
z2 &lt;- y - cos(x)

z1 &lt;- (z1 - min(z1)) / (max(z1) - min(z1))
z2 &lt;- (z2 - min(z2)) / (max(z2) - min(z2))

z12 &lt;- (z1 + z2*2)/3

# look at patterns

layout(matrix(c(
1, 1, 2, 2,
1, 1, 2, 2,
3, 3, 4, 4, 
3, 3, 5, 5), nrow=4, byrow=TRUE))

image(z1, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z2, col=gray(seq(0, 1, length=20)), zlim=c(0,1))
image(z12, col=gray(seq(0, 1, length=20)), zlim=c(0,1))

# analyze the pattern of z across space
z1 &lt;- as.vector(z1)
z2 &lt;- as.vector(z2)
z12 &lt;- as.vector(z12)
z1.d &lt;- dist(z1)
z2.d &lt;- dist(z2)
z12.d &lt;- dist(z12)

space &lt;- cbind(as.vector(x), as.vector(y))
space.d &lt;- dist(space)

# take partial correlogram without effects of z1
### pgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.no &lt;- pmgram(z12.d, space.d, nperm=1000, resids=FALSE)
### save(z.no, file="ecodist/data/z.no.rda")
plot(z.no)

# take partial correlogram of z12 given z1
### pgram() is time-consuming, so this was generated
### in advance and saved.
### set.seed(1234)
### z.z1 &lt;- pmgram(z12.d, space.d, z2.d, nperm=1000, resids=FALSE)
### save(z.z1, file="ecodist/data/z.z1.rda")
plot(z.z1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
