<!DOCTYPE html><html><head><title>Help for package kpeaks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kpeaks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#findk'>
<p>Estimate the Number of Clusters in a Data Set</p></a></li>
<li><a href='#findpolypeaks'><p>Find the Peaks of a Frequency Polygon</p></a></li>
<li><a href='#genpolygon'><p>Generate the Classes to Build a Frequency Polygon</p></a></li>
<li><a href='#kpeaks-package'><p>Determination of K Using Peak Counts of Features for Clustering</p></a></li>
<li><a href='#plotpolygon'>
<p>Plot Frequency Polygons</p></a></li>
<li><a href='#rmshoulders'>
<p>Shoulders Removal in Frequency Polygons</p></a></li>
<li><a href='#x5p4c'>
<p>Synthetic Data Set contains 5 Variables and 4 Clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Determination of K Using Peak Counts of Features for Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Zeynel Cebeci [aut, cre],
  Cagatay Cebeci [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zeynel Cebeci &lt;zcebeci@cukurova.edu.tr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The number of clusters (k) is needed to start all the partitioning clustering algorithms. An optimal value of this input argument is widely determined by using some internal validity indices. Since most of the existing internal indices suggest a k value which is computed from the clustering results after several runs of a clustering algorithm they are computationally expensive. On the contrary,  the package 'kpeaks' enables to estimate k before running any clustering algorithm. It is based on a simple novel technique using the descriptive statistics of peak counts of the features in a data set.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-08 16:20:22 UTC; user1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-08 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='findk'>
Estimate the Number of Clusters in a Data Set
</h2><span id='topic+findk'></span>

<h3>Description</h3>

<p>Based on some of descriptive statistics of the peak counts in the frequency polygon of a feature, this function proposes a list of estimates of the number of clusters in a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findk(x, binrule, nbins, tcmethod, tc, trmethod, tv, rms=FALSE, rcs=FALSE, tpc=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findk_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="findk_+3A_binrule">binrule</code></td>
<td>
<p>a string specifying the binning rule to compute the number of classes of a frequency polygon.</p>
</td></tr>
<tr><td><code id="findk_+3A_nbins">nbins</code></td>
<td>
<p>an integer specifying the number of classes (bins). It is internally computed according to the selected binning rule except <span class="option">usr</span>. See all available options in <code><a href="#topic+genpolygon">genpolygon</a></code>.</p>
</td></tr>
<tr><td><code id="findk_+3A_tcmethod">tcmethod</code></td>
<td>
<p>a string representing a threshold method to compute a threshold distance value to discard the small or empty bins of a frequency polygon. See all available options in <code><a href="#topic+findpolypeaks">findpolypeaks</a></code>.</p>
</td></tr>
<tr><td><code id="findk_+3A_tc">tc</code></td>
<td>
<p>an integer for threshold frequency value assigned by <code>tcmethod</code>.</p>
</td></tr>
<tr><td><code id="findk_+3A_trmethod">trmethod</code></td>
<td>
<p>a string used to specify a removal method to discard the shoulders around the main peaks in a frequency polygon. See all available options in <code><a href="#topic+rmshoulders">rmshoulders</a></code>.</p>
</td></tr>
<tr><td><code id="findk_+3A_tv">tv</code></td>
<td>
<p>a numeric threshold distance value assigned by <code>trmethod</code>.</p>
</td></tr>
<tr><td><code id="findk_+3A_rms">rms</code></td>
<td>
<p>a logical value whether the shoulders removal is applied or not. Default value is <span class="option">FALSE</span>.</p>
</td></tr>
<tr><td><code id="findk_+3A_rcs">rcs</code></td>
<td>
<p>a logical value whether the estimates of <var>k</var> computed on the reduced counts set instead of the full set. Default value is <span class="option">FALSE</span>, and set to <code>TRUE</code> in order to use the reduced counts set.</p>
</td></tr>
<tr><td><code id="findk_+3A_tpc">tpc</code></td>
<td>
<p>an integer threshold value for creating the reduced set of the peak counts. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>findk</code> returns a list of <var>k</var> values which are proposed as the estimates of the number of clusters in a given data set. The estimation is based on various descriptive statistics of the peak counts in the frequency polygon of the features. Firstly, the classes of frequency polygons of the features are generated by using the function <code><a href="#topic+genpolygon">genpolygon</a></code>. Then, the main peaks in frequency polygons are determined by using the function <code><a href="#topic+findpolypeaks">findpolypeaks</a></code>. If desired, with the function <code><a href="#topic+rmshoulders">rmshoulders</a></code> the shoulder peaks are removed from the peaks matrix returned by the function <code><a href="#topic+findpolypeaks">findpolypeaks</a></code>. In the returned peaks matrix, the peaks are counted for each feature, and a list of estimates of <var>k</var> is produced by using various descriptive statistics of the peak counts.
</p>


<h3>Value</h3>

<p>a list of the estimates of <var>k</var> consists of the following items which are computed from the peak counts of the features in a given data set:
</p>
<table>
<tr><td><code>am</code></td>
<td>
<p>arithmetic mean of peak counts.</p>
</td></tr>
<tr><td><code>med</code></td>
<td>
<p>median of peak counts.</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>mode of peak counts.</p>
</td></tr>
<tr><td><code>cr</code></td>
<td>
<p>center of the range of peak counts.</p>
</td></tr>
<tr><td><code>ciqr</code></td>
<td>
<p>center of the interquartile range (IQR) of peak counts.</p>
</td></tr>
<tr><td><code>mppc</code></td>
<td>
<p>overall mean of the pairwise means of peak counts.</p>
</td></tr>
<tr><td><code>mq3m</code></td>
<td>
<p>mean of the third quartile (Q3) and maximum of peak counts.</p>
</td></tr>
<tr><td><code>mtl</code></td>
<td>
<p>mean of two largest value of peak counts.</p>
</td></tr>
<tr><td><code>avgk</code></td>
<td>
<p>proposed <var>k</var> as the mean of all the estimates.</p>
</td></tr>
<tr><td><code>modk</code></td>
<td>
<p>proposed <var>k</var> as the mode of all the estimates.</p>
</td></tr>
<tr><td><code>mtlk</code></td>
<td>
<p>proposed <var>k</var> as the mean of two largest estimates.</p>
</td></tr>
<tr><td><code>dst</code></td>
<td>
<p>a string representing the type of counts set which is used in computations.</p>
</td></tr>
<tr><td><code>pcounts</code></td>
<td>
<p>an integer vector containing the peak counts of the features.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The input arguments of the function <code>findk</code> usually are the outputs from the functions <code><a href="#topic+findpolypeaks">findpolypeaks</a></code> and <code><a href="#topic+rmshoulders">rmshoulders</a></code>.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci
</p>


<h3>References</h3>

<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;kpeaks: An R Package for Quick Selection of K for Cluster Analysis&quot;, In <em>2018 International Conference on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. 
doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findpolypeaks">findpolypeaks</a></code>, 
<code><a href="#topic+rmshoulders">rmshoulders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate the number of clusters in x5p4c data set
data(x5p4c)
estk &lt;- findk(x5p4c, binrule="sturges")
print(estk)
summary(estk$pcounts)
cat("Estimated the number of clusters as the mean of Q3 and max peak count:", estk$mq3m, fill=TRUE)
cat("Proposed number of clusters based on the mean of two largest estimates:", estk$mtlk, fill=TRUE)

# Estimate the number of clusters in x5p4c data set by using threshold frequency method 'avg' 
# and shoulders removal method 'q1'
estk &lt;- findk(x5p4c, binrule="usr", nbins=15, tcmethod="usr", tc=1, trmethod="avg", rms=TRUE)
print(estk)
summary(estk$pcounts)
cat("Proposed number of clusters based on the mean of two largest estimates:", estk$mtlk, fill=TRUE)

# Estimate the number of clusters in iris data set
data(iris)
estk &lt;- findk(iris[,1:4], binrule="bc", rcs=FALSE)
print(estk)
summary(estk$pcounts)
cat("Proposed number of clusters based on the mean of estimates:", estk$avgk, fill=TRUE)
cat("Proposed number of clusters based on the mode of estimates:", estk$modk, fill=TRUE)
cat("Proposed number of clusters based on the mean of two largest estimates:", estk$mtlk, fill=TRUE)
</code></pre>

<hr>
<h2 id='findpolypeaks'>Find the Peaks of a Frequency Polygon</h2><span id='topic+findpolypeaks'></span>

<h3>Description</h3>

<p>Frequency polygons are graphics to reveal the shapes of data distributions as histograms do. The peaks of frequency polygons are required in several data mining applications. <code>findpolypeaks</code> finds the peaks in a frequency polygon by using the frequencies and middles values of the classes of it.</p>


<h3>Usage</h3>

<pre><code class='language-R'>findpolypeaks(xm, xc, tcmethod, tc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findpolypeaks_+3A_xm">xm</code></td>
<td>
<p>a numeric vector contains the middle values of the classes of the frequency polygon (or the bins of a histogram).</p>
</td></tr>
<tr><td><code id="findpolypeaks_+3A_xc">xc</code></td>
<td>
<p>an integer vector contains the frequencies of the classes of the frequency polygon.</p>
</td></tr>
<tr><td><code id="findpolypeaks_+3A_tcmethod">tcmethod</code></td>
<td>
<p>a string represents the threshold method to discard the empty and the small bins whose frequencies are smaller than a threshold frequency value. Default method is <span class="option">usr</span>. Alternatively, the methods given below can be used to compute a threshold frequency value using the descriptive statistics of the frequencies in <code>xc</code>.
</p>

<ul>
<li> <p><span class="option">sd1</span> and <span class="option">sd2</span> use the standard deviation.
</p>
</li>
<li> <p><span class="option">q1</span> uses the first quartile (Q1).
</p>
</li>
<li> <p><span class="option">iqr</span> uses the interquartile range (IQR).
</p>
</li>
<li> <p><span class="option">avg</span> uses the arithmetic mean.
</p>
</li>
<li> <p><span class="option">min</span> and <span class="option">min2</span> use the minimum.
</p>
</li>
<li> <p><span class="option">log2</span> uses the two-base logarithm of <var>n</var>, vector size.
</p>
</li>
<li> <p><span class="option">usr</span> uses a user-specified value.</p>
</li></ul>
</td></tr>
<tr><td><code id="findpolypeaks_+3A_tc">tc</code></td>
<td>
<p>an integer which is used as the threshold frequency value for discarding the empty and small height classes in the frequency polygon. Default value is 1 if the threshold option <span class="option">usr</span> is chosen. Depending on the selected methods, the value of <code>tc</code> equals to: 
</p>

<ul>
<li><p> one standart deviation with the method <span class="option">sd1</span>, 
</p>
</li>
<li><p> one quarter of the standart deviation with the method <span class="option">sd2</span>, 
</p>
</li>
<li><p> the first quartile with the method <span class="option">q1</span>,
</p>
</li>
<li><p> one quarter of the interquartile range with method <span class="option">iqr</span>,
</p>
</li>
<li><p> 10% of the arithmetic mean with the method <span class="option">avg</span>, 
</p>
</li>
<li><p> the minimum value with the method <span class="option">min</span>, 
</p>
</li>
<li><p> two times of minimum with method <span class="option">min2</span>,
</p>
</li>
<li><p> two-base logarithm of the number of classes divided by ten with the method <span class="option">log2</span>,
</p>
</li>
<li><p> an arbitrary number specified with the method <span class="option">usr</span>.</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The peaks are determined after removing the empty and small height classes whose frequencies are below the chosen threshold frequency. Default threshold value is 1 that means that all the classes which have frequencies of 0 and 1 are removed in the input vectors <code>xm</code> and <code>xc</code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>pm</code></td>
<td>
<p>a data frame with two columns which are <var>pvalues</var> and <var>pfreqs</var> containing the middle values and frequencies of the peaks which determined in the frequency polygon, respectively.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>an integer representing the number of peaks in the frequency polygon.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci</p>


<h3>References</h3>

<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;kpeaks: An R Package for Quick Selection of K for Cluster Analysis&quot;, In <em>2018 International Conference on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. 
doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findk">findk</a></code>,
<code><a href="#topic+genpolygon">genpolygon</a></code>,
<code><a href="#topic+rmshoulders">rmshoulders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x5p4c)
# Using a user-specified number of bins, build the frequency polygon of p2 in the data set x5p4c
hvals &lt;- genpolygon(x5p4c$p2, binrule="usr", nbins=20)
plotpolygon(x5p4c$p2, nbins=hvals$nbins, ptype="ph")

# Find the peaks in the frequency polygon by using the threshold method min
resfpp1 &lt;- findpolypeaks(hvals$mids, hvals$freqs, tcmethod="min")
print(resfpp1)

# Find the peaks in the frequency polygon by using the threshold equals to 5
resfpp2 &lt;- findpolypeaks(hvals$mids, hvals$freqs, tcmethod="usr", tc=5)
print(resfpp2)

data(iris)
# By using Doane rule, build the frequency polygon of the 4th feature in the data set iris
hvals &lt;- genpolygon(iris[,4], binrule="doane")
plotpolygon(iris[,4], nbins=hvals$nbins, ptype="p")

#Find the peaks in the frequency polygon by using the threshold method avg
resfpp3 &lt;- findpolypeaks(hvals$mids, hvals$freqs, tcmethod="avg")
print(resfpp3)
</code></pre>

<hr>
<h2 id='genpolygon'>Generate the Classes to Build a Frequency Polygon</h2><span id='topic+genpolygon'></span>

<h3>Description</h3>

<p>Constructs the histogram of a feature by using a selected binning rule, returns the middle values and frequencies of classes for further works on the frequency polygon.</p>


<h3>Usage</h3>

<pre><code class='language-R'>genpolygon(x, binrule, nbins, disp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genpolygon_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the observations for a feature.</p>
</td></tr>
<tr><td><code id="genpolygon_+3A_binrule">binrule</code></td>
<td>
<p>name of the rule in order to compute the number of bins to build the histogram.</p>
</td></tr>
<tr><td><code id="genpolygon_+3A_nbins">nbins</code></td>
<td>
<p>an integer representing the number of bins which is computed by using the selected binning rule. Default rule is <span class="option">sturges</span>. Depending on the selected rule <code>nbins</code> equals to (In the formulae, <code>n</code> is the number of observations.):
</p>

<ul>
<li> <p><code>floor(sqrt(n))</code> if the rule is <span class="option">sqr</span>,
</p>
</li>
<li> <p><code>ceiling(1+log(n, 2))</code> if the rule is <span class="option">sturges</span>,
</p>
</li>
<li> <p><code>ceiling(1+3.332*log(n, 10))</code> if the rule is <span class="option">huntsberger</span>,
</p>
</li>
<li> <p><code>ceiling(5*log(n, 10))</code> if the rule is <span class="option">bc</span>,
</p>
</li>
<li> <p><code>ceiling(n^(1/3))</code> if the rule is <span class="option">cencov</span>,
</p>
</li>
<li> <p><code>ceiling(2*n^(1/3))</code> if the rule is <span class="option">rice</span>,
</p>
</li>
<li> <p><code>ceiling((2*n)^(1/3))</code> if the rule is <span class="option">ts</span>,
</p>
</li>
<li> <p><code>ceiling(((max(x)-min(x))/(3.5*sqrt(var(x))*n^(-1/3))))</code> if the rule is <span class="option">scott</span>,
</p>
</li>
<li> <p><code>ceiling(((max(x)-min(x))/(2*IQR(x)*n^(-1/3)))</code> if the rule is <span class="option">fd</span>,
</p>
</li>
<li> <p><code>ceiling(1+log(n,2)+log(1+abs(skewness(x))/(6*(n-2)/((n+1)*(n+3))^0.5),2))</code> if the rule is <span class="option">doane</span>,
</p>
</li>
<li> <p><code>ceiling(log(n)/2*pi)</code> if the rule is <span class="option">cebeci</span>,
</p>
</li>
<li><p> a user-specified integer if the rule is <span class="option">usr</span>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="genpolygon_+3A_disp">disp</code></td>
<td>
<p>a logical value should be set to <code>TRUE</code> to display the histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to Hyndman (1995), Sturges's rule was the first rule to calculate <var>k</var>, the number of classes to build a histogram. Most of the statistical packages use this simple rule for determining the number of classes in constructing histograms. Brooks &amp; Carruthers (1953) proposed a rule using <code class="reqn">log_{10}</code> instead of <code class="reqn">log_{2}</code> giving always larger <var>k</var> when compared to Sturges's rule.  The rule by Huntsberger (1962) yields nearly equal result to those of Sturges's rule. These two rules work well if <var>n</var> is less than 200. Scott (1992) argued that Sturges's rule leads to generate oversmoothed histograms in case of large number of <var>n</var>. In his rule, Cencov (1962) used the cube root of <var>n</var> simply. This rule was followed by its extensions, i.e., Rice rule and Terrell &amp; Scott (1985) rule.  When compared to the others, the square root rule produces larger <var>k</var> (Davies &amp; Goldsmith, 1980).<br /><br />
Most of the rules simply include only <var>n</var> as the input argument. On the other hand, the rules using variation and shape of data distributions can provide more optimal <var>k</var> values. For instance, Doane (1976) extended the Sturges's rule by adding the standardized skewness in order to overcome the problem with non-normal distributions need more classes. In order to estimate optimal <var>k</var> values, Scott (1979) added the standard deviation to his formula. Freedman and Diaconis (1981) proposed to use the interquartile range (IQR) statistic which is less sensitive to outliers than the standard deviation. In a study on unsupervised discretization methods, Cebeci &amp; Yildiz (2017) tested a binning rule formula based on the ten-base logarithm of <var>n</var> divided by <code>2*pi</code>. They also argued that the rules Freedman-Diaconis and Doane were slightly performed better than the other rules based on the training model accuracies on a chicken egg quality traits dataset. Therefore, using the above mentioned rules may be more effective in determining the peaks of a frequency polygon. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>xm</code></td>
<td>
<p>a numeric vector containing the middle values of bins.</p>
</td></tr>
<tr><td><code>xc</code></td>
<td>
<p>an integer vector containing the frequencies of the bins.</p>
</td></tr>
<tr><td><code>nbins</code></td>
<td>
<p>an integer containing the number of bins to build the histogram.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci</p>


<h3>References</h3>

<p>Brooks C E P &amp; Carruthers N (1953). Handbook of statistical methods in meteorology. H M Stationary Office, London.
</p>
<p>Cebeci Z &amp; Yildiz F (2017). Unsupervised discretization of continuous variables in a chicken egg quality traits dataset. <em>Turk. J Agriculture-Food Sci. &amp; Tech.</em> 5(4): 315-320. doi: <a href="https://doi.org/10.24925/turjaf.v5i4.315-320.1056">10.24925/turjaf.v5i4.315-320.1056</a>.
</p>
<p>Cebeci Z &amp; Cebeci C (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci Z &amp; Cebeci C (2018). &quot;kpeaks: An R package for quick selection of k for cluster analysis&quot;, In <em>2018 Int. Conf. on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>
<p>Cencov N N (1962). Evaluation of an unknown distribution density from observations. <em>Soviet Mathematics</em> 3: 1559-1562.
</p>
<p>Davies O L &amp; Goldsmith P L (1980). Statistical methods in research and production. 4th edn, Longman: London.
</p>
<p>Doane D P (1976). Aesthetic frequency classification. <em>American Statistician</em> 30(4):181-183.
</p>
<p>Freedman D &amp; Diaconis P (1981). On the histogram as a density estimator: L2 Theory. <em>Zeit. Wahr. ver. Geb.</em> 57(4):453-476.
</p>
<p>Hyndman R J (1995). The problem with Sturges rule for constructing histograms. url:<a href="http://robjhyndman.com/papers/sturges.pdf">http://robjhyndman.com/papers/sturges.pdf</a>. 
</p>
<p>Huntsberger D V (1962). Elements of statistical inference. London: Prentice-Hall.
</p>
<p>Scott D W (1992). Multivariate density estimation: Theory, Practice and Visualization. John Wiley &amp; Sons: New York.
</p>
<p>Sturges H (1926). The choice of a class-interval. <em>J Amer. Statist. Assoc.</em> 21(153):65-66.
</p>
<p>Terrell G R &amp; Scott D W (1985). Oversmoothed nonparametric density estimates. <em>J Amer. Statist. Assoc.</em> 80(389):209-214. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findk">findk</a></code>, 
<code><a href="#topic+findpolypeaks">findpolypeaks</a></code>, 
<code><a href="#topic+plotpolygon">plotpolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(n=100, mean=5, sd=0.5)
# Construct the histogram of x according to the Sturges rule with no display
hvals &lt;- genpolygon(x, binrule = "sturges")
print(hvals)

# Plot the histogram of x by using the user-specified number of classes
hvals &lt;- genpolygon(x, binrule = "usr", nbins = 20, disp = TRUE)
print(hvals)

# Plot the histogram of the second feature in iris dataset 
# by using the Freedman-Diaconis (fd) rule
data(iris)
hvals &lt;- genpolygon(iris[,2], binrule = "fd", disp = TRUE)
print(hvals)
</code></pre>

<hr>
<h2 id='kpeaks-package'>Determination of K Using Peak Counts of Features for Clustering</h2><span id='topic+kpeaks-package'></span>

<h3>Description</h3>

<p>The input argument <var>k</var>, represents the number of clusters is needed to start all the partitioning clustering algorithms. In unsupervised learning applications, an optimal value of this argument is widely determined by using the internal validity indexes. Since these indexes suggest a <var>k</var> value which is computed on the clustering results obtained with several runs of a clustering algorithm, they are computationally expensive. On the contrary, the package '<span class="pkg">kpeaks</span>' enables to estimate <var>k</var> before running any clustering algorithm. It is based on a simple novel technique using the descriptive statistics of peak counts of the features in a dataset.</p>


<h3>Details</h3>

<p>The package '<span class="pkg">kpeaks</span>' contains five functions and one synthetically created dataset for testing purposes. In order to suggest an estimate of <var>k</var>, the function <code><a href="#topic+findk">findk</a></code> internally calls the functions <code><a href="#topic+genpolygon">genpolygon</a></code> and <code><a href="#topic+findpolypeaks">findpolypeaks</a></code>, respectively. The frequency polygons can be visually inspected by using the function <code><a href="#topic+plotpolygon">plotpolygon</a></code>. Using the function <code><a href="#topic+rmshoulders">rmshoulders</a></code> is recommended to flatten or remove the the shoulder peaks around the main peaks of a frequency polygon, if any.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci</p>


<h3>References</h3>

<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;kpeaks: An R Package for Quick Selection of K for Cluster Analysis&quot;, In <em>2018 International Conference on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. 
doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findk">findk</a></code>,
<code><a href="#topic+findpolypeaks">findpolypeaks</a></code>,
<code><a href="#topic+genpolygon">genpolygon</a></code>,
<code><a href="#topic+plotpolygon">plotpolygon</a></code>,
<code><a href="#topic+rmshoulders">rmshoulders</a></code>
</p>

<hr>
<h2 id='plotpolygon'>
Plot Frequency Polygons
</h2><span id='topic+plotpolygon'></span>

<h3>Description</h3>

<p>Plots the frequency polygon and histogram of a feature with some options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpolygon(x, nbins, ptype, bcol = "gray", pcol = "blue")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpolygon_+3A_x">x</code></td>
<td>

<p>a numeric vector containing the observations of a feature, or a numeric matrix when <code>ptype</code> is <span class="option">sp</span>.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_nbins">nbins</code></td>
<td>

<p>an integer for the number of classes in the frequency polygon.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_bcol">bcol</code></td>
<td>

<p>a string for the color of bins. Default is <span class="option">gray</span>.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_pcol">pcol</code></td>
<td>

<p>a string for the color of polygon lines. Default is <span class="option">blue</span>.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_ptype">ptype</code></td>
<td>

<p>a string specifying the type of plot. Use <span class="option">p</span> for plotting the polygon only or <span class="option">ph</span> for plotting the polygon with the histogram. Default is <span class="option">sp</span> for the scatterplots between the pairs of features and the polygons on the diagonal panel.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci
</p>


<h3>References</h3>

<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;kpeaks: An R Package for Quick Selection of K for Cluster Analysis&quot;, In <em>2018 International Conference on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. 
doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genpolygon">genpolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot the frequency polygon of the 2nd feature in x5p4c data set
data(x5p4c)
hvals &lt;- genpolygon(x5p4c[,2], binrule="usr", nbins=20)

# plot the frequency polygon of the 2nd feature in x5p4c data set
plotpolygon(x5p4c[,2], nbins=hvals$nbins, ptype="p")

# plot the histogram and frequency polygon of the 2nd feature in x5p4c data set
plotpolygon(x5p4c[,2], nbins=hvals$nbins, ptype="ph", bcol="orange", pcol="blue")

# plot the pairwise scatter plots of the features in x5p4c data set
pairs(x5p4c, diag.panel=plotpolygon, upper.panel=NULL, cex.labels=1.5)

# plot the histogram and frequency polygon of Petal.Width in iris data set 
data(iris)
hvals &lt;- genpolygon(iris$Petal.Width, binrule="doane")
plotpolygon(iris$Petal.Width, nbins=hvals$nbins, ptype="ph")
</code></pre>

<hr>
<h2 id='rmshoulders'>
Shoulders Removal in Frequency Polygons
</h2><span id='topic+rmshoulders'></span>

<h3>Description</h3>

<p>Removes the shoulders around the main peaks in a frequency polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmshoulders(xm, xc, trmethod, tv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmshoulders_+3A_xm">xm</code></td>
<td>

<p>a numeric vector containing the middle values of peaks of a frequency polygon.
</p>
</td></tr>
<tr><td><code id="rmshoulders_+3A_xc">xc</code></td>
<td>

<p>an integer vector containing the frequencies of peaks of a frequency polygon.
</p>
</td></tr>
<tr><td><code id="rmshoulders_+3A_trmethod">trmethod</code></td>
<td>
<p>a string representing the type of shoulders removal option for computing a threshold value. Default method is <span class="option">usr</span>. The alternatives are <span class="option">sd</span>, <span class="option">q1</span>, <span class="option">iqr</span>, <span class="option">avg</span> and <span class="option">med</span>. These methods compute the threshold distance value using some statistics of the distances between the middle values of two successive peaks in the vector <code>xm</code>.
</p>

<ul>
<li> <p><span class="option">sd</span> uses the standard deviation.
</p>
</li>
<li> <p><span class="option">q1</span> uses the first quartile (Q1).
</p>
</li>
<li> <p><span class="option">q3</span> uses the third quartile (Q3).
</p>
</li>
<li> <p><span class="option">iqr</span> uses the interquartile range (IQR).
</p>
</li>
<li> <p><span class="option">avg</span> uses the arithmetic mean.
</p>
</li>
<li> <p><span class="option">med</span> uses the median.
</p>
</li>
<li> <p><span class="option">usr</span> uses a user-specified number.
</p>
</li></ul>

</td></tr>
<tr><td><code id="rmshoulders_+3A_tv">tv</code></td>
<td>
<p>a numeric value to be used as the threshold distance for deciding the shoulders. Default threshold is 1 if the removal method <span class="option">usr</span> is chosen. Depending on the selected removal method <code>tv</code> equals to:
</p>

<ul>
<li><p> one standart deviation if <code>trmethod</code> is <span class="option">sd</span>,
</p>
</li>
<li><p> the first quartile if <code>trmethod</code> is <span class="option">q1</span>, 
</p>
</li>
<li><p> the third quartile if <code>trmethod</code> is <span class="option">q3</span>, 
</p>
</li>
<li><p> one quarter of the interquartile range if <code>trmethod</code> is <span class="option">iqr</span>, 
</p>
</li>
<li><p> the arithmetic mean if <code>trmethod</code> is <span class="option">avg</span>,
</p>
</li>
<li><p> the median if <code>trmethod</code> is <span class="option">med</span>,
</p>
</li>
<li><p> a user-specified number if <code>trmethod</code> is <span class="option">usr</span>. 
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Literally speaking, a <dfn>shoulder peak</dfn> or shortly <dfn>shoulder</dfn> is a secondary peak in a close location before or after the main peak of a mountain. In a frequency polygon, a shoulder is a smaller peak that is quite close to a higher peak resulting a non-obvious valley between them. Shoulders may occur randomly due to some reasons such as random noises or selecting higher number of classes in histogram building etc. Usually, it is desired to remove them from the peaks vector of a frequency polygon. In '<span class="pkg">kpeaks</span>', a peak considered as a shoulder when its height is smaller than the height of its neighbor peak and its distance to its neighbor is also lower than a threshold distance value. In order to compute a threshold distance value, here, we propose to use seven options as listed in the section &lsquo;arguments&rsquo;. The options <code>q1</code> and <code>iqr</code> can be applied to remove the minor shoulders that are very near to the main peaks while <code>q3</code> is recommended to eliminate the substantial shoulders in the processed frequency polygon. The remaining options may be more efficient for removing the moderate shoulders.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pm</code></td>
<td>
<p>a data frame with two columns whose names are <var>pvalues</var> and <var>pfreqs</var> for the middle values and the frequencies of the peaks after removal process, respectively.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>an integer representing the number of peaks after removal of the shoulders.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code>rmshoulders</code> normally should be called with the input values that are returned by the function <code><a href="#topic+findpolypeaks">findpolypeaks</a></code>.
</p>


<h3>Author(s)</h3>

<p>Zeynel Cebeci, Cagatay Cebeci
</p>


<h3>References</h3>

<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;A novel technique for fast determination of K in partitioning cluster analysis&quot;, <em>Journal of Agricultural Informatics</em>, 9(2), 1-11. 
doi: <a href="https://doi.org/10.17700/jai.2018.9.2.442">10.17700/jai.2018.9.2.442</a>.
</p>
<p>Cebeci, Z. &amp; Cebeci, C. (2018). &quot;kpeaks: An R Package for Quick Selection of K for Cluster Analysis&quot;, In <em>2018 International Conference on Artificial Intelligence and Data Processing (IDAP)</em>, IEEE. 
doi: <a href="https://doi.org/10.1109/IDAP.2018.8620896">10.1109/IDAP.2018.8620896</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findpolypeaks">findpolypeaks</a></code>,
<code><a href="#topic+plotpolygon">plotpolygon</a></code>,
<code><a href="#topic+genpolygon">genpolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a data vector with three peaks
x1 &lt;-rnorm(100, mean=20, sd=5)
x2 &lt;-rnorm(50, mean=50, sd=5)
x3 &lt;-rnorm(150, mean=90, sd=10)
x &lt;- c(x1,x3,x2)

# generate the frequency polygon and histogram of x by using Doane rule
hvals &lt;- genpolygon(x, binrule="doane")
plotpolygon(x, nbins=hvals$nbins, ptype="p")

# find the peaks in frequency polygon of x by using the default threshold frequency
resfpp &lt;- findpolypeaks(xm=hvals$mids, xc=hvals$freqs)
print(resfpp)

# remove the shoulders with the threshold distance option 'avg'
resrs &lt;- rmshoulders(resfpp$pm[,1], resfpp$pm[,2], trmethod = "avg")
print(resrs)

# remove the shoulders with the threshold distance option 'iqr'
resrs &lt;- rmshoulders(resfpp$pm[,1], resfpp$pm[,2], trmethod = "iqr")
print(resrs)

data(x5p4c)
# plot the frequnecy polygon and histogram of p2 in x5p4c data set 
hvals &lt;- genpolygon(x5p4c$p2, binrule="usr", nbins=30)
plotpolygon(x5p4c$p2, nbins=hvals$nbins, ptype="ph")

# find the peaks in frequency polygon of p2 
resfpp &lt;- findpolypeaks(xm=hvals$mids, xc=hvals$freqs, tcmethod = "min")
print(resfpp)

# remove the shoulders with threshold distance option 'q1'
resrs &lt;- rmshoulders(resfpp$pm[,1], resfpp$pm[,2], trmethod = "q1")
print(resrs)

## Not run: 
data(iris)
# plot the frequency polygon and histogram of Petal.Length in iris data set 
# by using a user-defined class number 
hvals &lt;- genpolygon(iris$Petal.Length, binrule="usr", nbins=30)
plotpolygon(iris$Petal.Length, nbins=hvals$nbins, ptype="p")

# find the peaks in frequency polygon of Petal.Length with default 
# threshold frequency value
resfpp &lt;- findpolypeaks(xm=hvals$mids, xc=hvals$freqs)
print(resfpp)

# remove the shoulders with threshold option 'med'
resrs &lt;- rmshoulders(resfpp$pm[,1], resfpp$pm[,2], trmethod = "med")
print(resrs)

## End(Not run)
</code></pre>

<hr>
<h2 id='x5p4c'>
Synthetic Data Set contains 5 Variables and 4 Clusters 
</h2><span id='topic+x5p4c'></span>

<h3>Description</h3>

<p>A synthetically created data frame consists of five continous variables forming four clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(x5p4c)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 5 numeric variables:
</p>

<dl>
<dt>p1</dt><dd><p>a continous variable with one mode</p>
</dd>
<dt>p2</dt><dd><p>a continous variable with four modes</p>
</dd>
<dt>p3</dt><dd><p>a continous variable with two modes</p>
</dd>
<dt>p4</dt><dd><p>a continous variable with three modes</p>
</dd>
<dt>p5</dt><dd><p>a continous variable with two modes</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data set <code>x5p4c</code> is recommended to use in comparing the performances of the internal validity indexes in cluster analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(x5p4c)
# descriptive statistics of the variables
summary(x5p4c)
# plot the histogram of the variable p2
hist(x5p4c$p2, breaks=15)
# scatter plots of the variable pairs
pairs(x5p4c)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
