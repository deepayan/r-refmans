<!DOCTYPE html><html><head><title>Help for package pmclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pmclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign.N.sample'><p>Obtain a Set of Random Samples for X.spmd</p></a></li>
<li><a href='#EM-like algorithms'><p>EM-like Steps for GBD</p></a></li>
<li><a href='#generate.basic'><p>Generate Examples for Testing</p></a></li>
<li><a href='#generate.MixSim'><p>Generate MixSim Examples for Testing</p></a></li>
<li><a href='#get.N.CLASS'><p>Obtain Total Elements for Every Clusters</p></a></li>
<li><a href='#Independent logL'><p>Independent Function for Log Likelihood</p></a></li>
<li><a href='#Initialization'><p>Initialization for EM-like Algorithms</p></a></li>
<li><a href='#Internal Functions'><p> All Internal Functions</p></a></li>
<li><a href='#mb.print'><p>Print Results of Model-Based Clustering</p></a></li>
<li><a href='#One E-Step'><p>Compute One E-step and Log Likelihood Based on Current Parameters</p></a></li>
<li><a href='#One M-Step'><p>Compute One M-Step Based on Current Posterior Probabilities</p></a></li>
<li><a href='#One Step of EM algorithm'><p>One EM Step for GBD</p></a></li>
<li><a href='#pmclust and pkmeans'><p>Parallel Model-Based Clustering and Parallel K-means Algorithm</p></a></li>
<li><a href='#pmclust-package'><p>Parallel Model-Based Clustering</p></a></li>
<li><a href='#print.object'><p>Functions for Printing or Summarizing Objects According to Classes</p></a></li>
<li><a href='#Read Me First'><p>Read Me First Function</p></a></li>
<li><a href='#Set Global Variables'><p>Set Global Variables According to the global matrix X.gbd (X.spmd)</p></a></li>
<li><a href='#Set of CONTROL'><p>A Set of Controls in Model-Based Clustering.</p></a></li>
<li><a href='#Set of PARAM'><p>A Set of Parameters in Model-Based Clustering.</p></a></li>
<li><a href='#Update Class of EM or Kmenas Results'><p>Update CLASS.spmd Based on the Final Iteration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Model-Based Clustering using
Expectation-Gathering-Maximization Algorithm for Finite Mixture
Gaussian Model</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), pbdMPI (&ge; 0.4-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, MASS</td>
</tr>
<tr>
<td>Enhances:</td>
<td>MixSim</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Aims to utilize model-based clustering (unsupervised)
        for high dimensional and ultra large data, especially in a distributed
        manner. The code employs 'pbdMPI' to perform a
        expectation-gathering-maximization algorithm
        for finite mixture Gaussian
        models. The unstructured dispersion matrices are assumed in the
        Gaussian models. The implementation is default in the single program
        multiple data programming model. The code can be executed
        through 'pbdMPI' and MPI' implementations such as 'OpenMPI'
        and 'MPICH'.
        See the High Performance Statistical Computing website
	<a href="https://snoweye.github.io/hpsc/">https://snoweye.github.io/hpsc/</a>
	for more information, documents and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pbdr.org/">https://pbdr.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/pmclust/issues">https://github.com/snoweye/pmclust/issues</a></td>
</tr>
<tr>
<td>MailingList:</td>
<td>Please send questions and comments to wccsnow@gmail.com</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-10 03:12:30 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  George Ostrouchov [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-11 14:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign.N.sample'>Obtain a Set of Random Samples for X.spmd</h2><span id='topic+assign.N.sample'></span>

<h3>Description</h3>

<p>This utility function samples data randomly from <code><a href="#topic+X.spmd">X.spmd</a></code>
to form a relatively small subset of original data. The EM algorithm on the
smaller subset is topically performing fast and capturing rough structures of
entire dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  assign.N.sample(total.sample = 5000, N.org.spmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign.N.sample_+3A_total.sample">total.sample</code></td>
<td>
<p>a total number of samples which will be selected from
the original data <code><a href="#topic+X.spmd">X.spmd</a></code>.</p>
</td></tr>
<tr><td><code id="assign.N.sample_+3A_n.org.spmd">N.org.spmd</code></td>
<td>
<p>the original data size,
i.e. <code>nrow(<a href="#topic+X.spmd">X.spmd</a>)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function performs simple random sampling without replacement
for the original dataset <code><a href="#topic+X.spmd">X.spmd</a></code>. Different random seeds should
be set before calling this function.
</p>


<h3>Value</h3>

<p>A list variable will be returned and containing:
</p>

<table>
<tr>
 <td style="text-align: left;"><code>N</code>          </td><td style="text-align: left;"> total sample size across all
                                    <code class="reqn">S</code> processors </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.spmd</code>     </td><td style="text-align: left;"> sample size of given processor </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.allspmds</code> </td><td style="text-align: left;"> a collection of sample sizes for all
                                    <code class="reqn">S</code> processors </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>ID.spmd</code>    </td><td style="text-align: left;"> index of selected samples ranged from 1
                                    to <code>N.org.spmd</code>
</td>
</tr>

</table>

<p>Note that <code>N</code> and <code>N.allspmds</code> are the same across all
<code class="reqn">S</code> processors, but <code>N.spmd</code> and <code>ID.spmd</code> are most
likely all distinct. The lengths of these elements are <code class="reqn">1</code> for
<code>N</code> and <code>N.spmd</code>, <code class="reqn">S</code> for <code>N.allspmd</code>, and
<code>N.spmd</code> for <code>ID.spmd</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Save code in a file "demo.r" and run in 4 processors by
# &gt; mpiexec -np 4 Rscript demo.r

### Setup environment.
library(pmclust, quiet = TRUE)
comm.set.seed(123)

### Generate an example data.
N.org.spmd &lt;- 5000 + sample(1:1000, 1)
ret.spmd &lt;- assign.N.sample(total.sample = 5000, N.org.spmd)
cat("Rank:", comm.rank(), " Size:", ret.spmd$N.spmd,
    "\n", sep = "")

### Quit.
finalize()

## End(Not run)
</code></pre>

<hr>
<h2 id='EM-like+20algorithms'>EM-like Steps for GBD</h2><span id='topic+em.step'></span><span id='topic+aecm.step'></span><span id='topic+apecm.step'></span><span id='topic+apecma.step'></span><span id='topic+kmeans.step'></span>

<h3>Description</h3>

<p>The EM-like algorithm for model-based clustering of finite mixture Gaussian
models with unstructured dispersions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  em.step(PARAM.org)
  aecm.step(PARAM.org)
  apecm.step(PARAM.org)
  apecma.step(PARAM.org)
  kmeans.step(PARAM.org)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM-like+2B20algorithms_+3A_param.org">PARAM.org</code></td>
<td>
<p>an original set of parameters generated
by <code><a href="#topic+set.global">set.global</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A global variable called <code><a href="#topic+X.spmd">X.spmd</a></code> should exist in the
<code><a href="#topic+.pmclustEnv">.pmclustEnv</a></code>
environment, usually the working environment. The <code><a href="#topic+X.spmd">X.spmd</a></code>
is the data matrix to be clustered, and this matrix has a dimension
<code>N.spmd</code> by <code>p</code>.
</p>
<p>A <code>PARAM.org</code> will be a local variable inside all EM-linke functions
<code><a href="#topic+em.step">em.step</a></code>, <code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <code><a href="#topic+apecma.step">apecma.step</a></code>, and
<code><a href="#topic+kmeans.step">kmeans.step</a></code>,
This variable is a list containing all parameters related to models.
This function also updates in the parameters by the EM-like algorithms, and
return the convergent results. The details of list elements are initially
generated by <code><a href="#topic+set.global">set.global</a></code>.
</p>


<h3>Value</h3>

<p>A convergent results will be returned the other list variable
containing all new parameters which represent the components of models.
See the help page of <code><a href="#topic+PARAM">PARAM</a></code> or <code><a href="#topic+PARAM.org">PARAM.org</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>
<p>Chen, W.-C. and Maitra, R. (2011)
&ldquo;Model-based clustering of regression time series data via
APECM &ndash; an AECM algorithm sung to an even faster beat&rdquo;,
<em>Statistical Analysis and Data Mining</em>,
<b>4</b>, 567-578.
</p>
<p>Chen, W.-C., Ostrouchov, G., Pugmire, D., Prabhat, M., and Wehner, M. (2013)
&ldquo;A Parallel EM Algorithm for Model-Based Clustering with
Application to Explore Large Spatio-Temporal Data&rdquo;,
<em>Technometrics</em>,
(revision).
</p>
<p>Dempster, A.P., Laird, N.M. and Rubin, D.B. (1977)
&ldquo;Maximum Likelihood from Incomplete Data via the EM Algorithm&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>,
<b>39</b>, 1-38.
</p>
<p>Lloyd., S. P. (1982)
&ldquo;Least squares quantization in PCM&rdquo;,
<em>IEEE Transactions on Information Theory</em>,
<b>28</b>, 129-137.
</p>
<p>Meng, X.-L. and Van Dyk, D. (1997)
&ldquo;The EM Algorithm.an Old Folk-song Sung to a Fast New Tune&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>,
<b>59</b>, 511-567.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+mb.print">mb.print</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Save code in a file "demo.r" and run in 4 processors by
# &gt; mpiexec -np 4 Rscript demo.r

### Setup environment.
library(pmclust, quiet = TRUE)
comm.set.seed(123)

### Generate an example data.
N.allspmds &lt;- rep(5000, comm.size())
N.spmd &lt;- 5000
N.K.spmd &lt;- c(2000, 3000)
N &lt;- 5000 * comm.size()
p &lt;- 2
K &lt;- 2
data.spmd &lt;- generate.basic(N.allspmds, N.spmd, N.K.spmd, N, p, K)
X.spmd &lt;- data.spmd$X.spmd

### Run clustering.
PARAM.org &lt;- set.global(K = K)          # Set global storages.
# PARAM.org &lt;- initial.em(PARAM.org)    # One initial.
PARAM.org &lt;- initial.RndEM(PARAM.org)   # Ten initials by default.
PARAM.new &lt;- apecma.step(PARAM.org)     # Run APECMa.
em.update.class()                       # Get classification.

### Get results.
N.CLASS &lt;- get.N.CLASS(K)
comm.cat("# of class:", N.CLASS, "\n")

### Quit.
finalize()

## End(Not run)
</code></pre>

<hr>
<h2 id='generate.basic'>Generate Examples for Testing</h2><span id='topic+generate.basic'></span>

<h3>Description</h3>

<p>This function will generate a small set of data for testing algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generate.basic(N.allspmds, N.spmd, N.K.spmd, N, p, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.basic_+3A_n.allspmds">N.allspmds</code></td>
<td>
<p>a collection of sample sizes for all
<code class="reqn">S</code> processors, i.e. a vector of
length <code class="reqn">S</code>.</p>
</td></tr>
<tr><td><code id="generate.basic_+3A_n.spmd">N.spmd</code></td>
<td>
<p>total sample size of given processor.</p>
</td></tr>
<tr><td><code id="generate.basic_+3A_n.k.spmd">N.K.spmd</code></td>
<td>
<p>sample size of each clusters given processor, i.e.
sum over <code>N.K.spmd</code> is <code>N.spmd</code>,
a vector of length
<code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="generate.basic_+3A_n">N</code></td>
<td>
<p>total sample size across all <code class="reqn">S</code> processors, i.e.
sum over <code>N.spmd</code> is <code>N</code>.</p>
</td></tr>
<tr><td><code id="generate.basic_+3A_p">p</code></td>
<td>
<p>dimension of data <code><a href="#topic+X.spmd">X.spmd</a></code>,
i.e. <code>ncol(<a href="#topic+X.spmd">X.spmd</a>)</code>.</p>
</td></tr>
<tr><td><code id="generate.basic_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all <code class="reqn">S</code> processors, this function will generate in total
<code class="reqn">N</code> observations from <code class="reqn">K</code> clusters in <code class="reqn">p</code> dimensions.
</p>
<p>The clusters centers and dispersions are generated automatically inside
the code. Currently, it is not allowed for users to change, but it is
not difficult to specify them by mimicking this code.
</p>


<h3>Value</h3>

<p>A set of simulated data and information will be returned in a list variable
including:
</p>

<table>
<tr>
 <td style="text-align: left;"><code>K</code>               </td><td style="text-align: left;"> number of clusters, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>p</code>               </td><td style="text-align: left;"> dimension of data
                                         <code><a href="#topic+X.spmd">X.spmd</a></code>,
                                         as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N</code>               </td><td style="text-align: left;"> total sample size, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.allspmds</code>      </td><td style="text-align: left;"> a collection of sample sizes for all
                                         <code class="reqn">S</code> processors, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.spmd</code>          </td><td style="text-align: left;"> total sample size of given processor,
                                         as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.K.spmd</code>        </td><td style="text-align: left;"> sample size of each clusters given
                                         processor, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+X.spmd">X.spmd</a></code>   </td><td style="text-align: left;"> generated data set with dimension with
                                         dimension <code>N.spmd * p</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code>
                                    </td><td style="text-align: left;"> true id of each data, a vector of
                                         length <code>N.spmd</code>
                                         and has values from 1 to <code>K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.CLASS.spmd</code>    </td><td style="text-align: left;"> true sample size of each clusters, a
                                         vector of length <code>K</code>
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate.MixSim">generate.MixSim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help pages of em.step(),
# aecm.step(), apecm.step(), and apecma.step().

## End(Not run)
</code></pre>

<hr>
<h2 id='generate.MixSim'>Generate MixSim Examples for Testing</h2><span id='topic+generate.MixSim'></span>

<h3>Description</h3>

<p>This function utilizes <span class="pkg">MixSim</span> to generate sets of data
for testing algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generate.MixSim(N, p, K, MixSim.obj = NULL, MaxOmega = NULL,
                  BarOmega = NULL, PiLow = 1.0, sph = FALSE, hom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.MixSim_+3A_n">N</code></td>
<td>
<p>total sample size across all <code class="reqn">S</code> processors, i.e.
sum over <code>N.spmd</code> is <code>N</code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_p">p</code></td>
<td>
<p>dimension of data <code><a href="#topic+X.spmd">X.spmd</a></code>,
i.e. <code>ncol(<a href="#topic+X.spmd">X.spmd</a>)</code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_mixsim.obj">MixSim.obj</code></td>
<td>
<p>an object returned from <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_maxomega">MaxOmega</code></td>
<td>
<p>maximum overlap as in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_baromega">BarOmega</code></td>
<td>
<p>averaged overlap as in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_pilow">PiLow</code></td>
<td>
<p>lower bound of mixture proportion as in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_sph">sph</code></td>
<td>
<p>sph as in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
<tr><td><code id="generate.MixSim_+3A_hom">hom</code></td>
<td>
<p>hom as in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>MixSim.obj</code> is NULL, then <code>BarOmega</code> and <code>MaxOmega</code>
will be used in <code><a href="MixSim.html#topic+MixSim">MixSim</a></code> to obtain a new
<code>MixSim.obj</code>.
</p>


<h3>Value</h3>

<p>A set of simulated data and information will be returned in a list variable
including:
</p>

<table>
<tr>
 <td style="text-align: left;"><code>K</code>               </td><td style="text-align: left;"> number of clusters, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>p</code>               </td><td style="text-align: left;"> dimension of data
                                         <code><a href="#topic+X.spmd">X.spmd</a></code>,
                                         as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N</code>               </td><td style="text-align: left;"> total sample size, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.allspmds</code>      </td><td style="text-align: left;"> a collection of sample sizes for all
                                         <code class="reqn">S</code> processors, as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.spmd</code>          </td><td style="text-align: left;"> total sample size of given processor,
                                         as the input </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+X.spmd">X.spmd</a></code>   </td><td style="text-align: left;"> generated data set with dimension with
                                         dimension <code>N.spmd * p</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code>
                                    </td><td style="text-align: left;"> true id of each data, a vector of
                                         length <code>N.spmd</code>
                                         and has values from 1 to <code>K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>N.CLASS.spmd</code>    </td><td style="text-align: left;"> true sample size of each clusters, a
                                         vector of length <code>K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>MixSim.obj</code>      </td><td style="text-align: left;"> the true model where data
                                         <code>X.spmd</code> generated from
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Melnykov, V., Chen, W.-C. and Maitra, R. (2012)
&ldquo;MixSim: Simulating Data to Study Performance of Clustering
Algorithms&rdquo;,
<em>Journal of Statistical Software</em>,
(accepted).
</p>
<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate.basic">generate.basic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Save code in a file "demo.r" and run in 4 processors by
# &gt; mpiexec -np 4 Rscript demo.r

### Setup environment.
library(pmclust, quiet = TRUE)

### Generate an example data.
N &lt;- 5000
p &lt;- 2
K &lt;- 2
data.spmd &lt;- generate.MixSim(N, p, K, BarOmega = 0.01)
X.spmd &lt;- data.spmd$X.spmd

### Run clustering.
PARAM.org &lt;- set.global(K = K)          # Set global storages.
# PARAM.org &lt;- initial.em(PARAM.org)    # One initial.
PARAM.org &lt;- initial.RndEM(PARAM.org)   # Ten initials by default.
PARAM.new &lt;- apecma.step(PARAM.org)     # Run APECMa.
em.update.class()                       # Get classification.

### Get results.
N.CLASS &lt;- get.N.CLASS(K)
comm.cat("# of class:", N.CLASS, "\n")
comm.cat("# of class (true):", data.spmd$N.CLASS.spmd, "\n")

### Quit.
finalize()

## End(Not run)
</code></pre>

<hr>
<h2 id='get.N.CLASS'>Obtain Total Elements for Every Clusters</h2><span id='topic+get.N.CLASS'></span><span id='topic+get.CLASS'></span>

<h3>Description</h3>

<p>This function will collect the total elements for every clusters
from all processors that the all reduced calls with the sum operation
will be performed.
</p>
<p>The <code>get.CLASS</code> returns class ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get.N.CLASS(K)

  get.CLASS(PARAM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.N.CLASS_+3A_k">K</code></td>
<td>
<p>the total number of clusters.</p>
</td></tr>
<tr><td><code id="get.N.CLASS_+3A_param">PARAM</code></td>
<td>
<p>a set of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The final results are distributed in all processors including the total
elements for each cluster. The global variable <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code>
stores the identification for each observation on each processors.
This function will first summary <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code>
in <code>K</code> categories,
then use the all reduce function with the sum operation to add the numbers
by clusters.
The <code><a href="#topic+COMM.RANK">COMM.RANK</a></code> 0 will be used to take care the printing.
</p>


<h3>Value</h3>

<p><code>K</code> numbers will be returned that are the total elements for each
cluster. Sum of these <code>K</code> numbers should be equal to <code>N</code> the
total number of observations.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <br />
<code><a href="#topic+apecma.step">apecma.step</a></code>,
<code><a href="#topic+kmeans.step">kmeans.step</a></code>. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help pages of em.step(),
# aecm.step(), apecm.step(), apecma.step(), and kmeans.step().

## End(Not run)
</code></pre>

<hr>
<h2 id='Independent+20logL'>Independent Function for Log Likelihood</h2><span id='topic+indep.logL'></span>

<h3>Description</h3>

<p>This function is for debugging only and for checking if the observed data
log likelihood is consistent for each EM iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  indep.logL(PARAM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Independent+2B20logL_+3A_param">PARAM</code></td>
<td>
<p>a set of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will provide an observed data log likelihood based on the
current parameter <code><a href="#topic+PARAM">PARAM</a></code>.
This function will take in information from global, but
no global variables will be updated by this function.
</p>
<p>This function also don't take care the numerical issues, so the return
value may be inaccurate sometimes.
</p>


<h3>Value</h3>

<p>An observed data log likelihood will be returned.
This value can quickly compare with the log likelihood computed inside
<code><a href="#topic+em.onestep">em.onestep</a></code>. Small difference is allowed, but
large difference indicates bugs of code or illness of data.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+em.onestep">em.onestep</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is a core function for em.estep()
# see the source code for details.
# Reset .pmclustEnv$CONTROL$debug to turn on this function
# automatically for each EM iteration.

## End(Not run)
</code></pre>

<hr>
<h2 id='Initialization'>Initialization for EM-like Algorithms</h2><span id='topic+initial.RndEM'></span><span id='topic+initial.em'></span><span id='topic+initial.center'></span>

<h3>Description</h3>

<p>These functions implement initialization of EM-like algorithms
for model-based clustering based on <code><a href="#topic+X.spmd">X.spmd</a></code>, and
initialization of K-means algorithm by randomly picking samples
from data based on <code><a href="#topic+X.spmd">X.spmd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  initial.RndEM(PARAM)
  initial.em(PARAM, MU = NULL)
  initial.center(PARAM, MU = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialization_+3A_param">PARAM</code></td>
<td>
<p>an original set of parameters generated
by <code><a href="#topic+set.global">set.global</a></code>.</p>
</td></tr>
<tr><td><code id="Initialization_+3A_mu">MU</code></td>
<td>
<p>a center matrix with dim = <code class="reqn">p \times K</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>initial.RndEM</code>,
the procedure is implemented by randomly picking
<code>.pmclustEnv$CONTROL$RndEM.iter</code> starting points from data
<code><a href="#topic+X.spmd">X.spmd</a></code>
and run one E-step to obtain the log likelihood.
Then pick the starting point with the highest log likelihood as the
best choice to pursue the MLEs in further EM iterations.
</p>
<p>This function repeatedly run <code><a href="#topic+initial.em">initial.em</a></code> by
<code>.pmclustEnv$CONTROL$RndEM.iter</code> random starts and pick the
best initializations from the random starts.
</p>
<p>For <code>initial.em</code>,
it takes <code><a href="#topic+X.spmd">X.spmd</a></code> from the global environment and
randomly pick <code class="reqn">K</code> of them as the centers of <code class="reqn">K</code> groups.
If <code><a href="#topic+MU">MU</a></code> is specified, then this <code><a href="#topic+MU">MU</a></code>
will be the centers.
The default identity dispersion in <code>PARAM$SIGMA</code> will be used.
Then, one E-step will be called to obtain the log likelihood and new
classification will be updated.
</p>
<p>This function is used to implement the RndEM procedure for more
elaborate initialization scheme in <code><a href="#topic+initial.RndEM">initial.RndEM</a></code>.
Potentially, several random starts should be tried before running EM
algorithms. This can benefit in two aspects including:
shorter convergent iterations and better classification results.
</p>
<p>For <code>initial.center</code>,
if <code><a href="#topic+MU">MU</a></code> is given, then the center will be assigned according.
</p>


<h3>Value</h3>

<p>The best initial starting points <code><a href="#topic+PARAM">PARAM</a></code> will be returned among
all random starting points. The number of random starting points is assigned
by <code><a href="#topic+set.global">set.global</a></code> to a list variable <code><a href="#topic+CONTROL">CONTROL</a></code>.
See the help page of <code><a href="#topic+initial.em">initial.em</a></code> and <code><a href="#topic+set.global">set.global</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>
<p>Maitra, R. (2009)
&ldquo;Initializing partition-optimization algorithms&rdquo;,
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>,
<b>6:1</b>, 114-157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>, <br />
<code><a href="#topic+apecm.step">apecm.step</a></code>,
<code><a href="#topic+apecma.step">apecma.step</a></code>,
<code><a href="#topic+kmeans.step">kmeans.step</a></code>. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help page of em.step(),
# aecm.step(), apecm.step(), apecma.step(), and kmeans.step().

## End(Not run)
</code></pre>

<hr>
<h2 id='Internal+20Functions'> All Internal Functions </h2><span id='topic+pmclust.reduceK'></span>

<h3>Description</h3>

<p> All internal functions </p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='mb.print'>Print Results of Model-Based Clustering</h2><span id='topic+mb.print'></span>

<h3>Description</h3>

<p>This function will print summarized messages for model-based clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mb.print(PARAM, CHECK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb.print_+3A_param">PARAM</code></td>
<td>
<p>a set of convergent parameters to be printed.</p>
</td></tr>
<tr><td><code id="mb.print_+3A_check">CHECK</code></td>
<td>
<p>a set of checking parameters to be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will provide a quick summary from the <code>PARAM</code> and
<code>CHECK</code> typically the output of clusterings when algorithms stop.
The <code><a href="#topic+COMM.RANK">COMM.RANK</a></code> 0 will be used to take care the printing.
</p>


<h3>Value</h3>

<p>Summarized messages will print/cat on screen by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <br />
<code><a href="#topic+apecma.step">apecma.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help pages of em.step(),
# aecm.step(), apecm.step(), and apecma.step().

## End(Not run)
</code></pre>

<hr>
<h2 id='One+20E-Step'>Compute One E-step and Log Likelihood Based on Current Parameters</h2><span id='topic+e.step'></span>

<h3>Description</h3>

<p>This function will perform one E-step based on current parameters.
This is a core function of <code><a href="#topic+em.onestep">em.onestep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  e.step(PARAM, update.logL = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="One+2B20E-Step_+3A_param">PARAM</code></td>
<td>
<p>a set of parameters.</p>
</td></tr>
<tr><td><code id="One+2B20E-Step_+3A_update.logl">update.logL</code></td>
<td>
<p>TRUE for update observed data log likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will base on the current parameter to 
compute the densities for all observations for all
<code>K</code> components, and update the <code><a href="#topic+Z.spmd">Z.spmd</a></code> matrix.
If the <code>update.logL</code> is true, then the log likelihood
<code><a href="#topic+W.spmd.rowSums">W.spmd.rowSums</a></code> will be also updated before the end
of this function.
</p>
<p>Sum of <code><a href="#topic+W.spmd.rowSums">W.spmd.rowSums</a></code> of all processors will be the
observed data log likelihood for the current iteration.
</p>


<h3>Value</h3>

<p>Several global variables will be overwrote after this call including
<code><a href="#topic+Z.spmd">Z.spmd</a></code>, <code><a href="#topic+W.spmd.rowSums">W.spmd.rowSums</a></code>,
<code><a href="#topic+W.spmd">W.spmd</a></code>, <code><a href="#topic+U.spmd">U.spmd</a></code>,
and <code><a href="#topic+Z.colSums">Z.colSums</a></code>.
</p>


<h3>Computing Issues</h3>

<p>Since the clusters can be degenerated or highly flat, these cause very
large positive or negative exponents in densities.
The log likelihood will tend to be inaccurate (not finite).
Since the mixture structures can be over fit, this also cause very
tiny mixing proportions.
The poster probabilities can also unstable (NaN).
</p>
<p>These can be solved by rescaling the range of exponents carefully
and adjust the scaling factor on the log values.
See <code><a href="#topic+CONTROL">CONTROL</a></code> for details about constrains on E- and M-steps.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+em.onestep">em.onestep</a></code>,
<code><a href="#topic+m.step">m.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is a core function for em.onestep()
# see the source code for details.

## End(Not run)
</code></pre>

<hr>
<h2 id='One+20M-Step'>Compute One M-Step Based on Current Posterior Probabilities</h2><span id='topic+m.step'></span>

<h3>Description</h3>

<p>This function will perform one M-step based on current posterior
probabilities.
This is a core function of <code><a href="#topic+em.onestep">em.onestep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  m.step(PARAM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="One+2B20M-Step_+3A_param">PARAM</code></td>
<td>
<p>a set of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will base on the current posterior probabilities
<code><a href="#topic+Z.spmd">Z.spmd</a></code> to estimate the parameters <code><a href="#topic+PARAM">PARAM</a></code>
mainly including mixing proportions <code><a href="#topic+ETA">ETA</a></code>,
centers of clusters <code><a href="#topic+MU">MU</a></code>, and
dispersions of clusters <code><a href="#topic+SIGMA">SIGMA</a></code>.
</p>


<h3>Value</h3>

<p>Returning a new <code><a href="#topic+PARAM">PARAM</a></code> which maximizes the complete data log
likelihood for the current iteration.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+em.onestep">em.onestep</a></code>,
<code><a href="#topic+e.step">e.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is a core function for em.onestep()
# see the source code for details.

## End(Not run)
</code></pre>

<hr>
<h2 id='One+20Step+20of+20EM+20algorithm'>One EM Step for GBD</h2><span id='topic+em.onestep'></span>

<h3>Description</h3>

<p>One EM step only for model-based clustering of finite mixture Gaussian
models with unstructured dispersions.
This is a core function of <code><a href="#topic+em.step">em.step</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  em.onestep(PARAM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="One+2B20Step+2B20of+2B20EM+2B20algorithm_+3A_param">PARAM</code></td>
<td>
<p>an original set of parameters generated
by <code><a href="#topic+set.global">set.global</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A global variable called <code><a href="#topic+X.spmd">X.spmd</a></code> should exist in the
<code><a href="#topic+.pmclustEnv">.pmclustEnv</a></code>
environment, usually the working environment. The <code><a href="#topic+X.spmd">X.spmd</a></code>
is the data matrix to be clustered, and this matrix has a dimension
<code>N.spmd</code> by <code>p</code>.
</p>
<p>The <code>PARAM</code> will be a local variable for the current iteration inside
<code><a href="#topic+em.onestep">em.onestep</a></code>,
and this variable is a list containing all parameters related to models.
This function also updates in the parameters by the EM algorithm, and
return a new <code><a href="#topic+PARAM">PARAM</a></code> for the next iteration.
The details of list elements are initially
generated by <code><a href="#topic+set.global">set.global</a></code>.
</p>


<h3>Value</h3>

<p>This function is one EM step. The global variables will be updated and
a new <code><a href="#topic+PARAM">PARAM</a></code> will be returned.
See the help page of <code><a href="#topic+PARAM">PARAM</a></code> or <code><a href="#topic+PARAM.org">PARAM.org</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+e.step">e.step</a></code>,
<code><a href="#topic+m.step">m.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is a core function for em.step()
# see the source code for details.

## End(Not run)
</code></pre>

<hr>
<h2 id='pmclust+20and+20pkmeans'>Parallel Model-Based Clustering and Parallel K-means Algorithm</h2><span id='topic+pmclust'></span><span id='topic+pkmeans'></span>

<h3>Description</h3>

<p>Parallel Model-Based Clustering and Parallel K-means Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pmclust(X = NULL, K = 2, MU = NULL,
    algorithm = .PMC.CT$algorithm, RndEM.iter = .PMC.CT$RndEM.iter,
    CONTROL = .PMC.CT$CONTROL, method.own.X = .PMC.CT$method.own.X,
    rank.own.X = .pbd_env$SPMD.CT$rank.source, comm = .pbd_env$SPMD.CT$comm)

  pkmeans(X = NULL, K = 2, MU = NULL,
    algorithm = c("kmeans"),
    CONTROL = .PMC.CT$CONTROL, method.own.X = .PMC.CT$method.own.X,
    rank.own.X = .pbd_env$SPMD.CT$rank.source, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_x">X</code></td>
<td>
<p>a GBD row-major matrix.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_mu">MU</code></td>
<td>
<p>pre-specified centers.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>types of EM algorithms.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_rndem.iter">RndEM.iter</code></td>
<td>
<p>number of Rand-EM iterations.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_control">CONTROL</code></td>
<td>
<p>a control for algorithms, see <code><a href="#topic+CONTROL">CONTROL</a></code> for details.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_method.own.x">method.own.X</code></td>
<td>
<p>how <code>X</code> is distributed.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_rank.own.x">rank.own.X</code></td>
<td>
<p>who own <code>X</code> if <code>method.own.X = "single"</code>.</p>
</td></tr>
<tr><td><code id="pmclust+2B20and+2B20pkmeans_+3A_comm">comm</code></td>
<td>
<p>MPI communicator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are high-level functions for several functions in <span class="pkg">pmclust</span>
including: data distribution, setting global environment <code>.pmclustEnv</code>,
initializations, algorithm selection, etc.
</p>
<p>The input <code>X</code> is in <code>gbd</code>. It will
be converted in <code>gbd</code> row-major format and copied into
<code>.pmclustEnv</code> for computation. By default, <span class="pkg">pmclust</span> uses a
GBD row-major format (<code>gbdr</code>). While <code>common</code> means that
<code>X</code> is identical on all processors, and <code>single</code> means that
<code>X</code> only exist on one processor <code>rank.own.X</code>.
</p>


<h3>Value</h3>

<p>These functions return a list with class <code>pmclust</code> or <code>pkmeans</code>.
</p>
<p>See the help page of <code><a href="#topic+PARAM">PARAM</a></code> or <code><a href="#topic+PARAM.org">PARAM.org</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>,
<code><a href="#topic+e.step">e.step</a></code>,
<code><a href="#topic+m.step">m.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Save code in a file "demo.r" and run in 4 processors by
# &gt; mpiexec -np 4 Rscript demo.r

### Setup environment.
library(pmclust, quiet = TRUE)

### Load data
X &lt;- as.matrix(iris[, -5])

### Distribute data
jid &lt;- get.jid(nrow(X))
X.gbd &lt;- X[jid,]

### Standardized
N &lt;- allreduce(nrow(X.gbd))
p &lt;- ncol(X.gbd)
mu &lt;- allreduce(colSums(X.gbd / N))
X.std &lt;- sweep(X.gbd, 2, mu, FUN = "-")
std &lt;- sqrt(allreduce(colSums(X.std^2 / (N - 1))))
X.std &lt;- sweep(X.std, 2, std, FUN = "/")

### Clustering
library(pmclust, quiet = TRUE)
comm.set.seed(123, diff = TRUE)

ret.mb1 &lt;- pmclust(X.std, K = 3)
comm.print(ret.mb1)

ret.kms &lt;- pkmeans(X.std, K = 3)
comm.print(ret.kms)

### Finish
finalize()

## End(Not run)
</code></pre>

<hr>
<h2 id='pmclust-package'>Parallel Model-Based Clustering</h2><span id='topic+pmclust-package'></span>

<h3>Description</h3>

<p>The pmclust aims to utilize model-based clustering (unsupervised)
for high dimensional and ultra large data, especially in a distributed
manner. The package employs pbdMPI to perform a parallel version of
expectation and maximization (EM) algorithm for finite mixture
Gaussian models. The unstructured dispersion matrices
are assumed in the Gaussian models. The implementation is default in
the single program multiple data (SPMD) programming model.
The code can be executed through pbdMPI and independent to most MPI
applications. See the High Performance Statistical Computing (HPSC)
website for more information, documents and examples.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> pmclust</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">


  License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
  LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function is <code><a href="#topic+pmclust">pmclust</a></code> implementing the
parallel EM algorithm for mixture multivariate Gaussian models
with unstructured dispersions. This function groups a data matrix
<code><a href="#topic+X.gbd">X.gbd</a></code> or <code><a href="#topic+X.spmd">X.spmd</a></code>
into <code>K</code> clusters where <code><a href="#topic+X.gbd">X.gbd</a></code> or <code><a href="#topic+X.spmd">X.spmd</a></code> is
potentially huge and taken from the global environment <code>.GlobalEnv</code>
or <code><a href="#topic+.pmclustEnv">.pmclustEnv</a></code>.
</p>
<p>Other main functions <code><a href="#topic+em.step">em.step</a></code>, <code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, and
<code><a href="#topic+apecma.step">apecma.step</a></code> may provide better performance than the
<code><a href="#topic+em.step">em.step</a></code> in terms of computing time and convergent
iterations.
</p>
<p><code><a href="#topic+kmeans.step">kmeans.step</a></code> provides the fastest clustering among above
algorithms, but it is restricted by Euclidean distance and spherical
dispersions.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>
<p>Chen, W.-C. and Maitra, R. (2011)
&ldquo;Model-based clustering of regression time series data via
APECM &ndash; an AECM algorithm sung to an even faster beat&rdquo;,
<em>Statistical Analysis and Data Mining</em>,
<b>4</b>, 567-578.
</p>
<p>Chen, W.-C., Ostrouchov, G., Pugmire, D., Prabhat, M., and Wehner, M. (2013)
&ldquo;A Parallel EM Algorithm for Model-Based Clustering with
Application to Explore Large Spatio-Temporal Data&rdquo;,
<em>Technometrics</em>,
(revision).
</p>
<p>Dempster, A.P., Laird, N.M. and Rubin, D.B. (1977)
&ldquo;Maximum Likelihood from Incomplete Data via the EM Algorithm&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>,
<b>39</b>, 1-38.
</p>
<p>Lloyd., S. P. (1982)
&ldquo;Least squares quantization in PCM&rdquo;,
<em>IEEE Transactions on Information Theory</em>,
<b>28</b>, 129-137.
</p>
<p>Meng, X.-L. and Van Dyk, D. (1997)
&ldquo;The EM Algorithm &ndash; an Old Folk-song Sung to a Fast New Tune&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>,
<b>59</b>, 511-567.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <br />
<code><a href="#topic+apecma.step">apecma.step</a></code>,
<code><a href="#topic+kmeans.step">kmeans.step</a></code>. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Under command mode, run the demo with 2 processors by
### (Use Rscript.exe for windows system)
mpiexec -np 2 Rscript -e 'demo(gbd_em,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(gbd_aecm,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(gbd_apecm,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(gbd_apecma,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(gbd_kmeans,"pmclust",ask=F,echo=F)'

mpiexec -np 2 Rscript -e 'demo(ex_em,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(ex_aecm,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(ex_apecm,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(ex_apecma,"pmclust",ask=F,echo=F)'
mpiexec -np 2 Rscript -e 'demo(ex_kmeans,"pmclust",ask=F,echo=F)'

## End(Not run)
</code></pre>

<hr>
<h2 id='print.object'>Functions for Printing or Summarizing Objects According to Classes</h2><span id='topic+print.pmclust'></span><span id='topic+print.pkmeans'></span>

<h3>Description</h3>

<p>Several classes are declared in <span class="pkg">pmclust</span>, and these are functions
to print and summary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmclust'
print(x, ...)
## S3 method for class 'pkmeans'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.object_+3A_x">x</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="print.object_+3A_...">...</code></td>
<td>
<p>other possible options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are useful functions for summarizing.
</p>


<h3>Value</h3>

<p>The results will cat or print on the STDOUT by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmclust">pmclust</a></code>, <code><a href="#topic+pkmeans">pkmeans</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pmclust, quiet = TRUE)

# Functions applied by directly type the names of objects.

## End(Not run)
</code></pre>

<hr>
<h2 id='Read+20Me+20First'>Read Me First Function</h2><span id='topic+readme'></span><span id='topic+CHECK'></span><span id='topic+CLASS.spmd'></span><span id='topic+COMM.RANK'></span><span id='topic+COMM.SIZE'></span><span id='topic+SAVE.param'></span><span id='topic+SAVE.iter'></span><span id='topic+U.spmd'></span><span id='topic+W.spmd'></span><span id='topic+W.spmd.rowSums'></span><span id='topic+Z.colSums'></span><span id='topic+Z.spmd'></span><span id='topic+p.times.logtwopi'></span>

<h3>Description</h3>

<p>This function print the annotations of all variables used in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  readme()
</code></pre>


<h3>Details</h3>

<p>This package is optimized in the way by pre-specifying several global
variables in <code>.pmclustEnv</code>.
These variables will be overwrote by EM algorithms. Users should
use these names to access the results and utilize them with cautions.
</p>


<h3>Value</h3>

<p>A readme message will print on screen by default and explain the global
variables used in this package, including:
</p>

<table>
<tr>
 <td style="text-align: left;"><code>CHECK</code>            </td><td style="text-align: left;"> convergent checking </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>CLASS.spmd</code>       </td><td style="text-align: left;"> true id of each data, a vector of
                                          length N.spmd and has values
                                          from 1 to K </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>COMM.RANK</code>        </td><td style="text-align: left;"> rank of current processor, obtained
                                          from
                                          <code>comm.rank</code> of pbdMPI</td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>COMM.SIZE</code>        </td><td style="text-align: left;"> total processors in MPI world,
                                          obtained from
                                          <code>comm.size</code> of pbdMPI</td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+CONTROL">CONTROL</a></code>   </td><td style="text-align: left;"> controls for EM iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+PARAM">PARAM</a></code>     </td><td style="text-align: left;"> set or parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>SAVE.param</code>       </td><td style="text-align: left;"> (debug only)
                                          save parameters for every
                                          iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>SAVE.iter</code>        </td><td style="text-align: left;"> (debug only)
                                          save computing time for every
                                          iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>U.spmd</code>           </td><td style="text-align: left;"> temporary storage for density </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>W.spmd</code>           </td><td style="text-align: left;"> temporary storage for
                                          <code>eta * density</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>W.spmd.rowSums</code>   </td><td style="text-align: left;"> temporary storage for rowSums
                                          of <code>W.spmd</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code><a href="#topic+X.spmd">X.spmd</a></code>    </td><td style="text-align: left;"> generated data set with dimension
                                          with dimension
                                          <code>N.spmd * p</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>Z.colSums</code>        </td><td style="text-align: left;"> temporary storage for rowSums
                                          of <code>Z.spmd</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>Z.spmd</code>           </td><td style="text-align: left;"> posterior probabilities </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>p.times.logtwopi</code> </td><td style="text-align: left;"> <code>p * log(2 * pi)</code>
</td>
</tr>

</table>

<p>Each variable may contain several elements if it is a list, some variables
are used for temporary storages in order to optimize computing, and some
variables are used for constant variables. These variables may be restricted,
and only generated by the function <code><a href="#topic+set.global">set.global</a></code>.
</p>
<p>One can access these variables via the global environment <code>.pmclustEnv</code>
such as <code>.pmclustEnv$CONTROL</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
readme()

## End(Not run)
</code></pre>

<hr>
<h2 id='Set+20Global+20Variables'>Set Global Variables According to the global matrix X.gbd (X.spmd)</h2><span id='topic+.pmclustEnv'></span><span id='topic+set.global.gbd'></span><span id='topic+set.global'></span><span id='topic+X.gbd'></span><span id='topic+X.spmd'></span>

<h3>Description</h3>

<p>This function will set several sets of variables globally in the
environment <code>.pmclustEnv</code> according to the global matrix
<code>X.gbd/X.spmd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  set.global.gbd(K = 2, X.gbd = NULL, PARAM = NULL,
      algorithm = c("em", "aecm", "apecm", "apecma", "kmeans"),
      RndEM.iter = 10)

  set.global(K = 2, X.spmd = NULL, PARAM = NULL,
      algorithm = c("em", "aecm", "apecm", "apecma", "kmeans"),
      RndEM.iter = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_k">K</code></td>
<td>
<p>an original set of parameters generated
by <code>set.global</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_x.gbd">X.gbd</code></td>
<td>
<p>an input GBD matrix.</p>
</td></tr>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_x.spmd">X.spmd</code></td>
<td>
<p>an input SPMD matrix.</p>
</td></tr>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_param">PARAM</code></td>
<td>
<p>an original set of parameters generated
by <code>set.global</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_algorithm">algorithm</code></td>
<td>
<p>an original set of parameters generated
by <code>set.global</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20Global+2B20Variables_+3A_rndem.iter">RndEM.iter</code></td>
<td>
<p>number of RndEM iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: A global variable named <code>X.gbd/X.spmd</code> should be set before
calling <code>set.global</code> where <code>X.gbd/X.spmd</code> is a matrix containing data
with dimension <code>N.spmd * p</code>. i.e. <code>N.spmd</code> observations and
<code>p</code> variables.
</p>
<p><code>X.gbd/X.spmd</code> is supposed to exist in <code>.GlobalEnv</code>.
If not, they should be as an input object and will be copied into
<code>.pmclustEnv</code> which is less efficient.
</p>


<h3>Value</h3>

<p>A new set of <code><a href="#topic+PARAM">PARAM</a></code> will be returned and several global
variables will be set according to the data <code>X.gbd/X.spmd</code>.
</p>
<p>Sets of global variables are store in the default environment
<code>.pmclustEnv</code>.
</p>
<p>Use <code><a href="#topic+readme">readme</a></code> to see all global variables set by this function.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <br />
<code><a href="#topic+apecma.step">apecma.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help pages of em.step(),
# aecm.step(), apecm.step(), apecma.step(), and kmeans.step().

## End(Not run)
</code></pre>

<hr>
<h2 id='Set+20of+20CONTROL'>A Set of Controls in Model-Based Clustering.</h2><span id='topic+.PMC.CT'></span><span id='topic+CONTROL'></span>

<h3>Description</h3>

<p>This set of controls are used to guide all algorithms implemented in
this package.
</p>


<h3>Format</h3>

<p>A list variable contains several parameters for computing.
</p>


<h3>Details</h3>

<p><code>.PMC.CT</code> stores all default controls for <code>pmclust</code> and
<code>pkmeans</code> including
</p>

<table>
<tr>
 <td style="text-align: left;"><code>algorithm</code>      </td><td style="text-align: left;"> algorithms implemented </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>algorithm.gbd</code> </td><td style="text-align: left;"> algorithms implemented for gbd/spmd</td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>method.own.X</code>   </td><td style="text-align: left;"> how <code>X</code> is distributed </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>CONTROL</code>        </td><td style="text-align: left;"> a <code>CONTROL</code> list as in next </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of <code>CONTROL</code> or <code>.pmclustEnv$CONTROL</code> are
</p>

<table>
<tr>
 <td style="text-align: left;"><code>max.iter</code>   </td><td style="text-align: left;"> maximum number of iterations (1000) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>abs.err</code>    </td><td style="text-align: left;"> absolute error for convergence (1e-4) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>rel.err</code>    </td><td style="text-align: left;"> relative error for convergence (1e-6) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>debug</code>      </td><td style="text-align: left;"> debugging flag (0) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>RndEM.iter</code> </td><td style="text-align: left;"> number of RndEM iterations (10) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>exp.min</code>    </td><td style="text-align: left;"> minimum exponent (<code>log(.Machine$double.xmin)</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>exp.max</code>    </td><td style="text-align: left;"> maximum exponent (<code>log(.Machine$double.xmax)</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>U.min</code>      </td><td style="text-align: left;"> minimum of diagonal of <code><a href="base.html#topic+chol">chol</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>U.max</code>      </td><td style="text-align: left;"> maximum of diagonal of <code><a href="base.html#topic+chol">chol</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>stop.at.fail</code> </td><td style="text-align: left;"> stop iterations when fails such as NaN </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>These elements govern the computing including number of iterations,
convergent criteria, ill conditions, and numerical issues.
Some of them are machine dependent.
</p>
<p>Currently, the <code>algorithm</code> could be
<code>em</code>, <code>aecm</code>, <code>apecm</code>, <code>apecma</code>, and <code>kmeans</code>
for GBD.
The <code>method.own.X</code> could be <code>gbdr</code>, <code>common</code>, and
<code>single</code>.
</p>


<h3>Numerical Issues</h3>

<p>For example, <code>exp.min</code> and <code>exp.max</code> will control the range of
densities function before taking logarithm. If the density values were no
in the range, they would be rescaled. The scaling factor will be also
recorded for post adjustment for observed data log likelihood.
This will provide more accurate posterior probabilities and observed data
log likelihood.
</p>
<p>Also, <code>U.min</code> and <code>U.max</code> will control the output of
<code><a href="Matrix.html#topic+chol">chol</a></code> when decomposing <code><a href="#topic+SIGMA">SIGMA</a></code> in every
E-steps. If the diagonal terms were out of the range, a <code>PARAM$U.check</code>
would be set to <code>FALSE</code>. Only the components with <code>TRUE</code>
<code>U.check</code> will estimate and update the dispersions in M-steps
for the rest of iterations.
</p>
<p>These problems may cause wrong posteriors and log likelihood due to
the degenerate and inflated components. Usually, this is a sign of
overestimate the number of components <code>K</code>, or the initialization
do not provide good estimations for parameters.
See <code><a href="#topic+e.step">e.step</a></code> for more information about computing.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global.gbd">set.global.gbd</a></code>, and
<code><a href="#topic+set.global">set.global</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use set.global() to generate one of this.
# X.spmd should be pre-specified before calling set.global().

## End(Not run)
</code></pre>

<hr>
<h2 id='Set+20of+20PARAM'>A Set of Parameters in Model-Based Clustering.</h2><span id='topic+PARAM'></span><span id='topic+PARAM.org'></span><span id='topic+ETA'></span><span id='topic+MU'></span><span id='topic+SIGMA'></span>

<h3>Description</h3>

<p>This set of parameters are used in initialization, EM iterations, and
final convergent results. All share the same structure in a list variable.
</p>


<h3>Format</h3>

<p>A list variable contains several parameters for computing.
</p>


<h3>Details</h3>

<p>The elements of <code>PARAM</code> or <code>PARAM.org</code> are
</p>

<table>
<tr>
 <td style="text-align: left;"><code>N</code>           </td><td style="text-align: left;"> number of observations </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>p</code>           </td><td style="text-align: left;"> dimension of each observation,
                                     total number of variables </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>K</code>           </td><td style="text-align: left;"> number of clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>ETA</code>         </td><td style="text-align: left;"> mixing proportion </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>log.ETA</code>     </td><td style="text-align: left;"> log of mixing proportion </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>MU</code>          </td><td style="text-align: left;"> centers, dim =
                                     <code class="reqn">p \times K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>SIGMA</code>       </td><td style="text-align: left;"> dispersions, a list containing <code class="reqn">K</code>
                                     elements, each element is a matrix,
                                     dim = <code class="reqn">p \times p</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>U</code>           </td><td style="text-align: left;"> Choleski of SIGMA, the same size of
                                     SIGMA </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>U.check</code>     </td><td style="text-align: left;"> checks of each elements of U,
                                     length <code class="reqn">K</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>logL</code>        </td><td style="text-align: left;"> log likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
             <code>min.N.CLASS</code> </td><td style="text-align: left;"> minimum number of elements in a
                                     cluster (restrictions)
</td>
</tr>

</table>

<p>The model parameters are <code>ETA</code>, <code>MU</code>, and <code>SIGMA</code>, while
<code>log.ETA</code>, <code>U</code>, <code>U.check</code>, and <code>min.N.CLASS</code>
are only used in computing.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use set.global() to generate one of this.
# X.spmd should be pre-specified before calling set.global().

## End(Not run)
</code></pre>

<hr>
<h2 id='Update+20Class+20of+20EM+20or+20Kmenas+20Results'>Update CLASS.spmd Based on the Final Iteration</h2><span id='topic+em.update.class'></span><span id='topic+kmeans.update.class'></span>

<h3>Description</h3>

<p>Update <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code> based on the final iteration of EM-like
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  em.update.class()
  kmeans.update.class()
</code></pre>


<h3>Details</h3>

<p>This function takes <code><a href="#topic+Z.spmd">Z.spmd</a></code> from the global environment
<code><a href="#topic+.pmclustEnv">.pmclustEnv</a></code> and update <code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code>,
and provides the identification of groups for all data.
</p>


<h3>Value</h3>

<p><code><a href="#topic+CLASS.spmd">CLASS.spmd</a></code> will be updated.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+em.step">em.step</a></code>,
<code><a href="#topic+aecm.step">aecm.step</a></code>,
<code><a href="#topic+apecm.step">apecm.step</a></code>, <br />
<code><a href="#topic+apecma.step">apecma.step</a></code>,
<code><a href="#topic+kmeans.step">kmeans.step</a></code>. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Examples can be found in the help pages of em.step(),
# aecm.step(), apecm.step(), apecma.step(), and kmeans.step().

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
