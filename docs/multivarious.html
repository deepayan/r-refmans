<!DOCTYPE html><html><head><title>Help for package multivarious</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multivarious}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_node'><p>add a pre-processing stage</p></a></li>
<li><a href='#apply_rotation'><p>Apply rotation</p></a></li>
<li><a href='#apply_transform'><p>apply a pre-processing transform</p></a></li>
<li><a href='#bi_projector'><p>Construct a bi_projector instance</p></a></li>
<li><a href='#bi_projector_union'><p>A Union of Concatenated <code>bi_projector</code> Fits</p></a></li>
<li><a href='#block_indices'><p>get block_indices</p></a></li>
<li><a href='#block_lengths'><p>get block_lengths</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap Resampling for Multivariate Models</p></a></li>
<li><a href='#bootstrap.pca'><p>PCA Bootstrap Resampling</p></a></li>
<li><a href='#center'><p>center a data matrix</p></a></li>
<li><a href='#classifier'><p>Construct a Classifier</p></a></li>
<li><a href='#classifier.discriminant_projector'><p>Create a k-NN classifier for a discriminant projector</p></a></li>
<li><a href='#classifier.multiblock_biprojector'><p>Multiblock Bi-Projector Classifier</p></a></li>
<li><a href='#classifier.projector'><p>create <code>classifier</code> from a <code>projector</code></p></a></li>
<li><a href='#coef.cross_projector'><p>Extract coefficients from a cross_projector object</p></a></li>
<li><a href='#colscale'><p>scale a data matrix</p></a></li>
<li><a href='#components'><p>get the components</p></a></li>
<li><a href='#compose_projector'><p>Compose Two Projectors</p></a></li>
<li><a href='#compose_projectors'><p>Projector Composition</p></a></li>
<li><a href='#concat_pre_processors'><p>bind together blockwise pre-processors</p></a></li>
<li><a href='#convert_domain'><p>Transfer data from one input domain to another via common latent space</p></a></li>
<li><a href='#cross_projector'><p>Two-way (cross) projection to latent components</p></a></li>
<li><a href='#discriminant_projector'><p>Construct a Discriminant Projector</p></a></li>
<li><a href='#fresh'><p>Get a fresh pre-processing node cleared of any cached data</p></a></li>
<li><a href='#group_means'><p>Compute column-wise mean in X for each factor level of Y</p></a></li>
<li><a href='#init_transform'><p>initialize a transform</p></a></li>
<li><a href='#inverse_projection'><p>Inverse of the Component Matrix</p></a></li>
<li><a href='#is_orthogonal'><p>is it orthogonal</p></a></li>
<li><a href='#multiblock_biprojector'><p>Create a Multiblock Bi-Projector</p></a></li>
<li><a href='#multiblock_projector'><p>Create a Multiblock Projector</p></a></li>
<li><a href='#nblocks'><p>get the number of blocks</p></a></li>
<li><a href='#ncomp'><p>Get the number of components</p></a></li>
<li><a href='#nystrom_embedding'><p>Nystrom method for out-of-sample embedding</p></a></li>
<li><a href='#partial_inverse_projection'><p>Partial Inverse Projection of a Columnwise Subset of Component Matrix</p></a></li>
<li><a href='#partial_project'><p>Partially project a new sample onto subspace</p></a></li>
<li><a href='#partial_projector'><p>Construct a partial projector</p></a></li>
<li><a href='#partial_projector.projector'><p>construct a partial_projector from a <code>projector</code> instance</p></a></li>
<li><a href='#pass'><p>a no-op pre-processing step</p></a></li>
<li><a href='#pca'><p>Principal Components Analysis (PCA)</p></a></li>
<li><a href='#perm_ci'><p>Permutation Confidence Intervals</p></a></li>
<li><a href='#predict.classifier'><p>predict with a classifier object</p></a></li>
<li><a href='#prep'><p>prepare a dataset by applying a pre-processing pipeline</p></a></li>
<li><a href='#prinang'><p>Compute principal angles for a set of subspaces</p></a></li>
<li><a href='#print.bi_projector'><p>Pretty Print S3 Method for bi_projector Class</p></a></li>
<li><a href='#print.bi_projector_union'><p>Pretty Print S3 Method for bi_projector_union Class</p></a></li>
<li><a href='#print.classifier'><p>Pretty Print Method for <code>classifier</code> Objects</p></a></li>
<li><a href='#print.composed_projector'><p>Pretty Print Method for <code>composed_projector</code> Objects</p></a></li>
<li><a href='#print.multiblock_biprojector'><p>Pretty Print Method for <code>multiblock_biprojector</code> Objects</p></a></li>
<li><a href='#print.projector'><p>Pretty Print Method for <code>projector</code> Objects</p></a></li>
<li><a href='#project'><p>New sample projection</p></a></li>
<li><a href='#project_block'><p>Project a single &quot;block&quot; of data onto the subspace</p></a></li>
<li><a href='#project_vars'><p>Project one or more variables onto a subspace</p></a></li>
<li><a href='#project.cross_projector'><p>project a cross_projector instance</p></a></li>
<li><a href='#projector'><p>Construct a <code>projector</code> instance</p></a></li>
<li><a href='#reconstruct'><p>Reconstruct the data</p></a></li>
<li><a href='#refit'><p>refit a model</p></a></li>
<li><a href='#regress'><p>Multi-output linear regression</p></a></li>
<li><a href='#reprocess'><p>apply pre-processing parameters to a new data matrix</p></a></li>
<li><a href='#reprocess.cross_projector'><p>reprocess a cross_projector instance</p></a></li>
<li><a href='#residualize'><p>Compute a regression model for each column in a matrix and return residual matrix</p></a></li>
<li><a href='#residuals'><p>Obtain residuals of a component model fit</p></a></li>
<li><a href='#reverse_transform'><p>reverse a pre-processing transform</p></a></li>
<li><a href='#rf_classifier'><p>construct a random forest wrapper classifier</p></a></li>
<li><a href='#rf_classifier.projector'><p>create a random forest classifier</p></a></li>
<li><a href='#rotate'><p>Rotate a Component Solution</p></a></li>
<li><a href='#scores'><p>Retrieve the component scores</p></a></li>
<li><a href='#sdev'><p>standard deviations</p></a></li>
<li><a href='#shape'><p>Shape of the Projector</p></a></li>
<li><a href='#shape.cross_projector'><p>shape of a cross_projector instance</p></a></li>
<li><a href='#standardize'><p>center and scale each vector of a matrix</p></a></li>
<li><a href='#std_scores'><p>Compute standardized component scores</p></a></li>
<li><a href='#svd_wrapper'><p>Singular Value Decomposition (SVD) Wrapper</p></a></li>
<li><a href='#transpose'><p>Transpose a model</p></a></li>
<li><a href='#truncate'><p>truncate a component fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extensible Data Structures for Multivariate Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of basic and extensible data structures and functions for multivariate analysis, including dimensionality reduction techniques, projection methods, and preprocessing functions. The aim of this package is to offer a flexible and user-friendly framework for multivariate analysis that can be easily extended for custom requirements and specific data analysis tasks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, chk, glmnet, corpcor, Matrix, purrr, rsvd, svd, pls,
irlba, RSpectra, proxy, matrixStats, fitdistrplus</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, randomForest, testthat, magrittr, knitr, rmarkdown,
MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bbuchsbaum.github.io/multivarious/">https://bbuchsbaum.github.io/multivarious/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 13:14:27 UTC; bbuchsbaum</td>
</tr>
<tr>
<td>Author:</td>
<td>Bradley Buchsbaum <a href="https://orcid.org/0000-0002-1108-4866"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bradley Buchsbaum &lt;brad.buchsbaum@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_node'>add a pre-processing stage</h2><span id='topic+add_node'></span>

<h3>Description</h3>

<p>add a pre-processing stage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_node(x, step, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_node_+3A_x">x</code></td>
<td>
<p>the processing pipeline</p>
</td></tr>
<tr><td><code id="add_node_+3A_step">step</code></td>
<td>
<p>the pre-processing step to add</p>
</td></tr>
<tr><td><code id="add_node_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new pre-processing pipeline with the added step
</p>

<hr>
<h2 id='apply_rotation'>Apply rotation</h2><span id='topic+apply_rotation'></span>

<h3>Description</h3>

<p>Apply a specified rotation to the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_rotation(x, rotation_matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_rotation_+3A_x">x</code></td>
<td>
<p>A model object, possibly created using the <code>pca()</code> function.</p>
</td></tr>
<tr><td><code id="apply_rotation_+3A_rotation_matrix">rotation_matrix</code></td>
<td>
<p><code>matrix</code> reprsenting the rotation.</p>
</td></tr>
<tr><td><code id="apply_rotation_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified object with updated components and scores after applying the specified rotation.
</p>

<hr>
<h2 id='apply_transform'>apply a pre-processing transform</h2><span id='topic+apply_transform'></span>

<h3>Description</h3>

<p>apply a pre-processing transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_transform(x, X, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_transform_+3A_x">x</code></td>
<td>
<p>the pre_processor</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_x">X</code></td>
<td>
<p>the data matrix</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_colind">colind</code></td>
<td>
<p>column indices</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed data
</p>

<hr>
<h2 id='bi_projector'>Construct a bi_projector instance</h2><span id='topic+bi_projector'></span>

<h3>Description</h3>

<p>A bi_projector offers a two-way mapping from samples (rows) to scores and from variables (columns) to components.
Thus, one can project from D-dimensional input space to d-dimensional subspace. And one can project (project_vars) from n-dimensional
variable space to the d-dimensional component space. The singular value decomposition is a canonical example of such a two-way mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_projector(v, s, sdev, preproc = prep(pass()), classes = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_projector_+3A_v">v</code></td>
<td>
<p>A matrix of coefficients with dimensions <code>nrow(v)</code> by <code>ncol(v)</code> (number of columns = number of components)</p>
</td></tr>
<tr><td><code id="bi_projector_+3A_s">s</code></td>
<td>
<p>The score matrix</p>
</td></tr>
<tr><td><code id="bi_projector_+3A_sdev">sdev</code></td>
<td>
<p>The standard deviations of the score matrix</p>
</td></tr>
<tr><td><code id="bi_projector_+3A_preproc">preproc</code></td>
<td>
<p>(optional) A pre-processing pipeline, default is prep(pass())</p>
</td></tr>
<tr><td><code id="bi_projector_+3A_classes">classes</code></td>
<td>
<p>(optional) A character vector specifying the class attributes of the object, default is NULL</p>
</td></tr>
<tr><td><code id="bi_projector_+3A_...">...</code></td>
<td>
<p>Extra arguments to be stored in the <code>projector</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bi_projector object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(200), 10, 20)
svdfit &lt;- svd(X)

p &lt;- bi_projector(svdfit$v, s = svdfit$u %% diag(svdfit$d), sdev=svdfit$d)
</code></pre>

<hr>
<h2 id='bi_projector_union'>A Union of Concatenated <code>bi_projector</code> Fits</h2><span id='topic+bi_projector_union'></span>

<h3>Description</h3>

<p>This function combines a set of <code>bi_projector</code> fits into a single <code>bi_projector</code> instance.
The new instance's weights and associated scores are obtained by concatenating the weights
and scores of the input fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_projector_union(fits, outer_block_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_projector_union_+3A_fits">fits</code></td>
<td>
<p>A list of <code>bi_projector</code> instances with the same row space. These instances
will be combined to create a new <code>bi_projector</code> instance.</p>
</td></tr>
<tr><td><code id="bi_projector_union_+3A_outer_block_indices">outer_block_indices</code></td>
<td>
<p>An optional list of indices for the outer blocks. If not provided,
the function will compute the indices based on the dimensions of the input fits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>bi_projector</code> instance with concatenated weights, scores, and other
properties from the input <code>bi_projector</code> instances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1 &lt;- matrix(rnorm(5*5), 5, 5)
X2 &lt;- matrix(rnorm(5*5), 5, 5)

bpu &lt;- bi_projector_union(list(pca(X1), pca(X2)))

</code></pre>

<hr>
<h2 id='block_indices'>get block_indices</h2><span id='topic+block_indices'></span>

<h3>Description</h3>

<p>extract the list of indices associated with each block in a <code>multiblock</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_indices(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_indices_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="block_indices_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of block indices
</p>

<hr>
<h2 id='block_lengths'>get block_lengths</h2><span id='topic+block_lengths'></span>

<h3>Description</h3>

<p>extract the lengths of each block in a multiblock object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_lengths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_lengths_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the block lengths
</p>

<hr>
<h2 id='bootstrap'>Bootstrap Resampling for Multivariate Models</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Perform bootstrap resampling on a multivariate model to estimate the variability of components and scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(x, nboot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>A fitted model object, such as a <code>projector</code>, that has been fit to a training dataset.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>An integer specifying the number of bootstrap resamples to perform.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>bootstrap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the bootstrap resampled components and scores for the model.
</p>

<hr>
<h2 id='bootstrap.pca'>PCA Bootstrap Resampling</h2><span id='topic+bootstrap.pca'></span>

<h3>Description</h3>

<p>Perform bootstrap resampling for Principal Component Analysis (PCA) to estimate component and score variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pca'
bootstrap(x, nboot = 100, k = ncomp(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.pca_+3A_x">x</code></td>
<td>
<p>A fitted PCA model object.</p>
</td></tr>
<tr><td><code id="bootstrap.pca_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap resamples (default: 100).</p>
</td></tr>
<tr><td><code id="bootstrap.pca_+3A_k">k</code></td>
<td>
<p>The number of components to bootstrap (default: all components in the fitted PCA model).</p>
</td></tr>
<tr><td><code id="bootstrap.pca_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>bootstrap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing bootstrap z-scores for the loadings (<code>zboot_loadings</code>) and scores (<code>zboot_scores</code>).
</p>


<h3>References</h3>

<p>Fisher, Aaron, Brian Caffo, Brian Schwartz, and Vadim Zipunnikov. 2016.
&quot;Fast, Exact Bootstrap Principal Component Analysis for P &gt; 1 Million.&quot; <em>Journal of the American Statistical Association</em> 111 (514): 846-60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(10*100), 10, 100)
x &lt;- pca(X, ncomp=9)
bootstrap_results &lt;- bootstrap(x)

</code></pre>

<hr>
<h2 id='center'>center a data matrix</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>remove mean of all columns in matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(preproc = prepper(), cmeans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processing pipeline</p>
</td></tr>
<tr><td><code id="center_+3A_cmeans">cmeans</code></td>
<td>
<p>optional vector of precomputed column means</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>prepper</code> list
</p>

<hr>
<h2 id='classifier'>Construct a Classifier</h2><span id='topic+classifier'></span>

<h3>Description</h3>

<p>Create a classifier from a given model object (e.g., <code>projector</code>). This classifier can generate predictions for new data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifier(x, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifier_+3A_x">x</code></td>
<td>
<p>A model object, such as a <code>projector</code>, that has been fit to a training dataset.</p>
</td></tr>
<tr><td><code id="classifier_+3A_colind">colind</code></td>
<td>
<p>Optional vector of column indices used for prediction. If not provided, all columns will be used.</p>
</td></tr>
<tr><td><code id="classifier_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>classifier</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A classifier function that can be used to make predictions on new data points.
</p>

<hr>
<h2 id='classifier.discriminant_projector'>Create a k-NN classifier for a discriminant projector</h2><span id='topic+classifier.discriminant_projector'></span>

<h3>Description</h3>

<p>Constructs a k-NN classifier for a discriminant projector, with an option to use a subset of the components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discriminant_projector'
classifier(x, colind = NULL, knn = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifier.discriminant_projector_+3A_x">x</code></td>
<td>
<p>the discriminant projector object</p>
</td></tr>
<tr><td><code id="classifier.discriminant_projector_+3A_colind">colind</code></td>
<td>
<p>an optional vector specifying the column indices of the components to use for prediction (NULL by default)</p>
</td></tr>
<tr><td><code id="classifier.discriminant_projector_+3A_knn">knn</code></td>
<td>
<p>the number of nearest neighbors to consider in the k-NN classifier (default is 1)</p>
</td></tr>
<tr><td><code id="classifier.discriminant_projector_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a classifier object
</p>

<hr>
<h2 id='classifier.multiblock_biprojector'>Multiblock Bi-Projector Classifier</h2><span id='topic+classifier.multiblock_biprojector'></span>

<h3>Description</h3>

<p>Constructs a classifier for a multiblock bi-projector model that can generate predictions for new data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock_biprojector'
classifier(
  x,
  colind = NULL,
  labels,
  new_data = NULL,
  block = NULL,
  knn = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifier.multiblock_biprojector_+3A_x">x</code></td>
<td>
<p>A fitted multiblock bi-projector model object.</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_colind">colind</code></td>
<td>
<p>An optional vector of column indices used for prediction (default: NULL).</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_labels">labels</code></td>
<td>
<p>A factor or vector of class labels for the training data.</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_new_data">new_data</code></td>
<td>
<p>An optional data matrix for which to generate predictions (default: NULL).</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_block">block</code></td>
<td>
<p>An optional block index for prediction (default: NULL).</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_knn">knn</code></td>
<td>
<p>The number of nearest neighbors to consider in the classifier (default: 1).</p>
</td></tr>
<tr><td><code id="classifier.multiblock_biprojector_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>classifier</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multiblock classifier object.
</p>


<h3>See Also</h3>

<p>Other classifier: 
<code><a href="#topic+classifier.projector">classifier.projector</a>()</code>
</p>

<hr>
<h2 id='classifier.projector'>create <code>classifier</code> from a <code>projector</code></h2><span id='topic+classifier.projector'></span>

<h3>Description</h3>

<p>create <code>classifier</code> from a <code>projector</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projector'
classifier(x, colind = NULL, labels, new_data, knn = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifier.projector_+3A_x">x</code></td>
<td>
<p>A model object, such as a <code>projector</code>, that has been fit to a training dataset.</p>
</td></tr>
<tr><td><code id="classifier.projector_+3A_colind">colind</code></td>
<td>
<p>Optional vector of column indices used for prediction. If not provided, all columns will be used.</p>
</td></tr>
<tr><td><code id="classifier.projector_+3A_labels">labels</code></td>
<td>
<p>the labels associated with the rows of the projected data (see <code>new_data</code>)</p>
</td></tr>
<tr><td><code id="classifier.projector_+3A_new_data">new_data</code></td>
<td>
<p>reference data associated with <code>labels</code> and to be projected into subspace (required).</p>
</td></tr>
<tr><td><code id="classifier.projector_+3A_knn">knn</code></td>
<td>
<p>the number of nearest neighbors to use when classifying a new point.</p>
</td></tr>
<tr><td><code id="classifier.projector_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>classifier</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>classifier</code> object
</p>


<h3>See Also</h3>

<p>Other classifier: 
<code><a href="#topic+classifier.multiblock_biprojector">classifier.multiblock_biprojector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- iris[,1:4]
pcres &lt;- pca(as.matrix(X),2)
cfier &lt;- classifier(pcres, labels=iris[,5], new_data=as.matrix(iris[,1:4]))
p &lt;- predict(cfier, as.matrix(iris[,1:4]))
</code></pre>

<hr>
<h2 id='coef.cross_projector'>Extract coefficients from a cross_projector object</h2><span id='topic+coef.cross_projector'></span>

<h3>Description</h3>

<p>Extract coefficients from a cross_projector object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross_projector'
coef(object, source = c("X", "Y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cross_projector_+3A_object">object</code></td>
<td>
<p>the model fit</p>
</td></tr>
<tr><td><code id="coef.cross_projector_+3A_source">source</code></td>
<td>
<p>the source of the data (X or Y block), either &quot;X&quot; or &quot;Y&quot;</p>
</td></tr>
<tr><td><code id="coef.cross_projector_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coefficients
</p>

<hr>
<h2 id='colscale'>scale a data matrix</h2><span id='topic+colscale'></span>

<h3>Description</h3>

<p>normalize each column by a scale factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colscale(preproc = prepper(), type = c("unit", "z", "weights"), weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colscale_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processing pipeline</p>
</td></tr>
<tr><td><code id="colscale_+3A_type">type</code></td>
<td>
<p>the kind of scaling, <code>unit</code> norm, <code>z</code>-scoring, or precomputed <code>weights</code></p>
</td></tr>
<tr><td><code id="colscale_+3A_weights">weights</code></td>
<td>
<p>optional precomputed weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>prepper</code> list
</p>

<hr>
<h2 id='components'>get the components</h2><span id='topic+components'></span>

<h3>Description</h3>

<p>Extract the component matrix of a fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>the model fit</p>
</td></tr>
<tr><td><code id="components_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the component matrix
</p>

<hr>
<h2 id='compose_projector'>Compose Two Projectors</h2><span id='topic+compose_projector'></span>

<h3>Description</h3>

<p>Combine two projector models into a single projector by sequentially applying the first projector and then the second projector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_projector(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_projector_+3A_x">x</code></td>
<td>
<p>A fitted model object (e.g., <code>projector</code>) that has been fit to a dataset and will be applied first in the composition.</p>
</td></tr>
<tr><td><code id="compose_projector_+3A_y">y</code></td>
<td>
<p>A second fitted model object (e.g., <code>projector</code>) that has been fit to a dataset and will be applied after the first projector.</p>
</td></tr>
<tr><td><code id="compose_projector_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>compose_projector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>projector</code> object representing the composed projector, which can be used to project data onto the combined subspace.
</p>

<hr>
<h2 id='compose_projectors'>Projector Composition</h2><span id='topic+compose_projectors'></span>

<h3>Description</h3>

<p>Compose a sequence of <code>projector</code> objects in forward order.
This function allows the composition of multiple projectors, applying them sequentially to the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_projectors(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_projectors_+3A_...">...</code></td>
<td>
<p>The sequence of <code>projector</code> objects to be composed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>composed_projector</code> object that extends the <code>function</code> class, allowing the composed projectors to be
applied to input data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projector">projector</a></code>, <code><a href="#topic+project">project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two PCA projectors and compose them
X &lt;- matrix(rnorm(20*20), 20, 20)
pca1 &lt;- pca(X, ncomp=10)
X2 &lt;- scores(pca1)
pca2 &lt;- pca(X2, ncomp=4)

# Compose the PCA projectors
cproj &lt;- compose_projectors(pca1, pca2)

# Ensure the output of the composed projectors has the expected dimensions
stopifnot(ncol(cproj(X)) == 4)
# Check that the composed projectors work as expected
all.equal(project(cproj, X), cproj(X))
</code></pre>

<hr>
<h2 id='concat_pre_processors'>bind together blockwise pre-processors</h2><span id='topic+concat_pre_processors'></span>

<h3>Description</h3>

<p>concatenate a sequence of pre-processors, each previously applied to a block of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat_pre_processors(preprocs, block_indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat_pre_processors_+3A_preprocs">preprocs</code></td>
<td>
<p>a list of initialized <code>pre-processor</code> objects</p>
</td></tr>
<tr><td><code id="concat_pre_processors_+3A_block_indices">block_indices</code></td>
<td>
<p>a list of block indices where each vector in the list
contains the global indices of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new <code>prepper</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- center() |&gt; prep()
p2 &lt;- center() |&gt; prep()

x1 &lt;- rbind(1:10, 2:11)
x2 &lt;- rbind(1:10, 2:11)

p1a &lt;- init_transform(p1,x1)
p2a &lt;- init_transform(p2,x2)

clist &lt;- concat_pre_processors(list(p1,p2), list(1:10, 11:20))
t1 &lt;- apply_transform(clist, cbind(x1,x2))

t2 &lt;- apply_transform(clist, cbind(x1,x2[,1:5]), colind=1:15)
</code></pre>

<hr>
<h2 id='convert_domain'>Transfer data from one input domain to another via common latent space</h2><span id='topic+convert_domain'></span>

<h3>Description</h3>

<p>Convert between data representations in a multiblock decomposition/alignment by projecting
the input data onto a common latent space and then reconstructing it in the target domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_domain(x, new_data, i, j, comp, rowind, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_domain_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of a class that implements a <code>transfer</code> method</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_new_data">new_data</code></td>
<td>
<p>The data to transfer, with the same number of rows as the source data block</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_i">i</code></td>
<td>
<p>The index of the source data block</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_j">j</code></td>
<td>
<p>The index of the destination data block</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_comp">comp</code></td>
<td>
<p>A vector of component indices to use in the reconstruction</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_rowind">rowind</code></td>
<td>
<p>Optional set of row indices to transfer (default: all rows)</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_colind">colind</code></td>
<td>
<p>Optional set of column indices to transfer (default: all columns)</p>
</td></tr>
<tr><td><code id="convert_domain_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>convert_domain</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data frame representing the transferred data in the target domain
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project_block">project_block</a></code> for projecting a single block of data onto the subspace
</p>

<hr>
<h2 id='cross_projector'>Two-way (cross) projection to latent components</h2><span id='topic+cross_projector'></span>

<h3>Description</h3>

<p>A projector that reduces two blocks of data, X and Y, yielding a pair of weights for each component.
This structure can be used, for example, to store weights derived from canonical correlation analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_projector(
  vx,
  vy,
  preproc_x = prep(pass()),
  preproc_y = prep(pass()),
  ...,
  classes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_projector_+3A_vx">vx</code></td>
<td>
<p>the X coefficients</p>
</td></tr>
<tr><td><code id="cross_projector_+3A_vy">vy</code></td>
<td>
<p>the Y coefficients</p>
</td></tr>
<tr><td><code id="cross_projector_+3A_preproc_x">preproc_x</code></td>
<td>
<p>the X pre-processor</p>
</td></tr>
<tr><td><code id="cross_projector_+3A_preproc_y">preproc_y</code></td>
<td>
<p>the Y pre-processor</p>
</td></tr>
<tr><td><code id="cross_projector_+3A_...">...</code></td>
<td>
<p>extra parameters or results to store</p>
</td></tr>
<tr><td><code id="cross_projector_+3A_classes">classes</code></td>
<td>
<p>additional class names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class extends <code>projector</code> and therefore basic operations such as <code>project</code>, <code>shape</code>, <code>reprocess</code>,
and <code>coef</code> work, but by default, it is assumed that the <code>X</code> block is primary. To access <code>Y</code> block operations, an
additional argument <code>source</code> must be supplied to the relevant functions, e.g., <code>coef(fit, source = "Y")</code>
</p>


<h3>Value</h3>

<p>a cross_projector object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two scaled matrices X and Y
X &lt;- scale(matrix(rnorm(10 * 5), 10, 5))
Y &lt;- scale(matrix(rnorm(10 * 5), 10, 5))

# Perform canonical correlation analysis on X and Y
cres &lt;- cancor(X, Y)
sx &lt;- X %*% cres$xcoef
sy &lt;- Y %*% cres$ycoef

# Create a cross_projector object using the canonical correlation analysis results
canfit &lt;- cross_projector(cres$xcoef, cres$ycoef, cor = cres$cor,
                          sx = sx, sy = sy, classes = "cancor")
</code></pre>

<hr>
<h2 id='discriminant_projector'>Construct a Discriminant Projector</h2><span id='topic+discriminant_projector'></span>

<h3>Description</h3>

<p>A <code>discriminant_projector</code> is an instance that extends <code>bi_projector</code> with a projection that maximizes class separation.
This can be useful for dimensionality reduction techniques that take class labels into account, such as Linear Discriminant Analysis (LDA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discriminant_projector(
  v,
  s,
  sdev,
  preproc = prep(pass()),
  labels,
  classes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discriminant_projector_+3A_v">v</code></td>
<td>
<p>A matrix of coefficients with dimensions <code>nrow(v)</code> by <code>ncol(v)</code> (number of columns = number of components)</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_s">s</code></td>
<td>
<p>The score matrix</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_sdev">sdev</code></td>
<td>
<p>The standard deviations of the score matrix</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_preproc">preproc</code></td>
<td>
<p>(optional) A pre-processing pipeline, default is prep(pass())</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_labels">labels</code></td>
<td>
<p>A factor or character vector of class labels corresponding to the rows of the score matrix <code>s</code>.</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_classes">classes</code></td>
<td>
<p>(optional) A character vector specifying the class attributes of the object, default is NULL</p>
</td></tr>
<tr><td><code id="discriminant_projector_+3A_...">...</code></td>
<td>
<p>Extra arguments to be stored in the <code>projector</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>discriminant_projector</code> object.
</p>


<h3>See Also</h3>

<p>bi_projector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and labels
set.seed(123)
X &lt;- matrix(rnorm(100 * 10), 100, 10)
labels &lt;- factor(rep(1:2, each = 50))

# Perform LDA and create a discriminant projector
lda_fit &lt;- MASS::lda(X, labels)

dp &lt;- discriminant_projector(lda_fit$scaling, X %*% lda_fit$scaling, sdev = lda_fit$svd, 
labels = labels)
</code></pre>

<hr>
<h2 id='fresh'>Get a fresh pre-processing node cleared of any cached data</h2><span id='topic+fresh'></span>

<h3>Description</h3>

<p>Get a fresh pre-processing node cleared of any cached data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fresh(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fresh_+3A_x">x</code></td>
<td>
<p>the processing pipeline</p>
</td></tr>
<tr><td><code id="fresh_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fresh pre-processing pipeline
</p>

<hr>
<h2 id='group_means'>Compute column-wise mean in X for each factor level of Y</h2><span id='topic+group_means'></span>

<h3>Description</h3>

<p>This function computes group means for each factor level of Y in the provided data matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_means(Y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_means_+3A_y">Y</code></td>
<td>
<p>a vector of labels to compute means over disjoint sets</p>
</td></tr>
<tr><td><code id="group_means_+3A_x">X</code></td>
<td>
<p>a data matrix from which to compute means</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with row names corresponding to factor levels of Y and column-wise means for each factor level
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data
X &lt;- matrix(rnorm(50), 10, 5)
Y &lt;- factor(rep(1:2, each = 5))

# Compute group means
gm &lt;- group_means(Y, X)
</code></pre>

<hr>
<h2 id='init_transform'>initialize a transform</h2><span id='topic+init_transform'></span>

<h3>Description</h3>

<p>initialize a transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_transform(x, X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_transform_+3A_x">x</code></td>
<td>
<p>the pre_processor</p>
</td></tr>
<tr><td><code id="init_transform_+3A_x">X</code></td>
<td>
<p>the data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an initialized pre-processor
</p>

<hr>
<h2 id='inverse_projection'>Inverse of the Component Matrix</h2><span id='topic+inverse_projection'></span>

<h3>Description</h3>

<p>Return the inverse projection matrix, which can be used to map back to data space.
If the component matrix is orthogonal, then the inverse projection is the transpose of the component matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_projection(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_projection_+3A_x">x</code></td>
<td>
<p>The model fit.</p>
</td></tr>
<tr><td><code id="inverse_projection_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse projection matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> for projecting data onto the subspace.
</p>

<hr>
<h2 id='is_orthogonal'>is it orthogonal</h2><span id='topic+is_orthogonal'></span>

<h3>Description</h3>

<p>test whether components are orthogonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_orthogonal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_orthogonal_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether the transformation is orthogonal
</p>

<hr>
<h2 id='multiblock_biprojector'>Create a Multiblock Bi-Projector</h2><span id='topic+multiblock_biprojector'></span>

<h3>Description</h3>

<p>Constructs a multiblock bi-projector using the given component matrix (<code>v</code>), score matrix (<code>s</code>), singular values (<code>sdev</code>),
a preprocessing function, and a list of block indices. This allows for the projection of multiblock data, where each block
represents a different set of variables or features, with two-way mapping from samples to scores and from variables to components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiblock_biprojector(
  v,
  s,
  sdev,
  preproc = prep(pass()),
  ...,
  block_indices,
  classes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiblock_biprojector_+3A_v">v</code></td>
<td>
<p>A matrix of components with dimensions <code>nrow(v)</code> by <code>ncol(v)</code> (number of columns = number of components).</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_s">s</code></td>
<td>
<p>A matrix of scores.</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_sdev">sdev</code></td>
<td>
<p>A numeric vector of singular values.</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_preproc">preproc</code></td>
<td>
<p>A pre-processing function for the data (default is a pass-through with <code>prep(pass())</code>).</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_block_indices">block_indices</code></td>
<td>
<p>A list of numeric vectors specifying the indices of each data block.</p>
</td></tr>
<tr><td><code id="multiblock_biprojector_+3A_classes">classes</code></td>
<td>
<p>(optional) A character vector specifying the class attributes of the object, default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>multiblock_biprojector</code> object.
</p>


<h3>See Also</h3>

<p>bi_projector, multiblock_projector
</p>

<hr>
<h2 id='multiblock_projector'>Create a Multiblock Projector</h2><span id='topic+multiblock_projector'></span>

<h3>Description</h3>

<p>Constructs a multiblock projector using the given component matrix (<code>v</code>), a preprocessing function, and a list of block indices.
This allows for the projection of multiblock data, where each block represents a different set of variables or features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiblock_projector(
  v,
  preproc = prep(pass()),
  ...,
  block_indices,
  classes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiblock_projector_+3A_v">v</code></td>
<td>
<p>A matrix of components with dimensions <code>nrow(v)</code> by <code>ncol(v)</code> (number of columns = number of components).</p>
</td></tr>
<tr><td><code id="multiblock_projector_+3A_preproc">preproc</code></td>
<td>
<p>A pre-processing function for the data (default is a pass-through with <code>prep(pass())</code>).</p>
</td></tr>
<tr><td><code id="multiblock_projector_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
<tr><td><code id="multiblock_projector_+3A_block_indices">block_indices</code></td>
<td>
<p>A list of numeric vectors specifying the indices of each data block.</p>
</td></tr>
<tr><td><code id="multiblock_projector_+3A_classes">classes</code></td>
<td>
<p>(optional) A character vector specifying the class attributes of the object, default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>multiblock_projector</code> object.
</p>


<h3>See Also</h3>

<p>projector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some example data
X1 &lt;- matrix(rnorm(10 * 5), 10, 5)
X2 &lt;- matrix(rnorm(10 * 5), 10, 5)
X &lt;- cbind(X1, X2)

# Compute PCA on the combined data
pc &lt;- pca(X, ncomp = 8)

# Create a multiblock projector using PCA components and block indices
mb_proj &lt;- multiblock_projector(pc$v, block_indices = list(1:5, 6:10))

# Project the multiblock data using the multiblock projector
mb_scores &lt;- project(mb_proj, X)
</code></pre>

<hr>
<h2 id='nblocks'>get the number of blocks</h2><span id='topic+nblocks'></span>

<h3>Description</h3>

<p>The number of data blocks in a multiblock element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nblocks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nblocks_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of blocks
</p>

<hr>
<h2 id='ncomp'>Get the number of components</h2><span id='topic+ncomp'></span>

<h3>Description</h3>

<p>This function returns the total number of components in the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncomp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncomp_+3A_x">x</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of components in the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using the svd_wrapper function
data(iris)
X &lt;- iris[, 1:4]
fit &lt;- svd_wrapper(X, ncomp = 3, preproc = center(), method = "base")
ncomp(fit) # Should return 3
</code></pre>

<hr>
<h2 id='nystrom_embedding'>Nystrom method for out-of-sample embedding</h2><span id='topic+nystrom_embedding'></span>

<h3>Description</h3>

<p>Approximate the embedding of a new data point using the Nystrom method, which is particularly useful
for large datasets and data-dependent embedding spaces, such as multidimensional scaling (MDS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nystrom_embedding(
  new_data,
  landmark_data,
  kernel_function,
  eigenvectors,
  eigenvalues,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nystrom_embedding_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or data frame containing the new data points to be projected.</p>
</td></tr>
<tr><td><code id="nystrom_embedding_+3A_landmark_data">landmark_data</code></td>
<td>
<p>A matrix or data frame containing the landmark data points used for approximation.</p>
</td></tr>
<tr><td><code id="nystrom_embedding_+3A_kernel_function">kernel_function</code></td>
<td>
<p>A function used to compute the kernel matrix (e.g., a distance function for MDS).</p>
</td></tr>
<tr><td><code id="nystrom_embedding_+3A_eigenvectors">eigenvectors</code></td>
<td>
<p>A matrix containing the eigenvectors obtained from the eigendecomposition of the
kernel matrix between the landmark points.</p>
</td></tr>
<tr><td><code id="nystrom_embedding_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>A vector containing the eigenvalues obtained from the eigendecomposition of the
kernel matrix between the landmark points.</p>
</td></tr>
<tr><td><code id="nystrom_embedding_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the kernel_function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the approximate embedding of the new_data in the data-dependent space.
</p>

<hr>
<h2 id='partial_inverse_projection'>Partial Inverse Projection of a Columnwise Subset of Component Matrix</h2><span id='topic+partial_inverse_projection'></span>

<h3>Description</h3>

<p>Compute the inverse projection of a columnwise subset of the component matrix (e.g., a sub-block).
Even when the full component matrix is orthogonal, there is no guarantee that the partial component matrix is orthogonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_inverse_projection(x, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_inverse_projection_+3A_x">x</code></td>
<td>
<p>A fitted model object, such as a <code>projector</code>, that has been fit to a dataset.</p>
</td></tr>
<tr><td><code id="partial_inverse_projection_+3A_colind">colind</code></td>
<td>
<p>A numeric vector specifying the column indices of the component matrix to consider for the partial inverse projection.</p>
</td></tr>
<tr><td><code id="partial_inverse_projection_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>partial_inverse_projection</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the partial inverse projection.
</p>

<hr>
<h2 id='partial_project'>Partially project a new sample onto subspace</h2><span id='topic+partial_project'></span>

<h3>Description</h3>

<p>Project a selected subset of column indices onto the subspace. This function allows for the projection of new data
onto a lower-dimensional space using only a subset of the variables, as specified by the column indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_project(x, new_data, colind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_project_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of class <code>bi_projector</code> or any other class that implements a <code>partial_project</code> method</p>
</td></tr>
<tr><td><code id="partial_project_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or vector of new observations with a subset of columns equal to length of <code>colind</code>. Rows represent observations and columns represent variables</p>
</td></tr>
<tr><td><code id="partial_project_+3A_colind">colind</code></td>
<td>
<p>A numeric vector of column indices to select in the projection matrix. These indices correspond to the variables used for the partial projection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of the partially projected observations, where rows represent observations and columns represent the lower-dimensional space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_projector">bi_projector</a></code> for an example of a class that implements a <code>partial_project</code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with the bi_projector class
X &lt;- matrix(rnorm(10*20), 10, 20)
svdfit &lt;- svd(X)
p &lt;- bi_projector(svdfit$v, s = svdfit$u %*% diag(svdfit$d), sdev=svdfit$d)

# Partially project new_data onto the same subspace as the original data 
# using only the first 10 variables
new_data &lt;- matrix(rnorm(5*20), 5, 20)
colind &lt;- 1:10
partially_projected_data &lt;- partial_project(p, new_data[,colind], colind)
</code></pre>

<hr>
<h2 id='partial_projector'>Construct a partial projector</h2><span id='topic+partial_projector'></span>

<h3>Description</h3>

<p>Create a new projector instance restricted to a subset of input columns. This function allows for the generation of
a new projection object that focuses only on the specified columns, enabling the projection of data using a limited
set of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_projector(x, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_projector_+3A_x">x</code></td>
<td>
<p>The original <code>projector</code> instance, typically an object of class <code>bi_projector</code> or any other class that implements a <code>partial_projector</code> method</p>
</td></tr>
<tr><td><code id="partial_projector_+3A_colind">colind</code></td>
<td>
<p>A numeric vector of column indices to select in the projection matrix. These indices correspond to the variables used for the partial projector</p>
</td></tr>
<tr><td><code id="partial_projector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>partial_projector</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>projector</code> instance, with the same class as the original object, that is restricted to the specified subset of input columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_projector">bi_projector</a></code> for an example of a class that implements a <code>partial_projector</code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with the bi_projector class
X &lt;- matrix(rnorm(10*20), 10, 20)
svdfit &lt;- svd(X)
p &lt;- bi_projector(svdfit$v, s = svdfit$u %*% diag(svdfit$d), sdev=svdfit$d)

# Create a partial projector using only the first 10 variables
colind &lt;- 1:10
partial_p &lt;- partial_projector(p, colind)
</code></pre>

<hr>
<h2 id='partial_projector.projector'>construct a partial_projector from a <code>projector</code> instance</h2><span id='topic+partial_projector.projector'></span>

<h3>Description</h3>

<p>construct a partial_projector from a <code>projector</code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projector'
partial_projector(x, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_projector.projector_+3A_x">x</code></td>
<td>
<p>The original <code>projector</code> instance, typically an object of class <code>bi_projector</code> or any other class that implements a <code>partial_projector</code> method</p>
</td></tr>
<tr><td><code id="partial_projector.projector_+3A_colind">colind</code></td>
<td>
<p>A numeric vector of column indices to select in the projection matrix. These indices correspond to the variables used for the partial projector</p>
</td></tr>
<tr><td><code id="partial_projector.projector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>partial_projector</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>partial_projector</code> instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- matrix(rnorm(10*10), 10, 10)
pfit &lt;- pca(X, ncomp=9)
proj &lt;- project(pfit, X)

pp &lt;- partial_projector(pfit, 1:5)
</code></pre>

<hr>
<h2 id='pass'>a no-op pre-processing step</h2><span id='topic+pass'></span>

<h3>Description</h3>

<p><code>pass</code> simply passes its data through the chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pass(preproc = prepper())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pass_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processing pipeline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>prepper</code> list
</p>

<hr>
<h2 id='pca'>Principal Components Analysis (PCA)</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>Compute the directions of maximal variance in a data matrix using the Singular Value Decomposition (SVD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(
  X,
  ncomp = min(dim(X)),
  preproc = center(),
  method = c("fast", "base", "irlba", "propack", "rsvd", "svds"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_x">X</code></td>
<td>
<p>The data matrix.</p>
</td></tr>
<tr><td><code id="pca_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of requested components to estimate (default is the minimum dimension of the data matrix).</p>
</td></tr>
<tr><td><code id="pca_+3A_preproc">preproc</code></td>
<td>
<p>The pre-processing function to apply to the data matrix (default is centering).</p>
</td></tr>
<tr><td><code id="pca_+3A_method">method</code></td>
<td>
<p>The SVD method to use, passed to <code>svd_wrapper</code> (default is &quot;fast&quot;).</p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>Extra arguments to send to <code>svd_wrapper</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bi_projector</code> object containing the PCA results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svd_wrapper">svd_wrapper</a></code> for details on SVD methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- as.matrix(iris[, 1:4])
res &lt;- pca(X, ncomp = 4)
tres &lt;- truncate(res, 3)
</code></pre>

<hr>
<h2 id='perm_ci'>Permutation Confidence Intervals</h2><span id='topic+perm_ci'></span>

<h3>Description</h3>

<p>Estimate confidence intervals for model parameters using permutation testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_ci(x, X, nperm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_ci_+3A_x">x</code></td>
<td>
<p>A model fit object.</p>
</td></tr>
<tr><td><code id="perm_ci_+3A_x">X</code></td>
<td>
<p>The original data matrix used to fit the model.</p>
</td></tr>
<tr><td><code id="perm_ci_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to perform for the confidence interval estimation.</p>
</td></tr>
<tr><td><code id="perm_ci_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the specific model implementation of <code>perm_ci</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated lower and upper bounds of the confidence intervals for model parameters.
</p>

<hr>
<h2 id='predict.classifier'>predict with a classifier object</h2><span id='topic+predict.classifier'></span>

<h3>Description</h3>

<p>predict with a classifier object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classifier'
predict(
  object,
  new_data,
  ncomp = NULL,
  colind = NULL,
  metric = c("cosine", "euclidean"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.classifier_+3A_object">object</code></td>
<td>
<p>the model fit</p>
</td></tr>
<tr><td><code id="predict.classifier_+3A_new_data">new_data</code></td>
<td>
<p>new data to predict on</p>
</td></tr>
<tr><td><code id="predict.classifier_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of components to use</p>
</td></tr>
<tr><td><code id="predict.classifier_+3A_colind">colind</code></td>
<td>
<p>the column indices to select in the projection matrix</p>
</td></tr>
<tr><td><code id="predict.classifier_+3A_metric">metric</code></td>
<td>
<p>the similarity metric (&quot;euclidean&quot; or &quot;cosine&quot;)</p>
</td></tr>
<tr><td><code id="predict.classifier_+3A_...">...</code></td>
<td>
<p>additional arguments to projection function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the predicted class and probabilities
</p>

<hr>
<h2 id='prep'>prepare a dataset by applying a pre-processing pipeline</h2><span id='topic+prep'></span>

<h3>Description</h3>

<p>prepare a dataset by applying a pre-processing pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_+3A_x">x</code></td>
<td>
<p>the pipeline</p>
</td></tr>
<tr><td><code id="prep_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the pre-processed data
</p>

<hr>
<h2 id='prinang'>Compute principal angles for a set of subspaces</h2><span id='topic+prinang'></span>

<h3>Description</h3>

<p>This function calculates the principal angles between subspaces derived from a list of bi_projector instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prinang(fits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prinang_+3A_fits">fits</code></td>
<td>
<p>a list of <code>bi_projector</code> instances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of principal angles with length equal to the minimum dimension of input subspaces
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
X &lt;- as.matrix(iris[, 1:4])
res &lt;- pca(X, ncomp = 4)
fits_list &lt;- list(res,res,res)
principal_angles &lt;- prinang(fits_list)
</code></pre>

<hr>
<h2 id='print.bi_projector'>Pretty Print S3 Method for bi_projector Class</h2><span id='topic+print.bi_projector'></span>

<h3>Description</h3>

<p>Pretty Print S3 Method for bi_projector Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bi_projector'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bi_projector_+3A_x">x</code></td>
<td>
<p>A <code>bi_projector</code> object</p>
</td></tr>
<tr><td><code id="print.bi_projector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>bi_projector</code> object
</p>

<hr>
<h2 id='print.bi_projector_union'>Pretty Print S3 Method for bi_projector_union Class</h2><span id='topic+print.bi_projector_union'></span>

<h3>Description</h3>

<p>Pretty Print S3 Method for bi_projector_union Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bi_projector_union'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bi_projector_union_+3A_x">x</code></td>
<td>
<p>A <code>bi_projector_union</code> object</p>
</td></tr>
<tr><td><code id="print.bi_projector_union_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>bi_projector_union</code> object
</p>

<hr>
<h2 id='print.classifier'>Pretty Print Method for <code>classifier</code> Objects</h2><span id='topic+print.classifier'></span>

<h3>Description</h3>

<p>Display a human-readable summary of a <code>classifier</code> object, including information about the k-NN classifier, the model fit, and the dimensions of the scores matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classifier'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.classifier_+3A_x">x</code></td>
<td>
<p>A <code>classifier</code> object.</p>
</td></tr>
<tr><td><code id="print.classifier_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>classifier</code> object.
</p>

<hr>
<h2 id='print.composed_projector'>Pretty Print Method for <code>composed_projector</code> Objects</h2><span id='topic+print.composed_projector'></span>

<h3>Description</h3>

<p>Display a human-readable summary of a <code>composed_projector</code> object, including information about the number and order of projectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'composed_projector'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.composed_projector_+3A_x">x</code></td>
<td>
<p>A <code>composed_projector</code> object.</p>
</td></tr>
<tr><td><code id="print.composed_projector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>composed_projector</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two PCA projectors and compose them
X &lt;- matrix(rnorm(20*20), 20, 20)
pca1 &lt;- pca(X, ncomp=10)
X2 &lt;- scores(pca1)
pca2 &lt;- pca(X2, ncomp=4)
cproj &lt;- compose_projectors(pca1, pca2)
</code></pre>

<hr>
<h2 id='print.multiblock_biprojector'>Pretty Print Method for <code>multiblock_biprojector</code> Objects</h2><span id='topic+print.multiblock_biprojector'></span>

<h3>Description</h3>

<p>Display a human-readable summary of a <code>multiblock_biprojector</code> object, including information about the dimensions of the projection matrix, the pre-processing pipeline, and block indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock_biprojector'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multiblock_biprojector_+3A_x">x</code></td>
<td>
<p>A <code>multiblock_biprojector</code> object.</p>
</td></tr>
<tr><td><code id="print.multiblock_biprojector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>multiblock_biprojector</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some example data
X1 &lt;- matrix(rnorm(10 * 5), 10, 5)
X2 &lt;- matrix(rnorm(10 * 5), 10, 5)
X &lt;- cbind(X1, X2)
# Compute PCA on the combined data
pc &lt;- pca(X, ncomp = 8)
# Create a multiblock bi-projector using PCA components and block indices
mb_biproj &lt;- multiblock_biprojector(pc$v, s = pc$u %*% diag(sdev(pc)), sdev = sdev(pc), 
block_indices = list(1:5, 6:10))
# Pretty print the multiblock bi-projector object
print(mb_biproj)
</code></pre>

<hr>
<h2 id='print.projector'>Pretty Print Method for <code>projector</code> Objects</h2><span id='topic+print.projector'></span>

<h3>Description</h3>

<p>Display a human-readable summary of a <code>projector</code> object, including information about the dimensions of the projection matrix and the pre-processing pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projector'
print(x, ...)

## S3 method for class 'projector'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.projector_+3A_x">x</code></td>
<td>
<p>A <code>projector</code> object.</p>
</td></tr>
<tr><td><code id="print.projector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>projector</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(10*10), 10, 10)
svdfit &lt;- svd(X)
p &lt;- projector(svdfit$v)
print(p)
</code></pre>

<hr>
<h2 id='project'>New sample projection</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Project one or more samples onto a subspace. This function takes a model fit and new observations, and projects them onto the
subspace defined by the model. This allows for the transformation of new data into the same lower-dimensional space as the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of class bi_projector or any other class that implements a project method</p>
</td></tr>
<tr><td><code id="project_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or vector of new observations with the same number of columns as the original data. Rows represent observations and columns represent variables</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to the specific project method for the object's class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of the projected observations, where rows represent observations and columns represent the lower-dimensional space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_projector">bi_projector</a></code> for an example of a class that implements a project method
</p>
<p>Other project: 
<code><a href="#topic+project.cross_projector">project.cross_projector</a>()</code>,
<code><a href="#topic+project_block">project_block</a>()</code>,
<code><a href="#topic+project_vars">project_vars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with the bi_projector class
X &lt;- matrix(rnorm(10*20), 10, 20)
svdfit &lt;- svd(X)
p &lt;- bi_projector(svdfit$v, s = svdfit$u %% diag(svdfit$d), sdev=svdfit$d)

# Project new_data onto the same subspace as the original data
new_data &lt;- matrix(rnorm(5*20), 5, 20)
projected_data &lt;- project(p, new_data)
</code></pre>

<hr>
<h2 id='project_block'>Project a single &quot;block&quot; of data onto the subspace</h2><span id='topic+project_block'></span>

<h3>Description</h3>

<p>When observations are concatenated into &quot;blocks&quot;, it may be useful to project one block from the set.
This function facilitates the projection of a specific block of data onto a subspace. It is a
convenience method for multi-block fits and is equivalent to a &quot;partial projection&quot; where the
column indices are associated with a given block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_block(x, new_data, block, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_block_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of a class that implements a <code>project_block</code> method</p>
</td></tr>
<tr><td><code id="project_block_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or vector of new observation(s) with the same number of columns as the original data</p>
</td></tr>
<tr><td><code id="project_block_+3A_block">block</code></td>
<td>
<p>An integer representing the block ID to select in the block projection matrix. This ID corresponds to the specific block of data to be projected</p>
</td></tr>
<tr><td><code id="project_block_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>project_block</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of the projected data for the specified block
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> for the generic projection function
</p>
<p>Other project: 
<code><a href="#topic+project">project</a>()</code>,
<code><a href="#topic+project.cross_projector">project.cross_projector</a>()</code>,
<code><a href="#topic+project_vars">project_vars</a>()</code>
</p>

<hr>
<h2 id='project_vars'>Project one or more variables onto a subspace</h2><span id='topic+project_vars'></span>

<h3>Description</h3>

<p>This function projects one or more variables onto a subspace. It is often called supplementary variable
projection and can be computed for a biorthogonal decomposition, such as Singular Value Decomposition (SVD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_vars(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_vars_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of a class that implements a <code>project_vars</code> method</p>
</td></tr>
<tr><td><code id="project_vars_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or vector of new observation(s) with the same number of rows as the original data</p>
</td></tr>
<tr><td><code id="project_vars_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>project_vars</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of the projected variables in the subspace
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> for the generic projection function for samples
</p>
<p>Other project: 
<code><a href="#topic+project">project</a>()</code>,
<code><a href="#topic+project.cross_projector">project.cross_projector</a>()</code>,
<code><a href="#topic+project_block">project_block</a>()</code>
</p>

<hr>
<h2 id='project.cross_projector'>project a cross_projector instance</h2><span id='topic+project.cross_projector'></span>

<h3>Description</h3>

<p>project a cross_projector instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross_projector'
project(x, new_data, source = c("X", "Y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.cross_projector_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of class bi_projector or any other class that implements a project method</p>
</td></tr>
<tr><td><code id="project.cross_projector_+3A_new_data">new_data</code></td>
<td>
<p>A matrix or vector of new observations with the same number of columns as the original data. Rows represent observations and columns represent variables</p>
</td></tr>
<tr><td><code id="project.cross_projector_+3A_source">source</code></td>
<td>
<p>the source of the data (X or Y block)</p>
</td></tr>
<tr><td><code id="project.cross_projector_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to the specific project method for the object's class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the projected data
</p>


<h3>See Also</h3>

<p>Other project: 
<code><a href="#topic+project">project</a>()</code>,
<code><a href="#topic+project_block">project_block</a>()</code>,
<code><a href="#topic+project_vars">project_vars</a>()</code>
</p>

<hr>
<h2 id='projector'>Construct a <code>projector</code> instance</h2><span id='topic+projector'></span>

<h3>Description</h3>

<p>A <code>projector</code> maps a matrix from an N-dimensional space to d-dimensional space, where <code>d</code> may be less than <code>N</code>.
The projection matrix, <code>v</code>, is not necessarily orthogonal. This function constructs a <code>projector</code> instance which can be
used for various dimensionality reduction techniques like PCA, LDA, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projector(v, preproc = prep(pass()), ..., classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projector_+3A_v">v</code></td>
<td>
<p>A matrix of coefficients with dimensions <code>nrow(v)</code> by <code>ncol(v)</code> (number of columns = number of components)</p>
</td></tr>
<tr><td><code id="projector_+3A_preproc">preproc</code></td>
<td>
<p>A prepped pre-processing object. Default is the no-processing <code>pass()</code> preprocessor.</p>
</td></tr>
<tr><td><code id="projector_+3A_...">...</code></td>
<td>
<p>Extra arguments to be stored in the <code>projector</code> object.</p>
</td></tr>
<tr><td><code id="projector_+3A_classes">classes</code></td>
<td>
<p>Additional class information used for creating subtypes of <code>projector</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of type <code>projector</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(10*10), 10, 10)
svdfit &lt;- svd(X)
p &lt;- projector(svdfit$v)
proj &lt;- project(p, X)

</code></pre>

<hr>
<h2 id='reconstruct'>Reconstruct the data</h2><span id='topic+reconstruct'></span>

<h3>Description</h3>

<p>Reconstruct a data set from its (possibly) low-rank representation. This can be useful when analyzing
the impact of dimensionality reduction or when visualizing approximations of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct(x, comp, rowind, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of a class that implements a <code>reconstruct</code> method</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_comp">comp</code></td>
<td>
<p>A vector of component indices to use in the reconstruction</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_rowind">rowind</code></td>
<td>
<p>The row indices to reconstruct (optional). If not provided, all rows are used.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_colind">colind</code></td>
<td>
<p>The column indices to reconstruct (optional). If not provided, all columns are used.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>reconstruct</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reconstructed data set based on the selected components, rows, and columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_projector">bi_projector</a></code> for an example of a two-way mapping model that can be reconstructed
</p>

<hr>
<h2 id='refit'>refit a model</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>refit a model given new data or new parameter(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_+3A_x">x</code></td>
<td>
<p>the original model fit object</p>
</td></tr>
<tr><td><code id="refit_+3A_new_data">new_data</code></td>
<td>
<p>the new data to process</p>
</td></tr>
<tr><td><code id="refit_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a refit model object
</p>

<hr>
<h2 id='regress'>Multi-output linear regression</h2><span id='topic+regress'></span>

<h3>Description</h3>

<p>Fit a multivariate regression model for a matrix of basis functions, <code>X</code>, and a response matrix <code>Y</code>.
The goal is to find a projection matrix that can be used for mapping and reconstruction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regress(
  X,
  Y,
  preproc = NULL,
  method = c("lm", "enet", "mridge", "pls"),
  intercept = FALSE,
  lambda = 0.001,
  alpha = 0,
  ncomp = ceiling(ncol(X)/2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regress_+3A_x">X</code></td>
<td>
<p>the set of independent (basis) variables</p>
</td></tr>
<tr><td><code id="regress_+3A_y">Y</code></td>
<td>
<p>the response matrix</p>
</td></tr>
<tr><td><code id="regress_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processor (currently unused)</p>
</td></tr>
<tr><td><code id="regress_+3A_method">method</code></td>
<td>
<p>the regression method: <code>lm</code>, <code>enet</code>, <code>mridge</code>, or <code>pls</code></p>
</td></tr>
<tr><td><code id="regress_+3A_intercept">intercept</code></td>
<td>
<p>whether to include an intercept term</p>
</td></tr>
<tr><td><code id="regress_+3A_lambda">lambda</code></td>
<td>
<p>ridge shrinkage parameter (for methods <code>mridge</code> and <code>enet</code>)</p>
</td></tr>
<tr><td><code id="regress_+3A_alpha">alpha</code></td>
<td>
<p>the elastic net mixing parameter if method is <code>enet</code></p>
</td></tr>
<tr><td><code id="regress_+3A_ncomp">ncomp</code></td>
<td>
<p>number of PLS components if method is <code>pls</code></p>
</td></tr>
<tr><td><code id="regress_+3A_...">...</code></td>
<td>
<p>extra arguments sent to the underlying fitting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bi-projector of type <code>regress</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate synthetic data
Y &lt;- matrix(rnorm(100 * 10), 10, 100)
X &lt;- matrix(rnorm(10 * 9), 10, 9)
# Fit regression models and reconstruct the response matrix
r_lm &lt;- regress(X, Y, intercept = FALSE, method = "lm")
recon_lm &lt;- reconstruct(r_lm)
r_mridge &lt;- regress(X, Y, intercept = TRUE, method = "mridge", lambda = 0.001)
recon_mridge &lt;- reconstruct(r_mridge)
r_enet &lt;- regress(X, Y, intercept = TRUE, method = "enet", lambda = 0.001, alpha = 0.5)
recon_enet &lt;- reconstruct(r_enet)
r_pls &lt;- regress(X, Y, intercept = TRUE, method = "pls", ncomp = 5)
recon_pls &lt;- reconstruct(r_pls)
</code></pre>

<hr>
<h2 id='reprocess'>apply pre-processing parameters to a new data matrix</h2><span id='topic+reprocess'></span>

<h3>Description</h3>

<p>Given a new dataset, process it in the same way the original data was processed (e.g. centering, scaling, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reprocess(x, new_data, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reprocess_+3A_x">x</code></td>
<td>
<p>the model fit object</p>
</td></tr>
<tr><td><code id="reprocess_+3A_new_data">new_data</code></td>
<td>
<p>the new data to process</p>
</td></tr>
<tr><td><code id="reprocess_+3A_colind">colind</code></td>
<td>
<p>the column indices of the new data</p>
</td></tr>
<tr><td><code id="reprocess_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the reprocessed data
</p>

<hr>
<h2 id='reprocess.cross_projector'>reprocess a cross_projector instance</h2><span id='topic+reprocess.cross_projector'></span>

<h3>Description</h3>

<p>reprocess a cross_projector instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross_projector'
reprocess(x, new_data, colind = NULL, source = c("X", "Y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reprocess.cross_projector_+3A_x">x</code></td>
<td>
<p>the model fit object</p>
</td></tr>
<tr><td><code id="reprocess.cross_projector_+3A_new_data">new_data</code></td>
<td>
<p>the new data to process</p>
</td></tr>
<tr><td><code id="reprocess.cross_projector_+3A_colind">colind</code></td>
<td>
<p>the column indices of the new data</p>
</td></tr>
<tr><td><code id="reprocess.cross_projector_+3A_source">source</code></td>
<td>
<p>the source of the data (X or Y block)</p>
</td></tr>
<tr><td><code id="reprocess.cross_projector_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the re(pre-)processed data
</p>

<hr>
<h2 id='residualize'>Compute a regression model for each column in a matrix and return residual matrix</h2><span id='topic+residualize'></span>

<h3>Description</h3>

<p>Compute a regression model for each column in a matrix and return residual matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualize(form, X, design, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualize_+3A_form">form</code></td>
<td>
<p>the formula defining the model to fit for residuals</p>
</td></tr>
<tr><td><code id="residualize_+3A_x">X</code></td>
<td>
<p>the response matrix</p>
</td></tr>
<tr><td><code id="residualize_+3A_design">design</code></td>
<td>
<p>the <code>data.frame</code> containing the design variables specified in <code>form</code> argument.</p>
</td></tr>
<tr><td><code id="residualize_+3A_intercept">intercept</code></td>
<td>
<p>add an intercept term (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> of residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- matrix(rnorm(20*10), 20, 10)
des &lt;- data.frame(a=rep(letters[1:4], 5), b=factor(rep(1:5, each=4)))
xresid &lt;- residualize(~ a+b, X, design=des)

## design is saturated, residuals should be zero
xresid2 &lt;- residualize(~ a*b, X, design=des)
sum(xresid2) == 0
</code></pre>

<hr>
<h2 id='residuals'>Obtain residuals of a component model fit</h2><span id='topic+residuals'></span>

<h3>Description</h3>

<p>Calculate the residuals of a model after removing the effect of the first <code>ncomp</code> components.
This function is useful to assess the quality of the fit or to identify patterns that are not
captured by the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals(x, ncomp, xorig, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_x">x</code></td>
<td>
<p>The model fit object.</p>
</td></tr>
<tr><td><code id="residuals_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to factor out before calculating residuals.</p>
</td></tr>
<tr><td><code id="residuals_+3A_xorig">xorig</code></td>
<td>
<p>The original data matrix (X) used to fit the model.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of residuals, with the same dimensions as the original data matrix.
</p>

<hr>
<h2 id='reverse_transform'>reverse a pre-processing transform</h2><span id='topic+reverse_transform'></span>

<h3>Description</h3>

<p>reverse a pre-processing transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_transform(x, X, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_transform_+3A_x">x</code></td>
<td>
<p>the pre_processor</p>
</td></tr>
<tr><td><code id="reverse_transform_+3A_x">X</code></td>
<td>
<p>the data matrix</p>
</td></tr>
<tr><td><code id="reverse_transform_+3A_colind">colind</code></td>
<td>
<p>column indices</p>
</td></tr>
<tr><td><code id="reverse_transform_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the reverse-transformed data
</p>

<hr>
<h2 id='rf_classifier'>construct a random forest wrapper classifier</h2><span id='topic+rf_classifier'></span>

<h3>Description</h3>

<p>Given a model object (e.g. <code>projector</code> construct a random forest classifier that can generate predictions for new data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_classifier(x, colind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_classifier_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="rf_classifier_+3A_colind">colind</code></td>
<td>
<p>the (optional) column indices used for prediction</p>
</td></tr>
<tr><td><code id="rf_classifier_+3A_...">...</code></td>
<td>
<p>extra arguments to <code>randomForest</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random forest classifier
</p>

<hr>
<h2 id='rf_classifier.projector'>create a random forest classifier</h2><span id='topic+rf_classifier.projector'></span>

<h3>Description</h3>

<p>create a random forest classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projector'
rf_classifier(x, colind = NULL, labels, scores, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_classifier.projector_+3A_x">x</code></td>
<td>
<p>the model object</p>
</td></tr>
<tr><td><code id="rf_classifier.projector_+3A_colind">colind</code></td>
<td>
<p>the (optional) column indices used for prediction</p>
</td></tr>
<tr><td><code id="rf_classifier.projector_+3A_labels">labels</code></td>
<td>
<p>A factor or vector of class labels for the training data.</p>
</td></tr>
<tr><td><code id="rf_classifier.projector_+3A_scores">scores</code></td>
<td>
<p>a matrix of references scores used for classification</p>
</td></tr>
<tr><td><code id="rf_classifier.projector_+3A_...">...</code></td>
<td>
<p>extra arguments to <code>randomForest</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>rf_classifier</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- iris[,1:4]
pcres &lt;- pca(as.matrix(X),2)
cfier &lt;- rf_classifier(pcres, labels=iris[,5], scores=scores(pcres))
p &lt;- predict(cfier, new_data=as.matrix(iris[,1:4]))
</code></pre>

<hr>
<h2 id='rotate'>Rotate a Component Solution</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Perform a rotation of the component loadings to improve interpretability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(x, ncomp, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>The model fit, typically a result from a dimensionality reduction method like PCA.</p>
</td></tr>
<tr><td><code id="rotate_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to rotate.</p>
</td></tr>
<tr><td><code id="rotate_+3A_type">type</code></td>
<td>
<p>The type of rotation to apply (e.g., &quot;varimax&quot;, &quot;quartimax&quot;, &quot;promax&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified model fit with the rotated components.
</p>

<hr>
<h2 id='scores'>Retrieve the component scores</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>Extract the factor score matrix from a fitted model. The factor scores represent the projections of the
data onto the components, which can be used for further analysis or visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_x">x</code></td>
<td>
<p>The model fit object.</p>
</td></tr>
<tr><td><code id="scores_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of factor scores, with rows corresponding to samples and columns to components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> for projecting new data onto the components.
</p>

<hr>
<h2 id='sdev'>standard deviations</h2><span id='topic+sdev'></span>

<h3>Description</h3>

<p>The standard deviations of the projected data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdev_+3A_x">x</code></td>
<td>
<p>the model fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the standard deviations
</p>

<hr>
<h2 id='shape'>Shape of the Projector</h2><span id='topic+shape'></span>

<h3>Description</h3>

<p>Get the input/output shape of the projector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_+3A_x">x</code></td>
<td>
<p>The model fit.</p>
</td></tr>
<tr><td><code id="shape_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function retrieves the dimensions of the sample loadings matrix <code>v</code> in the form of a vector with two elements.
The first element is the number of rows in the <code>v</code> matrix, and the second element is the number of columns.
</p>


<h3>Value</h3>

<p>A vector containing the dimensions of the sample loadings matrix <code>v</code> (number of rows and columns).
</p>

<hr>
<h2 id='shape.cross_projector'>shape of a cross_projector instance</h2><span id='topic+shape.cross_projector'></span>

<h3>Description</h3>

<p>shape of a cross_projector instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross_projector'
shape(x, source = c("X", "Y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape.cross_projector_+3A_x">x</code></td>
<td>
<p>The model fit.</p>
</td></tr>
<tr><td><code id="shape.cross_projector_+3A_source">source</code></td>
<td>
<p>the source of the data (X or Y block)</p>
</td></tr>
<tr><td><code id="shape.cross_projector_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the shape of the data
</p>

<hr>
<h2 id='standardize'>center and scale each vector of a matrix</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>center and scale each vector of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(preproc = prepper(), cmeans = NULL, sds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processing pipeline</p>
</td></tr>
<tr><td><code id="standardize_+3A_cmeans">cmeans</code></td>
<td>
<p>an optional vector of column means</p>
</td></tr>
<tr><td><code id="standardize_+3A_sds">sds</code></td>
<td>
<p>an optional vector of sds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>prepper</code> list
</p>

<hr>
<h2 id='std_scores'>Compute standardized component scores</h2><span id='topic+std_scores'></span>

<h3>Description</h3>

<p>Calculate standardized factor scores from a fitted model. Standardized scores are useful for comparing
the contributions of different components on the same scale, which can help in interpreting the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_scores(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std_scores_+3A_x">x</code></td>
<td>
<p>The model fit object.</p>
</td></tr>
<tr><td><code id="std_scores_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of standardized factor scores, with rows corresponding to samples and columns to components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scores">scores</a></code> for retrieving the original component scores.
</p>

<hr>
<h2 id='svd_wrapper'>Singular Value Decomposition (SVD) Wrapper</h2><span id='topic+svd_wrapper'></span>

<h3>Description</h3>

<p>Computes the singular value decomposition of a matrix using one of the specified methods.
It is designed to be an easy-to-use wrapper for various SVD methods available in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svd_wrapper(
  X,
  ncomp = min(dim(X)),
  preproc = pass(),
  method = c("fast", "base", "irlba", "propack", "rsvd", "svds"),
  q = 2,
  p = 10,
  tol = .Machine$double.eps,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svd_wrapper_+3A_x">X</code></td>
<td>
<p>the input matrix</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of components to estimate (default: min(dim(X)))</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_preproc">preproc</code></td>
<td>
<p>the pre-processor to apply on the input matrix (e.g., <code>center()</code>, <code>standardize()</code>, <code>pass()</code>)</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_method">method</code></td>
<td>
<p>the SVD method to use: 'base', 'fast', 'irlba', 'propack', 'rsvd', or 'svds'</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_q">q</code></td>
<td>
<p>parameter passed to method <code>rsvd</code> (default: 2)</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_p">p</code></td>
<td>
<p>parameter passed to method <code>rsvd</code> (default: 10)</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_tol">tol</code></td>
<td>
<p>minimum eigenvalue magnitude, otherwise component is dropped (default: .Machine$double.eps)</p>
</td></tr>
<tr><td><code id="svd_wrapper_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the selected SVD function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an SVD object that extends <code>projector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load iris dataset and select the first four columns
data(iris)
X &lt;- iris[, 1:4]

# Compute SVD using the base method and 3 components
fit &lt;- svd_wrapper(X, ncomp = 3, preproc = center(), method = "base")
</code></pre>

<hr>
<h2 id='transpose'>Transpose a model</h2><span id='topic+transpose'></span>

<h3>Description</h3>

<p>This function transposes a model by switching coefficients and scores. It is useful when you want to
reverse the roles of samples and variables in a model, especially in the context of dimensionality
reduction methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_x">x</code></td>
<td>
<p>The model fit, typically an object of a class that implements a <code>transpose</code> method</p>
</td></tr>
<tr><td><code id="transpose_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>transpose</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transposed model with coefficients and scores switched
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_projector">bi_projector</a></code> for an example of a two-way mapping model that can be transposed
</p>

<hr>
<h2 id='truncate'>truncate a component fit</h2><span id='topic+truncate'></span>

<h3>Description</h3>

<p>take the first n components of a decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate(x, ncomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_+3A_x">x</code></td>
<td>
<p>the object to truncate</p>
</td></tr>
<tr><td><code id="truncate_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components to retain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a truncated object (e.g. PCA with 'ncomp' components)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
