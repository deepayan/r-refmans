<!DOCTYPE html><html lang="en"><head><title>Help for package itp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {itp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#itp-package'><p>itp: The Interpolate, Truncate, Project (ITP) Root-Finding Algorithm</p></a></li>
<li><a href='#itp'><p>The ITP root-finding algorithm</p></a></li>
<li><a href='#itp_c'><p>The ITP root-finding algorithm using C++</p></a></li>
<li><a href='#itp_cpp'><p>Internal itp functions</p></a></li>
<li><a href='#plot.itp'><p>Plot method for objects of class <code>"itp"</code></p></a></li>
<li><a href='#print.itp'><p>Print method for objects of class <code>"itp"</code></p></a></li>
<li><a href='#xptr_create'><p>Create an external pointer to a C++ function</p></a></li>
<li><a href='#xptr_eval'><p>Call a C++ function using an external pointer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Interpolate, Truncate, Project (ITP) Root-Finding Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Interpolate, Truncate, Project (ITP) root-finding 
    algorithm developed by Oliveira and Takahashi (2021) &lt;<a href="https://doi.org/10.1145%2F3423597">doi:10.1145/3423597</a>&gt;.
    The user provides the function, from the real numbers to the real numbers, 
    and an interval with the property that the values of the function at its 
    endpoints have different signs. If the function is continuous over this 
    interval then the ITP method estimates the value at which the function is 
    equal to zero. If the function is discontinuous then a point of 
    discontinuity at which the function changes sign may be found. 
    The function can be supplied using either an R function or an external 
    pointer to a C++ function. Tuning parameters of the ITP algorithm can be 
    set by the user. Default values are set based on arguments in Oliveira and 
    Takahashi (2021). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stats, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/itp/">https://paulnorthrop.github.io/itp/</a>,
<a href="https://github.com/paulnorthrop/itp">https://github.com/paulnorthrop/itp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/itp/issues">https://github.com/paulnorthrop/itp/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 14:43:29 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='itp-package'>itp: The Interpolate, Truncate, Project (ITP) Root-Finding Algorithm</h2><span id='topic+itp-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Implements the Interpolate, Truncate, Project (ITP) root-finding
algorithm developed by Oliveira and Takahashi (2021).
The user provides a function, from the real numbers to the real numbers, and
an interval with the property that the values of the function at its
endpoints have different signs. If the function is continuous over this
interval then the ITP method estimates the value at which the function is
equal to zero. If the function is discontinuous then a point of
discontinuity at which the function changes sign may be found. The function
can be supplied using either an R function or an external pointer to a C++
function. Tuning parameters of the ITP algorithm can be set by the user.
Default values are set based on arguments in Oliveira and Takahashi (2021).
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+itp">itp</a></code>.
See the vignette
<a href="https://paulnorthrop.github.io/itp/articles/itp-vignette.html">
Overview of the itp package</a>, which can also be accessed using
<code>vignette("itp-vignette", package = "itp")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>


<h3>References</h3>

<p>Oliveira, I. F. D. and Takahashi, R. H. C. (2021). An Enhancement
of the Bisection Method Average Performance Preserving Minmax Optimality,
<em>ACM Transactions on Mathematical Software</em>, <strong>47</strong>(1), 1-24.
<a href="https://doi.org/10.1145/3423597">doi:10.1145/3423597</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itp">itp</a></code> for the ITP root-finding algorithm
</p>
<p><code><a href="#topic+print.itp">print.itp</a></code> and <code><a href="#topic+plot.itp">plot.itp</a></code> for print and
plot methods for objects of class <code>"itp"</code> returned from <code>itp</code>.
</p>
<p><code><a href="#topic+xptr_create">xptr_create</a></code> and <code><a href="#topic+xptr_eval">xptr_eval</a></code> for
creating external pointers to the C++ functions used as examples in this
package and evaluating those functions.
</p>

<hr>
<h2 id='itp'>The ITP root-finding algorithm</h2><span id='topic+itp'></span>

<h3>Description</h3>

<p>Performs one-dimensional root-finding using the ITP algorithm of
Oliveira and Takahashi (2021).  The function <code>itp</code> searches an
interval [<code class="reqn">a</code>, <code class="reqn">b</code>] for a root (i.e., a zero) of the
function <code>f</code> with respect to its first argument. Each iteration
results in a bracketing interval for the root that is narrower than the
previous interval.  If the function is discontinuous then a point of
discontinuity at which the function changes sign may be found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itp(
  f,
  interval,
  ...,
  a = min(interval),
  b = max(interval),
  f.a = f(a, ...),
  f.b = f(b, ...),
  epsilon = 1e-10,
  k1 = 0.2/(b - a),
  k2 = 2,
  n0 = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itp_+3A_f">f</code></td>
<td>
<p>An R function or an external pointer to a C++ function.  For the
latter see the article
<a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers/">
Passing user-supplied C++ functions</a> in the
<a href="https://gallery.rcpp.org/">Rcpp Gallery</a>. The function for which the
root is sought.</p>
</td></tr>
<tr><td><code id="itp_+3A_interval">interval</code></td>
<td>
<p>A numeric vector <code>c(a, b)</code> of length 2
containing the end points of the interval to be searched for the root.
The function values at the end points must be of opposite signs.</p>
</td></tr>
<tr><td><code id="itp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="itp_+3A_a">a</code>, <code id="itp_+3A_b">b</code></td>
<td>
<p>An alternative way to set the lower and upper end points of the
interval to be searched. The function values at these end points must be
of opposite signs.</p>
</td></tr>
<tr><td><code id="itp_+3A_f.a">f.a</code>, <code id="itp_+3A_f.b">f.b</code></td>
<td>
<p>The values of <code>f(a)</code> and <code>f(b)</code>, respectively.</p>
</td></tr>
<tr><td><code id="itp_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric scalar. The desired accuracy of the root.
The algorithm continues until the width of the bracketing interval for the
root is less than or equal to <code>2 * epsilon</code>.</p>
</td></tr>
<tr><td><code id="itp_+3A_k1">k1</code>, <code id="itp_+3A_k2">k2</code>, <code id="itp_+3A_n0">n0</code></td>
<td>
<p>Numeric scalars. The values of the tuning parameters
<code class="reqn">\kappa</code><sub>1</sub>,
<code class="reqn">\kappa</code><sub>2</sub>,
<code class="reqn">n</code><sub>0</sub>.
See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Page 8 of Oliveira and Takahashi (2021) describes the ITP
algorithm and the roles of the tuning parameters
<code class="reqn">\kappa</code><sub>1</sub>,
<code class="reqn">\kappa</code><sub>2</sub> and
<code class="reqn">n</code><sub>0</sub>.  The algorithm is
described using pseudocode. The Wikipedia entry for the
<a href="https://en.wikipedia.org/wiki/ITP_method">ITP method</a> provides
a summary.  If the input function <code>f</code> is continuous over the interval
[<code>a</code>, <code>b</code>] then the value of <code>f</code> evaluated at the estimated
root is (approximately) equal to 0. If <code>f</code> is discontinuous over the
interval [<code>a</code>, <code>b</code>] then the bracketing interval returned after
convergence has the property that the signs of the function <code>f</code> at
the end points of this interval are different and therefore the estimated
root may be a point of discontinuity at which the sign of <code>f</code>
changes.
</p>
<p>The ITP method requires at most
<code class="reqn">n</code><sub>max</sub> = <code class="reqn">n</code><sub>1/2</sub> +
<code class="reqn">n</code><sub>0</sub> iterations,
where <code class="reqn">n</code><sub>1/2</sub> is the
smallest integer not less than log<sub>2</sub>((b-a) /
2<code class="reqn">\epsilon</code>).
If <code class="reqn">n</code><sub>0</sub> = 0 then the
ITP method will require no more iterations than the bisection method.
Depending on the function <code>f</code>, setting a larger value for
<code class="reqn">n</code><sub>0</sub>, e.g. the default
setting <code class="reqn">n</code><sub>0</sub>=1 used by
the <code>itp</code> function, may result in a smaller number of iterations.
</p>
<p>The default values of the other tuning parameters
(<code>epsilon = 1e-10, k1 = 0.2 / (b - a), k2 = 2</code>) are set based on
arguments made in Oliveira and Takahashi (2021).
</p>


<h3>Value</h3>

<p>An object (a list) of class <code>"itp"</code> containing the following
components:
</p>
<table role = "presentation">
<tr><td><code>root</code></td>
<td>
<p>the location of the root, calculated as <code>(a+b)/2</code>, where
[<code>a, b</code>] is the bracketing interval after convergence.</p>
</td></tr>
<tr><td><code>f.root</code></td>
<td>
<p>the value of the function evaluated at root.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations performed.</p>
</td></tr>
<tr><td><code>a</code>, <code>b</code></td>
<td>
<p>the end points of the bracketing interval [<code>a, b</code>] after
convergence.</p>
</td></tr>
<tr><td><code>f.a</code>, <code>f.b</code></td>
<td>
<p>the values of function at <code>a</code> and <code>b</code> after
convergence.</p>
</td></tr>
<tr><td><code>estim.prec</code></td>
<td>
<p>an approximate estimated precision for <code>root</code>,
equal to the half the width of the final bracket for the root.</p>
</td></tr>
</table>
<p>the root occurs at one of the input endpoints <code>a</code> or <code>b</code> then
<code>iter = 0</code> and <code>estim.prec = NA</code>.
</p>
<p>The returned object also has the attributes <code>f</code> (the input R function
or pointer to a C++ function <code>f</code>), <code>f_args</code> (a list of
additional arguments to <code>f</code> provided in <code>...</code>), <code>f_name</code>
(a function name extracted from <code>as.character(substitute(f))</code> or the
form of the R function if <code>f</code> was not named), <code>used_c</code> (a
logical scalar: <code>FALSE</code>, if <code>f</code> is an R function and <code>TRUE</code>
if <code>f</code> is a pointer to a C++ function) and <code>input_a</code> and
<code>input_b</code> (the input values of <code>a</code> and <code>b</code>).  These
attributes are used in <code><a href="#topic+plot.itp">plot.itp</a></code> to produce a plot of the
function <code>f</code> over the interval <code>(input_a, input_b)</code>.
</p>


<h3>References</h3>

<p>Oliveira, I. F. D. and Takahashi, R. H. C. (2021). An Enhancement
of the Bisection Method Average Performance Preserving Minmax Optimality,
<em>ACM Transactions on Mathematical Software</em>, <strong>47</strong>(1), 1-24.
<a href="https://doi.org/10.1145/3423597">doi:10.1145/3423597</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.itp">print.itp</a></code> and <code><a href="#topic+plot.itp">plot.itp</a></code> for print and
plot methods for objects of class <code>"itp"</code> returned from <code>itp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### ----- The example used in the Wikipedia entry for the ITP method

# Supplying an R function
wiki &lt;- function(x) x ^ 3 - x - 2
itp(wiki, c(1, 2), epsilon = 0.0005, k1 = 0.1, n0 = 1)
# The default setting (with k1 = 0.2) wins by 1 iteration
wres &lt;- itp(wiki, c(1, 2), epsilon = 0.0005, n0 = 1)
wres
plot(wres)

# Supplying an external pointer to a C++ function
wiki_ptr &lt;- xptr_create("wiki")
wres_c &lt;- itp(f = wiki_ptr, c(1, 2), epsilon = 0.0005, k1 = 0.1)
wres_c
plot(wres_c)

#### ----- Some examples from Table 1 of Oliveira and Takahashi (2021)

### Well-behaved functions

# Lambert
lambert &lt;- function(x) x * exp(x) - 1
itp(lambert, c(-1, 1))

# Trigonometric 1
# Supplying an R function
trig1 &lt;- function(x, root) tan(x - root)
itp(trig1, c(-1, 1), root = 1 / 10)
# Supplying an external pointer to a C++ function
trig1_ptr &lt;- xptr_create("trig1")
itp(f = trig1_ptr, c(-1, 1), root = 1 / 10)

# Logarithmic
logarithmic &lt;- function(x, shift) log(abs(x - shift))
itp(logarithmic, c(-1, 1), shift = 10 /9)

# Linear
linear &lt;- function(x) x
# Solution in one iteration
itp(linear, c(-1, 1))
# Solution at an input endpoint
itp(linear, c(-1, 0))

### Ill-behaved functions

## Non-simple zero

# Polynomial 3
poly3 &lt;- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1))
# Using n0 = 0 leads to fewer iterations, in this example
poly3 &lt;- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1), n0 = 0)

## Discontinuous

# Staircase
staircase &lt;- function(x) ceiling(10 * x - 1) + 1 / 2
itp(staircase, c(-1, 1))

## Multiple roots

# Warsaw
warsaw &lt;- function(x) ifelse(x &gt; -1, sin(1 / (x + 1)), -1)
# Function increasing over the interval
itp(warsaw, c(-1, 1))
# Function decreasing over the interval
itp(warsaw, c(-0.85, -0.8))
</code></pre>

<hr>
<h2 id='itp_c'>The ITP root-finding algorithm using C++</h2><span id='topic+itp_c'></span>

<h3>Description</h3>

<p>Performs one-dimensional root-finding using the ITP algorithm of
Oliveira and Takahashi (2021). This function is equivalent to
<code><a href="#topic+itp">itp</a></code> but calculations are performed entirely using C++, and
the arguments differ slightly: <code>itp_c</code> has a named required argument
<code>pars</code> rather than <code>...</code> and it does not have the arguments
<code>interval</code>, <code>f.a</code> or <code>f.b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itp_c(f, pars, a, b, epsilon = 1e-10, k1 = -1, k2 = 2, n0 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itp_c_+3A_f">f</code></td>
<td>
<p>An external pointer to a C++ function that evaluates the function
<code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="itp_c_+3A_pars">pars</code></td>
<td>
<p>A list of additional arguments to the function.  This may be an
empty list.</p>
</td></tr>
<tr><td><code id="itp_c_+3A_a">a</code>, <code id="itp_c_+3A_b">b</code></td>
<td>
<p>Numeric scalars. Lower (<code>a</code>) and upper <code>b</code> limits of
the interval to be searched for a root.</p>
</td></tr>
<tr><td><code id="itp_c_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric scalar. The desired accuracy of the root.
The algorithm continues until the width of the bracketing interval for the
root is less than or equal to <code>2 * epsilon</code>.</p>
</td></tr>
<tr><td><code id="itp_c_+3A_k1">k1</code>, <code id="itp_c_+3A_k2">k2</code>, <code id="itp_c_+3A_n0">n0</code></td>
<td>
<p>Numeric scalars. The values of the tuning parameters
<code class="reqn">\kappa</code><sub>1</sub>,
<code class="reqn">\kappa</code><sub>2</sub>,
<code class="reqn">n</code><sub>0</sub>.
See the <strong>Details</strong> section of <code><a href="#topic+itp">itp</a></code>.
</p>
<p>The default value for <code>k1</code> in <code><a href="#topic+itp_c">itp_c</a></code> is set as
the inadmissible value of <code>-1</code>
(in reality <code class="reqn">\kappa</code><sub>1</sub>
must be positive) as a device to set the same default value for <code>k1</code>
as <code><a href="#topic+itp">itp</a></code>, that is, <code>k1 = 0.2 / (b - a)</code>.  If the input
value of <code>k1</code> is less than or equal to 0 then, inside
<code><a href="#topic+itp_c">itp_c</a></code>, <code>k1 = 0.2 / (b - a)</code> is set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see <code><a href="#topic+itp">itp</a></code>.
</p>


<h3>Value</h3>

<p>An object (a list) of class <code>"itp"</code> with the same structure
as detailed in the <strong>Value</strong> section of <code><a href="#topic+itp">itp</a></code>, except
that the attribute <code>f_name</code> is empty (equal to <code>""</code>).
</p>


<h3>References</h3>

<p>Oliveira, I. F. D. and Takahashi, R. H. C. (2021). An Enhancement
of the Bisection Method Average Performance Preserving Minmax Optimality,
<em>ACM Transactions on Mathematical Software</em>, <strong>47</strong>(1), 1-24.
<a href="https://doi.org/10.1145/3423597">doi:10.1145/3423597</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.itp">print.itp</a></code> and <code><a href="#topic+plot.itp">plot.itp</a></code> for print and
plot methods for objects of class <code>"itp"</code> returned from <code>itp_c</code>
or <code>itp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wiki_ptr &lt;- xptr_create("wiki")
wres &lt;- itp_c(f = wiki_ptr, pars = list(), a = 1, b = 2, epsilon = 0.0005)
wres
plot(wres, main = "Wiki")
</code></pre>

<hr>
<h2 id='itp_cpp'>Internal itp functions</h2><span id='topic+itp_cpp'></span><span id='topic+itp-internal'></span><span id='topic+itp_r'></span>

<h3>Description</h3>

<p>Internal itp functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itp_cpp(f, pars, a, b, ya, yb, epsilon, k1, k2, for_rk, inc)

itp_r(f, ..., a, b, ya, yb, epsilon, k1, k2, for_rk, inc)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='plot.itp'>Plot method for objects of class <code>"itp"</code></h2><span id='topic+plot.itp'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>"itp"</code> returned from
<code><a href="#topic+itp">itp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'itp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.itp_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"itp"</code>, a result of a
call to <code><a href="#topic+itp">itp</a></code>.</p>
</td></tr>
<tr><td><code id="plot.itp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+curve">curve</a></code>,
such as graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+curve">curve</a></code> to produce a plot of the
function <code>f</code> provided to <code><a href="#topic+itp">itp</a></code> over the interval within
which a root was sought. The estimated root is indicated using a
horizontal line drawn at 0 and a vertical line drawn at the estimated
root. By default the name of the function <code>f</code> is used as a title,
but this can be replaced by supplying the argument <code>main</code>.  The
interval over which <code>f</code> is plotted can be changed by supplying the
arguments <code>from</code> and/or <code>to</code>.
</p>


<h3>Value</h3>

<p>No return value, only the plot is produced.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itp">itp</a></code> for the Interpolate, Truncate, Project (ITP) root
finding algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lambert

# Supplying an R function
lambert &lt;- function(x) x * exp(x) - 1
x &lt;- itp(lambert, c(-1, 1))
plot(x)

# Supplying an external pointer to a C++ function
lambert_ptr &lt;- xptr_create("lambert")
x &lt;- itp(lambert_ptr, c(-1, 1))
plot(x, main = "Lambert")
</code></pre>

<hr>
<h2 id='print.itp'>Print method for objects of class <code>"itp"</code></h2><span id='topic+print.itp'></span>

<h3>Description</h3>

<p>Prints objects of class <code>"itp"</code> returned from <code><a href="#topic+itp">itp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'itp'
print(x, all = FALSE, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.itp_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"itp"</code>, a result of a
call to <code><a href="#topic+itp">itp</a></code>.</p>
</td></tr>
<tr><td><code id="print.itp_+3A_all">all</code></td>
<td>
<p>A logical scalar.  If <code>all = FALSE</code> then only the estimated
root, the value of the function at the root an the number of iterations
are printed.  If <code>all = TRUE</code> then, in addition, the final bracketing
interval [<code>a, b</code>], the values of the function at the end points of
this interval and the estimated precision are printed.</p>
</td></tr>
<tr><td><code id="print.itp_+3A_digits">digits</code></td>
<td>
<p>The argument <code>digits</code> passed to <code><a href="base.html#topic+format">format</a></code>
to set the number of significant digits to print.</p>
</td></tr>
<tr><td><code id="print.itp_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods. They are
ignored in this function..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting is to print only the root, the value of the
function at the root and the number of iterations.  To include the
bracketing interval after convergence and the estimated precision use
<code>all = TRUE</code>.
</p>


<h3>Value</h3>

<p>The argument <code>x</code> is returned, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itp">itp</a></code> for the Interpolate, Truncate, Project (ITP) root
finding algorithm.
</p>

<hr>
<h2 id='xptr_create'>Create an external pointer to a C++ function</h2><span id='topic+xptr_create'></span>

<h3>Description</h3>

<p>This function is used in the <code><a href="#topic+itp-package">itp</a></code> package to
create external pointers to the C++ functions used as examples to
illustrate the use of the function <code><a href="#topic+itp">itp</a></code>.  These pointers are
passed as the argument <code>f</code> to <code><a href="#topic+itp">itp</a></code>.  To create their own
examples the user will need to create their own C++ function(s) and a
function that is similar to <code>xptr_create</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xptr_create(fstr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xptr_create_+3A_fstr">fstr</code></td>
<td>
<p>A string indicating the C++ function required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette
<a href="https://paulnorthrop.github.io/itp/articles/itp-vignette.html">
Overview of the itp package</a> and the file
<a href="https://raw.githubusercontent.com/paulnorthrop/itp/main/src/user_fns.cpp">
user_fns.cpp</a> for information.
</p>
<p>The example C++ functions available in <code>itp</code> are: <code>"wiki"</code>,
<code>"lambert"</code>, <code>"trig1"</code>, <code>"poly3"</code>, <code>"linear"</code>,
<code>"warsaw"</code> and <code>staircase</code>.
</p>


<h3>Value</h3>

<p>The external pointer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xptr_eval">xptr_eval</a></code> for calling a C++ function using an
external pointer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambert_ptr &lt;- xptr_create("lambert")
res &lt;- itp(lambert_ptr, c(-1, 1))
</code></pre>

<hr>
<h2 id='xptr_eval'>Call a C++ function using an external pointer</h2><span id='topic+xptr_eval'></span>

<h3>Description</h3>

<p>This function is used in <code><a href="#topic+plot.itp">plot.itp</a></code> to plot a function and
the root estimated by <code><a href="#topic+itp">itp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xptr_eval(x, pars, xpsexp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xptr_eval_+3A_x">x</code></td>
<td>
<p>The main argument of the function.</p>
</td></tr>
<tr><td><code id="xptr_eval_+3A_pars">pars</code></td>
<td>
<p>A list of additional arguments to the function.  This may be an
empty list.</p>
</td></tr>
<tr><td><code id="xptr_eval_+3A_xpsexp">xpsexp</code></td>
<td>
<p>An external pointer to a C++ function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the
<a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers/">
Passing user-supplied C++ functions</a> article in the
<a href="https://gallery.rcpp.org/">Rcpp Gallery</a> for information.
</p>


<h3>Value</h3>

<p>A numeric scalar: the value of the C++ function evaluated at the
input values <code>x</code> and <code>pars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xptr_create">xptr_create</a></code> for creating an external pointer to a
C++ function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambert_ptr &lt;- xptr_create("lambert")
res &lt;- itp(lambert_ptr, c(-1, 1))

# Value at lower limit
xptr_eval(-1, list(), lambert_ptr)

# Value at upper limit
xptr_eval(1, list(), lambert_ptr)

# Value at the estimated root
xptr_eval(res$root, list(), lambert_ptr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
