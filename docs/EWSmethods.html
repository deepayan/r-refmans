<!DOCTYPE html><html><head><title>Help for package EWSmethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EWSmethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CODrecovery'><p>Three Recovering Cod Populations</p></a></li>
<li><a href='#conda_clean'><p>Python Removal</p></a></li>
<li><a href='#default_weights_path'><p>Path to Model Weights</p></a></li>
<li><a href='#deseason_ts'><p>Deseason Seasonal Time Series</p></a></li>
<li><a href='#detrend_ts'><p>Detrend Time Series</p></a></li>
<li><a href='#ewsnet_finetune'><p>EWSNet Finetune</p></a></li>
<li><a href='#ewsnet_init'><p>EWSNet Initialisation</p></a></li>
<li><a href='#ewsnet_predict'><p>EWSNet Predict</p></a></li>
<li><a href='#ewsnet_reset'><p>Reset EWSNet Model Weights</p></a></li>
<li><a href='#FI'><p>Calculate Fisher Information</p></a></li>
<li><a href='#multi_smap_jacobian'><p>S-map Inferred Jacobian</p></a></li>
<li><a href='#multiAR'><p>Multivariate Jacobian Index Estimated From Multivariate Autocorrelation Matrix</p></a></li>
<li><a href='#multiEWS'><p>Multivariate Early Warning Signal Assessment</p></a></li>
<li><a href='#multiJI'><p>S-map Jacobian index function</p></a></li>
<li><a href='#mvi'><p>Multivariate Variance Index function</p></a></li>
<li><a href='#perm_rollEWS'><p>Significance Testing of Rolling Window Early Warning Signals</p></a></li>
<li><a href='#plot.EWSmethods'><p>Plot an EWSmethods object</p></a></li>
<li><a href='#simTransComms'><p>Three Simulated Transitioning Communities.</p></a></li>
<li><a href='#uni_smap_jacobian'><p>S-map Inferred Jacobian</p></a></li>
<li><a href='#uniEWS'><p>Univariate Early Warning Signal Assessment</p></a></li>
<li><a href='#uniJI'><p>Univariate S-map Jacobian index function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecasting Tipping Points at the Community Level</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan O'Brien &lt;duncan.a.obrien@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Rolling and expanding window approaches to assessing abundance based early warning signals, non-equilibrium resilience measures, and machine learning. See Dakos et al. (2012) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0041010">doi:10.1371/journal.pone.0041010</a>&gt;, Deb et al. (2022) &lt;<a href="https://doi.org/10.1098%2Frsos.211475">doi:10.1098/rsos.211475</a>&gt;, Drake and Griffen (2010) &lt;<a href="https://doi.org/10.1038%2Fnature09389">doi:10.1038/nature09389</a>&gt;, Ushio et al. (2018) &lt;<a href="https://doi.org/10.1038%2Fnature25504">doi:10.1038/nature25504</a>&gt; and Weinans et al. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41598-021-87839-y">doi:10.1038/s41598-021-87839-y</a>&gt; for methodological details. Graphical presentation of the outputs are also provided for clear and publishable figures. Visit the 'EWSmethods' website for more information, and tutorials.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, dplyr (&ge; 1.0.6), egg, ggplot2, gtools, forecast,
foreach, infotheo, mAr, moments, rEDM (&ge; 1.15.0), reticulate,
scales, tidyr, zoo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/duncanobrien/EWSmethods">https://github.com/duncanobrien/EWSmethods</a>,
<a href="https://duncanobrien.github.io/EWSmethods/">https://duncanobrien.github.io/EWSmethods/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/duncanobrien/EWSmethods/issues">https://github.com/duncanobrien/EWSmethods/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, doParallel, knitr, fs, parallel, rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 12:54:53 UTC; ul20791</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan O'Brien <a href="https://orcid.org/0000-0002-3420-5210"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Smita Deb <a href="https://orcid.org/0000-0001-7037-7055"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Sahil Sidheekh [aut],
  Narayanan Krishnan [aut],
  Partha Dutta <a href="https://orcid.org/0000-0001-6067-1023"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christopher Clements
    <a href="https://orcid.org/0000-0001-5677-5401"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 08:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='CODrecovery'>Three Recovering Cod Populations</h2><span id='topic+CODrecovery'></span>

<h3>Description</h3>

<p>A dataset containing three simulated cod populations. Community 1 does not recovery whereas Community 100 and 200 do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CODrecovery
</code></pre>


<h3>Format</h3>

<p>A list of three dataframes with 191 rows and 6 variables each:
</p>

<dl>
<dt>community_id</dt><dd><p>the identity of the simulated community</p>
</dd>
<dt>time</dt><dd><p>time index</p>
</dd>
<dt>biomass</dt><dd><p>population total biomass</p>
</dd>
<dt>mean.size</dt><dd><p>average length of cod individuals</p>
</dd>
<dt>sd.size</dt><dd><p>variation in length of cod individuals</p>
</dd>
<dt>inflection_pt</dt><dd><p>the time index where transition occurs</p>
</dd>
</dl>



<h3>Source</h3>

<p>Clements C., McCarthy M., Blanchard J. (2019) Early warning signals of recovery in complex systems. Nature Communications, 10:1681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CODrecovery", package = "EWSmethods")

cod_data &lt;- CODrecovery$scenario2

</code></pre>

<hr>
<h2 id='conda_clean'>Python Removal</h2><span id='topic+conda_clean'></span>

<h3>Description</h3>

<p>Removes <code>ewsnet_init()</code> downloaded Anaconda binaries and environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conda_clean(envname, conda_path = reticulate::miniconda_path(), auto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conda_clean_+3A_envname">envname</code></td>
<td>
<p>A string naming the desired Python environment to remove.</p>
</td></tr>
<tr><td><code id="conda_clean_+3A_conda_path">conda_path</code></td>
<td>
<p>The location of Python install. By default, this follows <code>minicondata_path</code> defined by the <code>reticulate</code> package.</p>
</td></tr>
<tr><td><code id="conda_clean_+3A_auto">auto</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, asks permission to uninstall Python, packages and specified environment. If <code>TRUE</code>, no user confirmation is required for activation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return an object as is cleaning Python and its environments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Prior to running `conda_clean()`, you must restart
#your R session to detach any activated environments

conda_clean("EWSNET_env", auto = TRUE)


</code></pre>

<hr>
<h2 id='default_weights_path'>Path to Model Weights</h2><span id='topic+default_weights_path'></span>

<h3>Description</h3>

<p>The default path for EWSNet model weights to use. Is the location of the EWSmethods package. If you'd like to instead set your own path, <code>ewsnet_reset()</code> contains the argument <code>weights_path</code> to do so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_weights_path()
</code></pre>


<h3>Value</h3>

<p>No return value, called for reference.
</p>

<hr>
<h2 id='deseason_ts'>Deseason Seasonal Time Series</h2><span id='topic+deseason_ts'></span>

<h3>Description</h3>

<p>Removes seasonal signals from time series using either averaging or time series decomposition methods. Three decomposition methods are available: traditional decompostion, loess decomposition and X11 decompostion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deseason_ts(
  data,
  increment = c("month", "year", "week", "day"),
  method = c("average", "decompose", "stl"),
  order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deseason_ts_+3A_data">data</code></td>
<td>
<p>The dataframe to be transformed, The first column must be a vector of dates with all other columns the individual time series.</p>
</td></tr>
<tr><td><code id="deseason_ts_+3A_increment">increment</code></td>
<td>
<p>The time-step increment in either <code>month</code>, <code>year</code>, <code>week</code>, or <code>day</code>. Provides the basis for deaseasoning.</p>
</td></tr>
<tr><td><code id="deseason_ts_+3A_method">method</code></td>
<td>
<p>String of either <code>"average"</code>, <code>"decompose"</code>, <code>"stl"</code> or <code>"x11"</code> indicating the method of deseasoning. <code>"average"</code> subtracts the average representative month/week/day-of-the-year from each time point whereas <code>"decompose"</code>, <code>"stl"</code> and <code>"x11"</code> subtracts the seasonal component estimated by time series decomposition, loess decomposition and the X11 method respectively.</p>
</td></tr>
<tr><td><code id="deseason_ts_+3A_order">order</code></td>
<td>
<p>String indicating the date format of the date columns. Options are <code>"dmy"</code>, <code>"ymd"</code> or <code>"mdy"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of deseasoned time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate five random monthly time series
#of 5 years length.

spp_data &lt;- matrix(nrow = 5*12, ncol = 5)
spp_data &lt;- sapply(1:dim(spp_data)[2], function(x){
spp_data[,x] &lt;- rnorm(5*12,mean=20,sd=5)})
multi_spp_data &lt;- cbind("time" =
 seq(as.Date('2000/01/01'), as.Date('2004/12/01'), by="month"),
   as.data.frame(spp_data))

#Deseason using time series
#decomposition.

decomp_dat &lt;- deseason_ts(data = multi_spp_data,
increment = "month",
method = "decompose",
order = "ymd")

#Deseason using loess

decomp_dat &lt;- deseason_ts(data = multi_spp_data,
increment = "month",
method = "stl",
order = "ymd")

</code></pre>

<hr>
<h2 id='detrend_ts'>Detrend Time Series</h2><span id='topic+detrend_ts'></span>

<h3>Description</h3>

<p>Removes directional signals from time series using loess, linear regression or gaussian detrending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend_ts(data, method = "linear", bandwidth = NULL, span = 0.25, degree = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_ts_+3A_data">data</code></td>
<td>
<p>The dataframe to be detrended. The first column must be a vector of dates with all other columns the individual time series.</p>
</td></tr>
<tr><td><code id="detrend_ts_+3A_method">method</code></td>
<td>
<p>The method of detrending. Options include <code>"linear"</code> (residuals of a linear regression), <code>loess</code> (smoothing by local polynomial regression), <code>gaussian</code> (smoothing by a gaussian kernel), or <code>first.difference</code>.</p>
</td></tr>
<tr><td><code id="detrend_ts_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If <code>method = "gaussian"</code>, dictates the bandwidth of the gaussian kernel. If <code>NULL</code>, this is estimated from the data.</p>
</td></tr>
<tr><td><code id="detrend_ts_+3A_span">span</code></td>
<td>
<p>If <code>method = "loess"</code>, controls the degree of smoothing as a proportion of points to be used (if <code>span = 1</code>, all points are used)</p>
</td></tr>
<tr><td><code id="detrend_ts_+3A_degree">degree</code></td>
<td>
<p>If <code>method = "loess"</code>, specifies the degree polynomials allowed. Options are normally <code>1</code> or <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of deseasoned time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate five random monthly time series
#of 5 years length.

spp_data &lt;- matrix(nrow = 5*12, ncol = 5)
spp_data &lt;- sapply(1:dim(spp_data)[2], function(x){
spp_data[,x] &lt;- rnorm(5*12,mean=20,sd=5)})
multi_spp_data &lt;- cbind("time" =
 seq(as.Date('2000/01/01'), as.Date('2004/12/01'), by="month"),
   as.data.frame(spp_data))

detrend_dat &lt;- detrend_ts(data = multi_spp_data,
method = "gaussian",
bandwidth = 2)

</code></pre>

<hr>
<h2 id='ewsnet_finetune'>EWSNet Finetune</h2><span id='topic+ewsnet_finetune'></span>

<h3>Description</h3>

<p>Communicates with EWSNet (https://ewsnet.github.io), a deep learning framework for modelling and anticipating regime shifts in dynamical systems, and finetunes the model to match the inputted training data. This overwrites the Pretrained weights bundled with <code>EWSmethods</code>. See <code>reset_ewsnet()</code> on how to reset these trained weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewsnet_finetune(
  x,
  y,
  scaling = TRUE,
  envname,
  weights_path = default_weights_path()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewsnet_finetune_+3A_x">x</code></td>
<td>
<p>A numeric matrix to finetune EWSNet on. Each column represents a separate timeseries and each row is a timestep.</p>
</td></tr>
<tr><td><code id="ewsnet_finetune_+3A_y">y</code></td>
<td>
<p>A numeric vector consisting of target labels for each training time series. Labels include: 0 (no transition), 1 (smooth transition) or 2 (critical transition).</p>
</td></tr>
<tr><td><code id="ewsnet_finetune_+3A_scaling">scaling</code></td>
<td>
<p>Boolean.  If <code>TRUE</code>, the time series will be scaled between 1 and 2 and scaled EWSNet model weights will be used. This is the recommended setting.</p>
</td></tr>
<tr><td><code id="ewsnet_finetune_+3A_envname">envname</code></td>
<td>
<p>A string naming the Python environment prepared by <code>ewsnet_init()</code>.</p>
</td></tr>
<tr><td><code id="ewsnet_finetune_+3A_weights_path">weights_path</code></td>
<td>
<p>A string naming the path to model weights installed by <code>ewsnet_reset()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Activate python environment (only necessary
#on first opening of R session).

## Not run: 
ewsnet_init(envname = "EWSNET_env")

## End(Not run)

#A dummy dataset of a hedgerow bird population
#monitored over 50 years that needs to be tuned.

abundance_data &lt;- data.frame(time = seq(1:50),
 abundance = rnorm(50,mean = 20))

#Generate training data (this is random data as
#an example).

x &lt;- matrix(nrow = 50, ncol = 10)
x &lt;- sapply(1:dim(x)[2], function(i){
 x[,i] &lt;- rnorm(50,mean=20,sd=10)})

#Label each time series.

y &lt;- sample(0:2,10,replace = TRUE)

#Finetune EWSNet.

## Not run: 
ewsnet_finetune(
 x = x,
 y = y,
 scaling = TRUE,
 envname = "EWSNET_env")
 
## End(Not run)

#Generate new EWSNet predictions.

## Not run: 
pred &lt;- ewsnet_predict(
 abundance_data$abundance,
 scaling = TRUE,
 ensemble = 15,
 envname = "EWSNET_env")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='ewsnet_init'>EWSNet Initialisation</h2><span id='topic+ewsnet_init'></span>

<h3>Description</h3>

<p>Prepares your R session for communicating with Python. This function first searches your computer for an appropriate Python environment and activates it, importing the vital Python packages required. If no appropriate Python install or environment is found, after asking permission, miniconda is downloaded and an environment created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewsnet_init(
  envname,
  conda_path = reticulate::miniconda_path(),
  pip_ignore_installed = FALSE,
  auto = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewsnet_init_+3A_envname">envname</code></td>
<td>
<p>A string naming the desired Python environment to create/activate. If no Python or environment found, the functions prompts to install miniconda and the required python packages.</p>
</td></tr>
<tr><td><code id="ewsnet_init_+3A_conda_path">conda_path</code></td>
<td>
<p>The location to install Python. By default, this follows <code>minicondata_path</code> defined by the <code>reticulate</code> package.</p>
</td></tr>
<tr><td><code id="ewsnet_init_+3A_pip_ignore_installed">pip_ignore_installed</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, any packages already installed are loaded and not re-downloaded. However, if <code>TRUE</code>, packages are downloaded irregardless, overwriting any version already present (is analagous to updating if required).</p>
</td></tr>
<tr><td><code id="ewsnet_init_+3A_auto">auto</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, asks permission to install Python and/or packages. If <code>TRUE</code>, no user confirmation is required for activation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return an object as is simply preparing your R session.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ewsnet_init(envname = "EWSNET_env", auto = FALSE)

## End(Not run)
#Common errors at this stage result from 'reticulate's
#behaviour. For example, conflicts between 'ewsnet_init'
#and RETICULATE_PYTHON may occur if run inside a
#RStudio R project. To fix this, navigate to
#Preferences -&gt; Python, untick 'Automatically
#activate project-local Python environments'
#and restart R.

## Not run: 
reticulate::py_config()

## End(Not run)
#If successful, 'EWSNET_env forced by use_python
#function' will be printed.

</code></pre>

<hr>
<h2 id='ewsnet_predict'>EWSNet Predict</h2><span id='topic+ewsnet_predict'></span>

<h3>Description</h3>

<p>Communicates with EWSNet (https://ewsnet.github.io), a deep learning framework for modelling and anticipating regime shifts in dynamical systems, and returns the model's prediction for the inputted univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewsnet_predict(
  x,
  scaling = TRUE,
  ensemble = 25,
  envname,
  weights_path = default_weights_path()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewsnet_predict_+3A_x">x</code></td>
<td>
<p>A numeric vector of values to be tested.</p>
</td></tr>
<tr><td><code id="ewsnet_predict_+3A_scaling">scaling</code></td>
<td>
<p>Boolean.  If <code>TRUE</code>, the time series will be scaled between 1 and 2 and scaled EWSNet model weights will be used. This is the recommended setting.</p>
</td></tr>
<tr><td><code id="ewsnet_predict_+3A_ensemble">ensemble</code></td>
<td>
<p>A numeric value stating the number of models to average over. Options range from 1 to 25.</p>
</td></tr>
<tr><td><code id="ewsnet_predict_+3A_envname">envname</code></td>
<td>
<p>A string naming the Python environment prepared by <code>ewsnet_init()</code>.</p>
</td></tr>
<tr><td><code id="ewsnet_predict_+3A_weights_path">weights_path</code></td>
<td>
<p>A string naming the path to model weights installed by <code>ewsnet_reset()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of EWSNet predictions. Values represent the estimated probability that the quoted event will occur.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A dummy dataset of a hedgerow bird population
#monitored over 50 years.

abundance_data &lt;- data.frame(time = seq(1:50),
 abundance = rnorm(50,mean = 20))

#Activate python environment (only necessary
#on first opening of R session).

## Not run: 
ewsnet_init(envname = "EWSNET_env")

## End(Not run)

#Generate EWSNet predictions.

## Not run: 
pred &lt;- ewsnet_predict(
 abundance_data$abundance,
 scaling = TRUE,
 ensemble = 15,
 envname = "EWSNET_env")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='ewsnet_reset'>Reset EWSNet Model Weights</h2><span id='topic+ewsnet_reset'></span>

<h3>Description</h3>

<p>Restores EWSNet model weights to the pretrained defaults published at https://ewsnet.github.io. This is vital on first use of EWSNet as no model weights are provided with 'EWSmethods'. The use of this function may also be necessary after finetuning to reset the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewsnet_reset(
  weights_path = default_weights_path(),
  remove_weights = FALSE,
  auto = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewsnet_reset_+3A_weights_path">weights_path</code></td>
<td>
<p>A string naming the path to install model weights. Can be changed, but by default, attempts to add weights to the same location as the Python scripts bundled with EWSmethods.</p>
</td></tr>
<tr><td><code id="ewsnet_reset_+3A_remove_weights">remove_weights</code></td>
<td>
<p>Boolean. Should all weights be removed (<code>TRUE</code>) or should weights be re/downloaded (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="ewsnet_reset_+3A_auto">auto</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, asks permission to download model weights from Google Drive. If <code>TRUE</code>, no user confirmation is required for re/download.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# on first use of EWSNet via `EWSmethods`
ewsnet_reset(remove_weights = FALSE, auto = TRUE,
weights_path = tempdir())



# to remove all downloaded weights
ewsnet_reset(remove_weights = TRUE, auto = TRUE,
weights_path = tempdir())


</code></pre>

<hr>
<h2 id='FI'>Calculate Fisher Information</h2><span id='topic+FI'></span>

<h3>Description</h3>

<p>Uses a multivariate array of time series to estimate Fisher information following the approach of Karunanithi et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FI(data, sost, winsize = 50, winspace = 1, TL = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FI_+3A_data">data</code></td>
<td>
<p>A numeric matrix of individual time series across the columns. These could be different species, populations or measurements. The first column must be an equally spaced time vector.</p>
</td></tr>
<tr><td><code id="FI_+3A_sost">sost</code></td>
<td>
<p>A 1 x n matrix where n is a length equal to the number of time series in <code>data</code>. Each value is the 'size of state' tolerable for that time series and typically is represented by the standard deviation of the time series during a reference period.</p>
</td></tr>
<tr><td><code id="FI_+3A_winsize">winsize</code></td>
<td>
<p>Numeric value. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="FI_+3A_winspace">winspace</code></td>
<td>
<p>Numeric value. The number of data points to roll the window over in each iteration. Must be less than <code>winsize</code>.</p>
</td></tr>
<tr><td><code id="FI_+3A_tl">TL</code></td>
<td>
<p>Numeric value. The 'tightening level' or percentage of points shared between states that allows the algorithm to classify data points as the same state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three objects:
</p>
<table>
<tr><td><code>FI</code></td>
<td>
<p>A dataframe of Fisher information estimates and the last time point contributing to each window.</p>
</td></tr>
<tr><td><code>midt_win</code></td>
<td>
<p>A numeric vector of the time index at the centre of the window for that associated value in <code>FI</code>.</p>
</td></tr>
<tr><td><code>t_win</code></td>
<td>
<p>A n x m numeric matrix where the length of n is the winspace and length of m is the number of window shifts made. Values are consequently the timepoint indices that contribute to that window.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data(simTransComms)

#Estimate the size-of-states for each
#time series in the first community.
#This is typically suggested
#to be the standard deviation of a
#reference period or the entire time
#series

eg.sost &lt;- t(apply(simTransComms$community1[,3:7], MARGIN = 2, FUN = sd))
 #transpose required to ensure a 1 x n matrix

egFI &lt;- FI(data = simTransComms$community1[1:50,2:7],
sost =  eg.sost,
winsize = 10,
winspace = 1,
TL = 90)

</code></pre>

<hr>
<h2 id='multi_smap_jacobian'>S-map Inferred Jacobian</h2><span id='topic+multi_smap_jacobian'></span>

<h3>Description</h3>

<p>Performs the S-map on a multivariate time series to infer the Jacobian matrix at different points in time across thetas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_smap_jacobian(data, theta_seq = NULL, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_smap_jacobian_+3A_data">data</code></td>
<td>
<p>Numeric matrix with time in first column and species abundances in other columns</p>
</td></tr>
<tr><td><code id="multi_smap_jacobian_+3A_theta_seq">theta_seq</code></td>
<td>
<p>Numeric vector of thetas (nonlinear tuning parameters) to estimate the Jacobian over. If 'NULL', a default sequence is provided.</p>
</td></tr>
<tr><td><code id="multi_smap_jacobian_+3A_scale">scale</code></td>
<td>
<p>Boolean. Should data be scaled prior to estimating the Jacobian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three objects:
</p>
<table>
<tr><td><code>smap_J</code></td>
<td>
<p>Jacobian matrices for each point in time. It is recommended to just use the last estimate.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Pearson correlation between observed and predicted for each species.</p>
</td></tr>
<tr><td><code>smap_intercept.r</code></td>
<td>
<p>Intercepts of the regression fit.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Medeiros, L.P., Allesina, S., Dakos, V., Sugihara, G. &amp; Saavedra, S. (2022) Ranking species based on sensitivity to perturbations under non-equilibrium community dynamics. Ecology Letters, 00, 1– 14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data("simTransComms")

#Subset the third community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community3,time &lt; inflection_pt)


#Estimate the Jacobian using s-map (typically only
#the final estimate is informative)
est_jac &lt;- multi_smap_jacobian(pre_simTransComms[1:10,2:7])

</code></pre>

<hr>
<h2 id='multiAR'>Multivariate Jacobian Index Estimated From Multivariate Autocorrelation Matrix</h2><span id='topic+multiAR'></span>

<h3>Description</h3>

<p>Estimate the dominant Jacobian eigenvalue of a multivariate time series using autocorrelated stochastic differential equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiAR(data, scale = TRUE, winsize = 50, dt = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiAR_+3A_data">data</code></td>
<td>
<p>Numeric matrix with time in first column and species abundance in the second</p>
</td></tr>
<tr><td><code id="multiAR_+3A_scale">scale</code></td>
<td>
<p>Boolean. Should data be scaled prior to estimating the Jacobian.</p>
</td></tr>
<tr><td><code id="multiAR_+3A_winsize">winsize</code></td>
<td>
<p>Numeric. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="multiAR_+3A_dt">dt</code></td>
<td>
<p>Numeric An appropriate time step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe where the first column is last time index of the window and the second column is the estimated index value. A value &lt;1.0 indicates stability, a value &gt;1.0 indicates instability.
</p>


<h3>Source</h3>

<p>Williamson and Lenton (2015). Detection of bifurcations in noisy coupled systems from multiple time series. Chaos, 25, 036407
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data(simTransComms)

#Subset the second community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community2,time &lt; inflection_pt)

#Estimate the univariate stability index for the first species in
#the second community

egarJ &lt;- multiAR(data = pre_simTransComms[,2:7],
winsize = 25, dt = 1)

</code></pre>

<hr>
<h2 id='multiEWS'>Multivariate Early Warning Signal Assessment</h2><span id='topic+multiEWS'></span>

<h3>Description</h3>

<p>A single function for performing early warning signal (EWS) assessment on multivariate systems where multiple time series have been measured. Both methods of EWS assessment can be performed (rolling or expanding windows) with the assessments returned as a dataframe. The two methods of dimension reduction used to perform these assessments are Principal Component Analysis and Maximum/Minimum Autocorrelation Factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiEWS(
  data,
  metrics = c("meanAR", "maxAR", "meanSD", "maxSD", "eigenMAF", "mafAR", "mafSD",
    "pcaAR", "pcaSD", "eigenCOV", "maxCOV", "mutINFO"),
  method = c("expanding", "rolling"),
  winsize = 50,
  burn_in = 5,
  threshold = 2,
  tail.direction = "one.tailed"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiEWS_+3A_data">data</code></td>
<td>
<p>A dataframe where the first column is an equally spaced time vector and all other columns are individual time series. These could be different species, populations or measurements.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_metrics">metrics</code></td>
<td>
<p>String vector of early warning signal metrics to be assessed.  Options include: <code>"meanSD"</code>, <code>"maxSD"</code>, <code>"meanAR"</code>, <code>"maxAR"</code>, <code>"eigenMAF"</code>, <code>"mafAR"</code>, <code>"mafSD"</code>, <code>"pcaAR"</code>, <code>"pcaSD"</code>, <code>"eigenCOV"</code>, <code>"maxCOV"</code> and <code>"mutINFO"</code>.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_method">method</code></td>
<td>
<p>Single string of either <code>"expanding"</code> or <code>"rolling"</code>. <code>"expanding"</code> calls composite, expanding window EWS assessment. <code>"rolling"</code> calls typical, rolling window EWS assessment.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_winsize">winsize</code></td>
<td>
<p>Numeric value. If <code>method = "rolling"</code>, defines the window size of the rolling window as a percentage of the time series' length.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_burn_in">burn_in</code></td>
<td>
<p>Numeric value. If <code>method = "expanding"</code>, defines the number of data points to 'train' signals prior to EWS assessment.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_threshold">threshold</code></td>
<td>
<p>Numeric value of either <code>1</code> or <code>2</code>. Threshold*sigma is the value which, if the EWS strength exceeds it, constitutes a &quot;signal&quot;.</p>
</td></tr>
<tr><td><code id="multiEWS_+3A_tail.direction">tail.direction</code></td>
<td>
<p>String of either <code>"one.tailed"</code> or <code>"two.tailed"</code>. <code>"one.tailed"</code> only indicates a warning if positive threshold sigma exceeded. <code>"two.tailed"</code> indicates a warning if positive OR negative threshold*sigma exceeded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing up to two objects: EWS outputs through time (<code>EWS</code>), and an identifier string (<code>method</code>).
</p>
<table>
<tr><td><code>EWS$raw</code></td>
<td>
<p>Dataframe of EWS measurements through time. If <code>method = "expanding"</code>, then each metric has been rbound into a single dataframe and extra columns are provided indicating whether the threshold*sigma value has been exceeded (i.e. <code>"threshold.crossed"</code>). If <code>method = "rolling"</code>, then each metric's evolution over time is returned in individual columns.</p>
</td></tr>
<tr><td><code>EWS$dimred.ts</code></td>
<td>
<p>Dataframe containing the dimension reduction time series</p>
</td></tr>
<tr><td><code>EWS$cor</code></td>
<td>
<p>Dataframe of Kendall Tau correlations. Only returned if <code>method = "rolling"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a random five species, non-transitioning
#ecosystem with 50 years of monitoring data.

spp_data &lt;- matrix(nrow = 50, ncol = 5)
spp_data &lt;- sapply(1:dim(spp_data)[2], function(x){
 spp_data[,x] &lt;- rnorm(50,mean=20,sd=5)})
 multi_spp_data &lt;- as.data.frame(cbind("time" =
 seq(1:50), spp_data))

#Rolling window early warning signal assessment of
#the ecosystem.

roll_ews &lt;- multiEWS(
 data = multi_spp_data,
 method = "rolling",
 winsize = 50)

#Expanding window early warning signal assessment of
#the ecosystem.

exp_ews &lt;- multiEWS(
 data = multi_spp_data,
 method = "expanding",
 burn_in = 10)

</code></pre>

<hr>
<h2 id='multiJI'>S-map Jacobian index function</h2><span id='topic+multiJI'></span>

<h3>Description</h3>

<p>Calculate a stability metric from the s-map estimated Jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiJI(data, winsize = 50, theta_seq = NULL, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiJI_+3A_data">data</code></td>
<td>
<p>Numeric matrix with time in first column and species abundances in other columns</p>
</td></tr>
<tr><td><code id="multiJI_+3A_winsize">winsize</code></td>
<td>
<p>Numeric. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="multiJI_+3A_theta_seq">theta_seq</code></td>
<td>
<p>Numeric vector of thetas (nonlinear tuning parameters) to estimate the Jacobian over. If 'NULL', a default sequence covering '0:8' is provided.</p>
</td></tr>
<tr><td><code id="multiJI_+3A_scale">scale</code></td>
<td>
<p>Boolean. Should data be scaled within each window prior to estimating the Jacobian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe where the first column is last time index of the window and the second column is the estimated index value. A value &lt;1.0 indicates stability, a value &gt;1.0 indicates instability.
</p>


<h3>Source</h3>

<p>Ushio, M., Hsieh, Ch., Masuda, R. et al. (2018) Fluctuating interaction network and time-varying stability of a natural fish community. Nature 554, 360–363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data(simTransComms)

#Subset the third community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community3,time &lt; inflection_pt)

#Estimate the stability index for the third community
#(trimmed for speed)

egJI &lt;- multiJI(data = pre_simTransComms[1:10,2:5],
winsize = 75)

</code></pre>

<hr>
<h2 id='mvi'>Multivariate Variance Index function</h2><span id='topic+mvi'></span>

<h3>Description</h3>

<p>Calculate a multivariate variance following Brock, W. A., and S. R. Carpenter. 2006. Variance as a leading indicator of regime shift in ecosystem services. Ecology and Society 11(2): 9.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvi(data, winsize = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvi_+3A_data">data</code></td>
<td>
<p>A numeric matrix of species abundances, names across columns, time across rows. The first column is a time vector, the remainder are species values.</p>
</td></tr>
<tr><td><code id="mvi_+3A_winsize">winsize</code></td>
<td>
<p>Numeric. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where the first column is last time index of the window and the second column is the estimated index value.
</p>


<h3>Source</h3>

<p>Brock, W.A. &amp; Carpenter, S.R. (2006) Variance as a leading indicator of regime shift in ecosystem services. Ecology and Society 11(2): 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data(simTransComms)

#Estimate the MVI for the second community

egMVI &lt;- mvi(data = simTransComms$community2[,2:7],
winsize = 10)

</code></pre>

<hr>
<h2 id='perm_rollEWS'>Significance Testing of Rolling Window Early Warning Signals</h2><span id='topic+perm_rollEWS'></span>

<h3>Description</h3>

<p>A function for identifying whether a warning has been generated from rolling early warning signal data using permutation tests. If a parallel connection is setup via <code>parallel</code> or <code>future</code> prior to usage of <code>perm_rollEWS()</code>, then the function is parallelised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_rollEWS(
  data,
  metrics,
  winsize = 50,
  variate = c("uni", "multi"),
  perm.meth = "arima",
  iter = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_rollEWS_+3A_data">data</code></td>
<td>
<p>A dataframe where the first column is an equally spaced time vector and the remainder column are the time series to be assessed. If a two column dataframe is provided, and <code>variate = "uni"</code>, <code>uniEWS()</code> is called, whereas if number of columns exceeds two &amp; <code>variate = "multi"</code>, then <code>multiEWS()</code> is called.</p>
</td></tr>
<tr><td><code id="perm_rollEWS_+3A_metrics">metrics</code></td>
<td>
<p>String vector of early warning signal metrics to be assessed. For <code>variate = "uni"</code> these include: <code>"ar1"</code>, <code>"cv"</code>, <code>"SD"</code>, <code>"acf"</code>, <code>"rr"</code>, <code>"dr"</code>, <code>"skew"</code> and <code>"kurt"</code>. For <code>variate = "multi"</code>, pptions include: <code>"meanSD"</code>, <code>"maxSD"</code>, <code>"meanAR"</code>, <code>"maxAR"</code>, <code>"eigenMAF"</code>, <code>"mafAR"</code>, <code>"mafSD"</code>, <code>"pcaAR"</code>, <code>"pcaSD"</code>, <code>"eigenCOV"</code>, <code>"maxCOV"</code> and <code>"mutINFO"</code>.</p>
</td></tr>
<tr><td><code id="perm_rollEWS_+3A_winsize">winsize</code></td>
<td>
<p>Numeric value. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="perm_rollEWS_+3A_variate">variate</code></td>
<td>
<p>String. Is a <code>"uni"</code>variate or <code>"multi"</code>variate assessment to be made.</p>
</td></tr>
<tr><td><code id="perm_rollEWS_+3A_perm.meth">perm.meth</code></td>
<td>
<p>String dictating the pseudo-randomisation technique to be used. Options include: &quot;arima&quot; (sampled from predictions of an ARIMA model), &quot;red.noise&quot; (red noise process using data mean, variance and autocorrelation coef) or &quot;sample&quot; (sampled from observed data without replacement).</p>
</td></tr>
<tr><td><code id="perm_rollEWS_+3A_iter">iter</code></td>
<td>
<p>Numeric value. The number of permutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing up to two objects: EWS outputs through time (<code>EWS</code>), and an identifier string (<code>method</code>).
</p>
<table>
<tr><td><code>EWS$raw</code></td>
<td>
<p>Dataframe of EWS measurements through time. Each metric's evolution over time is returned in individual columns.</p>
</td></tr>
<tr><td><code>EWS$cor</code></td>
<td>
<p>Dataframe of Kendall Tau correlations and permuted p-values.</p>
</td></tr>
<tr><td><code>EWS$dimred.ts</code></td>
<td>
<p>Dataframe containing the dimension reduction time series. Only returned if <code>variate = "multi"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simTransComms)

#Permute p value for a univariate
#time series using resampling

#(data trimmed for speed)
perm_uni &lt;- perm_rollEWS(
data = simTransComms$community1[1:10,2:3],
 winsize = 75,
 variate = "uni",
 metrics = c("ar1", "SD", "skew"),
 perm.meth = "sample",
 iter = 25)

 #' #Permute p value for a multivariate
#community using a red.noise process


#if parallelisation desired,
#this can be achieved using the
#below code
cl &lt;- parallel::makeCluster(2)



doParallel::registerDoParallel(cl)


perm_multi &lt;- perm_rollEWS(
data = simTransComms$community1[1:10,2:7],
 winsize = 75,
 variate = "multi",
 metrics = c("meanAR", "maxAR", "meanSD"),
 perm.meth = "red.noise",
 iter = 25)


parallel::stopCluster(cl)


</code></pre>

<hr>
<h2 id='plot.EWSmethods'>Plot an EWSmethods object</h2><span id='topic+plot.EWSmethods'></span>

<h3>Description</h3>

<p>A function for visualising the output of <code>uniEWS</code> or <code>multiEWS</code> using ggplot2 inspired figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EWSmethods'
plot(
  x,
  ...,
  y_lab = "Generic indicator name",
  trait_lab = "Generic trait name",
  trait_scale = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.EWSmethods_+3A_x">x</code></td>
<td>
<p>An EWSmethods object created by <code>uniEWS</code> or <code>multiEWS</code></p>
</td></tr>
<tr><td><code id="plot.EWSmethods_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the plotting functions.</p>
</td></tr>
<tr><td><code id="plot.EWSmethods_+3A_y_lab">y_lab</code></td>
<td>
<p>String label. Labels the abundance y axis.</p>
</td></tr>
<tr><td><code id="plot.EWSmethods_+3A_trait_lab">trait_lab</code></td>
<td>
<p>String label. If <code>trait</code> argument populated in <code>uniEWS</code> or <code>multiEWS</code>, &amp; <code>"trait"</code> supplied in metrics, labels the right side y axis which represents trait values through time.</p>
</td></tr>
<tr><td><code id="plot.EWSmethods_+3A_trait_scale">trait_scale</code></td>
<td>
<p>Numeric value. Scales trait y axis relative to abundance y axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simTransComms)

#Subset the third community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community3,time &lt; inflection_pt)

#Perform multivariate EWS assessments
roll_ews &lt;- multiEWS(
 data = pre_simTransComms[,2:7],
 method = "rolling",
 winsize = 50)

 #Plot outcome
## Not run: 
 plot(roll_ews)

## End(Not run)

#Perform univariate EWS assessments on
#simulated data with traits

abundance_data &lt;- data.frame(time = seq(1:50),
 abundance = rnorm(50,mean = 20),
 trait = rnorm(50,mean=1,sd=0.25))

trait_ews &lt;- uniEWS(
 data = abundance_data[,1:2],
 metrics = c("ar1","SD","trait"),
 method = "expanding",
 trait = abundance_data[,3],
 burn_in = 10)

#Plot outcome
## Not run: 
 plot(trait_ews, y_lab = "Abundance",
 trait_lab = "Trait value",
 trait_scale = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='simTransComms'>Three Simulated Transitioning Communities.</h2><span id='topic+simTransComms'></span>

<h3>Description</h3>

<p>A dataset containing three simulated five species communities stressed through a critical transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTransComms
</code></pre>


<h3>Format</h3>

<p>A list of three dataframes with 301 rows and 7 variables each:
</p>

<dl>
<dt>community_id</dt><dd><p>the identity of the simulated community</p>
</dd>
<dt>time</dt><dd><p>time index</p>
</dd>
<dt>spp_1</dt><dd><p>density of species 1</p>
</dd>
<dt>spp_2</dt><dd><p>density of species 1</p>
</dd>
<dt>spp_3</dt><dd><p>density of species 1</p>
</dd>
<dt>spp_4</dt><dd><p>density of species 1</p>
</dd>
<dt>spp_5</dt><dd><p>density of species 1</p>
</dd>
<dt>inflection_pt</dt><dd><p>the time index where transition occurs</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("simTransComms", package = "EWSmethods")

community_data &lt;- simTransComms$community1
</code></pre>

<hr>
<h2 id='uni_smap_jacobian'>S-map Inferred Jacobian</h2><span id='topic+uni_smap_jacobian'></span>

<h3>Description</h3>

<p>Performs the S-map on a univariate time series to infer the Jacobian matrix at different points in time across thetas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uni_smap_jacobian(data, theta_seq = NULL, E = 1, tau = NULL, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uni_smap_jacobian_+3A_data">data</code></td>
<td>
<p>Numeric matrix with time in first column and species abundance in the second</p>
</td></tr>
<tr><td><code id="uni_smap_jacobian_+3A_theta_seq">theta_seq</code></td>
<td>
<p>Numeric vector of thetas (nonlinear tuning parameters) to estimate the Jacobian over. If 'NULL', a default sequence is provided.</p>
</td></tr>
<tr><td><code id="uni_smap_jacobian_+3A_e">E</code></td>
<td>
<p>Numeric. The embedding dimension. Is suggested to be positive.</p>
</td></tr>
<tr><td><code id="uni_smap_jacobian_+3A_tau">tau</code></td>
<td>
<p>Numeric. The time-delay offset to use for time delay embedding. Suggested to be positive here, but if not provided, is set to 10% the length of the time series.</p>
</td></tr>
<tr><td><code id="uni_smap_jacobian_+3A_scale">scale</code></td>
<td>
<p>Boolean. Should data be scaled prior to estimating the Jacobian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three objects:
</p>
<table>
<tr><td><code>smap_J</code></td>
<td>
<p>Jacobian matrices across taus. It is recommended to average across these matrices.</p>
</td></tr>
<tr><td><code>eigenJ</code></td>
<td>
<p>Absolute maximum eigenvalue.</p>
</td></tr>
<tr><td><code>reJ</code></td>
<td>
<p>Real component of dominant eigenvalue</p>
</td></tr>
<tr><td><code>imJ</code></td>
<td>
<p>Imaginary component of dominant eigenvalue.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Grziwotz, F., Chang, C.-W., Dakos, V., van Nes, E.H., Schwarzländer, M., Kamps, O., et al. (2023). Anticipating the occurrence and type of critical transitions. Science Advances, 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data("simTransComms")

#Subset the second community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community2,time &lt; inflection_pt)
winsize &lt;- round(dim(pre_simTransComms)[1] * 50/100)

#Estimate the Jacobian for the first 50 timepoints of the
#second species using s-map
est_jac &lt;- uni_smap_jacobian(pre_simTransComms[1:50,2:3])

</code></pre>

<hr>
<h2 id='uniEWS'>Univariate Early Warning Signal Assessment</h2><span id='topic+uniEWS'></span>

<h3>Description</h3>

<p>A function for performing early warning signal (EWS) assessment on univariate time series. Both rolling and expanding window methods of EWS assessment can be performed with the assessments returned as a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniEWS(
  data,
  metrics,
  method = c("expanding", "rolling"),
  winsize = 50,
  burn_in = 5,
  threshold = 2,
  tail.direction = "one.tailed",
  trait = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniEWS_+3A_data">data</code></td>
<td>
<p>A dataframe where the first column is an equally spaced time vector and the second column is the time series to be assessed.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_metrics">metrics</code></td>
<td>
<p>String vector of early warning signal metrics to be assessed.  Options include: <code>"ar1"</code>, <code>"cv"</code>, <code>"SD"</code>, <code>"acf"</code>, <code>"rr"</code>, <code>"dr"</code>, <code>"skew"</code>, <code>"kurt"</code>, and <code>"trait"</code> (only available if <code>method = "expanding"</code>).</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_method">method</code></td>
<td>
<p>Single string of either <code>"expanding"</code> or <code>"rolling"</code>. <code>"expanding"</code> calls composite, expanding window EWS assessment. <code>"rolling"</code> calls typical, rolling window EWS assessment.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_winsize">winsize</code></td>
<td>
<p>Numeric value. If <code>method = "rolling"</code>, defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_burn_in">burn_in</code></td>
<td>
<p>Numeric value. If <code>method = "expanding"</code>, defines the number of data points to 'train' signals prior to EWS assessment.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_threshold">threshold</code></td>
<td>
<p>Numeric value of either <code>1</code> or <code>2</code>. Threshold*sigma is the value which, if the EWS strength exceeds it, constitutes a &quot;signal&quot;.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_tail.direction">tail.direction</code></td>
<td>
<p>String of either <code>"one.tailed"</code> or <code>"two.tailed"</code>. <code>"one.tailed"</code> only indicates a warning if positive threshold sigma exceeded. <code>"two.tailed"</code> indicates a warning if positive OR negative threshold*sigma exceeded.</p>
</td></tr>
<tr><td><code id="uniEWS_+3A_trait">trait</code></td>
<td>
<p>A vector of numeric trait values if desired. Can be <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing up to two objects: EWS outputs through time (<code>EWS</code>), and an identifier string (<code>method</code>).
</p>
<table>
<tr><td><code>EWS$raw</code></td>
<td>
<p>Dataframe of EWS measurements through time. If <code>method = "expanding"</code>, then each metric has been rbound into a single dataframe and extra columns are provided indicating whether the threshold*sigma value has been exceeded (i.e. <code>"threshold.crossed"</code>). If <code>method = "rolling"</code>, then each metric's evolution over time is returned in individual columns.</p>
</td></tr>
<tr><td><code>EWS$cor</code></td>
<td>
<p>Dataframe of Kendall Tau correlations. Only returned if <code>method = "rolling"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#A dummy dataset of a hedgerow bird population over
#25 years where both the number of individuals and
#the average bill length has been measured.

abundance_data &lt;- data.frame(time = seq(1:25),
 abundance = rnorm(25,mean = 20),
 trait = rnorm(25,mean=1,sd=0.5))

#The early warning signal metrics to compute.

ews_metrics &lt;- c("SD","ar1","skew")

#Rolling window early warning signal assessment of
#the bird abundance.

roll_ews &lt;- uniEWS(
 data = abundance_data[,1:2],
 metrics =  ews_metrics,
 method = "rolling",
 winsize = 50)

#Expanding window early warning signal assessment of
#the bird abundance (with plotting).

exp_ews &lt;- uniEWS(
 data = abundance_data[,1:2],
 metrics = ews_metrics,
 method = "expanding",
 burn_in = 10)

#Expanding window early warning signal assessment of
#the bird abundance incorporating the trait
#information.

ews_metrics_trait &lt;- c("SD","ar1","trait")

trait_exp_ews &lt;- uniEWS(
 data = abundance_data[,1:2],
 metrics = ews_metrics_trait,
 method = "expanding",
 burn_in = 10,
 trait = abundance_data$trait)

</code></pre>

<hr>
<h2 id='uniJI'>Univariate S-map Jacobian index function</h2><span id='topic+uniJI'></span>

<h3>Description</h3>

<p>Calculate a stability metric from the s-map estimated Jacobian of a univariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniJI(data, winsize = 50, theta_seq = NULL, E = 1, tau = NULL, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniJI_+3A_data">data</code></td>
<td>
<p>Numeric matrix with time in first column and species abundance in the second</p>
</td></tr>
<tr><td><code id="uniJI_+3A_winsize">winsize</code></td>
<td>
<p>Numeric. Defines the window size of the rolling window as a percentage of the time series length.</p>
</td></tr>
<tr><td><code id="uniJI_+3A_theta_seq">theta_seq</code></td>
<td>
<p>Numeric vector of thetas (nonlinear tuning parameters) to estimate the Jacobian over. If 'NULL', a default sequence is provided.</p>
</td></tr>
<tr><td><code id="uniJI_+3A_e">E</code></td>
<td>
<p>Numeric. The embedding dimension. Is suggested to be positive.</p>
</td></tr>
<tr><td><code id="uniJI_+3A_tau">tau</code></td>
<td>
<p>Numeric. The time-delay offset to use for time delay embedding. Suggested to be positive here, but if not provided, is set to 10% the length of the time series.</p>
</td></tr>
<tr><td><code id="uniJI_+3A_scale">scale</code></td>
<td>
<p>Boolean. Should data be scaled prior to estimating the Jacobian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe where the first column is last time index of the window and the second column is the estimated index value. A value &lt;1.0 indicates stability, a value &gt;1.0 indicates instability.
</p>


<h3>Source</h3>

<p>Grziwotz, F., Chang, C.-W., Dakos, V., van Nes, E.H., Schwarzländer, M., Kamps, O., et al. (2023). Anticipating the occurrence and type of critical transitions. Science Advances, 9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the multivariate simulated
#dataset `simTransComms`

data(simTransComms)

#Subset the second community prior to the transition

pre_simTransComms &lt;- subset(simTransComms$community2,time &lt; inflection_pt)

#Estimate the univariate stability index for the first species in
#the second community

egJI &lt;- uniJI(data = pre_simTransComms[1:25,2:3],
winsize = 75, E = 3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
