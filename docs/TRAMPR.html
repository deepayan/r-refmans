<!DOCTYPE html><html><head><title>Help for package TRAMPR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TRAMPR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absolute.min'><p>Absolute Minimum</p></a></li>
<li><a href='#add.known'><p>Add Knowns To TRAMPknowns Databases</p></a></li>
<li><a href='#build.knowns'><p>Automatically Build Knowns Database</p></a></li>
<li><a href='#classify'><p>Value Matching for Data Frames</p></a></li>
<li><a href='#combine'><p>Combine Two Objects</p></a></li>
<li><a href='#combine.TRAMPsamples'><p>Combine TRAMPsamples Objects</p></a></li>
<li><a href='#create.diffsmatrix'><p>Calculate Matrix of Distances between Peaks</p></a></li>
<li><a href='#demo.knowns'><p>Demonstration Knowns Database</p></a></li>
<li><a href='#demo.samples'><p>Demonstration Samples Database</p></a></li>
<li><a href='#group.knowns'><p>Knowns Clustering</p></a></li>
<li><a href='#load.abi'><p>Load ABI Output Files</p></a></li>
<li><a href='#plot.TRAMP'><p>Plot a TRAMP Object</p></a></li>
<li><a href='#plot.TRAMPknowns'><p>Summary Plot of Knowns Data</p></a></li>
<li><a href='#plot.TRAMPsamples'><p>Plot a TRAMPsamples Object</p></a></li>
<li><a href='#read.abi'><p>Read ABI Output Files</p></a></li>
<li><a href='#read.write'><p>Read/Write TRAMPknowns and TRAMPsamples Objects</p></a></li>
<li><a href='#rebuild.TRAMP'><p>Rebuild a TRAMP Object</p></a></li>
<li><a href='#remove.TRAMP.match'><p>Mark a TRAMP Match as Ignored</p></a></li>
<li><a href='#summary.TRAMP'><p>Create Presence/Absence Matrices from TRAMP Objects</p></a></li>
<li><a href='#TRAMP'><p>TRFLP Analysis and Matching Program</p></a></li>
<li><a href='#TRAMPindexing'><p>Index (Subset) TRAMPsamples and TRAMPknowns Objects</p></a></li>
<li><a href='#TRAMPknowns'><p>TRAMPknowns Objects</p></a></li>
<li><a href='#TRAMPR-package'><p>The TRAMPR Package (TRFLP Analysis and Matching Package for R)</p></a></li>
<li><a href='#TRAMPsamples'><p>TRAMPsamples Objects</p></a></li>
<li><a href='#update.TRAMP'><p>Interactively Alter a TRAMP Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'TRFLP' Analysis and Matching Package for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-10</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richfitz/TRAMPR">https://github.com/richfitz/TRAMPR</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Matching terminal restriction fragment length
        polymorphism ('TRFLP') profiles between unknown samples and a
        database of known samples.  'TRAMPR' facilitates analysis of
        many unknown profiles at once, and provides tools for working
        directly with electrophoresis output through to generating
        summaries suitable for community analyses with R's rich set of
        statistical functions.  'TRAMPR' also resolves the issues of
        multiple 'TRFLP' profiles within a species, and shared 'TRFLP'
        profiles across species.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-07 18:07:37 UTC; rich</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Ian Dickie [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-07 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='absolute.min'>Absolute Minimum</h2><span id='topic+absolute.min'></span>

<h3>Description</h3>

<p>Returns the signed value of the element with the minimum
absolute value in a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>absolute.min(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absolute.min_+3A_x">x</code></td>
<td>
<p>Numeric vector (<code>NA</code>s are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value; the value with the smallest absolute value, but with
its original sign.  This is equivalent to (and implemented as)
<code>x[which.min(abs(x))]</code>
</p>
<p>The value is <code>NA</code> if <code>x</code> has no non-<code>NA</code> values
(c.f. <code><a href="base.html#topic+which.min">which.min</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(16)
min(x)          # -2.2147
min(abs(x))     #  0.0444
absolute.min(x) # -0.0444: preserves sign

# NA values OK:
absolute.min(c(-1, 4, NA))

# Slightly unintuitive behaviour:
absolute.min(numeric(0)) # numeric(0)
absolute.min(NA)         # NA
</code></pre>

<hr>
<h2 id='add.known'>Add Knowns To TRAMPknowns Databases</h2><span id='topic+add.known'></span><span id='topic+add.known.TRAMP'></span><span id='topic+add.known.TRAMPknowns'></span><span id='topic+combine.TRAMP'></span><span id='topic+combine.TRAMPknowns'></span>

<h3>Description</h3>

<p>Add a single known or many knowns to a knowns database in a
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object.  <code>add.known</code> takes a
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object, and adds the peak profile of a
single sample from a <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object.
<code>combine.TRAMPknowns</code> combines two <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>
objects (similar to <code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code>).
<code>add.known</code> and <code>combine</code> are generic, so if <code>x</code>
argument is a <code><a href="#topic+TRAMP">TRAMP</a></code> object, then the <code>knowns</code>
component of that object will be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.known(x, ...)
## S3 method for class 'TRAMPknowns'
add.known(x, samples, sample.fk, prompt=TRUE, default.species=NULL, ...)
## S3 method for class 'TRAMP'
add.known(x, sample.fk, rebuild=TRUE, ...)

## S3 method for class 'TRAMPknowns'
combine(x, y, rewrite.knowns.pk=FALSE, ...)
## S3 method for class 'TRAMP'
combine(x, y, rebuild=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.known_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> or <code><a href="#topic+TRAMP">TRAMP</a></code> object,
containing identified TRFLP patterns.</p>
</td></tr>
<tr><td><code id="add.known_+3A_samples">samples</code></td>
<td>
<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object, containing
unidentified samples.</p>
</td></tr>
<tr><td><code id="add.known_+3A_sample.fk">sample.fk</code></td>
<td>
<p><code>sample.fk</code> of sample in <code>samples</code> to add
to the knowns database.  If <code>x</code> is a <code><a href="#topic+TRAMP">TRAMP</a></code>
object, then <code>sample.fk</code> refers to a sample in the
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object used in the creation of that
<code><a href="#topic+TRAMP">TRAMP</a></code> object (stored as <code>x$samples</code>: see
<code>labels(x$samples)</code> for codes).</p>
</td></tr>
<tr><td><code id="add.known_+3A_prompt">prompt</code></td>
<td>
<p>Logical: Should the function interactively prompt for a
new species name?</p>
</td></tr>
<tr><td><code id="add.known_+3A_default.species">default.species</code></td>
<td>
<p>Default species name.  If <code>NULL</code> (the
default), the name chosen will be the value of
<code>samples$info$species</code> for the current sample.  Set to
<code>NA</code> if no name is currently known (see
<code><a href="#topic+group.knowns">group.knowns</a></code> - identical non-<code>NA</code> names are
considered related).</p>
</td></tr>
<tr><td><code id="add.known_+3A_y">y</code></td>
<td>
<p>A second <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object, containing knowns
to add to <code>x</code>.</p>
</td></tr>
<tr><td><code id="add.known_+3A_rewrite.knowns.pk">rewrite.knowns.pk</code></td>
<td>
<p>Logical: If the new knowns data contain
<code>knowns.pk</code> values that conflict with those in the original
<code>TRAMPknowns</code> object, should the new knowns be renumbered?  If
this is <code>TRUE</code>, do not rely on <em>any</em> <code>knowns.pk</code>
values staying the same for the newly added knowns.
<code>knowns.pk</code> values in the original <code>TRAMPknowns</code> object
will never be changed.</p>
</td></tr>
<tr><td><code id="add.known_+3A_rebuild">rebuild</code></td>
<td>
<p>Logical: should the <code><a href="#topic+TRAMP">TRAMP</a></code> object be
rebuilt after adding knowns, by running <code><a href="#topic+rebuild.TRAMP">rebuild.TRAMP</a></code>
on it?  This is important to determine if the new known(s) match any
of the samples in the <code>TRAMP</code> object.  This should be left as
<code>TRUE</code> unless you plan on manually rebuilding the object
later.</p>
</td></tr>
<tr><td><code id="add.known_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(<code>add.known</code> only): When adding the profile of a single
individual via <code>add.known</code>, if more than one peak per
enzyme/primer combination is present we select the most likely profile
by picking the highest peak (largest <code>height</code> value) for each
enzyme/primer combination (a warning will be given).  If two peaks are
of the same <code>height</code>, then the peak taken is unspecified (similar
to <code><a href="#topic+build.knowns">build.knowns</a></code> with <code>min.ratio=0</code>).
</p>
<p>(<code>combine</code> only): <code>rewrite.knowns.pk</code> provides a
simple way of merging knowns databases that use the same values of
<code>knowns.pk</code>.  Because <code>knowns.pk</code> must be unique, if
<code>y</code> (the new knowns database) uses <code>knowns.pk</code> values
present in <code>x</code> (the original database), then the <code>knowns.pk</code>
values in <code>y</code> must be rewritten.  This will be done by adding
<code>max(labels(x))</code> to <em>every</em> <code>knowns.pk</code> value in
<code>y$info</code> and <code>knowns.fk</code> value in <code>y$data</code>.
</p>
<p>If retaining <code>knowns.pk</code> information is important, we
suggest saving the value of <code>knowns.pk</code> before running this
function, e.g.
</p>
<p><code>info$knowns.pk.old &lt;- info$knowns.pk</code>
</p>
<p>If more control over the renaming process is required, manually adjust
<code>y$info$knowns.pk</code> yourself before calling this function.
However, by default no translation will be done, and an error will
occur if <code>x</code> and <code>y</code> share <code>knowns.pk</code> values.
</p>
<p>For <code>add.known</code>, only a subset of columns are passed to the
knowns object (a future version may be more inclusive):
</p>

<ul>
<li><p> From <code>samples$info</code>: <code>sample.pk</code> (as
<code>knowns.pk</code>.)
</p>
</li>
<li><p> From <code>samples$data</code>: <code>sample.fk</code> (as
<code>knowns.fk</code>), <code>primer</code>, <code>enzyme</code>, <code>size</code>.
</p>
</li></ul>

<p>For <code>combine</code>, the <code>data</code> and <code>info</code> elements of
the resulting <code>TRAMPknowns</code> object will have the union of the
columns present in both sets of knowns.  If any additional elements
exist as part of the second <code>TRAMPknowns</code> object (e.g. passed as
<code>...</code> to <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> when creating <code>y</code>), these
will be ignored.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>: if a <code>TRAMP</code> object is
supplied, a new <code>TRAMP</code> object with an updated <code>TRAMPknowns</code>
component will be returned, and if the object is a <code>TRAMPknowns</code>
object an updated <code>TRAMPknowns</code> object will be returned.
</p>


<h3>Note</h3>

<p>If the <code>TRAMPknowns</code> object has a <code>file.pat</code> element (see
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>), then the new knowns database will be
written to file.  This may be confusing when operating on <code>TRAMP</code>
objects directly, since both the <code>TRAMPknowns</code> object used in the
<code>TRAMP</code> object and the original <code>TRAMPknowns</code> object will
share the same <code>file.pat</code> argument, but contain different data as
soon as <code>add.known</code> or <code>combine</code> is used.  In short -
be careful!  To avoid this issue, either set <code>file.pat</code> to
<code>NULL</code> before using <code>add.known</code> or <code>combine</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build.knowns">build.knowns</a></code>, which automatically builds a knowns
database, and <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>, which documents the object
containing the knowns database.
</p>
<p><code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code>, which combines a pair of
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.knowns)
data(demo.samples)

## (1) Using add.known(), to add a single known:

## Sample "101" looks like a potential known, add it to our knowns
## database:
plot(demo.samples, 101)

## Add this to a knowns database:
## Because there is more than one peak per enzyme/primer combination, a
## warning will be given.  In this case, since there are clear peaks it
## is harmless.
demo.knowns.2 &lt;- add.known(demo.knowns, demo.samples, 101,
                           prompt=FALSE)

## The known has been added:
demo.knowns.2[101]
try(demo.knowns[101]) # error - known didn't exist in original knowns

## Same, but adding to an existing TRAMP object.
res &lt;- TRAMP(demo.samples, demo.knowns)
plot(res, 101)
res2 &lt;- add.known(res, 101, prompt=FALSE, default.species="New known")

## Now the new known matches itself.
plot(res2, 101)

## (2) Using combine() to combine knowns databases.

## Let's split the original knowns database in two:
demo.knowns.a &lt;- demo.knowns[head(labels(demo.knowns), 10)]
demo.knowns.b &lt;- demo.knowns[tail(labels(demo.knowns), 10)]

## Combining these is easy:
demo.knowns.c &lt;- combine(demo.knowns.a, demo.knowns.b)

## Knowns from both the small database are present in the new one:
identical(c(labels(demo.knowns.a), labels(demo.knowns.b)),
          labels(demo.knowns.c))


## Demonstration of knowns rewriting:
demo.knowns.d &lt;- demo.knowns.a
demo.knowns.a$info$from &lt;- "a"
demo.knowns.d$info$from &lt;- "d"

try(combine(demo.knowns.a, demo.knowns.d)) # error
demo.knowns.e &lt;- combine(demo.knowns.a, demo.knowns.d,
                         rewrite.knowns.pk=TRUE)

## See that both data sets are here (check the "from" column).
demo.knowns.e$info

## Note that a better approach in might be to manually resolve
## conficting knowns.pk values before combining.
</code></pre>

<hr>
<h2 id='build.knowns'>Automatically Build Knowns Database</h2><span id='topic+build.knowns'></span>

<h3>Description</h3>

<p>This function uses several filters to select likely knowns, and
construct a <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object from a
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object.  Samples are considered to be
&ldquo;potential knowns&rdquo; if they have data for an adequate number of
enzyme/primer combinations, and if for each combination they have
either a single peak, or a peak that is &ldquo;distinct enough&rdquo; from
any other peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.knowns(d, min.ratio=3, min.comb=NA, restrict=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.knowns_+3A_d">d</code></td>
<td>
<p>A <code>TRAMPsamples</code> object, containing samples from which
to build the knowns database.</p>
</td></tr>
<tr><td><code id="build.knowns_+3A_min.ratio">min.ratio</code></td>
<td>
<p>Minimum ratio of maximum to second highest peak to
accept known (see Details).</p>
</td></tr>
<tr><td><code id="build.knowns_+3A_min.comb">min.comb</code></td>
<td>
<p>Minimum number of enzyme/primer combinations required
for each known (see Details for behaviour of default).</p>
</td></tr>
<tr><td><code id="build.knowns_+3A_restrict">restrict</code></td>
<td>
<p>Logical: Use only cases where <code>d$info$species</code> is
non-blank?  (These are assumed to come from samples of a known
species.  However, it is not guaranteed that all samples with data for
<code>species</code> will become knowns; if they fail either the
<code>min.ratio</code> or <code>min.comb</code> checks they will be excluded.)</p>
</td></tr>
<tr><td><code id="build.knowns_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>
(e.g. <code>cluster.pars</code>, <code>file.pat</code> and any additional
objects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all samples and enzyme/primer combinations, the ratio of the
largest to the second largest peak is calculated.  If it is greater
than <code>min.ratio</code>, then that combination is accepted.  If the
sample has at least <code>min.comb</code> valid enzyme/primer combinations,
then that sample is included in the knowns database.  If
<code>min.comb</code> is <code>NA</code> (the default), then <em>every</em>
enzyme/primer combination present in the data is required.
</p>


<h3>Value</h3>

<p>A new <code>TRAMPknowns</code> object.  It will generally be neccessary to
edit this object; see <code><a href="#topic+read.TRAMPknowns">read.TRAMPknowns</a></code> for details on
how to write, edit, and read back a modified object.
</p>


<h3>Note</h3>

<p>If two peaks have the same height, then using <code>min.ratio=1</code> will
not allow the entry as part of the knowns database; use
<code>min.ratio=0</code> instead if this is desired.  In this case, the peak
chosen is unspecified.
</p>
<p>Note that this function is sensitive to data quality.  In particular
split peaks may cause a sample not to be added.  These samples may be
manually added using <code><a href="#topic+add.known">add.known</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)
demo.knowns.auto &lt;- build.knowns(demo.samples, min.comb=4)
plot(demo.knowns.auto, cex=.75)
</code></pre>

<hr>
<h2 id='classify'>Value Matching for Data Frames</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p><code>match</code>-like classification for data.frames; returns a
vector of row numbers of (first) matches of its first argument in its
second, across shared column names.  This is unlikely to be useful to
casual <code>TRAMP</code> users, but see the final example for a relevant
usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(x, table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>data.frame: containing columns with the values to be
matched.</p>
</td></tr>
<tr><td><code id="classify_+3A_table">table</code></td>
<td>
<p>data.frame: where all columns contain the values to be
matched against.</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="base.html#topic+match">match</a></code> (see especially
<code>nomatch</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with <code><a href="base.html#topic+duplicated.data.frame">duplicated.data.frame</a></code>, this works by pasting
together a character representation of the rows separated by
<code>\r</code> (a carriage return), so may be imperfect if the data.frame
has characters with embedded carriage returns or columns which do not
reliably map to characters.
</p>
<p>Cases in <code>x</code> with <code>NA</code> values in any column shared with
<code>table</code> will not be matched (and will return the value of
<code>nomatch</code>).  Cases in <code>table</code> with any <code>NA</code> values in
any row will match nothing.
</p>
<p>All columns in <code>table</code> must be present in <code>x</code>, but <code>x</code>
may have additional columns that will be ignored.
</p>


<h3>Value</h3>

<p>A vector of length <code>nrow(x)</code>, with each element giving the row
number in <code>table</code> where all elements match across shared
columns.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>, on which this is based.</p>


<h3>Examples</h3>

<pre><code class='language-R'>table &lt;- data.frame(a=letters[1:3], b=rep(1:2, each=3))
x &lt;- cbind(table[sample(nrow(table), 20, TRUE),], x=runif(20))

classify(x, table)
all.equal(table[classify(x, table),], x[names(table)])

## Select only a few cases from a TRAMPsamples data object,
## corresponding with 4 enzyme/primer combinations.
data(demo.samples)
d &lt;- demo.samples$data
use &lt;- expand.grid(primer=c("ITS1F", "ITS4"),
                   enzyme=c("HpyCH4IV", "BsuRI"))
classify(d, use)
d[!is.na(classify(d, use)),]
</code></pre>

<hr>
<h2 id='combine'>Combine Two Objects</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>This function is used to combine <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> together,
and to combine <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> to <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>
or <code><a href="#topic+TRAMP">TRAMP</a></code> objects.  <code>combine</code> is generic; please see
<code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code> and
<code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code>, <code id="combine_+3A_y">y</code></td>
<td>
<p>Objects to be combined.  See
<code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code> and
<code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code> for more information.</p>
</td></tr>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>Additional arguments required by methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code> and
<code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code> for more information.
</p>

<hr>
<h2 id='combine.TRAMPsamples'>Combine TRAMPsamples Objects</h2><span id='topic+combine.TRAMPsamples'></span>

<h3>Description</h3>

<p>Combines two <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> objects into one
large <code>TRAMPsamples</code> object containing all the samples for both
original objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMPsamples'
combine(x, y, rewrite.sample.pk=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.TRAMPsamples_+3A_x">x</code>, <code id="combine.TRAMPsamples_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> objects, containing TRFLP
patterns.</p>
</td></tr>
<tr><td><code id="combine.TRAMPsamples_+3A_rewrite.sample.pk">rewrite.sample.pk</code></td>
<td>
<p>Logical: If the new sample data (<code>y</code>)
contains <code>sample.pk</code> values that conflict with those in the
original <code>TRAMPsamples</code> object (<code>x</code>), should the new samples
be renumbered?  If this is <code>TRUE</code>, do not rely on <em>any</em>
<code>sample.pk</code> values staying the same for the newly added samples.
<code>sample.pk</code> values in the original <code>TRAMPsamples</code> object
will never be changed.</p>
</td></tr>
<tr><td><code id="combine.TRAMPsamples_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a discussion of <code>rewrite.sample.pk</code>, see the comments on
<code>rewrite.knowns.pk</code> in the Details of
<code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code>.
</p>
<p>The <code>data</code> and <code>info</code> elements of the resulting
<code>TRAMPsamples</code> object will have union of the columns present in
both sets of samples.
</p>
<p>If any additional elements exist as part of the second
<code>TRAMPsamples</code> object (e.g. passed as <code>...</code> to
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>), these will be ignored with a warning (see
Example).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code>, the method for
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> objects.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)

## Let's split the original samples database in two, and recombine.
demo.samples.a &lt;- demo.samples[head(labels(demo.samples), 10)]
demo.samples.b &lt;- demo.samples[tail(labels(demo.samples), 10)]

## Combining these is easy:
demo.samples.c &lt;- combine.TRAMPsamples(demo.samples.a, demo.samples.b)

## There is a warning message because demo.samples.b contains extra
## elements:
names(demo.samples.b)

## In this case, these objects should not be combined, but in other
## cases it may be necessary to rbind() the extra objects together:
## Not run: 
demo.samples.c$soilcore &lt;- rbind(demo.samples.a$soilcore,
                                 demo.samples.b$soilcore)

## End(Not run)

## This must be done manually, since there is no way of telling what
## should be done automatically.  Ideas/contributions are welcome here.
</code></pre>

<hr>
<h2 id='create.diffsmatrix'>Calculate Matrix of Distances between Peaks</h2><span id='topic+create.diffsmatrix'></span>

<h3>Description</h3>

<p>Generate an array of goodness-of-fit (or distance) between samples and
knowns based on the sizes (in base pairs) of TRFLP peaks.  For each
sample/known combination, and for each enzyme/primer combination, this
calculates the minimum distance between any peak in the sample and the
single peak in the known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.diffsmatrix(samples, knowns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.diffsmatrix_+3A_samples">samples</code></td>
<td>
<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object, containing
unidentified samples.</p>
</td></tr>
<tr><td><code id="create.diffsmatrix_+3A_knowns">knowns</code></td>
<td>
<p>A <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object, containing
identified TRFLP patterns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will rarely need to be called directly, but does most of
the calculations behind <code><a href="#topic+TRAMP">TRAMP</a></code>, so it is useful to
understand how this works.
</p>
<p>This function generates a three-dimensional <code class="reqn">s \times k \times
    n</code> matrix of the (smallest, see below) distance in base
pairs between peaks in a collection of unknowns (run data) and a
database of knowns for several enzyme/primer combinations.  <code class="reqn">s</code> is
the number of different samples in the samples data
(<code>length(labels(samples))</code>), <code class="reqn">k</code> is the number of different
types in the knowns database (<code>length(labels(knowns))</code>), and
<code class="reqn">n</code> is the number of different enzyme/primer combinations.  The
enzyme/primer combinations used are all combinations present in the
knowns database; combinations present only in the samples will be
ignored.  Not all samples need contain all enzyme/primer combinations
present in the knowns.
</p>
<p>In the resulting array, <code>m[i,j,k]</code> is the difference (in base
pairs) between the <code>i</code>th sample and the <code>j</code>th known for the
<code>k</code>th enzyme/primer combination.  The ordering of the <code class="reqn">n</code>
enzyme/primer combinations is arbitrary, so a data.frame of
combinations is included as the attribute <code>enzyme.primer</code>, where
<code>enzyme.primer$enzyme[k]</code> and <code>enzyme.primer$primer[k]</code>
correspond to enzyme and primer used for the distances in
<code>m[,,k]</code>.
</p>
<p>Each case in the knowns database has a single (or no) peak for each
enzyme/primer combination, but each sample may contain multiple peaks
for an enzyme/primer combination; the difference is always the
smallest distance from the sample to the known peak.  Where a sample
and/or a known lacks an enzyme/primer combination, the value of the
difference is <code>NA</code>.  The smallest <em>absolute</em> distance is
taken between sample and known peaks, but the sign of the difference
is preserved (negative where the closest sample peak was less than the
known peak, positive where greater; see <code><a href="#topic+absolute.min">absolute.min</a></code>).
</p>


<h3>Value</h3>

<p>A three-dimensional matrix, with an attribute <code>enzyme.primer</code>,
described above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TRAMP">TRAMP</a></code>, which uses output from
<code>create.diffsmatrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)
data(demo.knowns)

s &lt;- length(labels(demo.samples))
k &lt;- length(labels(demo.knowns))
n &lt;- nrow(unique(demo.knowns$data[c("enzyme", "primer")]))

m &lt;- create.diffsmatrix(demo.samples, demo.knowns)

dim(m)
identical(dim(m), c(s, k, n))

## Maximum error for each sample/known (i.e. across all enzyme/primer
## combinations), similar to how calculated by \link{TRAMP}
error &lt;- apply(abs(m), 1:2, max, na.rm=TRUE)
dim(error)

## Euclidian error (see ?\link{TRAMP})
error.euclid &lt;- sqrt(rowSums(m^2, TRUE, 2))/rowSums(!is.na(m), dims=2)

## Euclidian and maximum error will require different values of
## accept.error in TRAMP:
plot(error, error.euclid, pch=".")
</code></pre>

<hr>
<h2 id='demo.knowns'>Demonstration Knowns Database</h2><span id='topic+demo.knowns'></span>

<h3>Description</h3>

<p>A knowns database, for demonstrating the <code>TRAMPR</code> package.
This is a subset of a full knowns database, and not intended to
represent any real data set, and should not be assumed to be
accurate.
</p>
<p>The data are stored as a <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object.  Columns in
the <code>info</code> and <code>data</code> components are described on the
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo.knowns)</code></pre>


<h3>Licence</h3>

<p>This data set is provided under a Creative Commons
&ldquo;Attribution-NonCommercial-NoDerivs 2.5&rdquo; licence.  Please see
<a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a> for details.
</p>

<hr>
<h2 id='demo.samples'>Demonstration Samples Database</h2><span id='topic+demo.samples'></span>

<h3>Description</h3>

<p>A samples database, for demonstrating the <code>TRAMPR</code> package.
This is a subset of a full samples database, is not intended to
represent any real data set, and should not be assumed to be
accurate.
</p>
<p>The data are stored as a <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object.  Columns in
the <code>info</code> and <code>data</code> components are described on the
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> page, but with some additions:
</p>

<ul>
<li> <p><code>info</code>:
</p>

<ul>
<li> <p><code>soilcore.fk</code>: Key to the soil core from which a
sample came.  See <code>soilcore</code>, below.
</p>
</li></ul>

</li>
<li> <p><code>data</code>:
</p>

<ul>
<li> <p><code>sample.file.name</code>: Original <code>.fsa</code> file
corresponding to the TRFLP run.  This is included in all
<code>TRAMPsamples</code> objects created by <code><a href="#topic+load.abi">load.abi</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>soilcore</code>: A <code>data.frame</code> with information about
the soilcore from which samples came.
</p>

<ul>
<li> <p><code>soilcore.pk</code>: Key, distinguishing soil cores.
</p>
</li>
<li> <p><code>plot</code>: Plot number (1 to 10).
</p>
</li>
<li> <p><code>elevation</code>: Height above mean sea level, in metres.
</p>
</li>
<li> <p><code>east</code>: Easting (New Zealand Map Grid/NZMG).
</p>
</li>
<li> <p><code>north</code>: Northing (NZMG).
</p>
</li>
<li> <p><code>vegetation</code>: Vegetation type (<code>Nothofagus
	solandri</code> or <code>Pinus contorta</code>).
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(demo.samples)</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object.</p>


<h3>Licence</h3>

<p>This data set is provided under a Creative Commons
&ldquo;Attribution-NonCommercial-NoDerivs 2.5&rdquo; licence.  Please see
<a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a> for details.
</p>

<hr>
<h2 id='group.knowns'>Knowns Clustering</h2><span id='topic+group.knowns'></span><span id='topic+group.knowns.TRAMP'></span><span id='topic+group.knowns.TRAMPknowns'></span>

<h3>Description</h3>

<p>Group a <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object so that knowns
with similar TRFLP patterns and knowns that share the same species
name &ldquo;group&rdquo; together. In general, this function will be called
automatically whenever appropriate (e.g. when loading a data set or
adding new knowns).  Please see Details to understand why this
function is necessary, and how it works.
</p>
<p>The main reason for manually calling <code>group.knowns</code> is to change
the default values of the arguments; if you call <code>group.knowns</code>
on a <code>TRAMPknowns</code> object, then any subsequent automatic call to
<code>group.knowns</code> will use any arguments you passed in the
manual <code>group.knowns</code> call (e.g. after doing
<code>group.knowns(x, cut.height=20)</code>, all future groupings will use
<code>cut.height=20</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.knowns(x, ...)
## S3 method for class 'TRAMPknowns'
group.knowns(x, dist.method, hclust.method, cut.height, ...)
## S3 method for class 'TRAMP'
group.knowns(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group.knowns_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> or <code><a href="#topic+TRAMP">TRAMP</a></code> object,
containing identified TRFLP patterns.</p>
</td></tr>
<tr><td><code id="group.knowns_+3A_dist.method">dist.method</code></td>
<td>
<p>Distance method used in calculating similarity
between different knowns (see <code><a href="stats.html#topic+dist">dist</a></code>).  Valid options
include <code>"maximum"</code>, <code>"euclidian"</code> and
<code>"manhattan"</code>.</p>
</td></tr>
<tr><td><code id="group.knowns_+3A_hclust.method">hclust.method</code></td>
<td>
<p>Clustering method used in generating clusters
from the similarity matrix (see <code><a href="stats.html#topic+hclust">hclust</a></code>).</p>
</td></tr>
<tr><td><code id="group.knowns_+3A_cut.height">cut.height</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+cutree">cutree</a></code>; controls how similar
members of each group should be (the larger <code>cut.height</code>, the
more inclusive knowns groups will be).</p>
</td></tr>
<tr><td><code id="group.knowns_+3A_...">...</code></td>
<td>
<p>Arguments passed to further methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>group.knowns</code> groups together knowns in a
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object based on two criteria: (1) TRFLP
profiles that are very similar across shared enzyme/primer
combinations (based on clustering) and (2) TRFLP profiles that belong
to the same species (i.e. share a common <code>species</code> column in the
<code>info</code> data.frame of <code>x</code>; see <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> for
more information).  This is to solve three issues in TRFLP analysis:
</p>

<ol>
<li><p> The TRFLP profile of a single species can have variation in
peak sizes due to DNA sequence variation.  By including multiple
collections of each species, variation in TRFLP profiles can be
accounted for.  If a <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object contains
multiple collections of a species, these will be aggregated by
<code>group.knowns</code>.  This aggregation is essential for community
analysis, as leaving individual collections will artificially
inflate the number of &ldquo;present species&rdquo; when running
<code><a href="#topic+TRAMP">TRAMP</a></code>.
</p>
<p>Some authors have taken an alternative approach by using a larger
tolerance in matching peaks between samples and knowns (effectively
increasing <code>accept.error</code> in <code><a href="#topic+TRAMP">TRAMP</a></code>) to account
for within-species variation.  This is not recommended, as it
dramatically increases the risk of incorrect matches.
</p>
</li>
<li><p> Distinctly different TRFLP profiles may occur within a species
(or in some cases within an individual); see Avis et al. (2006).
<code>group.knowns</code> looks at the <code>species</code> column of the
<code>info</code> data.frame of <code>x</code> and joins any knowns with
identical <code>species</code> values as a group.



This can also be used where multiple profiles are present in an
individual.
</p>
</li>
<li><p> Different species may share a similar TRFLP profile and
therefore be indistinguishable using TRFLP. If these patterns are
not grouped, two species will be recorded as present wherever either
is present. <code>group.knowns</code> prevents this by joining knowns with
&ldquo;very similar&rdquo; TRFLP patterns as a group.  Ideally, these
problematic groups can be resolved by increasing the number of
enzyme/primer pairs in the data.
</p>
</li></ol>

<p>Groups names are generated by concatenating all unique (sorted)
species names together, separated by commas.
</p>
<p>To determine if knowns are &ldquo;similar enough&rdquo; to form a group, we
use <span class="rlang"><b>R</b></span>'s clustering tools: <code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>
and <code><a href="stats.html#topic+cutree">cutree</a></code>.  First, we generate a distance matrix of the
knowns profiles using <code><a href="stats.html#topic+dist">dist</a></code>, and using method
<code>dist.method</code> (see Example below; this is very similar to what
<code><a href="#topic+TRAMP">TRAMP</a></code> does, and <code>dist.method</code> should be specified
accordingly).  We then generate clusters using <code><a href="stats.html#topic+hclust">hclust</a></code>,
and using method <code>hclust.method</code>, and &ldquo;cut&rdquo; the tree at
<code>cut.height</code> using <code><a href="stats.html#topic+cutree">cutree</a></code>.
</p>
<p>Knowns are grouped together iteratively; so that all groups sharing a
common cluster are grouped together, and all knowns that share a
common species name are grouped together.  In certain cases this may
chain together seemingly unrelated groups.
</p>
<p>Because <code>group.knowns</code> is generic, it can be run on either a
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> or a <code><a href="#topic+TRAMP">TRAMP</a></code> object.  When run
on a <code>TRAMP</code> object, it updates the <code>TRAMPknowns</code> object
(stored as <code>x$knowns</code>), so that subsequent calls to
<code><a href="#topic+plot.TRAMPknowns">plot.TRAMPknowns</a></code> or <code><a href="#topic+summary.TRAMPknowns">summary.TRAMPknowns</a></code>
(for example) will use the new grouping parameters.
</p>
<p>Parameters set by <code>group.knowns</code> are retained as part of the
object, so that when adding additional knowns (<code><a href="#topic+add.known">add.known</a></code>
and <code>combine</code>), or when subsetting a knowns database (see
<code><a href="#topic++5B.TRAMPknowns">[.TRAMPknowns</a></code>, 
aka <code><a href="#topic+TRAMPindexing">TRAMPindexing</a></code>), the same grouping parameters will be
used.
</p>


<h3>Value</h3>

<p>For <code>group.knowns.TRAMPknowns</code>, a new <code>TRAMPknowns</code> object.
The <code>cluster.pars</code> element will have been updated with new
parameters, if any were specified.
</p>
<p>For <code>group.knowns.TRAMP</code>, a new <code>TRAMP</code> object, with an
updated <code>knowns</code> element.  Note that the <em>original</em>
<code>TRAMPknowns</code> object (i.e. the one from which the <code>TRAMP</code>
object was constructed) will <code>not</code> be modified.
</p>


<h3>Warning</h3>

<p>Warning about missing data: where there are <code>NA</code> values in
certain combinations, <code>NA</code>s may be present in the final distance
matrix, which means we cannot use <code>hclust</code> to generate the
clusters!  In general, <code>NA</code> values are fine.  They just can't be
everywhere.
</p>


<h3>References</h3>

<p>Avis PG, Dickie IA, Mueller GM 2006. A &lsquo;dirty&rsquo; business:
testing the limitations of terminal restriction fragment length
polymorphism (TRFLP) analysis of soil fungi. Molecular Ecology
15: 873-882.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>, which describes the <code>TRAMPknowns</code>
object.
</p>
<p><code><a href="#topic+build.knowns">build.knowns</a></code>, which attempts to generate a knowns
database from a <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> data set.
</p>
<p><code><a href="#topic+plot.TRAMPknowns">plot.TRAMPknowns</a></code>, which graphically displays the
relationships between knowns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.knowns)
data(demo.samples)

demo.knowns &lt;- group.knowns(demo.knowns, cut.height=2.5)
plot(demo.knowns)

## Increasing cut.height makes groups more inclusive:
plot(group.knowns(demo.knowns, cut.height=100))

res &lt;- TRAMP(demo.samples, demo.knowns)
m1.ungrouped &lt;- summary(res)
m1.grouped &lt;- summary(res, group=TRUE)
ncol(m1.grouped) # 94 groups

res2 &lt;- group.knowns(res, cut.height=100)
m2.ungrouped &lt;- summary(res2)
m2.grouped &lt;- summary(res2, group=TRUE)
ncol(m2.grouped) # Now only 38 groups

## group.knowns results in the same distance matrix as produced by
## TRAMP, therefore using the same method (e.g. method="maximum") is
## important.  The example below shows how the matrix produced by
## dist(summary(x)) (as calculated by group.knowns) is the same as that
## produced by TRAMP:
f &lt;- function(x, method="maximum") {
  ## Create a pseudo-samples object from our knowns
  y &lt;- x
  y$data$height &lt;- 1
  names(y$info)[names(y$info) == "knowns.pk"] &lt;- "sample.pk"
  names(y$data)[names(y$data) == "knowns.fk"] &lt;- "sample.fk"
  class(y) &lt;- "TRAMPsamples"

  ## Run TRAMP, clean up and return
  ## (If method != "maximum", rescale the error to match that
  ## generated by dist()).
  z &lt;- TRAMP(y, x, method=method)
  if ( method != "maximum" ) z$error &lt;- z$error * z$n
  names(dimnames(z$error)) &lt;- NULL
  z
}

g &lt;- function(x, method="maximum")
  as.matrix(dist(summary(x), method=method))

all.equal(f(demo.knowns, "maximum")$error,   g(demo.knowns, "maximum"))
all.equal(f(demo.knowns, "euclidian")$error, g(demo.knowns, "euclidian"))
all.equal(f(demo.knowns, "manhattan")$error, g(demo.knowns, "manhattan"))

## However, TRAMP is over 100 times slower in this special case.
system.time(f(demo.knowns))
system.time(g(demo.knowns))
</code></pre>

<hr>
<h2 id='load.abi'>Load ABI Output Files</h2><span id='topic+load.abi'></span><span id='topic+load.abi.create.template'></span><span id='topic+load.abi.create.info'></span><span id='topic+peakscanner.to.genemapper'></span>

<h3>Description</h3>

<p>These functions help convert data from Applied Biosystems
Gene Mapper (ABI) output format into <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>
objects for analysis.  Note that this operates on the summarised
output (a text file), rather than the <code>.fsa</code> files containing
data for individual runs.
</p>
<p>Details of the procedure of this function are given below, and a
worked example is given in the package vignette; type
<code>vignette("TRAMPRdemo")</code> to view it.
</p>
<p>The function <code>peakscanner.to.genemapper</code> is an experimental
function to convert from peakscanner output to abi genemapper output.
The peakscanner output is very slightly different in format, and
currently <code>load.abi</code> is very fussy about the input file's
structure.  Eventially <code>load.abi</code> will be made more tolerant, but
as an interim solution, run <code>peakscanner.to.genemapper</code> on your
file.  By default, running
<code>peakscanner.to.genemapper(myfile.csv)</code> will produce a file
<code>myfile.txt</code>.  This can then be loaded using <code>load.abi</code> as
described below, specifying <code>myfile.txt</code> as the <code>file</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.abi(file, file.template, file.info, primer.translate, ...)
load.abi.create.template(file, file.template)
load.abi.create.info(file, file.template, file.info)

peakscanner.to.genemapper(filename, output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.abi_+3A_file">file</code></td>
<td>
<p>The name of the file from which the ABI data are to be
read from.</p>
</td></tr>
<tr><td><code id="load.abi_+3A_file.template">file.template</code></td>
<td>
<p>The name of the file containing the
&ldquo;template&rdquo; file (see Details).</p>
</td></tr>
<tr><td><code id="load.abi_+3A_file.info">file.info</code></td>
<td>
<p>(Optional) the name of the file containing extra
information associated with each sample (see Details).</p>
</td></tr>
<tr><td><code id="load.abi_+3A_primer.translate">primer.translate</code></td>
<td>
<p>List used to translate dye codes into
primers.  The same codes are assumed to apply across the whole
file.  See Details for format.</p>
</td></tr>
<tr><td><code id="load.abi_+3A_...">...</code></td>
<td>
<p>Additional objects to incorportate
into a <code>TRAMPsamples</code> object.  See <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>
for details.</p>
</td></tr>
<tr><td><code id="load.abi_+3A_filename">filename</code></td>
<td>
<p>In <code>peakscanner.to.genemapper</code>, the name of the
csv file containing output.</p>
</td></tr>
<tr><td><code id="load.abi_+3A_output">output</code></td>
<td>
<p>In <code>peakscanner.to.genemapper</code>, the name of the
file to be output in abi format (if omitted, this will be
automatically generated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some terminology: a &ldquo;sample&rdquo; refers to a physical sample
(e.g. a root tip), while a &ldquo;run&rdquo; refers to an individual
TRFLP run (i.e. one enzyme and one primer).  Because two primers are
run at once, each &ldquo;runfile&rdquo; contains information on two
&ldquo;runs&rdquo;, but each &ldquo;sample&rdquo; may contain more than one
&ldquo;runfile&rdquo;.  Runfiles are distinguished by different
<code>sample.file.name</code> values in the ABI file, while different
samples are distinguished by different
<code>sample.fk</code>/<code>sample.pk</code> values.
</p>
<p><code>primer.translate</code> is a list used to translate between the dyes
recorded in the ABI file and the primers used.  Each element
corresponds to a different primer, and is a vector of different colour
dyes.  The list:
</p>
<p><code>list(ITS1F="B", ITS4="G")</code>
</p>
<p>would translate all dyes with the value <code>"B"</code> to <code>"ITS1F"</code>,
and all dyes with the value <code>"G"</code> to <code>"ITS4"</code>.  The list:
</p>
<p><code>list(ITS1F="B", ITS4=c("G", "Y"))</code>
</p>
<p>would do the same, except that <em>both</em> <code>"G"</code> and <code>"Y"</code>
dyes would be converted to <code>"ITS4"</code>.  If a dye is used in the
data that is not represented within <code>primer.translate</code>, then it
will be excluded (e.g., all rows of data with <code>dye</code> as
<code>"R"</code> will be excluded).
</p>
<p>The procedure for loading in ABI data is:
</p>


<ol>
<li><p> Create the &ldquo;template&rdquo; file.  Template files are
required to record which enzymes were used for each run, since that
is not included in the ABI output, and to group together separate
runs (typically different enzymes) that apply to the same
individual.  The function <code>load.abi.create.template</code> will
create a template that contains all the unique file names found in
the ABI file (as <code>sample.file.name</code>), and blank columns titled
<code>enzyme</code> and <code>sample.index</code>.  Running
</p>
<p><code>load.abi.create.template(x)</code>
</p>
<p>where <code>x</code> is the name of your ABI file will create a template
file in the same directory as the ABI file.  The function will print
the name and location of the template file to the console.
</p>
</li>
<li><p> Edit the template file and save.  The <code>enzyme</code> and
<code>sample.index</code> columns are initially empty and need filling in,
which can be done in Excel, or another spreadsheet program.  The
<code>sample.index</code> column links <code>sample.file.name</code> back to an
individual sample; multiple <code>sample.file.name</code>s that share
<code>sample.index</code> values come from the same individual sample.
(If editing with Excel, ignore all the warnings about incompatible
file formats when saving.)  <code>sample.index</code> should be a positive
integer (but see Note below).
</p>
</li>
<li><p> Optionally create an &ldquo;info&rdquo; file, which is useful if
you want to associate extra information against your samples.  The
function <code>load.abi.create.info</code> will create an info file that
contains all the unique values of <code>sample.index</code>, and an empty
column titled <code>species</code>.  The <code>species</code> column can be
filled in where the species is known (e.g. from collections of
sporocarps).  Any additional columns may be added.  Running
</p>
<p><code>load.abi.create.info(x)</code>
</p>
<p>where <code>x</code> is the name of your ABI file will create an info
file in the same directory as the ABI file.  The function will print
the name and location of the info file to the console.  Edit and
save this file.
</p>
</li>
<li><p> Create the <code>TRAMPsamples</code> object by running
<code>load.abi</code>.  This loads your ABI data, plus the new template
file, plus an optional information file.  Running
</p>
<p><code>my.samples &lt;- load.abi(x, primer.translate=primer.translate)</code>
</p>
<p>will create an object &ldquo;<code>my.samples</code>&rdquo; containing your
data.
</p>
</li></ol>

<p>By default, the filenames of the template and info files will be
automatically generated: <code>&lt;prefix&gt;.&lt;ext&gt;</code> becomes
<code>&lt;prefix&gt;_template.csv</code> or <code>&lt;prefix&gt;_info.csv</code>.  If you
choose to specify <code>file.template</code> or <code>file.info</code> manually
when running <code>load.info.create.template</code> or
<code>load.info.create.info</code>, you must use the same values of
<code>file.template</code> and <code>file.info</code> when running
<code>load.abi</code>.
</p>


<h3>Warning</h3>

<p>Do not change the names of any columns produced by
<code>load.abi.create.template</code> or <code>load.abi.create.info</code>.
</p>


<h3>Note</h3>

<p>There is no reason that data from other types of output files could
not be manually imported using <code>TRAMPsamples</code>.  We welcome
contributions for other major data formats.
</p>
<p>When creating <code>sample.index</code> values, these should be positive
integers.  If you enter strings (e.g. <code>a1</code>, <code>b1</code>), these
will be automatically converted into integers.  Once loaded,
<code>sample.pk</code>/<code>sample.fk</code> is always a positive integer key,
but <code>sample.index</code> will be retained as your string keys.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.abi">read.abi</a></code>, which reads in ABI data with few
modifications.
</p>
<p><code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>, which documents the data type produced by
<code>load.abi</code>.
</p>
<p>The package vignette, which includes a worked example of loading data
using these functions; to locate the vignette, type
<code>help(library=TRAMPR)</code>, and scroll to the bottom of the page, or
type: <code>system.file("doc/TRAMPR_demo.pdf", package="TRAMPR")</code>.
</p>

<hr>
<h2 id='plot.TRAMP'>Plot a TRAMP Object</h2><span id='topic+plot.TRAMP'></span><span id='topic+TRAMP.plotone'></span>

<h3>Description</h3>

<p>Creates a graphical representation of matches performed by
<code><a href="#topic+TRAMP">TRAMP</a></code>.  The plot displays (1) &ldquo;matches&rdquo;, showing
how samples match the knowns and (2) &ldquo;peak profiles&rdquo;, showing
the locations of peaks for individual enzyme/primer combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMP'
plot(x, sample.fk, ...)
TRAMP.plotone(x, sample.fk, grouped=FALSE, ignore=FALSE,
              all.knowns=TRUE, all.samples=FALSE,
              all.samples.global=FALSE, col=1:10,
              pch=if (grouped) 15 else 16, xmax=NULL, horiz.lines=TRUE,
              mar.default=.5, p.top=.5, p.labels=1/3, cex.axis=NULL,
              cex.axis.max=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TRAMP_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMP">TRAMP</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_sample.fk">sample.fk</code></td>
<td>
<p>The <code>sample.fk</code> to plot.  If omitted, then all
samples are plotted, one after the other (this is useful for
generating a summary of all fits for printing out: see Example).</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_grouped">grouped</code></td>
<td>
<p>Logical: Should the matched knowns be grouped?</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_ignore">ignore</code></td>
<td>
<p>Logical: Should matches marked as ignored by
<code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code> be excluded?</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_all.knowns">all.knowns</code>, <code id="plot.TRAMP_+3A_all.samples">all.samples</code>, <code id="plot.TRAMP_+3A_all.samples.global">all.samples.global</code></td>
<td>
<p>Controls which
enzyme/primer combinations are displayed (see Details)</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_col">col</code></td>
<td>
<p>Vector of colours to plot the different enzyme/primer
combinations.  There must be at least as many colours as there are
different combinations.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol to use (see <code><a href="graphics.html#topic+points">points</a></code> for
possible values and their interpretation).  By default, this will
use filled circles when ungrouped and filled squares when grouped.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_xmax">xmax</code></td>
<td>
<p>Maximum size (in base pairs) for the plots to cover.
<code>NULL</code> (the default) uses the range of all data found in the
<code>TRAMPsamples</code> object (rounded up to the nearest 100).
<code>NA</code> will use the range of all data in the current sample.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_horiz.lines">horiz.lines</code></td>
<td>
<p>Logical: Should horizontal grid lines be used for
each matched known?</p>
</td></tr>
</table>
<p>The following arguments control the layout and margins of the plot:
</p>
<table>
<tr><td><code id="plot.TRAMP_+3A_mar.default">mar.default</code></td>
<td>
<p>Margin size (in lines of text) to surround the
plot.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_p.top">p.top</code></td>
<td>
<p>Proportion of the plotting area to be used for the
&ldquo;matches&rdquo;.  The &ldquo;peak profiles&rdquo; will share the bottom
<code>1-p.top</code> of the plot.</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_p.labels">p.labels</code></td>
<td>
<p>Proportion of the plotting area to be used for labels
to the left of the plots.  <code>1-p.labels</code> will be used for the
plots (try increasing this if you have very long species or group
names).</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Size of the text used for axes.  If <code>NULL</code> (the
default), then the largest cex that will exactly fit labels is
chosen (up to <code>cex.axis.max</code>).</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_cex.axis.max">cex.axis.max</code></td>
<td>
<p>Maximum size of the text used for axes, if
automatically determining the label size (i.e. <code>cex.axis</code> is
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot.TRAMP_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>TRAMP.plotone</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructs a plot of a <code><a href="#topic+TRAMP">TRAMP</a></code> fit, illustrating
where knowns match the sample data, and which sample peaks remain
unmatched.
</p>
<p>The top portion of the plot displays &ldquo;matches&rdquo;, showing
how samples match the knowns.  Individual species (or groups if
<code>grouped</code> is <code>TRUE</code>) are represented by different horizontal
lines.  Where the sample matches a particular known, a symbol is drawn
(Beware: it may look like only one symbol is drawn when several
symbols are plotted on top of one another).
</p>
<p>The bottom portion of the plot displays the &ldquo;peak profile&rdquo; of
the sample, showing the locations and heights of peaks for
various enzyme/primer combinations (the exact combination depends on
the values of <code>all.knowns</code>, <code>all.samples</code> and
<code>all.samples.global</code>; see below).  The height is arbitrary, so
units are ommited.
</p>
<p>The arguments <code>all.knowns</code>, <code>all.samples</code> and
<code>all.samples.global</code> control which enzyme/primer combinations are
displayed in the plot.  <code>all.knowns=TRUE</code> displays all
combinations present in the knowns database and
<code>all.samples=TRUE</code> displays all combinations present in the
samples;  when <code>all.samples.global=TRUE</code> this is combinations
across the entire samples data set, otherwise this is samples present
in the <em>current sample</em> only.  At least one of <code>all.knowns</code>
and <code>all.samples</code> must be <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>While <code>TRAMP.plotone</code> does the actual plot, it should not be
called directly; please use <code>plot(x, sample.fk, ...)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.TRAMPknowns">plot.TRAMPknowns</a></code>, for plotting <code>TRAMPknowns</code>
objects, and <code><a href="#topic+plot.TRAMPsamples">plot.TRAMPsamples</a></code>, for plotting
<code>TRAMPsamples</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)
data(demo.knowns)
res &lt;- TRAMP(demo.samples, demo.knowns)

plot(res, 101)
plot(res, 110)
plot(res, 117)

plot(res, 117, grouped=TRUE)

## Not run: 
# Create a PDF file with all matches:
pdf("all_matches.pdf")
plot(res)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.TRAMPknowns'>Summary Plot of Knowns Data</h2><span id='topic+plot.TRAMPknowns'></span>

<h3>Description</h3>

<p>Creates a plot showing the clustering and profiles of a
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object (a &ldquo;knowns database&rdquo;).  The
plot has three vertical panels;
</p>

<ul>
<li><p> The leftmost contains a dendrogram, showing
how similar the profiles of knowns are (see
<code><a href="#topic+group.knowns">group.knowns</a></code> for details).
</p>
</li>
<li><p> The rightmost displays the TRFLP profile for each individual
(with a different colour symbol for each different enzyme/primer
combination).
</p>
</li>
<li><p> The middle panel displays information on the species names and
groups of the knowns.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMPknowns'
plot(x, cex=1, name="species", pch=1, peaks.col, p=.02,
     group.clusters=TRUE, groups.col=1:4, grid.by=5, grid.col="gray",
     widths=c(1, 2, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TRAMPknowns_+3A_x">x</code></td>
<td>
<p>A <code>TRAMPknowns</code> object.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_cex">cex</code></td>
<td>
<p>Character size for the plot.  Because knowns databases can
be large, this should be small and may need to be adjusted.  Most
aspects of the plot will scale with this.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_name">name</code></td>
<td>
<p>Column name to use when generating species names; must be
one of <code>species</code> or <code>group.name</code>.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol to use for peaks in the peak profiles.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_peaks.col">peaks.col</code></td>
<td>
<p>Vector of colours to plot the different enzymes in
the peak profiles.  These will be used in the order of the columns
of <code>summary(x)</code>.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_p">p</code></td>
<td>
<p>Scaling factor for the middle plot; this specifies the
proportion of the width that elements are spaced horizontally from
one another.  Columns of text are <code>p</code> apart, brackets grouping
knowns are <code>p/2</code> apart, and cluster groups (if present) are
<code>p*2/3</code> apart.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_group.clusters">group.clusters</code></td>
<td>
<p>Logical: Should groups of clusters (determined
by <code>group.strict</code> - see <code><a href="#topic+group.knowns">group.knowns</a></code>) be joined
together?</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_groups.col">groups.col</code></td>
<td>
<p>Vector of colours to plot different group clusters
in.  This will be recycled as neccessary.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_grid.by">grid.by</code></td>
<td>
<p>Interval between horizontal grid lines.  Grid lines
start at <code>ceiling(grid.by/2)</code> from the bottom of the plot.  A
value of <code>NA</code> suppresses grid lines.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_grid.col">grid.col</code></td>
<td>
<p>Colour of the horizontal grid lines.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_widths">widths</code></td>
<td>
<p>Relative widths of the three panels of the plot (see
<code><a href="graphics.html#topic+layout">layout</a></code>).  <code>widths</code> must be a vector of 3 elements,
corresponding to the three panels from left to right.</p>
</td></tr>
<tr><td><code id="plot.TRAMPknowns_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In general, there will probably be too many knowns to make a
legible plot when displayed on the screen.  We recommend creating a
PDF of the plot and viewing that instead (see Example).
</p>
<p>When plotted on the interactive plotting device, if the plot is
resized, the plot is likely to look strange.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group.knowns">group.knowns</a></code>, which controls the grouping of
knowns, and <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>, which constructs
<code>TRAMPknowns</code> objects.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.knowns)
plot(demo.knowns)

## Not run: 
pdf("knowns_summary.pdf", paper="default", width=8, height=11)
plot(demo.knowns)
plot(demo.knowns, group.clusters=FALSE)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.TRAMPsamples'>Plot a TRAMPsamples Object</h2><span id='topic+plot.TRAMPsamples'></span><span id='topic+TRAMPsamples.plotone'></span>

<h3>Description</h3>

<p>Shows the peak profiles of samples in a
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object, showing
the locations and heights of peaks for individual enzyme/primer
combinations.  This is the same information that is displayed in the
bottom portion of a <code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code> plot, but may be useful
where a <code><a href="#topic+TRAMP">TRAMP</a></code> fit has not been performed yet
(e.g. before a knowns database has been constructed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMPsamples'
plot(x, sample.fk, ...)
TRAMPsamples.plotone(x, sample.fk, all.samples.global=FALSE, col=1:10,
                     xmax=NULL, mar.default=.5, mar.labels=8, cex=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TRAMPsamples_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object, containing profiles to
plot.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_sample.fk">sample.fk</code></td>
<td>
<p>The <code>sample.fk</code> to plot.  If omitted, then all
samples are plotted, one after the other (this is useful for
generating a summary of all fits for printing out: see Example).</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_all.samples.global">all.samples.global</code></td>
<td>
<p>Logical: Should plots be set up for all
enzyme/primer combinations present in <code>x</code>, even if the
combinations are not present for all individual cases?  Analagous to
the same argument in <code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>.  (This is useful for
keeping combinations in the same place, and plotted with the same
colours.)</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_col">col</code></td>
<td>
<p>Vector of colours to plot the different enzyme/primer
combinations.  There must be at least as many colours as there are
different combinations.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_xmax">xmax</code></td>
<td>
<p>Maximum size (in base pairs) for the plots to cover.
<code>NULL</code> (the default) uses the range of all data found in the
<code>TRAMPsamples</code> object (rounded up to the nearest 100).
<code>NA</code> will use the range of all data in the current sample.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_mar.default">mar.default</code></td>
<td>
<p>Margin size (in lines of text) to surround the
plot.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_mar.labels">mar.labels</code></td>
<td>
<p>Number of lines of text to be used for labels to the
left of the plots.  Increase this if labels are being truncated.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_cex">cex</code></td>
<td>
<p>Scaling factor for text.</p>
</td></tr>
<tr><td><code id="plot.TRAMPsamples_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>, the plotting method for <code><a href="#topic+TRAMP">TRAMP</a></code>
objects, and <code><a href="#topic+plot.TRAMPknowns">plot.TRAMPknowns</a></code>, for
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)

plot(demo.samples, 101)
plot(demo.samples, 117)

## Not run: 
# Create a PDF file with all profiles:
pdf("all_profiles.pdf")
plot(demo.samples)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='read.abi'>Read ABI Output Files</h2><span id='topic+read.abi'></span>

<h3>Description</h3>

<p>Read an Applied Biosystems Gene Mapper (ABI) output file,
and prepare for analysis.
</p>
<p>Note that this operates on the summarised output (a text file), rather
than the <code>.fsa</code> files containing data for individual runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.abi(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.abi_+3A_file">file</code></td>
<td>
<p>The name of the file from which the data are to be read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ABI file format contains a few features that make it difficult to
interact with directly, so <code>read.abi</code> provides a wrapper around
<code><a href="utils.html#topic+read.table">read.table</a></code> to work around these.  The three issues are
(1) trailing tab characters, (2) mixed case and punctuation in column
names, and (3) parsing the  &ldquo;Dye/Sample Peak&rdquo; column.
</p>
<p>Because each line of an ABI file contains a trailing tab character
(<code>\t</code>), <code><a href="utils.html#topic+read.table">read.table</a></code> fails to read the file
correctly.  <code>read.abi</code> renames all columns so that
non-alphanumeric characters all become periods, and all uppercase
letters are converted to lower case.
</p>
<p>The column <code>Dye/Sample Peak</code> contains data of the form
<code>&lt;Dye&gt;,&lt;Sample Peak&gt;</code>, where <code>&lt;Dye&gt;</code> is a code for the dye
colour used and <code>&lt;Sample Peak&gt;</code> is an integer indicating the
order of the peaks.  Entries where the contents of <code>Dye/Sample
    Peak</code> terminates in a <code>"*"</code> character (indicating an internal
size standard) are automatically excluded from the analysis.
</p>
<p>The final column names are:
</p>

<ul>
<li> <p><code>sample.file.name</code>: Name of the file containing data.
</p>
</li>
<li> <p><code>size</code>: Size of the peak (in base pairs).
</p>
</li>
<li> <p><code>height</code>: Height of the peak (arbitrary units).
</p>
</li>
<li> <p><code>dye</code>: Code for dye used.
</p>
</li>
<li> <p><code>sample.peak</code>: Rank of peak within current sample.
</p>
</li></ul>

<p>In addition, other column names may be retained from ABI output, but
not used.
</p>


<h3>Note</h3>

<p>There is no reason that data from other types of output files could
not be manually imported using <code>TRAMPsamples</code>.  We welcome
contributions for other major data formats.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.abi">load.abi</a></code>, which attempts to construct a
<code>TRAMPsamples</code> object from an ABI file (with a bit of user
intervention).
</p>

<hr>
<h2 id='read.write'>Read/Write TRAMPknowns and TRAMPsamples Objects</h2><span id='topic+read.TRAMPknowns'></span><span id='topic+write.TRAMPknowns'></span><span id='topic+read.TRAMPsamples'></span><span id='topic+write.TRAMPsamples'></span>

<h3>Description</h3>

<p>Saves and loads <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> and
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> objects as a series of &ldquo;csv&rdquo; (comma
separated value) files for external editing.
</p>
<p>If you do not want to edit your data, then saving with
<code><a href="base.html#topic+save">save</a></code> is preferable; it is faster, creates smaller files,
and will save any additional components in the objects (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.TRAMPknowns(file.pat, auto.save=TRUE, overwrite=FALSE)
write.TRAMPknowns(x, file.pat=x$file.pat, warn=TRUE)

read.TRAMPsamples(file.pat)
write.TRAMPsamples(x, file.pat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.write_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> or <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>
object.</p>
</td></tr>
<tr><td><code id="read.write_+3A_file.pat">file.pat</code></td>
<td>
<p>Pattern, with the filename prefix: &ldquo;info&rdquo; and
&ldquo;data&rdquo; objects will be read/written as
<code>&lt;file.pat&gt;_info.csv</code> and <code>&lt;file.pat&gt;_data.csv</code>,
respectively.</p>
</td></tr>
<tr><td><code id="read.write_+3A_auto.save">auto.save</code></td>
<td>
<p>Logical: Should <code>TRAMPknowns</code> object be
automatically saved back to the loaded filename as it is modified
(e.g. knowns added to the database).  If this is <code>TRUE</code>, the
original files will be backed up as
</p>
<p><code>&lt;file.pat&gt;_(info|data)_&lt;YYYYMMDD&gt;.csv</code>,
</p>
<p>where <code>&lt;YYYYMMDD&gt;</code> is the ISO date.</p>
</td></tr>
<tr><td><code id="read.write_+3A_overwrite">overwrite</code></td>
<td>
<p>Should previous backup files be overwritten when
creating new backups?</p>
</td></tr>

<tr><td><code id="read.write_+3A_warn">warn</code></td>
<td>
<p>Should the function warn when no filename is given?
(Because this function is called automatically when adding new
knowns, and because <code>TRAMPknowns</code> objects need not contain a
<code>file.pat</code> element, it may not be possible or neccesary to
save).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>file.pat</code> may contain a path.  It is best to use forward slashes
as directory separators (<code>path/to/file</code>), but on Windows (only),
<em>double</em> backslashes will also work (<code>path\\to\\file</code>).
</p>
<p>Paths may be either relative (e.g. <code>path/to/file</code>), or absolute
(e.g. <code>/path/to/file</code>, or <code>x:/path/to/file</code> on Windows).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.abi">load.abi</a></code>, for semi-automatic loading of ABI output
files.
</p>
<p><code><a href="base.html#topic+save">save</a></code> and <code><a href="base.html#topic+load">load</a></code>, for saving and loading of
arbitrary <span class="rlang"><b>R</b></span> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preferred way of saving/loading objects, if editing is not required:
save(demo.knowns, file="my_knowns.Rdata")

# (possibly in a different session, but _after_ loading TRAMP)
load("my_knowns.Rdata") # -&gt; creates 'demo.knowns' in global environment

## End(Not run)
</code></pre>

<hr>
<h2 id='rebuild.TRAMP'>Rebuild a TRAMP Object</h2><span id='topic+rebuild.TRAMP'></span>

<h3>Description</h3>

<p>This function rebuilds a <code>TRAMP</code> object.  Typically this will be
called automatically after adding knowns (see
<code><a href="#topic+add.known">add.known</a></code>); there should be little need to call this
manually.   The same parameters that were used in the
original call to <code><a href="#topic+TRAMP">TRAMP</a></code> are used again, and these cannot
currently be modified during this call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebuild.TRAMP(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebuild.TRAMP_+3A_x">x</code></td>
<td>
<p>A <code>TRAMP</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>TRAMP</code> object, with all components recalculated.</p>

<hr>
<h2 id='remove.TRAMP.match'>Mark a TRAMP Match as Ignored</h2><span id='topic+remove.TRAMP.match'></span>

<h3>Description</h3>

<p>Mark a match in a TRAMP object as ignored; when this is
set, a match will be ignored when producing presence/absence matrices
(see <code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code>) or when plotting
(<code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>) when <code>ignore</code> is <code>TRUE</code>.
<code><a href="#topic+update.TRAMP">update.TRAMP</a></code> provides an interactive interface for doing
this, but <code>remove.TRAMP.match</code> may be useful directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.TRAMP.match(x, sample.fk, knowns.fk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.TRAMP.match_+3A_x">x</code></td>
<td>
<p>A <code>TRAMP</code> object.</p>
</td></tr>
<tr><td><code id="remove.TRAMP.match_+3A_sample.fk">sample.fk</code>, <code id="remove.TRAMP.match_+3A_knowns.fk">knowns.fk</code></td>
<td>
<p>Key of sample and known, respectively.
See <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> and <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> for
more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>TRAMP</code> object.</p>


<h3>Warning</h3>

<p>This should be regarded as experimental.  There is currently no
mechanism for restoring ignored matches, aside from recreating the
<code>TRAMP</code> object, or through editing <code>x$presence.ign</code> directly
(the format of that table is self-explanatory, but is not guaranteed
not to change between TRAMP versions).  Note that by default,
<code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code> and <code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code> will not
remove matches; you must specify <code>ignore=TRUE</code> to enable this.
</p>


<h3>Note</h3>

<p>This function returns a modified object - the <code>TRAMP</code> object is
not modified in place.  You must do:
</p>
<p><code>x &lt;- remove.TRAMP.match(x, sample.fk, knowns.fk)</code>
</p>
<p>to mark a match as ignored in the object <code>x</code>.
</p>

<hr>
<h2 id='summary.TRAMP'>Create Presence/Absence Matrices from TRAMP Objects</h2><span id='topic+summary.TRAMP'></span>

<h3>Description</h3>

<p>Generate a summary of a <code>TRAMP</code> object, by producing a
presence/absence matrix.  This is the preferred way of extracting the
presence/absence matrix from a  <code>TRAMP</code> object, and allows for
grouping, naming knowns, and ignoring matches (specified by
<code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMP'
summary(object, name=FALSE, grouped=FALSE, ignore=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.TRAMP_+3A_object">object</code></td>
<td>
<p>A <code>TRAMP</code> object.</p>
</td></tr>
<tr><td><code id="summary.TRAMP_+3A_name">name</code></td>
<td>
<p>Logical: Should the knowns be named?</p>
</td></tr>
<tr><td><code id="summary.TRAMP_+3A_grouped">grouped</code></td>
<td>
<p>Logical: Should the knowns be grouped?</p>
</td></tr>
<tr><td><code id="summary.TRAMP_+3A_ignore">ignore</code></td>
<td>
<p>Logical: Should matches marked as ignored be excluded?</p>
</td></tr>
<tr><td><code id="summary.TRAMP_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A presence/absence matrix, with samples as rows
and knowns as columns.  If <code>name</code> is <code>TRUE</code>, then names of
knowns (or groups of knowns) are used, otherwise the <code>knowns.fk</code>
is used (<code>group.strict</code> if grouped).  If <code>grouped</code> is
<code>TRUE</code>, then the knowns are collapsed by group (using
<code>group.strict</code>; see <code><a href="#topic+group.knowns">group.knowns</a></code>).  A group is
present if <em>any</em> of the knowns belonging to it are present.  If
<code>ignore</code> is <code>TRUE</code>, then any matches marked by
<code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code> are excluded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.knowns)
data(demo.samples)
res &lt;- TRAMP(demo.samples, demo.knowns)

head(summary(res))
head(summary(res, name=TRUE))
head(summary(res, name=TRUE, grouped=TRUE))

## Extract the species richness for each sample (i.e. the number of
## knowns present in each sample)
rowSums(summary(res, grouped=TRUE))

## Extract species frequencies and plot a rank abundance diagram:
## (i.e. the number of times each known was recorded)
sp.freq &lt;- colSums(summary(res, name=TRUE, grouped=TRUE))

sp.freq &lt;- sort(sp.freq[sp.freq &gt; 0], decreasing=TRUE)
plot(sp.freq, xlab="Species rank", ylab="Species frequency", log="y")
text(1:2, sp.freq[1:2], names(sp.freq[1:2]), cex=.7, pos=4, font=3)
</code></pre>

<hr>
<h2 id='TRAMP'>TRFLP Analysis and Matching Program</h2><span id='topic+TRAMP'></span>

<h3>Description</h3>

<p>Determine if TRFLP profiles may match those in a database
of knowns.  The resulting object can be used to produce a
presence/absence matrix of known profiles in environmental samples.
</p>
<p>The <code>TRAMPR</code> package contains a vignette, which includes a worked
example; type <code>vignette("TRAMPRdemo")</code> to view it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRAMP(samples, knowns, accept.error=1.5, min.comb=4, method="maximum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRAMP_+3A_samples">samples</code></td>
<td>
<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> object, containing
unidentified samples.</p>
</td></tr>
<tr><td><code id="TRAMP_+3A_knowns">knowns</code></td>
<td>
<p>A <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object, containing
identified TRFLP patterns.</p>
</td></tr>
<tr><td><code id="TRAMP_+3A_accept.error">accept.error</code></td>
<td>
<p>The largest acceptable difference (in base pairs)
between any peak in the sample data and the knowns database (see
Details; interpretation will depend on the value of <code>method</code>).</p>
</td></tr>
<tr><td><code id="TRAMP_+3A_min.comb">min.comb</code></td>
<td>
<p>Minimum number of enzyme/primer combinations required
before presence will be tested.  The default (4) should be
reasonable in most cases.  Setting <code>min.comb</code> to <code>NA</code> will
require that all enzyme/primer combinations in the knowns database
are present in the samples.</p>
</td></tr>
<tr><td><code id="TRAMP_+3A_method">method</code></td>
<td>
<p>Method used in calculating the difference between
samples and knowns; may be one of <code>"maximum"</code>,
<code>"euclidian"</code> or <code>"manhattan"</code> (or any unambiguous
abbreviation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TRAMP</code> attempts to determine which species in the
&lsquo;knowns&rsquo; database <em>may</em> be present in a collection of
samples.
</p>
<p>A sample matches a known if it has a peak that is &ldquo;close
enough&rdquo; to every peak in the known for every enzyme/primer
combination that they share.  The default is to accept matches where
the largest distance between a peak in the knowns database and the
sample is less than <code>accept.error</code> base pairs (default 2), and
where at least <code>min.comb</code> enzyme/primer combinations are shared
between a sample and a known (default 4).
</p>
<p>The three-dimensional matrix of match errors is generated by
<code><a href="#topic+create.diffsmatrix">create.diffsmatrix</a></code>.  In the resulting array,
<code>m[i,j,k]</code> is the difference (in base pairs) between the
<code>i</code>th sample and the <code>j</code>th known for the <code>k</code>th
enzyme/primer combination.
</p>
<p>If <code class="reqn">p_k</code> and <code class="reqn">q_k</code> are the sizes of peaks for the <code class="reqn">k</code>th
enzyme/primer combination for a sample and known (respectively), then
maximum distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">\max(|p_k - q_k|)</code>
</p>

<p>Euclidian distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sqrt{\sum (p_k - q_k)^2}</code>
</p>

<p>and Manhattan distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum{|p_k - q_k|}</code>
</p>

<p>where <code class="reqn">n</code> is the number of shared enzyme/primer combinations,
since this may vary across sample/known combinations.  For Euclidian
and Manhattan distances, <code>accept.error</code> then becomes the
<em>mean</em> distance, rather than the total distance.
</p>


<h3>Value</h3>

<p>A <code>TRAMP</code> object, with elements:
</p>
<table>
<tr><td><code>presence</code></td>
<td>
<p>Presence/absence matrix.  Rows are different samples
(with rownames from <code>labels(samples)</code>) and columns are
different knowns (with colnames from <code>labels(knowns)</code>).  Do not
access the presence/absence matrix directly, but use
<code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code>, which provides options for labelling
knowns, grouping knowns, and excluding &ldquo;ignored&rdquo; matches.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>Matrix of distances between the samples and known,
calculated by one of the methods described above.  Rows correspond
to different samples, and columns correspond to different knowns.
The matrix dimension names are set to the values <code>sample.pk</code>
and <code>knowns.pk</code> for the samples and knowns, respectively.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>A two-dimensional matrix (same dimensions as <code>error</code>),
recording the number of enzyme/primer combinations present for each
combination of samples and knowns.</p>
</td></tr>
<tr><td><code>diffsmatrix</code></td>
<td>
<p>Three-dimensional array of output from
<code><a href="#topic+create.diffsmatrix">create.diffsmatrix</a></code>.</p>
</td></tr>
<tr><td><code>enzyme.primer</code></td>
<td>
<p>Different enzyme/primer combinations present in
the data, in the order of the third dimension of <code>diffsmatrix</code>
(see <code><a href="#topic+create.diffsmatrix">create.diffsmatrix</a></code> for details).</p>
</td></tr>
<tr><td><code>samples</code>, <code>knowns</code>, <code>accept.error</code>, <code>min.comb</code>, <code>method</code></td>
<td>
<p>The input data
objects and arguments, unmodified.</p>
</td></tr>
</table>
<p>In addition, an element <code>presence.ign</code> is included to allow
matches to be ignored.  However, this interface is experimental and
its current format should not be relied on - use
<code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code> rather than interacting directly with
<code>presence.ign</code>.
</p>
<p>Matching is based only on peak size (in base pairs), and does not
consider peak heights.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+create.diffsmatrix">create.diffsmatrix</a></code> for discussion of how differences
between sample and known profiles are generated.
</p>
<p><code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>, which displays TRAMP fits graphically.
</p>
<p><code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code>, which creates a presence/absence matrix.
</p>
<p><code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code>, which marks TRAMP matches as
ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.knowns)
data(demo.samples)

res &lt;- TRAMP(demo.samples, demo.knowns)

## The resulting object can be interrogated with methods:

## The goodness of fit of the sample with sample.pk=101 (see
## ?\link{plot.TRAMP}).
plot(res, 101)

## Not run: 
## To see all plots (this produces many figures), one after another.
op &lt;- par(ask=TRUE)
plot(res)
par(op)

## End(Not run)

## Produce a presence/absence matrix (see ?\link{summary.TRAMP}).
m &lt;- summary(res)
head(m)
</code></pre>

<hr>
<h2 id='TRAMPindexing'>Index (Subset) TRAMPsamples and TRAMPknowns Objects</h2><span id='topic+TRAMPindexing'></span><span id='topic++5B.TRAMPknowns'></span><span id='topic++5B.TRAMPsamples'></span>

<h3>Description</h3>

<p>This provides very basic support for subsetting
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> and <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMPknowns'
x[i, na.interp=TRUE, ...]
## S3 method for class 'TRAMPsamples'
x[i, na.interp=TRUE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRAMPindexing_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> or <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>
object.</p>
</td></tr>
<tr><td><code id="TRAMPindexing_+3A_i">i</code></td>
<td>
<p>A vector of <code>sample.fk</code> or <code>knowns.fk</code> values.  For
valid values, use <code>labels(x)</code>.  If any index values are not
present in <code>x</code>, then an error will be raised.  Alternatively,
this may be a logical vector, of the same length as the number of
samples or knowns in <code>x</code>.  See Examples for use of this.
</p>
</td></tr>
<tr><td><code id="TRAMPindexing_+3A_na.interp">na.interp</code></td>
<td>
<p>Logical: Controls how <code>NA</code> values should be
interpreted when <code>i</code> is a logical vector.</p>
</td></tr>
<tr><td><code id="TRAMPindexing_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When indexing by logical vectors, <code>NA</code> values do not make valid
indexes, but may be produced when testing columns that contain missing
values, so these must be converted to either <code>TRUE</code> or
<code>FALSE</code>. If <code>i</code> is a logical index that contains missing
values (<code>NA</code>s), then <code>na.interp</code> controls how they will be
interpreted:
</p>

<ul>
<li><p> If <code>na.interp=TRUE</code>, then
<code>TRUE, FALSE, NA</code> becomes <code>TRUE, FALSE, TRUE</code>.
</p>
</li>
<li><p> If <code>na.interp=FALSE</code>, then
<code>TRUE, FALSE, NA</code> becomes <code>TRUE, FALSE, FALSE</code>.
</p>
</li></ul>



<h3>Warning</h3>

<p>For <code>TRAMPknowns</code> objects, if the <code>file.pat</code> element is
specified as part of the object (see <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>), then
the subsetted <code>TRAMPknowns</code> object will be written to a file.
This may not be what you want, so it is probably best to disable
knowns writing by doing <code>x$file.pat &lt;- NULL</code> before doing any
subsetting (where <code>x</code> is the name of your <code>TRAMPknowns</code>
object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.samples)
data(demo.knowns)

## Subsetting by sample.fk values
labels(demo.samples)
demo.samples[c(101, 102, 110)]
labels(demo.samples[c(101, 102, 110)])

## Take just samples from the first 10 soilcores:
demo.samples[demo.samples$info$soilcore.fk &lt;= 10]

## Indexing also works on TRAMPknowns:
demo.knowns[733]
labels(demo.knowns[733])
</code></pre>

<hr>
<h2 id='TRAMPknowns'>TRAMPknowns Objects</h2><span id='topic+TRAMPknowns'></span><span id='topic+labels.TRAMPknowns'></span><span id='topic+summary.TRAMPknowns'></span>

<h3>Description</h3>

<p>These functions create and interact with
<code>TRAMPknowns</code> objects (collections of known TRFLP
patterns).  Knowns contrast with &ldquo;samples&rdquo; (see
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>) in that knowns contain identified
profiles, while samples contain unidentified profiles.  Knows must
have at most one peak per enzyme/primer combination (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRAMPknowns(data, info, cluster.pars=list(), file.pat=NULL,
            warn.factors=TRUE, ...)


## S3 method for class 'TRAMPknowns'
labels(object, ...)
## S3 method for class 'TRAMPknowns'
summary(object, include.info=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRAMPknowns_+3A_data">data</code></td>
<td>
<p>data.frame containing peak information.</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_info">info</code></td>
<td>
<p>data.frame, describing individual samples (see Details for
definitions of both data.frames).</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_cluster.pars">cluster.pars</code></td>
<td>
<p>Parameters used when clustering the knowns
database.  See Details.</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_file.pat">file.pat</code></td>
<td>
<p>Optional partial filename in which to store knowns
database after modification.  Files <code>&lt;file.pat&gt;_info.csv</code>
and <code>&lt;file.pat&gt;_data.csv</code> will be created.</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_warn.factors">warn.factors</code></td>
<td>
<p>Logical: Should a warning be given if any columns
in <code>info</code> or <code>data</code> are converted into factors?</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_object">object</code></td>
<td>
<p>A <code>TRAMPknowns</code> object.</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_include.info">include.info</code></td>
<td>
<p>Logical: Should the output be augmented with the
contents of the <code>info</code> component of the <code>TRAMPknowns</code>
object?</p>
</td></tr>
<tr><td><code id="TRAMPknowns_+3A_...">...</code></td>
<td>
<p><code>TRAMPknowns</code>: Additional objects to incorportate
into a <code>TRAMPknowns</code> object.  Other methods: Further arguments
passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object has at least two components, which relate to each other (in
the sense of a relational database).  <code>info</code> holds information
about the individual samples, and <code>data</code> holds information about
individual peaks (many of which may belong to a single sample).
</p>
<p>Column definitions:
</p>

<ul>
<li> <p><code>info</code>:
</p>

<dl>
<dt><code>knowns.pk</code>:</dt><dd><p>Unique positive integer, used to identify
individual knowns (i.e. a &ldquo;primary key&rdquo;).</p>
</dd>
<dt><code>species</code>:</dt><dd><p>Character, giving species name.</p>
</dd>
</dl>

</li>
<li> <p><code>data</code>:
</p>

<dl>
<dt><code>knowns.fk</code>:</dt><dd><p>Positive integer, indicating which sample
the peak belongs to (by matching against <code>info$knowns.pk</code>)
(i.e. a &ldquo;foreign key&rdquo;).</p>
</dd>
<dt><code>primer</code>:</dt><dd><p>Character, giving the name of the primer
used.</p>
</dd>
<dt><code>enzyme</code>:</dt><dd><p>Character, giving the name of the
restriction digest enzyme used.</p>
</dd>
<dt><code>size</code>:</dt><dd><p>Numeric, giving size (in base pairs) of the
peak.</p>
</dd>
</dl>

</li></ul>

<p>In addition, <code>TRAMPknowns</code> will create additional columns holding
clustering information (see <code><a href="#topic+group.knowns">group.knowns</a></code>).  Additional
columns are allowed (and retained, but ignored) in both data.frames.
Additional objects are allowed as part of the <code>TRAMPknowns</code>
object, but these will not be written by
<code><a href="#topic+write.TRAMPknowns">write.TRAMPknowns</a></code>; any extra objects passed (via
<code>...</code>) will be included in the final <code>TRAMPknowns</code> object.
</p>
<p>The <code>cluster.pars</code> argument controls how knowns will be clustered
(this will happen automatically as needed).  Elements of the list
<code>cluster.pars</code> may be any of the three arguments to
<code><a href="#topic+group.knowns">group.knowns</a></code>, and will be used as defaults in
subsequent calls to <code>group.knowns</code>.  If not provided, default
values are: <code>dist.method="maximum"</code>,
<code>hclust.method="complete"</code>, <code>cut.height=2.5</code> (if only some
elements of <code>cluster.pars</code> are provided, the remaining elements
default to the values above).  To change values of clustering
parameters in an existing <code>TRAMPknowns</code> object, use
<code><a href="#topic+group.knowns">group.knowns</a></code>.
</p>
<p>A known contains at most one peak per enzyme/primer combination.
Where a species is known to have multiple TRFLP profiles, these should
be treated as separate knowns with different, unique, <code>knowns.pk</code>
values, but with identical <code>species</code> values.  A sample containing
either pattern will then be recorded as having that species present
(see <code><a href="#topic+group.knowns">group.knowns</a></code>).
</p>


<h3>Value</h3>

<table>
<tr><td><code>TRAMPknowns</code></td>
<td>
<p>A new <code>TRAMPknowns</code> object: a list with
components <code>info</code>, <code>data</code> (the provided data.frames, with
clustering information added to <code>info</code>), <code>cluster.pars</code>
and <code>file.pat</code>, plus any extra objects passed as <code>...</code>.</p>
</td></tr>
<tr><td><code>labels.TRAMPknowns</code></td>
<td>
<p>A sorted vector of the unique samples
present in <code>x</code> (from <code>info$knowns.pk</code>).</p>
</td></tr>
<tr><td><code>summary.TRAMPknowns</code></td>
<td>
<p>A data.frame, with the size of the peak (if
present) for each enzyme/primer combination, with each known
(indicated by <code>knowns.pk</code>) as rows and each combination (in the
format <code>&lt;primer&gt;_&lt;enzyme&gt;</code>) as columns.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Across a <code>TRAMPknowns</code> object, primer and enzyme names must be
<em>exactly</em> the same (including case and whitespace) to be
considered the same.  For example <code>"ITS4"</code>, <code>"Its4"</code>,
<code>"ITS 4"</code> and <code>"ITS4 "</code> would be considered to be four
different primers.
</p>
<p>Factors will not merge correctly (with
<code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code> or <code><a href="#topic+add.known">add.known</a></code>).
<code>TRAMPknowns</code> will attempt to catch factor columns and convert
them into characters for the <code>info</code> and <code>data</code> data.frames.
Other objects (passed as part of <code>...</code>) will not be altered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>, which constructs an analagous object to
hold &ldquo;samples&rdquo; data.
</p>
<p><code><a href="#topic+plot.TRAMPknowns">plot.TRAMPknowns</a></code>, which creates a graphical
representation of the knowns data.
</p>
<p><code><a href="#topic+TRAMP">TRAMP</a></code>, for matching unknown TRFLP patterns to
<code>TRAMPknowns</code> objects.
</p>
<p><code><a href="#topic+group.knowns">group.knowns</a></code>, which groups similar knowns (generally
called automatically).
</p>
<p><code><a href="#topic+add.known">add.known</a></code> and <code><a href="#topic+combine.TRAMPknowns">combine.TRAMPknowns</a></code>, which
provide tools for adding knowns from a sample data set and merging
knowns databases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example builds a TRAMPknowns object from completely artificial
## data:

## The info data.frame:
knowns.info &lt;-
  data.frame(knowns.pk=1:8,
             species=rep(paste("Species", letters[1:5]), length=8))
knowns.info

## The data data.frame:
knowns.data &lt;- expand.grid(knowns.fk=1:8,
                           primer=c("ITS1F", "ITS4"),
                           enzyme=c("BsuRI", "HpyCH4IV"))
knowns.data$size &lt;- runif(nrow(knowns.data), min=40, max=800)

## Construct the TRAMPknowns object:
demo.knowns &lt;- TRAMPknowns(knowns.data, knowns.info, warn.factors=FALSE)

## A plot of the pretend knowns:
plot(demo.knowns, cex=1, group.clusters=TRUE)
</code></pre>

<hr>
<h2 id='TRAMPR-package'>The TRAMPR Package (TRFLP Analysis and Matching Package for R)</h2><span id='topic+TRAMPR-package'></span><span id='topic+TRAMPR'></span>

<h3>Description</h3>

<p>This package contains a collection of functions to help
analyse terminal restriction fragment length polymorphism (TRFLP)
profiles, by matching unknown peaks to known TRFLP profiles in order
to identify species.
</p>
<p>The <code>TRAMPR</code> package contains a vignette, which includes a worked
example; type <code>vignette("TRAMPRdemo")</code> to view it.  To see all
documented help topics, type <code>library(help=TRAMPR)</code>.
</p>


<h3>Details</h3>

<p>Start by reading the <code><a href="#topic+TRAMP">TRAMP</a></code> (and perhaps
<code><a href="#topic+create.diffsmatrix">create.diffsmatrix</a></code>) help pages, which explain the
matching algorithm.
</p>
<p>Then read <code><a href="#topic+load.abi">load.abi</a></code> to learn how to load ABI format data
into the program.  Alternatively, read <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> and
<code><a href="#topic+read.TRAMPsamples">read.TRAMPsamples</a></code> to load already-processed data.
</p>
<p>If you already have a collection of knowns, read
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> and <code><a href="#topic+read.TRAMPknowns">read.TRAMPknowns</a></code> to learn
how to load them.  Otherwise, read <code><a href="#topic+build.knowns">build.knowns</a></code> to learn
how to automatically generate a set of known profiles from your data.
</p>
<p>Once your data are loaded, reread <code><a href="#topic+TRAMP">TRAMP</a></code> to do the
analysis, then read <code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code> and
<code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code> to examine the analysis.
<code><a href="#topic+update.TRAMP">update.TRAMP</a></code> may also be useful for modifying your
matches.  <code><a href="#topic+summary.TRAMP">summary.TRAMP</a></code> is also useful for preparing
presence/absence matrices for analysis with other tools (e.g. the
<span class="pkg">vegan</span> package; see the vignette indicated below).
</p>
<p><span class="pkg">TRAMPR</span> works with database-like objects, and a basic
understanding of relational databases and primary/foreign keys will
aid in understanding some aspects of the package.
</p>


<h3>Citation</h3>

<p>Please see <code>citation("TRAMPR")</code> for the citation of
<code>TRAMPR</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">TRAMPR</span> is designed specifically for &ldquo;database TRFLP&rdquo;
(identifying species based on a database of known TRFLP profiles: see
Dicke et al. 2002.  It is not designed for direct community analysis
of TRFLP profiles as in peak-profile TRFLP.
</p>


<h3>Author(s)</h3>

<p>Rich FitzJohn and Ian Dickie, Landcare Research
</p>


<h3>References</h3>

<p>Dicke IA, FitzJohn RG 2007: Using terminal-restriction fragment length
polymorphism (T-RFLP) to identify mycorrhizal fungi; a methods
review. Mycorrhiza 17: 259-270.
</p>
<p>Dickie IA, Xu B, Koide RT 2002.  Vertical distribution of
ectomycorrhizal hyphae in soil as shown by T-RFLP analysis.  New
Phytologist 156: 527-535.
</p>
<p>FitzJohn RG, Dickie IA 2007: TRAMPR: An R package for analysis and
matching of terminal-restriction fragment length polymorphism (TRFLP)
profiles.  Molecular Ecology Notes
[doi:10.1111/j.1471-8286.2007.01744.x].
</p>

<hr>
<h2 id='TRAMPsamples'>TRAMPsamples Objects</h2><span id='topic+TRAMPsamples'></span><span id='topic+labels.TRAMPsamples'></span><span id='topic+summary.TRAMPsamples'></span>

<h3>Description</h3>

<p>These functions create and interact with
<code>TRAMPsamples</code> objects (collections of TRFLP patterns).  Samples
contrast with &ldquo;knowns&rdquo; (see <code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>) in that
samples contain primarily unidentified profiles.  In contrast with
knowns, samples may have many peaks per enzyme/primer combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRAMPsamples(data, info=NULL, warn.factors=TRUE, ...)

## S3 method for class 'TRAMPsamples'
labels(object, ...)
## S3 method for class 'TRAMPsamples'
summary(object, include.info=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRAMPsamples_+3A_data">data</code></td>
<td>
<p>data.frame containing peak information.</p>
</td></tr>
<tr><td><code id="TRAMPsamples_+3A_info">info</code></td>
<td>
<p>(Optional) data.frame, describing individual samples (see
Details for definitions of both data.frames).  If this is omitted,
a basic data.frame will be generated.</p>
</td></tr>
<tr><td><code id="TRAMPsamples_+3A_warn.factors">warn.factors</code></td>
<td>
<p>Logical: Should a warning be given if any columns
in <code>info</code> or <code>data</code> are converted into factors?</p>
</td></tr>
<tr><td><code id="TRAMPsamples_+3A_object">object</code></td>
<td>
<p>A <code>TRAMPsamples</code> object.</p>
</td></tr>
<tr><td><code id="TRAMPsamples_+3A_include.info">include.info</code></td>
<td>
<p>Logical: Should the output be augmented with the
contents of the <code>info</code> component of the <code>TRAMPsamples</code>
object?</p>
</td></tr>
<tr><td><code id="TRAMPsamples_+3A_...">...</code></td>
<td>
<p><code>TRAMPsamples</code>: Additional objects to incorportate
into a <code>TRAMPsamples</code> object.  Other methods: Further arguments
passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object has at least two components, which relate to each other (in
the sense of a relational database). <code>info</code> holds information
about the individual samples, and <code>data</code> holds information about
individual peaks (many of which belong to a single sample).
</p>
<p>Column definitions:
</p>

<ul>
<li> <p><code>info</code>:
</p>

<dl>
<dt><code>sample.pk</code></dt><dd><p>Unique positive integer, used to identify
individual samples (i.e. a &ldquo;primary key&rdquo;).</p>
</dd>
<dt><code>species</code></dt><dd><p>Character, giving species name if samples
were collected from an identified species.  If this column is
missing, it will be initialised as <code>NA</code>.</p>
</dd>
</dl>

</li>
<li> <p><code>data</code>:
</p>

<dl>
<dt><code>sample.fk</code></dt><dd><p>Positive integer, indicating which sample
the peak belongs to (by matching against <code>info$sample.pk</code>)
(i.e. a &ldquo;foreign key&rdquo;).</p>
</dd>
<dt><code>primer</code>:</dt><dd><p>Character, giving the name of the primer
used.</p>
</dd>
<dt><code>enzyme</code>:</dt><dd><p>Character, giving the name of the
restriction digest enzyme used.</p>
</dd>
<dt><code>size</code></dt><dd><p>Numeric, giving size (in base pairs) of the
peak.</p>
</dd>
<dt><code>height</code></dt><dd><p>Numeric, giving the height (arbitrary units)
of the peak.</p>
</dd>
</dl>

</li></ul>

<p>Additional columns are allowed (and ignored) in both data.frames, and
will be retained.  This allows notes on data quality and treatments to
be easily included.  Additional objects are allowed as part of the
<code>TRAMPsamples</code> object; any extra objects passed (via
<code>...</code>) will be included in the final <code>TRAMPsamples</code> object.
</p>
<p>If <code>info</code> is omitted, then a basic data.frame will be generated,
containing just the unique values of <code>sample.fk</code>, and
<code>NA</code> for <code>species</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>TRAMPsamples</code></td>
<td>
<p>A new <code>TRAMPsamples</code> object, as described
above.</p>
</td></tr>
<tr><td><code>labels.TRAMPsamples</code></td>
<td>
<p>A sorted vector of the unique samples
present in <code>x</code> (from <code>info$sample.pk</code>).</p>
</td></tr>
<tr><td><code>summary.TRAMPsamples</code></td>
<td>
<p>A data.frame, with the number of peaks
per enzyme/primer combination, with each sample (indicated by
<code>sample.pk</code>) as rows and each combination (in the format
<code>&lt;primer&gt;_&lt;enzyme&gt;</code>) as columns.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Across a <code>TRAMPsamples</code> object, primer and enzyme names must be
<em>exactly</em> the same (including case and whitespace) to be
considered the same.  For example <code>"ITS4"</code>, <code>"Its4"</code>,
<code>"ITS4 "</code> and <code>"ITS 4"</code> would be considered to be four
different primers.
</p>
<p>Factors will not merge correctly (with
<code><a href="#topic+combine.TRAMPsamples">combine.TRAMPsamples</a></code>).  <code>TRAMPsamples</code> will attempt
to catch factor columns and convert them into characters for the
<code>info</code> and <code>data</code> data.frames.  Other objects (passed as
part of <code>...</code>) will not be altered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.TRAMPsamples">plot.TRAMPsamples</a></code> and
<code><a href="#topic+summary.TRAMPsamples">summary.TRAMPsamples</a></code>, for plotting and summarising
<code>TRAMPsamples</code> objects.
</p>
<p><code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code>, which constructs an analagous object to
hold &ldquo;knowns&rdquo; data.
</p>
<p><code><a href="#topic+TRAMP">TRAMP</a></code>, for analysing <code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code>
objects.
</p>
<p><code><a href="#topic+load.abi">load.abi</a></code>, which creates a <code>TRAMPsamples</code> object
from Gene Mapper (Applied Biosystems) output.
</p>

<hr>
<h2 id='update.TRAMP'>Interactively Alter a TRAMP Object</h2><span id='topic+update.TRAMP'></span>

<h3>Description</h3>

<p>This function allows some manual checking and correction of
a <code><a href="#topic+TRAMP">TRAMP</a></code> object.  By default, it steps through each
sample, and offers to (1) add a new known to the
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> database within the <code>TRAMP</code> object (see
<code><a href="#topic+add.known">add.known</a></code> for details), (2) mark matches to be ignored
in future calls to <code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code> (see
<code><a href="#topic+remove.TRAMP.match">remove.TRAMP.match</a></code>), (3) save the current plot as a
PDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TRAMP'
update(object, sample.fk=labels(object$samples), grouped=FALSE,
       ignore=TRUE, delay.rebuild=FALSE, default.species=NULL,
       filename.fmt="TRAMP_%d.pdf", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.TRAMP_+3A_object">object</code></td>
<td>
<p>A <code>TRAMP</code> object.</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_sample.fk">sample.fk</code></td>
<td>
<p>A vector of <code>sample.fk</code> to cycle through.  If
omitted, this will default to all samples present in the
<code><a href="#topic+TRAMPsamples">TRAMPsamples</a></code> component of the <code>TRAMP</code> object.</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_grouped">grouped</code>, <code id="update.TRAMP_+3A_ignore">ignore</code></td>
<td>
<p>Plotting parameters, as in
<code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>.  Currently these cannot be altered from
their default values.</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_delay.rebuild">delay.rebuild</code></td>
<td>
<p>Logical: Should the rebuild of the <code>TRAMP</code>
object be delayed until the function returns?  If this is
<code>FALSE</code> (the default), then the <code>TRAMP</code> object will
rebuild every time a new known is added.  This may take a while for
large objects, so if set to <code>TRUE</code>, then the <code>TRAMP</code>
object will not be rebuilt until all <code>sample.fk</code>s have been
displayed.  This means that any new samples added as knowns will not
be included in plots.</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_default.species">default.species</code></td>
<td>
<p>Default species name for newly added knowns.
Passed to <code><a href="#topic+add.known">add.known</a></code>.</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_filename.fmt">filename.fmt</code></td>
<td>
<p>Format used to generate filenames when saving
PDFs.  Include a <code>"%d"</code> to stand in for the <code>sample.fk</code>
(so <code>"TRAMP_%d.pdf"</code> becomes <code>"TRAMP_12.pdf"</code> for
<code>sample.fk</code> 12).</p>
</td></tr>
<tr><td><code id="update.TRAMP_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plotting function
<code><a href="#topic+plot.TRAMP">plot.TRAMP</a></code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If an error occurs while running <code>update</code>, all modifications will
be lost.
</p>


<h3>Note</h3>

<p><code>update.TRAMP</code> returns a modified <code>TRAMP</code> object, and does
not modify the original <code>TRAMP</code> object in place.  You must use it
like:
</p>
<p><code>x &lt;- update(x)</code>
</p>
<p>or
</p>
<p><code>x2 &lt;- update(x)</code>
</p>
<p>to modify the original object or create a new, modified object in
place.  Note that if creating mutiple objects, if the
<code><a href="#topic+TRAMPknowns">TRAMPknowns</a></code> object has a <code>file.pat</code> element, then
any changes to either of <code>x</code> or <code>x2</code> will be written back to
file, but the knowns contained in <code>x</code> and <code>x2</code> may be
different.  See the note in <code><a href="#topic+add.known">add.known</a></code>.
</p>
<p>The action &ldquo;Quit&rdquo; will always exit the <code>update</code> function and
save the object.
</p>
<p>Be careful when using a <code>TRAMP</code> object whose <code>TRAMPknowns</code>
element has a <code>file.pat</code> element; new knowns added will be
immediately written to file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Since this function runs interactively, there can be no sample.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
