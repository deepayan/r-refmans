<!DOCTYPE html><html><head><title>Help for package spNNGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spNNGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BCEF'><p>Forest Canopy Height from NASA Goddard's LiDAR Hyperspectral and</p>
Thermal (G-LiHT) over Bonanza Creek Experimental Forest</a></li>
<li><a href='#MI_TSCA'><p>Occurrence of Tsuga canadensis (Eastern hemlock) in Michigan</p></a></li>
<li><a href='#PGLogit'><p>Function for Fitting Logistic Models using Polya-Gamma Latent Variables</p></a></li>
<li><a href='#predict.NNGP'><p>Function for prediction at new locations using <code>NNGP</code> models.</p></a></li>
<li><a href='#print.spDiag'><p>Methods for spDiag Object</p></a></li>
<li><a href='#spConjNNGP'><p>Function for Fitting Univariate Bayesian Conjugate Spatial</p>
Regression Models</a></li>
<li><a href='#spDiag'><p>Model fit diagnostics</p></a></li>
<li><a href='#spNNGP'><p>Function for Fitting Univariate Bayesian Spatial Regression</p>
Models</a></li>
<li><a href='#summary.NNGP'><p>Methods for NNGP and Derived Objects</p></a></li>
<li><a href='#summary.PGLogit'><p>Methods for PGLogit Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Regression Models for Large Datasets using Nearest
Neighbor Gaussian Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Finley &lt;finleya@msu.edu&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Finley [aut, cre],
  Abhirup Datta [aut],
  Sudipto Banerjee [aut]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), coda, Formula, RANN</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits univariate Bayesian spatial regression models for large datasets using Nearest Neighbor Gaussian Processes (NNGP) detailed in Finley, Datta, Banerjee (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v103.i05">doi:10.18637/jss.v103.i05</a>&gt;, Finley, Datta, Cook, Morton, Andersen, and Banerjee (2019) &lt;<a href="https://doi.org/10.1080%2F10618600.2018.1537924">doi:10.1080/10618600.2018.1537924</a>&gt;, and Datta, Banerjee, Finley, and Gelfand (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1044091">doi:10.1080/01621459.2015.1044091</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.finley-lab.com/">https://www.finley-lab.com/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-27 13:42:51 UTC; andy</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-27 15:00:05 UTC</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
</table>
<hr>
<h2 id='BCEF'>Forest Canopy Height from NASA Goddard's LiDAR Hyperspectral and
Thermal (G-LiHT) over Bonanza Creek Experimental Forest</h2><span id='topic+BCEF'></span>

<h3>Description</h3>

<p>Forest canopy height (FCH) estimates from NASA Goddard's LiDAR Hyperspectral and
Thermal (G-LiHT; Cook et al. 2013) Airborne Imager and percent tree
cover (Hansen et al. 2013) over a subset of
Bonanza Creek Experimental Forest, AK, collected in Summer 2014.
</p>
<p>The <code>BCEF</code> matrix columns are longitude (x), latitude (y), forest
canopy height (FCH) in meters from ground, and Landsat derived percent tree cover
(PTC) for 188,717 observations.  Longitude and latitude are
in Albers Equal Area (proj4string
&quot;+proj=aea +lat_1=55 +lat_2=65 +lat_0=50 +lon_0=-154 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=km +no_defs&quot;). The last column (holdout) identifies a subset of data useful for assessing wall-to-wall predictive performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BCEF)
</code></pre>


<h3>Format</h3>

<p>A matrix containing 188,717 rows and 6 columns named longitude,
latitude, FCH, PTC, and holdout. 
</p>


<h3>Source</h3>

<p>G-LiHT data were downloaded from <a href="https://gliht.gsfc.nasa.gov">https://gliht.gsfc.nasa.gov</a>.</p>


<h3>References</h3>

<p>Cook, B.D., L.W. Corp, R.F. Nelson, E.M. Middleton, D.C. Morton,
J.T. McCorkel, J.G. Masek, K.J. Ranson, and V. Ly. (2013) NASA Goddard's
Lidar, Hyperspectral and Thermal (G-LiHT) airborne imager. Remote
Sensing 5:4045-4066.
</p>
<p>Hansen, M.C., Potapov, P.V., Moore, R., Hancher, M., Turubanova,
S.A., Tyukavina, A.,Thau, D., Stehman, S.V., Goetz, S.J., Loveland,
T.R., Kommareddy, A., Egorov, A., Chini, L., Justice, C.O., and
Townshend, J.R.G. (2013), High-Resolution Global Mapsof 21st-Century
Forest Cover Change, Science, 342, 850-853.
</p>

<hr>
<h2 id='MI_TSCA'>Occurrence of Tsuga canadensis (Eastern hemlock) in Michigan</h2><span id='topic+MI_TSCA'></span>

<h3>Description</h3>

<p>Eastern hemlock (<em>Tsuga canadensis L.</em>) analyzed in
Lany et al. (2019). The date comprise hemlock occurrence (binomial
outcome) on 17,743 forest stands across Michigan, USA. A set of
covariates were also observed at each stand and can be used to explain
the probability of hemlock occurrence. Covariates included minimum
winter temperature (MIN), maximum summer temperature (MAX), total
precipitation in the coldest quarter of the year (WIP), total
precipitation in the warmest quarter of the year (SUP), annual actual
evapotranspiration (AET) and annual climatic water deficit
(DEF). Spatial coordinates are recorded in 
Longitude (long) and latitude (lat) which are Albers Equal Area (proj4string
&quot;+proj=aea +lat_1=55 +lat_2=65 +lat_0=50 +lon_0=-154 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;). See
Lany et al. (2019) for details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MI_TSCA)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 17,743 rows and 9 columns. 
</p>


<h3>References</h3>

<p>Lany, N. K., Zarnetske, P. L., Finley, A. O. and McCullough, D. G. 2019. Complimentary strengths of spatially-explicit and multi-species distribution models. â€“ Ecography doi: 10.1111/ecog.04728
</p>

<hr>
<h2 id='PGLogit'>Function for Fitting Logistic Models using Polya-Gamma Latent Variables</h2><span id='topic+PGLogit'></span>

<h3>Description</h3>

<p>The function <code>PGLogit</code> fits logistic models to binomial data using Polya-Gamma latent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PGLogit(formula, weights = 1, data = parent.frame(), n.samples,
        n.omp.threads = 1, fit.rep = FALSE, sub.sample, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PGLogit_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="PGLogit_+3A_weights">weights</code></td>
<td>
<p>specifies the number of trials for each observation. The
default is 1 trial for each observation. Valid arguments are a
scalar value that specifies the number of trials used if all
observations have the same number of trials, and a vector of length <code class="reqn">n</code> that specifies the number of trials for
each observation when there are differences in the number of trials. </p>
</td></tr>
<tr><td><code id="PGLogit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>PGLogit</code> is called.  </p>
</td></tr>
<tr><td><code id="PGLogit_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect.</p>
</td></tr>
<tr><td><code id="PGLogit_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on all systems.</p>
</td></tr>
<tr><td><code id="PGLogit_+3A_fit.rep">fit.rep</code></td>
<td>
<p>if <code>TRUE</code>, regression fitted and replicate data will be
returned. The argument <code>sub.sample</code> controls which MCMC samples
are used to generate the fitted and replicated data. </p>
</td></tr>
<tr><td><code id="PGLogit_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples used
for <code>fit.rep</code>. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
      as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="PGLogit_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="PGLogit_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PGLogit</code> which is a list comprising:
</p>
<table>
<tr><td><code>p.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
the regression coefficients. </p>
</td></tr>
<tr><td><code>y.hat.samples</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, regression fitted values from posterior samples
specified using <code>sub.sample</code>. </p>
</td></tr>
<tr><td><code>y.hat.quants</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, 0.5, 0.025, and 0.975 quantiles of the <code>y.hat.samples</code>. </p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, replicated outcome from posterior samples
specified using <code>sub.sample</code>. </p>
</td></tr>
<tr><td><code>y.rep.quants</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, 0.5, 0.025, and 0.975
quantiles of the <code>y.rep.samples</code>. </p>
</td></tr>
<tr><td><code>s.indx</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, the subset index specified with <code>sub.sample</code>.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>MCMC sampler execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Note</h3>

<p>Some of the underlying code used for generating random number from the
Polya-Gamma distribution is taken from the <span class="pkg">pgdraw</span> package written
by Daniel F. Schmidt and Enes Makalic. Their code implements Algorithm
6 in PhD thesis of Jesse Bennett Windle (2013) <a href="https://repositories.lib.utexas.edu/handle/2152/21842">https://repositories.lib.utexas.edu/handle/2152/21842</a>.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Polson, N.G., J.G. Scott, and J. Windle. (2013) Bayesian Inference for
Logistic Models Using Polya-Gamma Latent Variables. Journal of the
American Statistical Association, 108:1339-1349.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Generate binary data
set.seed(1)
n &lt;- 100

x &lt;- cbind(1, rnorm(n), runif(n,0,1))
beta &lt;- c(0.1,-5, 5)
p &lt;- 1/(1+exp(-(x%*%beta)))

##Assume 5 trials per outcome
weights &lt;- rep(5, n)

y &lt;- rbinom(n, size=weights, prob=p)

m &lt;- PGLogit(y~x-1, weights = rep(5, n), n.samples = 1000)

summary(m)

</code></pre>

<hr>
<h2 id='predict.NNGP'>Function for prediction at new locations using <code>NNGP</code> models.</h2><span id='topic+predict.NNGP'></span>

<h3>Description</h3>

<p>The function <code>predict</code> collects posterior predictive samples
for a set of new locations given an object of
class <code>NNGP</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NNGP'
predict(object, X.0, coords.0, sub.sample,
        n.omp.threads = 1, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.NNGP_+3A_object">object</code></td>
<td>
<p>an object of class <code>NNGP</code>. </p>
</td></tr>
<tr><td><code id="predict.NNGP_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix for prediction locations. An
intercept should be provided in the first column if one is specified
in <code>sp.obj</code> model.</p>
</td></tr>
<tr><td><code id="predict.NNGP_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to
<code>X.0</code>. </p>
</td></tr>
<tr><td><code id="predict.NNGP_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples to included in
the composition sampling a non-Conjugate model. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
      as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and
<code>thin=1</code>.</p>
</td></tr>  
<tr><td><code id="predict.NNGP_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="predict.NNGP_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="predict.NNGP_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress. </p>
</td></tr>  
<tr><td><code id="predict.NNGP_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predict.NNGP</code> which is a list comprising:
</p>
<table>
<tr><td><code>p.y.0</code></td>
<td>
<p>a matrix that holds the response variable posterior
predictive samples where rows are locations corresponding to
<code>coords.0</code> and columns are samples. </p>
</td></tr>
<tr><td><code>p.w.0</code></td>
<td>
<p>a matrix that holds the random effect posterior
predictive samples where rows are locations corresponding to
<code>coords.0</code> and columns are samples. This is only returned if the
input class has <code>method = "latent".</code></p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time reported using <code>proc.time()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, doi: <a href="https://doi.org/10.1080/01621459.2015.1044091">10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Jurnal of Computational and Graphical
Statistics</em>, doi: <a href="https://doi.org/10.1080/10618600.2018.1537924">10.1080/10618600.2018.1537924</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

##Make some data
set.seed(1)
n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

x &lt;- cbind(1, rnorm(n))

B &lt;- as.matrix(c(1,5))

sigma.sq &lt;- 5
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

ho &lt;- sample(1:n, 50)

y.ho &lt;- y[ho]
x.ho &lt;- x[ho,,drop=FALSE]
w.ho &lt;- w[ho]
coords.ho &lt;- coords[ho,]

y &lt;- y[-ho]
x &lt;- x[-ho,,drop=FALSE]
w &lt;- w[-ho,,drop=FALSE]
coords &lt;- coords[-ho,]

##Fit a Response, Latent, and Conjugate NNGP model
n.samples &lt;- 500

starting &lt;- list("phi"=phi, "sigma.sq"=5, "tau.sq"=1)

tuning &lt;- list("phi"=0.5, "sigma.sq"=0.5, "tau.sq"=0.5)

priors &lt;- list("phi.Unif"=c(3/1, 3/0.01), "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 1))

cov.model &lt;- "exponential"

n.report &lt;- 500

##Latent
m.s &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="latent", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1, n.report=n.report)

p.s &lt;- predict(m.s, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

plot(apply(p.s$p.w.0, 1, mean), w.ho)
plot(apply(p.s$p.y.0, 1, mean), y.ho)

##Response
m.r &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="response", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1, n.report=n.report)

p.r &lt;- predict(m.r, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

points(apply(p.r$p.y.0, 1, mean), y.ho, pch=19, col="blue")

##Conjugate
theta.alpha &lt;- c(phi, tau.sq/sigma.sq)
names(theta.alpha) &lt;- c("phi", "alpha")

m.c &lt;- spConjNNGP(y~x-1, coords=coords, n.neighbors=10,
                  theta.alpha=theta.alpha, sigma.sq.IG=c(2, sigma.sq),
                  cov.model=cov.model, n.omp.threads=1)

p.c &lt;- predict(m.c, X.0 = x.ho, coords.0 = coords.ho, n.omp.threads=1)

points(p.c$y.0.hat, y.ho, pch=19, col="orange")

</code></pre>

<hr>
<h2 id='print.spDiag'>Methods for spDiag Object</h2><span id='topic+print.spDiag'></span>

<h3>Description</h3>

<p>Methods for extracting information from <code>spDiag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spDiag'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spDiag_+3A_x">x</code></td>
<td>
<p>object of class <code>spDiag</code>.</p>
</td></tr>
<tr><td><code id="print.spDiag_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A standard extractor function for printing objects of class <code>spDiag</code>. 
</p>

<hr>
<h2 id='spConjNNGP'>Function for Fitting Univariate Bayesian Conjugate Spatial
Regression Models</h2><span id='topic+spConjNNGP'></span>

<h3>Description</h3>

<p>The function <code>spConjNNGP</code> fits Gaussian univariate Bayesian conjugate spatial
regression models using Nearest Neighbor Gaussian Processes (NNGP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    spConjNNGP(formula, data = parent.frame(), coords, knots, n.neighbors = 15,
               theta.alpha, sigma.sq.IG, cov.model = "exponential",
               k.fold = 5, score.rule = "crps",
               X.0, coords.0, n.omp.threads = 1, search.type = "cb",
               ord, return.neighbor.info = TRUE, 
               neighbor.info, fit.rep = FALSE, n.samples, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spConjNNGP_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spConjNNGP</code> is called.  </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing), or if
<code>data</code> is a data frame then <code>coords</code> can be a vector of
length two comprising coordinate column names or indices. There can
be no duplicate locations. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_knots">knots</code></td>
<td>
<p>an <code class="reqn">r \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). Adding the
<code>knots</code> argument invokes SLGP, see Shin et al. (2019) below.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_theta.alpha">theta.alpha</code></td>
<td>
<p>a vector or matrix of parameter values for
<code>phi</code>, <code>nu</code>, and <code>alpha</code>, where
<code class="reqn">\alpha=\tau^2/\sigma^2</code> and <code>nu</code> is
only required if <code>cov.model="matern"</code>. A vector is passed to
run the model using one set of parameters. The vector elements must
be named and hold values for <code>phi</code>, <code>nu</code>, and
<code>alpha</code>. If a matrix is passed, columns must be named and hold
values for <code>phi</code>, <code>nu</code>, and <code>alpha</code>. Each row in the matrix defines a set of parameters for which the model will be run. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_sigma.sq.ig">sigma.sq.IG</code></td>
<td>
<p>a vector of length two that holds the
hyperparameters, <em>shape</em> and <em>scale</em> respectively, for the
inverse-Gamma prior on <code class="reqn">\sigma^2</code>. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_k.fold">k.fold</code></td>
<td>
<p>specifies the number of
<em>k</em> folds for cross-validation. If <code>theta.alpha</code> is a
vector then cross-validation is not performed and
<code>k-fold</code> and <code>score.rule</code> are ignored. In <em>k</em>-fold
cross-validation, the data specified in <code>model</code> is randomly
partitioned into <em>k</em> equal sized subsamples. Of the <em>k</em>
subsamples, <em>k</em>-1 subsamples are used to fit the model and the
remaining <em>k</em> samples are used for prediction. The
cross-validation process is repeated <em>k</em> times (the folds). Root
mean squared prediction error (RMSPE) and continuous ranked
probability score (CRPS; Gneiting and Raftery, 2007) rules are
averaged over the <em>k</em> fold prediction results and reported for
the parameter sets defined by <code>theta.alpha</code>. The parameter set
that yields the <em>best</em> performance based on the scoring rule
defined by <code>score.rule</code> is used to fit the final model that uses all
the data and make predictions if <code>X.0</code> and <code>coords.0</code> are
supplied.  Results from the <em>k</em>-fold cross-validation are returned in
the <code>k.fold.scores</code> matrix. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_score.rule">score.rule</code></td>
<td>
<p>a quoted keyword <code>"rmspe"</code> or <code>"crps"</code>
that specifies the scoring rule used to select the <em>best</em>
parameter set, see argument definition for <code>k.fold</code> for more
details.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_x.0">X.0</code></td>
<td>
<p>the design matrix for prediction locations. An
intercept should be provided in the first column if one is specified
in <code>model</code>.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to
<code>X.0</code>. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we recommend setting
<code>n.omp.threads</code> up to the number of hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering (see
<code>ord</code> argument) then <code>"cb"</code> and <code>"brute"</code> should
produce identical neighbor sets. However, if there are identical
coordinate values on the axis used for nearest neighbor ordering,
then <code>"cb"</code> and <code>"brute"</code> might produce different, but
equally valid, neighbor sets, e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_ord">ord</code></td>
<td>
<p>an index vector of length <code class="reqn">n</code> used for the nearest neighbor
search. Internally, this vector is used to order <code>coords</code>,
i.e., <code>coords[ord,]</code>, and associated data. Nearest neighbor
candidates for the <em>i</em>-th row in the ordered <code>coords</code> are
rows <code>1:(i-1)</code>, with the <code>n.neighbors</code> nearest neighbors being
those with the minimum euclidean distance to the location defined by
ordered <code>coords[i,]</code>. The default used when <code>ord</code> is not
specified is x-axis ordering, i.e.,
<code>order(coords[,1])</code>. This argument should typically be
left blank. This argument will be ignored if the <code>neighbor.info</code>
argument is used. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_return.neighbor.info">return.neighbor.info</code></td>
<td>
<p>if <code>TRUE</code>, a list called
<code>neighbor.info</code> containing several data structures used for
fitting the NNGP model is returned. If there is no change in input
data or <code>n.neighbors</code>, this list can be passed to subsequent
<code>spNNGP</code> calls via the <code>neighbor.info</code> argument to avoid
the neighbor search, which can be time consuming if <code class="reqn">n</code> is
large. In addition to the several cryptic data structures in
<code>neighbor.info</code> there is a list called <code>n.indx</code> that is of
length <code class="reqn">n</code>. The <em>i</em>-th element in <code>n.indx</code>
corresponds to the <em>i</em>-th row in <code>coords[ord,]</code> and holds
the vector of that location's nearest neighbor indices. This list can be useful for plotting the
neighbor graph if desired. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_neighbor.info">neighbor.info</code></td>
<td>
<p>see the <code>return.neighbor.info</code> argument
description above.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_fit.rep">fit.rep</code></td>
<td>
<p>if <code>TRUE</code>, regression fitted and replicate data will be
returned. The argument <code>n.samples</code> controls the number of
fitted and replicated data samples. </p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_n.samples">n.samples</code></td>
<td>
<p>gives the number of posterior samples
returned. Note, point and associated variance estimates for model
parameters are not based on posterior samples. Only specify
<code>n.samples</code> if you wish to generate samples from parameters'
posteriors (this is an exact sampling algorithm). If
<code>fit.rep</code> is <code>TRUE</code>, then <code>n.samples</code> also controls
the number of fitted and replicated data samples.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="spConjNNGP_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>NNGP</code> and <code>conjugate</code>, and, if <code>knots</code>
is provided, <code>SLGP</code>. Among other elements, the object contains:
</p>
<table>
<tr><td><code>theta.alpha</code></td>
<td>
<p>the input <code>theta.alpha</code> vector, or <em>best</em> (according to the selected scoring
rule) set of parameters in the <code>theta.alpha</code> matrix. All
subsequent parameter estimates are based on this parameter set.</p>
</td></tr>
<tr><td><code>beta.hat</code></td>
<td>
<p>a matrix of regression coefficient estimates
corresponding to the returned <code>theta.alpha</code>.</p>
</td></tr>
<tr><td><code>beta.var</code></td>
<td>
<p><code>beta.hat</code> variance-covariance matrix.</p>
</td></tr>
<tr><td><code>sigma.sq.hat</code></td>
<td>
<p>estimate of <code class="reqn">\sigma^2</code> corresponding to the returned <code>theta.alpha</code>.</p>
</td></tr>
<tr><td><code>sigma.sq.var</code></td>
<td>
<p><code>sigma.sq.hat</code> variance.</p>
</td></tr>
<tr><td><code>k.fold.scores</code></td>
<td>
<p>results from the k-fold cross-validation if
<code>theta.alpha</code> is a matrix.</p>
</td></tr>
<tr><td><code>y.0.hat</code></td>
<td>
<p>prediction if <code>X.0</code> and <code>coords.0</code> are
specified.</p>
</td></tr>
<tr><td><code>y.0.var.hat</code></td>
<td>
<p><code>y.0.hat</code> variance.</p>
</td></tr>
<tr><td><code>n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP.</p>
</td></tr>
<tr><td><code>neighbor.info</code></td>
<td>
<p>returned if <code>return.neighbor.info=TRUE</code> see the <code>return.neighbor.info</code> argument
description above.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time for parameter estimation reported using
<code>proc.time()</code>. This time does not include nearest neighbor
search time for building the neighbor set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, doi: <a href="https://doi.org/10.1080/01621459.2015.1044091">10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, S. Banerjee (2022) spNNGP R Package for
Nearest Neighbor Gaussian Process Models. <em>Journal of Statistical
Software</em>, doi: <a href="https://doi.org/10.18637/jss.v103.i05">10.18637/jss.v103.i05</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, doi: <a href="https://doi.org/10.1080/10618600.2018.1537924">10.1080/10618600.2018.1537924</a>.
</p>
<p>Gneiting, T and A.E. Raftery. (2007) Strictly proper scoring rules,
prediction, and estimation. <em>Journal of the American Statistical
Association</em>, doi: <a href="https://doi.org/10.1198/016214506000001437">10.1198/016214506000001437</a>.
</p>
<p>Shirota, S., A.O. Finley, B.D. Cook, and S. Banerjee (2019) Conjugate Nearest Neighbor Gaussian Process models for efficient statistical interpolation of large spatial data. <a href="https://arxiv.org/abs/1907.10109">https://arxiv.org/abs/1907.10109</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

##Make some data
set.seed(1)
n &lt;- 2000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

x &lt;- cbind(1, rnorm(n))

B &lt;- as.matrix(c(1,5))

sigma.sq &lt;- 5
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

ho &lt;- sample(1:n, 1000)

y.ho &lt;- y[ho]
x.ho &lt;- x[ho,,drop=FALSE]
w.ho &lt;- w[ho]
coords.ho &lt;- coords[ho,]

y &lt;- y[-ho]
x &lt;- x[-ho,,drop=FALSE]
w &lt;- w[-ho,,drop=FALSE]
coords &lt;- coords[-ho,]

##Fit a Conjugate NNGP model and predict for the holdout
sigma.sq.IG &lt;- c(2, sigma.sq)

cov.model &lt;- "exponential"

g &lt;- 10
theta.alpha &lt;- cbind(seq(phi,30,length.out=g), seq(tau.sq/sigma.sq,5,length.out=g))

colnames(theta.alpha) &lt;- c("phi", "alpha")

m.c &lt;- spConjNNGP(y~x-1, coords=coords, n.neighbors = 10,
                  X.0 = x.ho, coords.0 = coords.ho,
                  k.fold = 5, score.rule = "crps",
                  n.omp.threads = 1,
                  theta.alpha = theta.alpha, sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)

m.c


</code></pre>

<hr>
<h2 id='spDiag'>Model fit diagnostics</h2><span id='topic+spDiag'></span>

<h3>Description</h3>

<p>The function <code>spDiag</code> calculates measurements of model fit for
objects of class <code>NNGP</code> and <code>PGLogit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spDiag(object, sub.sample, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spDiag_+3A_object">object</code></td>
<td>
<p>an object of class <code>NNGP</code> or <code>PGLogit</code>.</p>
</td></tr>
<tr><td><code id="spDiag_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples to included in
the computations. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
    as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and
<code>thin=1</code>. If <code>sub.samples</code> is not specified, then it is
taken from <code>object</code>, or, if not aviable in <code>object</code> the
default values of <code>start</code>, <code>end</code>, and <code>thin</code> are
used. Note, if the <code>object</code> is a <code>NNGP</code> <code>response</code> model
and <code>n</code> is large, then computing the replicated data needed for
<code>GPD</code> and <code>GRS</code> can take a long time. </p>
</td></tr>
<tr><td><code id="spDiag_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following tags:
</p>
<table>
<tr><td><code>DIC</code></td>
<td>
<p>a data frame holding Deviance information criterion (DIC) and associated values. Values in <code>DIC</code> include
<code>DIC</code> the criterion (lower is better), <code>D</code> a goodness of fit, and <code>pD</code> the effective
number of parameters, see Spiegelhalter et al. (2002) for details. </p>
</td></tr>
<tr><td><code>GPD</code></td>
<td>
<p>a data frame holding D=G+P and associated values. Values in
<code>GPD</code> include <code>G</code> a goodness of fit, <code>P</code> a penalty term, and <code>D</code> the
criterion (lower is better), see Gelfand
and Ghosh (1998) for details. </p>
</td></tr>
<tr><td><code>GRS</code></td>
<td>
<p>a scoring rule, see Equation 27 in Gneiting and Raftery
(2007) for details.</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>a data frame hold Watanabe-Akaike information criteria (WAIC) and associated values. Values in
<code>WAIC</code> include <code>LPPD</code> log pointwise predictive density,
<code>P.1</code> penalty term defined in unnumbered equation above Equation
(11) in Gelman et al. (2014), <code>P.2</code> an alternative penalty
term defined in Equation (11), and the criteria <code>WAIC.1</code> and
<code>WAIC.2</code> (lower is better) computed using <code>P.1</code> and
<code>P.2</code>, respectively.</p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>if <code>y.rep.samples</code> in <code>object</code> were not
used (or not available), then the newly computed <code>y.rep.samples</code> is returned.</p>
</td></tr>
<tr><td><code>y.fit.samples</code></td>
<td>
<p>if <code>y.fit.samples</code> in <code>object</code> were not
used (or not available), then the newly computed <code>y.fit.samples</code> is returned.</p>
</td></tr>
<tr><td><code>s.indx</code></td>
<td>
<p>the index of samples used for the computations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., A. Datta, S. Banerjee (2022) spNNGP R Package for
Nearest Neighbor Gaussian Process Models. <em>Journal of Statistical
Software</em>, doi: <a href="https://doi.org/10.18637/jss.v103.i05">10.18637/jss.v103.i05</a>.
</p>
<p>Gelfand A.E. and Ghosh, S.K. (1998). Model choice: a minimum posterior
predictive loss approach. <em>Biometrika</em>, 85:1-11.
</p>
<p>Gelman, A., Hwang, J., and  Vehtari, A. (2014). Understanding predictive
information criteria for Bayesian models. <em>Statistics and
Computing</em>, 24:997-1016.
</p>
<p>Gneiting, T. and Raftery, A.E. (2007). Strictly proper scoring rules, prediction, and estimation.
<em>Journal of the American Statistical Association</em>, 102:359-378.
</p>
<p>Spiegelhalter, D.J., Best, N.G., Carlin, B.P., van der Linde, A. (2002). Bayesian measures of model complexity and fit (with discussion). <em>Journal of the Royal Statistical Society, Series B.</em>, 64:583-639.
</p>

<hr>
<h2 id='spNNGP'>Function for Fitting Univariate Bayesian Spatial Regression
Models</h2><span id='topic+spNNGP'></span>

<h3>Description</h3>

<p>The function <code>spNNGP</code> fits Gaussian and non-Gaussian univariate Bayesian spatial
regression models using Nearest Neighbor Gaussian Processes (NNGP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spNNGP(formula, data = parent.frame(), coords, method = "response",
      family="gaussian", weights, n.neighbors = 15, 
      starting, tuning, priors, cov.model = "exponential",
      n.samples, n.omp.threads = 1, search.type = "cb", ord,
      return.neighbor.info = FALSE, neighbor.info,
      fit.rep = FALSE, sub.sample, verbose = TRUE, n.report = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spNNGP_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spNNGP</code> is called.  </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing), or if
<code>data</code> is a data frame then <code>coords</code> can be a vector of
length two comprising coordinate column names or indices. There can
be no duplicate locations. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_method">method</code></td>
<td>
<p>a quoted keyword that specifies the NNGP sampling
algorithm. Supported method keywords are: <code>"response"</code> and
<code>"latent"</code>. When <code class="reqn">n</code> is large, the <code>"response"</code>
algorithm should be faster and provide finer control over Metropolis
acceptance rate for covariance parameters. In general,
unless estimates of spatial random effects are needed, the
<code>"response"</code> algorithm should be used. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_family">family</code></td>
<td>
<p>a quoted keyword that specifies the data
likelihood. Choices are &quot;gaussian&quot; for continuous outcome and
&quot;binomial&quot; for discrete outcome which assumes a logistic link modeled
using Polya-Gamma latent variables. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_weights">weights</code></td>
<td>
<p>specifies the number of trials for each observation when
<code>family="binomial"</code>. The default is 1 trial for each
observation. Valid arguments are a scalar value that specifies the number
of trials used if all observations have the same number of trials, and a
vector of length <code class="reqn">n</code> that specifies the number of trials for
each observation used there are differences in the number of trials. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>. <code>nu</code> is only
specified if <code>cov.model="matern"</code>. The value portion of each
tag is the parameter's startingvalue. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a parameter
name. Valid tags are <code>sigma.sq</code>, <code>tau.sq</code>, <code>phi</code>, and
<code>nu</code>. If <code>method="latent"</code> then only <code>phi</code> and
<code>nu</code> need to be specified. The value portion of each tag defines
the variance of the Metropolis sampler Normal proposal distribution. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>,
<code>tau.sq.ig</code>, <code>phi.unif</code>, and <code>nu.unif</code>. Variance parameters, <code>simga.sq</code> and
<code>tau.sq</code>, are assumed to follow an
inverse-Gamma distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Gamma are
passed as a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first
and second elements corresponding to the lower and upper support,
respectively.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. Note, <code>n.omp.threads</code> &gt; 1 might not
work on some systems.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_fit.rep">fit.rep</code></td>
<td>
<p>if <code>TRUE</code>, regression fitted and replicate data will be
returned. The argument <code>sub.sample</code> controls which MCMC samples
are used to generate the fitted and replicated data. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples used
for <code>fit.rep</code>. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
      as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="spNNGP_+3A_search.type">search.type</code></td>
<td>
<p>a quoted keyword that specifies type of nearest
neighbor search algorithm. Supported method key words are: <code>"cb"</code> and
<code>"brute"</code>. The <code>"cb"</code> should generally be much
faster. If locations do not have identical coordinate values on
the axis used for the nearest neighbor ordering (see
<code>ord</code> argument) then <code>"cb"</code> and <code>"brute"</code> should
produce identical neighbor sets. However, if there are identical
coordinate values on the axis used for nearest neighbor ordering,
then <code>"cb"</code> and <code>"brute"</code> might produce different, but
equally valid, neighbor sets, e.g., if data are on a grid. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_ord">ord</code></td>
<td>
<p>an index vector of length <code class="reqn">n</code> used for the nearest neighbor
search. Internally, this vector is used to order <code>coords</code>,
i.e., <code>coords[ord,]</code>, and associated data. Nearest neighbor
candidates for the <em>i</em>-th row in the ordered <code>coords</code> are
rows <code>1:(i-1)</code>, with the <code>n.neighbors</code> nearest neighbors being
those with the minimum euclidean distance to the location defined by
ordered <code>coords[i,]</code>. The default used when <code>ord</code> is not
specified is x-axis ordering, i.e.,
<code>order(coords[,1])</code>. This argument should typically be left
blank. This argument will be ignored if the <code>neighbor.info</code>
argument is used. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_return.neighbor.info">return.neighbor.info</code></td>
<td>
<p>if <code>TRUE</code>, a list called
<code>neighbor.info</code> containing several data structures used for
fitting the NNGP model is returned. If there is no change in input
data or <code>n.neighbors</code>, this list can be passed to subsequent <code>spNNGP</code> calls via the <code>neighbor.info</code> argument to avoid
the neighbor search, which can be time consuming if <code class="reqn">n</code> is
large. In addition to the several cryptic data structures in
<code>neighbor.info</code> there is a list called <code>n.indx</code> that is of
length <code class="reqn">n</code>. The <em>i</em>-th element in <code>n.indx</code>
corresponds to the <em>i</em>-th row in <code>coords[ord,]</code> and holds
the vector of that location's nearest neighbor indices. This list can be useful for plotting the
neighbor graph if desired. </p>
</td></tr>
<tr><td><code id="spNNGP_+3A_neighbor.info">neighbor.info</code></td>
<td>
<p>see the <code>return.neighbor.info</code> argument
description above.</p>
</td></tr>    
<tr><td><code id="spNNGP_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance
and MCMC progress.</p>
</td></tr>  
<tr><td><code id="spNNGP_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>
<p>The <em>no nugget</em> model is specified by setting <code>tau.sq</code> to zero
in the <code>starting</code> and <code>tuning</code> lists.
</p>


<h3>Value</h3>

<p>An object of class <code>NNGP</code> with additional class designations for
<code>method</code> and <code>family</code>. The return object is a list comprising:
</p>
<table>
<tr><td><code>p.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
the regression coefficients. </p>
</td></tr>
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
covariance parameters. </p>
</td></tr>
<tr><td><code>p.w.samples</code></td>
<td>
<p>is a matrix of posterior samples for the spatial
random effects, where rows correspond to locations in <code>coords</code> and columns hold the <code>n.samples</code> posterior samples. This is only returned if <code>method="latent"</code>.</p>
</td></tr>
<tr><td><code>y.hat.samples</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, regression fitted values from posterior samples
specified using <code>sub.sample</code>. See additional details below. </p>
</td></tr>
<tr><td><code>y.hat.quants</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, 0.5, 0.025, and 0.975 quantiles of the <code>y.hat.samples</code>. </p>
</td></tr>
<tr><td><code>y.rep.samples</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, replicated outcome from posterior samples
specified using <code>sub.sample</code>. See additional details below. </p>
</td></tr>
<tr><td><code>y.rep.quants</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, 0.5, 0.025, and 0.975
quantiles of the <code>y.rep.samples</code>. </p>
</td></tr>
<tr><td><code>s.indx</code></td>
<td>
<p>if <code>fit.rep=TRUE</code>, the subset index specified with <code>sub.sample</code>.</p>
</td></tr>
<tr><td><code>neighbor.info</code></td>
<td>
<p>returned if <code>return.neighbor.info=TRUE</code> see the <code>return.neighbor.info</code> argument
description above.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>execution time for parameter estimation reported using
<code>proc.time()</code>. This time does not include nearest neighbor
search time for building the neighbor set.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., A. Datta, S. Banerjee (2022) spNNGP R Package for
Nearest Neighbor Gaussian Process Models. <em>Journal of Statistical
Software</em>, doi: <a href="https://doi.org/10.18637/jss.v103.i05">10.18637/jss.v103.i05</a>.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. <em>Journal of the American Statistical
Association</em>, doi: <a href="https://doi.org/10.1080/01621459.2015.1044091">10.1080/01621459.2015.1044091</a>.
</p>
<p>Finley, A.O., A. Datta, B.D. Cook, D.C. Morton, H.E. Andersen, and
S. Banerjee. (2019) Efficient algorithms for Bayesian Nearest Neighbor
Gaussian Processes. <em>Journal of Computational and Graphical
Statistics</em>, doi: <a href="https://doi.org/10.1080/10618600.2018.1537924">10.1080/10618600.2018.1537924</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

##Make some data
set.seed(1)
n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

x &lt;- cbind(1, rnorm(n))

B &lt;- as.matrix(c(1,5))

sigma.sq &lt;- 5
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

##Fit a Response and Latent NNGP model
n.samples &lt;- 500

starting &lt;- list("phi"=phi, "sigma.sq"=5, "tau.sq"=1)

tuning &lt;- list("phi"=0.5, "sigma.sq"=0.5, "tau.sq"=0.5)

priors &lt;- list("phi.Unif"=c(3/1, 3/0.01), "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 1))

cov.model &lt;- "exponential"

m.s &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="latent", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1)

summary(m.s)
plot(apply(m.s$p.w.samples, 1, median), w)

m.r &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="response", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              n.samples=n.samples, n.omp.threads=1)

summary(m.r)

##Fit with some user defined neighbor ordering

##ord &lt;- order(coords[,2]) ##y-axis 
ord &lt;- order(coords[,1]+coords[,2]) ##x+y-axis
##ord &lt;- sample(1:n, n) ##random

m.r.xy &lt;- spNNGP(y~x-1, coords=coords, starting=starting, method="response", n.neighbors=10,
              tuning=tuning, priors=priors, cov.model=cov.model,
              ord=ord, return.neighbor.info=TRUE,
              n.samples=n.samples, n.omp.threads=1)

summary(m.r.xy)

## Not run: 
##Visualize the neighbor sets and ordering constraint
n.indx &lt;- m.r.xy$neighbor.info$n.indx
ord &lt;- m.r.xy$neighbor.info$ord

##This is how the data are ordered internally for model fitting
coords.ord &lt;- coords[ord,]

for(i in 1:n){

    plot(coords.ord, cex=1, xlab="Easting", ylab="Northing")
    points(coords.ord[i,,drop=FALSE], col="blue", pch=19, cex=1)
    points(coords.ord[n.indx[[i]],,drop=FALSE], col="red", pch=19, cex=1)

    readline(prompt = "Pause. Press &lt;Enter&gt; to continue...")
}

## End(Not run)


</code></pre>

<hr>
<h2 id='summary.NNGP'>Methods for NNGP and Derived Objects</h2><span id='topic+summary.NNGP'></span><span id='topic+fitted.NNGP'></span><span id='topic+residuals.NNGP'></span><span id='topic+print.NNGP'></span><span id='topic+print.predict.NNGP'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted NNGP model of class
<code>NNGP</code> and <code>predict.NNGP</code> objects from <code>predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NNGP'
summary(object, sub.sample, quantiles = c(0.025, 0.25,
0.5, 0.75, 0.975), digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'NNGP'
print(x, ...)
## S3 method for class 'predict.NNGP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NNGP_+3A_object">object</code>, <code id="summary.NNGP_+3A_x">x</code></td>
<td>
<p>object of class <code>NNGP</code> or <code>predict.NNGP</code>.</p>
</td></tr>
<tr><td><code id="summary.NNGP_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples to included in
the summary or composition sampling. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
      as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="summary.NNGP_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.NNGP_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report in summary.</p>
</td></tr>
<tr><td><code id="summary.NNGP_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>NNGP</code> and prediction object of class <code>predict.NNGP</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>. 
</p>

<hr>
<h2 id='summary.PGLogit'>Methods for PGLogit Object</h2><span id='topic+summary.PGLogit'></span><span id='topic+fitted.PGLogit'></span><span id='topic+residuals.PGLogit'></span><span id='topic+print.PGLogit'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted <code>PGLogit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PGLogit'
summary(object, sub.sample, quantiles
=c(0.025, 0.25, 0.5, 0.75, 0.975), digits = max(3L, getOption("digits")
- 3L), ...)
## S3 method for class 'PGLogit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PGLogit_+3A_object">object</code>, <code id="summary.PGLogit_+3A_x">x</code></td>
<td>
<p>object of class <code>PGLogit</code>.</p>
</td></tr>
<tr><td><code id="summary.PGLogit_+3A_sub.sample">sub.sample</code></td>
<td>
<p>an optional list that specifies the samples to included in
the summary or composition sampling. Valid tags are <code>start</code>,
<code>end</code>, and <code>thin</code>. Given the value associated with the tags,
the sample subset is selected using <code>seq(as.integer(start),
    as.integer(end), by=as.integer(thin))</code>. The default values are
<code>start=floor(0.5*n.samples)</code>, <code>end=n.samples</code> and <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="summary.PGLogit_+3A_quantiles">quantiles</code></td>
<td>
<p>for <code>summary</code>, posterior distribution quantiles to compute.</p>
</td></tr>
<tr><td><code id="summary.PGLogit_+3A_digits">digits</code></td>
<td>
<p>for <code>summary</code>, number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.PGLogit_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects of
class <code>PGLogit</code>, including methods to the generic functions <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>. 
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
